<html>
<head>
<title>Logistic Regression For Facial Recognition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于面部识别的逻辑回归</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/logistic-regression-for-facial-recognition-ab051acf6e4?source=collection_archive---------14-----------------------#2018-12-19">https://towardsdatascience.com/logistic-regression-for-facial-recognition-ab051acf6e4?source=collection_archive---------14-----------------------#2018-12-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3e52" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用 sklearn 的混淆矩阵和 ROC-AUC 曲线</h2></div><h1 id="c86f" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated"><strong class="ak">**注意* *:此帖子不再是最新的，可能包含错误。它是为了透明而保留的。更新版本可以在这里找到</strong><a class="ae kx" href="https://medium.com/@AudreyLorberfeld/the-learning-process-logistic-regression-for-facial-recognition-take-2-6a1fef4ebe21" rel="noopener"><strong class="ak"/></a><strong class="ak">。</strong></h1></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="dbdb" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">面部识别算法一直令我着迷，为了在一些数据上展示我新发现的逻辑回归技能，我基于一个名为“皮肤分割”的数据集创建了一个模型。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/901b4abae4b0a46d802ae690c88f7a5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/0*eSVDq1BiQcUGaqsg"/></div></figure><p id="cd03" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">正如其<a class="ae kx" href="https://archive.ics.uci.edu/ml/datasets/Skin+Segmentation" rel="noopener ugc nofollow" target="_blank">描述</a>中所指出的，皮肤分割中的数据是“通过从各种年龄组(青年、中年和老年)、种族组(白人、黑人和亚洲人)以及从<a class="ae kx" href="https://www.nist.gov/itl/iad/image-group/color-feret-database" rel="noopener ugc nofollow" target="_blank"> FERET </a>数据库和 PAL 数据库获得的性别的面部图像中随机采样 B、G、R 值来收集的。”数据集具有 245，057 行和 4 列(B、G、R 和指示图像被分类为包含皮肤还是不包含皮肤的二进制列)。后者，二元列使这个数据集适合逻辑回归。</p><p id="5c52" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">(如果你想阅读使用该数据集的两篇(付费)学术文章，请参见此处的<a class="ae kx" href="https://ieeexplore.ieee.org/abstract/document/5409447" rel="noopener ugc nofollow" target="_blank">和此处的</a>和<a class="ae kx" href="https://link.springer.com/chapter/10.1007/978-3-642-10520-3_69" rel="noopener ugc nofollow" target="_blank"/>。)</p><h1 id="f3a5" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">回归</h1><p id="e8e2" class="pw-post-body-paragraph lf lg iq lh b li mj jr lk ll mk ju ln lo ml lq lr ls mm lu lv lw mn ly lz ma ij bi translated">我的专长是 Python，我特别想测试一下<a class="ae kx" href="https://scikit-learn.org/stable/index.html" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>库，因为它是回归等科学任务的行业标准。我还选择使用 Juypter Notebook 作为我的 IDE，而不是 Atom 这样的文本编辑器，因为它的入门门槛较低；凭借其叙事结构，Jupyter 让大多数人都能感受到代码是如何工作的。</p><p id="74a3" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">要自己运行这段代码，您需要在您的机器上/虚拟环境中安装/导入 Python 3、scikit-learn、Pandas、NumPy、matplotlib、Seaborn、Itertools 和 imb learn(requirements . txt 文件即将发布！).</p><p id="8be2" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">你可以在这里找到这个项目<a class="ae kx" href="https://github.com/aulorbe/skin-noskin" rel="noopener ugc nofollow" target="_blank">的回购。在那里，你可以找到一个深入的 Jupyter 笔记本，概述了这篇文章中总结的所有步骤。</a></p><h2 id="9eb1" class="mo kg iq bd kh mp mq dn kl mr ms dp kp lo mt mu kr ls mv mw kt lw mx my kv mz bi translated">芒格</h2><p id="ecc8" class="pw-post-body-paragraph lf lg iq lh b li mj jr lk ll mk ju ln lo ml lq lr ls mm lu lv lw mn ly lz ma ij bi translated">我必须对这个数据集进行的数据管理相当简单。在通过 URL 读入文本文件并保存到 Pandas dataframe 后，您可以看到它唯一真正的问题是缺少列标题。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi na"><img src="../Images/97c6ca1395ed9e6338137dac1651afc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:354/format:webp/1*-OfBtPpniJuZSn0zO7BU2g.png"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Original dataframe</figcaption></figure><p id="c0a8" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在将第一行下推到数据框中并重命名列标题后，我能够得到这样的结果:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/1bbc95b86917e36205bedb636edb63b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/1*ySK4L2Ksj29K3GWciBJksw.png"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Munged dataframe</figcaption></figure><p id="909d" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在这个数据集中，1 表示没有皮肤的像素，2 表示有皮肤的像素。</p><p id="c8de" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">正如您所预料的，1 和 2 确实很有帮助，但是我们真的希望 1 和 0 用于逻辑回归。所以，我为皮肤或无皮肤专栏制作了假人。(我还将数据类型强制为 int64，以便与数据帧中的其他列保持一致。)</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/3089bb9e75c9bb159c7a7e314e810b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*L8ZX6WIKaKbG2p1yMwkPmg.png"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Making dummies and coercing datatype.</figcaption></figure><p id="1f61" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">正如你所看到的，我把这个皮肤或者无皮肤列变成了我的 y 变量(我的因变量)。其他列我变成了一个矩阵(X)。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/977e03f54231e11e094e0b387d020819.png" data-original-src="https://miro.medium.com/v2/resize:fit:318/format:webp/1*fwUKYKsGQgmfysdkWt_j_g.png"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">X matrix</figcaption></figure><p id="206a" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在我的 X 矩阵中，我还想让我的所有变量都在同一标度上，所以我让它们通过一个最小-最大归一化器，并让它们都在 0-1 标度上。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ni"><img src="../Images/8cc1de084f496818b85cf303c83243cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*jmjEd2eKdLeD7sTBAV4C3w.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Normalizing X values</figcaption></figure><h2 id="81de" class="mo kg iq bd kh mp mq dn kl mr ms dp kp lo mt mu kr ls mv mw kt lw mx my kv mz bi translated">训练-测试-分割和建立模型</h2><p id="1a35" class="pw-post-body-paragraph lf lg iq lh b li mj jr lk ll mk ju ln lo ml lq lr ls mm lu lv lw mn ly lz ma ij bi translated">在使我的数据进入可工作状态后，我使用 sklearn 将它分成测试集和训练集。我还创建了我的模型，使其适合我的训练数据，然后在我的训练和测试数据上运行我的模型，以查看它的性能如何。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nn"><img src="../Images/1250fdf2391b645f6592bbb7772f269f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jMQ88pkgQLCFd0fwcEq10Q.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Train-test-split</figcaption></figure><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi no"><img src="../Images/f7cd68cd2bacda77ac63ef7761ffb52a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*xDUVs89NwgoazZLvu_I27g.png"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Creating and fitting my model</figcaption></figure><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi np"><img src="../Images/838d5fbc0db8e142db513116fe86a326.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*3G881NuNIX2dzS2DOYuq7w.png"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Running the model on my training and test data</figcaption></figure><h2 id="2904" class="mo kg iq bd kh mp mq dn kl mr ms dp kp lo mt mu kr ls mv mw kt lw mx my kv mz bi translated">评估性能，第 1 部分:简单的读数</h2><p id="5302" class="pw-post-body-paragraph lf lg iq lh b li mj jr lk ll mk ju ln lo ml lq lr ls mm lu lv lw mn ly lz ma ij bi translated">我查看了我的预测值(y_hat_train 和 y_hat_test)与我的原始 y_train 和 y_test 值之间的差异，以评估我的模型的准确性。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nq"><img src="../Images/bf25f39503ea0a2e99fb859c07301297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_0qz9bWochJCUkCZs9AI6A.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Evaluating initial performance</figcaption></figure><p id="1a63" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在读数中，与真实值相比，0 的数量是正确预测的数量，1 的数量是错误预测的数量。normalize = True 只是将读数的第一部分从预测数转换为百分比。</p><p id="a1b9" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">您可以看到，根据我们的训练数据，我们的模型在 90.7%的时间内是准确的，而根据我们的测试数据，它在 90.6%的时间内是准确的。相当不错！</p><h2 id="caf6" class="mo kg iq bd kh mp mq dn kl mr ms dp kp lo mt mu kr ls mv mw kt lw mx my kv mz bi translated">评估性能，第 2 部分:混淆矩阵</h2><p id="9b37" class="pw-post-body-paragraph lf lg iq lh b li mj jr lk ll mk ju ln lo ml lq lr ls mm lu lv lw mn ly lz ma ij bi translated">我还想看看我的模型在混淆矩阵方面表现如何。(关于混淆矩阵的精彩阅读，见<a class="ae kx" rel="noopener" target="_blank" href="/understanding-confusion-matrix-a9ad42dcfd62">这里</a>。)</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nr"><img src="../Images/c3bc30d2c650defa85af6588902b1292.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J_JqSo2CgbA7PW-KFJYCUQ.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Confusion matrix for initial model</figcaption></figure><p id="33d4" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">正如你在评论中看到的，这里 0 是被分类为没有皮肤的像素，1 是被分类为有皮肤的像素。</p><p id="a406" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了让我的混淆矩阵的值更容易理解，我运行了一个分类报告，以获得一些常见的指标，如精确度、召回率和 f1 分数。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ns"><img src="../Images/4bbab471bb614fead7bf9985fc414723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*DSYz6GiLFyAes4LWQKgxsQ.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Classification Report from sklearn.metrics</figcaption></figure><p id="5d8a" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">您可以在这里看到，我们的模型的准确率为 96%，召回率为 92%，f1 值为 94%。我还想知道我的准确率，所以我简单地手动计算了一下，得到了 91%(与我们在上面的简单读数部分的测试数据中得到的数字相同)。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nt"><img src="../Images/ed19bd22a24586f452f05c7eab3fe3f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vBWTqyglC3Um_1E61UkkjQ.png"/></div></div></figure><p id="2b4d" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了更好地展示每个分数的含义，请参见下图。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/3d2608ab821f23d73faf531d67c79cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*hz3_VbUn62HSy2Fza6lubg.png"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Recall and precision mapped onto a confusion matrix</figcaption></figure><h2 id="5298" class="mo kg iq bd kh mp mq dn kl mr ms dp kp lo mt mu kr ls mv mw kt lw mx my kv mz bi translated">评估绩效，第 3 部分:ROC-AUC 曲线</h2><p id="80f6" class="pw-post-body-paragraph lf lg iq lh b li mj jr lk ll mk ju ln lo ml lq lr ls mm lu lv lw mn ly lz ma ij bi translated">ROC-AUC 曲线是一个有用的指标，因为它们衡量的是真阳性率和假阳性率。</p><p id="c911" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我为我的训练和测试数据生成了 ROC-AUC 曲线，但是它们看起来基本相同，所以我在这里只显示训练图像。(训练数据的 AUC 为 93.4%，而测试数据的 AUC 为 93.2%。)</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nv"><img src="../Images/f97c71f28ebaf0146ea5239d014a86cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L_7WBID88qmuYF480WJizg.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Creating my ROC curve</figcaption></figure><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nw"><img src="../Images/dfce461084a07ae313a473a66f0d243a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xLSG7qmEN1Zsd6h85wy_nw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">ROC-AUC curve for testing data.</figcaption></figure><p id="7dc9" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">更多关于 ROC-AUC 曲线及其目的可以在<a class="ae kx" href="https://www.theanalysisfactor.com/what-is-an-roc-curve/" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae kx" rel="noopener" target="_blank" href="/understanding-auc-roc-curve-68b2303cc9c5">这里</a>找到。</p><p id="0092" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如你所见，我们的 ROC 曲线紧挨着图表的左上角，这正是我们想要的。</p><h2 id="c841" class="mo kg iq bd kh mp mq dn kl mr ms dp kp lo mt mu kr ls mv mw kt lw mx my kv mz bi translated">倒回一点:ROC-AUC 曲线和类别不平衡</h2><p id="3fb7" class="pw-post-body-paragraph lf lg iq lh b li mj jr lk ll mk ju ln lo ml lq lr ls mm lu lv lw mn ly lz ma ij bi translated">ROC-AUC 曲线最有用的一点是，即使原始数据集中存在类别不平衡，它们也允许我们评估模型。</p><p id="5931" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">类别不平衡是指在您的数据中，一种类别明显多于另一种类别。这有能力真正搞乱你的分析。举个例子，一个罕见疾病的数据集是有偏差的(即存在类别不平衡问题)。我们假设 1000 个案例中只有 2 个是阳性的。即使你做了一个蹩脚的模型，把一切都归类为负面，你仍然会达到 99.8%的准确率(即 998 / 1000 的分类是正确的)。因此，当模型在不平衡的数据集上运行时，您需要更多的上下文来真正评估您的模型。</p><p id="1610" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">所以，让我们倒回去一点，看看我们的数据是否不平衡。也许我们可以让我们的模型变得更好。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/bdff4110d30f3e804084b33038d95845.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*4znjWbnjgIuehpiQ1XgHqA.png"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Class balance for original data</figcaption></figure><p id="31b0" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以看到，我们的数据有点奇怪——大约 79%被归类为 1(即包含皮肤的像素)，只有大约 21%被归类为 0(即不包含皮肤的像素)。</p><p id="73a3" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">所以，在我们今天结束之前，让我们运行一个叫做 SMOTE(合成少数过采样)的东西。SMOTE 创建合成数据来为我们的少数类填充更多的值(在我们的例子中，这意味着它将为我们提供更多的 0 数据点)。尽管创建合成数据看起来像是作弊，但这在数据科学世界中是非常常见的做法，因为数据集通常并不均衡。</p><p id="086a" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对我们的原始数据运行 SMOTE 并重新生成我们的混淆矩阵和分类报告，我们得到以下结果。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/0eb3b6890bb5bd7f729230ba67614a5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*paW1ypCGCiZHiIN46fa5Sg.png"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">SMOTE confusion matrix</figcaption></figure><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/41c02ac60fede458bdf9544a4d165298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*xflIWdHyQ49Z2ZO-ZzQ7Ow.png"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Classification Report for SMOTE-ized data, showing both training and test readouts</figcaption></figure><p id="61fb" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以看到这些数字与我们最初的数字有很大的不同。回想一下，第一次我们的准确率为 96%，召回率为 92%，f1 得分为 94%。通过 SMOTE 运行我们的数据后，我们的准确率为 85%，召回率为 92%，f1 得分为 89%。<strong class="lh ir">所以，我们的模型在试图补偿阶级不平衡后实际上变得<em class="oa">更差</em>。</strong></p><p id="a042" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">作为数据科学家，何时对我们的数据运行 SMOTE 之类的操作，或者让我们的数据保持原样，这取决于我们。在这种情况下，我们可以看到，让我们的数据保持原样是正确的做法。</p><h1 id="a986" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">那么，这一切意味着什么呢？</h1><p id="a70e" class="pw-post-body-paragraph lf lg iq lh b li mj jr lk ll mk ju ln lo ml lq lr ls mm lu lv lw mn ly lz ma ij bi translated">除了是一个很好的学习机会，我们真的创造了一个很好的模式。我们知道，在这种情况下，对我们的数据做其他事情，例如试图补偿阶级不平衡，肯定不是我们应该做的。我们的原始模型是我们表现最好的，在 94%的时间里正确预测了有皮肤的图像(使用我们的 f1 分数)。</p><p id="192b" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">虽然这听起来可能是一个不错的分类率，但创建用于面部识别的算法会带来无数的伦理问题。如果我们的模型被用来在人群中识别被通缉的恐怖分子呢？这当然不同于在 Snapchat 中为滤镜识别人脸。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ob"><img src="../Images/cffb26525bced7a07a0d28f92c66934f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ierhLVXSt2m-YfEE"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">From <a class="ae kx" href="https://medium.com/@AWChristoph" rel="noopener">Christoph Auer-Welsbach</a>’s post “<a class="ae kx" href="https://medium.com/cityai/the-ethics-of-ai-building-technology-that-benefits-people-and-society-ea6b10c5ff3" rel="noopener">The Ethics of AI: Building technology that benefits people and society</a>”</figcaption></figure><p id="080c" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这是我们作为数据科学家在创建算法时需要尽可能多的信息的地方。如果我们的模型用于 Snapchat 过滤器，我们可能会希望优化以提高我们的回忆分数——表面上看，当事物不是人脸时，我们错误地将它们识别为人脸比有时只识别真实人脸要好。</p><p id="132f" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">另一方面，如果我们的模型用于在人群中发现通缉犯，我们可能仍然希望优化回忆，但结果将会大不相同。如果这意味着你几乎 100%的时间都能抓到被通缉的罪犯，那么把无辜的人带进来审问并潜在地侵犯他们的权利值得吗？或许不会。</p><p id="48dd" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当我们在人工智能的世界里玩耍时，我们需要仔细思考这些问题。正如凯茜·奥尼尔在<em class="oa">数学毁灭武器</em>中所写的，构建算法需要“道德想象力，而这只有人类才能提供。”</p></div></div>    
</body>
</html>