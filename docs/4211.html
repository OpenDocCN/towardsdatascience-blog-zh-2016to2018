<html>
<head>
<title>The Perceptron</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">感知器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-perceptron-3af34c84838c?source=collection_archive---------7-----------------------#2018-07-29">https://towardsdatascience.com/the-perceptron-3af34c84838c?source=collection_archive---------7-----------------------#2018-07-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/04cd54309a771f7d7794c596e589cc5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gjFY9fBnQfTF0SHJixsCVQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><strong class="bd kc">Fig 1: Chicken or Egg? | Perceptron!</strong></figcaption></figure><p id="159b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感知器最早是由<a class="ae lb" href="https://en.wikipedia.org/wiki/Frank_Rosenblatt" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="lc">弗兰克·罗森布拉特</em> </strong> </a>提出的。在这篇文章中，我们将看看什么是感知器，以及它如何根据给定的输入进行预测。所以，让我们开始吧！</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><p id="b260" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">感知器是一个单层神经网络</strong>，看起来像这样</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lk"><img src="../Images/d0ee00b2066e79a209ae7574a6cc73d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7pwA1DjBw6JDkwZQecUNiw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><strong class="bd kc">Fig 2: Perceptron</strong></figcaption></figure><p id="6901" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们看看这些节点和连接的含义。</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/74f10e615e26b3df11293d02153cf3b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*YVO2ubm82slqc7Mzp-JrIQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><strong class="bd kc">Fig 3: Input Node</strong></figcaption></figure><p id="8e00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">蓝色节点是<strong class="kf ir"> <em class="lc">输入节点。</em> </strong>每个这样的节点代表一个输入问题的特征。在上面的例子中，我们有<code class="fe lq lr ls lt b">m</code>输入特征。第 I 个输入特征由<code class="fe lq lr ls lt b">x_{i}</code>表示。这一层叫做<strong class="kf ir"> <em class="lc">输入层</em> </strong>。在神经网络中，我们只能有实数作为输入。</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/ccf40230d470c48162f8343c3ac28717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*nBVQpjkTrWq4poemZaar5Q.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><strong class="bd kc">Fig 4: Weights</strong></figcaption></figure><p id="4b52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，红色箭头将输入节点连接到橙色节点。这些被称为突触。这些突触中的每一个都有一个权重，用<code class="fe lq lr ls lt b">w_{i}</code>表示，即第 I 个突触的权重为<strong class="kf ir"><em class="lc"/></strong><code class="fe lq lr ls lt b">w_{i}</code>。我们可以简单地称之为<strong class="kf ir"> <em class="lc">权重层</em> </strong>。</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/9d4d0db3be08a661f5e22dd2ca4b7b67.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*VD3wMrfDcYrNYqpFPGQnNA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><strong class="bd kc">Fig 5: Output node</strong></figcaption></figure><p id="ae58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们有橙色节点，上面写着<code class="fe lq lr ls lt b">y</code>。是<strong class="kf ir"> <em class="lc">输出节点</em> </strong>。它基于<em class="lc">输入</em>和<em class="lc">权重</em>计算<em class="lc">分数</em>，然后基于该分数使用<em class="lc">激活函数</em>获得<em class="lc">对<code class="fe lq lr ls lt b">0</code>或<code class="fe lq lr ls lt b">1</code>的预测</em>。</p><p id="d85b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是感知器所做的一切！</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><p id="22dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们看看分数是如何精确计算的，以及如何根据输入和权重在输出单元中进行预测。</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lw"><img src="../Images/01575b156068643448b5b4c4f5436c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LNlhvTpmMmmSjvAMfyDqLg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><strong class="bd kc">Fig 6: Formula to make a prediction from the Inputs and <em class="lx">Weights</em></strong></figcaption></figure><p id="b768" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">等式的红色部分简单地越过<code class="fe lq lr ls lt b">m</code>输入特征，并对输入特征(<code class="fe lq lr ls lt b">x_{i}</code>)和权重(<code class="fe lq lr ls lt b">w_{i}</code>)之间的乘积求和。这就是我们如何计算给定输入特征的<strong class="kf ir"> <em class="lc">分数</em> </strong>。</p><p id="45f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们想象一下我刚才说的等式的红色部分。</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/b6f697199e805c109c6b5b812fb30581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c1__xa2EPo4xDLBXGG3uMw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><strong class="bd kc">Fig 7: Scores from Inputs</strong></figcaption></figure><p id="0563" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，现在，为了根据这个计算出的分数做出一个<strong class="kf ir"> <em class="lc">预测</em> </strong>，我们必须使用一个<strong class="kf ir"> <em class="lc">激活函数</em> </strong>。</p><p id="990c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="lc">激活功能？</em> </strong> <em class="lc"> <br/>激活函数主要用于在神经网络的每一层中引入网络中的非线性，没有激活函数，无论神经网络有多深，我们都将计算一个线性函数。<br/>在输出层，对于分类问题，我们使用激活函数将分数映射到类别。</em></p><p id="3dfe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，我们将使用<a class="ae lb" href="https://en.wikipedia.org/wiki/Heaviside_step_function" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="lc"> Heaviside step 函数</em> </strong> </a>，如果分数小于或等于 0，则简单地输出<br/> <strong class="kf ir"> 0 </strong>，否则输出<br/> <strong class="kf ir"> 1 </strong>。</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/5b1988fb89eb744e90237fc46cedd34c.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*AYYr8Sg-VfSS6OnGSiX0Nw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae lb" href="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d9/Dirac_distribution_CDF.svg/512px-Dirac_distribution_CDF.svg.png" rel="noopener ugc nofollow" target="_blank"><strong class="bd kc">Fig 8: Heaviside Step Function</strong></a></figcaption></figure><p id="9d7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，上图(图 6)中等式<code class="fe lq lr ls lt b">f(...)</code>的绿色部分是亥维赛阶梯函数。</p><p id="fa04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，现在如果你有了输入和权重，你就可以用红色方程得到分数，然后用一个激活函数得到预测！</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><p id="255d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="lc">注意事项</em> </strong> : <br/> <strong class="kf ir"> 1) </strong>感知器中不存在非线性。所以，它只能计算线性函数(<em class="lc">“直线”</em>)。<br/> <strong class="kf ir"> 2) </strong>还有一个附加的偏置项(用<code class="fe lq lr ls lt b">x_{0}</code>和<code class="fe lq lr ls lt b">w_{0}</code>表示)。为了简单起见，我们跳过了这一步。一般带偏置<code class="fe lq lr ls lt b">x_{0} = 1</code>和<code class="fe lq lr ls lt b">w_{0} = theta</code>。其中，<code class="fe lq lr ls lt b">theta</code>是网络学习的某个值。在这篇文章中，我们看到了如何使用感知器进行预测(<em class="lc">正向传播</em>)，而不是网络如何学习(<em class="lc">反向传播</em>)。</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><p id="7bc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望这篇文章对你有所帮助，如果有，那么👏 👏 👏！<br/>喜欢我的作品？跟我来。</p><p id="7528" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随时给我发消息！我们连线吧！</p></div></div>    
</body>
</html>