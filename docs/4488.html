<html>
<head>
<title>10 not so intuitive things about programming with R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 R 编程的 10 个不太直观的地方</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-not-so-intuitive-things-about-programming-with-r-a4d9d120c42c?source=collection_archive---------10-----------------------#2018-08-19">https://towardsdatascience.com/10-not-so-intuitive-things-about-programming-with-r-a4d9d120c42c?source=collection_archive---------10-----------------------#2018-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d128167ba32bd900b69e338b70daa824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZPQOUmHKUeF6dTMDwjHitw.jpeg"/></div></div></figure><h1 id="226d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">为什么数据科学要用 R</strong></h1><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kw"><img src="../Images/9316fa318e74919d0e655b11886f1a72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BgoeftOFRdO7g8F3O1eXSQ.png"/></div></div></figure><p id="5435" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">传统上，r 被认为是统计学家和某些学术研究者的首选计算语言，因为有大量可用的统计软件包和庞大的社区。可以说，R 的最大优势在于数据操作和统计分析任务的容易实现。此外，ggplot2 之类的包可以生成高质量的可视化效果，使数据分析和报告变得令人愉快，而没有其他脚本语言的陡峭的学习曲线。</p><p id="02ca" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">也就是说，R 的行为也可能相当古怪。作为三藩市大学 MSDS 项目的一部分，我最近参加了一门关于 R 的探索性数据分析的课程，并以惨痛的代价学会了其中的一些怪癖。我在下面列出了十大怪癖，可能不是很直观。在分析数据和调试代码时，意识到这些怪癖可以节省大量的时间和挫折。</p><h2 id="d99a" class="lz jz iq bd ka ma mb dn ke mc md dp ki lm me mf km lq mg mh kq lu mi mj ku mk bi translated"><strong class="ak"> 1)加载包时使用 require()和 library()</strong></h2><p id="1b30" class="pw-post-body-paragraph lb lc iq ld b le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly ij bi translated">如上所述，R 的主要优点是有大量的包，可以很容易地检索并加载到活动的 R 会话中。<strong class="ld ir"> require() </strong>和<strong class="ld ir"> library() </strong>函数都允许我们将已安装的包加载到活动内存中，但是当加载有问题的包抛出异常时，它们的输出会有细微的差别。当<strong class="ld ir"> library() </strong>抛出一个<strong class="ld ir"> <em class="mq">错误</em> </strong>当包不可加载到活动内存时，<strong class="ld ir"> require() </strong>抛出<strong class="ld ir"> </strong>一个<strong class="ld ir"> <em class="mq">警告</em> </strong>并返回一个基于包可用性的逻辑响应。</p><pre class="kx ky kz la gt mr ms mt mu aw mv bi"><span id="b754" class="lz jz iq ms b gy mw mx l my mz">&gt; library(randomForest)<br/><strong class="ms ir">Error</strong> in library(randomForest) : <br/>  there is no package called ‘randomForest’<br/><br/>&gt; b &lt;- require(randomForest)<br/>Loading required package: randomForest<br/><strong class="ms ir">Warning message:</strong><br/>In library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :<br/>  there is no package called ‘randomForest’<br/>&gt; print(b)<br/>[1] <strong class="ms ir">FALSE</strong></span></pre><p id="32b9" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir"> require() </strong>通常可以作为条件检查，查看包是否存在并安装。</p><h2 id="2ad3" class="lz jz iq bd ka ma mb dn ke mc md dp ki lm me mf km lq mg mh kq lu mi mj ku mk bi translated">2)R 中的 NA 与 NULL</h2><p id="ff97" class="pw-post-body-paragraph lb lc iq ld b le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly ij bi translated"><code class="fe na nb nc ms b">NA</code>和<code class="fe na nb nc ms b">NULL</code>之间的差异可能是一个混淆点，因为人们可能会直觉地认为它们都表示缺失/未定义的值。然而，r 以不同的方式处理这两个保留字。<code class="fe na nb nc ms b">NA</code>是一个长度为 1  的<strong class="ld ir"> <em class="mq">逻辑常数，其中包含一个<strong class="ld ir"> <em class="mq">缺失值</em> </strong>指示符，而<code class="fe na nb nc ms b">NULL</code>表示<strong class="ld ir"> <em class="mq">空对象。</em> </strong>通过下面的代码可以直观的解释上述语句:</em></strong></p><pre class="kx ky kz la gt mr ms mt mu aw mv bi"><span id="33da" class="lz jz iq ms b gy mw mx l my mz">&gt; v &lt;- c(1,2,3,NA)<br/>&gt; v<br/>[1]  1  2  3 NA</span><span id="bbc2" class="lz jz iq ms b gy nd mx l my mz">&gt; w &lt;- c(1,2,3,NULL)<br/>&gt; w<br/>[1] 1 2 3</span></pre><p id="87d0" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">上面的代码帮助我们理解了<code class="fe na nb nc ms b">NA</code>和<code class="fe na nb nc ms b">NULL</code>之间的一个关键区别。<code class="fe na nb nc ms b">NULL</code>是自身类型的对象，不能强制为任何其他类型。因此，当我们试图将它包含在矢量形式中时，它被忽略了。另一方面，<code class="fe na nb nc ms b">NA</code>可以被强制为各种类型，如<strong class="ld ir"> NA_interger、NA_character </strong>等。但是，如果我们创建一个列表(因为列表可以将不同的类型存储在一起)，那么它们都可以作为一个元素包含在内。</p><pre class="kx ky kz la gt mr ms mt mu aw mv bi"><span id="5ae8" class="lz jz iq ms b gy mw mx l my mz">&gt; w &lt;- list(1,2,3,NULL)<br/>&gt; w<br/>[[1]]<br/>[1] 1<br/><br/>[[2]]<br/>[1] 2<br/><br/>[[3]]<br/>[1] 3<br/><br/>[[4]]<br/>NULL</span></pre><h2 id="c345" class="lz jz iq bd ka ma mb dn ke mc md dp ki lm me mf km lq mg mh kq lu mi mj ku mk bi translated">3)使用浮点值的子设置和逻辑向量的循环</h2><p id="53ff" class="pw-post-body-paragraph lb lc iq ld b le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly ij bi translated">要访问向量/矩阵/数组中的特定值，我们可以使用索引值或逻辑向量进行子设置。值得注意的一点是，我们可以使用 floats 和 integer 来调用特定的值，如下所示:</p><pre class="kx ky kz la gt mr ms mt mu aw mv bi"><span id="c25a" class="lz jz iq ms b gy mw mx l my mz">&gt; w &lt;- c(1,2,3,4,5)<br/>&gt; w[3.5]<br/>[1] 3<br/>&gt; w[-4.9]<br/>[1] 1 2 3 5</span></pre><p id="838e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们可以清楚地看到，无论符号如何，在子设置时，指数的浮动部分被忽略。所以<strong class="ld ir"> 3.5 </strong>给我们向量中的第 3 个元素，而<strong class="ld ir"> -4.9 </strong>忽略第 4 个元素。在使用逻辑向量进行子集设置时，另一件要注意的事情是向量长度。如果子集向量的长度较小，R 不会抛出错误，而是回收较小的向量，使其具有相同的长度。</p><pre class="kx ky kz la gt mr ms mt mu aw mv bi"><span id="f380" class="lz jz iq ms b gy mw mx l my mz">&gt; w &lt;- c(1,2,3,4,5)<br/>&gt; x &lt;- c(T,F)<br/>&gt; x<br/>[1]  TRUE FALSE<br/>&gt; w[x]<br/>[1] 1 3 5</span></pre><p id="08fd" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们可以看到向量<code class="fe na nb nc ms b">x </code>的长度为 2，向量<code class="fe na nb nc ms b">w</code>的长度为 5。然而，当我们使用<code class="fe na nb nc ms b">x</code>子集时，它被循环到<strong class="ld ir"> c(T，F，T，F，T) </strong>并且我们在<code class="fe na nb nc ms b">w</code>中得到所有的替代值。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/27371056087d925f269b829e28f8f037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*z1fIDGt03YMHHgzR4QMF5w.jpeg"/></div></figure><h2 id="8a8c" class="lz jz iq bd ka ma mb dn ke mc md dp ki lm me mf km lq mg mh kq lu mi mj ku mk bi translated">4)列表中的类型保留与简化</h2><p id="8cbf" class="pw-post-body-paragraph lb lc iq ld b le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly ij bi translated">列表能够将不同类型的数据存储在一起，这非常有用。<strong class="ld ir">类型保留</strong>和<strong class="ld ir">类型简化</strong>是两个有趣的概念，当我们试图使用(<code class="fe na nb nc ms b">[ ]</code>或<code class="fe na nb nc ms b">[[ ]]</code>)提取列表元素时，它们就发挥作用了</p><pre class="kx ky kz la gt mr ms mt mu aw mv bi"><span id="52bb" class="lz jz iq ms b gy mw mx l my mz">&gt; a &lt;- list(1,2,3,c(4,5,6))<br/># a has 1,2,3 and c(4,5,6) as its elements<br/>&gt; a[1]<br/>[[1]]<br/>[1] 1<br/>#Element one as list:Type preservation</span><span id="949f" class="lz jz iq ms b gy nd mx l my mz">&gt; a[4]<br/>[[1]]<br/>[1] 4 5 6<br/>#Element 4 as list:Type preservation</span><span id="ec6f" class="lz jz iq ms b gy nd mx l my mz">&gt; a[[4]]<br/>[1] 4 5 6<br/>#Element 4 as vector, type simplification</span><span id="229d" class="lz jz iq ms b gy nd mx l my mz">&gt; a[[4]][1]<br/>[1] 4<br/>#First element of 4th element of a, type simplification</span><span id="5784" class="lz jz iq ms b gy nd mx l my mz">&gt; a[4][1]<br/>[[1]]<br/>[1] 4 5 6<br/>#[] Outputs the whole vector as we did not simplify the data type to vector from list.</span></pre><p id="26d4" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">从上面的例子中，我们可以看到<code class="fe na nb nc ms b">[]</code>有助于 T <strong class="ld ir">类型保存</strong>，输出也是一个列表，类似于初始列表。另一方面，<code class="fe na nb nc ms b">[[]]</code>对<strong class="ld ir">进行了类型简化</strong>，并给出了最简单的潜在数据类型。另外，当我们试图访问一个向量的元素时，<code class="fe na nb nc ms b">[[]]</code>是很重要的，这个向量包含在一个列表中，如代码的最后一行所示。</p><h2 id="c382" class="lz jz iq bd ka ma mb dn ke mc md dp ki lm me mf km lq mg mh kq lu mi mj ku mk bi translated">5)访问矩阵中的列并使用 drop</h2><p id="c0b0" class="pw-post-body-paragraph lb lc iq ld b le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly ij bi translated">矩阵运算在实现很多机器学习模型的矢量化和速度方面发挥了很大的作用。很多时候，我们需要对矩阵进行子集化，以访问矩阵中的特定列并执行某些操作。但是，当您尝试从矩阵中提取单个列时，会发生如下所示的奇怪情况:</p><pre class="kx ky kz la gt mr ms mt mu aw mv bi"><span id="88e4" class="lz jz iq ms b gy mw mx l my mz">&gt; a &lt;- matrix(c(1:9),ncol=3,nrow=3)<br/>&gt; a<br/>     [,1] [,2] [,3]<br/>[1,]    1    4    7<br/>[2,]    2    5    8<br/>[3,]    3    6    9<br/>&gt; a[,1]<br/>[1] 1 2 3<br/>&gt; class(a[,1])<br/>[1] "integer"<br/>#When you extract a single column, it is converted to a vector</span><span id="c961" class="lz jz iq ms b gy nd mx l my mz">&gt; a[,1,drop=F]<br/>     [,1]<br/>[1,]    1<br/>[2,]    2<br/>[3,]    3<br/>&gt; class(a[,1,drop=F])<br/>[1] "matrix"<br/># drop=F helps us retain the matrix form</span></pre><p id="982d" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当我们试图访问一个单独的列时，R 把它转换成向量形式。这有时可能是不必要的，因为您的下游代码可能会由于这种转换而受到影响(<em class="mq">在 R </em>中从头实现 k- means 算法时学到了这一点)。为了避免这种情况，我们必须在访问单个列时使用<code class="fe na nb nc ms b">drop=F</code>作为参数。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/05854e5930e6cef27d40b0dd8840d144.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*fNCAUoWu6hwees12M8gRUA.jpeg"/></div></figure><h2 id="6e22" class="lz jz iq bd ka ma mb dn ke mc md dp ki lm me mf km lq mg mh kq lu mi mj ku mk bi translated">6)访问向量和列表中的越界元素</h2><p id="02d8" class="pw-post-body-paragraph lb lc iq ld b le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly ij bi translated">当我们试图访问一个越界的元素时，这是我们在 R 中能观察到的最不寻常的事情之一。看看下面的代码:</p><pre class="kx ky kz la gt mr ms mt mu aw mv bi"><span id="8910" class="lz jz iq ms b gy mw mx l my mz">&gt; a &lt;- c(1:5)<br/>&gt; a<br/>[1] 1 2 3 4 5<br/># a has 5 elements as shown above</span><span id="1937" class="lz jz iq ms b gy nd mx l my mz">&gt; a[7]<br/>[1] NA<br/>#When we try to access 7th element, we get NA instead of an error</span><span id="a626" class="lz jz iq ms b gy nd mx l my mz">&gt; b &lt;- list(c(1,2,3,4))<br/>&gt; b<br/>[[1]]<br/>[1] 1 2 3 4<br/>#b has 1 element which is a vector of 4 elements<br/>&gt; b[2]<br/>[[1]]<br/>NULL<br/>#When we try to access 2nd element, we get NULL instead of an error</span></pre><p id="d0c8" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当我们从一个向量或列表中访问一个越界索引时，我们得到的不是一个错误，而是作为输出的<code class="fe na nb nc ms b">NA</code>和<code class="fe na nb nc ms b">NULL</code>，这可能会引起关注，有时会使测试/调试变得困难。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/84b694aae966ecd5e7432862bb6b6b29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W1KWLWBcLKVYLKYI0r1sYg.jpeg"/></div></div></figure><h2 id="73fe" class="lz jz iq bd ka ma mb dn ke mc md dp ki lm me mf km lq mg mh kq lu mi mj ku mk bi translated">7) if {} else{} vs ifelse()</h2><p id="94fa" class="pw-post-body-paragraph lb lc iq ld b le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly ij bi translated">当我们有了一个向量并想要检查给定的条件时，<code class="fe na nb nc ms b">if {} else{}</code>只对向量的第一个元素起作用，并给出一个警告。然而，如果我们想要访问向量中每个元素的条件，我们必须使用<code class="fe na nb nc ms b">ifelse()</code>。它比较向量中的每个值并返回一个向量。假设，我们有一个包含 5 个元素的向量，我们想检查它们是偶数还是奇数</p><pre class="kx ky kz la gt mr ms mt mu aw mv bi"><span id="e2d3" class="lz jz iq ms b gy mw mx l my mz">&gt; a &lt;- c(5:10)<br/>&gt; a<br/>[1]  5  6  7  8  9 10<br/>&gt; if(a%%2==0){x &lt;- "Even"} else{x &lt;- "Odd"}<br/>Warning message:<br/>In if (a%%2 == 0) { :<br/>  the condition has length &gt; 1 and only the first element will be used<br/>&gt; x<br/>[1] "Odd"</span><span id="431c" class="lz jz iq ms b gy nd mx l my mz">&gt; y &lt;- ifelse(a%%2,"Even","Odd")<br/>&gt; y<br/>[1] "Even" "Odd"  "Even" "Odd"  "Even" "Odd"</span></pre><p id="564e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们可以看到<code class="fe na nb nc ms b">if{} else{}</code>只比较了<code class="fe na nb nc ms b">a</code>的第一个元素，而<code class="fe na nb nc ms b">ifelse()</code>达到了要求的结果。</p><h2 id="52a2" class="lz jz iq bd ka ma mb dn ke mc md dp ki lm me mf km lq mg mh kq lu mi mj ku mk bi translated">8)调用参数数量不足的函数</h2><p id="d1b2" class="pw-post-body-paragraph lb lc iq ld b le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly ij bi translated">r 允许调用参数数量不足的函数，只要缺少的参数没有被调用。这是需要记住的非常重要的一点，并且不同于其他编程语言。如果我们明确地希望所有的参数都出现在函数调用中，我们可以在其他选项中使用<code class="fe na nb nc ms b">force()</code>。</p><pre class="kx ky kz la gt mr ms mt mu aw mv bi"><span id="94e9" class="lz jz iq ms b gy mw mx l my mz">&gt; f &lt;- function(x,y){<br/>           print(x)}<br/>&gt; f(2)<br/>[1] 2<br/>#Function call works with one argument as y is not used.</span><span id="ed28" class="lz jz iq ms b gy nd mx l my mz">&gt; f(2,3)<br/>[1] 2<br/>#Calling with both arguments</span><span id="f2d2" class="lz jz iq ms b gy nd mx l my mz">&gt; f()<br/>Error in print(x) : argument "x" is missing, with no default<br/>#Since x is called inside function and is missing, we get error</span><span id="5ad1" class="lz jz iq ms b gy nd mx l my mz">#Explicitly checking for both x and y using force()<br/>&gt; f &lt;- function(x,y){force(x,y); print(x)}<br/>&gt; f(2,3)<br/>[1] 2<br/>&gt; f(2)<br/>Error in force(y) : argument "y" is missing, with no default</span></pre><p id="c682" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe na nb nc ms b">force()</code>检查 x 和 y 是否都存在，当缺失时抛出错误。</p><h2 id="e13b" class="lz jz iq bd ka ma mb dn ke mc md dp ki lm me mf km lq mg mh kq lu mi mj ku mk bi translated">9)功能屏蔽和使用:</h2><p id="7f4b" class="pw-post-body-paragraph lb lc iq ld b le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly ij bi translated">很多时候，不同的包有相同名称但不同功能的函数。如果我们想使用特定包中的特定函数，我们可能需要特别指定它。在没有特定调用的情况下，最近加载的包中的函数会屏蔽所有其他同名函数。例如，库<code class="fe na nb nc ms b">chron</code>和<code class="fe na nb nc ms b">tseries</code>都以<code class="fe na nb nc ms b">is.weekend()</code>为其功能。</p><pre class="kx ky kz la gt mr ms mt mu aw mv bi"><span id="f29d" class="lz jz iq ms b gy mw mx l my mz">library(chron)<br/>library(tseries)<br/>    ‘tseries’ version: 0.10-45<br/><br/>    ‘tseries’ is a package for time series analysis and computational finance.<br/><br/>    See ‘library(help="tseries")’ for details.<br/><br/><br/>Attaching package: ‘tseries’<br/><br/><strong class="ms ir">The following object is masked from ‘package:chron’:</strong><br/><br/>    is.weekend</span><span id="b5e9" class="lz jz iq ms b gy nd mx l my mz">is.weekend(x)</span></pre><p id="b663" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当我们调用<code class="fe na nb nc ms b">is.weekend()</code>时，来自<code class="fe na nb nc ms b">tseries</code>包的函数被使用，因为它是最近加载的包。如果我们特别想使用<code class="fe na nb nc ms b">chron</code>，我们需要做以下事情:</p><pre class="kx ky kz la gt mr ms mt mu aw mv bi"><span id="8366" class="lz jz iq ms b gy mw mx l my mz">chron::is.weekend(x)</span></pre><p id="7d8e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe na nb nc ms b">::</code>帮助我们指定使用哪个包。<code class="fe na nb nc ms b">::</code>也帮助我们不用加载包就可以使用一个函数。然而，每当我们想要使用这个包中的函数时，我们需要使用<code class="fe na nb nc ms b">::</code>来专门调用这个函数。</p><h2 id="8f85" class="lz jz iq bd ka ma mb dn ke mc md dp ki lm me mf km lq mg mh kq lu mi mj ku mk bi translated">10)调用函数时的参数匹配</h2><p id="e4d0" class="pw-post-body-paragraph lb lc iq ld b le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly ij bi translated">调用函数时，参数按照以下顺序进行匹配:a)完全名称匹配<br/> b)部分名称匹配<br/> c)位置匹配</p><pre class="kx ky kz la gt mr ms mt mu aw mv bi"><span id="3851" class="lz jz iq ms b gy mw mx l my mz">&gt; f &lt;- function(a1,b1,a2){<br/>    print(paste("a1:",a1,"b1:",b1,"c1:",a2))}</span><span id="8c6a" class="lz jz iq ms b gy nd mx l my mz">&gt; f(a1=2,b1=3,a2=5)<br/>[1] "a1: 2 b1: 3 c1: 5"<br/>#Example of Exact match, each argument has same name</span><span id="bf73" class="lz jz iq ms b gy nd mx l my mz"><br/>&gt; f(b1=3,5,2)<br/>[1] "a1: 5 b1: 3 c1: 2"<br/>#Example of exact match and positional match. Since b1 is matched, 5 and 2 are assigned based on position</span><span id="4281" class="lz jz iq ms b gy nd mx l my mz">&gt; f(3,b=5,2)<br/>[1] "a1: 3 b1: 5 c1: 2"<br/>#Partial name match, b matches to b1. Rest matched based on position</span><span id="39bc" class="lz jz iq ms b gy nd mx l my mz"><br/>&gt; f(3,5,2)<br/>[1] "a1: 3 b1: 5 c1: 2"<br/>&gt; f(3,5,a=2)<br/>Error in f(3, 5, a = 2) : argument 3 matches multiple formal arguments<br/>#Since a matches to both a1 and a2 we get error as R does not know where the value needs to be assigned.</span></pre><h1 id="9e38" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结束注释:</h1><p id="de39" class="pw-post-body-paragraph lb lc iq ld b le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly ij bi translated">r 为我们打开了一个无限可能的世界，它蓬勃发展的社区和生态系统使它成为一门值得学习的编程语言。我希望以上几点对任何使用 R 的人都有用，并帮助他们避免许多常见的错误。这篇博客文章是我在旧金山大学教授的探索性数据分析的几个要点。联系我，讨论/编辑任何具体问题。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="407c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir">关于我:</strong>研究生，旧金山大学数据科学硕士</p><p id="b8fb" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir">领英:</strong><a class="ae nh" href="https://www.linkedin.com/in/jyoti-prakash-maheswari-940ab766/" rel="noopener ugc nofollow" target="_blank">https://www . LinkedIn . com/in/jyoti-pra kash-maheswari-940 ab 766/</a><br/><strong class="ld ir">GitHub:</strong><a class="ae nh" href="https://github.com/jyotipmahes" rel="noopener ugc nofollow" target="_blank">https://github.com/jyotipmahes</a></p><h2 id="d249" class="lz jz iq bd ka ma mb dn ke mc md dp ki lm me mf km lq mg mh kq lu mi mj ku mk bi translated">参考</h2><ol class=""><li id="e420" class="np nq iq ld b le ml li mm lm nr lq ns lu nt ly nu nv nw nx bi translated"><a class="ae nh" href="https://github.com/paulintrevado" rel="noopener ugc nofollow" target="_blank">Paul interva do 利用 R </a>进行探索性数据分析</li></ol></div></div>    
</body>
</html>