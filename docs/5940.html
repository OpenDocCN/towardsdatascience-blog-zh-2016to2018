<html>
<head>
<title>Essential text correction process for NLP tasks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NLP 任务的基本文本更正过程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/essential-text-correction-process-for-nlp-tasks-f731a025fcc3?source=collection_archive---------3-----------------------#2018-11-17">https://towardsdatascience.com/essential-text-correction-process-for-nlp-tasks-f731a025fcc3?source=collection_archive---------3-----------------------#2018-11-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9a34640bf668fa186e862ad62865d5bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3VkW3K1PQYTNdUKp"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">“person walking on sea near bridge during daytime” by <a class="ae kf" href="https://unsplash.com/@frankiefoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">frank mckenna</a> on <a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1c31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在之前的<a class="ae kf" rel="noopener" target="_blank" href="/correcting-your-spelling-error-with-4-operations-50bcfd519bb8">故事</a>中，引入了 Norvig 的算法来纠正拼写错误。它使用了 4 种操作(即删除、转座、替换和插入)。在这个故事中，我想介绍另一种方法，只使用删除操作来找到潜在的正确单词。</p><p id="9b66" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在处理文本时，我们可能需要处理不正确的文本。尽管我们仍然可以使用<a class="ae kf" rel="noopener" target="_blank" href="/besides-word-embedding-why-you-need-to-know-character-embedding-6096a34a3b10">字符嵌入</a>和<a class="ae kf" rel="noopener" target="_blank" href="/3-silver-bullets-of-word-embedding-in-nlp-10fa8f50cc5a">单词嵌入</a>来计算类似的向量。它对看不见的数据和词汇表之外的东西很有用(OOV)。不过如果能纠正错别字就更好了。</p><p id="5006" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看完这篇帖子，你会明白:</p><ul class=""><li id="a628" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">对称删除拼写纠正(SymSpell)</li><li id="3639" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">履行</li><li id="3f92" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">拿走</li></ul><h1 id="4254" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">对称删除拼写纠正(SymSpell)</h1><p id="8a79" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">Garbe 引入了对称删除拼写纠正(SymSpell)。这是一种简单但有用的纠正拼写错误的方法。</p><p id="6f78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在离线训练期间，需要执行预先计算来建立语料库。用编辑距离生成 word(仅删除操作)并将它们与原始项目连接。换句话说，它使用额外的存储和内存资源来节省在线预测时间。如果匹配，新生成的单词将用于搜索并返回原始单词。在线预测时，输入单词经过同样的计算，然后从预先计算的结果中查找。你可以查看这个故事的细节。</p><p id="cb11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">速度方面的性能非常好，因为:</p><ul class=""><li id="78b3" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">预计算是离线完成的。</li><li id="5489" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">在线预测只涉及删除操作和索引搜索(哈希表)</li></ul><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/87367d22bc954b747757a5f25801e0e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C1gm2aphT8fVlVNEjjMTsQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk"><a class="ae kf" href="https://github.com/wolfgarbe/symspell" rel="noopener ugc nofollow" target="_blank">https://github.com/wolfgarbe/symspell</a></figcaption></figure><h1 id="702d" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">履行</h1><p id="3dd4" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">为了方便拼写检查，需要语料库。为了便于演示，我简单地使用了 sklearn 库中的数据集，没有进行预处理。您应该使用特定领域的数据集来为您的数据构建更好的语料库。</p><p id="5089" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="na">建立语料库</em></p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="abff" class="ng lt it nc b gy nh ni l nj nk">from collections import Counter<br/>from sklearn.datasets import fetch_20newsgroups<br/>import re</span><span id="36d3" class="ng lt it nc b gy nl ni l nj nk">corpus = []<br/>for line in fetch_20newsgroups().data:<br/>    line = line.replace('\n', ' ').replace('\t', ' ').lower()<br/>    line = re.sub('[^a-z ]', ' ', line)<br/>    tokens = line.split(' ')<br/>    tokens = [token for token in tokens if len(token) &gt; 0]<br/>    corpus.extend(tokens)</span><span id="9809" class="ng lt it nc b gy nl ni l nj nk">corpus = Counter(corpus)</span><span id="0014" class="ng lt it nc b gy nl ni l nj nk">corpus_dir = '../../data/'<br/>corpus_file_name = 'spell_check_dictionary.txt'</span><span id="4233" class="ng lt it nc b gy nl ni l nj nk">symspell = SymSpell(verbose=10)<br/>symspell.build_vocab(<br/>    dictionary=corpus, <br/>    file_dir=corpus_dir, file_name=corpus_file_name)</span><span id="afa6" class="ng lt it nc b gy nl ni l nj nk">symspell.load_vocab(corpus_file_path=corpus_dir+corpus_file_name)</span></pre><p id="f443" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">修正</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="b8fc" class="ng lt it nc b gy nh ni l nj nk">results = symspell.correction(word='edwarda')<br/>print(results)</span></pre><p id="2b40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出是它将“edward”和“edwarda”标识为 1 个距离，而“count”是指原始语料库的频率。</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="a982" class="ng lt it nc b gy nh ni l nj nk">[{'distance': 1, 'word': 'edward', 'count': 154}, {'distance': 1, 'word': 'edwards', 'count': 50}]</span></pre><p id="490e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了单词校正，Symspell 还提供了一个复合词的距离计算。</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="e270" class="ng lt it nc b gy nh ni l nj nk">results = symspell.corrections(sentence='Hello I am Edarda')<br/>print(results)</span></pre><p id="ffb3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与单字校正不同，复合函数支持拆分和分解操作。有关详细信息，您可以查看<a class="ae kf" href="https://github.com/wolfgarbe/symspell" rel="noopener ugc nofollow" target="_blank">符号拼写 API </a>。</p><p id="402d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的输出计算与原始句子的总距离。给出“你好我是 Edarda”，它发现如果修正为“你好我是 ed 区”最短距离是 3。</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="473e" class="ng lt it nc b gy nh ni l nj nk">[{'distance': 3, 'word': 'hello i am ed area'}]</span></pre><h1 id="9a77" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">拿走</h1><p id="4524" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">要访问所有代码，你可以访问我的 github repo。</p><ul class=""><li id="4644" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">和拼写校正器一样，符号拼写<strong class="ki iu">不考虑上下文</strong>，而仅仅考虑拼写。</li><li id="a880" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">由于方法简单，<strong class="ki iu">搜索时间复杂度为 O(1) </strong>为常数时间。</li><li id="3193" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">允许更大的编辑距离会引入更大的词汇，并导致更大的硬盘和内存消耗，但在当前的资源规模下应该没问题。</li></ul><h1 id="9ab6" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">关于我</h1><p id="49f6" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">我是湾区的数据科学家。专注于数据科学、人工智能，尤其是 NLP 和平台相关领域的最新发展。你可以通过<a class="ae kf" href="http://medium.com/@makcedward/" rel="noopener">媒体博客</a>、<a class="ae kf" href="https://www.linkedin.com/in/edwardma1026" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>或<a class="ae kf" href="https://github.com/makcedward" rel="noopener ugc nofollow" target="_blank"> Github </a>联系我。</p><h1 id="986e" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">参考</h1><p id="f087" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated"><a class="ae kf" href="https://github.com/wolfgarbe/symspell" rel="noopener ugc nofollow" target="_blank">C #中的符号拼写</a>(原始)</p><p id="2447" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://github.com/mammothb/symspellpy" rel="noopener ugc nofollow" target="_blank">python 中的符号拼写</a></p></div></div>    
</body>
</html>