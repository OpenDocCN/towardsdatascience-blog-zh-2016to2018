<html>
<head>
<title>Data Handling using Pandas; Machine Learning in Real Life</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用熊猫进行数据处理；现实生活中的机器学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-handling-using-pandas-machine-learning-in-real-life-be76a697418c?source=collection_archive---------7-----------------------#2018-10-10">https://towardsdatascience.com/data-handling-using-pandas-machine-learning-in-real-life-be76a697418c?source=collection_archive---------7-----------------------#2018-10-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="221c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天，我们将看到一些基本的技术来处理稍微复杂一点的数据，而不是我在<code class="fe km kn ko kp b">sklearn</code>数据集的之前使用<a class="ae kl" rel="noopener" target="_blank" href="/ridge-and-lasso-regression-a-complete-guide-with-python-scikit-learn-e20e34bcbf0b">的例子，使用<code class="fe km kn ko kp b">pandas</code>的各种特性。这篇文章将帮助你安排复杂的数据集来处理现实生活中的问题，最终我们将通过一个逻辑回归的例子来研究数据。关于数据清理的更多信息，你可以查看这篇</a><a class="ae kl" rel="noopener" target="_blank" href="/data-handling-using-pandas-cleaning-and-processing-3aa657dc9418">文章</a>。</p><p id="2665" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以从我的 github <a class="ae kl" href="https://github.com/suvoooo/Machine_Learning" rel="noopener ugc nofollow" target="_blank">存储库</a>下载名为“bank.csv”的数据文件，或者从原始的<a class="ae kl" href="http://archive.ics.uci.edu/ml/datasets/Bank+Marketing" rel="noopener ugc nofollow" target="_blank">源</a>下载，那里有数据集的详细描述。</p><p id="50a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在描述数据文件之前，让我们导入它并看看基本的形状</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="f696" class="ky kz iq kp b gy la lb l lc ld">import pandas as pd</span><span id="939a" class="ky kz iq kp b gy le lb l lc ld">bankdf = pd.read_csv('bank.csv',sep=';') # check the csv file before to know that 'comma' here is ';'</span><span id="36b3" class="ky kz iq kp b gy le lb l lc ld">print bankdf.head(3)<br/>print list(bankdf.columns)# show the features and label <br/>print bankdf.shape # instances vs features + label (4521, 17) </span></pre><p id="e389" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出如下</p><figure class="kq kr ks kt gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lf"><img src="../Images/fc9fc5fee6bc72fd4c906338e5340b14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KSB7kJmdDToyGTon-5RU0w.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">bank data-set brief description</figcaption></figure><p id="8319" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从输出中我们看到数据集有 16 个特征，标签用<code class="fe km kn ko kp b">'y'</code>指定。主<a class="ae kl" href="http://archive.ics.uci.edu/ml/datasets/Bank+Marketing" rel="noopener ugc nofollow" target="_blank">库</a>中给出了这些特性的详细描述。主存储库中的数据集概述如下</p><blockquote class="lr ls lt"><p id="742c" class="jn jo lu jp b jq jr js jt ju jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj kk ij bi translated">该数据与一家葡萄牙银行机构的直接营销活动相关。营销活动以电话为基础。通常，为了了解产品(银行定期存款)是否认购(“是”)或不认购(“否”)，需要与同一客户进行多次联系。</p></blockquote><p id="e33e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以制作一个<code class="fe km kn ko kp b">seaborn</code>计数图，看看其中一个类是如何控制输出的。</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="f085" class="ky kz iq kp b gy la lb l lc ld">import matplotlib.pyplot as plt<br/>import seaborn as sns</span><span id="5296" class="ky kz iq kp b gy le lb l lc ld">sns.set(font_scale=1.5)<br/>countplt=sns.countplot(x='y', data=bankdf, palette ='hls')</span><span id="277b" class="ky kz iq kp b gy le lb l lc ld">plt.show()</span></pre><figure class="kq kr ks kt gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ly"><img src="../Images/e3ab8e166b25be43e29a262681d4cee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kxX9ROPJEVT4zKxvt5qMdQ.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Label (‘y’) of the bank data is dominated with ‘no’ variable</figcaption></figure><p id="816b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以用下面的一段代码来计算这个数字</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="b660" class="ky kz iq kp b gy la lb l lc ld">count_no_sub = len(bankdf[bankdf['y']=='no'])</span><span id="b017" class="ky kz iq kp b gy le lb l lc ld">print count_no_sub</span><span id="5dd7" class="ky kz iq kp b gy le lb l lc ld">&gt;&gt;&gt; 4000</span></pre><p id="892c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为数据集的标签是以“是”和“否”的形式给出的，所以有必要用数字来代替它们，可能分别用 1 和 0，以便它们可以用于数据的建模。在第一步中，我们将<strong class="jp ir">将数据集的输出标签从二进制字符串 yes/no 转换为整数 1/0。</strong></p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="998f" class="ky kz iq kp b gy la lb l lc ld">bankdf['y'] = (bankdf['y']=='yes').astype(int)  # changing yes to 1 and no to 0<br/>print bankdf['y'].value_counts()</span><span id="8373" class="ky kz iq kp b gy le lb l lc ld">&gt;&gt;&gt; 0    4000<br/>    1     521<br/>Name: y, dtype: int64</span></pre><p id="955b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于输出标签现在被转换成整数，我们可以使用 pandas 的<code class="fe km kn ko kp b">groupby</code>特性来进一步研究数据集。根据输出标签(是/否)，我们可以看到特性中的数字如何变化。</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="9726" class="ky kz iq kp b gy la lb l lc ld">out_label = bankdf.groupby('y')<br/>print out_label.agg(np.mean)</span><span id="c223" class="ky kz iq kp b gy le lb l lc ld"># above two lines can be written using a single line of code<br/>#print bankdf.groupby('y').mean()</span><span id="92f7" class="ky kz iq kp b gy le lb l lc ld">&gt;&gt;&gt;<br/>    age   balance   day  duration campaign pdays previous<br/>y                                                                       <br/>0  40.99 1403.2117 15.948 226.347 2.862  36.006  0.471 <br/>1  42.49 1571.9558 15.658 552.742 2.266  68.639  1.090</span></pre><p id="38bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，这里我们只看到 16 个特性中的 7 个，因为剩下的特性是对象，而不是整数或浮点数。你可以输入<code class="fe km kn ko kp b">bankdf.info()</code>来检查。我们看到“持续时间”这一功能告诉我们最近一次通话的持续时间(以秒为单位),购买了产品的客户是没有购买产品的客户的两倍多。“活动”,表示在当前活动期间进行的通话次数，对于购买产品的客户来说较低。<code class="fe km kn ko kp b"><strong class="jp ir">groupby</strong></code> <strong class="jp ir">可以给我们一些关于特征和标签之间关系的重要信息。</strong>感兴趣的人可以在“教育”功能上检查类似的“分组”操作，以验证受过高等教育的客户具有最高的“余额”(以欧元表示的平均年余额)！</p><p id="9a62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据集的一些特征有许多类别，可以通过使用<em class="lu">系列</em>对象的<strong class="jp ir"/><code class="fe km kn ko kp b"><strong class="jp ir">unique</strong></code><strong class="jp ir">方法进行检查。</strong>示例如下</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="a419" class="ky kz iq kp b gy la lb l lc ld">print bankdf["education"].unique()<br/>print bankdf["marital"].unique()</span><span id="0432" class="ky kz iq kp b gy le lb l lc ld">&gt;&gt;&gt; ['primary' 'secondary' 'tertiary' 'unknown']<br/>    ['married' 'single' 'divorced']</span></pre><p id="4cda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些变量被称为分类变量，就<code class="fe km kn ko kp b">pandas</code>而言，它们被称为“对象”。<strong class="jp ir">为了使用分类变量检索信息，我们需要将它们转换成“虚拟”变量，以便它们可以用于建模。</strong>我们使用<a class="ae kl" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.get_dummies.html#pandas-get-dummies" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">pandas . get _ dummies</strong></a><strong class="jp ir"/>特性来实现。首先，我们创建一个分类变量列表</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="acec" class="ky kz iq kp b gy la lb l lc ld">cat_list = ['job','marital','education','default','housing','loan','contact','month','poutcome']</span></pre><p id="5b5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们将这些变量转换成虚拟变量，如下所示</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="0d9f" class="ky kz iq kp b gy la lb l lc ld">for ele in cat_list:<br/> add = pd.get_dummies(bankdf[ele], prefix=ele)<br/> bankdf1 = bankdf.join(add)# join columns with old dataframe<br/> bankdf = bankdf1</span><span id="1797" class="ky kz iq kp b gy le lb l lc ld">#print bankdf.head(3)<br/>#print bankdf.info()</span></pre><p id="357b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经为每个分类变量创建了虚拟变量，打印出新数据帧的头部将会得到如下结果</p><figure class="kq kr ks kt gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lz"><img src="../Images/17c94e4728002ea12b15b1fafddbc836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wInXQuj3kOdA9758n1x8Rg.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Dummy variables from categorical variables</figcaption></figure><p id="44af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以理解，分类变量是如何被转换成虚拟变量的，这些虚拟变量可以在这个数据集的建模中使用。但是，我们有一个小问题。实际的分类变量仍然存在，它们需要被移除以使数据帧为机器学习做好准备。我们首先通过<em class="lu">使用</em> <code class="fe km kn ko kp b"><em class="lu">tolist() </em></code> <em class="lu">属性将新数据帧的列标题转换成一个列表。然后，我们创建一个没有分类变量的新列标题列表，并重命名标题。我们使用下面的代码来做到这一点</em></p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="1dd1" class="ky kz iq kp b gy la lb l lc ld">bank_vars = bankdf.columns.values.tolist() # column headers are converted into a list</span><span id="1313" class="ky kz iq kp b gy le lb l lc ld">to_keep = [i for i in bank_vars if i not in cat_list] #create a new list by comparing with the list of categorical variables - 'cat_list'</span><span id="dfcd" class="ky kz iq kp b gy le lb l lc ld">print to_keep # check the list of headers to make sure no categorical variable remains</span></pre><p id="7866" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们准备创建一个没有分类变量的新的数据框架，我们通过-</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="a72e" class="ky kz iq kp b gy la lb l lc ld">bank_final = bankdf[to_keep]</span></pre><p id="cadd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，为了创建新的数据帧，我们将一个列表(' to_keep ')传递给索引操作符(' bankdf ')。如果您没有将列名列表传递给索引操作符，它将返回一个<code class="fe km kn ko kp b"><strong class="jp ir">keyerror</strong></code>。要选择多个列作为数据帧，我们应该向索引操作符传递一个列表。但是，您可以选择单个列作为“系列”,如下所示</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="e113" class="ky kz iq kp b gy la lb l lc ld">bank_final = bankdf[to_keep] # to_keep is a 'list'<br/>print type(bank_final) </span><span id="e333" class="ky kz iq kp b gy le lb l lc ld">&gt;&gt;&gt; &lt;class 'pandas.core.frame.DataFrame'&gt;</span><span id="ffd0" class="ky kz iq kp b gy le lb l lc ld">bank_final = bankdf['age']<br/>print type(bank_final)</span><span id="a8a8" class="ky kz iq kp b gy le lb l lc ld">&gt;&gt;&gt; &lt;class 'pandas.core.series.Series'&gt;</span><span id="ff63" class="ky kz iq kp b gy le lb l lc ld">bank_final = bankdf['age','y']<br/>print type(bank_final)</span><span id="b107" class="ky kz iq kp b gy le lb l lc ld">&gt;&gt;&gt; KeyError: ('age', 'y')</span></pre><p id="c9a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以验证新数据帧<code class="fe km kn ko kp b">bank-final</code>的列标题。</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="ed25" class="ky kz iq kp b gy la lb l lc ld">print bank_final.columns.values</span><span id="fda1" class="ky kz iq kp b gy le lb l lc ld">&gt;&gt;&gt; ['age' 'balance' 'day' 'duration' 'campaign' 'pdays' 'previous' 'y' 'job_admin.' 'job_blue-collar' 'job_entrepreneur' 'job_housemaid' 'job_management' 'job_retired' 'job_self-employed' 'job_services' 'job_student' 'job_technician' 'job_unemployed' 'job_unknown' 'marital_divorced' 'marital_married' 'marital_single' 'education_primary' 'education_secondary' 'education_tertiary' 'education_unknown' 'default_no' 'default_yes' 'housing_no' 'housing_yes' 'loan_no' 'loan_yes' 'contact_cellular' 'contact_telephone' 'contact_unknown' 'month_apr' 'month_aug' 'month_dec' 'month_feb' 'month_jan' 'month_jul' 'month_jun' 'month_mar' 'month_may' 'month_nov' 'month_oct' 'month_sep' 'poutcome_failure' 'poutcome_other' 'poutcome_success' 'poutcome_unknown']</span></pre><p id="74c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们能够分离特征变量和标签，这样就有可能在数据集上测试一些机器学习算法。使用下面的代码从这个新数据框中选择要素和标注</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="8e40" class="ky kz iq kp b gy la lb l lc ld">bank_final_vars=bank_final.columns.values.tolist()# just like before converting the headers into a list<br/>Y = ['y']<br/>X = [i for i in bank_final_vars if i not in Y]</span></pre><p id="a8df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于有太多的特征，我们可以在<code class="fe km kn ko kp b">sklearn</code>下用递归特征消除(RFE)选择一些最重要的特征，它分两步工作。在我以后的文章中，我可能会讨论为什么特征选择不能用逻辑回归，但是现在让我们用一个<code class="fe km kn ko kp b">RFE</code>来选择一些重要的特征。首先，分类器被传递给<a class="ae kl" href="http://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.RFE.html#sklearn-feature-selection-rfe" rel="noopener ugc nofollow" target="_blank"> RFE </a>，带有要选择的特征数量，然后调用拟合方法。下面的代码描述了这一点</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="1222" class="ky kz iq kp b gy la lb l lc ld">model = LogisticRegression()<br/>rfe = RFE(model, 15) # we have selected here 15 features <br/>rfe = rfe.fit(bank_final[X], bank_final[Y])</span></pre><p id="aa61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用<code class="fe km kn ko kp b">support_</code>属性来查找哪些特征被选中。</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="0944" class="ky kz iq kp b gy la lb l lc ld">print rfe.support_</span><span id="82ff" class="ky kz iq kp b gy le lb l lc ld">&gt;&gt;&gt; [False False False False False False False False False False False False True False False False False False False False  True False False False False False  True False False False False  True False False  True False False  True False  True  True  True  True False False  True  True  True False  True  True]</span></pre><p id="ecb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">rfe.support_</code>生成一个数组，其中所选的特征被标记为真，您可以看到其中的 15 个，因为我们已经选择了最好的 15 个特征。<code class="fe km kn ko kp b">RFE</code>的另一个属性是<code class="fe km kn ko kp b">ranking_</code>，数组中的值 1 将突出显示所选的特征。</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="dc0e" class="ky kz iq kp b gy la lb l lc ld">print rfe.ranking_</span><span id="bace" class="ky kz iq kp b gy le lb l lc ld">&gt;&gt;&gt; [33 37 32 35 23 36 31 18 11 29 27 30  1 28 17  7 12 10  5  9  1 21 16 25 22  4  1 26 24 13 20  1 14 15  1 34  6  1 19  1  1  1  1  3  2  1  1  1 8  1  1]</span></pre><p id="15ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以用下面的代码明确地打印出使用<code class="fe km kn ko kp b">RFE</code>选择的特性的名称</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="9b39" class="ky kz iq kp b gy la lb l lc ld">rfe_rankinglist = rfe.ranking_.tolist()<br/>selected_columns = []</span><span id="770a" class="ky kz iq kp b gy le lb l lc ld">for im in range(len(X)):<br/> if rfe_rankinglist[im]==1:<br/>  selected_columns.append(X[im]) <br/>print selected_columns</span><span id="542a" class="ky kz iq kp b gy le lb l lc ld">&gt;&gt;&gt; ['job_retired', 'marital_married', 'default_no', 'loan_yes', 'contact_unknown', 'month_dec', 'month_jan', 'month_jul', 'month_jun', 'month_mar', 'month_oct', 'month_sep', 'poutcome_failure', 'poutcome_success', 'poutcome_unknown']</span></pre><p id="d2f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们终于可以继续了。fit()和。score()属性来检查模型的性能。</p><p id="dfc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在另一篇<a class="ae kl" href="https://medium.com/@saptashwa/logit-of-logistic-regression-understanding-the-fundamentals-f384152a33d1" rel="noopener">帖子</a>中，我将详细讨论逻辑回归背后的数学原理，我们将看到逻辑回归不能选择特征，它只是缩小线性模型的系数，类似于<a class="ae kl" rel="noopener" target="_blank" href="/ridge-and-lasso-regression-a-complete-guide-with-python-scikit-learn-e20e34bcbf0b">岭回归</a>。下面是可以用来检查特性选择效果的代码。这里我们使用了整个数据集，但最佳实践是将数据分为训练集和测试集。作为一个小练习，你可以试试这个，记住数据集的标签是高度倾斜的，使用<code class="fe km kn ko kp b">stratify</code>可能是个好主意。祝你好运！</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="612f" class="ky kz iq kp b gy la lb l lc ld">X_new = bank_final[selected_columns]<br/>Y = bank_final['y']<br/>X_old = bank_final[X]</span><span id="9df4" class="ky kz iq kp b gy le lb l lc ld">clasf = LogisticRegression()<br/>clasf_sel = LogisticRegression()<br/>clasf.fit(X_old,Y)<br/>clasf_sel.fit(X_new,Y)</span><span id="86c1" class="ky kz iq kp b gy le lb l lc ld">print "score using all features", clasf.score(X_old,Y)<br/>print "score using selected features", clasf_sel.score(X_new,Y)</span></pre><p id="e769" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，让我们总结一下最重要的几点来结束这篇文章</p><ul class=""><li id="c4d5" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">我们已经学会了使用<code class="fe km kn ko kp b">pandas</code>来处理现实数据集可能存在的一些问题。</li><li id="26c4" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">我们已经学会了将字符串(' yes '，' no ')转换成二进制变量(1，0)。</li><li id="3ab6" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">熊猫数据框的<code class="fe km kn ko kp b">groupby</code>属性如何帮助我们理解要素和标注之间的一些关键联系。</li><li id="4245" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">将分类变量改为虚拟变量，并在数据集建模中使用它们。</li><li id="b0d1" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">如何通过向索引操作员传递列表来选择数据帧的一部分。</li><li id="4340" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">使用 RFE 选择复杂数据集的一些主要特征。</li></ul><p id="c443" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于数据清理和处理的更多信息，你可以查看我关于使用 pandas 处理数据的帖子。关于使用熊猫分组和交叉表的更多信息，你可以查看我的全球恐怖主义数据分析<a class="ae kl" href="https://medium.com/swlh/practical-data-analysis-using-pandas-global-terrorism-database-20b29009adad" rel="noopener">帖子</a>。希望这篇文章能帮助你在处理现实的数据集时更自信一点。保持坚强和快乐。干杯！！</p></div></div>    
</body>
</html>