<html>
<head>
<title>Q-LocalSearch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">q-局部搜索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/q-localsearch-51e276d04d20?source=collection_archive---------12-----------------------#2018-12-25">https://towardsdatascience.com/q-localsearch-51e276d04d20?source=collection_archive---------12-----------------------#2018-12-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/ea0521b74243ec2fb9382d98c4decbad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hAUSOqDyYkx0pqseB0balQ.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/photos/z4H9MYmWIMA?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Franki Chamaki</a> on <a class="ae jd" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="15d0" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">一种基于 Q 学习的特征选择算法</h2></div><p id="a510" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">“这次我不会再开什么无聊的玩笑，也不会做什么参考”，她就是这么说的！</p><p id="ba1e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在今天的文章中，我将尝试向您解释我上周一直在做什么，以及我在我的<a class="ae jd" href="https://medium.com/@amineremache/the-local-search-problem-part-1-4daedbb2e482" rel="noopener">上一篇文章</a>中谈论的内容，任何评论或建议都将是很好的，即使您觉得您并不关心，也许您正在从一个可能有所帮助的角度看待它，您可以在此链接中找到完整的代码(确保选择分支:“local-search-rl”)。</p><p id="b6cd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">总之，在这部分代码中，你可以看到有初始局部搜索函数和 q-局部搜索函数，保持代码的可扩展性很好，所以当我需要实现一个新算法时，我所要做的就是在它们之间进行选择，因为它们不会影响其他部分。</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="lv lw l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">BSO algorithm</figcaption></figure><p id="ac6e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们在蜜蜂的水平上考虑局部搜索的初始算法，它进行穷举搜索，换句话说，它采用解决方案，一个接一个地翻转它的所有位，并每次进行评估，这使得复杂性，如果我们将其作为训练模型的成本，相当于模型的属性数量(例如声纳数据集，有 60 个属性， 这意味着我们将训练 60 个模型)并且这仅针对单个蜜蜂，并且针对单次迭代，这使得复杂度:<strong class="kx jh"> <em class="lx"> o(最大 Iter x Nbr 蜜蜂 x Nbr 本地 Iter x Nbr 属性)</em> </strong></p><p id="244e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是初始的本地搜索功能:</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="lv lw l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">The original local search algorithm</figcaption></figure><p id="c6d9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Q-LocalSearch 背后的想法是提供“过滤”数据的子集(仍然是可选的)，智能地翻转属性<strong class="kx jh"/>，或者换句话说，根据<strong class="kx jh">策略</strong>，以避免穷举搜索。</p><p id="1dab" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们首先解释什么是 Q-Learning:</p><p id="7650" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Q-learning 是由(Watkins &amp; Dayan，1992)提出的一种无模型、非策略的强化学习算法。它包括评估状态-动作对的良好性。状态 s 和行动 a 的 q 值定义为在状态 s 采取行动 a，然后遵循<em class="lx">政策</em>的预期累积回报。</p><figure class="lr ls lt lu gt is gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/31645148f30fe0fafeaf526389dceab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*XP-I6hsGjibT8olyMH6tAQ.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Reinforcement learning basic classification, <a class="ae jd" href="https://www.mathworks.com/examples/matlab/community/36132-maze-solving-using-q-learning-algorithm" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="107f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">蒙特卡罗树搜索</strong> (MCTS)、<strong class="kx jh">状态-动作-奖励-状态-动作</strong> (SARSA)和 Q-Learning 是这种分类的一些示例算法。</p><h1 id="53cc" class="lz ma jg bd mb mc md me mf mg mh mi mj km mk kn ml kp mm kq mn ks mo kt mp mq bi translated">q 表</h1><p id="ec3a" class="pw-post-body-paragraph kv kw jg kx b ky mr kh la lb ms kk ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">Q-Table 只是简单的跟踪表的一个花哨的名字，就像 T2 ADL T3 在他的文章 T5 中所说的。它通常由 2D 数组组成，其中行代表状态，列代表可能的动作，因为当您处理特性选择时，使用静态数据结构是不明智的，所以我使用字典列表[索引是 nbrOnes(state)]字典列表[关键字是“state”][关键字是“action”](python 中的字典或 dict，就像 JAVA 中的 HashMap)</p><pre class="lr ls lt lu gt my mz na nb aw nc bi"><span id="549d" class="nd ma jg mz b gy ne nf l ng nh">q_table[nbrOnes(state)][“state”][“action”]</span></pre><h1 id="2fb3" class="lz ma jg bd mb mc md me mf mg mh mi mj km mk kn ml kp mm kq mn ks mo kt mp mq bi translated">q 函数</h1><p id="526b" class="pw-post-body-paragraph kv kw jg kx b ky mr kh la lb ms kk ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">Q 学习算法基于下面给出的贝尔曼最优方程:</p><p id="274e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Q(状态，动作)= R(状态，动作)+ Gamma * Max[Q(下一个状态，所有动作)]</p><figure class="lr ls lt lu gt is gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/1b5aef912f1535dee5befec4d6c424b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*eyvquWnldzyJtyCT5cbljA.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">The Q-function explained</figcaption></figure><p id="057e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是我们每次更新表的方式，我们使用 Q 值来选择下一个状态，在这种情况下，要翻转哪些属性，这是 Q-LocalSearch 函数:</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="lv lw l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">The Q-localSearch algorithm</figcaption></figure><h1 id="2c4a" class="lz ma jg bd mb mc md me mf mg mh mi mj km mk kn ml kp mm kq mn ks mo kt mp mq bi translated">概述</h1><p id="d7eb" class="pw-post-body-paragraph kv kw jg kx b ky mr kh la lb ms kk ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">为了概括我们今天在这里所做的事情，我们谈到了 Q-learning，以及我们如何使用它来制作所谓的 Q-LocalSearch 函数，这是一种使用 Q-learning 算法进行特征选择的方法。</p><p id="e9da" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于这个模型，我们有:</p><ul class=""><li id="3045" class="nj nk jg kx b ky kz lb lc le nl li nm lm nn lq no np nq nr bi translated"><strong class="kx jh">状态</strong>:是特征的组合</li><li id="726d" class="nj nk jg kx b ky ns lb nt le nu li nv lm nw lq no np nq nr bi translated"><strong class="kx jh">动作</strong>:翻转特征</li><li id="6987" class="nj nk jg kx b ky ns lb nt le nu li nv lm nw lq no np nq nr bi translated"><strong class="kx jh">奖励</strong>:目前，我们认为状态动作的准确性(适合度)是一种奖励，但是在下一篇文章中，我们可能会更深入，看看为什么它不是定义它的最佳方式。</li></ul><p id="a251" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我真的希望你喜欢它，我试图把我认为重要的一切，如果你需要更多的细节，不要犹豫留下评论，或 PM 我。</p><p id="cff4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">是的，你可以随时查看我的<a class="ae jd" href="https://medium.com/@amineremache/the-one-with-reinforcement-learning-9bcbddd75d15" rel="noopener">上一篇文章</a>。</p><p id="28e1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lx">原载于 2018 年 12 月 26 日</em><a class="ae jd" href="https://amineremache.blogspot.com/2018/12/q-localsearch.html" rel="noopener ugc nofollow" target="_blank"><em class="lx">amineremache.blogspot.com</em></a><em class="lx">。</em></p></div></div>    
</body>
</html>