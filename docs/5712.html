<html>
<head>
<title>Optimize data preparation code using Python concurrent futures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 并发期货优化数据准备代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/optimize-data-preparation-code-using-python-concurrent-futures-97a15ac580f6?source=collection_archive---------14-----------------------#2018-11-04">https://towardsdatascience.com/optimize-data-preparation-code-using-python-concurrent-futures-97a15ac580f6?source=collection_archive---------14-----------------------#2018-11-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f198db31792bc7710c1df72b14638fa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0DcUzdzltpcPnq_GScV2oA.png"/></div></div></figure><p id="be68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">最初发表于</em>【www.easy-analysis.com】<em class="kw"/></p><blockquote class="ky kz la"><p id="779b" class="jy jz kw ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><em class="iq">只需几行代码，就能让您的 Python 代码为数据准备提供更快的执行速度。利用内置的</em> <a class="ae kx" href="https://docs.python.org/3/library/concurrent.futures.html" rel="noopener ugc nofollow" target="_blank"> <em class="iq">并发期货</em> </a></p></blockquote><p id="9b03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章将讨论并展示在执行 Python 代码进行数据准备时，如何通过添加几行额外的代码来利用所有的 CPU 内核。</p><h1 id="e542" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">常见的数据准备任务</h1><p id="282b" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">数据科学中一个非常常见的任务是数据准备。一个常见的任务可能是为模型训练准备图像。下面的代码片段演示了遍历文件夹中的图像、操作每个图像并最终保存每个更改的常见任务。</p><h1 id="59ff" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建文件 compress.py</h1><p id="09d7" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">该文件应该包含以下代码。</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="b4fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函数 compress_image()检查图像的尺寸，并根据设置的 max_dim 调整尺寸。缩放图像尺寸时，纵横比保持不变。调整大小时，图像保存在内存中，而不是在光盘上，并检查大小。如果不满足 set image_size，则使用变量 max_dim 的较低值递归调用该函数，否则，用新尺寸覆盖图像。如果你想了解更多关于库<a class="ae kx" href="https://pillow.readthedocs.io/en/5.3.x/" rel="noopener ugc nofollow" target="_blank"> PIL </a>和<a class="ae kx" href="https://docs.python.org/3/library/io.html" rel="noopener ugc nofollow" target="_blank">木卫一的信息。BytesIO </a>请访问各自的文档。</p><p id="713e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一个任务是使用这个函数来测量对任意数量的图像执行操作需要多长时间。出于测试的目的，我们将再创建一个 Python 文件。</p><h1 id="056f" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建文件 test_compress.py</h1><p id="019c" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">该文件应该包含以下代码。</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="d800" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码创建了一个特定文件夹中所有图像文件的列表，在我的例子中是“../data/test_compres/*。png”，此外，我只希望将 PNG 文件添加到列表中。最后，对于列表中的每个图像路径，调用函数 compress_image(file_name)。库时间用于测量执行文件所用的时间。</p><p id="b352" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行 test_compress.py 文件打印时间<strong class="ka ir"> 6.6042399406433105 </strong>秒。这有点慢，因此，让我们通过使用 Pythons 的一个核心库 Concurrent futures 来提高速度。</p><h1 id="5c0a" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用 Python 并发期货</h1><p id="0165" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">python 中的并发未来允许我们利用执行代码的机器上所有可用的内核。我们运行的第一个示例只使用了我的 Mac 上四个可用内核中的一个。让我们看看，如果我们使用全部四种方法，我们可以提高多少时间。</p><p id="1767" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了进行这种改进，我们需要导入一个新的库，并稍微更改文件 test_compress.py 中的代码。修改后的 test_compress.py 文件现在应该包含以下内容。</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="4403" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个版本的文件 test_compress.py 与以前的版本略有不同。导入了一个新的库 concurrent.futures。现在以不同的方式调用了进一步的函数 compress_image()。并发期货用于创建可用资源池，我们使用 map 为 list_files 中的每个项目调用函数 compress_image()。就这样，现在让我们再次运行文件。</p><p id="923a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行 test_compress.py 文件现在打印出时间<strong class="ka ir"> 3.422382116317749 </strong>秒。这是大约 90%的改进。</p><h1 id="c27d" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="3aec" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">您可能已经注意到，如果一个内核可以在大约 6 秒内完成任务，那么四个内核可以在 1.5 秒内完成。然而，这通常取决于你的代码在做什么，对于其他任务来说，它甚至可以扩展得很好。然而，仅仅通过增加两行代码就实现了<strong class="ka ir"> 90% </strong>的改进，这实在是太棒了。</p><p id="5be2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了提高 Python 代码的性能，可能还有许多其他的优化方法。一个有趣的方法是使用<a class="ae kx" href="https://cython.org/" rel="noopener ugc nofollow" target="_blank"> Cython </a>将你的 Python 代码编译成 C 代码。Cython 做得很好，你不需要知道任何 C 编程。使用 Cython 的话题不在本文的讨论范围之内，但是，这是一个值得探讨的有趣话题。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="0df2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你有兴趣了解我更多。请访问我在 LinkedIn 上的个人简介<a class="ae kx" href="https://www.linkedin.com/in/vedranmarkulj/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/vedranmarkulj/</a></p><p id="82f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读。如果你对我写的关于机器学习和类似主题的未来帖子感兴趣，请在<a class="ae kx" href="https://medium.com/@vedranmarkulj" rel="noopener"> Medium </a>和<a class="ae kx" href="https://www.linkedin.com/in/vedranmarkulj/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上关注我。更多文章即将发表。</p></div></div>    
</body>
</html>