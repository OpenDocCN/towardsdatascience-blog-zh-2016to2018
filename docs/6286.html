<html>
<head>
<title>What they don’t tell you about scaling AI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">他们没告诉你的关于扩展人工智能的事</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/scaling-ai-2be294368504?source=collection_archive---------10-----------------------#2018-12-05">https://towardsdatascience.com/scaling-ai-2be294368504?source=collection_archive---------10-----------------------#2018-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9e7ac7d11aaa1b82a54474ad084974b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VJKX1yppWAAtwpZRfWf37A.png"/></div></div></figure><p id="857d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在有 AI 的<em class="kw">一切</em>的教程。<em class="kw">如何做物体检测，图像分类，自然语言处理，建立聊天机器人</em>等。，这样的例子不胜枚举。</p><p id="acf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是当我寻找如何恰当地<em class="kw">缩放</em>人工智能的信息时，我发现内容很少。更令人惊讶的是，确实存在的少数资源似乎重复了相同的几点:</p><ul class=""><li id="702d" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">使用像<strong class="ka ir"> TensorFlow </strong>这样的可扩展框架构建您的模型</li><li id="313e" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">要么打包到你的客户端(TF.js，TF Lite，TF-slim 等。)或者将其部署为带有容器的微服务</li></ul><p id="4103" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我对第二部分更感兴趣，因为我已经开发了一个模型，但令我惊讶的是，几乎没有提供关于如何实际实现这一点的细节，关于每个解决方案的缺点的信息甚至更少。在研究了几天并在<a class="ae ll" href="http://crane.ai" rel="noopener ugc nofollow" target="_blank"> Crane.ai </a>上扩展 AI 之后，我收集了一些关于部署的更多信息<strong class="ka ir">，它们的缺点，以及如何在低层次上优化你的 TensorFlow 模型。</strong></p><figure class="ln lo lp lq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lm"><img src="../Images/70a92f8bfc33ee139b63c8d4b84c8601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IY6K0dSlX22rrP-DFNbv-w.png"/></div></div></figure><h1 id="68d1" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">把它打包到你的客户身上——糟透了！</h1><p id="bc71" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">最常用的技术之一是使用 TensorFlow.js、TF Lite 或 TensorFlow Slim 等工具将 AI 打包到您选择的客户端中。关于这些框架是如何运作的，我不会讲太多细节，而是集中讨论它们的缺点。</p><ul class=""><li id="00d6" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir">计算能力。</strong>部署这些型号的问题在于，它们需要<strong class="ka ir">巨大的内存</strong>(我指的是移动应用或浏览器的限制，即&gt;1–2GB 内存)。许多手机没有这种能力，桌面浏览器会延迟 UI 线程，同时也会降低用户计算机的速度，加热计算机，打开风扇等等。</li><li id="fe30" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">推断时间。</strong>当你在一个计算能力未知的设备上运行模型时，推理时间通常也是未知的；然而，这些不是 GPU 驱动的高 RAM 高 CPU 机器，而是运行在普通计算机上的手机、浏览器和桌面应用程序。用一些更大的模型进行推理可以轻松地<strong class="ka ir">占用一分钟</strong>，从用户体验的角度来看这是一个巨大的<strong class="ka ir">不</strong>。</li></ul><figure class="ln lo lp lq gt jr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/d6cebe4214988fae81fbcf08725b4f76.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*aDlEr5OL0Q6qFRqlVs6TAA.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">Stolen from a <a class="ae ll" href="https://www.reddit.com/r/ProgrammerHumor/comments/9cu51a/shamelessly_stolen_from_xkcd_credit_where_is_due/" rel="noopener ugc nofollow" target="_blank">Reddit parody</a> of <a class="ae ll" href="https://xkcd.com/303/" rel="noopener ugc nofollow" target="_blank">XKCD 303</a></figcaption></figure><ul class=""><li id="ddd6" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir">大文件。</strong>不幸的是<strong class="ka ir">大多数模型都存储在相当大的文件中</strong>(我们说的是几十、几百 MB)。因此，这将是缓慢和内存密集型加载，并增加了你的应用捆绑包的大小很大一部分。</li><li id="73ab" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">没有安全感。</strong>除非您使用开源模型，否则您会希望将您的 AI 和预训练检查点相对保密。不幸的是，当你把你的模型和你的应用打包在一起时，不仅你的推理代码容易被反编译，而且<strong class="ka ir">你的预训练检查点也会在包里面，很容易被窃取</strong>。</li><li id="4053" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">更难更新。</strong>如果您更新您的模型，您在客户端有两种选择。要么通过集中式管理器(即，Play Store、App Store 等)向用户发布更新。这导致<strong class="ka ir">频繁的大规模更新</strong>(对于用户来说非常烦人，并且根据他们的设置，进程可能会被中断或永远不会启动)，或者应用程序本身运行新模型检查点和元数据的获取。后者听起来好得多，但这也意味着<strong class="ka ir">你必须通过用户可能不稳定的连接下载 100MB 以上的文件</strong>；这将需要一段时间，因此你的应用程序必须至少在后台打开才能完成这个过程，而且你会产生相当大的互联网成本(这取决于你的云)。</li></ul><figure class="ln lo lp lq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/c54761cae51e0afeb1cb41d6e915596f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*suMHOOZBlZ-UB57N2wsfHQ.png"/></div></div></figure><ul class=""><li id="7be6" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir">缺乏可训练性。</strong>针对新用户数据的训练模型提供了一定程度的个性化，同时提高了其准确性，并建立了一个核心的高信号数据集。<strong class="ka ir">不幸的是，大多数设备缺乏训练模型的计算能力</strong>，即使它们有，也不可能将训练的效果传播到您的服务器或运行应用程序的其他设备。</li></ul><p id="6330" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些缺点使得在客户端上部署和维护大型神经网络几乎是不可能的，因此我们将排除这个作为扩展模型的选项。</p><h1 id="3e29" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">将其部署为云端点</h1><figure class="ln lo lp lq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/b523724e289b8d30ebf3f8f1257fd7bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*McnoXUqaeBbvXdPg.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk"><a class="ae ll" href="https://xkcd.com/908/" rel="noopener ugc nofollow" target="_blank">XKCD 908</a>, and <a class="ae ll" href="https://xkcd.com/1117/" rel="noopener ugc nofollow" target="_blank">1117</a> is also relevant</figcaption></figure><p id="28c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">云</strong>是大规模部署模型的强大工具。您可以启动完全根据您的需求定制的环境，将您的应用程序容器化，并立即进行水平扩展，同时提供可与大公司媲美的 SLA 和正常运行时间。</p><p id="f9fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于大多数 TensorFlow 模型，<strong class="ka ir">部署周期</strong>是相同的:</p><ul class=""><li id="c5ee" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">将您的图形冻结成 Protobuf 二进制文件</li><li id="0f89" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">调整您的推理代码以处理冻结的图形</li><li id="d649" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">容器化您的应用程序</li><li id="5689" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">在顶部添加一个 API 层</li></ul><p id="7929" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一块比较简单。“冻结”您的图需要创建一个 protobuf 二进制文件，其中包含与您的检查点相关的所有命名节点、权重、架构和元数据。这可以通过各种各样的工具来完成，最流行的是 TF 自己的工具来冻结任何给定了输出节点名称的图。你可以在这里找到更多关于这个技巧以及如何完成它的信息。</p><figure class="ln lo lp lq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/6cbb8d415960833fc5bc7204c20bf492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*coCipR983gR425Dtiltymw.png"/></div></div></figure><p id="45d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">调整您的推理代码也不难；在大多数情况下，您的<code class="fe nc nd ne nf b">feed_dict</code>将保持不变，主要的区别将是添加代码来加载模型，可能还有输出节点的规范。</p><p id="4008" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">容器化也很简单——只需在 Dockerfile 中设置你的环境(</strong> <a class="ae ll" href="https://www.tensorflow.org/install/docker" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">你可以使用一个 TF docker 镜像作为你的基础</strong> </a> <strong class="ka ir">)。</strong>当我们开始添加 API 层时，事情开始变得混乱。通常有两种方法可以做到这一点:</p><ul class=""><li id="a586" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir">部署运行推理脚本的缩放容器。</strong>这些容器针对输入运行一个脚本，该脚本启动一个会话并运行推理，然后输出一些东西，结果通过管道返回给您。<strong class="ka ir">这是极有问题的；</strong>对于大多数云提供商来说，添加一个操纵容器和管道进出的 API 层<strong class="ka ir">并不容易或简单</strong>(例如，AWS 有 API Gateway，但它远没有你想象的那么方便)，这是你可以使用的<strong class="ka ir">效率最低的</strong>方法。这里的问题是您在<strong class="ka ir">容器启动、硬件分配、会话启动和推理</strong>中损失了宝贵的时间。如果您让<code class="fe nc nd ne nf b">stdin</code>保持打开并保持管道输出，您将加速您的脚本，但是<strong class="ka ir">会失去可伸缩性</strong>(您现在被连接到这个容器的 STDIN，并且它也不能接受多个请求)。</li><li id="8653" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">部署运行 API 层的扩展容器。尽管在体系结构上相似，但出于几个原因，这要高效得多；通过<strong class="ka ir">将 API 层放在容器</strong>中，您可以缓解之前提出的大部分问题。虽然这需要更多的资源，但这是最小的，并不意味着垂直扩展；它<strong class="ka ir">允许每个容器保持运行，</strong>并且因为在这种情况下 API 是分散的，所以将特定的<code class="fe nc nd ne nf b">stdin</code> / <code class="fe nc nd ne nf b">stdout</code>挂接到主请求路由器没有问题。这意味着您<strong class="ka ir">摆脱了启动时间</strong>，并且<strong class="ka ir">可以在服务多个请求</strong>的同时，轻松保持速度和水平缩放</strong>。您可以使用<strong class="ka ir">负载平衡器、</strong>集中您的容器，并使用<a class="ae ll" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>来保证几乎 100%的正常运行时间并管理您的设备。简单有效！</li></ul><figure class="ln lo lp lq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/526579ce6eb427764abec12bb4b1f4db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TN5V3VRS2RrCx5bc0f4f0g.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">Deploy your fleet!</figcaption></figure><p id="5a54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过集装箱船队分散 API 的主要缺点是成本会相对较快地增加到一个大数目。不幸的是，这是人工智能不可避免的，尽管有一些方法可以减轻这一点。</p><ul class=""><li id="5c4c" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir">重用你的会话。</strong>您的车队随着负载成比例地增长和收缩，因此您的目标是最小化运行推理所需的时间，以便容器可以释放空间来处理另一个请求。一种方法是<strong class="ka ir">重用</strong> <code class="fe nc nd ne nf b"><strong class="ka ir">tf.Session</strong></code> <strong class="ka ir">和</strong> <code class="fe nc nd ne nf b"><strong class="ka ir">tf.Graph</strong></code> <strong class="ka ir">，一旦初始化就存储它们并作为全局变量</strong>传递它们；这将消除 TF 启动一个会话和构建图所花费的时间，这将大大加快您的推理任务。这种方法即使在单个容器上也是有效的，并且作为一种技术被广泛使用，以最小化资源重新分配和最大化效率。</li><li id="8df0" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">缓存输入，如果可能，缓存输出。</strong>动态编程范式在 AI 中最为重要；通过缓存输入，可以节省预处理输入或从远程获取输入所需的时间，通过缓存输出，可以节省运行推理所需的时间。这在 Python 中可以很容易地完成，<strong class="ka ir"> <em class="kw">尽管你应该问问自己这对于你的用例是否正确！</em> </strong>通常情况下，你的模型会随着时间变得更好，这将极大地影响你的输出缓存机制。在我自己的系统中，我喜欢使用我所谓的“80-20”法则。当一个模型的准确率低于 80%时，我<strong class="ka ir">不缓存任何输出。</strong>一旦达到 80%，我就开始缓存，并且<strong class="ka ir">将缓存设置为在某个精确度到期</strong>(而不是说，在某个时间点)。这样，输出会随着模型变得更加精确而变化，但在这种 80–20<em class="kw">减轻的</em>高速缓存中，性能和速度之间的权衡较少。</li></ul><figure class="ln lo lp lq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/2138e08e997b11b834569743c2eae0c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w_zf0higBNvjCEM1pVrc_A.png"/></div></div></figure><ul class=""><li id="514a" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">使用任务队列。经常有较大和较小的推理任务需要运行(在我们的例子中，较大和较小，复杂和简单的图像)。对于 UX 来说，在这里使用堆队列可能更好，并且<strong class="ka ir">处理优先级为</strong>的较小的任务，这样运行小步骤的用户只需等待该步骤，而不是等待另一个用户的较大推断先完成。(如果你在想，<em class="kw">为什么我不在这里只是水平缩放呢？，</em>你可以<strong class="ka ir">但是会增加成本</strong></li><li id="f52c" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">在带有任务队列的专用 GPU 上训练您的模型。</strong>培训是一项漫长而艰巨的任务，需要大量的资源使用，并使模型在其持续时间内不可用。如果你将每个交互反馈到你的模型中进行训练，<strong class="ka ir">考虑在一个单独的服务器上运行这个，</strong>也许用一个 GPU。一旦训练完成，您就可以将模型部署到您的容器中(在 AWS 中，您可以将您的模型库集中在 S3)。</li></ul></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="3ca5" class="lr ls iq bd lt lu np lw lx ly nq ma mb mc nr me mf mg ns mi mj mk nt mm mn mo bi translated">结论</h1><figure class="ln lo lp lq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/e325a371dce27bc91e6134c49f2255d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ADcTgNpzb1UBVKzfKeYlAA.png"/></div></div></figure><p id="f193" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">经过深思熟虑，我们提出了一个大规模部署人工智能的有效工作流程:</p><ul class=""><li id="3169" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir">冻结图形</strong>并在一个<strong class="ka ir"> API </strong>下包装推理</li><li id="09f1" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">重用</strong>会话和图形，并<strong class="ka ir">缓存</strong>输入和输出</li><li id="ec10" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">使用 Docker 封装</strong>应用程序(<strong class="ka ir">包括 API 层</strong></li><li id="c642" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">使用 Kubernetes 在您选择的云上大规模部署</strong>应用</li><li id="93da" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">从推理中分离出</strong>训练</li><li id="0d78" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">开发一个任务队列来优先处理较小的任务</li></ul><p id="419a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用这些技术，您应该能够以最小的成本和开销进行部署，同时最大限度地提高速度和效率！</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><figure class="ln lo lp lq gt jr gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/b84deccabf5ef8c6f28ce7bfc822d68d.png" data-original-src="https://miro.medium.com/v2/resize:fit:128/format:webp/0*kGtE8NfGDZwa65uq.png"/></div></figure><p id="b7f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">关于我</strong>:我是<a class="ae ll" href="https://crane.ai" rel="noopener ugc nofollow" target="_blank"> Crane.ai </a>(我们用 ai 做 app)的 AI 研究员。在过去的几年里，我一直在研究人工智能，今年花了几个月的时间研究如何扩展人工智能！我希望这是信息，如果你有任何问题，请随时询问。</p></div></div>    
</body>
</html>