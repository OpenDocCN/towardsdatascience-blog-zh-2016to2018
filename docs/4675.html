<html>
<head>
<title>Data Science with Python: Intro to Loading, Subsetting, and Filtering Data with pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 的数据科学:使用 pandas 加载、子集化和过滤数据简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-science-with-python-intro-to-loading-and-subsetting-data-with-pandas-9f26895ddd7f?source=collection_archive---------1-----------------------#2018-08-30">https://towardsdatascience.com/data-science-with-python-intro-to-loading-and-subsetting-data-with-pandas-9f26895ddd7f?source=collection_archive---------1-----------------------#2018-08-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/c9b5689421f2445739865dee2310eaf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*4IeXCHyO2IusMEI1V86ahw.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Source: <a class="ae jy" href="https://www.star-spain.com/en/blog/transittermstar-nxt-tooltips/filtering-data-records-termstar-nxt" rel="noopener ugc nofollow" target="_blank">https://www.star-spain.com/en/blog/transittermstar-nxt-tooltips/filtering-data-records-termstar-nxt</a></figcaption></figure><h1 id="93bd" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">介绍</h1><p id="68ef" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">作为数据科学家，我们经常处理大量数据。我们想要加载的数据可以用不同的方式存储。最常见的格式是<strong class="kz ir"> CSV 文件</strong>、<strong class="kz ir"> Excel 文件</strong>或<strong class="kz ir">数据库</strong>。此外，数据可以通过<strong class="kz ir"> web 服务</strong>获得。当然还有很多其他的格式。为了处理数据，我们需要用一个<strong class="kz ir">表格结构</strong>来表示它。任何表格形式的东西都排列在一个有<strong class="kz ir">行</strong>和<strong class="kz ir">列</strong>的表格中。</p><p id="71b6" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">在某些情况下，数据已经是表格了，很容易加载。在其他情况下，我们处理非结构化数据。<a class="ae jy" href="https://en.wikipedia.org/wiki/Unstructured_data" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir">非结构化数据</strong> </a>不是以预定义的方式组织的(<strong class="kz ir">纯文本</strong>、<strong class="kz ir">图像</strong>、<strong class="kz ir">音频</strong>、<strong class="kz ir">网页</strong>)。在这篇文章中，我们将着重于从 CSV(<strong class="kz ir">C</strong>omma<strong class="kz ir">S</strong>separated<strong class="kz ir">V</strong>alues)文件中加载数据。</p><h1 id="5abb" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">熊猫</h1><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/de412a2a6751d6f43a931e6fd99942f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*LQ-UAdZ0HBIFdEVj5swoeg.png"/></div></figure><p id="4444" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">Pandas 是 Wes McKinney 开发的 Python 编程语言的开源库。这个库非常高效，提供了易于使用的数据结构和分析工具。</p><h2 id="34e9" class="mf ka iq bd kb mg mh dn kf mi mj dp kj li mk ml kn lm mm mn kr lq mo mp kv mq bi translated">数据帧</h2><p id="da18" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="kz ir"> Pandas </strong>包含一个用于<strong class="kz ir">数据操作</strong>的<strong class="kz ir">快速高效对象</strong>，称为 DataFrame。熊猫的一个常用别名是<code class="fe mr ms mt mu b">pd</code>。该库可以加载许多不同格式的数据。当我们的数据是干净的和结构化的，每一行代表一个观察，每一列代表一个特征。行和列可以有<strong class="kz ir">标签</strong>。</p><p id="297a" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">在下面的例子中，为了更好地理解我们正在改变的东西，我将用透明矩形标记一些部分。此外，为了简单起见，我们将使用数据集中非常小的子集。该数据集包含给定国家和年份的移动电话用户。完整数据可在<a class="ae jy" href="https://docs.google.com/spreadsheet/pub?key=0AkBd6lyS3EmpdEhWLWtqNzljbWg4ZXV6M09JQXNGaUE&amp;output=xlsx" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我事先做了一些清理，使数据整洁。</p><p id="504b" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">这是我们想要加载到 Pandas <strong class="kz ir">数据框架</strong>中的数据。它被上传到<a class="ae jy" href="https://gist.github.com" rel="noopener ugc nofollow" target="_blank"> GitHubGist </a> web 应用程序中，并在这里以表格结构显示出来。不过，我们可以在这里看到它的 raw 格式<a class="ae jy" href="https://gist.githubusercontent.com/Ventsislav-Yordanov/a38e2a76dca556ac43e9fc9d7dc71539/raw/25cd9617a4f065019ecf9c2e216bb0c745e999ee/cellular_subscriptions_2011_year.csv" rel="noopener ugc nofollow" target="_blank"/>。同样，我们可以看到这个文件包含了<strong class="kz ir"> c </strong> omma <strong class="kz ir"> s </strong>单独的<strong class="kz ir"> v </strong>值。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="c6e8" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">为了加载这些数据，我们可以使用<code class="fe mr ms mt mu b">pd.read_csv()</code>函数。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/30d9ff2c9665bc8692ceb4dbeaffab9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5hxuPdCCZRJjxqzseaHVSg.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Loading data from a <strong class="bd nc">CSV file</strong>.</figcaption></figure><p id="f89a" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">为了创造这些例子，我用了一个 Jupyter 笔记本。如果代码单元格中的最后一行包含值，则打印该行。所以，这就是为什么我把变量<code class="fe mr ms mt mu b">cellular_data</code>放在例子的最后一行。</p><p id="29f1" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">我们可以看到数据已加载，但有些奇怪。这个<code class="fe mr ms mt mu b">Unnamed: 0</code>栏目是什么？我们的 CSV 文件中没有这样的列。在我们的例子中，这一列包含数据的<strong class="kz ir">行标签</strong> ( <strong class="kz ir">行索引</strong>)，我们必须告诉熊猫。我们可以使用<code class="fe mr ms mt mu b">index_col</code>参数做到这一点。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nd"><img src="../Images/6ce91d6384234e5faf7df047a8bf1c2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i9Q_o1NBpCdwICPTuBqqGA.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Loading data from a <strong class="bd nc">CSV file</strong> using <strong class="bd nc">index_col</strong></figcaption></figure><p id="4f62" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">在其他情况下，我们的<strong class="kz ir">数据</strong>可以是<strong class="kz ir">而没有行标签</strong>。在这些情况下，熊猫会从<code class="fe mr ms mt mu b">0</code>开始到<code class="fe mr ms mt mu b">rows — 1</code>的长度<strong class="kz ir">自动生成</strong>这些<strong class="kz ir">标签</strong>。让我们看看没有行标签的相同数据的例子。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ne"><img src="../Images/2d3300d5e6f44f17a7cd353c38eca425.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nrw1H43nvIrWpXXewAsrVQ.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Loading data from a <strong class="bd nc">CSV file</strong>.</figcaption></figure><p id="abb4" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">现在我们的数据帧看起来很好。有时，我们希望更改行标签，以便以后更容易地处理数据。在这里，我们可以将<strong class="kz ir">行标签</strong>设置为每行的<strong class="kz ir">国家代码</strong>。我们可以通过将熊猫数据帧的<code class="fe mr ms mt mu b">index</code>属性设置为一个列表来实现。列表的<strong class="kz ir">长度</strong>和行的<strong class="kz ir">长度</strong>必须与<strong class="kz ir">相同</strong>。之后，我们可以很容易地对我们的数据进行子集划分，或者使用国家代码查看给定的国家。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nf"><img src="../Images/51a0ee8dc128fa8edcef4884dab5f580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gGWTfbbekB1hb6uwQUAXAg.png"/></div></div></figure><p id="c419" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">在许多情况下，<strong class="kz ir">我们不希望手动设置索引</strong>，我们希望索引是数据帧中的<strong class="kz ir">列之一。在这种情况下，我们可以使用 DataFrame 对象的<strong class="kz ir">方法</strong>调用<code class="fe mr ms mt mu b">set_index</code>。注意<strong class="kz ir"> pandas 不会永久设置索引</strong> <strong class="kz ir">，除非我们告诉它</strong>。如果我们想永久地设置索引<strong class="kz ir"/>，我们可以使用<code class="fe mr ms mt mu b">inplace</code>参数来实现。</strong></p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ng"><img src="../Images/f5db788adca074c154f69f7c27388dde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Y9p3jnUkqz3LhyZPPeVGQ.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Setting the country column to be the index for our DataFrame.</figcaption></figure><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nd"><img src="../Images/7b9d5db0d4fe6e19e6047c799215ed4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lLi9pT1EPvag-wttiaRm4A.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Setting the country column to be the index for our DataFrame.</figcaption></figure><p id="cb9f" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">在上面的例子中，<strong class="kz ir">我们没有告诉熊猫</strong>永久设置索引，当我们打印<code class="fe mr ms mt mu b">cellular_data</code>数据帧时，我们看到<strong class="kz ir">索引没有改变</strong>。让我们用<code class="fe mr ms mt mu b">inplace</code>参数再试一次。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nh"><img src="../Images/dbdcff3263a5453f4f980d070d907be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4yxLVXKpzR_wZXJbcVJWew.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Setting (inplace) the country column to be the index for our DataFrame.</figcaption></figure><p id="812c" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">现在，我们可以清楚地看到，当我们使用<code class="fe mr ms mt mu b">inplace = True</code>时，我们的数据帧的<strong class="kz ir">索引</strong>被<strong class="kz ir">永久地</strong>改变<strong class="kz ir"/>。</p><h2 id="f02d" class="mf ka iq bd kb mg mh dn kf mi mj dp kj li mk ml kn lm mm mn kr lq mo mp kv mq bi translated">索引和选择数据</h2><p id="293c" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">有许多方法可以从数据框中选择数据。在这篇博文中，我们将看到如何使用<strong class="kz ir">方括号</strong>和方法<strong class="kz ir"> loc </strong>和<strong class="kz ir"> iloc </strong>来实现这一点。</p><p id="40de" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">使用<strong class="kz ir">方括号</strong>，您可以从行中选择选项，也可以从列中选择选项。对于一个<strong class="kz ir">行选择</strong>，我们可以使用一个<strong class="kz ir">索引列表</strong>或者一个<strong class="kz ir">切片</strong>。我们可以像这样使用<strong class="kz ir">切片</strong>来选择行:<code class="fe mr ms mt mu b">sliceable[start_index:end_index:step]</code></p><p id="0008" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">end_index 不包含。我已经在之前的一篇名为<a class="ae jy" rel="noopener" target="_blank" href="/python-basics-for-data-science-6a6c987f2755">数据科学 Python 基础</a>的博客文章中写过关于切片的内容。可以快速看一下“<strong class="kz ir">子集列表</strong>”<strong class="kz ir">部分</strong>了解一下。虽然那里的例子都是带列表的，<strong class="kz ir">这里的想法</strong>和<strong class="kz ir">是一样的</strong>。我们这里只使用数据帧，它们也是<strong class="kz ir">可切片的</strong>。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/5e8c81d11ba5ec1db8d9340baf9042fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hk6Sa0Ewiiaoh_mpBvJKPQ.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Select all rows.</figcaption></figure><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/73e47f762a9163eac5e8ba825f5f650f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XwT6foMFZqCPju82NwLVTw.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Select the first 2 rows.</figcaption></figure><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/3eae32e005997feb1e59b347f4b1f3c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AtGxSZpvtTmk47mkf3ShaQ.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Select the all rows from the third to the end.</figcaption></figure><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/413b46dfc9bfe06553a978b182a0bb71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5DLPdtq7stXL-iAZseM5PA.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Select the second row.</figcaption></figure><p id="3d6b" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">对于一个选择的<strong class="kz ir">列，我们可以使用一个包含</strong>所需<strong class="kz ir">列</strong>的<strong class="kz ir">列表。如果我们只将<strong class="kz ir">一列作为字符串</strong>而不是列表传递，结果将是<a class="ae jy" href="https://pandas.pydata.org/pandas-docs/version/0.22/generated/pandas.Series.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir">熊猫系列</strong> </a>。熊猫系列是一个<strong class="kz ir">一维数组，可以标为</strong>。如果我们将<strong class="kz ir"> 2 个或更多系列</strong>粘贴在一起，我们将创建一个<strong class="kz ir">数据框架</strong>。在某些情况下，我们可能只想选择一列，但将数据保存在 DataFrame 中。在这种情况下，我们可以传递一个只有一个列名的列表。</strong></p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/f480b9efef4a45bb156eb73fd330038c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zgJOjYeNUKiel5B7jBk7mA.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Select the “country” column only as series.</figcaption></figure><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/14f9ea6de2de64c4bf41fe4e7ee30ee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LHc7K5QVvTHvLJPOrieg8Q.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Select the “country” and “cellular_subscriptions” columns.</figcaption></figure></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="db20" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated"><strong class="kz ir">方括号</strong>很有用，但是它们的<strong class="kz ir">功能有限</strong>。我们可以从给定的数据帧中只选择<strong class="kz ir">列</strong>或<strong class="kz ir">行</strong>。在许多情况下，我们需要同时选择列和行。<strong class="kz ir"> loc </strong>和<strong class="kz ir"> iloc </strong>方法给了我们这种能力。</p><p id="a5cd" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated"><strong class="kz ir"> loc </strong>方法允许我们根据<strong class="kz ir">标签</strong>选择数据的行和列。首先，你指定左侧的<strong class="kz ir">行标签</strong> <strong class="kz ir">，然后你指定右侧</strong>的列标签<strong class="kz ir">。<strong class="kz ir"> iloc </strong>允许我们做同样的事情，但是基于我们数据帧的<strong class="kz ir">整数位置</strong>。</strong></p><p id="9727" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">如果我们想选择所有的行或列，我们可以简单地输入<code class="fe mr ms mt mu b">:</code>来选择行或列。同样，如果我们想要选择<strong class="kz ir">特定行</strong>而<strong class="kz ir">所有列</strong>，我们可以只传递<strong class="kz ir">行标签</strong>。</p><p id="b3ad" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">用例子理解比较容易，那就来看一些吧。在这些例子中，我们将比较这两种方法的用法。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/7c7dd049becce855679bd6aacf10c756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YH4s6gp1P4B5HEZkKfyr7A.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Select the <strong class="bd nc">first row</strong> as <strong class="bd nc">Series</strong>.</figcaption></figure><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/0a9848f180c55fa60d45c22c15285960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lkf_C7SnXQRP3iGgi7se4w.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Select the <strong class="bd nc">first row</strong> as <strong class="bd nc">DataFrame</strong>.</figcaption></figure><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/ef72d664d3d70aaaa71533b9ca02be72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sENC524O0f9WFZmHuuxVCw.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Select the rows for <strong class="bd nc">Bulgaria </strong>and <strong class="bd nc">Romania</strong>.</figcaption></figure><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/a777dac9eeb7f41d58ef3458ddf321dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mUpWBL9C7AuO8fY6LyCi0Q.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Select the rows for <strong class="bd nc">Russia</strong> and <strong class="bd nc">the United Kingdom</strong> and the “<strong class="bd nc">year</strong>” and “<strong class="bd nc">cellular_subscriptions</strong>” <strong class="bd nc">columns</strong>.</figcaption></figure><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/34950888248558859720fe4363fe1032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*22GrCZGI2kGAVM45uNglGQ.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Select <strong class="bd nc">all the rows</strong> and the “<strong class="bd nc">year</strong>” and “<strong class="bd nc">cellular_subscriptions</strong>” <strong class="bd nc">columns</strong>.</figcaption></figure><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/86992b3af7ff548de72698f18afa3866.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*793Ro_LGqIahjr7Aaej5VQ.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Select the <strong class="bd nc">all the columns</strong> and the rows for <strong class="bd nc">Bulgaria, Russia, </strong>and <strong class="bd nc">Denmark</strong>.</figcaption></figure><h1 id="c46c" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">Python 中的比较运算符</h1><p id="7f6a" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="kz ir">比较运算符</strong>可以告诉我们 2 个值<strong class="kz ir">如何将</strong>相互关联。在很多情况下，<strong class="kz ir"> Python 无法告诉我们不同类型的 2 个值如何相互关联</strong>，但也有一些<strong class="kz ir">例外</strong>。比如我们可以比较<strong class="kz ir">浮点数和整数</strong>。需要记住的是，我们可以比较<strong class="kz ir">布尔值和</strong>整数。<code class="fe mr ms mt mu b">True</code>对应<strong class="kz ir"> 1 </strong>，<code class="fe mr ms mt mu b">False</code>对应<strong class="kz ir"> 0 </strong>。这些运算符非常简单。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/793ff570da537041b7b6a34e6db8386d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*8SQW612BQ3r2dzAnzvvtzw.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">The comparison operators in Python.</figcaption></figure><p id="9325" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">让我们看一些非常简单的例子。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Simple Comparison Operators</figcaption></figure><h1 id="ef95" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">过滤熊猫数据帧</h1><p id="2634" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="kz ir">比较运算符</strong>可用于熊猫<strong class="kz ir">系列</strong>。这可以帮助我们根据特定条件过滤我们的数据<strong class="kz ir">。我们可以对序列使用比较运算符，结果将是一个<strong class="kz ir">布尔序列</strong>。如果满足条件，这些系列的每一项将为<code class="fe mr ms mt mu b">True</code>，否则为<code class="fe mr ms mt mu b">False</code>。有了这些布尔序列后，我们可以应用一个<strong class="kz ir">行选择</strong>来得到一个过滤后的数据帧。</strong></p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/b0d58b25a1bfa02a2f206ea35b3480a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aD1rAZCpS5GUiFob2S8pnw.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Creating a <strong class="bd nc">boolean series</strong> called <strong class="bd nc">is_small_subscr</strong></figcaption></figure><p id="caeb" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">注意，我们已经使用了<strong class="kz ir">的另一种语法</strong>在这里<strong class="kz ir">得到了</strong> <code class="fe mr ms mt mu b">cellular_subcription</code> <strong class="kz ir">列</strong>。<code class="fe mr ms mt mu b">DataFrame[column_name]</code>和<code class="fe mr ms mt mu b">DataFrame.column_name</code>代码块返回<strong class="kz ir">相同的结果</strong>。</p><p id="1644" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">但是，要小心使用<strong class="kz ir">点语法</strong>(在这些示例中使用)，因为您的列可能与<strong class="kz ir"> DataFrame 的方法</strong>同名。例如，如果我们有一个名为“<strong class="kz ir"> min </strong>”的列，我们就不能使用点语法从该列中获取值。那是因为 DataFrame 对象有一个名为“<strong class="kz ir"> min </strong>”的方法。现在让我们看看如何使用上面的布尔序列来过滤我们的数据帧。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/3da2e496f1a3399c62ba4ca57cf36311.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CEXwfXCm_aidMyYBL2k1IQ.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk"><strong class="bd nc">Filtering</strong> the <strong class="bd nc">DataFrame</strong> using the <strong class="bd nc">boolean series</strong> from the <strong class="bd nc">previous example</strong></figcaption></figure><p id="df9b" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">让我们看另一个例子。假设我们希望<strong class="kz ir">获得所有记录，其中</strong>国家<strong class="kz ir">是<strong class="kz ir">英国</strong>。</strong></p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/ebae3d4ba0a6e294b67d44813f0649d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q14JZE0OSI5KtduWUr8rbg.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Get <strong class="bd nc">all records</strong> where the <strong class="bd nc">country</strong> <strong class="bd nc">is </strong>the <strong class="bd nc">United Kingdom</strong></figcaption></figure><h1 id="96c7" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">布尔运算符</h1><p id="b646" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">既然我们知道了如何生成满足某些条件的布尔序列，我们现在可以对它们使用<strong class="kz ir">布尔运算符</strong>来创建更多的<strong class="kz ir">复杂过滤</strong>。</p><p id="d0b3" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">有<strong class="kz ir"> 3 </strong>种类型的<strong class="kz ir">布尔运算</strong></p><ul class=""><li id="012f" class="nr ns iq kz b la lv le lw li nt lm nu lq nv lu nw nx ny nz bi translated"><strong class="kz ir">和</strong>——取 2 个布尔值，如果<strong class="kz ir">和</strong>都是<strong class="kz ir">则返回<code class="fe mr ms mt mu b"><strong class="kz ir">True</strong></code>值</strong> <code class="fe mr ms mt mu b"><strong class="kz ir">True</strong></code>。这个操作符是一个<strong class="kz ir">短路</strong>，如果第一个参数是<code class="fe mr ms mt mu b"><strong class="kz ir">True</strong></code>，它只计算第二个参数。</li><li id="b6f2" class="nr ns iq kz b la oa le ob li oc lm od lq oe lu nw nx ny nz bi translated"><strong class="kz ir">或</strong> -取 2 个布尔值，如果<strong class="kz ir">中至少有一个</strong>为 T1，则返回<code class="fe mr ms mt mu b"><strong class="kz ir">True</strong></code>。这个操作符也是一个短路符<strong class="kz ir"/>，如果第一个参数是<code class="fe mr ms mt mu b"><strong class="kz ir">False</strong></code>，它只计算第二个参数。</li><li id="f8d8" class="nr ns iq kz b la oa le ob li oc lm od lq oe lu nw nx ny nz bi translated"><strong class="kz ir">非</strong>——取一个布尔值，返回对面的<strong class="kz ir">。该运算符优先级低于非布尔运算符。例如，<code class="fe mr ms mt mu b">not x == y</code>被解释为<code class="fe mr ms mt mu b">not (x == y)</code>，而<code class="fe mr ms mt mu b">x == not y</code>是一个语法错误。还有就是当我们需要<strong class="kz ir">组合不同的布尔运算</strong>然后想要<strong class="kz ir">对结果</strong>求反时常用的<strong class="kz ir">。</strong></strong></li></ul><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk"><strong class="ak">Simple Boolean Operations</strong></figcaption></figure><h1 id="1645" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">多条件子集化</h1><p id="b04d" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">当我们想要通过<strong class="kz ir">多个条件</strong>过滤我们的数据帧时，我们可以使用<strong class="kz ir">布尔运算符</strong>。这里需要注意的一点是，当我们想要对熊猫使用布尔运算符时，我们必须<strong class="kz ir">如下使用它们</strong>:</p><ul class=""><li id="d376" class="nr ns iq kz b la lv le lw li nt lm nu lq nv lu nw nx ny nz bi translated"><code class="fe mr ms mt mu b">&amp;</code>用于<strong class="kz ir">和</strong></li><li id="9e8f" class="nr ns iq kz b la oa le ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe mr ms mt mu b">|</code>为<strong class="kz ir">或</strong></li><li id="0ab3" class="nr ns iq kz b la oa le ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe mr ms mt mu b">~</code>为<strong class="kz ir">而非</strong></li></ul><p id="8bf2" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">当我们对两个大小相同的布尔序列应用布尔运算时，布尔运算将适用于每一对。</p><h2 id="450c" class="mf ka iq bd kb mg mh dn kf mi mj dp kj li mk ml kn lm mm mn kr lq mo mp kv mq bi translated">使用“与”运算符</h2><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/245a51908d5878788c21d706cf3a2aa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FxVsDqs6vZZxcl5FGHEb4Q.jpeg"/></div></div></figure><p id="736f" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">我们可以看到 pandas 不使用<code class="fe mr ms mt mu b">and</code>操作符，它需要<code class="fe mr ms mt mu b"><strong class="kz ir">&amp;</strong></code>操作符。现在，让我们再试一次。这里的目标是只得到那些<strong class="kz ir">多于</strong> <strong class="kz ir"> 240 </strong>乘客<strong class="kz ir">而</strong> <strong class="kz ir">少于</strong> <strong class="kz ir"> 300 </strong>乘客的航班。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/c5d49f7d1ae0539f31e25c735850cd44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_10hNZQzCioOYqFF6gQn1Q.jpeg"/></div></div></figure><h2 id="2a80" class="mf ka iq bd kb mg mh dn kf mi mj dp kj li mk ml kn lm mm mn kr lq mo mp kv mq bi translated">使用“或”运算符</h2><p id="2323" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">让我们找出所有<strong class="kz ir">低于</strong> <strong class="kz ir"> 200 </strong> <strong class="kz ir">或</strong> <strong class="kz ir">大于 375 名乘客</strong>的航班。记住，对于<strong class="kz ir">或</strong>操作符，我们使用<strong class="kz ir">管道</strong> <code class="fe mr ms mt mu b"><strong class="kz ir">|</strong></code> <strong class="kz ir">字符</strong>。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/86dbd9cad2238971eac227dc4a93c2aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Omf4xEOBfPcj1fvwWkz6FA.jpeg"/></div></div></figure><h2 id="e3d7" class="mf ka iq bd kb mg mh dn kf mi mj dp kj li mk ml kn lm mm mn kr lq mo mp kv mq bi translated">使用 not 运算符反转条件</h2><p id="ae77" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在某些情况下，我们希望<strong class="kz ir">否定</strong>我们的<strong class="kz ir">条件</strong>。在这种情况下，我们可以使用<strong class="kz ir">而不是</strong>操作符。对于这个操作符，我们使用<strong class="kz ir">波浪号</strong> <code class="fe mr ms mt mu b"><strong class="kz ir">~</strong></code> <strong class="kz ir">字符</strong>。</p><p id="71ff" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">假设我们想得到 11 月的<strong class="kz ir">而不是</strong> <strong class="kz ir">的所有航班。</strong></p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/6aa20dedd2258239a689820304617ce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wF6qIpcFmB2YQlIbsKeh5Q.jpeg"/></div></div></figure><h2 id="1677" class="mf ka iq bd kb mg mh dn kf mi mj dp kj li mk ml kn lm mm mn kr lq mo mp kv mq bi translated">复杂条件</h2><p id="c736" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们可以基于<strong class="kz ir">非常具体的条件</strong>进行更加<strong class="kz ir">复杂的过滤</strong>。</p><p id="0486" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">让我们看看 1952 年和 1954 年 11 月 22 日在 T21 的所有航班。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/d2c108f435124712db7a014762393b32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eoo8Y1b802f4X3KV_oy1DA.jpeg"/></div></div></figure><p id="456e" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">现在，让我们得到 1952 年和 1954 年之间的所有航班，月份是八月或九月。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/8049560b346450ad0bd9de4cdc0e032e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nkUAv-5iEgIZmhL6uREe-A.jpeg"/></div></div></figure><h2 id="ca90" class="mf ka iq bd kb mg mh dn kf mi mj dp kj li mk ml kn lm mm mn kr lq mo mp kv mq bi translated">isin 方法</h2><p id="e55c" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">假设我们想要比较单个列与多个值的<strong class="kz ir">相等。假设我们想要得到以下月份的所有航班:<strong class="kz ir">二月</strong>、<strong class="kz ir">八月</strong>和<strong class="kz ir">九月</strong>。实现这一点的一种方法是像这样使用多个<code class="fe mr ms mt mu b">or</code>条件。</strong></p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/701828f5dc40f56ed0f0e3b392fa4ca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9D8kMFC3IhnOIk4kGVpj5g.jpeg"/></div></div></figure><p id="440e" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">有一个<strong class="kz ir">重复码</strong>这是<strong class="kz ir">繁琐的</strong>。使用<strong class="kz ir"/><code class="fe mr ms mt mu b"><strong class="kz ir">isin</strong></code><strong class="kz ir">方法</strong>还有一种<strong class="kz ir">更好的方法</strong>可以达到同样的效果。我们需要传递一个列表或者设置<strong class="kz ir">值</strong>给这个方法，它将返回想要的<strong class="kz ir">布尔序列</strong>。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/fd2c21fa2b4a3842958fdcc0de24f077.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RzevrcIontou0U9D4XQc4g.jpeg"/></div></div></figure><p id="3efc" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">当然，<strong class="kz ir">我们可以把这个方法返回的<strong class="kz ir">布尔级数</strong>和其他布尔级数</strong>组合起来。</p><p id="cef0" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">假设我们想得到 1954 年<strong class="kz ir"/>和 2 月<strong class="kz ir"/>、<strong class="kz ir">8 月</strong>和<strong class="kz ir">9 月</strong>的航班。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/e24a4db8c47bf2f8da99dad8e7b0b353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*toK1k0QCP0vG2mjVdGlNjg.jpeg"/></div></div></figure><h2 id="d7d2" class="mf ka iq bd kb mg mh dn kf mi mj dp kj li mk ml kn lm mm mn kr lq mo mp kv mq bi translated">between 方法</h2><p id="ec14" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">当我们想要<strong class="kz ir">选择一个范围</strong>内的值时，这个方法可以使我们的代码更干净。<strong class="kz ir">代替</strong>的写法<strong class="kz ir"> 2 布尔条件</strong>，我们可以用这个方法。</p><p id="949e" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">假设我们想要得到 1955 年到 1960 年之间的所有航班<strong class="kz ir">。</strong></p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/015775fb4dfca6d4af0b387b3b03aaa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PFon0WjE3OVNuUnyRvqK7g.jpeg"/></div></div></figure><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/71606660f88400281cd8cc1ab286405c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*paP7C9YQ_eujRLLq5KKPRQ.jpeg"/></div></div></figure><p id="425b" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">同样，我们可以将这种方法与另一种条件过滤相结合。</p><p id="a4a5" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">让我们得到所有在 1955 年和 1960 年之间<strong class="kz ir">并且在 10 月</strong>的航班。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/98db4b4fdb1a6d92c7de021c5df95ab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXYe2HLX5hZdXG7ixbvULg.jpeg"/></div></div></figure><h2 id="0a41" class="mf ka iq bd kb mg mh dn kf mi mj dp kj li mk ml kn lm mm mn kr lq mo mp kv mq bi translated">isnull 和 isna 方法</h2><p id="843f" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这个<code class="fe mr ms mt mu b"><strong class="kz ir">isna</strong></code>方法指示值是否缺失(数值数组中的<code class="fe mr ms mt mu b"><strong class="kz ir">NaN</strong></code>，对象数组中的<code class="fe mr ms mt mu b"><strong class="kz ir">None</strong></code>或<code class="fe mr ms mt mu b"><strong class="kz ir">NaN</strong></code>，datetimelike 中的<code class="fe mr ms mt mu b"><strong class="kz ir">NaT</strong></code>)。<code class="fe mr ms mt mu b"><strong class="kz ir">isnull</strong></code>方法是<code class="fe mr ms mt mu b"><strong class="kz ir">isna</strong></code>方法的别名。这意味着<strong class="kz ir">这两种方法完全相同</strong>，但是名称不同。</p><p id="0e58" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">我已经改变了我们使用的航班数据框架。在<strong class="kz ir">月</strong>列中有一些<code class="fe mr ms mt mu b"><strong class="kz ir">NaN</strong></code>值。让我们来看看如何获取<strong class="kz ir">有<strong class="kz ir">个月</strong>缺失的所有记录</strong>。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/b63d37c1e26f5c681abf6adfdc7a2f8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tpbCaMZRpAIbw3oYLeqWcg.jpeg"/></div></div></figure><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/462c31db748194ab35ff0b1e54adb7f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*phr_b4bBZQlSI7sEYtv3iA.jpeg"/></div></div></figure><p id="3375" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">在许多情况下，我们希望得到没有缺失值的数据。让我们设法得到没有错过月份的航班。我们可以使用带有<code class="fe mr ms mt mu b"><strong class="kz ir">~</strong></code> <strong class="kz ir">字符</strong>的<strong class="kz ir"> not 运算符</strong>对<code class="fe mr ms mt mu b"><strong class="kz ir">isna</strong></code>方法返回的布尔序列<strong class="kz ir">求反。</strong></p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/2097241c9c40474ed9ce65740a504605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lCvXUdMYMb4b1r8FFTbiYA.jpeg"/></div></div></figure><h2 id="c2c3" class="mf ka iq bd kb mg mh dn kf mi mj dp kj li mk ml kn lm mm mn kr lq mo mp kv mq bi translated">notna 方法</h2><p id="5dd7" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">还有一种方法叫<code class="fe mr ms mt mu b"><strong class="kz ir">notna</strong></code>。此方法是 <code class="fe mr ms mt mu b"><strong class="kz ir">isna</strong></code> <strong class="kz ir">方法</strong>的 <strong class="kz ir">对面的<strong class="kz ir">。使用这种方法，我们可以获得与上一个示例相同的结果。</strong></strong></p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/34d5f256ec68c55277a0d298aeedca58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CyGGRInBkX6CZrHnIhWZ5g.jpeg"/></div></div></figure><h2 id="396b" class="mf ka iq bd kb mg mh dn kf mi mj dp kj li mk ml kn lm mm mn kr lq mo mp kv mq bi translated">通过一行中的条件进行子集设置</h2><p id="b620" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们现在看到的所有例子都可以用<strong class="kz ir">一行</strong>写出来。有人喜欢，有人讨厌。当我们通过<strong class="kz ir">只设置一个条件</strong>时，在很多情况下，在一行中编写我们的过滤器会更好更容易。</p><p id="3485" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">我们先来看一个只有一个条件的子集化例子。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/3a9be3ba0722e431b0a5816cf0dc269c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5lGtlIQFk2D-e0H-eY3ohw.jpeg"/></div></div></figure><h2 id="f0ec" class="mf ka iq bd kb mg mh dn kf mi mj dp kj li mk ml kn lm mm mn kr lq mo mp kv mq bi translated">通过一行中的多个条件进行子集设置</h2><p id="21de" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在某些情况下，用一行写一个<strong class="kz ir">简单的表达式还行，但在另一些情况下，就非常<strong class="kz ir">不可读</strong>。我这里的建议是<strong class="kz ir">把简单的写一行</strong>复杂的写多行</strong>。如果你的行很长，它可能<strong class="kz ir">不可读</strong>，所以要小心。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/1de0c9cf0057af01b3b3172a33d1aba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kjhWWsXefFjIxKL7yPPhVg.jpeg"/></div></div></figure><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/be089e1a8ced9d9b5afcb50f3258ac55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oJEpnTNr0L7Sw6lY775uNw.jpeg"/></div></div></figure><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/d3a0b5a103cbe0248fc10f5986e99970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fg0akh-A0yEfKeb3SMzPag.jpeg"/></div></div></figure><h2 id="3fae" class="mf ka iq bd kb mg mh dn kf mi mj dp kj li mk ml kn lm mm mn kr lq mo mp kv mq bi translated">使用<code class="fe mr ms mt mu b">.loc</code>方法对布尔序列进行子集化。</h2><p id="14e2" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">还记得<code class="fe mr ms mt mu b"><strong class="kz ir">.loc</strong></code>法吗？我们可以用这种方法根据<strong class="kz ir">标签</strong>选择行和列。好的一面是我们可以传递<strong class="kz ir">布尔序列</strong>而不是传递行或列选择的标签，这样就可以了。</p><p id="d35e" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">我们在上面的例子中使用的所有生成的布尔序列都可以传递给行选择。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/5ccb592f823fc8ed0636a557c4063985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lEJgk1Hvz2H5qrbA95iNNw.jpeg"/></div></div></figure><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/2f7bb6b14144aca4481ee21300a1eddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8nZ4xJnjcfyOfcZ8tTlyEQ.jpeg"/></div></div></figure><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/73329579dd8a1c360a16e3427e4100f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iUTIl95o21lVXcEXs63r2A.jpeg"/></div></div></figure><p id="5211" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">注意，如果我们<strong class="kz ir">不使用</strong> <code class="fe mr ms mt mu b"><strong class="kz ir">loc</strong></code> <strong class="kz ir">方法</strong>进行列选择 <strong class="kz ir">，那么<strong class="kz ir">的结果与使用方括号</strong> <code class="fe mr ms mt mu b"><strong class="kz ir">[]</strong></code>进行<strong class="kz ir">子集化的</strong>是相同的。</strong></p><h1 id="f083" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">文章注释</h1><p id="f6fd" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">为了简单起见，本文中使用的数据集非常小。实际上，我们需要处理的数据集要大得多。但是不管您是在处理 100 MB 还是 10 GB 的数据集，子集化总是一种有用的技术！</p><h1 id="7010" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">练习</h1><p id="fc8c" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我已经创建了一个<strong class="kz ir"> Jupyter 笔记本文件</strong>，里面有一些关于<strong class="kz ir">加载和子集化数据</strong>的练习。如果你想检查你的技能，你可以从这个库下载。该存储库还包含另一个 Jupyter 笔记本文件，其中包含<strong class="kz ir">解决方案</strong>。</p><h1 id="3307" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated"><strong class="ak">数据资源</strong></h1><ul class=""><li id="9caa" class="nr ns iq kz b la lb le lf li of lm og lq oh lu nw nx ny nz bi translated">手机:<a class="ae jy" href="https://www.gapminder.org/data/" rel="noopener ugc nofollow" target="_blank">gapminder.org</a></li><li id="3789" class="nr ns iq kz b la oa le ob li oc lm od lq oe lu nw nx ny nz bi translated">航班:<a class="ae jy" href="https://github.com/mwaskom/seaborn-data" rel="noopener ugc nofollow" target="_blank">GitHub seaborn 数据库示例</a></li></ul><h1 id="45a0" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">我的其他博客文章</h1><p id="3015" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">你也可以看看我以前的博文。</p><ul class=""><li id="1f99" class="nr ns iq kz b la lv le lw li nt lm nu lq nv lu nw nx ny nz bi translated"><a class="ae jy" href="https://medium.com/@ventsislav94/jypyter-notebook-shortcuts-bf0101a98330" rel="noopener"> Jupyter 笔记本快捷键</a></li><li id="356e" class="nr ns iq kz b la oa le ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae jy" href="https://medium.com/@ventsislav94/jypyter-notebook-shortcuts-bf0101a98330" rel="noopener">数据科学的 Python 基础知识</a></li><li id="fc83" class="nr ns iq kz b la oa le ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae jy" rel="noopener" target="_blank" href="/data-science-with-python-intro-to-data-visualization-and-matplotlib-5f799b7c6d82">Python 数据科学:Matplotlib 数据可视化简介</a></li><li id="86cd" class="nr ns iq kz b la oa le ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae jy" rel="noopener" target="_blank" href="/introduction-to-natural-language-processing-for-text-df845750fb63">文本自然语言处理入门</a></li></ul><h1 id="f19c" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">时事通讯</h1><p id="c567" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果你想在我发表新的博客文章时得到通知，你可以订阅我的<a class="ae jy" href="https://buttondown.email/Ventsislav" rel="noopener ugc nofollow" target="_blank">时事通讯</a>。</p><h1 id="c5df" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated"><strong class="ak">领英</strong></h1><p id="3d59" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这是我在 LinkedIn 上的简介，如果你想和我联系的话。</p><h1 id="2676" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">最后的话</h1><p id="c4c0" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">谢谢你的阅读。你喜欢这篇文章吗？如果你喜欢，请按住鼓掌按钮👏并分享给你的朋友。</p></div></div>    
</body>
</html>