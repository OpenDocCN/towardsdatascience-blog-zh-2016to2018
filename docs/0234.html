<html>
<head>
<title>K nearest neighbors, it’s purpose and how to use it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">k 最近邻，它的用途和如何使用它</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/k-nearest-neighbors-its-purpose-and-how-to-use-it-36fa927acc64?source=collection_archive---------3-----------------------#2017-04-03">https://towardsdatascience.com/k-nearest-neighbors-its-purpose-and-how-to-use-it-36fa927acc64?source=collection_archive---------3-----------------------#2017-04-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f16d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于那些不知道 k 最近邻是什么的人来说，这是一个预测模型。它的目的是什么，为什么使用它？这些是我们将在这篇文章中深入探讨的问题。</p><p id="51e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了让这个模型工作，数据必须有一个距离的概念。用外行人的话来说，我们需要能够用图表表示我们的数据。</p><p id="4d18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个模型将是非线性的，可以用在课堂上。我所说的类是指它可以帮助确定一个数据点是属于一个类还是另一个类。一个很好的例子是根据收入和年龄来决定某人是共和党人还是民主党人。该模型将被证明是有用的，因为本质上它查看邻近的数据点来确定这个新数据点将落入什么样的位置。</p><p id="b6bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们知道了为什么这是有用的，让我们给出一个用 python 来做这件事的例子。</p><p id="f3e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个例子将使用花瓣宽度、花瓣长度、萼片长度和萼片宽度来尝试确定花的分类</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="60b6" class="ku kv iq kq b gy kw kx l ky kz"><strong class="kq ir">import</strong> <strong class="kq ir">pandas</strong> <strong class="kq ir">as</strong> <strong class="kq ir">pd</strong><br/>url = 'http://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data'<br/>col_names = ['sepal_length', 'sepal_width', 'petal_length', 'petal_width', 'species']<br/>iris = pd.read_csv(url, header=None, names=col_names)</span></pre><p id="2927" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我导入 pandas(一个 python 库)，然后读入我的数据集并设置列名。这将我的数据放入一个很好的数据框架中，可以很容易地进行分析。</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="de2c" class="ku kv iq kq b gy kw kx l ky kz"><strong class="kq ir">from</strong> <strong class="kq ir">matplotlib.colors</strong> <strong class="kq ir">import</strong> ListedColormap<br/>cmap_bold = ListedColormap(['#FF0000', '#00FF00', '#0000FF']</span></pre><p id="fc83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码块引入了颜色绘图能力。</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="9813" class="ku kv iq kq b gy kw kx l ky kz">iris["Species_number"] = iris.species.map({'Iris-setosa':0,'Iris-versicolor':1,'Iris-virginica':2 })</span></pre><p id="0232" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我制作了一个新的列，将每个物种映射到不同的 bin，bin 为 0、1 或 2。</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="f7fb" class="ku kv iq kq b gy kw kx l ky kz">iris.plot(kind = 'scatter', x = "petal_length", y = "petal_width", c ="Species_number" ,colormap= cmap_bold )</span></pre><figure class="kl km kn ko gt lb gh gi paragraph-image"><div class="gh gi la"><img src="../Images/e1ad95dab6c8a1cda541a0571176e8b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*_S-NpRtAdAbz-NKUpDKumw.png"/></div></figure><p id="218d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这显示踏板宽度和花瓣长度，以确定物种。每个物种都有不同的颜色。</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="be3a" class="ku kv iq kq b gy kw kx l ky kz">feature_cols = ['sepal_length', 'sepal_width', 'petal_length', 'petal_width'] <br/>X = iris[feature_cols]<br/>y = iris.Species_number</span></pre><p id="9de8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这使得我们的 X 是萼片长度，萼片宽度，花瓣长度，花瓣宽度。我们的 Y 是有三个箱的物种栏。我们试图使用 X 特征来确定 Y</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="424e" class="ku kv iq kq b gy kw kx l ky kz"><strong class="kq ir">from</strong> <strong class="kq ir">sklearn.model_selection</strong> <strong class="kq ir">import</strong> train_test_split<br/>X_train, X_test, y_train, y_test = train_test_split(X, y)</span></pre><p id="9077" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于任何一个好的模型，你都需要做一个训练测试来避免过度拟合你的模型。这是把你的数据分成一个训练集，然后是一个测试集来测试你的模型有多好。k 最近邻(也称为 KNN)是一个懒惰模型，这意味着它不使用训练数据点来做任何<em class="le">泛化。所以</em>我们不打算训练一个模特。你可能会问，为什么要进行列车试运行？因为我们仍然需要那个测试集来测试这 70%,看看我们的 X 变量是否是好的预测器。</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="50f7" class="ku kv iq kq b gy kw kx l ky kz"><strong class="kq ir">from</strong> <strong class="kq ir">sklearn.neighbors</strong> <strong class="kq ir">import</strong> KNeighborsClassifier<br/><strong class="kq ir">from</strong> <strong class="kq ir">sklearn</strong> <strong class="kq ir">import</strong> metrics<br/><em class="le"># make an instance of a KNeighborsClassifier object</em><br/>knn = KNeighborsClassifier(n_neighbors=1)<br/>knn.fit(X_train, y_train)</span></pre><p id="45db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们从 sklearn.neighbors 导入，以便能够使用我们的 KNN 模型。使用 KNeighborsClassifier，然后使用里面的参数确定您希望您的数据点查看多少个最近邻。没有经验法则告诉你应该看多少个邻居。确定要查看多少个相邻要素的最佳方法是测试一系列相邻要素，并确定哪一个具有最佳精度。</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="7692" class="ku kv iq kq b gy kw kx l ky kz">y_pred_class = knn.predict(X_test)<strong class="kq ir"><br/>print</strong> metrics.accuracy_score(y_test, y_pred_class)</span></pre><p id="e530" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将让您看到准确性分数，因为我们只有 1 个最近邻要检查，所以我们的分数最终是 1(也称为 100%)，这有可能被过度拟合。</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="1081" class="ku kv iq kq b gy kw kx l ky kz"><strong class="kq ir">def</strong> length(X, y):<br/>    empty_list = []<br/>    <strong class="kq ir">for</strong> n <strong class="kq ir">in</strong> range(1,100):<br/>        X_train, X_test, y_train, y_test = train_test_split(X, y)<br/>        knn = KNeighborsClassifier(n_neighbors=(n))<br/>        knn.fit(X_train, y_train)<br/>        y_pred_class = knn.predict(X_test)<br/>        empty_list.append(metrics.accuracy_score(y_test, y_pred_class))<br/>    <strong class="kq ir">return</strong> empty_list</span></pre><p id="dead" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该函数将测试 1-100 个最近邻，并返回每个最近邻的精度。这将有助于您为您的模型寻找最佳数量的邻居</p><p id="7e38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦您确定了最佳邻居，您就可以在其他数据点上使用您的模型，将它们放入一个类中。</p><p id="0d04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是你使用 KNN 的方式，我希望这能帮助那些对预测数据点将属于哪一类感兴趣的人</p></div></div>    
</body>
</html>