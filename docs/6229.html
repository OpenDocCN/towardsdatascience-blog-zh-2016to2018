<html>
<head>
<title>Neural Networks IV: The Graph Approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">神经网络 IV:图表方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/neural-networks-iv-the-graph-approach-cb25590a7f24?source=collection_archive---------15-----------------------#2018-12-02">https://towardsdatascience.com/neural-networks-iv-the-graph-approach-cb25590a7f24?source=collection_archive---------15-----------------------#2018-12-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="c6e1" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/tag/neural-network-notes/latest" rel="noopener">神经网络简介</a></h2><div class=""/><p id="7e90" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">这个关于神经网络的<a class="ae ku" href="https://medium.com/@pabloruizruiz/neural-networks-notes-fa42ab388bb8" rel="noopener">系列帖子</a>是脸书 PyTorch 挑战赛期间笔记收集的一部分，在 Udacity 的<a class="ae ku" href="https://eu.udacity.com/course/deep-learning-nanodegree--nd101" rel="noopener ugc nofollow" target="_blank">深度学习纳米学位项目之前。</a></p><h1 id="2ad4" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">内容</h1><ol class=""><li id="f4d4" class="lt lu iq jy b jz lv kd lw kh lx kl ly kp lz kt ma mb mc md bi translated"><strong class="jy ja">简介</strong></li><li id="1ac1" class="lt lu iq jy b jz me kd mf kh mg kl mh kp mi kt ma mb mc md bi translated"><strong class="jy ja">神经网络的图形表示</strong></li><li id="1a35" class="lt lu iq jy b jz me kd mf kh mg kl mh kp mi kt ma mb mc md bi translated"><strong class="jy ja">计算中的模式——门</strong></li><li id="13c2" class="lt lu iq jy b jz me kd mf kh mg kl mh kp mi kt ma mb mc md bi translated"><strong class="jy ja">结论</strong></li></ol><h1 id="af4a" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">1.介绍</h1><p id="1589" class="pw-post-body-paragraph jw jx iq jy b jz lv kb kc kd lw kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt ij bi translated">和前面的部分一样，我们将使用相同的神经网络结构。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="ab gu cl mr"><img src="../Images/e5d74863b6f2098ef5ef083d87ce436d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*JOvnkqDOkJxJHwM0M7F_ZQ.png"/></div></figure><p id="a618" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">正如我们在“学习”一节中看到的，神经网络通过转发输入并将结果输出与真实值或这些输出应该是什么进行比较，根据所犯的错误来更新其权重。</p><p id="4ab3" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在数学上，我们计算这些误差的梯度，并更新权重如下:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mu"><img src="../Images/430749e1ae4f4468617c881411ec29f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XH_FfmQswtd0Bj_uFWzYkA.png"/></div></div></figure><p id="8cbd" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">这些更新发生的次数非常多。神经网络使用大量数据进行大量迭代训练。为了使该过程在计算上可行，神经网络被理解为数学运算的非循环图，这便于导数的计算和链规则的应用。</p><h1 id="3e50" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">2.神经网络的图形表示</h1><p id="30e0" class="pw-post-body-paragraph jw jx iq jy b jz lv kb kc kd lw kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt ij bi translated">是时候发现我们的神经网络是如何运作的了。如果你曾经使用过像 TensorFlow 或 PyTorch 这样的机器学习框架，我们要做的就是试图找出简化你生活的那几行代码背后的东西。</p><p id="386d" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">好吧，信不信由你，我们一直在工作的友好的神经网络如图 1 所示。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mz"><img src="../Images/35a0ba3596ad3d79de515fb59518d944.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5hS7RVpqpEHnYgcLX37V7Q.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">Figure 1. Graph representation of out [2, 3, 1] neural network.</figcaption></figure><p id="ded6" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">让我们先看一看，并确定每种形状和颜色是什么:</p><blockquote class="ne nf ng"><p id="5575" class="jw jx nh jy b jz ka kb kc kd ke kf kg ni ki kj kk nj km kn ko nk kq kr ks kt ij bi translated">黄色方框是变量。x 是输入，Y 是输出，正向过程的输出应该是什么；J 是实际输出 Y 和 Y_hat 之间的误差。</p><p id="f9cb" class="jw jx nh jy b jz ka kb kc kd ke kf kg ni ki kj kk nj km kn ko nk kq kr ks kt ij bi translated">蓝色形状对应于各层之间的数学运算。它们基本上是基于元素的函数(激活)和矩阵加法和乘法。</p></blockquote><p id="59c8" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">现在我们可以转到上一章，回顾一下我们是如何通过将不同矩阵相乘的几个步骤来完成正向过程的。让我们写下我们可以为图表推断的方程，并检查它们是否与我们以前的知识一致。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nl"><img src="../Images/101496cc723a44ce4313558c032f5b75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rdCXFaRuJCe_SQsxZ7v9EA.png"/></div></div></figure><p id="b229" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">那是所有的向前传球。我们现在开始神经网络的反向传播。这变得越来越有趣，所以让我们用第一个反向传播误差的例子来解释一下细节，看看这个过程基本上是如何以相同的方式重复的，直到我们到达我们网络的起点。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nm"><img src="../Images/03a67890935eeb36068e93882ad0dc44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tvoa0WOECM0G_LhqxnQT1g.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">Figure 2.First Backward Propagation Step</figcaption></figure><p id="2a30" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我们需要从这里得到的想法如下:</p><p id="55c8" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">首先，我们输入我们的输入值<em class="nh"> z3 </em>和<em class="nh"> y </em>作为方程中描述的函数(成本)的输入值。F7。它们的值以灰色给出。因此，此时我们能够计算出<strong class="jy ja"> <em class="nh">的局部梯度</em> </strong>。这些是电流方程的偏导数(我们看到它们在盒子下面和上面是黑色的)。如果我们拿 Eq。F7 和我们推导它，结果是(鉴于我们只有 1 次步骤，所以 n = 1):</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nn"><img src="../Images/fc784b48f4721c89f130b54f71ff9a22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ov3bykME6QJ86Q9RU-AvZQ.png"/></div></div></figure><p id="6603" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">接下来，我们总是从函数本身的局部梯度开始反投影过程，显然是 1。之后，我们希望将该错误反向传播给所犯错误的负责人。我们所做的是<strong class="jy ja">应用链式法则将一个导数分解成更简单的导数</strong>。</p><p id="abd5" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">你必须意识到，这第一步可能不是最能说明问题的，因为成本函数本身的导数是 1，因此链式法则看起来没有任何作用。然而，当我们查看反向传播过程中的任何其他步骤时，它会对我们有所帮助，如图 3 所示。这里，我们以应用激活函数在系统中引入非线性的过程为例。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi no"><img src="../Images/66ae0957a9a0504958d7fc0f8d9e10a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y_RX9PcW1Zl89uTh69ra3A.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">Figure 3. Activation Backward Propagation Step</figcaption></figure><p id="c82a" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">本图中使用的激活函数是 sigmoid 函数。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi no"><img src="../Images/2faeed14861fec58b6c83668835ce379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J2Dix-WT78kLJWNwbjbXkA.png"/></div></div></figure><p id="e89f" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">重复相同的过程，我们有输入<em class="nh"> z2 </em>，它被应用 sigmoid 函数以获得<em class="nh"> a2 </em>。在这一点上，我们可以计算局部梯度，并等待来自网络末端的反向传播误差。</p><p id="01c9" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">然后，当它到达时，我们有<em class="nh"> dJ/da2，</em>它基本上意味着“J 的值对<em class="nh"> a2 </em>的多少负责”。应用链式法则，我们可以确定 z2  — (1)对那个<em class="nh"> J 有多大的影响。</em></p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi np"><img src="../Images/1fcebf7d3ea0e9640d3b1a2b11cc3bf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hX68jx12RY-vvgdIwhgb8g.png"/></div></div></figure><p id="a328" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">为此，我们应用与上一个示例相同的方法。我们使用链式法则将梯度表示为局部梯度和误差反向传播到这一点的乘积。</p><h2 id="5898" class="nq kw iq bd kx nr ns dn lb nt nu dp lf kh nv nw lj kl nx ny ln kp nz oa lr iw bi translated">为什么我们要计算这些梯度？</h2><p id="c8b6" class="pw-post-body-paragraph jw jx iq jy b jz lv kb kc kd lw kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt ij bi translated">为什么反向传播 J 成本的值？我们需要回忆一下网络是如何学习的。它们基于相对于权重的误差梯度来更新权重值。我们想知道“神经元的权重对所犯错误的责任有多大”，这样我们就可以调整它们的值，让我们的网络学习。所以，最后我们要找的是<em class="nh"> dJ/dW1 </em>和<em class="nh"> dJ/dW2 </em>。</p><p id="ea79" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">好，现在我们知道了工具和目标，让我们为我们的网络开发逆向方程！</p><h2 id="cf8b" class="nq kw iq bd kx nr ns dn lb nt nu dp lf kh nv nw lj kl nx ny ln kp nz oa lr iw bi translated">反向传播</h2><p id="ea22" class="pw-post-body-paragraph jw jx iq jy b jz lv kb kc kd lw kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt ij bi translated">在图 1 上向后看的同时看下面的等式。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ob"><img src="../Images/db252afddf3ac8fcc1c8b3e8b534a58e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GZKd2YDjNJj1XIFWpMkiSw.png"/></div></div></figure><p id="a7a0" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我们走吧！我们已经完成了所有的反向投影过程，并计算我们感兴趣的梯度如此容易！我们将使用这些值来更新权重值，并减少下次的误差。但是现在，让我们仔细看看，做一件人类仍然比机器做得更好的事情，让我们找到模式。</p><h1 id="23fc" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">3.计算中的模式—门</h1><p id="8c0d" class="pw-post-body-paragraph jw jx iq jy b jz lv kb kc kd lw kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt ij bi translated">正如我们在图 2 和图 3 中详细看到的，全局网络的每个组件的反向传播基本上包括将从网络末端接收的梯度乘以局部梯度。这就是人工智能的魔力，就这么简单！</p><p id="ee22" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我们看到的另一个模式是不同的模块是如何工作的。在人工智能世界中，它们有自己的术语，如下:</p><h2 id="f1a4" class="nq kw iq bd kx nr ns dn lb nt nu dp lf kh nv nw lj kl nx ny ln kp nz oa lr iw bi translated">添加门</h2><p id="4f3c" class="pw-post-body-paragraph jw jx iq jy b jz lv kb kc kd lw kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt ij bi translated">在正向传递中，加法门将输入相加作为输出。</p><p id="5fae" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在后向通路中，加闸称为<strong class="jy ja"><em class="nh"/></strong>。看看 B2-B2 或 B7-B8 这两个方程中的一个。它们代表网络中两个加法门的反向传播过程。他们两个的本地梯度都是 1，这就是为什么我们称他们为<em class="nh">分销商</em>。它们只是捕捉到到达它的梯度，然后原封不动地传递给它的所有输入。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oc"><img src="../Images/9ba0045291d83e5b2a59f29b466090a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*StDbDY88N_A8_lDsHlkirQ.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">Figure 4. Python code for the Add Gate</figcaption></figure><h2 id="0da9" class="nq kw iq bd kx nr ns dn lb nt nu dp lf kh nv nw lj kl nx ny ln kp nz oa lr iw bi translated">乘法门</h2><p id="c993" class="pw-post-body-paragraph jw jx iq jy b jz lv kb kc kd lw kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt ij bi translated">在前向传递中，乘法门将输入的乘积作为输出。</p><p id="8b7f" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在反向通路中，乘法门被称为<strong class="jy ja"> <em class="nh">开关</em> </strong>。看看方程式 B4-B5 或 B9-B10 中的一个。它们代表网络中每个乘法门的反向传播过程。两者的局部梯度是另一个输入的值，这就是为什么我们称它们为<em class="nh">开关</em>。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi od"><img src="../Images/2ac48b1027b3eee87f3cb509475baac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9iYWuhFT3ovQvenQYm9F8w.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">Figure 5. Python code for the Multiply Gate</figcaption></figure><h2 id="7f2d" class="nq kw iq bd kx nr ns dn lb nt nu dp lf kh nv nw lj kl nx ny ln kp nz oa lr iw bi translated"><strong class="ak">激活</strong></h2><p id="769f" class="pw-post-body-paragraph jw jx iq jy b jz lv kb kc kd lw kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt ij bi translated">在正向传递中，各层将我们为其选择的函数(激活函数)应用于输入，以计算输出。</p><p id="c872" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在后向过程中，层只是将其自身的导数值乘以传入渐变来计算输出渐变(也称为底部渐变)。看一下等式 6。两个典型的激活函数是 sigmoid 或双曲线正切。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi od"><img src="../Images/3d842e6a26b5228d7feed2f2a1063d6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1HFcwv0WWClpG7fLFUoijA.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">Figure 6. Python code for two common Activations</figcaption></figure><h2 id="ddca" class="nq kw iq bd kx nr ns dn lb nt nu dp lf kh nv nw lj kl nx ny ln kp nz oa lr iw bi translated">成本计算器— PyTorch 标准</h2><p id="0035" class="pw-post-body-paragraph jw jx iq jy b jz lv kb kc kd lw kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt ij bi translated">我们所看到的成本(通常也称为损失)是网络在与真实值进行比较时产生的误差。这可以解释为向前传递的最后一步或向后传递的第一步。</p><p id="b187" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在这种特殊情况下，我们应用了一个成本函数来最小化均方误差。然而，根据神经网络的应用，这个盒子的结构和其上的值将会不同。</p><p id="e323" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在这种特殊情况下，它接收输入的前向过程的输出，并将其与应有的值进行比较。之后，它返回导数的值，我们称之为<em class="nh"> top_diff </em>。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oe"><img src="../Images/1e607acdb00663c421af11d4874fbb31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ucc1E2oas06AtboaBUq90w.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">Figure 7. Python code for the Loss calcualtion</figcaption></figure><h1 id="6954" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">4.结论</h1><p id="e455" class="pw-post-body-paragraph jw jx iq jy b jz lv kb kc kd lw kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt ij bi translated">我们已经看到了神经网络的图形表示如何让我们容易地看到反向传播是如何发生的，以及如何通过图形的小组件使用链规则来容易地计算传播。</p><p id="b24e" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">只剩下最后一件事，我真的鼓励你去看，特别是现在你已经到了这一步。我建议你到下一章去关注反向传播过程中矩阵的维数，去理解所有这些矩阵的转置和乘法是从哪里来的。</p></div></div>    
</body>
</html>