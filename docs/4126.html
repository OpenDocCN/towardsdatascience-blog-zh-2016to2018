<html>
<head>
<title>Temp Tables vs Variable Tables — SQL Data Preparation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">临时表与变量表— SQL 数据准备</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/temp-tables-vs-variable-tables-sql-data-preparation-b2002ac0b708?source=collection_archive---------13-----------------------#2018-07-20">https://towardsdatascience.com/temp-tables-vs-variable-tables-sql-data-preparation-b2002ac0b708?source=collection_archive---------13-----------------------#2018-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/b453f50d54f5244ef8f4d8878fc7eda0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9Khxb5Q3wpmTMm6b"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Image by <a class="ae jd" href="https://unsplash.com/@markusspiske" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on unsplash.com</figcaption></figure><div class=""/><p id="74a4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据科学的很大一部分是数据准备，确保我们使用的数字是有效的，格式是正确的，并且能够有效地准备和访问。我花了大量时间在 SQL 上，从许多来源收集数据，并将它们从堆积的表中汇集到可访问的数据立方体中，这些立方体是自动准备的，具有引用完整性，并且在几秒钟而不是几小时内运行！我遇到和读到的一个概念是临时表和变量表。我认为总结我发现的一些要点是值得的，希望对你们有些人有帮助！</p><p id="94c7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一名商业智能顾问，我的主要工作是与公司合作，继承他们现有的程序/视图/工作，然后对其进行逆向工程，以改善处理时间、数据准确性和故障率。有时小的变化可以带来巨大的好处，所以理解 SQL 的一些核心概念是如何真正工作的是非常宝贵的，即使你的重点是高级分析和机器学习。</p><p id="873b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">继续吧！</p><p id="7a41" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你花了很多时间使用 SQL 和阅读其他人的代码(如果你自己没有使用过的话),那么临时表和变量表是名称前面分别带有#和@符号的表。这两个选项都允许您像存储存在于任何一个数据库中的永久表一样存储数据。下面列出了每种方法的一个例子。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="abe4" class="lk ll jg lg b gy lm ln l lo lp">-- This is a variable table</span><span id="756c" class="lk ll jg lg b gy lq ln l lo lp">declare @VariableTable as table</span><span id="d9c3" class="lk ll jg lg b gy lq ln l lo lp">([ID] int,</span><span id="0945" class="lk ll jg lg b gy lq ln l lo lp">[Name] varchar(100),</span><span id="7b82" class="lk ll jg lg b gy lq ln l lo lp">[Description] varchar(500))</span><span id="c369" class="lk ll jg lg b gy lq ln l lo lp">-- and this is a temporary table</span><span id="c71c" class="lk ll jg lg b gy lq ln l lo lp">CREATE TABLE #TemporaryTable</span><span id="e80d" class="lk ll jg lg b gy lq ln l lo lp">([ID] int,</span><span id="d484" class="lk ll jg lg b gy lq ln l lo lp">[Name] varchar(100),</span><span id="5c48" class="lk ll jg lg b gy lq ln l lo lp">[Description] varchar(500))</span></pre><p id="db0d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了两个表，insert 语句可以用来填充这两个表。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="9b72" class="lk ll jg lg b gy lm ln l lo lp">INSERT INTO @VariableTable</span><span id="7cb3" class="lk ll jg lg b gy lq ln l lo lp">SELECT [ID], [Name], [Description]</span><span id="a9be" class="lk ll jg lg b gy lq ln l lo lp">FROM [PermanentTable]</span><span id="bd4a" class="lk ll jg lg b gy lq ln l lo lp">INSERT INTO #TemporaryTable</span><span id="1aac" class="lk ll jg lg b gy lq ln l lo lp">SELECT [ID], [Name], [Description]</span><span id="bd43" class="lk ll jg lg b gy lq ln l lo lp">FROM [PermanentTable]</span></pre><p id="938e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，它们都很容易创建和填充。现在是有趣的部分了…它们有什么不同。</p><p id="6172" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">坚持</strong></p><p id="d03e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，变量表只存在于正在运行的批处理中，一旦查询执行完毕，数据就消失了。然而，临时表是“持久的”,这意味着在运行查询后，您可以检查表中的数据。这在调试复杂过程时非常有用，因为您可以运行查询，如果它没有返回您期望的结果，您可以查看任何/所有临时表中的数据，看看哪里出错了。</p><p id="4ac1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">数据量</strong></p><p id="89ee" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可变表仅设计用于保存少量数据。另一天的概念涉及执行计划，例如，存储过程用来优化查询的性能。SQL 中的执行计划假设一个变量表有一行数据，而它们通常用于存储数万行数据。这可能导致低效的计划和不必要的长时间运行。</p><p id="687f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">分度</strong></p><p id="cb6d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就其本身而言，临时表和变量表对于各种任务(插入、更新和删除等)具有不同的性能水平，但是一个关键的性能差异是向临时表添加索引的能力。这对于变量表是不可能的，这意味着任何时候你从变量表中访问数据，它都存在于一个“堆”中。</p><p id="c9c4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">索引的工作方式就像你在图书馆遇到的索引一样。你的选择(除了问图书管理员)是走到最近的书架前，开始阅读书名，直到你找到你要找的书，或者你可以使用目录。目录会给你一个与书的位置相对应的号码，这样你就可以走到一个特定的书架，并且(希望)在找到你要找的书之前只浏览几本书。SQL 以同样的方式运行，如果数据存在于一个堆中，SQL 将简单地从数据的顶部开始运行，直到找到相应的记录。如果有索引，它将跳转到您所在的行所在的数据部分，这大大减少了它需要读取的行数。下面是对[ID]列的简单索引的示例。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="c4a0" class="lk ll jg lg b gy lm ln l lo lp">--example index statement<br/>create index idx_temp on #TemporaryTable ([ID])</span></pre><p id="8dbf" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">索引是一个巨大的主题，非常值得花时间去研究。它们带来了额外的开销，但是根据我的经验，从表中选择数据的好处要大得多。</p><p id="60a7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于感兴趣的人来说，一些有用的主题包括堆和聚集表、表扫描和查找以及聚集和非聚集索引。对这些有一个坚实的理解将极大地提高您的数据库的性能！</p><p id="7651" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">我更喜欢哪个</strong></p><p id="8776" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管变量表有它的好处，特别是对于少量的数据，我通常坚持使用临时表，因为我发现它们更有用。持久性差异意味着当您完成时应该‘丢弃’(删除)表，这与变量表相比是一个额外的步骤。在这一点上，我仍然喜欢花额外的时间来准备我的代码，因为我知道最后的过程会更有效。</p><p id="8ece" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我开发一个新的过程时，有时我会忘记在重新运行之前删除临时表，这会导致执行失败。如前所述，需要先删除该表，然后才能重新创建它。通常，我会在临时表上方添加一条语句，该语句会删除该表(如果它存在)并重新创建它。这省去了执行失败的麻烦，但保留了其他好处。下面是这个“check”语句和“drop”语句的例子。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="f2aa" class="lk ll jg lg b gy lm ln l lo lp">--Example 'check' statement<br/>IF OBJECT_ID('tempdb..#<!-- -->TemporaryTable<!-- -->') IS NOT NULL DROP TABLE #<!-- -->TemporaryTable</span><span id="07e1" class="lk ll jg lg b gy lq ln l lo lp">--Example 'drop' statement<br/>drop table #TemporaryTable</span></pre><p id="82d4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望这是有用的。这绝不是详尽无遗的，我相信你们中的许多人会有更多的细节来补充这个话题。我期待着阅读您的回复！</p></div></div>    
</body>
</html>