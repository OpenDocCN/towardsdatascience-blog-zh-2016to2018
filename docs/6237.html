<html>
<head>
<title>Optimized I/O operations in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中优化的 I/O 操作</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/optimized-i-o-operations-in-python-194f856210e0?source=collection_archive---------2-----------------------#2018-12-03">https://towardsdatascience.com/optimized-i-o-operations-in-python-194f856210e0?source=collection_archive---------2-----------------------#2018-12-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1623" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用 Python 的数据科学堆栈加速分析的输入/输出技巧</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/63befdc50b7d03828b9aecc55cc90530.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3gDq1iXMeIbrV1KPgKZNmA.jpeg"/></div></div></figure><p id="0a52" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在处理数据密集型应用程序时，我经常面临输入/输出(I/O)挑战，这是每个性能关键型应用程序的瓶颈。随着存储数据量的增加，有必要将数据存储在磁盘中，以通过将数据从磁盘加载到 RAM 来弥补 RAM 的不足，反之亦然。因此，在处理金融数据或任何科学数据时，I/O 操作本质上是非常重要的任务。</p><p id="f766" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过这篇文章，我试图揭示一些图书馆和他们的商业技巧。Python 有内置的功能，可以用来将对象存储在磁盘上，并从磁盘读取到 RAM 中。此外，Python 在处理文本文件和 SQL 数据库时非常健壮。Pandas 库提供了大量的类和方法来读写各种格式的文件。</p><p id="f75e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将在这里研究以下领域的数据存储和检索方法:</p><ol class=""><li id="3130" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">使用 Pickle 模块的序列化存储</li><li id="367d" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">对文本数据的 I/O 操作</li><li id="8b12" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">SQL 数据库</li><li id="2d6c" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">具有 PyTables 的 I/O</li></ol><p id="70d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在 Python 语言中优化 I/O 操作时要考虑的两个主要因素是效率(性能)和灵活性。让我们直入主题:</p><h1 id="7486" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">使用 Pickle 模块的序列化存储</h1><p id="7264" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">Python 语言中有许多模块，可以在大规模部署环境中轻松使用。</p><h2 id="ca5c" class="my mc iq bd md mz na dn mh nb nc dp ml la nd ne mn le nf ng mp li nh ni mr nj bi translated">使用 pickle 模块读写文件</h2><p id="b3a4" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">您需要将数据存储在您的磁盘上，以便以后共享、记录或使用。我们有 pickle 模块，它序列化 python 对象以快速进行读写操作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="3d5d" class="my mc iq nn b gy nr ns l nt nu"># On running the above code snippet, you'll see:</span><span id="20a3" class="my mc iq nn b gy nv ns l nt nu">CPU times: user 40.9 ms, sys: 14 ms, total: 54.9 ms<br/>Wall time: 54.5 ms</span></pre><p id="c129" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">随机浮点构建一个 9MB 的文件，该文件被序列化为字节流并在 54.9 毫秒内写入磁盘。您将使用 pickle 模块的<strong class="kt ir"> <em class="nw"> dump </em> </strong>和<strong class="kt ir"> <em class="nw"> load </em> </strong>函数分别写入和读取文件。要断言序列化和反序列化的数据，可以使用 Numpy 的<em class="nw"> allclose </em>方法。你可以这样做:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="8942" class="my mc iq nn b gy nr ns l nt nu">np.allclose(np.array(a1), np.array(a2))</span><span id="d052" class="my mc iq nn b gy nv ns l nt nu"># here a2 is the deserialized object after reading the same file<br/># using the load function.</span></pre><p id="9fb9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，pickle 模块存储了 python 列表、dict 等。在将它们转换成磁盘上的字符流之后。这里的关键是这个字节流包含了在另一个 python 脚本中重建对象所必需的信息。</p><h1 id="7322" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">对文本数据的 I/O 操作</h1><p id="a8d6" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">Python 一直是最受欢迎的语言，尤其是在处理文本文件时，因为它具有处理文本数据的健壮性和易用性。有几个选项来操作字符串对象和一般的文本文件。</p><p id="3b4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要编写 CSV(逗号分隔值)，我们可以使用 write 和 readline 方法:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="6e48" class="my mc iq nn b gy nr ns l nt nu">csv_file.write(header)</span><span id="975b" class="my mc iq nn b gy nv ns l nt nu"># time is time array and data is the dummy numpy array<br/><strong class="nn ir">for </strong>time, (a, b, c, d, e) <strong class="nn ir">in </strong>zip(time, data): <br/>  s = '%s,%f,%f,%f,%f,%f<strong class="nn ir">\n</strong>' % (time, a, b, c, d, e)                csv_file.write(s)</span><span id="67b0" class="my mc iq nn b gy nv ns l nt nu">csv_file.close()</span><span id="aff2" class="my mc iq nn b gy nv ns l nt nu"># to read the file, we can use readlines function<br/>content = csv_file.readlines()</span></pre><p id="acab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然 python 提供了处理文本文件的方法，但是我们有 pandas 库，它可以读写各种数据格式，并且更好更容易获得。</p><p id="b55e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">无论是 CSV(逗号分隔值)、SQL(结构化查询语言)、XLS/XLSX(Microsoft Excel 文件)、JSON(Javascript 对象表示法)还是 HTML(超文本标记语言)。</p><p id="82fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">熊猫让整个 CSV 文件的读写过程变得更加方便、简洁、快捷。</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="47bb" class="my mc iq nn b gy nr ns l nt nu">%time data.to_csv(filename + '.csv')</span><span id="8775" class="my mc iq nn b gy nv ns l nt nu"># CPU times: user 5.59 s, sys: 137 ms, total: 5.69 s</span><span id="bd8a" class="my mc iq nn b gy nv ns l nt nu"># And to read the files back from the disk</span><span id="5bb7" class="my mc iq nn b gy nv ns l nt nu">pd.read_csv(&lt;path to the CSV file&gt;)</span></pre><h1 id="0db0" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">SQL 数据库</h1><p id="301c" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">Python 附带了对 SQL 数据库 SQLite3 的支持。使用 python，我们可以处理几乎任何类型的数据库(SQL 或 NoSQL)。</p><p id="c5dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">SQL 查询被写成字符串对象，其中语法和数据类型取决于所使用的数据库。说明了在 SQLite 数据库中通过 python 创建 Todo 表:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="6b8f" class="my mc iq nn b gy nr ns l nt nu">import sqlite3 as sq</span><span id="0691" class="my mc iq nn b gy nv ns l nt nu"># query string to create the table</span><span id="0da9" class="my mc iq nn b gy nv ns l nt nu">query = 'CREATE TABLE TODO_NUMBER (Num1 real, Num2 real, Num3 real)'<br/>con = sq.connect(path + 'todo.db')<br/>con.execute(query)<br/>con.commit()</span></pre><p id="22c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们尝试在创建的数据库中插入一些数据，</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="65e1" class="my mc iq nn b gy nr ns l nt nu">data = np.random.standard_normal((1000000, 3))<br/>%%time<br/>con.executemany('INSERT INTO TODO_NUMBER VALUES (?, ?, ?, ?, ?)', data)<br/>con.commit()</span><span id="d75f" class="my mc iq nn b gy nv ns l nt nu"># Time taken: CPU times: user 10.3 s, sys: 316 ms, total: 10.6 s<br/>Wall time: 11 s</span></pre><p id="4259" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将 100 万行写入数据库是一项有点繁重且耗时的任务。读取数据库要快得多:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="1e7b" class="my mc iq nn b gy nr ns l nt nu">con.execute('SELECT * FROM TODO_NUMBER').fetchall() </span></pre><p id="14b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果在数据库中处理大量的数字和数组，可以利用 Numpy 数组将数据直接读入 numpy ndarray。</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="04c3" class="my mc iq nn b gy nr ns l nt nu">np_query = 'SELECT * FROM TODO_NUMBER WHERE Num1 &gt; 0 AND Num2 &lt; 0'<br/>res = np.array(con.execute(np_query).fetchall()).round(3)</span></pre><p id="4434" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个非常好的技巧，可以毫不费力地读取和绘制查询结果。为了使读取更加高效和优化，我们应该使用 pandas 读取整个表和查询结果。当整个表被加载到内存中时，分析和处理变得更快。这是通过使用子库<em class="nw"> pandas.io.sql </em>实现的</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="6241" class="my mc iq nn b gy nr ns l nt nu">import pandas.io.sql as pds<br/>data_df = pds.read_sql('SELECT * FROM TODO_NUMBERS', con)</span></pre><p id="0e07" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该表现在被加载到内存中，这使得处理速度更快。使用 SQLite3 需要几秒钟的 SQL 查询在内存中使用 pandas 时在几毫秒内完成:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="6d4d" class="my mc iq nn b gy nr ns l nt nu">%time data_df[(data_df['Num1'] &gt; 0) &amp; (data_df['Num2'] &lt; 0)].head()</span><span id="4716" class="my mc iq nn b gy nv ns l nt nu"># CPU times: user 50 ms, sys: 0 ns, total: 50 ms</span><span id="d31b" class="my mc iq nn b gy nv ns l nt nu"># Wall time: 49.9 ms</span></pre><p id="ada9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以用 pandas 掌握更多复杂的查询，它会比 SQL 更快地产生结果，但它不能取代 SQL。鉴于 pandas 能够复制 SQL 查询，我们可以使用 pandas 的内存处理显著加快分析速度。</p><blockquote class="nx ny nz"><p id="fa1b" class="kr ks nw kt b ku kv jr kw kx ky ju kz oa lb lc ld ob lf lg lh oc lj lk ll lm ij bi translated">这里需要注意的一点是，pandas 并不是用来取代 SQL 数据库的，目前它也不能取代 SQL 数据库。Pandas 不支持关系数据结构。</p></blockquote><h1 id="e1d3" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">具有 PyTables 的 I/O</h1><p id="8131" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">PyTables 是针对 HDF5 数据库/文件标准的 Python 绑定。它是专门为增强 I/O 操作的性能和充分利用可用硬件而设计和开发的。它在加速分析和更快生成输出方面做得非常好。PyTables 数据库可以容纳许多表，它支持压缩和索引，还支持对表的重要查询。</p><p id="dd4e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">PyTables 具有基于文件的数据库格式。让我们看一下表格的工作原理，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b04f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将为我们创建一个带有指定数据类型的必需字段的表。现在让我们填充数据库，我们必须创建一些随机值，并将它们逐行写入表中，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0cfe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是同样，我们有一种更优化和 Pythonic 化的方法来达到相同的结果，即利用 NumPy 结构化数组:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="0daa" class="my mc iq nn b gy nr ns l nt nu">dty = np.dtype([('Num1', 'i4'), ('Num2', '&lt;i4')])</span><span id="c5bd" class="my mc iq nn b gy nv ns l nt nu">sarray = np.zeros(len(ran_int), dtype=dty)</span></pre><p id="a938" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们已经在表中设置了完整的数据，这一切都归结为表的创建，如下所示:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="c327" class="my mc iq nn b gy nr ns l nt nu">%%time<br/>h5.create_table('/', 'ints_from_array', sarray,</span><span id="a38f" class="my mc iq nn b gy nv ns l nt nu">title='Integers', expectedrows=rows, filters=filters)</span></pre><p id="a52d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种方法速度更快，而且我们用更少的代码行完成了同样的结果。我们可以使用以下命令删除重复的表:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="7c6b" class="my mc iq nn b gy nr ns l nt nu">h5.remove_node(‘/’, ‘ints_from_array’)</span></pre><p id="0c0b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">pandas 和 PyTables 都能够处理复杂的类似 SQL 的查询、索引和选择。就 I/O 操作而言，它们都经过了速度设计和优化。</p><p id="adab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用 PyTables 的一个主要优点是它的压缩操作方式。它使用压缩不仅可以节省磁盘空间，还可以提高 I/O 操作的性能。</p><h1 id="3c66" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">结论</h1><p id="a541" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">一般来说，金融或科学中的许多企业级应用领域只需基于阵列的数据建模就能取得成功。在大多数情况下，结合使用 NumPy 和 PyTables I/O 功能可以显著提高性能。事实证明，基于 HDF5 的商店是所有方法的独特补充。</p><p id="018c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你有复杂的数据结构，表现出单个对象/表之间的许多关系，关系数据库有它的优点。这在某些情况下可能证明是合理的，在这些情况下，与纯基于 NumPy ndarray 或基于 pandas DataFrame 的方法相比，存在性能劣势。</p><h1 id="81a7" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">Harshit 的数据科学</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od nl l"/></div></figure><p id="64ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过这个渠道，我计划推出几个涵盖整个数据科学领域的系列。以下是你应该订阅<a class="ae oe" href="https://www.youtube.com/channel/UCH-xwLTKQaABNs2QmGxK2bQ" rel="noopener ugc nofollow" target="_blank">频道</a>的原因:</p><ul class=""><li id="6d85" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm of lt lu lv bi translated">该系列将涵盖每个主题和副主题的所有必需/要求的高质量教程。</li><li id="7065" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm of lt lu lv bi translated">解释了为什么我们在 ML 和深度学习中做这些事情的数学和推导。</li><li id="aa03" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm of lt lu lv bi translated">与谷歌、微软、亚马逊等公司的数据科学家和工程师以及大数据驱动型公司的首席执行官的播客。</li><li id="7c2c" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm of lt lu lv bi translated">项目和说明，以实现迄今为止所学的主题。</li></ul><p id="f868" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以在<a class="ae oe" href="https://www.linkedin.com/in/tyagiharshit/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae oe" href="https://twitter.com/tyagi_harshit24" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae oe" href="https://www.instagram.com/upgradewithharshit/?hl=en" rel="noopener ugc nofollow" target="_blank"> Instagram </a>上与我联系(在那里我谈论健康和福祉。)</p><p id="5b7c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意:在这些黑暗的时期，自我隔离为自我提升腾出了一些空间，我们可以利用这些空间来发展新的技能、爱好，并帮助未来的自己。</p></div></div>    
</body>
</html>