<html>
<head>
<title>Activity Recognition using Smartphones — Machine Learning application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用智能手机的活动识别—机器学习应用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/activity-recognition-using-smartphones-machine-learning-application-a10e7b5578f9?source=collection_archive---------3-----------------------#2018-10-28">https://towardsdatascience.com/activity-recognition-using-smartphones-machine-learning-application-a10e7b5578f9?source=collection_archive---------3-----------------------#2018-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/65ebb2f79f4745503ef5d5a036494275.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zQg0Q1Smcvvz19U1"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">“white building with data has a better idea text signage” by <a class="ae kc" href="https://unsplash.com/@franki?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Franki Chamaki</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e1ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我第一次开始探索机器学习时，我阅读了大量的文章和研究论文。我最初发现的一篇论文涉及使用机器学习对活动进行分类。尽管当时实现似乎是一个遥不可及的目标，但我还是被这个应用程序吸引住了。从那天起，我获得了一些经验，我相信今天我可以应用我的机器学习知识来识别现在的活动。</p><p id="7b11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于数据集，我从<a class="ae kc" href="https://www.kaggle.com/uciml/human-activity-recognition-with-smartphones" rel="noopener ugc nofollow" target="_blank"> Kaggle 竞赛</a>中选择了<code class="fe lb lc ld le b">training.csv</code>和<code class="fe lb lc ld le b">test.csv</code>文件。我在这个项目中使用了一个 Jupyter 笔记本，在我的<a class="ae kc" href="https://github.com/kb22/Activity-Recognition-using-Machine-Learning" rel="noopener ugc nofollow" target="_blank">活动识别中使用了机器学习报告</a>。</p><blockquote class="lf lg lh"><p id="94d6" class="kd ke li kf b kg kh ki kj kk kl km kn lj kp kq kr lk kt ku kv ll kx ky kz la ij bi translated">顺便提一下，现在通过<a class="ae kc" href="https://toolbox.google.com/datasetsearch" rel="noopener ugc nofollow" target="_blank">谷歌数据集搜索</a>在线查找数据集变得容易多了。这是我找到这个项目数据集的地方。</p></blockquote><p id="473c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在这篇文章中，我将解释我在这个项目中采取的步骤，以及我如何使用机器学习以超过 96%的准确率对活动进行分类。分叉存储库，打开笔记本，开始吧。</p><h1 id="6b23" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">导入库</h1><p id="62cd" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在这个项目中，我们将需要许多存储库。</p><ol class=""><li id="a312" class="mp mq iq kf b kg kh kk kl ko mr ks ms kw mt la mu mv mw mx bi translated"><strong class="kf ir"> numpy 和 pandas: </strong> numpy 使我们能够高效地使用数组。Pandas 用于读取数据集文件并将其作为 dataframe 导入，data frame 类似于包含行和列的表。</li><li id="e181" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">matplotlib:  matplotlib 是一个高度可定制的包，它有一个子包<code class="fe lb lc ld le b">pyplot</code>，可以让我们绘制图表、柱状图、饼状图等等。我们可以选择添加图例、轴标题、改变线条粗细等。<code class="fe lb lc ld le b">cm</code>包(colormap)允许我们为图表获取颜色。</li><li id="ddc8" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated"><strong class="kf ir"> sklearn: </strong>这个机器学习库包括许多已经内置的机器学习算法，其中某些参数设置为默认参数，因此它们开箱即用。</li></ol><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="a386" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你注意到了，我加了一行<code class="fe lb lc ld le b">%matplotlib inline</code>。这将 matplotlib 的后端更改为 Jupyter 笔记本，因此，所有绘图现在都将显示在 Jupyter 笔记本本身中。</p><p id="064e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个项目中，我使用了四种算法，即支持向量分类器作为<code class="fe lb lc ld le b">SVC</code>，逻辑回归作为<code class="fe lb lc ld le b">LogisticRegression</code>，K 近邻分类器作为<code class="fe lb lc ld le b">KNeighborsClassifier</code>，随机森林分类器作为<code class="fe lb lc ld le b">RandomForestClassifier</code>。为了计算精度，我导入了<code class="fe lb lc ld le b">accuracy_score</code>。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="f1db" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">了解数据集</h1><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nj ni l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Person walking up the stairs</figcaption></figure><p id="d9fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先我们将使用<code class="fe lb lc ld le b">read_csv()</code>方法将训练和测试文件导入笔记本，并保存在变量<code class="fe lb lc ld le b">training_data</code>和<code class="fe lb lc ld le b">testing_data</code>中。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="b50a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe lb lc ld le b">shape</code>方法来寻找数据集的大小。其结果是输出为<code class="fe lb lc ld le b">(rows, columns)</code>。训练数据集中有 7352 行和 563 列，测试数据集中有 2947 行和 563 列。我们必须确保数据集没有任何空值。我们使用<code class="fe lb lc ld le b">isnull().values.any()</code>来检查是否有单元格是空的。我们打印输出，看到输出是<code class="fe lb lc ld le b">False</code>,意味着没有空值。所以，我们可以继续。</p><p id="6ef5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe lb lc ld le b">head(5)</code>方法来获得训练数据的前 5 行。我们看到有 563 列，最后一列为<strong class="kf ir">活动</strong>，它将作为我们的<strong class="kf ir">标签</strong>。在剩下的专栏中，subject 对于我们的机器学习应用程序没有特别的用途，因为我们想要探索活动，而不是谁执行了它。我们可以删除该列，剩下的 561 列将成为我们的<strong class="kf ir">功能</strong>。测试数据也是如此。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="5251" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">按照惯例，小写字母<code class="fe lb lc ld le b">y</code>充当标签集，大写字母<code class="fe lb lc ld le b">X</code>充当特征集。因此，这些名称是<code class="fe lb lc ld le b">y_train</code>、<code class="fe lb lc ld le b">X_train</code>、<code class="fe lb lc ld le b">y_test</code>和<code class="fe lb lc ld le b">X_test</code>。我们将在机器学习分析中使用这些变量。</p><h1 id="6e2e" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">可视化数据集</h1><p id="5085" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">处理数据的关键之一是确保所有类的大小大致相等。这是必不可少的，这样机器学习算法就不会偏向任何一个类。</p><p id="7078" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们借助一个例子来理解这一点。比方说，数据集包含 30 项活动，其份额百分比各不相同。数据集包含 99%的活动 1 数据和 1%的其余活动数据。在这种情况下，机器学习将永远不会学习关于数据的任何模式。它会认为 100 个案例中有 99 个案例的活动是活动 1。因此，它将总是输出 Activity 1，而不考虑任何数据，并且仍然可以达到 99%的准确率。这种模型是不正确的，因此必须确保不同数据类别的份额大致相等。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="51b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们首先在<code class="fe lb lc ld le b">count_of_each_activity</code>变量中获得每种类型活动的记录数。<code class="fe lb lc ld le b">value_counts()</code>给出计数，<code class="fe lb lc ld le b">np.array</code>将其转换成一个数组。计数按活动名称的字母顺序显示。</p><p id="db65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">unique()</code>在<code class="fe lb lc ld le b">y_train</code>给了我们独特的价值观。我们必须对其进行排序，以便它们与上面收集的计数值保持一致。<code class="fe lb lc ld le b">rcParams</code>帮助我们为我们的图表定义某些样式。我们使用<code class="fe lb lc ld le b">figure.figsize</code>定义图形大小，使用<code class="fe lb lc ld le b">font.size</code>定义字体大小。</p><p id="23d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在已经为饼图准备好了数据。<code class="fe lb lc ld le b">pie()</code>方法创建饼图。第一个参数是每个活动的计数，第二个参数是由<code class="fe lb lc ld le b">labels</code>表示的相应活动名称，第三个参数<code class="fe lb lc ld le b">autopct</code>计算每个活动的百分比。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/3b2ddd147263986f987b5d30b338a1af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xAGTP0kqjNT7B_FfffSqcg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Pie chart for share of each activity in dataset</figcaption></figure><p id="5353" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">观察上面的饼图，您可以看到每项活动的份额几乎相等。数据集的格式非常好，可以直接使用。</p><p id="869a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我观察 datatset 中的读数类型。如果您查看列标题，您会发现这些列要么有文本<code class="fe lb lc ld le b">Acc</code>来指代加速度计读数，要么有文本<code class="fe lb lc ld le b">Gyro</code>来指代陀螺仪值，要么两者都没有来指代所有其他值。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="b586" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我首先遍历列名，检查它们是否包含“Acc”或“Gyro”。基于变量值，我使用<code class="fe lb lc ld le b">pyplot</code>子包的<code class="fe lb lc ld le b">bar()</code>方法绘制了一个条形图。第一个参数是 X 轴标签，第二个参数是 Y 轴值的数组，<code class="fe lb lc ld le b">color</code>参数分别为三个条形定义了颜色<em class="li">红色</em>、<em class="li">蓝色</em>和<em class="li">绿色</em>。我再次为这个条形图定义了图形大小和字体大小。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/5c896925c177311b0dfbbd65a29a8b92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lUX4J4Q6jZzGuIQMMnt6gQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Bar plot of column types</figcaption></figure><h2 id="5f40" class="nm ln iq bd lo nn no dn ls np nq dp lw ko nr ns ma ks nt nu me kw nv nw mi nx bi translated">检查某项活动</h2><p id="6610" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">为了更好地了解数据，我知道我必须看一看这些活动。因此，我决定尝试探索更多关于“站立”的活动。</p><p id="b8cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我开始之前知道的所有信息:</p><ol class=""><li id="296d" class="mp mq iq kf b kg kh kk kl ko mr ks ms kw mt la mu mv mw mx bi translated">该数据集具有 30 个人的活动记录，并且一些个人进行了站立活动。</li><li id="c46f" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">收集到的数据会连续记录每个人，尤其是每个活动。这意味着任何给定活动的记录实际上都是时间序列。</li><li id="c19a" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">每个记录中有许多特征，但是我不能一次包含所有的特征，因为这可能会使数据的理解更加困难。</li></ol><p id="14b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据我所掌握的信息，我决定绘制一个线图，显示在一段时间内执行<em class="li">站立</em>活动的所有人的特征。我把这个特征作为 X 和平均重力之间的<em class="li">角度，除了由于人为误差造成的微小变化，这个角度应该保持不变。</em></p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/38bd9716886018f914ce6ad659f0bb93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Upp49po9LT6loqBf"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">“man standing on road” by <a class="ae kc" href="https://unsplash.com/@anthonytori?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Anthony Tori</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d17b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我首先从数据集中选择所有“活动”标签为“站立”的行，并将其存储在<code class="fe lb lc ld le b">standing_activity</code>中。这里，我们必须确保我们重置了索引。这是必要的，因为当我们选择上面的行时，被删除的行确实被删除了，但是其余行的索引没有改变，它们不再是连续的。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="493e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为每个个体收集的数据是连续的时间序列，并以相同的速率记录。因此，每次主题改变时，我可以简单地从<code class="fe lb lc ld le b">0</code>开始为每个活动分配时间值。对于每个主题，<em class="li">持续</em>活动记录将以时间值<code class="fe lb lc ld le b">0</code>开始，并以<code class="fe lb lc ld le b">1</code>递增，直到前一行的主题与当前行的主题相匹配。我将所有的时间序列存储在变量<code class="fe lb lc ld le b">time_series</code>中，并使用 pandas 方法<code class="fe lb lc ld le b">DataFrame()</code>将其转换为数据帧，然后存储在变量<code class="fe lb lc ld le b">time_series_df</code>中。最后，我使用 pandas <code class="fe lb lc ld le b">concatenate()</code>方法将记录和时间序列变量组合在一起。<code class="fe lb lc ld le b">axis = 1</code>告诉该方法组合两个数据帧，并将它们作为列追加。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7b8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">np.zeros()</code>创建一个由零组成的 numpy 数组，其大小等于括号内的数字。对于一个数据帧，如果我们在括号内分别使用<code class="fe lb lc ld le b">0</code>或<code class="fe lb lc ld le b">1</code>，在<code class="fe lb lc ld le b">shape</code>的末尾添加一个方括号有助于我们获得行或列。</p><p id="0b46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当数据准备好被绘制时，我使用 matplotlib 的<code class="fe lb lc ld le b">cm</code>子包通过<code class="fe lb lc ld le b">rainbow</code>方法获得一个颜色列表。</p><p id="5acb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我遍历<code class="fe lb lc ld le b">standing_activity_df</code>中的主题列表。我使用<code class="fe lb lc ld le b">rcParams</code>指定图形的大小。在绘图方法中，第一个参数是 X 轴值，在我们的例子中是<code class="fe lb lc ld le b">Time</code>列。第二列是 Y 轴值，所以我输入了<code class="fe lb lc ld le b">angle(X, gravityMean)</code>值。颜色在<code class="fe lb lc ld le b">c</code>中定义，主题编号设置为<code class="fe lb lc ld le b">label</code>，线条宽度在<code class="fe lb lc ld le b">linewidth</code>中设置为 4。然后，我指定绘图的 X 轴标签、Y 轴标签和标题。<code class="fe lb lc ld le b">legend()</code>方法在图上显示图例。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/e1c12d48c7d3c1e431e6f347aaf963a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1gjlrIJwoRHVt0MJRzBTeg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Angle between X and mean Gravity v/s Time graph</figcaption></figure><p id="a70d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们仔细观察图表，我们可以看到平均每条线在 0.2–0.3 值的最大范围之间转换。这确实是预期的行为，因为微小的变化可能是由微小的人为错误造成的。</p><h1 id="970a" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">将活动分类</h1><p id="7214" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">现在是我们过程中的最后一步，实际使用机器学习算法并进行分类。</p><p id="8634" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建一个大小为 4 的零数组来存储每个算法的精度。我们将在创建条形图时使用它。</p><pre class="nd ne nf ng gt oa le ob oc aw od bi"><span id="932b" class="nm ln iq le b gy oe of l og oh">accuracy_scores = np.zeros(4)</span></pre><p id="2267" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每一个的过程都是一样的，因为我将使用各种参数的默认值。让我们借助支持向量分类器来理解一下。首先，我把算法的名字写成 imported <code class="fe lb lc ld le b">SVC()</code>。随后是<code class="fe lb lc ld le b">fit()</code>方法，该方法根据提供的数据对算法进行建模。我输入参数作为训练数据，因此，<code class="fe lb lc ld le b">X_train</code>和<code class="fe lb lc ld le b">y_train</code>。</p><p id="9b44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我使用<code class="fe lb lc ld le b">predict()</code>方法预测测试数据<code class="fe lb lc ld le b">X_test</code>的输出，并将其存储在<code class="fe lb lc ld le b">prediction</code>变量中。然后我使用<code class="fe lb lc ld le b">accuracy_score</code>函数来计算精度，它将第一个参数作为真值，第二个参数作为预测值。我把它乘以 100 转换成百分比。我们对每个算法都执行相同的步骤。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="90f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从上面的输出值可以看出，<em class="li">逻辑回归</em>算法表现最好，准确率超过 96%。我们也可以将输出可视化为条形图。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/490010201359cb9b549a225cbd573118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mKWeP6bbAN6oUb2nTDArUw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Classifiers accuracy bars</figcaption></figure><h1 id="a48f" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="c8ed" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在本文中，我讨论了活动识别，从数据集绘制了可视化效果，并使用机器学习算法对活动进行分类。从结果来看，<em class="li"> Logistic 回归</em>的准确率最高。</p></div><div class="ab cl oj ok hu ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ij ik il im in"><p id="fd4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你喜欢我的作品。从未来的角度来看，您可以尝试其他算法，或者选择不同的参数值来进一步提高精度。请随时分享你的想法和想法。</p></div></div>    
</body>
</html>