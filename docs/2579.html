<html>
<head>
<title>Conversational AI chat-bot — Architecture overview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对话式人工智能聊天机器人——架构概述</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/architecture-overview-of-a-conversational-ai-chat-bot-4ef3dfefd52e?source=collection_archive---------0-----------------------#2018-02-09">https://towardsdatascience.com/architecture-overview-of-a-conversational-ai-chat-bot-4ef3dfefd52e?source=collection_archive---------0-----------------------#2018-02-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="720f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章的目的是给出一个典型的架构概述，以建立一个对话式人工智能聊天机器人。我们将详细回顾架构和各自的组件(<em class="kl">注</em> — <em class="kl">本文中引用的架构和术语大多来自我对</em><a class="ae km" href="https://core.rasa.ai/" rel="noopener ugc nofollow" target="_blank"><em class="kl">rasa-core</em></a><em class="kl">开源软件的理解)。</em></p><p id="d3ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以让我们开始吧…</p><p id="3151" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如本文标题所示，主要方面是—</p><ol class=""><li id="7b58" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated"><strong class="jp ir">它是一个聊天机器人</strong>——在本文中，为了简单起见，假设用户将输入文本，机器人将以文本的形式用适当的消息作出响应(<em class="kl">因此，我们将不涉及ASR、语音识别、语音到文本、文本到语音等方面。，根据需要，无论如何都可以使用这些组件增强以下架构</em>。</li></ol><p id="2276" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2。这是对话！</strong> —这是什么意思？机器人应该以某种方式维护对话的状态，并在当前上下文中响应用户请求(也称为。它需要是上下文感知的)。例如，假设对话流程是这样的——</p><ul class=""><li id="8a2c" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk kw kt ku kv bi translated">用户——明天天气怎么样？</li><li id="71c0" class="kn ko iq jp b jq kx ju ky jy kz kc la kg lb kk kw kt ku kv bi translated">明天大部分时间是多云，有小雨。</li><li id="bb5a" class="kn ko iq jp b jq kx ju ky jy kz kc la kg lb kk kw kt ku kv bi translated">用户——后天怎么样？(<em class="kl">因此，当提出这个问题时，机器人应该记住，这次对话的最近上下文是关于实体“天气”(而不是交通拥堵或预订可用性之类的其他东西，假设它们出现在之前的对话中)。</em></li></ul><p id="5f95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3。</strong>这是一个<strong class="jp ir"> AI / ML驱动的架构:</strong>该模型根据提供的训练数据学习动作(不像传统的基于状态机的架构，它是基于为对话的每个可能状态编码所有可能的if-else条件。)</p><p id="389f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个聊天机器人架构的高级概述。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/124f4c1b57573dbc6040762eb74032a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0JqMq7W9ndcOmL3UQ5lPhQ.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Chatbot architecture — image copyright@ <a class="ls lt ep" href="https://medium.com/u/c3f8c66f5451?source=post_page-----4ef3dfefd52e--------------------------------" rel="noopener" target="_blank">Ravindra Kompella</a></figcaption></figure><p id="1c6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们浏览流程时，我将参考上图中的组件。首先，让我们看看在对话流程的任何给定时刻，我们需要什么来决定适当的回应？</p><ol class=""><li id="b069" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">我们需要知道用户的意图——我们称之为<strong class="jp ir"> <em class="kl">意图</em> </strong>。意图的几个例子是——“请求天气”、“请求餐馆”等。上例中的意图是“请求天气”。</li><li id="3e4f" class="kn ko iq jp b jq kx ju ky jy kz kc la kg lb kk ks kt ku kv bi translated">我们需要知道请求中的具体意图(我们称它们为<strong class="jp ir"> <em class="kl">实体</em> </strong>)，例如——什么时候？，哪里？，有多少？等等。，分别对应于从用户请求中提取关于日期时间、位置、数字的信息。这里的日期时间、位置、数字都是<strong class="jp ir"> <em class="kl">的实体</em> </strong>。引用上面的天气示例，实体可以是“日期时间”(用户提供的信息)和位置(注意，位置不必是用户提供的显式输入，并且如果没有指定，将根据默认的用户位置来确定)。</li></ol><p id="1a04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">意图和实体一起将有助于对天气服务进行相应的API调用并检索结果，我们将在后面看到。</p><p id="9640" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在参考上图，代表<strong class="jp ir"> NLU组件(</strong> <em class="kl">【自然语言理解】</em> <strong class="jp ir"> ) </strong>的方框有助于从用户请求中提取意图和实体。</p><p id="b4d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> NLU成分</strong>成分—</p><ul class=""><li id="3a9d" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk kw kt ku kv bi translated">一个有监督的意图分类模型，以各种句子作为输入，以意图作为目标进行训练。通常，线性SVM将足以作为意图分类模型。</li><li id="52b4" class="kn ko iq jp b jq kx ju ky jy kz kc la kg lb kk kw kt ku kv bi translated">实体提取模型—这可以是预训练的模型，如Spacy或StanfordNLP库(或),也可以使用一些概率模型，如CRF(条件随机场)进行训练。</li></ul><p id="4962" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.现在，由于我们的是一个对话式人工智能机器人，我们需要跟踪迄今为止发生的对话，以预测适当的反应。为此，我们需要一个dictionary对象，它可以持久存储有关当前意图、当前实体的信息，以及用户对bot之前的问题、bot之前的操作、API调用结果(如果有)提供的持久存储信息。这些信息将构成我们输入的<strong class="jp ir"> X，</strong>特征向量。对话模型将要被训练的目标<strong class="jp ir"> <em class="kl"> y、</em> </strong>将是“<strong class="jp ir"><em class="kl">next _ action”</em></strong>(<strong class="jp ir"><em class="kl">next _ action</em></strong>可以简单地是对应于我们在训练数据中定义的每个动作的独热码编码向量)。</p><p id="fa88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，这将我们带到下一个问题——我们如何获得我们的特征向量的训练值，输入<strong class="jp ir"> X </strong>？</p><ul class=""><li id="0ca9" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk kw kt ku kv bi translated">正如我们从NLU组件中看到的那样，获取关于意图和实体的信息非常简单。</li><li id="4773" class="kn ko iq jp b jq kx ju ky jy kz kc la kg lb kk kw kt ku kv bi translated">获取剩余的值(<em class="kl">)信息，用户将提供给机器人之前的问题、机器人之前的动作、API调用的结果等。，</em>)有点棘手，这里是对话管理器组件接管的地方。这些特征值将需要从用户将以用户和机器人之间的<strong class="jp ir"> <em class="kl">样本对话</em> </strong>的形式定义的训练数据中提取。<strong class="jp ir"> <em class="kl"> </em> </strong>这些<strong class="jp ir"> <em class="kl">样本对话</em> </strong>应该以这样一种方式准备，即它们在假装既是用户又是机器人的同时，捕捉大多数可能的对话流。</li></ul><p id="adfe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">注意— </em> </strong>如果计划从头开始构建示例对话，那么一个推荐的方法是使用一种叫做<strong class="jp ir"> <em class="kl">交互式学习的方法。</em>该模型使用该反馈来改进其对下一次的预测(这类似于强化学习技术，其中该模型因其正确的预测而得到奖励)。</strong></p><p id="143e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我就不赘述提取每个特征值的细节了。它可以从我在上面提供的rasa-core link的文档中引用。因此，假设我们以所需的格式从样本对话中提取了所有所需的特征值，那么我们可以训练一个像LSTM和softmax这样的人工智能模型来预测<strong class="jp ir"> <em class="kl"> next_action。</em> </strong>参考上图，这就是'<strong class="jp ir">对话管理</strong>'组件的作用。为什么LSTM更合适？—如上所述，我们希望我们的模型能够感知上下文，并回顾对话历史来预测<strong class="jp ir"> <em class="kl"> next_action。</em> </strong>这类似于时间序列模型(请参见我的另一篇<a class="ae km" rel="noopener" target="_blank" href="/using-lstms-to-forecast-time-series-4ab688386b1f"> LSTM时间序列</a>文章)，因此可以在LSTM模型的内存状态中得到最好的捕捉。我们想要回顾的对话历史的数量可以是模型的可配置的超参数。</p><p id="8c48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，<strong class="jp ir"> <em class="kl"> next_action </em> </strong>的预测值可以是这样的—</p><ul class=""><li id="bf3f" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk kw kt ku kv bi translated">用适当的消息响应用户</li><li id="5d53" class="kn ko iq jp b jq kx ju ky jy kz kc la kg lb kk kw kt ku kv bi translated">从数据库中检索一些数据(如果我们有的话)</li><li id="f476" class="kn ko iq jp b jq kx ju ky jy kz kc la kg lb kk kw kt ku kv bi translated">进行一次API调用，得到一些符合意图的结果。</li></ul><p id="0270" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果恰好是API调用/数据检索，则控制流句柄将保留在“对话管理”组件中，该组件将进一步使用/保持该信息，以再次预测<strong class="jp ir"> <em class="kl"> next_action、</em> </strong>。对话管理器将基于该动作和检索的结果更新其当前状态，以进行下一次预测。一旦<strong class="jp ir"> <em class="kl"> next_action </em> </strong>对应于对用户的响应，那么<strong class="jp ir">‘消息生成器’</strong>组件就会接管。</p><p id="d638" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">消息生成器</strong>组件由几个用户定义的模板组成(<em class="kl">模板只是带有一些占位符的句子，视情况而定</em>)，这些模板映射到动作名称。因此，根据对话管理器预测的动作，调用相应的模板消息。如果模板需要填充一些占位符值，对话管理器也会将这些值传递给生成器。然后，向用户显示适当的消息，机器人进入等待模式，监听用户输入。</p></div></div>    
</body>
</html>