<html>
<head>
<title>Bitcoin Price Prediction Using Time Series Forecasting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用时间序列预测的比特币价格预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bitcoin-price-prediction-using-time-series-forecasting-9f468f7174d3?source=collection_archive---------3-----------------------#2018-06-27">https://towardsdatascience.com/bitcoin-price-prediction-using-time-series-forecasting-9f468f7174d3?source=collection_archive---------3-----------------------#2018-06-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a484323474be3b55314335092ab282b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zl6DHVp1I-LtIOnZUgNbFw.jpeg"/></div></div></figure><p id="fe4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章是关于使用时间序列预测来预测比特币价格的。时间序列预测与其他机器学习模型非常不同，因为-</p><p id="63eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1.它依赖于时间。因此，线性回归模型的基本假设，即观察值是独立的，在这种情况下不成立。</p><p id="513c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.除了增加或减少的趋势，大多数时间序列都有某种形式的季节性趋势，即特定时间范围内的变化。</p><p id="04a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，简单的机器学习模型无法使用，因此时间序列预测是一个不同的研究领域。本文采用 AR(自回归模型)、MA(移动平均模型)和 ARIMA(自回归综合移动平均模型)等时间序列模型对比特币价格进行预测。</p><p id="0917" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该数据集包含 2013 年 4 月至 2017 年 8 月比特币的开盘价和收盘价</p><h1 id="dc0b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">导入必要的库</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="54cf" class="md kx iq lz b gy me mf l mg mh"><strong class="lz ir">import</strong> <strong class="lz ir">pandas</strong> <strong class="lz ir">as</strong> <strong class="lz ir">kunfu</strong><br/><strong class="lz ir">import</strong> <strong class="lz ir">numpy</strong> <strong class="lz ir">as</strong> <strong class="lz ir">dragon</strong><br/><strong class="lz ir">import</strong> <strong class="lz ir">pylab</strong> <strong class="lz ir">as</strong> <strong class="lz ir">p</strong><br/><strong class="lz ir">import</strong> <strong class="lz ir">matplotlib.pyplot</strong> <strong class="lz ir">as</strong> <strong class="lz ir">plot</strong><br/><strong class="lz ir">from</strong> <strong class="lz ir">collections</strong> <strong class="lz ir">import</strong> Counter<br/><strong class="lz ir">import</strong> <strong class="lz ir">re</strong><br/><br/><em class="mi">#importing packages for the prediction of time-series data</em><br/><strong class="lz ir">import</strong> <strong class="lz ir">statsmodels.api</strong> <strong class="lz ir">as</strong> <strong class="lz ir">sm</strong><br/><strong class="lz ir">import</strong> <strong class="lz ir">statsmodels.tsa.api</strong> <strong class="lz ir">as</strong> <strong class="lz ir">smt</strong><br/><strong class="lz ir">import</strong> <strong class="lz ir">statsmodels.formula.api</strong> <strong class="lz ir">as</strong> <strong class="lz ir">smf</strong><br/><br/><strong class="lz ir">from</strong> <strong class="lz ir">sklearn.metrics</strong> <strong class="lz ir">import</strong> mean_squared_error<br/></span></pre><p id="bb60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">数据从 csv 文件加载到列车数据帧中。这是我们数据的前五行看起来的样子。</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/02427727f31dcbbcfe6addd69c536770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*dH5B1X7Z8HeQOCRFFCNXpw.png"/></div></figure><h1 id="3736" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">绘制时间序列</h1><p id="e2d1" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">以日期为索引，x 轴为日期，y 轴为收盘价。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="2e0d" class="md kx iq lz b gy me mf l mg mh">data = train['Close']<br/>Date1 = train['Date']<br/>train1 = train[['Date','Close']]<br/><em class="mi"># Setting the Date as Index</em><br/>train2 = train1.set_index('Date')<br/>train2.sort_index(inplace=<strong class="lz ir">True</strong>)<br/>print (type(train2))<br/>print (train2.head())<br/>plot.plot(train2)<br/>plot.xlabel('Date', fontsize=12)<br/>plot.ylabel('Price in USD', fontsize=12)<br/>plot.title("Closing price distribution of bitcoin", fontsize=15)<br/>plot.show()</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/27045e6ecfbb66d109d54033d0fbcf1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*Hm4_W8hWM84R-legpFri-g.png"/></div></figure><h1 id="4411" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">测试平稳性</strong></h1><p id="68f2" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated"><strong class="ka ir">增强迪基富勒测验:</strong></p><p id="51ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">扩展的 Dicky Fuller 检验是一种称为单位根检验的统计检验。</p><p id="831c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">单位根检验背后的直觉是，它决定了趋势对时间序列的定义有多强。</p><p id="e18f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">单位根检验有许多种，ADF 是应用最广泛的一种</p><p id="87c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 1。</strong> <strong class="ka ir">零假设(H0): </strong>检验的零假设是时间序列可以用一个非平稳的单位根来表示。</p><p id="f182" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.<strong class="ka ir">备选假设(H1): </strong>检验的备选假设是时间序列是平稳的。</p><p id="2919" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">p 值的解释</strong></p><p id="43a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 1。</strong> <strong class="ka ir"> p 值</strong> &gt; <strong class="ka ir"> 0.05: </strong>接受零假设(H0)，数据有单位根，非平稳。</p><p id="1920" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2。</strong> <strong class="ka ir"> p 值</strong> &lt; = <strong class="ka ir"> 0.05: </strong>拒绝零假设(H0)，数据是平稳的。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="019f" class="md kx iq lz b gy me mf l mg mh"><strong class="lz ir">from</strong> <strong class="lz ir">statsmodels.tsa.stattools</strong> <strong class="lz ir">import</strong> adfuller<br/><br/><strong class="lz ir">def</strong> test_stationarity(x):<br/><br/><br/>    <em class="mi">#Determing rolling statistics</em><br/>    rolmean = x.rolling(window=22,center=<strong class="lz ir">False</strong>).mean()<br/><br/>    rolstd = x.rolling(window=12,center=<strong class="lz ir">False</strong>).std()<br/>    <br/>    <em class="mi">#Plot rolling statistics:</em><br/>    orig = plot.plot(x, color='blue',label='Original')<br/>    mean = plot.plot(rolmean, color='red', label='Rolling Mean')<br/>    std = plot.plot(rolstd, color='black', label = 'Rolling Std')<br/>    plot.legend(loc='best')<br/>    plot.title('Rolling Mean &amp; Standard Deviation')<br/>    plot.show(block=<strong class="lz ir">False</strong>)<br/>    <br/>    <em class="mi">#Perform Dickey Fuller test    </em><br/>    result=adfuller(x)<br/>    print('ADF Stastistic: <strong class="lz ir">%f</strong>'%result[0])<br/>    print('p-value: <strong class="lz ir">%f</strong>'%result[1])<br/>    pvalue=result[1]<br/>    <strong class="lz ir">for</strong> key,value <strong class="lz ir">in</strong> result[4].items():<br/>         <strong class="lz ir">if</strong> result[0]&gt;value:<br/>            print("The graph is non stationery")<br/>            <strong class="lz ir">break</strong><br/>         <strong class="lz ir">else</strong>:<br/>            print("The graph is stationery")<br/>            <strong class="lz ir">break</strong>;<br/>    print('Critical values:')<br/>    <strong class="lz ir">for</strong> key,value <strong class="lz ir">in</strong> result[4].items():<br/>        print('<strong class="lz ir">\t%s</strong>: <strong class="lz ir">%.3f</strong> ' % (key, value))<br/>        <br/>ts = train2['Close']      <br/>test_stationarity(ts)<br/></span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/4cd23d283521db19497ae7c628eb71ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*RPtZSeqF63m-mi-5U3riLw.png"/></div></figure><p id="d785" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于 p 值大于 0.05，时间序列是非平稳的。到目前为止，我们测试了这个系列，它不是稳定的。因此，这里需要做一些工作。所以现在我们用变换使级数平稳。</p><h1 id="1a2d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">测井转换系列</strong></h1><p id="1e6a" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">日志转换用于对高度扭曲的数据进行去扭曲。从而有助于预测过程。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="f0ae" class="md kx iq lz b gy me mf l mg mh">ts_log = dragon.log(ts)<br/>plot.plot(ts_log,color="green")<br/>plot.show()<br/><br/>test_stationarity(ts_log)</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/1299ac6c4cc883b3c0602cb9646fffec.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*bX_xhXMHrEmE1VDdQGuhgg.png"/></div></figure><p id="728d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于 p 值仍然大于 0.05，所以序列仍然是非平稳的，所以我们需要做进一步的变换。让我们继续做差分。</p><h1 id="1f6f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">通过差异消除趋势和季节性</h1><p id="d500" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">在差分以使时间序列稳定的情况下，当前值与先前值相减。由于这一点，平均值是稳定的，因此时间序列的平稳性的机会增加。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="4014" class="md kx iq lz b gy me mf l mg mh">ts_log_diff = ts_log - ts_log.shift()<br/>plot.plot(ts_log_diff)<br/>plot.show()</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/2cf179e7e2d978639d50b6b08f21eb94.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*YqBjzjMGmq1-rKlkJaDDjw.png"/></div></figure><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="b800" class="md kx iq lz b gy me mf l mg mh">ts_log_diff.dropna(inplace=<strong class="lz ir">True</strong>)<br/>test_stationarity(ts_log_diff)</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/e8fff7134942831fd187272eb1f95e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*7gnDAr8nwEIsaEs0cz3G5g.png"/></div></div></figure><p id="eb08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们的时间序列现在是平稳的，因为我们的 p 值小于 0.05，因此我们可以应用时间序列预测模型。</p><h1 id="8256" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">自回归模型</strong></h1><p id="7f6d" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">自回归模型是一种时间序列预测模型，其中当前值依赖于过去值。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="8ef6" class="md kx iq lz b gy me mf l mg mh"><em class="mi"># follow lag</em><br/>model = ARIMA(ts_log, order=(1,1,0))  <br/>results_ARIMA = model.fit(disp=-1)  <br/>plot.plot(ts_log_diff)<br/>plot.plot(results_ARIMA.fittedvalues, color='red')<br/>plot.title('RSS: <strong class="lz ir">%.7f</strong>'% sum((results_ARIMA.fittedvalues-ts_log_diff)**2))<br/>plot.show()</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/2eda472201f6c29ad239048cee89c849.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*kOXKtYP3sVKrGZ5Vy7csmA.png"/></div></figure><h1 id="42f6" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">移动平均模型</h1><p id="bdc6" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">在移动平均模型中，序列依赖于过去的误差项。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="05d1" class="md kx iq lz b gy me mf l mg mh"><em class="mi"># follow error</em><br/>model = ARIMA(ts_log, order=(0,1,1))  <br/>results_MA = model.fit(disp=-1)  <br/>plot.plot(ts_log_diff)<br/>plot.plot(results_MA.fittedvalues, color='red')<br/>plot.title('RSS: <strong class="lz ir">%.7f</strong>'% sum((results_MA.fittedvalues-ts_log_diff)**2))<br/>plot.show()<br/></span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/f1153c49229f7d94e89a418535c7c470.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*g_lVF79Q7R9IEYg5yfsLIA.png"/></div></figure><h1 id="12ac" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">自回归综合移动平均模型</h1><p id="9ff7" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">它是 AR 和 MA 模型的结合。它通过差分过程使时间序列本身平稳。因此，对于 ARIMA 模型，不需要明确地进行差分</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="5300" class="md kx iq lz b gy me mf l mg mh"><strong class="lz ir">from</strong> <strong class="lz ir">statsmodels.tsa.arima_model</strong> <strong class="lz ir">import</strong> ARIMA<br/>model = ARIMA(ts_log, order=(2,1,0))  <br/>results_ARIMA = model.fit(disp=-1)  <br/>plot.plot(ts_log_diff)<br/>plot.plot(results_ARIMA.fittedvalues, color='red')<br/>plot.title('RSS: <strong class="lz ir">%.7f</strong>'% sum((results_ARIMA.fittedvalues-ts_log_diff)**2))<br/>plot.show()</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/c14f2dbf889014af7b1136403e672b00.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*bqDE83MTkP6zeEGeNxiUXQ.png"/></div></figure><p id="e466" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们看到，RSS(残差平方和)误差是最小的 ARIMA 模型。因此，ARIMA 模型是三个模型中最好的，因为它利用了对滞后值和误差项的依赖性。因此，它进一步用于计算均方差。在下面的代码片段中，数据集分为训练和测试。</p><p id="b5cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于测试中的每个值，我们应用 ARIMA 模型，然后计算误差，然后在迭代测试集中的所有值后，计算预测值和期望值之间的平均误差。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="a0df" class="md kx iq lz b gy me mf l mg mh">size = int(len(ts_log)-100)</span><span id="60d3" class="md kx iq lz b gy mx mf l mg mh"># Divide into train and test<br/>train_arima, test_arima = ts_log[0:size], ts_log[size:len(ts_log)]</span><span id="221e" class="md kx iq lz b gy mx mf l mg mh">history = [x <strong class="lz ir">for</strong> x <strong class="lz ir">in</strong> train_arima]predictions = list()<br/>originals = list()<br/>error_list = list()<br/><br/>print('Printing Predicted vs Expected Values...')<br/>print('<strong class="lz ir">\n</strong>')</span><span id="0105" class="md kx iq lz b gy mx mf l mg mh"># We go over each value in the test set and then apply ARIMA model and calculate the predicted value. We have the expected value in the test set therefore we calculate the error between predicted and expected value </span><span id="5699" class="md kx iq lz b gy mx mf l mg mh"><strong class="lz ir">for</strong> t <strong class="lz ir">in</strong> range(len(test_arima)):<br/>    model = ARIMA(history, order=(2, 1, 0))<br/>    model_fit = model.fit(disp=-1)<br/>    <br/>    output = model_fit.forecast()<br/>    <br/>    pred_value = output[0]<br/>    <br/>        <br/>    original_value = test_arima[t]<br/>    history.append(original_value)<br/>    <br/>    pred_value = dragon.exp(pred_value)<br/>    <br/>    <br/>    original_value = dragon.exp(original_value)<br/>    <br/>    # Calculating the error<br/>    error = ((abs(pred_value - original_value)) / original_value) * 100<br/>    error_list.append(error)<br/>    print('predicted = <strong class="lz ir">%f</strong>,   expected = <strong class="lz ir">%f</strong>,   error = <strong class="lz ir">%f</strong> ' % (pred_value, original_value, error), '%')<br/>    <br/>    predictions.append(float(pred_value))<br/>    originals.append(float(original_value))<br/>    <br/># After iterating over whole test set the overall mean error is calculated.   <br/>print('<strong class="lz ir">\n</strong> Mean Error in Predicting Test Case Articles : <strong class="lz ir">%f</strong> ' % (sum(error_list)/float(len(error_list))), '%')</span><span id="3e9e" class="md kx iq lz b gy mx mf l mg mh">plot.figure(figsize=(8, 6))<br/>test_day = [t<br/>           <strong class="lz ir">for</strong> t <strong class="lz ir">in</strong> range(len(test_arima))]<br/>labels={'Orginal','Predicted'}<br/>plot.plot(test_day, predictions, color= 'green')<br/>plot.plot(test_day, originals, color = 'orange')<br/>plot.title('Expected Vs Predicted Views Forecasting')<br/>plot.xlabel('Day')<br/>plot.ylabel('Closing Price')<br/>plot.legend(labels)<br/>plot.show()</span></pre><p id="d7b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">预测= 2513.745189，预期= 2564.060000，误差= 1.962310 % <br/>预测= 2566.007269，预期= 2601.640000，误差= 1.369626 % <br/>预测= 2604.348629，预期= 2601.990000，误差= 0.090647 % <br/> 预期= 2372.560000，误差= 6.258791 % <br/>预测= 2379.066829，预期= 2337.790000，误差= 1.765635 % <br/>预测= 2348.468544，预期= 2398.840000，误差= 2.099826 % <br/>预测= 2405.2999999 误差= 12.841677 % <br/>预测= 2238.150016，预期= 2318.880000，误差= 3.481421 % <br/>预测= 2307.325788，预期= 2273.430000，误差= 1.490954 % <br/>预测= 2272.890197，预期= 2817.60000 误差= 0.899246 % <br/>预测= 2763.766195，预期= 2576.480000，误差= 7.269072 % <br/>预测= 2580.946838，预期= 2529.450000，误差= 2.035891 % <br/>预测= 2541.493507，预期= 2671.7800000</p><p id="d701" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">预测测试用例文章的平均误差:3.593133 %</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/f077303a2eb385aa1daeb6bfe89c2ea7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*UjJbVxAZFrSmaZY20sN0HQ.png"/></div></figure><p id="a427" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，原始时间序列和预测时间序列的平均误差为 3.59%。因此，我们能够使用不同的转换和模型来预测比特币的收盘价。</p><p id="5cee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你读到最后，谢谢你。这是我关于数据科学的第一篇文章，以后还会有更多文章。如果您发现任何错误或有任何建议，请做评论。如果你喜欢这个帖子，请不要忘记鼓掌！谢谢你。</p></div></div>    
</body>
</html>