<html>
<head>
<title>From Scikit-learn to TensorFlow : Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Scikit-学习到TensorFlow:第1部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/from-scikit-learn-to-tensorflow-part-1-9ee0b96d4c85?source=collection_archive---------1-----------------------#2017-05-06">https://towardsdatascience.com/from-scikit-learn-to-tensorflow-part-1-9ee0b96d4c85?source=collection_archive---------1-----------------------#2017-05-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="aef1" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="9663" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在过去的一年半时间里，<a class="ae lj" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>无论是在<a class="ae lj" href="http://deliprao.com/archives/168" rel="noopener ugc nofollow" target="_blank">采用率</a>还是在<a class="ae lj" href="https://www.tensorflow.org/performance/benchmarks" rel="noopener ugc nofollow" target="_blank">计算速度</a>方面都以惊人的速度增长。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lk"><img src="../Images/50c4c3a02227b682086058fbae574ec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RwVhfOeLkfr3mtOs_70zgg.png"/></div></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi md"><img src="../Images/de03aa802d9f20920b62ffd158779afa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*IMqoXeCUZKSDfRTZSzj9tA.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Image Source: Unreasonable Popularity of TensorFlow [<a class="ae lj" href="http://deliprao.com/archives/168" rel="noopener ugc nofollow" target="_blank">http://deliprao.com/archives/168</a>]</figcaption></figure><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="1f54" class="pw-post-body-paragraph kl km iq kn b ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le mo lg lh li ij bi translated">TensorFlow已经成为最受欢迎的机器学习(ML)算法开发库。然而，它似乎也把自己建立成了一个库，需要对会话和图形进行定义，这是相当乏味和耗时的。虽然它在有效计算梯度以训练<a class="ae lj" href="https://en.wikipedia.org/wiki/Convolutional_neural_network" rel="noopener ugc nofollow" target="_blank">CNN</a>、<a class="ae lj" href="https://en.wikipedia.org/wiki/Recurrent_neural_network" rel="noopener ugc nofollow" target="_blank"> RNNs </a>和<a class="ae lj" href="https://en.wikipedia.org/wiki/Long_short-term_memory" rel="noopener ugc nofollow" target="_blank">lstm</a>方面做得很好，但这还不是全部。</p><p id="5ab2" class="pw-post-body-paragraph kl km iq kn b ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le mo lg lh li ij bi translated">在这一系列帖子中，我想讨论如何将TensorFlow用作通用ML库。更具体地说，我们将讨论它如何类似于<a class="ae lj" href="http://scikit-learn.org/" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>，另一个在数据科学家和开发人员中非常流行的ML库。</p><h1 id="0807" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">转向TensorFlow的理由</h1><p id="b35f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">虽然scikit-learn拥有高度优化的算法，但在面对大量数据点时，它缺乏扩展能力。然而，TensorFlow提供了许多优于scikit-learn的优势:</p><ul class=""><li id="7c8c" class="mp mq iq kn b ko mk ks ml kw mr la ms le mt li mu mv mw mx bi translated">高性能ML模块</li><li id="e6f6" class="mp mq iq kn b ko my ks mz kw na la nb le nc li mu mv mw mx bi translated">可定制性</li><li id="c15f" class="mp mq iq kn b ko my ks mz kw na la nb le nc li mu mv mw mx bi translated">纵向扩展以满足大数据点的需求</li><li id="3061" class="mp mq iq kn b ko my ks mz kw na la nb le nc li mu mv mw mx bi translated">能够利用GPU并在地理上分散的GPU设备之间进行培训</li><li id="ae02" class="mp mq iq kn b ko my ks mz kw na la nb le nc li mu mv mw mx bi translated">设备无关计算</li><li id="ed4d" class="mp mq iq kn b ko my ks mz kw na la nb le nc li mu mv mw mx bi translated">利用<a class="ae lj" href="https://cloud.google.com/ml-engine/" rel="noopener ugc nofollow" target="_blank"> Google Cloud </a>在训练好的ML模型上进行推理</li><li id="083e" class="mp mq iq kn b ko my ks mz kw na la nb le nc li mu mv mw mx bi translated">高度灵活的<a class="ae lj" href="https://github.com/tensorflow/tensorflow/blob/master/LICENSE" rel="noopener ugc nofollow" target="_blank"> Apache 2.0许可</a>而scikit-learn是基于<a class="ae lj" href="http://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> BSD许可</a>(虽然两者都是商业可用的，但是Apache 2.0不太容易出现专利诉讼)</li></ul><h1 id="3a3a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">目标</h1><ul class=""><li id="ad1e" class="mp mq iq kn b ko kp ks kt kw nd la ne le nf li mu mv mw mx bi translated">了解scikit-learn和TensorFlow之间的相似功能，这些功能将允许scikit-learn用户无缝使用TensorFlow。</li><li id="8457" class="mp mq iq kn b ko my ks mz kw na la nb le nc li mu mv mw mx bi translated">使用scikit-learn和TensorFlow开发一个程序来对来自<a class="ae lj" href="http://archive.ics.uci.edu/ml/datasets/Iris?ref=datanews.io" rel="noopener ugc nofollow" target="_blank">鸢尾花</a>数据集的花卉品种进行分类，以了解构建这样一个系统所需的工作。</li><li id="f3bb" class="mp mq iq kn b ko my ks mz kw na la nb le nc li mu mv mw mx bi translated">展示TensorFlow如何简单地实现新想法的原型。</li></ul><h1 id="deb6" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">功能级相似性</h1><p id="d165" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">scikit-learn受欢迎的原因之一是由于它的简单</p><pre class="ll lm ln lo gt ng nh ni nj aw nk bi"><span id="daf5" class="nl jo iq nh b gy nm nn l no np">classifier.fit() / classifier.predict() </span></pre><p id="de12" class="pw-post-body-paragraph kl km iq kn b ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le mo lg lh li ij bi translated">对于所使用的任何分类器都保持不变的方法。这种简单的用户体验使开发人员能够专注于算法及其参数，而不是担心需要调用哪些API来完成手头的任务。</p><p id="599d" class="pw-post-body-paragraph kl km iq kn b ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le mo lg lh li ij bi translated">另一方面，我们在TensorFlow中有受scikit-learn启发的高级API 。TensorFlow中的这些函数的工作方式与scikit-learn非常相似，具有类似的<em class="nq"> fit </em>和<em class="nq"> predict </em>方法以及允许进一步微调的其他功能。</p><p id="2f84" class="pw-post-body-paragraph kl km iq kn b ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le mo lg lh li ij bi translated">在我们深入研究使用TensorFlow的高级API调用开发我们的分类框架之前，让我们讨论一下TensorFlow的低级计算框架。TensorFlow使用<a class="ae lj" href="https://www.tensorflow.org/versions/r0.10/get_started/basic_usage" rel="noopener ugc nofollow" target="_blank">计算图</a>来执行所有计算。计算被表示为<code class="fe nr ns nt nh b">tf.Graph</code>对象的实例，其中数据被表示为<code class="fe nr ns nt nh b">tf.Tensor</code>对象，并且使用<code class="fe nr ns nt nh b">tf.Operation</code>对象对这些张量对象进行操作。然后使用<code class="fe nr ns nt nh b">tf.Session</code>对象在会话中执行该图。很明显，使用TensorFlow的低级API创建一个分类框架需要测试一个简单的ML原型。这也是我们讨论TensorFlow的高级API与scikit-learn的API进行对比的原因之一。我们将在以后的文章中讨论低级API及其用法。</p><h1 id="d608" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">示例代码</h1><p id="fbae" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们使用scikit-learn的<a class="ae lj" href="http://scikit-learn.org/stable/modules/svm.html" rel="noopener ugc nofollow" target="_blank"> SVM </a>模块和TensorFlow的高级API构建了一个分类器，根据花的特征对花进行分类。在这种情况下，数据集提供了4个不同的特征，如<em class="nq">萼片宽度</em>、<em class="nq">萼片长度</em>、<em class="nq">花瓣宽度</em>和<em class="nq">花瓣长度</em>，以将花分类为三个花卉品种之一(<em class="nq">鸢尾、杂色鸢尾</em>和<em class="nq">海滨鸢尾</em>)。)</p><p id="276f" class="pw-post-body-paragraph kl km iq kn b ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le mo lg lh li ij bi translated">这个项目的代码可以在我的GitHub页面上找到。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi nu"><img src="../Images/d8fe74a0f933dcec26b0f9721957cb61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xOxhDM-2Cz8RL16rkRBPKQ.jpeg"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Image source: TensorFlow Quickstart [<a class="ae lj" href="https://www.tensorflow.org/get_started/tflearn" rel="noopener ugc nofollow" target="_blank">https://www.tensorflow.org/get_started/tflearn</a>]</figcaption></figure><p id="abef" class="pw-post-body-paragraph kl km iq kn b ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le mo lg lh li ij bi translated">如果我们看看上面GitHub链接上的笔记本，我们可以看到数据加载和拆分功能是由两个框架共享的。我们在scikit-learn中定义了一个SVM分类器，如下所示:</p><pre class="ll lm ln lo gt ng nh ni nj aw nk bi"><span id="f7c9" class="nl jo iq nh b gy nm nn l no np"><em class="nq"># ------------------------------------------</em><br/><em class="nq"># Scikit Learn Implementation</em><br/><em class="nq"># ------------------------------------------</em><br/><em class="nq"># Use support vector classification</em><br/>classifier_sk = svm.SVC()</span><span id="a80e" class="nl jo iq nh b gy nv nn l no np"><em class="nq"># Use the train data to train this classifier</em><br/>classifier_sk.fit(x_train, y_train)</span><span id="9448" class="nl jo iq nh b gy nv nn l no np"><em class="nq"># Use the trained model to predict on the test data</em><br/>predictions = classifier_sk.predict(x_test)<br/>score = metrics.accuracy_score(y_test, predictions)</span></pre><p id="c7cc" class="pw-post-body-paragraph kl km iq kn b ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le mo lg lh li ij bi translated">在上面的代码片段中，我们简单地定义了一个支持向量分类器<em class="nq"> svm。SVC() </em>，其对象用于训练和预测。使用<em class="nq"> fit() </em>实现训练，而使用<em class="nq"> predict() </em>方法调用实现预测。我们最后计算这个四行代码片段最后一行的精度值。</p><p id="ee97" class="pw-post-body-paragraph kl km iq kn b ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le mo lg lh li ij bi translated">另一方面，在TensorFlow中，我们可以使用深度神经网络(DNN)分类器来完成相同的任务。我们使用TensorFlow的<em class="nq"> contrib </em>模块下的<a class="ae lj" href="https://www.tensorflow.org/api_docs/python/tf/contrib/learn/DNNClassifier" rel="noopener ugc nofollow" target="_blank"> DNNClassifier </a>如下:</p><pre class="ll lm ln lo gt ng nh ni nj aw nk bi"><span id="c2ce" class="nl jo iq nh b gy nm nn l no np"><em class="nq"># ------------------------------------------</em><br/><em class="nq"># TensorFlow Implementation</em><br/><em class="nq"># ------------------------------------------</em></span><span id="f427" class="nl jo iq nh b gy nv nn l no np"><em class="nq"># Extract the features from the training data</em><br/>feats = tf.contrib.learn.infer_real_valued_columns_from_input(x_train)</span><span id="451d" class="nl jo iq nh b gy nv nn l no np"><em class="nq"># Building a 3-layer DNN with 50 units each.</em><br/>classifier_tf = tf.contrib.learn.DNNClassifier(feature_columns=feats, <br/>                                               hidden_units=[50, 50, 50], <br/>                                               n_classes=3)</span><span id="aff3" class="nl jo iq nh b gy nv nn l no np"><em class="nq"># Use the train data to train this classifier</em><br/>classifier_tf.fit(x_train, y_train, steps=5000)</span><span id="6cd2" class="nl jo iq nh b gy nv nn l no np"><em class="nq"># Use the trained model to predict on the test data</em><br/>predictions = list(classifier_tf.predict(x_test, as_iterable=True))<br/>score = metrics.accuracy_score(y_test, predictions)</span></pre><p id="11e4" class="pw-post-body-paragraph kl km iq kn b ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le mo lg lh li ij bi translated">在上面的代码片段中，我们可以看到如何为几乎相同数量的行(<em class="nq">构建DNN，除了用于将输入数据转换为要素的附加行。</em>)这一额外的行完成了将输入数据转换成密集的、固定长度的浮点值的任务。</p><h1 id="a4ba" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">向张量流迁移的路径</h1><p id="ae6d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">虽然从一个框架转移到另一个框架的任务通常令人畏惧，有时令人沮丧，但TensorFlow似乎有一座桥梁，允许开发人员从一个不同的框架平稳过渡。<em class="nq"> contrib.learn </em>模块提供了这样一个桥梁，允许从scikit-learn或<a class="ae lj" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank"> Keras </a>到TensorFlow的熟悉路径。</p><p id="ea85" class="pw-post-body-paragraph kl km iq kn b ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le mo lg lh li ij bi translated">TensorFlow还具有足够的适应性，可以包含针对生产质量使用进行了高度优化的<a class="ae lj" href="https://www.tensorflow.org/programmers_guide/reading_data" rel="noopener ugc nofollow" target="_blank">阅读器</a>，同时支持ML社区使用的大多数文件格式。这使得开发人员可以避免依赖其他框架，如<a class="ae lj" href="http://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank">熊猫</a>(它完成了读取文件的繁重工作，但仍然需要手动将数据输入ML框架。)在今年早些时候举行的<a class="ae lj" href="https://www.youtube.com/watch?v=t64ortpgS-E" rel="noopener ugc nofollow" target="_blank"> TensorFlow开发峰会</a>上，TensorFlow阅读器也表现出了高性能。</p><h1 id="1707" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">摘要</h1><p id="1c35" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这篇文章中，我们开始探索使用scikit-learn和TensorFlow开发一个分类器来完成一个简单的任务。我们讨论了高级TensorFlow API如何类似于scikit-learn的API。你可以在我的<a class="ae lj" href="http://bit.ly/sklearn-tf-notebook" rel="noopener ugc nofollow" target="_blank"> GitHub </a>页面访问这篇博客中讨论的代码。</p><p id="7d47" class="pw-post-body-paragraph kl km iq kn b ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le mo lg lh li ij bi translated">在下一篇文章中，我打算介绍更多的scikit模块及其TensorFlow对应模块。你有什么特别的想法吗？给我发推特<a class="ae lj" href="http://bit.ly/twitter-krtk" rel="noopener ugc nofollow" target="_blank"> @krtk </a>或者在<a class="ae lj" href="https://www.linkedin.com/in/karthikmuthuswamy/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。</p></div></div>    
</body>
</html>