<html>
<head>
<title>Multi Label Intent Classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多标签意图分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/multi-label-intent-classification-1cdd4859b93?source=collection_archive---------5-----------------------#2018-08-07">https://towardsdatascience.com/multi-label-intent-classification-1cdd4859b93?source=collection_archive---------5-----------------------#2018-08-07</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><p id="fa62" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">有很多应用需要文本分类，或者我们可以说意图分类。现在，所有的东西都需要分类，就像内容一样，产品也经常被分类。</p><p id="dacb" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">但是网上绝大多数的文本分类文章和教程都是邮件垃圾过滤(spam vs. ham)、情感分析(正面 vs .负面)等二元文本分类。我们现实世界的问题要比这复杂得多。因此，这就是我要在这篇博客中解释的。将文本分类成多个类别。</p><p id="2aec" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><strong class="jq is">问题陈述:</strong></p><p id="83ba" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我为我的 GSoC 项目(Owasp SKF 聊天机器人)开发了这个分类器。问题陈述是针对不同漏洞的安全知识框架知识库。它提供了针对不同漏洞的描述、解决方案和代码示例。所以，我需要对用户的查询进行分类，无论他是要求描述、解决方案还是代码示例。</p><p id="d671" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我使用了<a class="ae km" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>和<a class="ae km" href="http://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> Jupyter Notebook </a>来开发我们的系统，依靠<a class="ae km" href="http://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> Scikit-Learn </a>作为机器学习组件。</p><p id="af4f" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">数据集的准备:</p><p id="cb7f" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">对于任何与分类或机器学习相关的问题，我们首先需要的是格式过于正确的数据。因此，首先我将解释我如何准备意图分类的数据集。</p><pre class="kn ko kp kq gu kr ks kt ku aw kv bi"><span id="ccb8" class="kw kx ir ks b gz ky kz l la lb">import json<br/>import csv<br/>with open("data.json",encoding='utf-8') as read_file:<br/>        data = json.load(read_file)</span></pre><p id="c16e" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">可以在这里查看 data.json <a class="ae km" href="https://github.com/Priya997/SKF-Chatbot/blob/master/Basic_Approach/Scripts_to_prepare_dataset/data.json" rel="noopener ugc nofollow" target="_blank">。我将准备 CSV 格式的数据集，因为它很容易训练模型。</a></p><pre class="kn ko kp kq gu kr ks kt ku aw kv bi"><span id="3d16" class="kw kx ir ks b gz ky kz l la lb">#For parsing the Json<br/>a=data['items']<br/>#Declaration of lists</span><span id="46d7" class="kw kx ir ks b gz lc kz l la lb">title=[]<br/>ques=[]<br/>sol=[]<br/>code=[]</span><span id="9526" class="kw kx ir ks b gz lc kz l la lb">#For accessing the title from Json and storing it in the list.<br/>for d in a: <br/>   title.append((d['title']))</span></pre><p id="0c56" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我的文本分类是针对问答类系统的。因此，我需要生成问题，因为我提取了列表中的所有标题。</p><pre class="kn ko kp kq gu kr ks kt ku aw kv bi"><span id="febb" class="kw kx ir ks b gz ky kz l la lb">for t in title:<br/>	ques.append("What is "+ t + " ?")<br/>	ques.append("What does "+ t + " mean ?")<br/>	ques.append("Tell me something about "+ t + " ?")<br/>	ques.append(t)<br/>	ques.append("Explain " + t +" ?")<br/>	ques.append("Elaborate " + t +" ?")<br/>	ques.append("Can you tell me about " + t + " ?")<br/>	ques.append("What do you know about " + t + " ?")<br/>	ques.append("What can you tell me about " + t + " ?")<br/>	ques.append("I want to know about XSS " + t )<br/>	ques.append("Do you have information about " + t + " ?")</span><span id="1060" class="kw kx ir ks b gz lc kz l la lb">for t in title:<br/>        sol.append("How to solve "+ t + " ?")<br/>        sol.append("How to resolve "+ t + " ?")<br/>        sol.append("How to mitigate "+ t + " ?")<br/>        sol.append("Solution for "+ t)<br/>        sol.append("Provide me some Solution for "+ t)<br/>        sol.append("mitigation for "+ t)<br/>        sol.append("How to stop "+ t + " ?")<br/>        sol.append("How to defend "+ t + " ?")<br/>        sol.append("How to get secured against "+ t + " ?")<br/>        sol.append("Solution, "+t)<br/><br/>for t in title:<br/>        code.append("Give me some sample code of "+ t )<br/>        code.append("Code example of "+ t + " ?")<br/>        code.append("Code of "+ t )</span></pre><p id="91a1" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">因此，问题需要根据描述、解决方案和代码进行分类。所以，我做了三个列表，每个列表存储一个问题。</p><pre class="kn ko kp kq gu kr ks kt ku aw kv bi"><span id="a0cd" class="kw kx ir ks b gz ky kz l la lb">file=open("intent_data.csv","x")<br/>file.write('class,question\n')<br/>for x in ques:<br/>		x=x.replace(",","")<br/>		file.write('Description, '+x+"\n")	 <br/>for y in sol:<br/>		y=y.replace(",","")<br/>		file.write('Solution, '+y+"\n")<br/><br/>for z in code:<br/>		z=z.replace(",","")<br/>		file.write('Code, '+z+"\n")<br/><br/>file.close()</span></pre><figure class="kn ko kp kq gu le gi gj paragraph-image"><div class="gi gj ld"><img src="../Images/47974d966a8a40a0295bc187c1b04d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*D0Q5JS51XLW4SpdAl1uU8g.png"/></div></figure><p id="a9ba" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">所以，现在数据准备好了。你可以在这里查看完整数据<a class="ae km" href="https://github.com/Priya997/SKF-Chatbot/blob/master/Basic_Approach/datasets/intent_data.csv" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="a604" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">为了更好地理解如何准备数据集，您也可以查看这个<a class="ae km" href="https://github.com/Priya997/SKF-Chatbot/blob/master/Basic_Approach/notebook/intent_data_prepare.ipynb" rel="noopener ugc nofollow" target="_blank"> jupyter 笔记本</a>示例。</p><p id="1847" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">现在，我们已经准备好数据😄...是时候用它变变魔术了。让我们看看如何对意图进行分类。</p><p id="f19b" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><strong class="jq is">让我们导入一些库:</strong></p><pre class="kn ko kp kq gu kr ks kt ku aw kv bi"><span id="df81" class="kw kx ir ks b gz ky kz l la lb">import pandas as pd<br/>from io import StringIO<br/>from sklearn.feature_extraction.text import TfidfVectorizer<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.feature_extraction.text import CountVectorizer<br/>from sklearn.feature_extraction.text import TfidfTransformer<br/>from sklearn.naive_bayes import MultinomialNB</span></pre><p id="5ef9" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">首先，我们将从 CSV 文件中提取数据，并将其存储在数据帧中。</p><pre class="kn ko kp kq gu kr ks kt ku aw kv bi"><span id="9758" class="kw kx ir ks b gz ky kz l la lb">def get_data():<br/>    df = pd.read_csv('datasets/intent_data.csv')<br/>    return df</span></pre><p id="29fc" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在这一步中，我们将准备好数据以将其输入算法。首先，我们在<strong class="jq is">‘y’</strong>中获得完整的数据，并使用</p><pre class="kn ko kp kq gu kr ks kt ku aw kv bi"><span id="f5fd" class="kw kx ir ks b gz ky kz l la lb"><strong class="ks is">y=[col]</strong></span></pre><p id="5fae" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">之后，使用'<strong class="jq is"> pd.notnull' </strong>来检查问题列中的数据是否为空，如果为空，则将删除整行。</p><blockquote class="lh li lj"><p id="7606" class="jo jp lk jq b jr js jt ju jv jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk kl ik bi translated">这一步对于获得高质量的干净数据非常重要。因为，如果我们有好的数据，我们就会有好的结果。😃</p></blockquote><p id="25b6" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我们将创建一个新的列<strong class="jq is">‘category _ id’</strong>，它将给出一个班级编号。类似于描述，它将是 0，解决方案 1 和代码 2。</p><p id="4706" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">删除重复后，我们将得到类似这样的东西</p><pre class="kn ko kp kq gu kr ks kt ku aw kv bi"><span id="b094" class="kw kx ir ks b gz ky kz l la lb">category_id_df = y[['classs', 'category_id']].<strong class="ks is">drop_duplicates()</strong>.sort_values('category_id')<br/><strong class="ks is">print(category_id_df)</strong></span><span id="e888" class="kw kx ir ks b gz lc kz l la lb"><strong class="ks is">classs                category_id</strong><br/>0       Description         0<br/>2       Solution            1<br/>5081    Code                2</span></pre><p id="ba3d" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">可以查看下面 data_prepare 的代码片段。</p><pre class="kn ko kp kq gu kr ks kt ku aw kv bi"><span id="290d" class="kw kx ir ks b gz ky kz l la lb">def data_prepare():<br/>    col = ['classs', 'question']<br/>    y=get_data()<br/>    y = y[col]<br/>    y = y[pd.notnull(y['question'])]<br/>    y.columns = ['classs', 'question']<br/>    y['category_id'] = y['classs'].factorize()[0]<br/>    category_id_df = y[['classs', 'category_id']].drop_duplicates().sort_values('category_id')<br/>    category_to_id = dict(category_id_df.values)<br/>    id_to_category = dict(category_id_df[['category_id', 'classs']].values) <strong class="ks is">#This will add the column in our dataframe</strong><br/>    return y</span></pre><p id="5cee" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我使用了多项式朴素贝叶斯算法进行预测，因为我发现它易于实现并且具有很高的准确性。</p><p id="85a8" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">OneVsRest 策略可用于多标签学习，例如，使用分类器来预测多个标签。朴素贝叶斯支持多类，但我们处于多标签场景中，因此，我们将朴素贝叶斯包装在 OneVsRestClassifier 中。</p><blockquote class="lh li lj"><p id="0899" class="jo jp lk jq b jr js jt ju jv jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk kl ik bi translated"><strong class="jq is"> OneVsRest 多标签策略</strong></p><p id="3da9" class="jo jp lk jq b jr js jt ju jv jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk kl ik bi translated">多标签算法接受多个标签上的二进制掩码。每个预测的结果将是一个由 0 和 1 组成的数组，用于标记哪些类标签适用于每个行输入样本。</p></blockquote><p id="230e" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">为了更好地理解下面的代码片段和多项式 Naive_bayes，请尝试<a class="ae km" href="http://scikit-learn.org/stable/modules/generated/sklearn.naive_bayes.MultinomialNB.html" rel="noopener ugc nofollow" target="_blank">这个</a>。</p><p id="7a6e" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">一个简短的概述是:在这里，我将我的数据分为测试数据和训练数据，然后将这些数据输入到模型中。</p><pre class="kn ko kp kq gu kr ks kt ku aw kv bi"><span id="b5b1" class="kw kx ir ks b gz ky kz l la lb">def naive_algo():<br/>    tfidf = TfidfVectorizer(sublinear_tf=True, min_df=5, norm='l2', encoding='latin-1', ngram_range=(1, 2), stop_words='english')<br/>    df=data_prepare()<br/>    features = tfidf.fit_transform(df.question).toarray()<br/>    labels = df.category_id<br/>    features.shape<br/>    X_train, X_test, y_train, y_test = train_test_split(df['question'], df['classs'], random_state = 0)<br/>    count_vect = CountVectorizer()<br/>    X_train_counts = count_vect.fit_transform(X_train)<br/>    tfidf_transformer = TfidfTransformer()<br/>    X_train_tfidf = tfidf_transformer.fit_transform(X_train_counts)<br/>    clf = MultinomialNB().fit(X_train_tfidf, y_train)<br/>    return clf,count_vect</span></pre><p id="1375" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我还尝试了其他算法或模型，如线性 SVC、逻辑回归和随机森林。你可以看看这里的那个<a class="ae km" href="https://github.com/Priya997/SKF-Chatbot/blob/master/Notebooks/implementing%20multiclass.ipynb" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="6809" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">这将给我们最终的预测。</p><pre class="kn ko kp kq gu kr ks kt ku aw kv bi"><span id="18cc" class="kw kx ir ks b gz ky kz l la lb">def predict(question):<br/>    clf,count_vect=naive_algo()<br/>    intent=clf.predict(count_vect.transform([question]))<br/>    intent=str(intent).strip("['']")<br/>    return intent</span></pre><p id="154f" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">最后，我们输入问题，并将其传递给 predict 函数，然后等待变魔术。😝</p><pre class="kn ko kp kq gu kr ks kt ku aw kv bi"><span id="0e5d" class="kw kx ir ks b gz ky kz l la lb">ques=input("Enter your question ")<br/>x=predict(ques)</span></pre><figure class="kn ko kp kq gu le gi gj paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gi gj lo"><img src="../Images/c3ee01909d8540bd7c36e922878e9ab3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZCo-a_2n2xrlqOI-4wi__g.png"/></div></div></figure><p id="2572" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">漂亮，准确，不是吗？</p><p id="3b90" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">您可以查看本<a class="ae km" href="https://github.com/Priya997/SKF-Chatbot/blob/master/Basic_Approach/notebook/Intent_classifier.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>以更好地了解意图分类。</p><blockquote class="lh li lj"><p id="7d4a" class="jo jp lk jq b jr js jt ju jv jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk kl ik bi translated">感谢阅读！如果你喜欢它，请鼓掌，评论(评论或质疑)并分享它😄</p><p id="cc04" class="jo jp lk jq b jr js jt ju jv jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk kl ik bi translated">你可以在<a class="ae km" href="https://github.com/Priya997" rel="noopener ugc nofollow" target="_blank"> Github </a>、<a class="ae km" href="https://www.linkedin.com/in/priyanka997/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>、<a class="ae km" href="https://twitter.com/priyankajain997" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上和我联系😄</p></blockquote><p id="5f9e" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">更多内容，请点击下面的“给我买杯咖啡”图标支持我。</p><figure class="kn ko kp kq gu le gi gj paragraph-image"><a href="https://www.buymeacoffee.com/priyankajain97"><div class="gi gj lt"><img src="../Images/50e94cd09638fbec196afd2091ddbace.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/0*66-SecDwUKbSNhw5.png"/></div></a></figure></div></div>    
</body>
</html>