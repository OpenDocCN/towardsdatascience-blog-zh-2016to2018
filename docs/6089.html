<html>
<head>
<title>Translating SQL to pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将 SQL 翻译成熊猫</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/translating-sql-to-pandas-8f4ae0268899?source=collection_archive---------16-----------------------#2018-11-25">https://towardsdatascience.com/translating-sql-to-pandas-8f4ae0268899?source=collection_archive---------16-----------------------#2018-11-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/efcae4341d65366ea46d809f2b372e65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4nTetLcT8RUPth4qBUajpQ.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/photos/Qy-CBKUg_X8?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Aaron Burden</a> on <a class="ae jd" href="https://unsplash.com/search/photos/autumn-aerial-landscape?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="8362" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">两者都做相似或相同的事情，但方式不同</h2></div><p id="83a9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就像一个有 SQL 背景的人和一个经常使用 SQL 的人一样，熊猫的第一步对我来说有点困难。我总是从 SQL 的角度思考，然后想知道为什么 pandas 如此不直观。但是随着时间的推移，我习惯了一种语法，并发现了这两者之间的联系。所以我决定创建一个翻译成熊猫语言的基本 SQL 命令的备忘单。</p><h2 id="6e7a" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">挑选</h2><p id="8526" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">最简单的 SQL 语句如下所示:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="1600" class="lr ls jg mu b gy my mz l na nb"># Select everything from table1<br/>SELECT *<br/>FROM table1</span></pre><p id="3cbf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在 2010 年，熊猫看起来会像:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="32a6" class="lr ls jg mu b gy my mz l na nb">df.head()</span></pre><p id="35f7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽管在默认情况下，pandas 将只显示前 5 行，但是 SQL 中的内容相当于 LIMIT 5 或 TOP (5)(取决于 DBMS)。同样，只需在终端中输入<code class="fe nc nd ne mu b">df</code>,就会显示数据帧的第一行和最后 15 行。</p><p id="47f5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了选择 SQL 中的特定列，我们将编写下一个查询:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="4771" class="lr ls jg mu b gy my mz l na nb">SELECT column1, column2<br/>FROM table1</span></pre><p id="0574" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在熊猫身上会这样写:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="d3d3" class="lr ls jg mu b gy my mz l na nb">df[['column1', 'column2']]</span></pre><h2 id="aba6" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">在哪里</h2><p id="d338" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">通常，我们希望选择具有特定标准的数据，在 SQL 中，这将使用 WHERE 子句来完成:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="293a" class="lr ls jg mu b gy my mz l na nb">SELECT column1, column2<br/>FROM table1<br/>WHERE column1 = 2</span></pre><p id="96ac" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在熊猫中，相同的查询看起来略有不同:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="b9e2" class="lr ls jg mu b gy my mz l na nb">df[['column1', 'column2']].loc[df['column1'] == 2]</span></pre><p id="9ac5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">WHERE 子句接受逻辑运算符——pandas 也是如此。所以这个 SQL 查询:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="e42a" class="lr ls jg mu b gy my mz l na nb">SELECT *<br/>FROM table1<br/>WHERE column1 &gt; 1 AND column2 &lt; 25</span></pre><p id="ec2a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在熊猫中采用以下形式:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="f8d6" class="lr ls jg mu b gy my mz l na nb">df.loc[(df['column1'] &gt; 1) &amp; (df['column2'] &lt; 25)]</span></pre><p id="73e0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">pandas 中的 or 运算符是“|”，而不是—“~”。注意括号——它是强制的。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="7670" class="lr ls jg mu b gy my mz l na nb">df.loc[(df['column1'] &gt; 1) | ~(df['column2'] &lt; 25)]</span></pre><p id="9437" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">SQL WHERE 子句还接受更复杂的比较，例如:LIKE、IN 和 BETWEEN 熊猫也有能力做到这一点——只是方式不同。让我们创建一个使用所有这些运算符的查询:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="1154" class="lr ls jg mu b gy my mz l na nb">SELECT *<br/>FROM table1<br/>WHERE column1 BETWEEN 1 and 5 AND column2 IN (20,30,40,50) AND column3 LIKE '%arcelona%'</span></pre><p id="35b1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">pandas 中的相同查询(都是一行):</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="971d" class="lr ls jg mu b gy my mz l na nb">df.loc[(df['colum1'].between(1,5)) &amp; (df['column2'].isin([20,30,40,50])) &amp; (df['column3'].str.contains('arcelona'))]</span></pre><p id="8a49" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关于这些方法的更多细节可以在文档中找到:<a class="ae jd" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.isin.html" rel="noopener ugc nofollow" target="_blank">在</a>，<a class="ae jd" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.between.html" rel="noopener ugc nofollow" target="_blank">在</a>，<a class="ae jd" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.str.contains.html" rel="noopener ugc nofollow" target="_blank">之间，如。</a></p><h2 id="08b2" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">加入</h2><p id="7c5d" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在数据科学家的日常工作中，连接表是一种常见的做法，在 SQL 中，我们使用 4 种不同类型的连接来连接表:内连接、左连接、右连接和全连接。该查询如下所示:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="90ca" class="lr ls jg mu b gy my mz l na nb">SELECT t1.column1, t2.column1<br/>FROM table1 t1<br/>INNER JOIN table2 t2 ON t1.column_id = t2.column_id</span></pre><p id="990e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于所有的连接，语法都是相同的，所以我们只需将 INNER 更改为剩下的 3 种类型中的任意一种。在 pandas 中，这个操作最好分两步完成——首先执行 join，然后选择我们需要的数据(尽管它可以在一行中完成):</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="4983" class="lr ls jg mu b gy my mz l na nb">df_joined = df1.join(df2, on='column_id', how='inner')<br/>df_joined.loc[['column1_df1', 'column1_df2']]</span></pre><p id="863a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果没有指定参数<code class="fe nc nd ne mu b">on</code>和<code class="fe nc nd ne mu b">how</code>，pandas 将使用索引作为键列来执行左连接。</p><h2 id="22bb" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">分组依据</h2><p id="86e5" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">分组使我们能够获得关于数据的一些聚合信息:计数、总和、AVG、最小值、最大值等等:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="ac84" class="lr ls jg mu b gy my mz l na nb">SELECT column1, count(*)<br/>FROM table1<br/>GROUP BY column1</span></pre><p id="e2e9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">熊猫也有这种灵活性:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="8d10" class="lr ls jg mu b gy my mz l na nb">df.groupby('column1')['column1'].count()</span></pre><p id="9080" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们必须在方括号中指定列名，以便在结果中只包含该列，否则我们将得到给定数据帧中每列的计数。</p><p id="3215" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们想要得到按列 1 分组的列 2 中所有值的总和(例如，每个商店的总销售额)，并且只显示那些已经达到某个级别的值，比如说超过 1000 个单位，我们将在 SQL 中执行以下操作:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="c4b9" class="lr ls jg mu b gy my mz l na nb">SELECT store, sum(sales)<br/>FROM table1<br/>GROUP BY store<br/>HAVING sum(sales) &gt; 1000</span></pre><p id="6c26" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在 pandas 中，我们没有 HAVING 子句的特权，但我们仍然可以通过两个步骤做到这一点:首先对数据进行分组，然后进行过滤:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="dd30" class="lr ls jg mu b gy my mz l na nb">df_grouped = df.groupby('store')['sales'].sum()<br/>df_grouped.loc[df_grouped &gt; 1000]</span></pre><h2 id="05f4" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">以...排序</h2><p id="45a5" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">为了在 SQL 中对结果进行排序，我们使用 ORDER BY 子句，它总是最后一个从数据库中获取结果。为了选择表中的所有值并按列 1 降序排序，我们编写了下一个查询:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="dd13" class="lr ls jg mu b gy my mz l na nb">SELECT *<br/>FROM table1<br/>ORDER BY column1 DESC</span></pre><p id="765c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在 pandas 中，同样的查询看起来像:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="69f7" class="lr ls jg mu b gy my mz l na nb">df.sort_values(by=['column1'], ascending=False)</span></pre><p id="c81b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个对我来说是最直观最清晰的。虽然，当你练习更多的时候，所有这些语法差异不再困扰你。</p><p id="f6ee" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以用 SQL 和 pandas 编写更复杂的查询，但是这种基本的对齐对我帮助很大，我相信对其他 SQL server 也有帮助。Pandas 是一个非常强大的库，让你以一种非常有效的方式提取、转换、清理你的数据。更多信息可以在我的文章<a class="ae jd" rel="noopener" target="_blank" href="/extracting-and-transforming-data-in-python-63291f63d350">“在 Python 中提取和转换数据”</a>和<a class="ae jd" rel="noopener" target="_blank" href="/cleaning-and-preparing-data-in-python-494a9d51a878">“在 Python 中清理和准备数据”</a>中找到</p><p id="58da" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢您的阅读，祝您有美好的一天！</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="c578" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nm">原载于 2018 年 11 月 25 日</em><a class="ae jd" href="http://sergilehkyi.com/translating-sql-to-pandas/" rel="noopener ugc nofollow" target="_blank"><em class="nm">sergilehkyi.com</em></a><em class="nm">。</em></p></div></div>    
</body>
</html>