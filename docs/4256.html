<html>
<head>
<title>Loading Data from OpenStreetMap with Python and the Overpass API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 和天桥 API 从 OpenStreetMap 加载数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/loading-data-from-openstreetmap-with-python-and-the-overpass-api-513882a27fd0?source=collection_archive---------1-----------------------#2018-08-02">https://towardsdatascience.com/loading-data-from-openstreetmap-with-python-and-the-overpass-api-513882a27fd0?source=collection_archive---------1-----------------------#2018-08-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="a2a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你有没有想过德国大部分 Biergarten 在哪里，或者瑞士隐藏着多少家银行？<a class="ae ko" href="https://www.openstreetmap.org/" rel="noopener ugc nofollow" target="_blank"> OpenStreetMap </a>是一个伟大的开源世界地图，它可以让我们对这些和类似的问题有所了解。隐藏了大量的数据，充满了有用的标签和地理信息，但是我们如何得到这些数据呢？</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/8de6bd10498c5b9f1f21351458bc7720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SKQfgazMUGMonIwl.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Biergarten in Germany, can you guess the big peak?</figcaption></figure><p id="8be9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从 OpenStreetMap (OSM)下载地图数据有多种方式，如他们的<a class="ae ko" href="https://wiki.openstreetmap.org/wiki/Downloading_data" rel="noopener ugc nofollow" target="_blank"> wiki </a>所示。当然，你可以下载整个<a class="ae ko" href="https://wiki.openstreetmap.org/wiki/Planet.osm" rel="noopener ugc nofollow" target="_blank"> Planet.osm </a>文件，但是在本文发表时，你需要释放超过 800 GB 的空间，才能将整个数据集放在你的计算机上等待分析。如果你只需要处理某个区域，你可以使用各种格式的<a class="ae ko" href="https://wiki.openstreetmap.org/wiki/Planet.osm#Country_and_area_extracts" rel="noopener ugc nofollow" target="_blank">提取</a>，比如原生<code class="fe lf lg lh li b"><a class="ae ko" href="https://wiki.openstreetmap.org/wiki/OSM_XML" rel="noopener ugc nofollow" target="_blank">.OSM</a></code>(存储为 XML)、<code class="fe lf lg lh li b"><a class="ae ko" href="https://wiki.openstreetmap.org/wiki/PBF_Format" rel="noopener ugc nofollow" target="_blank">.PBF</a></code>(T2 的压缩版本)、<a class="ae ko" href="https://en.wikipedia.org/wiki/Shapefile" rel="noopener ugc nofollow" target="_blank"> Shapefile </a>或<a class="ae ko" href="https://en.wikipedia.org/wiki/GeoJSON" rel="noopener ugc nofollow" target="_blank"> GeoJSON </a>。也可能有不同的 API，如本地<a class="ae ko" href="https://wiki.openstreetmap.org/wiki/API" rel="noopener ugc nofollow" target="_blank"> OSM API </a>或<a class="ae ko" href="https://wiki.openstreetmap.org/wiki/Nominatim" rel="noopener ugc nofollow" target="_blank">命名 API </a>。在本文中，我们将只关注<a class="ae ko" href="http://overpass-api.de/" rel="noopener ugc nofollow" target="_blank">override API</a>，它允许我们从 OSM 数据集中查询特定的数据。</p><h1 id="6fa3" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">快速浏览一下 OSM 数据模型</h1><p id="ffb1" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">在我们开始之前，我们必须看看 OSM 是如何构成的。在 OSM 数据模型中，我们有三个基本组件，分别是<a class="ae ko" href="https://wiki.openstreetmap.org/wiki/Node" rel="noopener ugc nofollow" target="_blank">节点</a>、<a class="ae ko" href="https://wiki.openstreetmap.org/wiki/Way" rel="noopener ugc nofollow" target="_blank">方式</a>和<a class="ae ko" href="https://wiki.openstreetmap.org/wiki/Relation" rel="noopener ugc nofollow" target="_blank">关系</a>，它们都有一个 id。许多元素都带有<a class="ae ko" href="https://wiki.openstreetmap.org/wiki/Tags" rel="noopener ugc nofollow" target="_blank">标签</a>，这些标签描述了被表示为键值对的特定特性。简单来说，<strong class="js iu">节点</strong>是地图上的点(以纬度和经度表示)，如下图所示，这是一张在伦敦的<a class="ae ko" href="https://www.openstreetmap.org/node/1607078914" rel="noopener ugc nofollow" target="_blank">长凳</a>的图片。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mm"><img src="../Images/03549e34f7724f7557d776e38b4a3a7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nh31X2FTgkKbw5mF.png"/></div></div></figure><p id="5a7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，<strong class="js iu">方式</strong>是节点的有序列表，它可以对应于一条街道或一所房子的轮廓。这里有一个麦克索利在纽约的旧啤酒馆的例子，在 OSM 也可以找到。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mm"><img src="../Images/e092ac0de3addf1fb7ebf5efc2ffeb2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BB5vTU8zlpPlQgFx.png"/></div></div></figure><p id="0fa3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后一个数据元素是一个<strong class="js iu">关系</strong>，它也是一个有序列表，包含节点、路径甚至其他关系。它用于建模对象之间的逻辑或地理关系。例如，这可用于大型结构，如凡尔赛宫<a class="ae ko" href="https://www.openstreetmap.org/relation/1149002" rel="noopener ugc nofollow" target="_blank">中的</a>包含多个多边形来描述建筑。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mn"><img src="../Images/6004c9ec7913c3d6c36c797408d03af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dIVDF-tPZbXMs--G.png"/></div></div></figure><h1 id="501a" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">使用天桥 API</h1><p id="4929" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">现在我们来看看如何从 OSM 加载数据。天桥 API 使用定制的查询语言来定义查询。这需要一些时间来适应，但幸运的是有<a class="ae ko" href="https://github.com/tyrasd" rel="noopener ugc nofollow" target="_blank"> Martin Raifer </a>的<a class="ae ko" href="http://overpass-turbo.eu/" rel="noopener ugc nofollow" target="_blank">over Turbo</a>，它可以方便地直接在浏览器中交互评估我们的查询。假设您想要查询咖啡馆的节点，那么您的查询如下所示</p><pre class="kq kr ks kt gt mo li mp mq aw mr bi"><span id="d78d" class="ms lk it li b gy mt mu l mv mw">node["amenity"="cafe"]({{bbox}}); out;</span></pre><p id="c70b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中查询源代码中的每条语句都以分号结束。该查询首先指定我们想要查询的组件，在本例中是一个节点。我们在查询中应用了一个按标签过滤的方法，寻找所有键值对为<code class="fe lf lg lh li b">"amenity"="cafe"</code>的节点。在<a class="ae ko" href="https://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL#By_tag_.28has-kv.29" rel="noopener ugc nofollow" target="_blank">文档</a>中可以找到不同的标签过滤选项。有各种各样的标签可供选择，一个常见的关键字是<a class="ae ko" href="https://wiki.openstreetmap.org/wiki/Key:amenity" rel="noopener ugc nofollow" target="_blank"> amenity </a>，它涵盖了各种社区设施，如咖啡馆、餐厅或只是一张长椅。为了对 OSM 其他可能的标签有一个大概的了解，看看<a class="ae ko" href="https://wiki.openstreetmap.org/wiki/Map_Features" rel="noopener ugc nofollow" target="_blank"> OSM 地图功能</a>或<a class="ae ko" href="https://taginfo.openstreetmap.org/" rel="noopener ugc nofollow" target="_blank"> taginfo </a>。</p><p id="8828" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个过滤器是边界框过滤器，其中<code class="fe lf lg lh li b">{{bbox}}</code>对应于我们要在其中搜索的边界框，并且只在天桥 Turbo 中工作。否则，您可以通过经纬度中的<code class="fe lf lg lh li b">(south, west, north, east)</code>指定一个边界框，如下所示</p><pre class="kq kr ks kt gt mo li mp mq aw mr bi"><span id="964a" class="ms lk it li b gy mt mu l mv mw">node["amenity"="pub"]<br/>  (53.2987342,-6.3870259,53.4105416,-6.1148829); <br/>out;</span></pre><p id="262b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以试试天桥涡轮。正如我们之前在 OSM 数据模型中看到的，也有可能拥有相同属性的方法和关系。我们也可以通过使用一个<a class="ae ko" href="https://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL#Union" rel="noopener ugc nofollow" target="_blank"> union </a> block 语句来获得这些结果，该语句收集一对括号内的语句序列的所有输出，如</p><pre class="kq kr ks kt gt mo li mp mq aw mr bi"><span id="df46" class="ms lk it li b gy mt mu l mv mw">( node["amenity"="cafe"]({{bbox}});<br/>  way["amenity"="cafe"]({{bbox}});<br/>  relation["amenity"="cafe"]({{bbox}});<br/>);<br/>out;</span></pre><p id="6da5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一种过滤查询的方法是通过元素 id 过滤<a class="ae ko" href="https://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL#By_element_id" rel="noopener ugc nofollow" target="_blank">。下面是查询<code class="fe lf lg lh li b">node(1); out;</code>的例子，它给出了经度接近于零的世界</a>的<a class="ae ko" href="https://www.openstreetmap.org/node/1" rel="noopener ugc nofollow" target="_blank">本初子午线。</a></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mm"><img src="../Images/6f7f2297768116a1e2bbfd719847f63e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vFZ0sxSF_Kx2fxbu.png"/></div></div></figure><p id="e2e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一种过滤查询的方法是按地区指定<a class="ae ko" href="https://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL#By_area_.28area.29" rel="noopener ugc nofollow" target="_blank">，可以像指定<code class="fe lf lg lh li b">area["ISO3166-1"="GB"][admin_level=2];</code>一样指定，这样我们就可以得到英国的地区。我们现在可以使用它作为查询的过滤器，方法是将<code class="fe lf lg lh li b">(area)</code>添加到我们的语句中，如</a></p><pre class="kq kr ks kt gt mo li mp mq aw mr bi"><span id="1fcd" class="ms lk it li b gy mt mu l mv mw">area["ISO3166-1"="GB"][admin_level=2];<br/>node["place"="city"](area);<br/>out;</span></pre><p id="a258" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该查询返回英国的所有城市。也可以使用关系或方式作为区域。在这种情况下，区域 id 需要通过将<code class="fe lf lg lh li b">2400000000</code>添加到其 OSM id 中，或者在有关系的情况下，通过添加<code class="fe lf lg lh li b">3600000000</code>从现有的 OSM 方式中导出。请注意，并不是所有的路/关系都有一个区域对应物(即那些标有<code class="fe lf lg lh li b">area=no</code>的路/关系，以及大多数没有定义<code class="fe lf lg lh li b">name=*</code>的多多边形将不属于区域)。如果我们将<a class="ae ko" href="https://www.openstreetmap.org/relation/62149" rel="noopener ugc nofollow" target="_blank">英国</a>的关系应用到前面的例子中，我们就会得到</p><pre class="kq kr ks kt gt mo li mp mq aw mr bi"><span id="0c73" class="ms lk it li b gy mt mu l mv mw">area(3600062149);<br/>node["place"="city"](area);<br/>out;</span></pre><p id="2070" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后我们可以指定查询数据的输出，这由<a class="ae ko" href="https://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL#Print_.28out.29" rel="noopener ugc nofollow" target="_blank"> out 动作</a>配置。到目前为止，我们将输出指定为<code class="fe lf lg lh li b">out;</code>，但是还有各种可以追加的附加值。第一组值可以控制输出信息的详细程度或详细程度，如<a class="ae ko" href="https://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL#Print_.28out.29" rel="noopener ugc nofollow" target="_blank">文档</a>中描述的<code class="fe lf lg lh li b">ids</code>、<code class="fe lf lg lh li b">skel</code>、<code class="fe lf lg lh li b">body</code>(默认值)、<code class="fe lf lg lh li b">tags</code>、<code class="fe lf lg lh li b">meta</code>和<code class="fe lf lg lh li b">count</code>。</p><p id="1648" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，我们可以添加地理编码信息的修改。<code class="fe lf lg lh li b">geom</code>为每个对象添加完整的几何图形。当返回没有关联坐标的关系或路径，并且您想要获得它们的节点和路径的坐标时，这很重要。例如，查询<code class="fe lf lg lh li b">rel["ISO3166-1"="GB"][admin_level=2]; out geom;</code>不会返回任何坐标。值<code class="fe lf lg lh li b">bb</code>仅将边界框添加到每个路径和关系，而<code class="fe lf lg lh li b">center</code>仅添加同一边界框的中心(不是几何图形的中心)。</p><p id="2588" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">排序顺序可通过<code class="fe lf lg lh li b">asc</code>和<code class="fe lf lg lh li b">qt</code>进行配置，分别按对象 id 或四块索引排序，后者明显更快。最后，通过添加一个整数值，您可以设置要返回的最大元素数。</p><p id="4d10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结合我们目前所学的知识，我们最终可以查询德国所有比尔加滕的位置</p><pre class="kq kr ks kt gt mo li mp mq aw mr bi"><span id="1a34" class="ms lk it li b gy mt mu l mv mw">area["ISO3166-1"="DE"][admin_level=2];</span><span id="e84c" class="ms lk it li b gy mx mu l mv mw">( node["amenity"="biergarten"](area);<br/>  way["amenity"="biergarten"](area);<br/>  rel["amenity"="biergarten"](area);<br/>);<br/>out center;</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mn"><img src="../Images/0eb16d54da40d3f95addaa5687aa0bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HWizfMQlWPKQV1Zw.png"/></div></div></figure><h1 id="a115" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">Python 和天桥 API</h1><p id="aa97" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">现在，我们应该已经很好地掌握了如何使用 transition API 查询 OSM 数据，但是我们现在如何使用这些数据呢？下载数据的一种方法是使用命令行工具<a class="ae ko" href="https://curl.haxx.se/" rel="noopener ugc nofollow" target="_blank"> curl </a>或<a class="ae ko" href="https://www.gnu.org/software/wget/" rel="noopener ugc nofollow" target="_blank"> wget </a>。为了做到这一点，我们需要访问其中一个<a class="ae ko" href="http://overpass-api.de/" rel="noopener ugc nofollow" target="_blank">over API 端点</a>，在这里我们将按照格式<code class="fe lf lg lh li b">http://overpass-api.de/api/interpreter?data=query</code>查看。当使用 curl 时，我们可以通过运行以下命令下载查询的<a class="ae ko" href="https://wiki.openstreetmap.org/wiki/OSM_XML" rel="noopener ugc nofollow" target="_blank"> OSM XML </a></p><pre class="kq kr ks kt gt mo li mp mq aw mr bi"><span id="6fdf" class="ms lk it li b gy mt mu l mv mw">curl --globoff -o output.xml <a class="ae ko" href="http://overpass-api.de/api/interpreter?data=node(1);out;" rel="noopener ugc nofollow" target="_blank">http://overpass-api.de/api/interpreter?data=node(1);out;</a></span></pre><p id="2701" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中先前精心制作的查询出现在<code class="fe lf lg lh li b">data=</code>之后，并且该查询需要被<a class="ae ko" href="https://en.wikipedia.org/wiki/Percent-encoding" rel="noopener ugc nofollow" target="_blank"> urlencoded </a>。为了使用方括号和花括号而不被 curl 解释，<code class="fe lf lg lh li b">--globoff</code>很重要。该查询返回以下 XML 结果</p><pre class="kq kr ks kt gt mo li mp mq aw mr bi"><span id="3dbe" class="ms lk it li b gy mt mu l mv mw">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;osm version="0.6" generator="Overpass API 0.7.54.13 ff15392f"&gt;<br/>&lt;note&gt;The data included in this document is from www.openstreetmap.org. <br/>      The data is made available under ODbL.&lt;/note&gt;<br/>&lt;meta osm_base="2018-02-24T21:09:02Z"/&gt;</span><span id="e357" class="ms lk it li b gy mx mu l mv mw">  &lt;node id="1" lat="51.4779481" lon="-0.0014863"&gt;<br/>    &lt;tag k="historic" v="memorial"/&gt;<br/>    &lt;tag k="memorial" v="stone"/&gt;<br/>    &lt;tag k="name" v="Prime Meridian of the World"/&gt;<br/>  &lt;/node&gt;</span><span id="a8da" class="ms lk it li b gy mx mu l mv mw">&lt;/osm&gt;</span></pre><p id="6c46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae ko" href="http://overpass-api.de/output_formats.html" rel="noopener ugc nofollow" target="_blank">文档</a>中有多种输出格式可供选择。为了下载 JSON 格式的查询结果，我们需要在查询的开头添加<code class="fe lf lg lh li b">[out:json];</code>,如</p><pre class="kq kr ks kt gt mo li mp mq aw mr bi"><span id="e279" class="ms lk it li b gy mt mu l mv mw">curl --globoff - o output.json <a class="ae ko" href="http://overpass-api.de/api/interpreter?data=[out:json];node(1);out;" rel="noopener ugc nofollow" target="_blank">http://overpass-api.de/api/interpreter?data=[out:json];node(1);out;</a></span></pre><p id="446d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">给我们之前的 JSON 格式的 XML 结果。您也可以通过访问<a class="ae ko" href="http://overpass-api.de/api/interpreter?data=[out:json];node(1);out;" rel="noopener ugc nofollow" target="_blank">http://overpass-api.de/api/interpreter?在浏览器中测试查询 data =[out:JSON]；节点(1)；出；</a>。</p><p id="6134" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是我已经承诺使用 Python 来获得结果查询。我们现在可以用 Python 运行我们众所周知的 Biergarten 查询，方法是使用<a class="ae ko" href="http://docs.python-requests.org/en/master/" rel="noopener ugc nofollow" target="_blank"> requests </a>包来访问天桥 API 和<a class="ae ko" href="https://docs.python.org/3/library/json.html" rel="noopener ugc nofollow" target="_blank"> json </a>包，以从查询中读取结果 json。</p><pre class="kq kr ks kt gt mo li mp mq aw mr bi"><span id="58e1" class="ms lk it li b gy mt mu l mv mw">import requests<br/>import json</span><span id="de02" class="ms lk it li b gy mx mu l mv mw">overpass_url = "http://overpass-api.de/api/interpreter"<br/>overpass_query = """<br/>[out:json];<br/>area["ISO3166-1"="DE"][admin_level=2];<br/>(node["amenity"="biergarten"](area);<br/> way["amenity"="biergarten"](area);<br/> rel["amenity"="biergarten"](area);<br/>);<br/>out center;<br/>"""<br/>response = requests.get(overpass_url, <br/>                        params={'data': overpass_query})<br/>data = response.json()</span></pre><p id="0c0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，我们不必为我们的查询使用 urlencoding，因为这由<code class="fe lf lg lh li b">requests.get</code>负责，现在我们可以存储数据或直接进一步使用数据。我们关心的数据存储在<code class="fe lf lg lh li b">elements</code>键下。那里的每个元素都包含一个<code class="fe lf lg lh li b">type</code>键和一个<code class="fe lf lg lh li b">id</code>键，前者指定它是节点、路还是关系。因为我们在查询中使用了<code class="fe lf lg lh li b">out center;</code>语句，所以我们为每条道路和关系获取了一个存储在<code class="fe lf lg lh li b">center</code>键下的中心坐标。在节点元素的情况下，坐标就在<code class="fe lf lg lh li b">lat, lon</code>键下面。</p><pre class="kq kr ks kt gt mo li mp mq aw mr bi"><span id="f7ed" class="ms lk it li b gy mt mu l mv mw">import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="59c0" class="ms lk it li b gy mx mu l mv mw"># Collect coords into list<br/>coords = []<br/>for element in data['elements']:<br/>  if element['type'] == 'node':<br/>    lon = element['lon']<br/>    lat = element['lat']<br/>    coords.append((lon, lat))<br/>  elif 'center' in element:<br/>    lon = element['center']['lon']<br/>    lat = element['center']['lat']<br/>    coords.append((lon, lat))</span><span id="8529" class="ms lk it li b gy mx mu l mv mw"># Convert coordinates into numpy array<br/>X = np.array(coords)</span><span id="335a" class="ms lk it li b gy mx mu l mv mw">plt.plot(X[:, 0], X[:, 1], 'o')<br/>plt.title('Biergarten in Germany')<br/>plt.xlabel('Longitude')<br/>plt.ylabel('Latitude')<br/>plt.axis('equal')<br/>plt.show()</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mm"><img src="../Images/694d2838474658a8c8a6a12f09f239b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vnFEMHRQ-l5KOOhW.png"/></div></div></figure><p id="8d93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一种用 Python 访问 over float API 的方法是使用<a class="ae ko" href="https://github.com/DinoTools/python-overpy" rel="noopener ugc nofollow" target="_blank"> overpy </a>包作为包装器。在这里你可以看到我们如何用 overpy 包来翻译前面的例子</p><pre class="kq kr ks kt gt mo li mp mq aw mr bi"><span id="23f3" class="ms lk it li b gy mt mu l mv mw">import overpy</span><span id="7df5" class="ms lk it li b gy mx mu l mv mw">api = overpy.Overpass()<br/>r = api.query("""<br/>area["ISO3166-1"="DE"][admin_level=2];<br/>(node["amenity"="biergarten"](area);<br/> way["amenity"="biergarten"](area);<br/> rel["amenity"="biergarten"](area);<br/>);<br/>out center;<br/>""")</span><span id="b45c" class="ms lk it li b gy mx mu l mv mw">coords  = []<br/>coords += [(float(node.lon), float(node.lat)) <br/>           for node in r.nodes]<br/>coords += [(float(way.center_lon), float(way.center_lat)) <br/>           for way in r.ways]<br/>coords += [(float(rel.center_lon), float(rel.center_lat)) <br/>           for rel in r.relations]</span></pre><p id="5cb2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">overpy 的一个优点是它从响应中检测内容类型(即 XML、JSON)。如需更多信息，请查看他们的<a class="ae ko" href="https://python-overpy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">文档</a>。你可以将这些收集到的数据用于其他目的，或者像在<a class="ae ko" href="https://github.com/njanakiev/openstreetmap-heatmap" rel="noopener ugc nofollow" target="_blank"> openstreetmap-heatmap </a>项目中一样，用 Blender 将其可视化。这就把我们带回了标题图片，正如你可能已经猜到的，它显示了德国比尔加藤的分布。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi my"><img src="../Images/717e2e7b685b9dabb9f727d17b791d66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MMvTKErcME_2tRNN.gif"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Image from <a class="ae ko" href="https://github.com/njanakiev/openstreetmap-heatmap" rel="noopener ugc nofollow" target="_blank">openstreetmap-heatmap</a></figcaption></figure><h1 id="bc73" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">结论</h1><p id="64b8" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">从获取特定区域内的建筑的需求开始，我发现在 OSM 有多少不同的东西可以发现，我迷失在地理空间兔子洞。看到 OSM 还有多少有趣的数据有待探索是令人兴奋的，甚至包括在 OSM 找到建筑物的 3D 数据的可能性。由于 OSM 是基于贡献的，你也可以探索 OSM 是如何随着时间的推移而增长的，以及有多少用户加入了本文<a class="ae ko" href="http://oslandia.com/en/2017/07/03/openstreetmap-data-analysis-how-to-parse-the-data-with-python/" rel="noopener ugc nofollow" target="_blank">中的</a>文章，该文章使用<a class="ae ko" href="http://osmcode.org/pyosmium/" rel="noopener ugc nofollow" target="_blank"> pyosmium </a>检索某些地区的 OSM 用户统计数据。我希望我启发了你，让你带着新装备的工具去 OSM 深处发现新奇和有趣的发现。</p><p id="d03f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mz">感谢阅读！如果你喜欢这篇文章，请继续展示你的爱，并关注我更多的文章。还有，在</em> <a class="ae ko" href="https://www.linkedin.com/in/nikolai-janakiev/" rel="noopener ugc nofollow" target="_blank"> <em class="mz"> LinkedIn </em> </a> <em class="mz">或者</em><a class="ae ko" href="https://twitter.com/njanakiev/" rel="noopener ugc nofollow" target="_blank"><em class="mz">Twitter</em></a><em class="mz">上随时联系我。</em></p><p id="69f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mz">本文原载于</em><a class="ae ko" href="https://janakiev.com/" rel="noopener ugc nofollow" target="_blank"><em class="mz">janakiev.com</em></a><em class="mz">。</em></p></div></div>    
</body>
</html>