<html>
<head>
<title>Lazy load data in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">延迟加载 R 中的数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/lazy-loading-data-in-r-2b100acb63fc?source=collection_archive---------5-----------------------#2018-11-01">https://towardsdatascience.com/lazy-loading-data-in-r-2b100acb63fc?source=collection_archive---------5-----------------------#2018-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e0b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近，我发现自己需要加载和处理大型数据文件以显示在闪亮的仪表板上，但是一次性加载和处理整个文件需要很长时间。这将迫使用户在显示结果之前盯着空白屏幕看一段时间。我想出了一个粗略的解决方案来“延迟加载”数据，并根据需要处理它们。当我说延迟加载时，我的意思是只加载/处理用户当前需要的部分并缓存它们。想象一下 YouTube，一边看一边加载部分视频。</p><p id="da52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我觉得有两个关键的 R 概念值得解释，因为它们真正塑造了延迟加载技术:环境和方法调度。</p><h1 id="d4bf" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">环境和方法分派</h1><p id="6555" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在高层次上，我创建了一个定制的环境对象，并在需要时基于索引重写了<code class="fe lo lp lq lr b">[</code>方法调度进程。</p><h2 id="9805" class="ls km iq bd kn lt lu dn kr lv lw dp kv jy lx ly kz kc lz ma ld kg mb mc lh md bi translated">环境</h2><p id="2c8c" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">r 不支持引用调用。在像<code class="fe lo lp lq lr b">C++</code>这样的语言中，引用(指针)可以作为参数传递给函数。不过有一个解决方法，使用<a class="ae me" href="http://adv-r.had.co.nz/Environments.html" rel="noopener ugc nofollow" target="_blank">环境</a>。环境是 R 的秘密“引用调用”。在这里，我使用它们来缓存我的使用环境的结果。当一个环境被传递给一个函数时，它被自动地通过引用传递，因为环境是<strong class="jp ir">而不是</strong>复制到 R 中的(更多<a class="ae me" href="https://www.stat.berkeley.edu/~paciorek/computingTips/Pointers_passing_reference_.html" rel="noopener ugc nofollow" target="_blank">在这里</a>)。让我们看一个例子</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">A <code class="fe lo lp lq lr b">human</code> can have only one age. And celebrating birthdays globally increments age by one, no matter where you are.</figcaption></figure><h2 id="d608" class="ls km iq bd kn lt lu dn kr lv lw dp kv jy lx ly kz kc lz ma ld kg mb mc lh md bi translated">数组和方法分派</h2><p id="5926" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">下一块是<a class="ae me" href="http://adv-r.had.co.nz/S3.html" rel="noopener ugc nofollow" target="_blank">法派</a>，具体是<code class="fe lo lp lq lr b">[</code>上的法派。这非常类似于 Java 中的运算符重载。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">A demonstration of method dispatch</figcaption></figure><p id="51a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第 11 行的输出并不是我们所期望的数组类对象的输出。定义一个<code class="fe lo lp lq lr b">[</code>方法调度是将对象伪装成数组的简单方法。另请注意第 32 行，其中方法分派是用函数中的一些操作定义的，以支持返回结果之前的处理。</p><p id="59ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么要关心定义<code class="fe lo lp lq lr b">[</code>方法调度呢？老实说，没关系。有了这种语法糖，代码读起来就简单多了。我喜欢让我的代码尽可能的干净和简单。</p><h1 id="6287" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">惰性装载</h1><p id="419a" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">正如我之前提到的，我将延迟加载称为一种仅在需要时加载或处理数据的技术。想象一下 YouTube 或网飞，视频分部分加载，而且只加载用户想看的部分。如果任何一方要求用户等待完整视频下载后再播放，那将是一场灾难。从磁盘加载和处理大文件也是类似的概念。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Very generic lazy loader</figcaption></figure><p id="fdec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我创建了一个接受<code class="fe lo lp lq lr b">inputs</code>和<code class="fe lo lp lq lr b">FUN</code>的构造函数。<code class="fe lo lp lq lr b">inputs</code>可能是一个数组，一个列表，或者另一个对象，基于你的用例。这里我做了一个数组。而<code class="fe lo lp lq lr b">FUN</code>是一个函数，你可以用它来处理<code class="fe lo lp lq lr b">inputs</code>中的每个元素。为了启用缓存，我还定义了一个<code class="fe lo lp lq lr b">returns</code>数组。同样，这可以是任何东西，而不仅仅是一个数组。在第 8 行定义自定义类对于以后创建方法分派很重要。例如，如果我想延迟处理(平方一个数)一个数的数组，这将是理想的。</p><pre class="mf mg mh mi gt mq lr mr ms aw mt bi"><span id="8e8e" class="ls km iq lr b gy mu mv l mw mx">inputs &lt;- 1:10<br/>FUN &lt;- function(x) x * x</span></pre><p id="42ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们期望的<code class="fe lo lp lq lr b">returns</code>是</p><pre class="mf mg mh mi gt mq lr mr ms aw mt bi"><span id="7f26" class="ls km iq lr b gy mu mv l mw mx">returns &lt;- c(1, 4, 9, 16, 25, 36, 49, 64, 81, 100)</span></pre><p id="5037" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于 lazy process，当我从新对象<code class="fe lo lp lq lr b">lazy.object[idx]</code>请求任何项目时，我希望它会返回该索引的结果。为了帮助索引，我定义了<code class="fe lo lp lq lr b">[</code>方法分派。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="16d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你会注意到我所做的就是调用<code class="fe lo lp lq lr b">FUN</code>并传递我想要处理的项目。如果您正在处理数组，那么您可以跳过 sapply，但是对于其他类型，这是合适的。对于列表，我会使用<code class="fe lo lp lq lr b">lapply</code>。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="66b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，为了缓存结果以备将来使用，我们对方法 dispatch 做了一点小小的修改。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Notice no processing message for code in line 25</figcaption></figure><p id="50e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第 3–7 行检查<code class="fe lo lp lq lr b">returns[i]</code>是否为 NA，只有当它为 NA 时才进行计算。为了演示，我修改了函数，以便在调用它时打印消息。</p><p id="05ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了更清楚地了解情况，我还为对象定义了一个<code class="fe lo lp lq lr b">print</code>方法分派。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Notice line 24, with populated values in positions 3:8</figcaption></figure><p id="5d4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，当创建对象时，<code class="fe lo lp lq lr b">ll</code>有一个空的<code class="fe lo lp lq lr b">returns</code>数组。当<code class="fe lo lp lq lr b">ll[3:8]</code>被计算时，结果被缓存。同样，虽然我使用了数组和一个简单的函数，但是可以很容易地修改它来支持复杂的对象和函数。</p><h1 id="a24c" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">趣味中的多重争论</h1><p id="a716" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">有时你需要做的不仅仅是计算平方，也许是两个数的和。因此，您的函数需要两个(或者可能更多)输入。有两种方法可以实现这一点:</p><ol class=""><li id="b661" class="my mz iq jp b jq jr ju jv jy na kc nb kg nc kk nd ne nf ng bi translated">为环境中的第二个输入定义一个新的<code class="fe lo lp lq lr b">inputs</code>,并将两个值传递给该函数</li><li id="6160" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated">使用带有多个参数的 R 的<code class="fe lo lp lq lr b">[</code></li></ol><p id="f080" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将在下面介绍这两种方法，并说明我认为每种方法的最佳用途。</p><h2 id="6dd7" class="ls km iq bd kn lt lu dn kr lv lw dp kv jy lx ly kz kc lz ma ld kg mb mc lh md bi translated">定义另一个<code class="fe lo lp lq lr b">input</code></h2><p id="3de8" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我发现这种方法在两个输入相差很大或者依赖于索引时最有用。您将定义输入并更新方法分派。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="c016" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于更多的输入，这变得有些费力，但仍然比让用户等待要高一步。</p><h2 id="9570" class="ls km iq bd kn lt lu dn kr lv lw dp kv jy lx ly kz kc lz ma ld kg mb mc lh md bi translated">传递带切片索引的参数</h2><p id="4ebf" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">方法分派就像 r 中的任何其他函数一样，因此，像任何其他函数一样，可以向它传递多个参数。这个方法实际上要求你把<code class="fe lo lp lq lr b">...</code>放在两个地方，这样你就完成了！当我对一些指数有相同的输入集时，我会使用这种方法。比如每个数字加 5。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Notice line 26</figcaption></figure><p id="b5db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">两种方法都很棒，但我个人更喜欢第二种。只是工作量更少:P</p><h1 id="cb02" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">缓存失效</h1><p id="a88b" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我想说这是一个高级主题，大多数普通读者可以跳过这一部分。如果输入有可能在运行时改变，那么我们需要一种方式通知加载器缓存的结果不再有效，需要重新计算。您可以创建一个新的对象，并重新计算或复制有效的结果，但有一个更简单的方法。为每个索引使用一个标志。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Cache invalidation</figcaption></figure><p id="e68f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过向每个索引添加一个有效的标志，加载程序只需检查是否设置了标志，并在需要时重新计算。我将<code class="fe lo lp lq lr b">[&lt;-</code>方法分派定义为语法糖。但要点是通过将有效标志设置为内部的<code class="fe lo lp lq lr b">FALSE</code>来使索引无效。之后每个命令的输出有助于更好地理解该过程。</p><h1 id="c1eb" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">最后的话</h1><p id="f836" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">当输入很大并且需要某种耗时的预处理时，这种技术非常有用。可以把这想象成一种有助于简化某些流程的设计模式。如有任何问题，请随时与我联系！</p><p id="e9fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">附:这是我的第一篇博客。请务必分享和评论！:D</p></div></div>    
</body>
</html>