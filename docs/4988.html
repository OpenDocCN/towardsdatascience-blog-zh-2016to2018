<html>
<head>
<title>Data pipelines, Luigi, Airflow: everything you need to know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据管道、Luigi、气流:你需要知道的一切</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-pipelines-luigi-airflow-everything-you-need-to-know-18dc741449b7?source=collection_archive---------1-----------------------#2018-09-20">https://towardsdatascience.com/data-pipelines-luigi-airflow-everything-you-need-to-know-18dc741449b7?source=collection_archive---------1-----------------------#2018-09-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1394947910852add79e1e67d7f664a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RuiyLX5EU0eY41GEQW7EuA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/photos/m3TYLFI_mDo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Gerrie van der Walt</a> on <a class="ae kc" href="https://unsplash.com/search/photos/pipeline?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="76ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章是基于我最近给同事们做的关于气流的演讲。</p><p id="c074" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">特别是，演讲的重点是:什么是气流，你可以用它做什么，它与 Luigi 有什么不同。</p><h1 id="7881" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">你为什么需要 WMS</h1><p id="e8b5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在公司中，移动和转换数据是很常见的事情。</p><p id="3121" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，您在 S3 的某个地方存储了大量日志，您希望定期获取这些数据，提取和聚合有意义的信息，然后将它们存储在分析数据库中(例如，Redshift)。</p><p id="71cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，这种任务首先是手动执行的，然后，随着规模的扩大，这个过程是自动化的，例如，用 cron 触发。最终，您会发现原来的 cron 已经无法保证稳定和健壮的性能。这已经远远不够了。</p><p id="3e31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这时候你就需要一个工作流管理系统(WMS)。</p><h1 id="0039" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">气流</h1><p id="1260" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Airflow 是 Airbnb 在 2014 年开发的，后来开源了。2016 年，它加入了阿帕奇软件基金会的孵化计划。</p><p id="a78d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当被问及“是什么让 WMS 的气流与众不同？”，Maxime Beauchemin(创造者或气流)回答:</p><blockquote class="me mf mg"><p id="b3a5" class="kd ke mh kf b kg kh ki kj kk kl km kn mi kp kq kr mj kt ku kv mk kx ky kz la ij bi translated">一个关键的区别是气流管道被定义为代码，任务是动态实例化的。</p></blockquote><p id="2550" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望在这篇文章结束时，你能够理解，更重要的是，同意(或不同意)这种说法。</p><p id="59be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们先来定义一下主要概念。</p><h1 id="a143" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">工作流作为 Dag</h1><p id="a6bd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在 Airflow 中，工作流被定义为具有方向依赖性的任务的集合，基本上是有向无环图(DAG)。图中的每个节点是一个任务，边定义了任务之间的依赖关系。</p><p id="849b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任务属于两类:</p><ol class=""><li id="99e7" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated"><strong class="kf ir">操作员</strong>:他们执行一些操作</li><li id="bce6" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated"><strong class="kf ir">传感器</strong>:它们检查进程或数据结构的状态</li></ol><p id="fb28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现实生活中的工作流可以从每个工作流只有一个任务(你不必总是很花哨)到非常复杂的 Dag，几乎不可能可视化。</p><h1 id="f379" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">主要组件</h1><p id="2ee0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">气流的主要组成部分有:</p><ul class=""><li id="153e" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mz mr ms mt bi translated">一个<strong class="kf ir">元数据库</strong></li><li id="e028" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mz mr ms mt bi translated">一个<strong class="kf ir">调度器</strong></li><li id="6d86" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mz mr ms mt bi translated">一个<strong class="kf ir">执行者</strong></li></ul><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/cb7ff0fb4b138e3b275b53de8187e778.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-wDxsSr5_2NyOHxysroYyA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Airflow architecture</figcaption></figure><p id="eb0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">元数据数据库存储任务和工作流的状态。调度器使用 DAGs 定义以及元数据数据库中的任务状态，并决定需要执行什么。<br/>执行器是一个消息队列进程(通常是<a class="ae kc" href="http://www.celeryproject.org/](http://www.celeryproject.org/" rel="noopener ugc nofollow" target="_blank">芹菜</a>)，它决定哪个工人将执行每个任务。</p><p id="d8ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用 Celery executor，可以管理任务的分布式执行。另一种方法是在同一台机器上运行调度器和执行器。在这种情况下，将使用多个进程来管理并行性。</p><p id="c9c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">气流也提供了一个非常强大的用户界面。用户能够监控 Dag 和任务的执行，并通过 web UI 与它们直接交互。</p><p id="0503" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">气流遵循<em class="mh">“设置好就忘了”</em>的方法是很常见的，但这意味着什么呢？<br/>表示一旦设置了 DAG，调度器将自动调度它按照指定的调度间隔运行。</p><h1 id="9876" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">路易吉</h1><p id="0dcd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">理解气流最简单的方法大概就是把它比作 Luigi。</p><p id="48d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Luigi 是一个用于构建复杂管道的 python 包，由 Spotify 开发。</p><p id="2dd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 Luigi 中，与在 Airflow 中一样，您可以将工作流指定为任务以及它们之间的依赖关系。</p><p id="28ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Luigi 的两个积木是<strong class="kf ir">任务</strong>和<strong class="kf ir">目标</strong>。目标通常是任务输出的文件，任务执行计算并消耗其他任务生成的目标。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/25cdca71280b8993294df69aaed60a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vVV3tw3ZS1XQLZCNAfrMeQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Luigi pipeline structure</figcaption></figure><p id="f703" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以把它想象成一条真正的管道。一个任务完成它的工作并生成一个目标。结果，第二个任务接受目标文件作为输入，执行一些操作并输出第二个目标文件，依此类推。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/8ab314cca2ff9f8222a757c95460a1aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6H39Hc_zPIRxNjZbFmNbSA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Coffee break (Photo by <a class="ae kc" href="https://unsplash.com/photos/qbrmH8y1jHY?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">rawpixel</a> on <a class="ae kc" href="https://unsplash.com/search/photos/break?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a>)</figcaption></figure><h1 id="ebdf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">简单的工作流程</h1><p id="f948" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们看看如何实现由两个任务组成的简单管道。<br/>第一个任务用一个单词生成一个. txt 文件(在本例中是“pipeline”)，第二个任务读取该文件并添加“My”修饰该行。新的一行写在一个新的文件上。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Luigi simple pipeline</figcaption></figure><p id="9adb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个任务被指定为从<code class="fe nj nk nl nm b">luigi.Task</code>派生的类，方法<code class="fe nj nk nl nm b">output()</code>指定输出，因此目标，<code class="fe nj nk nl nm b">run()</code>指定任务执行的实际计算。<br/>方法<code class="fe nj nk nl nm b">requires()</code>指定了任务之间的依赖关系。</p><p id="1f75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从代码中，很容易看出一个任务的输入是另一个任务的输出，依此类推。</p><p id="9886" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看如何在气流中做同样的事情。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Airflow simple DAG</figcaption></figure><p id="cc9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们定义并初始化 DAG，然后向 DAG 添加两个操作符。<br/>第一个是<code class="fe nj nk nl nm b">BashOperator</code>，它基本上可以运行所有的 bash 命令或脚本，第二个是执行 python 代码的<code class="fe nj nk nl nm b">PythonOperator</code>(为了演示，我在这里使用了两个不同的操作符)。</p><p id="3388" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见，没有输入和输出的概念。两个运营商之间没有信息共享。有很多方法可以在操作符之间共享信息(你基本上共享一个字符串)，但是作为一个通用的规则:如果两个操作符需要共享信息，那么它们可能应该合并成一个。</p><h1 id="74a9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">更复杂的工作流程</h1><p id="b0d0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在让我们考虑一下我们想要同时处理更多文件的情况。</p><p id="e661" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 Luigi，我们可以用多种方式做到这一点，但没有一种是真正简单的。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Luigi a pipeline managing multiple files</figcaption></figure><p id="c1c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，我们有两个任务，每个任务处理所有的文件。从属任务(<code class="fe nj nk nl nm b">t2</code>)必须等到<code class="fe nj nk nl nm b">t1</code>处理完所有文件。<br/>我们使用一个空文件作为目标来标记每个任务完成的时间。</p><p id="0a7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以为循环增加一些并行化。<br/>这种解决方案的问题是<code class="fe nj nk nl nm b">t1</code>开始产生输出后，<code class="fe nj nk nl nm b">t2</code>就可以开始逐渐处理文件，实际上<code class="fe nj nk nl nm b">t2</code>不必等到<code class="fe nj nk nl nm b">t1</code>创建完所有文件。</p><p id="7fb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Luigi 中的一个常见模式是创建一个包装器任务并使用多个 workers。</p><p id="6a40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是代码。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Luigi a pipeline using multiple workers</figcaption></figure><p id="e0d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用多个工作线程运行任务，我们可以在运行任务时指定<code class="fe nj nk nl nm b">— workers number_of_workers</code>。</p><p id="652f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现实生活中常见的一种方法是委托并行化。基本上，你使用第一种方法，例如在<code class="fe nj nk nl nm b">run()</code>函数中使用 Spark，来进行实际的处理。</p><h1 id="365d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">让我们用气流来做</h1><p id="acf5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">您还记得在最初的引用中，dag 是用代码动态实例化的吗？</p><p id="59fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是这到底是什么意思呢？<br/>这意味着借助气流，你可以做到这一点</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Airflow a parallel DAG with multiple files</figcaption></figure><p id="14a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任务(和依赖项)可以以编程方式添加(例如，在 for 循环中)。相应的 DAG 如下所示。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/cbcbe88dd343bdea9782b4a2d8a0bc1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*4xY3fyTu5reN2zIpYEUchQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Parallel DAG</figcaption></figure><p id="8fd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时，您不必担心并行化。气流执行器从 DAG 定义中知道，每个分支可以并行运行，这就是它所做的！</p><h1 id="8a95" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">最终考虑</h1><p id="976f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们在这篇文章中谈到了很多点，我们谈到了工作流程、Luigi、气流以及它们之间的区别。</p><p id="5899" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们快速回顾一下。</p><p id="9266" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">路易吉</strong></p><ul class=""><li id="a87a" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mz mr ms mt bi translated">它通常基于管道，任务输入和输出共享信息并连接在一起</li><li id="c8fb" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mz mr ms mt bi translated">基于目标的方法</li><li id="3f6a" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mz mr ms mt bi translated">UI 是最小的，没有用户与正在运行的进程的交互</li><li id="b7d5" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mz mr ms mt bi translated">没有自己的触发</li><li id="871a" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mz mr ms mt bi translated">Luigi 不支持分布式执行</li></ul><p id="674e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">气流</strong></p><ul class=""><li id="b5a1" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mz mr ms mt bi translated">基于 DAGs 表示</li><li id="0755" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mz mr ms mt bi translated">一般来说，任务之间没有信息共享，我们希望尽可能地并行</li><li id="92b6" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mz mr ms mt bi translated">没有功能强大的任务间通信机制</li><li id="a33f" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mz mr ms mt bi translated">它有一个执行器，管理分布式执行(您需要设置它)</li><li id="b255" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mz mr ms mt bi translated">方法是“设置它，然后忘记它”,因为它有自己的调度程序</li><li id="5342" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mz mr ms mt bi translated">强大的用户界面，你可以看到执行和互动运行的任务。</li></ul></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="c283" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mh">结论:在本文中，我们了解了 Airflow 和 Luigi，以及这两者在工作流管理系统中的不同之处。我们看了一些非常简单的管道示例，以及它们如何使用这两种工具来实现。最后我们总结了 Luigi 和 Airflow 的主要区别。</em></p><p id="a54b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您喜欢这篇文章，并且觉得它很有用，请随意👏或者分享。</p><p id="26a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">干杯</p></div></div>    
</body>
</html>