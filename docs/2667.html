<html>
<head>
<title>Building Prediction APIs in Python (Part 4): Decoupling the Model and API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python构建预测API(第4部分):解耦模型和API</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-prediction-apis-in-python-part-4-decoupling-the-model-and-api-4b5eaf2ed125?source=collection_archive---------6-----------------------#2018-02-18">https://towardsdatascience.com/building-prediction-apis-in-python-part-4-decoupling-the-model-and-api-4b5eaf2ed125?source=collection_archive---------6-----------------------#2018-02-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/3a652a09bd234e14c407771398c8adf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9KoTjJNB-_TEdxWQqrk3EQ.jpeg"/></div></div></figure><div class=""/><p id="f90e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" rel="noopener" target="_blank" href="/building-prediction-apis-in-python-part-3-automated-testing-a7cfa1fa7e9d">在最后一部分</a>中，我们用pytest查看了自动化测试，以验证我们的API是否正确地对模型评分。在本文中，我们将探讨如何将负责处理请求和准备响应的API功能与准备特性和模型评分所需的代码分离开来。</p><p id="4cc0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你是这个系列的新手，欢迎！此外，您可能希望从头开始，只是为了回顾我们已经完成的内容。</p><div class="ip iq gp gr ir kx"><a rel="noopener follow" target="_blank" href="/building-prediction-apis-in-python-part-1-series-introduction-basic-example-fe89e12ffbd3"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd jc gy z fp lc fr fs ld fu fw ja bi translated">用Python构建预测API(第1部分):系列介绍&amp;基本示例</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">好吧，你已经训练了一个模型，但是现在呢？如果没有人会使用，所有的工作都是没有意义的。在某些应用中…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">towardsdatascience.com</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll ix kx"/></div></div></a></div><p id="abe5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我们将会看到一些代码片段，但是完整的文件可以在GitHub 上找到。</p><p id="4121" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">附注:我非常感谢这个系列给我的反馈。在前三个部分，我花了很多时间修改草稿，以确保尽可能清晰地呈现内容。我最近刚开始面试，所以时间有点紧。我将尽我所能继续定期发帖，但可能会有更长的延迟。我也会试着花更少的时间复习。如果有令人困惑的部分，请告诉我，我会尽力澄清。谢谢！</p><h1 id="ddaf" class="ln lo jb bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">紧密耦合代码</h1><p id="210a" class="pw-post-body-paragraph jy jz jb ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">我们将从<a class="ae kw" rel="noopener" target="_blank" href="/building-prediction-apis-in-python-part-3-automated-testing-a7cfa1fa7e9d">第三部分</a>中的虹膜预测模型的最后一个例子开始。我们将拒绝缺少<code class="fe mq mr ms mt b">petal_width</code>的请求；对于所有其他缺失的特征，我们将使用均值插补进行评分。</p><figure class="mu mv mw mx gt is"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="23bf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们所看到的，API包含了大量与这个特定模型相关的代码。事实上，大部分代码都是特定于这个模型或iris模型的一个版本的:</p><ol class=""><li id="5145" class="na nb jb ka b kb kc kf kg kj nc kn nd kr ne kv nf ng nh ni bi translated">我们从请求中检索硬编码的查询字符串参数，将它们转换成<code class="fe mq mr ms mt b">float</code>值，如果它们丢失或不能转换，就用默认值替换它们。</li><li id="23ab" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">我们正在检查<code class="fe mq mr ms mt b">petal_width</code>是否丢失，并准备发送一个特定的错误消息给呼叫者。</li><li id="4e77" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">我们正在创建特征向量。API需要知道将特性放入<code class="fe mq mr ms mt b">features</code>列表的正确顺序。</li><li id="e033" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">类别标签包含在一个全局<code class="fe mq mr ms mt b">MODEL_LABELS</code>变量中。</li></ol><p id="216f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以修改这个代码来处理这个模型的变体。例如，对我们的特性使用硬编码默认值通常是糟糕的编码实践。我们可以将这些提取到一个配置文件中。这将允许我们用不同的平均插补值对模型的两个版本进行评分。</p><p id="d390" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，我们将很快发现其他的变化将很难适应。假设我们想要实现两个不同的模型意图:当前版本和一个如果缺少<code class="fe mq mr ms mt b">petal_width</code>我们将估算，但是拒绝缺少<code class="fe mq mr ms mt b">sepal_width</code>的请求。如果处理其中一个模型的缺失值的逻辑变得更加复杂怎么办？如果我们有一个完全不同的模型——一个使用40个特征来预测欺诈的模型——会怎么样？</p><p id="2961" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如在之前的一篇文章中提到的，我们可以为每种类型的模型创建单独的API或端点，但是引用Raymond Hettinger的话，“一定有更好的方法！”</p><h1 id="7f1f" class="ln lo jb bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">拉开线球</h1><p id="1c0e" class="pw-post-body-paragraph jy jz jb ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">在理想情况下，我们会将这种功能划分如下:</p><ul class=""><li id="5305" class="na nb jb ka b kb kc kf kg kj nc kn nd kr ne kv no ng nh ni bi translated">API:接受请求，找到合适的模型进行评分，将原始数据传递给模型进行评分，并根据模型输出准备响应。</li><li id="62ad" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv no ng nh ni bi translated">Model:提取正确的字段，将原始数据准备成特性，预测是否可以对记录进行评分，如果不能，则引发错误，并将结果发送回API。</li></ul><h2 id="1093" class="np lo jb bd lp nq nr dn lt ns nt dp lx kj nu nv mb kn nw nx mf kr ny nz mj oa bi translated">包装我们的模型</h2><p id="bf57" class="pw-post-body-paragraph jy jz jb ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">有几种方法可以实现这一点，但是我们将从一种简单的方法开始。我们将在一些额外的代码中包装我们的模型，这些代码将处理特征检索和准备。</p><figure class="mu mv mw mx gt is"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="2a28" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mq mr ms mt b">ModelWrapper</code>类只有三种方法:<code class="fe mq mr ms mt b">__init__</code>、<code class="fe mq mr ms mt b">predict</code>和<code class="fe mq mr ms mt b">_prepare_features</code>。当我们创建一个实例时，我们将传入带有<code class="fe mq mr ms mt b">class_labels</code>(之前存储在<code class="fe mq mr ms mt b">MODEL_LABELS</code>中)和<code class="fe mq mr ms mt b">feature_defaults</code> ( <code class="fe mq mr ms mt b">dict</code>包含插补值)的Scikit-Learn模型对象(<code class="fe mq mr ms mt b">model_object</code>)。</p><p id="77fa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">API将调用<code class="fe mq mr ms mt b">predict</code>方法来获得预测。API将直接传入<code class="fe mq mr ms mt b">request.args</code>对象，模型将提取正确的字段。缺失值的提取和处理已转移到单独的方法<code class="fe mq mr ms mt b">_prepare_features</code>。这些函数中的代码与我们最初在API中的代码几乎相同。</p><p id="5529" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便提一句，如果您不熟悉Python中的单个前导下划线约定，这是一种将方法标记为“仅供内部使用”的方式——代码只打算由类(或其基类/子类)中定义的其他方法调用。然而，没有机制可以阻止任何人直接调用它。</p><p id="7f53" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后要讨论的是我们如何将预测或错误返回给API代码。如果我们成功了，我们将返回一个带有<code class="fe mq mr ms mt b">label</code>和<code class="fe mq mr ms mt b">probabilities</code>的<code class="fe mq mr ms mt b">dict</code>。在出现错误的情况下，我们将引发一个定制的异常，<code class="fe mq mr ms mt b">ModelError</code>，它被定义在文件的顶部。一个奇怪的实现细节是我选择将这个异常作为<code class="fe mq mr ms mt b">ModelWrapper</code>的一部分。稍后，我们将在API中使用它来引用<code class="fe mq mr ms mt b">try/except</code>块中的这个异常。更干净的方法是在定义的地方有一个共享的工具模块/库。然后，模型包装器代码和API都可以引用这个定义。我认为共享库的方法可能更令人困惑(单独的文件),这就是为什么我选择了这个。</p><h2 id="8d3e" class="np lo jb bd lp nq nr dn lt ns nt dp lx kj nu nv mb kn nw nx mf kr ny nz mj oa bi translated">修改模型构建</h2><p id="8bbf" class="pw-post-body-paragraph jy jz jb ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">既然我们已经定义了包装器代码，我们需要将它合并到我们的模型构建过程中。这样，我们可以使用<code class="fe mq mr ms mt b">joblib</code>将模型、特征提取和评分代码一起打包/保存。</p><figure class="mu mv mw mx gt is"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="780b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本上，我们只是创建了一个<code class="fe mq mr ms mt b">dict</code>，它有键的特性名称和特性的平均值作为相应的值。我们包装模型，然后保存这个包装的版本。为了清楚起见，我省略了生成我们的测试数据集的代码(参见<a class="ae kw" rel="noopener" target="_blank" href="/building-prediction-apis-in-python-part-3-automated-testing-a7cfa1fa7e9d">第3部分</a>，但是你可以在这里找到<a class="ae kw" href="https://github.com/cmoradi/prediction-apis/blob/master/part03-testing/code/04_test_reject_missing_petalwidth/build_model_v1.0.py" rel="noopener ugc nofollow" target="_blank">完整的文件。</a></p><h2 id="16c9" class="np lo jb bd lp nq nr dn lt ns nt dp lx kj nu nv mb kn nw nx mf kr ny nz mj oa bi translated">新的API</h2><p id="7321" class="pw-post-body-paragraph jy jz jb ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">最后一步是修改我们的API来使用包装的模型。</p><figure class="mu mv mw mx gt is"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="eb9d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大多数情况下，我们需要删除所有的特征提取和评分代码。<code class="fe mq mr ms mt b">MODEL</code>以同样的方式加载(作为一个全局变量)，但是这个版本除了包含我们的Scikit模型之外，还包含了所有的<code class="fe mq mr ms mt b">ModelWrapper</code>代码。在一个<code class="fe mq mr ms mt b">try/except</code>街区，我们叫<code class="fe mq mr ms mt b">MODEL.predict()</code>，但现在我们只是路过<code class="fe mq mr ms mt b">request.args</code>。如果出现异常，我们可以捕捉异常，并将错误消息转换成正确的响应(带有正确的状态代码)。如果没有出现异常，我们将返回一个带有标签和类别概率的<code class="fe mq mr ms mt b">dict</code>。剩下的唯一事情就是通过<code class="fe mq mr ms mt b">jsonify()</code>准备响应。</p><h2 id="bffa" class="np lo jb bd lp nq nr dn lt ns nt dp lx kj nu nv mb kn nw nx mf kr ny nz mj oa bi translated">运行我们的测试</h2><p id="923c" class="pw-post-body-paragraph jy jz jb ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">我们可以复制我们在第3部分中构建的<code class="fe mq mr ms mt b">test_predict_api.py</code>文件(这里也有<a class="ae kw" href="https://github.com/cmoradi/prediction-apis/tree/master/part03-testing/code/04_test_reject_missing_petalwidth" rel="noopener ugc nofollow" target="_blank"/>)。将它与所有其他文件放在同一个目录中，并运行<code class="fe mq mr ms mt b">pytest</code>。这些测试应该都能通过。</p><h1 id="bbcd" class="ln lo jb bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">这种方法的局限性</h1><p id="3447" class="pw-post-body-paragraph jy jz jb ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">我们已经成功地将我们的模型评分代码从我们的通用API代码中分离出来。现在，API的<code class="fe mq mr ms mt b">predict</code>端点中没有任何东西是特定于这个model⁴的，所以我们可以快速扩展这个API来对多个模型进行评分。</p><p id="4531" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这是一个巨大的进步，但这种方法存在一些挑战。主要的一点是特性生成代码与一般的模型构建代码是分开的。可能很难看到这一点，因为我们的模型构建非常简单。我们的训练数据集甚至没有任何缺失值，所以我们不需要做均值插补。假设我们正在使用一个更现实的模型，该模型需要分类变量的虚拟/一次性编码、插补或复杂的特征计算，而不仅仅是转换到<code class="fe mq mr ms mt b">float</code>。使用我们当前的方法，我们可能需要维护这个特征化代码的两个版本:一个操作训练数据，另一个版本是<code class="fe mq mr ms mt b">ModelWrapper</code>的一部分。</p><p id="1f33" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一个可以应用于训练和评分环境的统一特征代码库有巨大的好处，但这可能具有挑战性，并不总是可能的。通过在两个上下文中使用单一版本的特征化代码，我们减少了错误，并且可以更快地部署模型。这不总是可能的主要原因是每个上下文有不同的约束。在模型构建过程中，必须准备好整个训练数据集，因此可以优化实现以一次处理许多记录。对于评分，我们只需要准备一个单一的记录，但这应该尽快完成。</p><p id="d0bf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们不打算在这篇文章中讨论它，但是Scikit-Learn有一个管道特性，让我们定义在模型构建和评分上下文之间共享的预处理/特征化步骤。然而，这也不是一个完美的解决方案。对可以在管道中定义的步骤类型有一些约束，这可能是限制性的。⁵</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h1 id="6759" class="ln lo jb bd lp lq oi ls lt lu oj lw lx ly ok ma mb mc ol me mf mg om mi mj mk bi translated">脚注</h1><ol class=""><li id="e10e" class="na nb jb ka b kb ml kf mm kj on kn oo kr op kv nf ng nh ni bi translated">Raymond从事Python核心开发已经超过15年，并且是<code class="fe mq mr ms mt b">collections</code>和<code class="fe mq mr ms mt b">itertools</code>模块的创建者。他还教授Python多年，是一位杰出的教育家。谷歌一下他，看看他所有的演讲，因为他们简直太棒了。</li><li id="d983" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">你可以把这些看作是Java类中的<code class="fe mq mr ms mt b">private</code>或<code class="fe mq mr ms mt b">protected</code>方法。但是，Java明确禁止从外部调用这些方法。Python不会。</li><li id="8721" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">状态不是结果<code class="fe mq mr ms mt b">dict</code>的一部分，所以我们需要添加它。如果你不熟悉<code class="fe mq mr ms mt b">**result</code>，这是执行关键字解包。快速举例:<code class="fe mq mr ms mt b">d = {'a': 1, 'b': 2, 'c': 3}</code>。然后，调用:<code class="fe mq mr ms mt b">myfuct(**d)</code>等价于调用:<code class="fe mq mr ms mt b">myfunct(a=1, b=2, c=3)</code></li><li id="44c3" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">我们仍然有硬编码的<code class="fe mq mr ms mt b">MODEL</code>全局变量，但是我们会在将来修复它。</li><li id="f5cb" class="na nb jb ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">可能有一个我们希望在API平台上运行的特定步骤，我们不需要在模型构建过程中运行。在以后的文章中，我们将关注日志/数据库存储。我们可能希望存储的一件事是准备好的特征向量，以便如果我们在API平台上遇到问题，我们可以验证特征是否被正确计算。为此，我们需要在模型评分发生之前在管道中插入一个“记录”步骤(管道的最后一步)。我不确定这是否可能。</li></ol></div></div>    
</body>
</html>