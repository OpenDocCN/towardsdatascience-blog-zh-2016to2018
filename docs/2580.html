<html>
<head>
<title>A gentle guide to Tidy statistics in R (part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R中整洁统计的简明指南(第2部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-gentle-guide-to-statistics-in-r-ccb91cc1177e?source=collection_archive---------1-----------------------#2018-02-09">https://towardsdatascience.com/a-gentle-guide-to-statistics-in-r-ccb91cc1177e?source=collection_archive---------1-----------------------#2018-02-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/907e4bccdf3cc1dcbe41fe346f194105.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dpuh7UPsEYRTkk2uy0RkRQ.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">While data analysis in R can seem intimidating, we will explore how to use it effectively and clearly!</figcaption></figure><div class=""/><p id="2ba8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://medium.com/@j.thomasmock/a-gentle-guide-to-statistics-in-r-a1da223e08b7" rel="noopener">第1部分</a>让您踏上用R代码运行统计数据的旅程。</p><h1 id="f158" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">介绍</h1><p id="5879" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">在Jesse Maegan ( <a class="ae la" href="http://twitter.com/kiersi" rel="noopener ugc nofollow" target="_blank"> @kiersi </a>)在Twitter上发起了一场大讨论之后，我决定发布一些(伪造的)实验治疗数据。这些数据与一种名为AD-x37的新(假)研究药物相对应，AD-x37是一种理论药物，已被证明对阿尔茨海默病小鼠模型的认知衰退具有有益的结果。在目前的实验中，我们将对<strong class="ke jg">药物</strong>在减少痴呆患者的<strong class="ke jg">认知障碍</strong>方面是否有效进行<strong class="ke jg">统计测试</strong>。此处见数据<a class="ae la" href="https://github.com/TexData43/tidy-stats-in-R/blob/master/ad_treatment.xlsx" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="b51e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将使用MMSE(简易精神状态测验)分数来评估认知障碍的程度。在真正的临床试验中，会记录许多其他变量，但为了一个简单但多变量的例子，我们将只关注MMSE。</p><figure class="mf mg mh mi gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi me"><img src="../Images/1f0ec31c6d0340ca8f4ec7e3aa8b7ac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zU_zT8-ShcgwdB-QlBPJJQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Source: Folstein et al, 1975 — J Psychiatr Res 12:189–198</figcaption></figure><p id="81cb" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将通过<code class="fe mj mk ml mm b">tidyverse</code>加载、绘制、分析和保存我们的分析输出，这是一个为数据分析而设计的“R包的自以为是的集合”。我们将把依赖性限制在两个包中:<code class="fe mj mk ml mm b">tidyverse</code>和<code class="fe mj mk ml mm b">broom</code>，而对其余的包使用基数R。在我看来，这两个包极大地改进了数据分析工作流程。虽然其他侧重于统计的包提供了额外的统计测试，但base R有相当好的能力来执行开箱即用的统计分析。我将使用<code class="fe mj mk ml mm b">knitr::kable</code>为markdown文档生成一些html表格，但是对于工作流来说这不是必需的。</p><p id="c35b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此外，我将上传本例中使用的<a class="ae la" href="https://github.com/TexData43/tidy-stats-in-R/blob/master/ad_treatment.xlsx" rel="noopener ugc nofollow" target="_blank"> excel表</a>，以便您可以自己重新创建工作流程。您可以简单地复制粘贴此处看到的代码，它将在R中运行。如果您希望在R-Markdown文档中看到整个工作流，请参见此处的<a class="ae la" href="http://rpubs.com/jtmock/tidy-stats-in-R" rel="noopener ugc nofollow" target="_blank"/>。R Markdown是在R内部创建的一个文档，它允许您编写代码、内联执行代码，并在编写过程中编写注释/笔记。你可以把它想象成能够在一个基本的Word文档中编写R代码(但是它能做的远不止这些！).</p><p id="bee1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">虽然您可能对我提供的数据集不感兴趣，但这有望为您提供一个清晰的工作流程，让您可以交换感兴趣的数据并完成基本分析！</p><h2 id="ca7c" class="mn lc jf bd ld mo mp dn lh mq mr dp ll kn ms mt lp kr mu mv lt kv mw mx lx my bi translated">装载扫把、扫帚和编织机</h2><p id="83b3" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">使用库函数，我们将加载<code class="fe mj mk ml mm b">tidyverse</code>。如果您以前从未安装过它，您也可以使用<code class="fe mj mk ml mm b">install.packages("tidyverse")</code>调用来首次安装它。这个包包括<code class="fe mj mk ml mm b">ggplot2</code>(图形)、<code class="fe mj mk ml mm b">dplyr</code> / <code class="fe mj mk ml mm b">tidyr</code>(汇总统计、数据操作)、和<code class="fe mj mk ml mm b">readxl</code>(读取excel文件)以及管道<code class="fe mj mk ml mm b">%&gt;%</code>，这将使我们的代码更具可读性！我们还将加载<code class="fe mj mk ml mm b">broom</code>包来整理我们的一些统计输出。最后，我们将通过<code class="fe mj mk ml mm b">knitr::kable,</code>加载<code class="fe mj mk ml mm b">knitr</code>来制作漂亮的html表格，但不需要简单地将输出保存到Excel。</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="def2" class="mn lc jf mm b gy nd ne l nf ng"># Load libraries<br/>library(tidyverse)<br/>library(broom)<br/>library(knitr)<br/>library(readxl)</span></pre><p id="88b1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将输出一些关于正在加载的包和任何函数调用冲突的消息。</p><p id="b25f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">加载数据</strong></p><p id="778c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当我呼叫<code class="fe mj mk ml mm b">readxl::read_xlsx</code>时，您也可以简单地使用<code class="fe mj mk ml mm b">read_xlsx, </code>，但是为了透明起见，我将使用完整的呼叫开始。使用<code class="fe mj mk ml mm b">::</code>调用函数的概念很重要，因为一些包在函数上有冲突，例如多个包包括函数<code class="fe mj mk ml mm b">select </code>和<code class="fe mj mk ml mm b">summarize</code>。这样，我们可以明确我们希望R从哪个包中调用我们的函数，所以<code class="fe mj mk ml mm b">package::function</code>！要了解更多关于调用函数时“名称空间”的概念，请查看<a class="ae la" href="http://r-pkgs.had.co.nz/namespace.html" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="7145" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe mj mk ml mm b">readxl </code>很不幸是一个有趣的例子，因为安装<code class="fe mj mk ml mm b">tidyverse </code>会安装<code class="fe mj mk ml mm b">readxl</code>，但是通过<code class="fe mj mk ml mm b">library </code>调用加载<code class="fe mj mk ml mm b">tidyverse </code>时<code class="fe mj mk ml mm b">readxl </code>不会被加载。因此，我们必须像加载任何其他包一样加载<code class="fe mj mk ml mm b">readxl </code>，或者像<code class="fe mj mk ml mm b">readxl::read_xlsx.</code> <code class="fe mj mk ml mm b">readxl </code>中允许我们读取的那样调用包和名称。xls，。或者，您可以将您的Excel表转换为。csv，可以通过<code class="fe mj mk ml mm b">read_csv()</code>读取。通过使用来自<code class="fe mj mk ml mm b">dplyr</code>的<code class="fe mj mk ml mm b">glimpse</code>函数，我们可以看到变量是如何导入的，以及前几行。</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="c09b" class="mn lc jf mm b gy nd ne l nf ng"># Read excel file<br/>raw_df &lt;- readxl::read_xlsx("ad_treatment.xlsx")<br/>dplyr::glimpse(raw_df)</span><span id="d24f" class="mn lc jf mm b gy nh ne l nf ng"># this is the output from glimpse(raw_df)<br/>Observations: 600<br/>Variables: 5<br/>$ age            &lt;dbl&gt; 80, 85, 82, 80, 83, 79, 82, 79, 80, 79, ...<br/>$ sex            &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, ...<br/>$ health_status  &lt;chr&gt; "Healthy", "Healthy", "Healthy", ...<br/>$ drug_treatment &lt;chr&gt; "Placebo", "Placebo", "Placebo", ...<br/>$ mmse           &lt;dbl&gt; 24.78988, 24.88192, 25.10903, 23.38...</span></pre><p id="a089" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们现在可以收集一些关于数据集的信息。也就是说，我们有3个分类/因素变量:性别、健康状况和药物治疗以及1个因变量(DV): mmse。我们也有年龄，但重要的是它被记录为一个离散的数字，而不是一个因素(如85岁，而不是老)。因此，我们可以考虑年龄，但我们不会把它作为方差分析的一个因素。</p><p id="f992" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">检查数据分布</strong></p><p id="8f23" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将使用第一个<code class="fe mj mk ml mm b">ggplot2</code>调用来创建一个显示年龄分布的图表。为了分解我们正在做的事情，我们需要调用ggplot，告诉它使用什么数据，并使用<code class="fe mj mk ml mm b">aes </code>或“美学”调用来分配x坐标。然后我们添加一个<code class="fe mj mk ml mm b">+ </code>，告诉ggplot包含下一行代码。<code class="fe mj mk ml mm b">geom_density</code>告诉R我们想要创建一个密度分布层，我们想要<code class="fe mj mk ml mm b">fill</code>用蓝色！关于<code class="fe mj mk ml mm b">ggplot2</code>的更多信息，请点击<a class="ae la" href="http://moderndive.com/3-viz.html" rel="noopener ugc nofollow" target="_blank">此处</a>或<a class="ae la" href="http://r4ds.had.co.nz/data-visualisation.html" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="cd30" class="mn lc jf mm b gy nd ne l nf ng">ggplot(data = raw_df, aes(x = age)) + <br/> geom_density(fill = "blue")</span></pre><figure class="mf mg mh mi gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ni"><img src="../Images/0f15ea153e6f3b89d9bdf46fab4a174e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wEYOQACTpHRPnFzBN1ZRkA.png"/></div></div></figure><p id="6496" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">图表显示，年龄实际上只在79-85岁之间，而且实际上不存在年龄过高或过低的情况。我们可以通过一个<code class="fe mj mk ml mm b">dplyr</code>summary调用或通过调用base R中的<code class="fe mj mk ml mm b">range</code>来确认年龄范围s。顺便提一下，我们现在可以讨论使用管道或<code class="fe mj mk ml mm b">%&gt;%.</code>管道将结果或数据从它的左边传递到右边。有关该管道的更多信息，请参见<a class="ae la" href="https://www.datacamp.com/community/tutorials/pipe-r-tutorial" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="78a7" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以把下面的代码理解为取<code class="fe mj mk ml mm b">raw_df</code>，然后通过取<code class="fe mj mk ml mm b">age</code>变量的<code class="fe mj mk ml mm b">min</code>和<code class="fe mj mk ml mm b">max</code>来<code class="fe mj mk ml mm b">summarize</code>它。现在，因为我们从<code class="fe mj mk ml mm b">raw_df</code>开始，R知道我们想要从这个数据帧中取出列<code class="fe mj mk ml mm b">age</code>。</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="ddac" class="mn lc jf mm b gy nd ne l nf ng">raw_df %&gt;% summarize(<br/> min = min(age), <br/> max = max(age))</span><span id="1520" class="mn lc jf mm b gy nh ne l nf ng"># A tibble: 1 x 2<br/>    min   max<br/>  &lt;dbl&gt; &lt;dbl&gt;<br/>1  79.0  85.0</span></pre><p id="8a00" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">或者，我们可以使用base R <code class="fe mj mk ml mm b">range</code>函数，这需要使用<code class="fe mj mk ml mm b">$</code>。美元符号表示R应该使用来自<code class="fe mj mk ml mm b">raw_df</code>的<code class="fe mj mk ml mm b">age</code>列。这两个函数给我们的结果是一样的，最小数和最大数。</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="cb38" class="mn lc jf mm b gy nd ne l nf ng">range(raw_df$age)</span><span id="62e9" class="mn lc jf mm b gy nh ne l nf ng">[1] 79 85</span></pre><p id="5ccd" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有关使用这两种语法的更多信息，请点击<a class="ae la" href="http://www.science.smith.edu/~amcnamara/Syntax-cheatsheet.pdf" rel="noopener ugc nofollow" target="_blank">这里</a>或者查看备忘单<a class="ae la" href="https://www.rstudio.com/resources/cheatsheets/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="a2bc" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">实验变量水平如何？</p><p id="7352" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，虽然我非常清楚这个数据框架中的变量，但你可能不会不探索它！为了快速确定<code class="fe mj mk ml mm b">drug_treatment</code>组、<code class="fe mj mk ml mm b">health_status</code>组以及它们如何交互，我们可以做一个<code class="fe mj mk ml mm b">table</code>调用。通过在<code class="fe mj mk ml mm b">drug_treatment</code>和<code class="fe mj mk ml mm b">health_status</code>上调用它，我们得到了一个很好的表格，它分解了每个变量组中有多少行。</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="e11c" class="mn lc jf mm b gy nd ne l nf ng">table(raw_df$drug_treatment, raw_df$health_status)</span><span id="1f21" class="mn lc jf mm b gy nh ne l nf ng">#output below</span><span id="c539" class="mn lc jf mm b gy nh ne l nf ng">            Alzheimer's Healthy<br/>  High Dose         100     100<br/>  Low dose          100     100<br/>  Placebo           100     100</span></pre><p id="13d5" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">或者，我们可以用下面的代码在<code class="fe mj mk ml mm b">dplyr</code>中做同样的事情。</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="bc7a" class="mn lc jf mm b gy nd ne l nf ng">raw_df %&gt;% <br/>  group_by(drug_treatment, health_status) %&gt;% <br/>  count()</span></pre><p id="c437" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们知道了我们感兴趣的变量的水平，并且每个整体治疗组有100名患者！</p><p id="a236" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">因变量的数据探索</strong></p><p id="27ed" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在运行我们的汇总统计数据之前，我们可以通过一个<code class="fe mj mk ml mm b">geom_boxplot</code>调用来可视化范围、集中趋势和四分位数。</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="63b6" class="mn lc jf mm b gy nd ne l nf ng">ggplot(data = raw_df, # add the data<br/>       aes(x = drug_treatment, y = mmse, # set x, y coordinates<br/>           color = drug_treatment)) +    # color by treatment<br/>  geom_boxplot() +<br/>  facet_grid(~health_status) # create panes base on health status</span></pre><figure class="mf mg mh mi gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ni"><img src="../Images/5471a9ae05fe0279cc95ec1219ee05dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hatTjK_p6Sy6i7QtTvvtpQ.png"/></div></div></figure><p id="9474" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将健康和阿尔茨海默病患者的数据分成单独的图形面(或窗格),并按药物治疗分成每个面内的组。这个图表告诉我们一些有趣的事情。看起来我们的(假的)神奇药物确实有效果了！让我们用描述性统计来探讨这个问题。</p><p id="3fdb" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">虽然这是一个探索性的图表，我们不一定要将其“调整”到完美，但我们可以注意到，我们的药物治疗应该是安慰剂&lt; Low dose &lt; High Dose and we should have Healthy patients presented first, and Alzheimer’s patients second. This is something we can fix in our next section!</p><p id="d37e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">汇总统计</strong></p><p id="af83" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们希望生成mmse分数的平均值和标准误差，这对于测量集中趋势和创建我们的最终出版图表是有用的。我们有性别、药物治疗和健康状况的分类变量。然而，回到我们之前的<code class="fe mj mk ml mm b">glimpse</code>调用，我们可以看到数据没有被正确“编码”。即性是一个<code class="fe mj mk ml mm b">dbl</code>(数字)，没有描述性名称，<code class="fe mj mk ml mm b">health_status</code> / <code class="fe mj mk ml mm b">drug_treatment</code>是<code class="fe mj mk ml mm b">chr</code>(人物)！这些都需要换算成因子！</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="909d" class="mn lc jf mm b gy nd ne l nf ng">Observations: 600<br/>Variables: 5<br/>$ age            &lt;dbl&gt; 80, 85, 82, 80, 83, 79, 82, 79, 80, 79, ...<br/>$ sex            &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1...<br/>$ health_status  &lt;chr&gt; "Healthy", "Healthy", "Healthy", ...<br/>$ drug_treatment &lt;chr&gt; "Placebo", "Placebo", "Placebo", ...<br/>$ mmse           &lt;dbl&gt; 24.78988, 24.88192, 25.10903, 23.38...</span></pre><p id="e244" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以使用<code class="fe mj mk ml mm b">dplyr::mutate</code>函数告诉R我们想要改变(突变)感兴趣的变量中的行。因此，我们将获取<code class="fe mj mk ml mm b">sex</code>、<code class="fe mj mk ml mm b">drug_treatment</code>和<code class="fe mj mk ml mm b">health_status </code>列中的数据，并将它们从数字或字符转换成因子变量！<code class="fe mj mk ml mm b">dplyr::mutate</code>还可以表演数学，以及许多其他有趣的事情。更多信息，请参见<a class="ae la" href="http://stat545.com/block010_dplyr-end-single-table.html#use-mutate-to-add-new-variables" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="58b8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将使用<code class="fe mj mk ml mm b">mutate </code>函数和基数R <code class="fe mj mk ml mm b">factor</code>函数将我们的变量转换成适当的因子，并给它们加上标签(表示性别)或重新排列因子的级别。</p><p id="40bd" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们需要非常小心地准确键入列中显示的标签，否则它会用NA替换那些拼写错误的标签。例如，您是否注意到<code class="fe mj mk ml mm b">High Dose</code>有一个大写的“D ”,而<code class="fe mj mk ml mm b">Low dose</code>有一个小写的“D ”?</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="ab42" class="mn lc jf mm b gy nd ne l nf ng">sum_df &lt;- raw_df %&gt;% <br/>            mutate(<br/>              sex = factor(sex, <br/>                  labels = c("Male", "Females")),<br/>              drug_treatment =  factor(drug_treatment, <br/>                  levels = c("Placebo", "Low dose", "High Dose")),<br/>              health_status = factor(health_status, <br/>                  levels = c("Healthy", "Alzheimer's"))<br/>              )</span></pre><p id="873b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">尽管R非常强大，但它需要明确而准确的代码输入来完成最终目标。因此，如果我们键入“High <strong class="ke jg"> d </strong> ose ”,它会给出安娜，而“High <strong class="ke jg"> D </strong> ose”会正确输出。我们现在将<code class="fe mj mk ml mm b">age </code>和<code class="fe mj mk ml mm b">mmse </code>视为<code class="fe mj mk ml mm b">dbl </code>(数字)，将<code class="fe mj mk ml mm b">sex</code>、<code class="fe mj mk ml mm b">health_status</code>和<code class="fe mj mk ml mm b">drug_treatment </code>视为因子。</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="35f8" class="mn lc jf mm b gy nd ne l nf ng">Observations: 600<br/>Variables: 5<br/>$ age            &lt;dbl&gt; 80, 85, 82, 80, 83, 79, 82, 79, 80, 79,...<br/>$ sex            &lt;fct&gt; Male, Male, Male, Male, Male, Females, Mal...<br/>$ health_status  &lt;fct&gt; Healthy, Healthy, Healthy, Healthy, Health...<br/>$ drug_treatment &lt;fct&gt; Placebo, Placebo, Placebo, Placebo, Placeb...<br/>$ mmse           &lt;dbl&gt; 24.78988, 24.88192, 25.10903, 24.92636,...</span></pre><p id="bceb" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在一切都已正确编码，我们可以计算我们的平均值和标准误差(se =标准偏差/样本数的平方根)！我们将使用<code class="fe mj mk ml mm b">group_by</code>来告诉R我们想要…分组的因素！然后，我们将通过首先调用<code class="fe mj mk ml mm b">summarize</code>然后用<code class="fe mj mk ml mm b">mmse_mean</code>和<code class="fe mj mk ml mm b">mmse_se</code>以及样本数量<code class="fe mj mk ml mm b">n()</code>指定我们想要的汇总来创建命名汇总。最后，我们将<code class="fe mj mk ml mm b">ungroup</code>，从数据帧中删除<code class="fe mj mk ml mm b">group_by</code>代码。</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="2dc8" class="mn lc jf mm b gy nd ne l nf ng">sum_df &lt;- sum_df %&gt;%   <br/>  group_by(sex, health_status, drug_treatment) %&gt;%  <br/>  summarize(mmse_mean = mean(mmse),   <br/>            mmse_se = sd(mmse)/sqrt(n()),<br/>            n_samples = n()) %&gt;%<br/>  ungroup() # ungrouping variable is a good habit to prevent errors</span></pre><p id="355e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们有了一个格式良好的数据框架，可以保存到Excel中，或用于绘图。我们需要指出我们正在写什么数据(<code class="fe mj mk ml mm b">sum_df</code>)以及我们希望结果文件被命名为什么(<code class="fe mj mk ml mm b">“adx37_sum_stats.csv”</code>)。</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="e5f9" class="mn lc jf mm b gy nd ne l nf ng"># code to save the table into a .csv Excel file<br/>write.csv(sum_df, "adx37_sum_stats.csv")</span></pre><figure class="mf mg mh mi gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nj"><img src="../Images/0df59e3265a361f0587c797a5e07d5fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*Y9MWE2qJUHnUXO3r7mVLXA.png"/></div></div></figure><p id="0c99" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">总结图</strong></p><p id="435b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过调用ggplot函数，我们可以生成一个初步的摘要图。</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="96b0" class="mn lc jf mm b gy nd ne l nf ng">ggplot(data = sum_df, # add the data<br/>       aes(x = drug_treatment,  #set x, y coordinates<br/>           y = mmse_mean,<br/>           group = drug_treatment,  # group by treatment<br/>           color = drug_treatment)) +    # color by treatment<br/>  geom_point(size = 3) + # set size of the dots<br/>  facet_grid(sex~health_status) # create facets by sex and status</span></pre><figure class="mf mg mh mi gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ni"><img src="../Images/e1501ff094dae2ae4b56b9a95dac04f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h8xAfONMyMdubstKgmkXbw.png"/></div></div></figure><p id="712e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们现在可以看到，该图按照药物治疗和健康状况进行了适当的分类。我们在最终的图表上还有一些工作要做，但是让我们先来看看ANOVAs！</p><p id="00cb" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">方差分析终于出来了！</strong></p><p id="8787" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将准备一个数据框架，通过方差分析进行分析。我们需要再次确保通过<code class="fe mj mk ml mm b">mutate</code>将我们的因素作为因素，并且顺序正确。这是ANOVA/事后检验工作所必需的，并使事后hoc和ANOVA输出更容易读取。</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="03ae" class="mn lc jf mm b gy nd ne l nf ng">stats_df &lt;- raw_df %&gt;% # start with data<br/>   mutate(drug_treatment = factor(drug_treatment, <br/>             levels = c("Placebo", "Low dose", "High Dose")),<br/>         sex = factor(sex, <br/>             labels = c("Male", "Female")),<br/>         health_status = factor(health_status, <br/>             levels = c("Healthy", "Alzheimer's")))</span><span id="6a80" class="mn lc jf mm b gy nh ne l nf ng">glimpse(stats_df)</span><span id="4ff0" class="mn lc jf mm b gy nh ne l nf ng">#output below</span><span id="4542" class="mn lc jf mm b gy nh ne l nf ng">Observations: 600<br/>Variables: 5<br/>$ age            &lt;dbl&gt; 80, 85, 82, 80, 83, 79, 82, 79, 80, 79...<br/>$ sex            &lt;fct&gt; Male, Male, Male, Male, Male, Male, ...<br/>$ health_status  &lt;fct&gt; Healthy, Healthy, Healthy, Healthy...<br/>$ drug_treatment &lt;fct&gt; Placebo, Placebo, Placebo, Placebo,...<br/>$ mmse           &lt;dbl&gt; 24.78988, 24.88192, 25.10903...</span></pre><p id="5782" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这使我们的数据框架进入工作状态！</p><p id="2947" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过<code class="fe mj mk ml mm b">aov</code>功能调用ANOVA。基本语法通过下面的伪代码显示。我们首先放入因变量(在我们的例子中是mmse ),然后是一个<code class="fe mj mk ml mm b">~</code>,然后是我们想要测试的自变量。最后，我们指定使用什么数据。</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="a74c" class="mn lc jf mm b gy nd ne l nf ng">aov(dependent_variable ~ independent variable, data = data_df)</span></pre><p id="be96" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以通过下面的代码添加真实的数据集:</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="66c1" class="mn lc jf mm b gy nd ne l nf ng"># this gives main effects AND interactions<br/>ad_aov &lt;- aov(mmse ~ sex * drug_treatment * health_status, <br/>        data = stats_df)</span><span id="1f10" class="mn lc jf mm b gy nh ne l nf ng"># this would give ONLY main effects<br/>ad_aov &lt;- aov(mmse ~ sex + drug_treatment + health_status, data = stats_df)</span></pre><p id="d729" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因为我们有3个独立变量，所以我们要做出选择。我们可以简单地通过在每个变量之间添加一个<code class="fe mj mk ml mm b">+</code>来寻找主效应，或者我们可以通过在每个变量之间添加一个<code class="fe mj mk ml mm b">*</code>来寻找主效应和交互作用。确保不要用逗号替换<code class="fe mj mk ml mm b">+</code>或<code class="fe mj mk ml mm b">*</code>，因为这会导致错误！</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="aa55" class="mn lc jf mm b gy nd ne l nf ng"># this throws an error because we shouldn't use commas in between!<br/>ad_aov &lt;- aov(mmse ~ sex, drug_treatment, health_status, data = stats_df)</span></pre><p id="69b5" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过将ANOVA分配给<code class="fe mj mk ml mm b">ad_aov</code>对象，我们可以调用它的<code class="fe mj mk ml mm b">summary </code>来查看ANOVA的结果。</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="3384" class="mn lc jf mm b gy nd ne l nf ng"># look at effects and interactions<br/>summary(ad_aov)</span><span id="da5d" class="mn lc jf mm b gy nh ne l nf ng">                                  Df  Sum Sq Mean Sq  F value Pr(&gt;F)    <br/>sex                                1      0       0    0.047  0.828    <br/>drug_treatment                     2   3601    1801  909.213<strong class="mm jg"> &lt;2e-16</strong> <br/>health_status                      1  10789   10789 5447.953 <strong class="mm jg">&lt;2e-16</strong> <br/>sex:drug_treatment                 2      8       4    2.070  0.127    <br/>sex:health_status                  1      5       5    2.448  0.118    <br/>drug_treatment:health_status       2   2842    1421  717.584 <strong class="mm jg">&lt;2e-16</strong> <br/>sex:drug_treatment:health_status   2      5       2    1.213  0.298    <br/>Residuals                        588   1164       2                    <br/>---<br/>Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</span></pre><p id="6aa1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">总结给出了自由度、平方和、均方、F值和p值。我在&lt;2e -16, these p values are so small that R switches to scientific notation. So we see significant main effects of drug treatment, health status, and an interaction of drug treatment by health status. We can interpret that Alzheimer’s patients had different cognitive scores than healthy, and that drug treatment had an effect on cognitive scores. Importantly, sex was not a significant factor, as p = 0.828. Variables being scored as significant or non-significant can both be important!</p><p id="c5a7" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">We can also use  【T6】  to clean up the results of the ANOVA and put them into a dataframe. This is useful for storage, or for automation of some analysis for future ANOVAs.</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="648a" class="mn lc jf mm b gy nd ne l nf ng"># this extracts ANOVA output into a nice tidy dataframe<br/>tidy_ad_aov &lt;- tidy(ad_aov)</span><span id="a2ed" class="mn lc jf mm b gy nh ne l nf ng"># which we can save to Excel<br/>write.csv(tidy_ad_aov, "ad_aov.csv")</span></pre><p id="9b32" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">However, we don’t know the direction of changes, or where the changes occurred. Was it just the high dose? Low dose? Both? We need follow-up post hoc tests to determine these answers!</p><p id="6130" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">后hocs &gt;博士后(学术界笑话&lt;爸爸笑话)</strong>上加了一个醒目的强调</p><p id="1154" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们有多种方式来看待后hocs。我将在这一部分展示两个。</p><p id="2a3a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于成对的，我们需要使用<code class="fe mj mk ml mm b">$</code>从每个数据帧中选择列，并通过<code class="fe mj mk ml mm b">:</code>查看交互。我们的第一个两两比较没有对多重比较进行校正，与无保护的Fisher's-LSD post-hoc相当。这一点也不严格，考虑到我们所做的大量比较，建议要么继续进行p.adjusting Bonferonni校正(将<code class="fe mj mk ml mm b">p.adj = “none”</code>改为<code class="fe mj mk ml mm b">p.adj = “bonf”</code>)要么进行Tukey事后测试，如下例所示。您可以看到，由于<code class="fe mj mk ml mm b">dataset$column</code>方法和每次交互之间对<code class="fe mj mk ml mm b">:</code>的需要，这个方法读起来有点混乱。我们可以这样理解，我们需要对<code class="fe mj mk ml mm b">sex </code>和<code class="fe mj mk ml mm b">drug_treatment </code>和<code class="fe mj mk ml mm b">health_status</code>的相互作用进行成对t.test，它给出了这些因素相对于其他因素的每一次迭代。</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="0cf9" class="mn lc jf mm b gy nd ne l nf ng"># call and save the pair.t.test<br/>ad_pairwise &lt;- pairwise.t.test(stats_df$mmse,    stats_df$sex<strong class="mm jg">:</strong>stats_df$drug_treatment<strong class="mm jg">:</strong>stats_df$health_status, <br/>p.adj = "none")</span></pre><p id="46d1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此外，我们需要提取p值矩阵并保存到Excel文件中以备将来使用。</p><p id="325a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们通过简单地用<code class="fe mj mk ml mm b">broom::tidy</code>包装我们的<code class="fe mj mk ml mm b">ad_last</code> posthoc来做到这一点。</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="2ffb" class="mn lc jf mm b gy nd ne l nf ng"># tidy the post hoc<br/>tidy_ad_pairwise &lt;- broom::tidy(ad_pairwise)</span><span id="fb43" class="mn lc jf mm b gy nh ne l nf ng"># save to excel<br/>write.csv(tidy_ad_pairwise, "tidy_ad_pairwise.csv")</span></pre><figure class="mf mg mh mi gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nk"><img src="../Images/ae3aa8e22d7959d5f02f1dc6a2739c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mmbsKSAae7txTynYFLFg9g.png"/></div></div></figure><p id="25d9" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Tukey post-hoc比未调整的成对t-test更容易调用。请注意，我们已经将Tukey结果封装在<code class="fe mj mk ml mm b">broom::tidy</code>中，以保存为一个整洁的数据帧！TukeyHSD调用合并了ANOVA调用的结果，并且优于前面的方法。</p><p id="209c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面的代码可以被阅读，因为我们想要对我们的<code class="fe mj mk ml mm b">ad_aov </code> ANOVA的结果进行Tukey事后测试，该ANOVA跨越<code class="fe mj mk ml mm b">drug_treatment </code> by <code class="fe mj mk ml mm b">health_status</code>的<code class="fe mj mk ml mm b">sex </code>的交互。注意每个变量之间的<code class="fe mj mk ml mm b">‘sex:drug_treatment:health_status’</code>和<code class="fe mj mk ml mm b">:</code>的引号。这些是告诉R我们希望Tukey如何运行所必需的！一旦完成，R就对它运行tidy，使它成为一个好的数据帧，类似于我们之前的成对测试。然后我们可以将结果保存到Excel中！</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="e024" class="mn lc jf mm b gy nd ne l nf ng"># call and tidy the tukey posthoc<br/>tidy_ad_tukey &lt;- tidy(TukeyHSD(ad_aov, which =             'sex:drug_treatment:health_status'))</span><span id="277c" class="mn lc jf mm b gy nh ne l nf ng"># save to excel<br/>write.csv(tidy_tukey_ad, "tukey_ad.csv")</span></pre><p id="aff4" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">出版图</strong></p><p id="8a0d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我们已经生成了ANOVAs和post-hoc，并将其保存到Excel中进行存储，我们可以开始制作出版物级别的图表了！</p><p id="4f4a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">图表允许极端的定制，我在图表上添加的一些内容是个人的选择，因此我建议与你所在领域的导师或有经验的成员讨论。条形图在我的领域中无处不在，虽然我认为绘制成箱线图可以告诉我们更多的数据，但我首先会从条形图开始。</p><p id="5d2e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的目标是绘制平均值、标准误差，并指出其发生的意义。我将使用<code class="fe mj mk ml mm b">tribble </code>函数手工制作一个定制的数据帧，而不是依赖一个包来标记重要性。除了这样做还有其他选择，但是我可以很容易地控制使用这种方法会发生什么，而且数据帧包含的内容非常明显。下面的例子显示了三层结构的基本原理。我们用<code class="fe mj mk ml mm b">~</code>指定列，然后显式地写出我们在列的每一行中想要的内容。</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="f1e4" class="mn lc jf mm b gy nd ne l nf ng"><a class="ae la" href="https://rdrr.io/cran/tibble/man/tribble.html" rel="noopener ugc nofollow" target="_blank">tribble</a>(<br/>  ~colA, ~colB,<br/>  "a",   1,<br/>  "b",   2,<br/>  "c",   3<br/>)</span><span id="baf2" class="mn lc jf mm b gy nh ne l nf ng"># Output below<br/><em class="nl"># A tibble: 3 x 2</em><br/>   colA  colB<br/>  &lt;chr&gt; &lt;dbl&gt;<br/>1     a     1<br/>2     b     2<br/>3     <a class="ae la" href="https://rdrr.io/r/base/c.html" rel="noopener ugc nofollow" target="_blank">c</a>     3</span></pre><p id="83f0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是我们制作自定义数据帧的实际代码。</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="7067" class="mn lc jf mm b gy nd ne l nf ng"># make the dataframe with specific points of interest to add *<br/>sig_df &lt;- tribble(<br/>  ~drug_treatment, ~ health_status, ~sex, ~mmse_mean,<br/>  "Low dose", "Alzheimer's", "Male", 17,<br/>  "High Dose", "Alzheimer's", "Male", 25,<br/>  "Low dose", "Alzheimer's", "Female", 18, <br/>  "High Dose", "Alzheimer's", "Female", 24<br/>  )</span><span id="d067" class="mn lc jf mm b gy nh ne l nf ng"># convert the variables to factors again :)<br/>sig_df &lt;- sig_df %&gt;% <br/>  mutate(drug_treatment = factor(drug_treatment, <br/>               levels = c("Placebo", "Low dose", "High Dose")),<br/>         sex = factor(sex, <br/>               levels = c("Male", "Female")),<br/>         health_status = factor(health_status, <br/>               levels = c("Healthy", "Alzheimer's")))</span><span id="02d5" class="mn lc jf mm b gy nh ne l nf ng"># Output below<br/># A tibble: 4 x 4<br/>  drug_treatment health_status sex    mmse_mean<br/>  &lt;fctr&gt;         &lt;fctr&gt;        &lt;fctr&gt;     &lt;dbl&gt;<br/>1 Low dose       Alzheimer's   Male        17.0<br/>2 High Dose      Alzheimer's   Male        25.0<br/>3 Low dose       Alzheimer's   Female      18.0<br/>4 High Dose      Alzheimer's   Female      24.0</span></pre><p id="978f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们有了这个数据框，我们可以在一个<code class="fe mj mk ml mm b">geom_text</code>调用中使用它，用重要性标签来标记我们的条，如<code class="fe mj mk ml mm b">*</code>所示。</p><p id="28b3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是最终发布图在<code class="fe mj mk ml mm b">ggplot2</code>代码中的样子。你会注意到我把它赋给了<code class="fe mj mk ml mm b">g1</code>，而不是直接调用它。这意味着我将不得不调用<code class="fe mj mk ml mm b">g1 </code>来查看图表，但我现在可以保存它！为了理解我们正在做的事情，我像以前一样调用初始的<code class="fe mj mk ml mm b">ggplot </code>调用，但是添加了一个误差条层、一个条形图层、分为性别和健康状态的窗格、切换到另一个外观(<code class="fe mj mk ml mm b">theme_bw</code>)、手动设置颜色、通过主题进行微小调整、添加<code class="fe mj mk ml mm b">* </code>以指示重要性，最后在添加图形标题的同时更改轴标签。</p><pre class="mf mg mh mi gt mz mm na nb aw nc bi"><span id="c1fd" class="mn lc jf mm b gy nd ne l nf ng">g1 &lt;- ggplot(data = sum_df, <br/>       aes(x = drug_treatment, y = mmse_mean, fill = drug_treatment,  <br/>           group = drug_treatment)) +<br/>  geom_errorbar(aes(ymin = mmse_mean - mmse_se, <br/>                    ymax = mmse_mean + mmse_se), width = 0.5) +<br/>  geom_bar(color = "black", stat = "identity", width = 0.7) +<br/>  <br/>  facet_grid(sex~health_status) +<br/>  theme_bw() +<br/>  scale_fill_manual(values = c("white", "grey", "black")) +<br/>  theme(legend.position = "NULL",<br/>        legend.title = element_blank(),<br/>        axis.title = element_text(size = 20),<br/>        legend.background = element_blank(),<br/>        panel.grid.major = element_blank(), <br/>        panel.grid.minor = element_blank(),<br/>        axis.text = element_text(size = 12)) +<br/>  geom_text(data = sig_df, label = "*", size = 8) +<br/>  labs(x = "\nDrug Treatment", <br/>       y = "Cognitive Function (MMSE)\n",<br/>       caption = "\nFigure 1. Effect of novel drug treatment AD-x37 on cognitive function in healthy and demented elderly adults. \nn = 100/treatment group (total n = 600), * indicates significance at p &lt; 0.001")</span><span id="3709" class="mn lc jf mm b gy nh ne l nf ng">g1</span><span id="382f" class="mn lc jf mm b gy nh ne l nf ng"># save the graph!<br/>ggsave("ad_publication_graph.png", g1, height = 7, width = 8, units = "in")</span></pre><p id="bb3b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">保存是通过<code class="fe mj mk ml mm b">ggsave </code>函数完成的，在这里我们需要用" "，告诉R我们想要哪个ggplot对象(<code class="fe mj mk ml mm b">g1</code>)，并通过高度、宽度和单位指示大小。</p><p id="b3f0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">还有最后的图！</p><figure class="mf mg mh mi gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nm"><img src="../Images/0157e3ff9faf0e09d23d311f012f0bd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ndvAQX_OJNvMQsQvK5Eniw.png"/></div></div></figure><p id="6491" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我认为说你可以通过简单地重现我的例子来学习<code class="fe mj mk ml mm b">ggplot</code>是一种伤害。因此，我想为您指出数据科学教科书的<a class="ae la" href="http://r4ds.had.co.nz/data-visualisation.html" rel="noopener ugc nofollow" target="_blank"> R方向，以及</a><a class="ae la" href="http://moderndive.com/3-viz.html" rel="noopener ugc nofollow" target="_blank">现代潜水电子书</a>。这些免费的电子书有大量的信息，可能超出你今天需要完成的，但会在你未来的努力中为你服务。他们关于数据可视化的章节对R绘图入门非常有帮助！</p><h1 id="66ab" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">谢谢</strong></h1><figure class="mf mg mh mi gt is gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/7432f33c26981ad02d1a1661d739b306.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*mgrsZOR9u6opF1y2ZOCQbA.gif"/></div></figure><p id="79f7" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你已经做到了这一步，对你有好处！我希望这有所帮助，如果你有任何问题，我建议你通过#rstats标签联系twitter，或者你可以在Twitter上找到我@thomas_mock。</p><p id="3b41" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此外，<a class="no np ep" href="https://medium.com/u/56211c3483cf?source=post_page-----ccb91cc1177e--------------------------------" rel="noopener" target="_blank"> Jesse Maegan </a>有一个R for Data Science Slack频道，你可以在那里学习和提问。r工作室(潮汐看护者)在https://community.rstudio.com/举办他们自己的论坛。</p></div></div>    
</body>
</html>