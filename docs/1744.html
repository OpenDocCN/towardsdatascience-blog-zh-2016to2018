<html>
<head>
<title>L1 and L2 Regularization Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">L1 和 L2 正则化方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/l1-and-l2-regularization-methods-ce25e7fc831c?source=collection_archive---------0-----------------------#2017-10-13">https://towardsdatascience.com/l1-and-l2-regularization-methods-ce25e7fc831c?source=collection_archive---------0-----------------------#2017-10-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d0b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">机器学习</p><p id="f604" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的上一篇<a class="ae kl" href="https://medium.com/@anujanagpal/over-fitting-and-regularization-64d16100f45c" rel="noopener">文章</a>中，我介绍了监督学习模型中的正则化。在这篇文章中，让我们回顾一些广泛使用的正则化技术以及它们之间的主要区别。</p><p id="e7e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当数据集中有大量要素时，为了创建不太复杂(简洁)的模型，一些用于解决过度拟合和要素选择的正则化技术包括:</p><p id="6a67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.<strong class="jp ir"> L1 正规化</strong></p><p id="2ce8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<strong class="jp ir"> L2 正规化</strong></p><p id="0f83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用 L1 正则化技术的回归模型被称为<strong class="jp ir"> <em class="km">套索回归</em> </strong>，使用 L2 的模型被称为<strong class="jp ir"> <em class="km">岭回归</em> </strong>。</p><p id="69aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">这两者的主要区别在于刑罚期限。</em></p><p id="78e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">岭回归</strong>将系数的<em class="km">平方值</em>作为惩罚项添加到损失函数中。这里<em class="km">高亮显示的</em>部分代表 L2 正规化元素。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kn"><img src="../Images/dc21524afc5a37d4b6767d7f0d3a7839.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*jgWOhDiGjVp-NCSPa5abmg.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Cost function</figcaption></figure><p id="2776" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，如果λ是零，那么你可以想象我们回到了 OLS。然而，如果<em class="km">λ</em>非常大，那么它将增加太多的重量，并且将导致装配不足。话虽如此，如何选择λ很重要。这种技术可以很好地避免过度拟合的问题。</p><p id="1dc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Lasso 回归</strong>(最小绝对收缩和选择算子)将系数的<em class="km">大小的绝对值</em>作为惩罚项添加到损失函数中。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/04cba1ac4428e35428272e6581992129.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*4MlW1d3xszVAGuXiJ1U6Fg.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Cost function</figcaption></figure><p id="648f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，如果<em class="km">λ</em>为零，那么我们将得到 OLS，而非常大的值将使系数为零，因此它将欠拟合。</p><p id="70a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些技术之间的关键区别是套索将不太重要的特征的系数缩小到零，从而完全删除了一些特征。因此，在我们有大量特征的情况下，这对于<strong class="jp ir">特征选择</strong>很有用。</p><p id="df76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">交叉验证、逐步回归等处理过度拟合和执行特征选择的传统方法适用于小的特征集，但当我们处理大的特征集时，这些技术是很好的替代方法。</p></div></div>    
</body>
</html>