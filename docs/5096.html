<html>
<head>
<title>5 Reasons why you should use Cross-Validation in your Data Science Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么应该在数据科学项目中使用交叉验证的 5 个理由</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-reasons-why-you-should-use-cross-validation-in-your-data-science-project-8163311a1e79?source=collection_archive---------2-----------------------#2018-09-27">https://towardsdatascience.com/5-reasons-why-you-should-use-cross-validation-in-your-data-science-project-8163311a1e79?source=collection_archive---------2-----------------------#2018-09-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/80594237e68d343650b6c948e82271a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZUXDKEUf5BhWKFKlUX4Dmg.png"/></div></div></figure><p id="ebf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">交叉验证是数据科学家工具箱中的一个重要工具。它允许我们更好地利用我们的数据。在我向你展示我使用交叉验证的五个理由之前，我想简单回顾一下什么是交叉验证，并展示一些常用的策略。</p><p id="325d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们使用一些数据建立机器学习模型时，我们通常会将数据分成训练集和验证/测试集。训练集用于训练模型，验证/测试集用于在它从未见过的数据上验证它。经典的方法是做一个简单的 80%-20%的分割，有时有不同的值，如 70%-30%或 90%-10%。在交叉验证中，我们不止做一次分割。我们可以做 3 次、5 次、10 次或任何 K 次分割。这些分裂叫做折叠，我们可以用很多策略来创建这些折叠。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi kw"><img src="../Images/c82b35df53344ac7779a348313b359dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*55TfJMq5AkMKDg9VUa7ktA.jpeg"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Diagram of k-fold cross-validation with k=4.</figcaption></figure><p id="91cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">简单的 K-Folds </strong> —我们把数据分成 K 份，让我们用 K=3 作为一个玩具的例子。如果我们的数据集中有 3000 个实例，我们将它分成三部分，第 1 部分、第 2 部分和第 3 部分。然后，我们建立三个不同的模型，每个模型在两个部分进行训练，在第三部分进行测试。我们的第一个模型在第 1 部分和第 2 部分进行训练，在第 3 部分进行测试。我们的第二个模型在第一部分和第三部分进行训练，在第二部分进行测试，依此类推。</p><p id="5755" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">漏掉一个</strong>——这是交叉验证最极端的方式。对于数据集中的每个实例，我们使用所有其他实例构建一个模型，然后在选定的实例上测试它。</p><p id="65d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">分层交叉验证</strong>——当我们将数据分成多个文件夹时，我们希望确保每个文件夹都能够很好地代表整个数据。最基本的例子是，我们希望每个文件夹中不同类的比例相同。大多数情况下，这只是随机发生的，但有时，在复杂的数据集中，我们必须对每个折叠执行正确的分布。</p><p id="45e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是我认为你应该使用交叉验证的五个理由:</p><h2 id="69c5" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated"><strong class="ak"> 1。使用你所有的数据</strong></h2><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/b9f286ef80184c856817ce07d904f0c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tb6kEOEauE5l_ixeIuMPeA.jpeg"/></div></div></figure><p id="82b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们只有很少的数据时，将其分成训练集和测试集可能会留给我们一个很小的测试集。假设我们只有 100 个例子，如果我们做一个简单的 80-20 分割，我们将在测试集中得到 20 个例子。这是不够的。我们能在这个舞台上得到几乎所有的表演完全是因为运气。当我们有一个多类问题时，问题就更严重了。如果我们有 10 个类，只有 20 个例子，那么平均每个类只有 2 个例子。只在两个例子上测试任何东西都不能得出任何真正的结论。</p><p id="c1fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们在这种情况下使用交叉验证，我们建立了 K 个不同的模型，因此我们能够对我们的所有数据进行预测。对于每个实例，我们通过没有看到这个例子的模型进行预测，因此我们在测试集中得到 100 个例子。对于多类问题，我们平均每类得到 10 个例子，比只有 2 个要好得多。在我们评估了我们的学习算法(参见下面的#2)之后，我们现在可以在我们的所有数据上训练我们的模型，因为如果我们的 5 个模型使用不同的训练集具有相似的性能，我们假设通过在所有数据上训练它将获得相似的性能。</p><p id="8c23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过进行交叉验证，我们能够使用我们所有的 100 个例子进行训练和测试，同时评估我们的学习算法在以前从未见过的例子上。</p><h2 id="f435" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated"><strong class="ak"> 2。获取更多指标</strong></h2><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/f5fce4f05655e6d116f31bc2e35be92d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*frqALPACFJxI6ldU_z3JEg.jpeg"/></div></div></figure><p id="305b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如#1 中提到的，当我们使用我们的学习算法创建五个不同的模型，并在五个不同的测试集上进行测试时，我们可以对我们的算法性能更有信心。当我们对测试集进行单次评估时，我们只能得到一个结果。这个结果可能是因为偶然，也可能是因为某种原因设置的测试有偏差。通过训练五个(或十个)不同的模型，我们可以更好地理解正在发生的事情。假设我们训练了五个模型，并以精确度作为衡量标准。我们可能会在几种不同的情况下结束。最好的情况是，我们的准确度在所有折叠中都是相似的，比如 92.0、91.5、92.0、92.5 和 91.8。这意味着我们的算法(和我们的数据)是一致的，我们可以相信，通过在所有数据集上训练它并在生产中部署它，将会产生类似的性能。</p><p id="4ee0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，我们可能会在一个稍微不同的场景中结束，比如 92.0，<strong class="ka ir">44.0</strong>，91.5，92.5 和 91.8。这些结果看起来很奇怪。看起来我们的一个折叠来自不同的分布，我们必须回去并确保我们的数据是我们认为的那样。</p><p id="27dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最坏的情况是我们的结果有相当大的变化，比如 80、44、99、60 和 87。这里看起来我们的算法或我们的数据(或两者)不一致，这可能是我们的算法无法学习，或者我们的数据非常复杂。</p><p id="f86f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过使用交叉验证，我们能够获得更多的指标，并得出关于我们的算法和数据的重要结论。</p><h2 id="12a8" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated"><strong class="ak"> 3。使用模型堆叠</strong></h2><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/8610b86e4e6f836b5c148c33a251cc23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oiQZerSdolaf0yuMl04Viw.jpeg"/></div></div></figure><p id="0e47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有时我们想要(或者不得不)建立一个模型管道来解决一些问题。以神经网络为例。我们可以创建许多层。每个层可以使用预览层输出，并学习我们的数据的新表示，因此最终，它将能够产生良好的预测。我们能够训练这些不同的层，因为我们使用反向传播算法。每一层计算其误差，并将其传递回前一层。</p><p id="8a69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们做一些类似的事情，但不使用神经网络时，我们不能用同样的方式训练它，因为并不总是有明确的“错误”(或导数)可以传递回来。</p><p id="38ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，我们可以创建一个随机的森林模型，它可以为我们预测一些事情，然后，我们想做一个线性回归，它将依赖于以前的预测并产生一些实数。</p><p id="8a27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的关键部分是我们的第二个模型必须学习我们的第一个模型<strong class="ka ir">的<strong class="ka ir">预测</strong>。</strong>这里的最佳解决方案是为每个模型使用两个不同的数据集。我们在数据集 a 上训练我们的随机森林。然后我们使用数据集 B 来使用它进行预测。然后，我们使用数据集 B 的预测来训练我们的第二个模型(逻辑回归)，最后，我们使用数据集 C 来评估我们的完整解决方案。我们使用第一个模型进行预测，将它们传递给我们的第二个模型，然后将其与实际情况进行比较。</p><p id="ec68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们的数据有限时(大多数情况下)，我们无法真正做到这一点。此外，我们不能在同一个数据集上训练我们的两个模型，因为这样一来，我们的第二个模型就会学习第一个模型已经看到的预测。这些可能会过拟合或至少有更好的结果比一个不同的设置。这意味着我们的第二个算法不是根据它将被测试的内容来训练的。这可能会在我们的最终评估中导致难以理解的不同效果。</p><p id="aa41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过使用交叉验证，我们可以用之前描述的相同方式对数据集进行预测，因此我们第二个模型的输入将是对我们第一个模型从未见过的数据的真实预测。</p><h2 id="426d" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated"><strong class="ak"> 4。处理相关/分组数据</strong></h2><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/3b7bb857bca05562e2f24b2f694b9165.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-6r2IQZ2iBGI5uBB3voDcA.jpeg"/></div></div></figure><p id="d490" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们对数据进行随机训练测试分割时，我们假设我们的例子是独立的。这意味着，通过了解/看到一些实例不会帮助我们理解其他实例。然而，情况并非总是如此。</p><p id="98f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑一个语音识别系统。我们的数据可能包括不同的发言者说不同的话。让我们看看语音数字识别。在<a class="ae lz" href="https://github.com/Jakobovski/free-spoken-digit-dataset" rel="noopener ugc nofollow" target="_blank">这个数据集</a>中，例如，有 3 个发言者和 1500 个记录(每个发言者 500 个)。如果我们进行随机分割，我们的训练集和测试集将共享同一个说话者说的相同的话！当然，这将提高我们的算法性能，但一旦在新的扬声器上测试，我们的结果会更差。</p><p id="17c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正确的做法是拆分扬声器，即使用两个扬声器进行训练，第三个用于测试。然而，我们将只在一个扬声器上测试我们的算法。这是不够的。我们需要知道我们的算法在不同的扬声器上表现如何。</p><p id="2323" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以在说话者层面使用交叉验证。我们将训练 3 个模型，每次使用一个扬声器进行测试，另外两个用于训练。这样，我们将能够更好地评估我们的算法(如上所述)，并最终在所有扬声器上建立我们的模型。</p><h2 id="1ce0" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated"><strong class="ak"> 5。参数微调</strong></h2><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/627e078ab083ce7935400b7b97bb9b3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lYslxtibJZka3rQN8ktM0A.jpeg"/></div></div></figure><p id="ba01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是进行交叉验证的最常见和最明显的原因之一。大多数学习算法需要一些参数调整。它可以是梯度增强分类器中的树的数量、神经网络中的隐藏层大小或激活函数、SVM 中的核的类型等等。我们想为我们的问题找到最好的参数。我们通过尝试不同的价值观并选择最好的来做到这一点。有许多方法可以做到这一点。它可以是手动搜索、网格搜索或一些更复杂的优化。然而，在所有这些情况下，我们不能在我们的训练测试中这样做，当然也不能在我们的测试集中这样做。我们必须使用第三个集合，一个验证集合。</p><p id="a9c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过将我们的数据分成三组而不是两组，我们将解决我们之前谈到的所有相同的问题，特别是如果我们没有很多数据的话。通过进行交叉验证，我们能够使用一组数据完成所有这些步骤。</p><h2 id="5d3b" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated"><strong class="ak">结论</strong></h2><p id="01ce" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">交叉验证是一个非常强大的工具。它帮助我们更好地使用我们的数据，并为我们提供更多关于算法性能的信息。在复杂的机器学习模型中，有时很容易不够重视，并且在管道的不同步骤中使用相同的数据。在大多数情况下，这可能导致良好但不真实的性能，或者在其他情况下引入奇怪的副作用。我们必须注意，我们对自己的模型充满信心。当我们处理数据科学项目中的重大挑战时，交叉验证会对我们有所帮助。</p><p id="1823" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想了解更多关于数据科学管道中可能出现的不同陷阱，欢迎你阅读我关于<a class="ae lz" rel="noopener" target="_blank" href="/how-to-lie-with-data-science-5090f3891d9c">如何与数据科学撒谎</a>的帖子</p><p id="26b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想阅读做某事的其他 5 个理由，欢迎阅读我的文章<a class="ae lz" rel="noopener" target="_blank" href="/5-reasons-logistic-regression-should-be-the-first-thing-you-learn-when-become-a-data-scientist-fcaae46605c4"> 5 个理由“逻辑回归”应该是成为数据科学家的第一件事</a></p></div></div>    
</body>
</html>