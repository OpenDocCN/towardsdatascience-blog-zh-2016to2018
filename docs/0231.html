<html>
<head>
<title>A study of Classification Problems using Logistic Regression and an insight to the admissions problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用逻辑回归研究分类问题及对招生问题的理解</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-study-of-classification-problems-using-logistic-regression-and-an-insight-to-the-admissions-ec69ddf93f36?source=collection_archive---------0-----------------------#2017-04-03">https://towardsdatascience.com/a-study-of-classification-problems-using-logistic-regression-and-an-insight-to-the-admissions-ec69ddf93f36?source=collection_archive---------0-----------------------#2017-04-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="4a2d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">摘要:</strong></h1><p id="3d40" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我们的世界里，很多经常遇到的问题都是分类问题。我们经常在确定的价值观和对事物的僵化选择之间感到困惑。在本文中，我们将讨论一种使用机器学习有效解决简单分类问题的算法。此外，我们将分析一个假设的二元类问题，涉及基于入学考试成绩和本科成绩的研究生成绩。</p><h1 id="cd49" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">简介:</h1><p id="d79f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">监督学习是一种机器学习技术，其中我们将输入与给定数据集中的目标相关联。对于我们的最终产出，我们已经有了明确的直觉。我们大致有两种类型的监督学习问题，“回归”和“分类”。我们将在本文中讨论分类问题。分类问题是我们将输入数据分成不同类别的问题。所谓离散，我们指的是单独的类。<br/>例如:想象一个基于研究生院招生的假设数据集，有三列。第一列是入学考试分数(<strong class="kn ir">输入X1 </strong>)，第二列是UG考试(<strong class="kn ir">输入X2 </strong>)，第三列是结果，录取/拒绝(<strong class="kn ir">目标Y </strong>)。本文中使用的数据集片段如下所示。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/37b61beacce44d2f64d30e9315a8e938.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*eKNr7D_ZfxgmMOadT9qoaA.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Entrance Exam Score, UG Score, Outcome(Binary)</figcaption></figure><p id="5cde" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">我们将目标类Y定义为二进制类。因此，我们将集合定义为，<strong class="kn ir"> Y={0，1} </strong>其中集合元素为:</p><p id="1f97" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated"><strong class="kn ir"> 0表示拒绝(否定类)，<br/> 1表示接受(肯定类)</strong></p><p id="6356" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">因此，这是一个分类问题。我们可以根据录取过程的结果将数据集分为两类。通常将数据集分解为离散类别的算法被定义为<em class="ma">分类器</em>。在这个例子中，因变量是<em class="ma">二分的</em>。在这种情况下，我们更喜欢逻辑回归。我们可以在MATLAB/Octave中绘制数据集的散点图，并观察下图:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/f88846d8094cfbc2b0e2f4979d9a1731.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*OrCLHXg0PKRfYav4JVLKKA.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Scatter plot of our dataset</figcaption></figure><h1 id="ba71" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">涉及的激活功能和映射功能:</h1><p id="ec7b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">首先，考虑映射我们的输出和输入的函数，因此在计算平方误差函数时用于计算预测。让我们称那个函数为映射函数或假设函数，<strong class="kn ir"> h(X) </strong>。“假说”一词是出于各种历史原因而创造的。此外，术语“逻辑”是乙状结肠的同义词。因此，我们在该算法中使用具有“S形曲线”的Sigmoid激活函数。通过我们的编程功能生成的曲线如下所示。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mc"><img src="../Images/0f0e7a285baf78349c6909e058e2281a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ichW46MbHPkvmuXMocHf9A.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Sigmoid Activation Function</figcaption></figure><p id="1ec6" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">数学上，我们将函数定义为:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/ed7129ad7ea94adea14f49e0836eacec.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*rIcxY0VM156U9UpFdRVC8w.png"/></div></figure><p id="c2ec" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">Sigmoid函数还有其他几个数学特性。比如我们可以用函数本身来表示函数的导数。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/470ce9705911b8eaea62eba2ac69bc93.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*KN77REKVWMnsDUGN7fgpjw.png"/></div></figure><p id="ab76" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">这种Sigmoid/Logistic函数简化了优化过程中涉及的数学运算，是小规模分类问题的理想选择。使用Sigmoid函数，我们可以有效地限制我们的范围，以便它有效地表示概率。我们可以用数学方法将假设/映射函数表示为:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/6a6ad61c75416412ef54be8a31de0f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/format:webp/1*svLDc1TyGqAI177fV7mt0Q.png"/></div></figure><p id="212c" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">这本质上是一个非常基本的线性成本函数，只是它与一个sigmoid函数相结合。</p><p id="d449" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">我们的假设函数给出了任何给定事件发生概率的数值。我们可以将映射函数的范围定义为:<strong class="kn ir"> 0≤h(X)≤1 </strong>。</p><h1 id="2cfb" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">成本函数直觉:</strong></h1><p id="9f97" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">成本函数是一种数学函数，用于估计假设与输入集和目标集的匹配程度。从图形上看，我们知道一个更好的成本函数会更好地拟合我们给定的数据。它通常表示为参数的函数。在这种情况下，我们称之为<strong class="kn ir"> J(θ) </strong>。<br/>在这个算法中，我们使用了一个<strong class="kn ir">对数代价函数</strong>，它是从<em class="ma">最大似然估计(M.S.E) </em>的原理中推导出来的，以确保我们得到的作为输出的函数是一个<strong class="kn ir">凸函数。</strong></p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mk"><img src="../Images/7e38ff69e111c870efa5624f6e73f229.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*zDG1C8af7a4-n-CVfj40tA.png"/></div></div></figure><p id="8f89" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">一个简单的直觉是认为代价函数中涉及的对数大致反作用于所涉及的<strong class="kn ir"> exp </strong>。</p><p id="db13" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">正如克里斯托弗·毕晓普在他的著作中指出的那样，</p><blockquote class="ml mm mn"><p id="3de6" class="kl km ma kn b ko lv kq kr ks lw ku kv mo lx ky kz mp ly lc ld mq lz lg lh li ij bi translated">“当我们假设我们的阳性和阴性训练样本来自两个不同的高斯聚类(不同的位置，但相同的协方差)时，我们可以开发一个完美的分类器。”</p></blockquote><p id="4418" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">凸函数中的优化更容易，因为在曲线中更容易达到最小值并获得参数θ的最佳值。<br/>然而，我们观察到，在我们对J(θ)进行微分之后，我们得到了与线性回归方法相同的梯度函数。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/c18f69bce14b6cbe48333be9ce43b343.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*77TY8V8hyEfsBVhltblcHQ.png"/></div></figure><p id="928f" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">然而，梯度值不是一回事，因为我们拥有不同的线性和逻辑回归映射函数。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/09ad512240c3140c7c7fffa8cc88f239.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*350fgnH2uOPN0SprzOwXGw.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Prototype code for a Cost Function</figcaption></figure><p id="7fb2" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">因此，使用参数向量θ和成本函数J(θ)，我们可以应用任何给定的优化算法来实现简单的决策边界。</p><h1 id="a4c0" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">优化参数:</strong></h1><p id="ae58" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在，如果我们想要拟合参数(在本例中为θ)，我们需要应用最小化(优化)算法。<br/>我们可以采取简单的小步骤<em class="ma"> ( </em> <strong class="kn ir"> <em class="ma">)限制(θ)&gt;0</em></strong><em class="ma">)</em>达到我们给定的最小值，通常称为<strong class="kn ir">梯度下降</strong>，或者采用高级优化算法，如<strong class="kn ir"><em class="ma">【BFGS】</em></strong>或<strong class="kn ir"> <em class="ma">有限内存BFGS </em> </strong> <em class="ma">。<br/> </em>高级优化方法是<strong class="kn ir"> <em class="ma">拟牛顿</em> </strong>方法的一部分，我们在其中计算<strong class="kn ir">黑森矩阵</strong>的优化值。L-BFGS非常类似于BFGS，除了它有更好的内存优化和更可扩展的算法。此外，当与梯度下降并置时，高级算法不容易出现反复试验的情况，因为不需要选择任意值的<em class="ma">α(</em>学习率)来获得更优的结果。Hessian矩阵的数学符号如下所示:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/310d88c1734b815033ac896b91cb84bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*qnZ3oYNHLFTobQhBwFGPmg.png"/></div></figure><p id="4ba8" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">通常，我们通过库应用高级优化。C++中用于应用高级优化算法的一个特殊库是<a class="ae mu" href="http://eigen.tuxfamily.org/index.php?title=Main_Page" rel="noopener ugc nofollow" target="_blank"> Eigen C++库</a>。</p><p id="e097" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">然而，不同的库可能有不同的时间复杂度。不明智地选择一个库可能会降低我们算法的整体性能，并对我们的整个程序产生严重的影响。</p><p id="dc19" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">因此，在使用优化方法有效地最小化我们的参数之后，我们可以绘制决策边界。因此，我们使用MATLAB的通用<em class="ma">“fmin unc”</em>来应用高级优化。在应用以θ和梯度值为参数的函数后，我们可以如下绘制决策边界:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/a982ec55e7a7819528a9fd9de75e66e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*MN6bdduQeuUCv9gvqaKxqQ.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Decision Boundary separating the data. In this case, a linear boundary fits better.</figcaption></figure><h1 id="1d21" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">过度拟合曲线的概念:</h1><p id="0e69" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">过度拟合基本上是一种情况，其中我们的学习假设设法拟合数据集中的所有点，并产生很少或没有错误，但有一个重大缺陷。我们的算法<strong class="kn ir">无法预测</strong>新测试实例<strong class="kn ir">的离散类。<br/>这个问题的解决方法:<br/> </strong>我们可以惩罚某些参数(θ)来修复这个。我们在优化算法中增加了一个调节参数(λ),可以优化曲线。这个技术叫做<em class="ma">正则化</em>。因此，我们修改我们的成本函数和优化算法来惩罚参数并获得最佳拟合。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/5b2fe06c6e2191c8a573aaa1bff49548.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*srxDyAIgZBi0qks-JQxSvw.png"/></div></figure><h1 id="9d5c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">适合度:</h1><p id="445f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在<strong class="kn ir">拟合优度(G.O.F) </strong>中，我们主要检查一个给定的模型是否被正确指定，以及它与统计观察值的拟合程度。通常有两种常用的方法来估计拟合优度。一个测试是著名的皮尔逊卡方测试，另一个测试是<em class="ma">霍斯默和莱梅休测试</em>。简单明了的<strong class="kn ir">皮尔逊卡方</strong>检验是一种更简单的技术，因此我们将讨论检验的直觉。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/8c853312e50889043ca8b4af26c2034c.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*IHuQCSs1fpVVczJKyVBtBA.png"/></div></figure><p id="5c2a" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">卡方(χ2)对于从给定数据集计算统计参数具有很高的数学准确性。此外，这个测试是渐近真实的。它的主要作用是计算数据集中每个观测值的频率。<br/>因此，我们可以通过比较p值和分布值来计算统计p值。<br/>我们还可以使用各种其他测试，如<strong class="kn ir"> Stukel测试或信息矩阵</strong>测试来有效地测量逻辑回归的拟合度。</p><p id="185f" class="pw-post-body-paragraph kl km iq kn b ko lv kq kr ks lw ku kv kw lx ky kz la ly lc ld le lz lg lh li ij bi translated">由于这是我关于机器学习的第一篇文章，我讨论了该领域的一个基本概念。在下一篇文章中，我将使用基于U64 Bitboard的国际象棋引擎来讨论Alpha Beta修剪。</p><h1 id="1fdb" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">参考资料:</h1><ol class=""><li id="cfa9" class="my mz iq kn b ko kp ks kt kw na la nb le nc li nd ne nf ng bi translated">W.李少华，刘，“利用加权逻辑回归的正例与非正例学习”，大学，2003年</li><li id="fbff" class="my mz iq kn b ko nh ks ni kw nj la nk le nl li nd ne nf ng bi translated">刘，和J .诺塞达尔，“关于大规模优化的有限记忆BFGS方法”-数学规划，1989-施普林格</li><li id="f033" class="my mz iq kn b ko nh ks ni kw nj la nk le nl li nd ne nf ng bi translated">马·巴比亚克，“所见不一定是所得:回归型模型中过度拟合的非技术性简要介绍”，《心身医学》，2004年，《</li><li id="d6a8" class="my mz iq kn b ko nh ks ni kw nj la nk le nl li nd ne nf ng bi translated">Andrew NG，“机器学习，斯坦福大学课程”。</li><li id="608d" class="my mz iq kn b ko nh ks ni kw nj la nk le nl li nd ne nf ng bi translated">Paul D. Allison，“适合逻辑回归的度量”，-SAS全球论坛，DC华盛顿州，2014年-statisticalhorizons.com</li><li id="4475" class="my mz iq kn b ko nh ks ni kw nj la nk le nl li nd ne nf ng bi translated">Christopher M Bishop，“模式识别和机器学习”。</li></ol></div></div>    
</body>
</html>