<html>
<head>
<title>Pandas Series: A Lightweight Intro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫系列:轻量级介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pandas-series-a-lightweight-intro-b7963a0d62a2?source=collection_archive---------2-----------------------#2018-10-06">https://towardsdatascience.com/pandas-series-a-lightweight-intro-b7963a0d62a2?source=collection_archive---------2-----------------------#2018-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/cd3653097384a3320ded804b1fdef3f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MrLP2CcEPygu_zffnQwpWw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Pandas Series: A Lightweight Intro</figcaption></figure><div class=""/><blockquote class="kc"><p id="ada2" class="kd ke jf bd kf kg kh ki kj kk kl km dk translated">Pandas 是一个开源的、BSD 许可的库，为 Python 编程语言提供了高性能、易于使用的数据结构和数据分析工具。</p></blockquote></div><div class="ab cl ko kp hu kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="ij ik il im in"><p id="8692" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">Pandas 提供的数据结构有两种不同的类型</p><ol class=""><li id="4981" class="ls lt jf kx b ky kz lc ld lg lu lk lv lo lw km lx ly lz ma bi translated"><strong class="kx jg"> <em class="mb">熊猫数据帧&amp; </em> </strong></li><li id="f4c9" class="ls lt jf kx b ky mc lc md lg me lk mf lo mg km lx ly lz ma bi translated"><strong class="kx jg"> <em class="mb">熊猫系列</em> </strong></li></ol><p id="67ed" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">本帖我们就来看看<strong class="kx jg"> <em class="mb">熊猫系列</em> </strong>。</p><p id="9514" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated"><strong class="kx jg"> <em class="mb">注:为了更好地理解熊猫系列</em></strong><strong class="kx jg"><em class="mb">之前，我强烈推荐阅读我之前在</em> </strong> <a class="ae mh" rel="noopener" target="_blank" href="/pandas-dataframe-a-lightweight-intro-680e3a212b96"> <strong class="kx jg"> <em class="mb">上的帖子</em></strong></a></p><h2 id="7700" class="mi mj jf bd mk ml mm dn mn mo mp dp mq lg mr ms mt lk mu mv mw lo mx my mz na bi translated">什么是系列？</h2><p id="33de" class="pw-post-body-paragraph kv kw jf kx b ky nb la lb lc nc le lf lg nd li lj lk ne lm ln lo nf lq lr km ij bi translated">从技术上来说，Pandas Series 是一个一维标签数组，能够保存任何数据类型。</p><p id="4f6a" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">通俗地说，熊猫系列不过是 excel 表中的一列。如下图所示，带有<strong class="kx jg">名称、年龄和职务</strong>的列代表一个系列</p><figure class="nh ni nj nk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ng"><img src="../Images/6a62f6bb5cc7b87e46478165d308ec2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3h2YForpOw5O_MjHgMOBsQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Pandas Series</figcaption></figure><blockquote class="kc"><p id="dfed" class="kd ke jf bd kf kg kh ki kj kk kl km dk translated"><em class="kn">因此，根据 Pandas 数据结构，一个系列代表内存中的一个单独的列，它或者是独立的，或者属于 Pandas 数据帧</em>。</p></blockquote><blockquote class="nl nm nn"><p id="7fd9" class="kv kw mb kx b ky no la lb lc np le lf nq nr li lj ns nt lm ln nu nv lq lr km ij bi translated">注意:一个系列可以有自己独立的存在，而不是数据帧的一部分。</p></blockquote><h2 id="9a8a" class="mi mj jf bd mk ml mm dn mn mo mp dp mq lg mr ms mt lk mu mv mw lo mx my mz na bi translated">如何打造系列？</h2><p id="36de" class="pw-post-body-paragraph kv kw jf kx b ky nb la lb lc nc le lf lg nd li lj lk ne lm ln lo nf lq lr km ij bi translated">Pandas 系列可以从 Python 列表或 NumPy 数组中创建。必须记住，与 Python 列表不同，一个系列将总是包含相同类型的数据。这使得 NumPy 数组成为创建熊猫系列的更好的候选对象</p><p id="9647" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">下面是我们如何使用以上两者来创建一个熊猫系列</p><pre class="nh ni nj nk gt nw nx ny nz aw oa bi"><span id="b67c" class="mi mj jf nx b gy ob oc l od oe">series_list = pd.Series([1,2,3,4,5,6])<br/>series_np = pd.Series(np.array([10,20,30,40,50,60]))</span></pre><p id="3a8e" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">这是它们的样子</p><figure class="nh ni nj nk gt is gh gi paragraph-image"><div class="gh gi of"><img src="../Images/5186f61eab4764b6cd7fa3f234f099fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*edGv4SXNAsInX1AemF3nRw.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Result of → series_list = pd.Series([1,2,3,4,5,6])</figcaption></figure><figure class="nh ni nj nk gt is gh gi paragraph-image"><div class="gh gi og"><img src="../Images/20f29a440d556c2b3eddcca71c314ccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*4rfLAxVZRnzyjeD1b02j4g.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Result of → series_np = pd.Series(np.array([10,20,30,40,50,60]))</figcaption></figure><p id="c709" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">正如在创建<a class="ae mh" rel="noopener" target="_blank" href="/pandas-dataframe-a-lightweight-intro-680e3a212b96">熊猫数据帧</a>时一样，该系列也默认生成行索引号，这是一个从‘0’开始的递增数字序列</p><p id="2735" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">正如您可能已经猜到的，在创建一个系列时，有可能拥有我们自己的行索引值。我们只需要传递索引参数，这些参数接受相同类型的列表或 NumPy 数组。</p><p id="4504" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">以下示例使用了 NumPy 生成的序列</p><pre class="nh ni nj nk gt nw nx ny nz aw oa bi"><span id="16af" class="mi mj jf nx b gy ob oc l od oe">series_index = pd.Series(<br/>      np.array([10,20,30,40,50,60]), <br/>      index=np.arange(0,12,2) <br/>)</span></pre><figure class="nh ni nj nk gt is gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/af00cc33ad42dc5372a4fa30d67721a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*lCvf3-Yko7tBJxiwW8Anmw.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Result of → series_index = pd.Series(np.array([10,20,30,40,50,60]), index=np.arange(0,12,2) )</figcaption></figure><p id="8d2b" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">下面的示例使用字符串作为行索引</p><pre class="nh ni nj nk gt nw nx ny nz aw oa bi"><span id="30fc" class="mi mj jf nx b gy ob oc l od oe">series_index = pd.Series(<br/>        np.array([10,20,30,40,50,60]), <br/>        index=['a', 'b', 'c', 'd', 'e', 'f' ] <br/>)</span></pre><figure class="nh ni nj nk gt is gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/72612d297089dc5b5afe815864e65e31.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*66QzwDNvxhyUzqmF4XWZQg.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Result of → series_index = pd.Series(np.array([10,20,30,40,50,60]), index=[‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’ ] )</figcaption></figure><p id="1379" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">我们可以使用序列的行索引作为</p><pre class="nh ni nj nk gt nw nx ny nz aw oa bi"><span id="3b75" class="mi mj jf nx b gy ob oc l od oe">series_index.index</span></pre><p id="6e31" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">它返回一个 NumPy 数组，而不管我们在创建序列时是传递了一个列表还是一个 NumPy 数组</p></div><div class="ab cl ko kp hu kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="ij ik il im in"><h2 id="be7c" class="mi mj jf bd mk ml mm dn mn mo mp dp mq lg mr ms mt lk mu mv mw lo mx my mz na bi translated">从 python 字典创建熊猫系列</h2><p id="9c75" class="pw-post-body-paragraph kv kw jf kx b ky nb la lb lc nc le lf lg nd li lj lk ne lm ln lo nf lq lr km ij bi translated">正如我们在创建<a class="ae mh" rel="noopener" target="_blank" href="/pandas-dataframe-a-lightweight-intro-680e3a212b96"> Pandas DataFrame </a>的过程中所看到的，从 python 字典创建 DataFrame 非常容易，因为<strong class="kx jg">键</strong>映射到列名，而<strong class="kx jg">值</strong>对应于列值列表。</p><blockquote class="nl nm nn"><p id="0c56" class="kv kw mb kx b ky kz la lb lc ld le lf nq lh li lj ns ll lm ln nu lp lq lr km ij bi translated"><strong class="kx jg">那么在创作熊猫系列的时候是如何贴图的呢？</strong></p></blockquote><p id="840a" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">如果我们从 python 字典创建一个序列，那么<strong class="kx jg">键</strong>成为行索引，而<strong class="kx jg">值</strong>成为该行索引的值。</p><p id="0173" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">作为一个例子，让我们看看一个非常简单的只有一个键值对的字典会发生什么</p><pre class="nh ni nj nk gt nw nx ny nz aw oa bi"><span id="c5cb" class="mi mj jf nx b gy ob oc l od oe">t_dict = {'a' : 1, 'b': 2, 'c':3}</span><span id="a2c0" class="mi mj jf nx b gy oj oc l od oe"># Creating a Series out of above dict<br/>series_dict = pd.Series(t_dict)</span></pre><p id="7182" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">这是输出的样子</p><figure class="nh ni nj nk gt is gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/10cb2163453044efc051d1c7291e3681.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*Lcy1_Xp1T552g2K0ObMxiA.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Result of → Code block Above</figcaption></figure><p id="25c8" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">如果字典中的值包含一个项目列表，情况不会改变。列表项仍然是单行索引的一部分，如下例所示</p><pre class="nh ni nj nk gt nw nx ny nz aw oa bi"><span id="d7dc" class="mi mj jf nx b gy ob oc l od oe">t_dict = {'a' : [1,2,3], 'b': [4,5], 'c':6, 'd': "Hello World"}</span><span id="bd1b" class="mi mj jf nx b gy oj oc l od oe"># Creating a Series out of above dict<br/>series_dict = pd.Series(t_dict)</span></pre><figure class="nh ni nj nk gt is gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/b5869b6034555d0fd78247c64a49676a.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*fRO5_-5xzJoYQQqPMz5xfg.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Result of → series_dict = pd.Series(t_dict)</figcaption></figure></div><div class="ab cl ko kp hu kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="ij ik il im in"><h2 id="0277" class="mi mj jf bd mk ml mm dn mn mo mp dp mq lg mr ms mt lk mu mv mw lo mx my mz na bi translated">从熊猫数据帧中获取序列</h2><p id="7b54" class="pw-post-body-paragraph kv kw jf kx b ky nb la lb lc nc le lf lg nd li lj lk ne lm ln lo nf lq lr km ij bi translated">虽然 Pandas Series 本身对于进行数据分析非常有用，并提供了许多有用的帮助函数，但是大多数时候，分析需求将迫使我们一起使用 DataFrame 和 Series。</p><p id="8f3b" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">让我们先创建一个熊猫数据帧，就像我们在<a class="ae mh" rel="noopener" target="_blank" href="/pandas-dataframe-a-lightweight-intro-680e3a212b96">这里</a>创建的一样</p><pre class="nh ni nj nk gt nw nx ny nz aw oa bi"><span id="f495" class="mi mj jf nx b gy ob oc l od oe">my_dict = { <br/>'name' : ["a", "b", "c", "d", "e"],<br/>'age' : [10,20, 30, 40, 50],<br/>'designation': ["CEO", "VP", "SVP", "AM", "DEV"]<br/>}</span><span id="057b" class="mi mj jf nx b gy oj oc l od oe">df = pd.DataFrame( my_dict, <br/>index = [<br/>"First -&gt; ",<br/>"Second -&gt; ", <br/>"Third -&gt; ", <br/>"Fourth -&gt; ", <br/>"Fifth -&gt; "])</span></pre><p id="7c56" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">下面是结果数据帧的样子</p><figure class="nh ni nj nk gt is gh gi paragraph-image"><div class="gh gi om"><img src="../Images/137054061c3f135ed44e0ba7d81b3810.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*7ehkFmbzBXwD2pPyDr-gnw.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Result of → DataFrame creation from dictionary</figcaption></figure><p id="11d1" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">DataFrame 提供了两种访问列的方法，即使用字典语法<code class="fe on oo op nx b">df['column_name']</code>或<code class="fe on oo op nx b">df.column_name</code>。每次我们使用这些表示得到一个列，我们得到一个熊猫系列。</p><p id="b233" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">在上面的例子中，我们可以通过访问列来获得序列(即一个单独的列)</p><pre class="nh ni nj nk gt nw nx ny nz aw oa bi"><span id="8193" class="mi mj jf nx b gy ob oc l od oe">series_name = df.name<br/>series_age = df.age<br/>series_designation = df.designation</span></pre><figure class="nh ni nj nk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oq"><img src="../Images/119f43690b96a1a8d7d08000820866dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*5dvAHVd77CkJouvEAW-_iQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">series_name</figcaption></figure><figure class="nh ni nj nk gt is gh gi paragraph-image"><div class="gh gi or"><img src="../Images/567d802a811de67bee974ab86356bdd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*qTzpDEJZWo6bqfYHyH_1BQ.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Series_age</figcaption></figure><figure class="nh ni nj nk gt is gh gi paragraph-image"><div class="gh gi os"><img src="../Images/3cc31a609332dc27416ee581e34b035c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*kKf-Mmd2H_5gRFWtpmp3Xg.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">series_designation</figcaption></figure></div><div class="ab cl ko kp hu kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="ij ik il im in"><h2 id="dd36" class="mi mj jf bd mk ml mm dn mn mo mp dp mq lg mr ms mt lk mu mv mw lo mx my mz na bi translated">通过遍历数据帧的列来获取序列</h2><blockquote class="nl nm nn"><p id="1cde" class="kv kw mb kx b ky kz la lb lc ld le lf nq lh li lj ns ll lm ln nu lp lq lr km ij bi translated">如果我们不知道列的名称会怎么样？</p></blockquote><p id="cdf5" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">Pandas DataFrame 是可迭代的，我们可以遍历各个列来获得序列</p><pre class="nh ni nj nk gt nw nx ny nz aw oa bi"><span id="aa0f" class="mi mj jf nx b gy ob oc l od oe">series_col = []<br/>for col_name in df.columns:<br/>    series_col.append(df[col_name])</span></pre></div><div class="ab cl ko kp hu kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="ij ik il im in"><h2 id="1b82" class="mi mj jf bd mk ml mm dn mn mo mp dp mq lg mr ms mt lk mu mv mw lo mx my mz na bi translated">使用系列创建数据框(独立或组合)</h2><p id="63f3" class="pw-post-body-paragraph kv kw jf kx b ky nb la lb lc nc le lf lg nd li lj lk ne lm ln lo nf lq lr km ij bi translated">熊猫数据帧只不过是一个系列(1+)的集合。我们可以通过使用单个系列或组合多个系列来生成数据帧</p><p id="d0a9" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">例如，让我们通过组合<code class="fe on oo op nx b">series_name</code>和<code class="fe on oo op nx b">series_age</code>生成一个数据帧</p><pre class="nh ni nj nk gt nw nx ny nz aw oa bi"><span id="b439" class="mi mj jf nx b gy ob oc l od oe">df_from_series = pd.DataFrame([series_name, series_age])</span></pre><p id="0025" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">令您惊讶的是，生成的数据帧看起来应该是</p><figure class="nh ni nj nk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ot"><img src="../Images/70f1bd99ceba9b1bf32ba16ea1b4ead1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SIrSsTK-p4piXfkUWy5MkQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">df_from_series</figcaption></figure><p id="e60f" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">是的，序列的行索引成为列，而列成为行索引值。你可以认为这类似于矩阵的转置。即使我们提供单个系列来创建数据帧，也是如此</p><pre class="nh ni nj nk gt nw nx ny nz aw oa bi"><span id="ae96" class="mi mj jf nx b gy ob oc l od oe">df_from_series_single = pd.DataFrame([series_name])</span></pre><figure class="nh ni nj nk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ou"><img src="../Images/bc158b0cc4db83ad21ca4e7edd660c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OxUw4QYRd4nn9jzBIQHZXA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">df_from_series_single</figcaption></figure><p id="2df5" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">然而，当我们从序列中移除列表/数组符号时，这种情况不会发生。例如</p><pre class="nh ni nj nk gt nw nx ny nz aw oa bi"><span id="c3e7" class="mi mj jf nx b gy ob oc l od oe">df_from_series_single = pd.DataFrame(series_name)</span></pre><p id="c1e7" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">将导致序列列名和行索引的保留</p><figure class="nh ni nj nk gt is gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/f4b3699eb356f268165d9388f445b750.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*XwAqOurj9OHeyrZdX9qMQw.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">df_from_series_single</figcaption></figure><blockquote class="nl nm nn"><p id="a6e9" class="kv kw mb kx b ky kz la lb lc ld le lf nq lh li lj ns ll lm ln nu lp lq lr km ij bi translated">注意:不幸的是，这仅限于一个系列，因为 DataFrame API 不接受一个以上的系列参数</p></blockquote><h2 id="2429" class="mi mj jf bd mk ml mm dn mn mo mp dp mq lg mr ms mt lk mu mv mw lo mx my mz na bi translated">用 Python 字典创建数据帧的行为</h2><p id="c46e" class="pw-post-body-paragraph kv kw jf kx b ky nb la lb lc nc le lf lg nd li lj lk ne lm ln lo nf lq lr km ij bi translated">当我们将 python 字典作为数组传递来创建 DataFrame 时，也会观察到同样的行为。让我们看看我们之前创建的<code class="fe on oo op nx b">t_dict = {'a': 1, ‘b’: 2, ‘c’:3}</code></p><pre class="nh ni nj nk gt nw nx ny nz aw oa bi"><span id="b242" class="mi mj jf nx b gy ob oc l od oe">ds = pd.DataFrame([t_dict])</span></pre><p id="0548" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">得到的数据帧应该看起来像这样</p><figure class="nh ni nj nk gt is gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/8ce9b20054e1446555670ef8c8dbe9e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*bY8vsoAtgXkCQADz6LktIw.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">ds</figcaption></figure><p id="bdd2" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">其中键被表示为列，否则如果我们创建了一个序列，它们将被表示为行索引</p><p id="b762" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">我们甚至可以组合多个<code class="fe on oo op nx b">t_dict</code>来创建一个数据帧</p><pre class="nh ni nj nk gt nw nx ny nz aw oa bi"><span id="cb69" class="mi mj jf nx b gy ob oc l od oe">ds = pd.DataFrame([t_dict, t_dict ], index=[1,2])</span></pre><figure class="nh ni nj nk gt is gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/5d4af641c293370584bbdc85c2f72bd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*DwjBw_SylbaX1S7wnTHjJQ.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">ds</figcaption></figure></div><div class="ab cl ko kp hu kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="ij ik il im in"><h2 id="34ad" class="mi mj jf bd mk ml mm dn mn mo mp dp mq lg mr ms mt lk mu mv mw lo mx my mz na bi translated">系列助手功能</h2><p id="8e66" class="pw-post-body-paragraph kv kw jf kx b ky nb la lb lc nc le lf lg nd li lj lk ne lm ln lo nf lq lr km ij bi translated">就像熊猫 DataFrame 一样，Series 也有多组帮助器函数用于数据分析。</p><p id="a3b1" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">请注意，Pandas DataFrame 的所有列助手功能都将适用于 Pandas 系列。一些例子是</p><pre class="nh ni nj nk gt nw nx ny nz aw oa bi"><span id="3141" class="mi mj jf nx b gy ob oc l od oe">#Getting the mean of a Series<br/>series_age.mean()</span><span id="279c" class="mi mj jf nx b gy oj oc l od oe"># Getting the size of the Series<br/>series_age.size</span><span id="a8fc" class="mi mj jf nx b gy oj oc l od oe"># Getting all unique items in a series<br/>series_designation.unique()</span><span id="0d6f" class="mi mj jf nx b gy oj oc l od oe"># Getting a python list out of a Series<br/>series_name.tolist()</span></pre></div><div class="ab cl ko kp hu kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="ij ik il im in"><h2 id="9230" class="mi mj jf bd mk ml mm dn mn mo mp dp mq lg mr ms mt lk mu mv mw lo mx my mz na bi translated">迭代序列</h2><p id="9ec5" class="pw-post-body-paragraph kv kw jf kx b ky nb la lb lc nc le lf lg nd li lj lk ne lm ln lo nf lq lr km ij bi translated">就像 python 中的许多其他数据结构一样，可以使用一个简单的 for 循环来迭代序列</p><pre class="nh ni nj nk gt nw nx ny nz aw oa bi"><span id="8d23" class="mi mj jf nx b gy ob oc l od oe">for value in series_name:<br/>    print(value)</span></pre><p id="7011" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">我们还可以迭代索引为</p><pre class="nh ni nj nk gt nw nx ny nz aw oa bi"><span id="5eca" class="mi mj jf nx b gy ob oc l od oe">for row_index in series_name.keys():<br/>    print(row_index)</span></pre><p id="ba6e" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">熊猫系列的基本用法就这些了。</p><p id="da8a" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">感谢阅读…！！！</p><p id="428b" class="pw-post-body-paragraph kv kw jf kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr km ij bi translated">达克什</p></div></div>    
</body>
</html>