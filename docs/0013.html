<html>
<head>
<title>Kaggle : Python : DataQuest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kaggle : Python : DataQuest</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/kaggle-python-dataquest-85ab1994fcdf?source=collection_archive---------1-----------------------#2017-01-14">https://towardsdatascience.com/kaggle-python-dataquest-85ab1994fcdf?source=collection_archive---------1-----------------------#2017-01-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2860ed531846f8b41dc961d103be284a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M3paK58zlCnSTPoZXhHwSg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Kaggle.com</figcaption></figure><h2 id="9b96" class="kc kd iq bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第二部分:<a class="ae ky" href="https://www.kaggle.com/c/titanic" rel="noopener ugc nofollow" target="_blank">卡格比赛</a>和<a class="ae ky" href="https://www.dataquest.io/course/kaggle-competitions" rel="noopener ugc nofollow" target="_blank">数据任务教程</a>在这句话中连在一起。在处理完第1部分之后。我回来接受更多的惩罚。</h2><p id="dbd1" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj kl lk ll lm kp ln lo lp kt lq lr ls lt ij bi translated">我正在使用Cloud9 IDE，它有ubantu，我从Python2开始，但我可能会以python 3结束。我仍然使用DataQuest作为我的指南，所以我们开始吧！请记住，到目前为止，我的代码如下所示:</p><p id="23e0" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">import pandas<br/>import numpy as np<br/>from sklearn import cross_validation<br/>from sklearn.linear_model import LogisticRegression<br/>titanic = pandas.read_csv(“train.csv”)<br/>predictors = [“Pclass”, “Sex”, “Age”, “SibSp”, “Parch”, “Fare”, “Embarked”]<br/>alg = LogisticRegression(random_state = 1)<br/>kf = cross_validation.KFold(titanic.shape[0], n_folds=3, random_state=1)<br/>predictions = []<br/>fillage = titanic[“Age”].median()<br/>titanic[‘Age’] = titanic[‘Age’].fillna(fillage)<br/>titanic.loc[titanic[“Sex”] == “male”, “Sex”] = 0<br/>titanic.loc[titanic[“Sex”] == “female”, “Sex”] = 1<br/>titanic[“Embarked”] = titanic[“Embarked”].fillna(‘S’)<br/>titanic.loc[titanic[“Embarked”] == “S”, “Embarked”] = 0<br/>titanic.loc[titanic[“Embarked”] == “C”, “Embarked”] = 1<br/>titanic.loc[titanic[“Embarked”] == “Q”, “Embarked”] = 2<br/>for train, test in kf:<br/> train_predictors = (titanic[predictors].iloc[train,:])<br/> train_target = titanic[“Survived”].iloc[train]<br/> alg.fit(train_predictors, train_target)<br/> test_predictions = alg.predict(titanic[predictors].iloc[test,:])<br/> predictions.append(test_predictions)<br/>predictions = np.concatenate(predictions, axis=0)<br/>predictions[predictions &gt; .5] = 1<br/>predictions[predictions &lt;=.5] = 0<br/>num = len(predictions)</code></p><p id="d769" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">i=0<br/>count = 0.0<br/>#print(count)<br/>for prediction in predictions:<br/> if predictions[i] == titanic[“Survived”][i]:<br/> count = count + 1<br/> i = i+1</code> <br/> <br/> <code class="fe lz ma mb mc b">accuracy = float(count/num)<br/>scores = cross_validation.cross_val_score(alg, titanic[predictors], titanic[“Survived”], cv=3)</code></p><p id="12f6" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">titanic_test = pandas.read_csv(“test.csv”)<br/>fillFare = titanic_test[‘Fare’].median()<br/>fillAge = titanic_test[‘Age’].median() +1<br/>titanic_test[‘Fare’] = titanic_test[‘Fare’].fillna(fillFare)<br/>titanic_test[‘Age’] = titanic_test[‘Age’].fillna(fillAge)<br/>titanic_test[‘Embarked’] = titanic_test[‘Embarked’].fillna(‘S’)<br/>titanic_test.loc[titanic_test[‘Sex’] == ‘male’, ‘Sex’] = 0<br/>titanic_test.loc[titanic_test[“Sex”] == “female”, ‘Sex’] = 1<br/>titanic_test.loc[titanic_test[‘Embarked’] == ‘S’, ‘Embarked’] = 0<br/>titanic_test.loc[titanic_test[‘Embarked’] == ‘C’, ‘Embarked’] = 1<br/>titanic_test.loc[titanic_test[‘Embarked’] == ‘Q’, ‘Embarked’] = 2</code></p><p id="5de3" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">alg.fit(titanic[predictors], titanic[“Survived”])<br/>predictions = alg.predict(titanic_test[predictors])<br/>submission = pandas.DataFrame({<br/> “Survived”: predictions<br/> },index= titanic_test[“PassengerId”])</code></p><p id="edc9" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">submission.to_csv(‘Kaggle.csv’)<br/>#print(titanic.describe())</code></p><p id="71df" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">注意:<em class="md">现在python 2不喜欢“准确性”这一行*叹*所以我换了python 3。在c9中，当你在一个工作空间中时，你可以按settings菜单，在python 2和3之间切换。记住，你必须下载你正在使用的新版本的所有软件包。</em></p><p id="65c6" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">计划的第二部分是提高我们的提交分数。第一个实用模块是关于一个叫做随机森林的东西。一棵树就像我们在小学看到的流程图。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/3fab9ce35ae5bfdbffb367b65173a29d.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*DkrqwWMgUL7CNMHW-nKo4w.png"/></div></figure><p id="1c3d" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">有“是”或“否”的输入来导致决定或最终答案(有点像玩20个问题)。这些统计学上的答案叫做终端节点。这允许机器通过将关系简化为一系列线性关系来理解可能不是线性的关系。对于你们这些书呆子来说，在微积分中，不管函数有多复杂，随着你看到的区间变小，它会变成一条直线，然后变成一个点(一般来说)。你可以把一个复杂的问题变成一系列简单的问题。</p><p id="d2f7" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">现在，如果你做多棵树，你会有一个森林。当你用随机的初始起点从数据中创建其他的树时，你可以很好的观察数据告诉你什么。取森林的平均值，就可以开始做预测了。如果树木不是随机的，这种技术就叫做“套袋”。</p><p id="30c4" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">Sklearn可以用来实现一个森林。Sklearn有一个名为<a class="ae ky" href="http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html" rel="noopener ugc nofollow" target="_blank">的随机森林分类器</a>的模块，在集成模块下完成这项工作。创建的森林将有十棵树。我们将使用泰坦尼克号的测试数据来做这件事。</p><p id="4e14" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">在我做任何事情之前，我会删除打印语句和导出语句，因为它们是不需要的。</p><p id="5f01" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">Dataquest明确写出了许多参数，但是根据文档，它们使用的值与默认值相同。</p><p id="5795" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">algForest = RandomForestClassifier(random_state=1, n_estimators=10, min_samples_split=2, min_samples_leaf=1)</code></p><p id="0fa7" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">以上代码由Dataquest提供:</p><p id="56bb" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">1)n_estimators = &gt;森林中树木的数量；默认值= 10</p><p id="573f" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">2)min_samples_split = &gt;分割3)内部节点所需的最小样本数；默认值= 2</p><p id="25fe" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">4)min_samples_leaf= &gt;作为叶节点所需的最小样本数；默认值= 1</p><p id="55c8" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">现在，我们可以使用这种新算法，并以与基于日志的算法相同的方式实现它。</p><p id="f902" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">首先我们做一个交叉验证。这将模拟我们之前代码中定义“score”的行，并为cv(交叉验证)参数传递kf变量。我的看起来像这样:</p><blockquote class="mj mk ml"><p id="ad9e" class="kz la md lb b lc lu le lf lg lv li lj mm lw ll lm mn lx lo lp mo ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b"><em class="iq">from sklearn import cross_validation<br/>from sklearn.ensemble import RandomForestClassifier titanic=pandas.read_csv(“train.csv”)<br/>predictors = [“Pclass”, “Sex”, “Age”, “SibSp”, “Parch”, “Fare”, “Embarked”] algForest = RandomForestClassifier(random_state=1, n_estimators=10, min_samples_split=2, min_samples_leaf=4)<br/>kf = cross_validation.KFold(titanic.shape[0], n_folds=3, random_state=1) scores_forest = cross_validation.cross_val_score(algForest, titanic[predictors], titanic[‘Survived’], cv=kf)</em></code></p><p id="03b4" class="kz la md lb b lc lu le lf lg lv li lj mm lw ll lm mn lx lo lp mo ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b"><em class="iq">print(scores.mean())</em></code></p></blockquote><p id="d6e0" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">现在，是时候生成一些新特性了。我以前在处理一些计算物理问题时用过熊猫。但是我从来没有在数据帧上真正使用过它。</p><p id="bb51" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">我使用pandas apply()函数和lambda函数。apply()函数从我们实现的lambda函数中推断出一个pandas系列。</p><p id="b94d" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">我们将使用简单的加法来计算家庭规模和名字的长度(名字越长，等级越高…理论上)。</p><p id="c335" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">Dataquest写出了这些行，我将它们添加到测试集和训练集中。</p><p id="b0c5" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">titanic[‘FamilySize’] = titanic[‘SibSp’] + titanic[‘Parch’]<br/>titanic[‘NameLength’] = titanic[‘Name’].apply(lambda x: len(x))</code></p><p id="877a" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">现在我应该得到每个乘客的头衔，在我看来，这比名字的长度更能反映身份。</p><p id="025b" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">对于这一个，我需要构建一个函数来完成这项工作。我将在不同的文件中创建这个类，并将它导入到原始文件中。</p><p id="c159" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">我准备用一个正则表达式(大家的最爱)来搜索名字。</p><p id="e54a" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">‘([A-Za-z]+)\.’</code></p><p id="9684" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">这意味着reg ex搜索将从A到Z查找一个大写字母，后跟一串字母，并以句点结尾。</p><p id="1df5" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">当我使用re.search()函数进行搜索时，我需要首先检查我是否找到了匹配项，如果是，我需要得到搜索找到的内容。为了实现前者，我使用了一个简单的if语句。为了实现后者，我需要使用group函数。Group采用reg ex给定的子组的编号。这意味着组(1)将返回由<code class="fe lz ma mb mc b">[A-Za-z]</code>表示的内容。</p><p id="0f68" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">然后，我使用pandas apply()将查找标题的函数映射到数据集的Name列:</p><blockquote class="mj mk ml"><p id="917f" class="kz la md lb b lc lu le lf lg lv li lj mm lw ll lm mn lx lo lp mo ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">def get_titles(name):<br/> title_search = re.search(‘ ([A-Za-z]+)\.’, name)<br/> if title_search:<br/> return title_search.group(1)<br/> return “”</code></p><p id="fb9b" class="kz la md lb b lc lu le lf lg lv li lj mm lw ll lm mn lx lo lp mo ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">titles = titanic[“Name”].apply(get_titles)</code></p></blockquote><p id="b978" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">此外，我可以使用pandas.value_counts对每个输出进行计数。</p><p id="1e83" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">遍历pandas.value_counts中的键/值对，使用标题作为键，计数作为值来创建数据集:</p><blockquote class="mj mk ml"><p id="c55e" class="kz la md lb b lc lu le lf lg lv li lj mm lw ll lm mn lx lo lp mo ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">title_mapping = {“Mr”: 1, “Miss”: 2, “Mrs”: 3, “Master”: 4, “Dr”: 5, “Rev”: 6,<br/>“Major”: 7, “Col”: 7, “Mlle”: 8, “Mme”: 8, “Don”: 9, “Lady”: 10, “Countess”: 10,“Jonkheer”: 10, “Sir”: 9, “Capt”: 7, “Ms”: 2}</code></p><p id="0da5" class="kz la md lb b lc lu le lf lg lv li lj mm lw ll lm mn lx lo lp mo ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">for k,v in title_mapping.items():<br/> titles[titles == k] = v</code></p></blockquote><p id="0e07" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">现在我把我的注意力转向看我能不能搞清楚家庭团体。当谈到生存能力时，这是一个很好的选择。什么规模的家庭存活几率更大？</p><p id="99ac" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">首先我们导入<a class="ae ky" href="https://docs.python.org/2/library/operator.html" rel="noopener ugc nofollow" target="_blank">操作符模块</a>。这个模块很难用语言来解释。为了简化，它采用运算(+、-、x等)并将它们转换成可以提供参数的函数。因此<code class="fe lz ma mb mc b">operator.add(x,y)</code>在功能上与<code class="fe lz ma mb mc b">x+y</code>相同。</p><p id="aa23" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">导入之后，正如我对标题所做的那样，我们需要定义一个映射字典。但是这一次，字典将是空的(最初)。</p><p id="a8fd" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">然后，当给定一行时，我创建一个函数来获取id。在该函数中，首先我们获得姓氏，然后我使用reg ex <code class="fe lz ma mb mc b">“{0}{1}”</code>创建一个id，并将其与姓氏相关联。这样做之后，我创建一个条件:如果系列id不在我们之前创建的系列映射字典中，那么我向字典中添加一个全新的系列，如果id确实存在，那么我向该系列id添加1:</p><blockquote class="mj mk ml"><p id="b73b" class="kz la md lb b lc lu le lf lg lv li lj mm lw ll lm mn lx lo lp mo ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">def get_family_ids(row):<br/> last_name = row[‘Name’].split(“,”)[0]<br/> family_id = “{0}{1}”.format(last_name, row[“FamilySize”])<br/> if family_id not in family_id_mapping:<br/> if len(family_id_mapping) == 0:<br/> current_id = 1<br/> else:<br/> current_id = (max(family_id_mapping.items(), key=operator.itemgetter(1))[1] + 1)<br/> family_id_mapping[family_id] = current_id<br/> return family_id_mapping[family_id]</code></p></blockquote><p id="533e" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">在函数外部，我使用pandas.apply方法定义了family _ ids。参数是我们创建的函数，用于获取系列id和轴=1。</p><p id="a547" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">DataQuest让我把所有少于三人的家庭压缩成一个代码。我说…不。我们看看会发生什么。</p><p id="9690" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">最后，我们将该列添加到我们的数据集，然后打印出来。</p><blockquote class="mj mk ml"><p id="5e33" class="kz la md lb b lc lu le lf lg lv li lj mm lw ll lm mn lx lo lp mo ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">family_ids = titanic.apply(get_family_ids, axis=1)<br/>titanic[“FamilyId”] = family_ids</code></p></blockquote><p id="6302" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">这些代码的大部分是由DataQuest编写的，我花了一些时间来分析它并弄清楚发生了什么。看了很多文件！</p><p id="25e5" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">不管怎样，我要去寻找预测的最佳特征了。我的森林里有哪些问题通常能让我得到正确答案？</p><p id="431a" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">接下来我将使用一个叫做<a class="ae ky" href="http://scikit-learn.org/stable/auto_examples/feature_selection/plot_feature_selection.html" rel="noopener ugc nofollow" target="_blank">的东西，单变量特征选择</a>。那是一口。我需要从scikitlearn导入更多的模块；<a class="ae ky" href="http://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.SelectKBest.html" rel="noopener ugc nofollow" target="_blank"> SelectKBest </a>，f_classif。</p><p id="5d41" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">然后，我需要将我创建的新参数(头衔和家庭规模)添加到预测列表中。</p><p id="9838" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">我把一个叫做选择器的变量等同于以f_classif和k=5为参数的函数selectBest。I将选择器与巨大的预测器和幸存的参数列相匹配。</p><p id="21b0" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">我使用numpy.log10和p值计算每个预测值的得分。根据<a class="ae ky" href="http://blog.minitab.com/blog/adventures-in-statistics-2/how-to-correctly-interpret-p-values" rel="noopener ugc nofollow" target="_blank">这篇文章</a>:</p><blockquote class="mj mk ml"><p id="7cdf" class="kz la md lb b lc lu le lf lg lv li lj mm lw ll lm mn lx lo lp mo ly lr ls lt ij bi translated">p值评估样本数据在多大程度上支持“魔鬼代言人”的论点，即零假设为真。它衡量你的数据与零假设的符合程度。如果零假设为真，在样本数据中观察到这种效应的可能性有多大？</p><p id="b904" class="kz la md lb b lc lu le lf lg lv li lj mm lw ll lm mn lx lo lp mo ly lr ls lt ij bi translated">高P值:您的数据可能为真空值。</p><p id="a1dc" class="kz la md lb b lc lu le lf lg lv li lj mm lw ll lm mn lx lo lp mo ly lr ls lt ij bi translated">低P值:您的数据不太可能为真空值。</p></blockquote><p id="63a1" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">然后我用matplotlib.pylot将结果图形化，有了这个，我就能算出什么是最好的预测器(“Pclass”、“Sex”、“Fare”、“Title”)。然后，我使用我们为随机森林创建的算法来重新定义分数，并打印出平均值。为了便于阅读，我将这个新的分数称为scores_graph。</p><blockquote class="mj mk ml"><p id="7a6c" class="kz la md lb b lc lu le lf lg lv li lj mm lw ll lm mn lx lo lp mo ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">predictors = [“Pclass”, “Sex”, “Age”, “SibSp”, “Parch”, “Fare”, “Embarked”, “FamilySize”, “Title”, “FamilyId”, “NameLength”]<br/>selector = SelectKBest(f_classif, k=5)<br/>selector.fit(titanic[predictors], titanic[“Survived”])<br/>algForest.fit(titanic[predictors], titanic[‘Survived’])<br/>scores_graph = -np.log10(selector.pvalues_)<br/>plt.bar(range(len(predictors)), scores_graph)</code></p><p id="1fe2" class="kz la md lb b lc lu le lf lg lv li lj mm lw ll lm mn lx lo lp mo ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">plt.xticks(range(len(predictors)), predictors, rotation=’vertical’)<br/>plt.show()</code></p></blockquote><p id="e7d0" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">在这一点上，我遇到了c9的障碍。它不会显示图表。*她哭泣*所以我问了我的老朋友谷歌先生，我得到了<a class="ae ky" href="http://stackoverflow.com/questions/15089174/support-for-cloud9-ide-and-matplotlib-or-other-graphical-tool-for-python" rel="noopener ugc nofollow" target="_blank">这里</a>。我需要与进口和matplotlib的工作方式。</p><p id="0659" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">import matplotlib<br/>matplotlib.use(‘Agg’)</code></p><ul class=""><li id="f570" class="mp mq iq lb b lc lu lg lv kl mr kp ms kt mt lt mu mv mw mx bi translated">注意，这些行应该在导入matplotlib.pyplot之前插入。</li></ul><p id="6261" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">所以在你画出图后，你加上这两条线:</p><p id="10a1" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">fig = plt.figure()</code></p><p id="d04d" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">fig.savefig(filename)</code></p><p id="bc53" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">它应该在程序所在的目录下创建一个你选择的格式的文件。</p><p id="2a7e" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">在这一点上，下一个模块是关于梯度增强，这是一种增强我们从随机森林中获得的预测的方法。但是，我不知道它是如何工作的，所以我查了一下，找到了这个视频。哈佛大学的统计学教授特雷弗·哈斯蒂谈到了这个话题(我不得不查一些术语)。</p><p id="a820" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">Boosting Trees获取树，并像以前一样找到平均值，但这一次，它将根据是否得到好的结果来加权每棵树。它会增加森林中表现不佳的部分的权重，并尝试修复错误。这可能会导致过度拟合，当我们准备好预测时，这会导致各种各样的问题，但对于我们的目的来说，这是可以的。</p><p id="6414" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">在梯度增强之后是关于集合的部分。这是将不同的分类器(如线性、对数、随机森林或装袋)放在一起的行为。就像科学怪人的统计数据。为了充分利用这一点，分类器需要具有不同的类型，并且具有相似的等级(具有相似的)误差值。DataQuest让我使用带有梯度提升树的对数分类器。</p><p id="c747" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">从scikitLearn中，我导入了梯度推进分类器模块，并给它一个随机状态1，估计数量为25，每棵树只有3个分支(两个是二进制选择:是或否问题，它们被称为树桩)。</p><p id="aa3f" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">然后，我创建了一个名为“ens”的数组，它将两个算法作为嵌套数组的元素。一个数组中有梯度增强分类器和预测器，另一个数组中有对数回归和预测器(不同的)。设置好之后，我在训练数据集中使用它。</p><p id="c838" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">然后，因为梯度提升比对数回归更准确，所以我们将权重添加到提升中(三倍于对数):</p><blockquote class="mj mk ml"><p id="327b" class="kz la md lb b lc lu le lf lg lv li lj mm lw ll lm mn lx lo lp mo ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">predictions = []<br/>predictors = [“Pclass”, “Sex”, “Age”, “Fare”, “Embarked”, “FamilySize”, “Title”, “FamilyId”]<br/>ens = [[alg_gradient , predictors],[alg ,[“Pclass”, “Sex”, “Fare”, “FamilySize”, “Title”, “Age”, “Embarked”]]]<br/>for train, test in kf:<br/> train_target = titanic[‘Survived’].iloc[train]<br/> full_test_predictions = []<br/> for alg, predictors in ens:<br/> alg.fit(titanic[predictors].iloc[train,:], train_target)<br/> test_predictions = alg.predict_proba(titanic[predictors].iloc[test,:].astype(float))[:,1]<br/> full_test_predictions.append(test_predictions)<br/> test_predictions = (full_test_predictions[0] + full_test_predictions[1]) / 2<br/> test_predictions[test_predictions &lt;= .5] = 0<br/> test_predictions[test_predictions &gt; .5] = 1<br/> predictions.append(test_predictions)<br/>predictions = np.concatenate(predictions,axis=0)</code></p><p id="23d8" class="kz la md lb b lc lu le lf lg lv li lj mm lw ll lm mn lx lo lp mo ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">accuracy = sum(predictions[predictions == titanic[“Survived”]]) / len(predictions)</code></p></blockquote><p id="83a1" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">因为这不是公主新娘，所以某人不可能“大部分”死亡，所以我们可以继续进行测试_预测枯萎0或1(幸存与否)。</p><p id="7178" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">在此之后，我将我们对训练数据所做的预测应用到完整的数据集。为此，我首先将整个数据集与训练数据进行拟合。然后使用<a class="ae ky" href="http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html#sklearn.linear_model.LogisticRegression.predict_proba" rel="noopener ugc nofollow" target="_blank"> alg.predict_proba() </a>函数填写预测值:</p><blockquote class="mj mk ml"><p id="b5dd" class="kz la md lb b lc lu le lf lg lv li lj mm lw ll lm mn lx lo lp mo ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">alg_ens = [<br/> [GradientBoostingClassifier(random_state=1, n_estimators=25, max_depth=3), predictors],<br/> [LogisticRegression(random_state=1), [“Pclass”, “Sex”, “Fare”, “FamilySize”, “Title”, “Age”, “Embarked”]]<br/>]<br/>full_predictions =[]<br/>for alg, predictors in alg_ens:<br/> alg.fit(titanic[predictors], titanic[“Survived”])<br/> predictions = alg.predict_proba(titanic_test[predictors].astype(float))[:,1]<br/> full_predictions.append(predictions)<br/>predictions = (full_predictions[0] * 3 + full_predictions[1]) / 4<br/>predictions[predictions &lt;= .5] = 0<br/>predictions[predictions &gt; .5] = 1</code></p></blockquote><p id="6cbe" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">我再次使用本教程第一部分中的提交术语:</p><p id="c98e" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">submission = pandas.DataFrame({<br/> “PassengerId”: titanic[“PassengerId”],<br/> “Survived”: predictions<br/> }).astype(int) <br/>submission.to_csv(‘Kaggle.csv’)</code></p><p id="a12c" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">在上一篇文章中，我不得不进入我的google drive，手动删除索引栏(像个傻瓜一样)。然后我做了一些研究，当我在做另一个项目时，我意识到当你使用熊猫导出到csv时，你可以关闭索引。你只需要写下:</p><p id="75ad" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">submission.to_csv(‘Kaggle.csv’,index=False)</code></p><p id="bad5" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">嘣！完成了。</p><p id="d877" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">对于Python版本，唯一的区别是“准确性”行必须用2注释掉。它与熊猫有关。</p><p id="df08" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj kl lw ll lm kp lx lo lp kt ly lr ls lt ij bi translated">我这里的代码是<a class="ae ky" href="https://ide.c9.io/vworri/kaggle1titanic" rel="noopener ugc nofollow" target="_blank"/>。我要去睡觉了。</p></div></div>    
</body>
</html>