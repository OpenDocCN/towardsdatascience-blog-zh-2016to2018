<html>
<head>
<title>The Why and How of Python Properties</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 属性的原因和方式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-why-and-how-of-python-properties-b791817cf4b9?source=collection_archive---------3-----------------------#2017-12-23">https://towardsdatascience.com/the-why-and-how-of-python-properties-b791817cf4b9?source=collection_archive---------3-----------------------#2017-12-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="gh gi ju"><img src="../Images/1184164f7e6f471ed675b6ff0c851855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AY18v5DxO51Prce1vDoOtw.jpeg"/></div></div><figcaption class="kg kh gj gh gi ki kj bd b be z dk"><a class="ae kk" href="https://cdn.programiz.com/sites/tutorial2program/files/python-property.jpg" rel="noopener ugc nofollow" target="_blank">https://cdn.programiz.com/sites/tutorial2program/files/python-property.jpg</a></figcaption></figure><h2 id="7977" class="kl km iq bd kn ko kp dn kq kr ks dp kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated"><strong class="ak">一个现实世界的问题</strong></h2><p id="fcce" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr ku ls lt lu ky lv lw lx lc ly lz ma mb ij bi translated">大约一年前，我们在我目前的工作中遇到了一个有趣的障碍:我们的计算机视觉管道消耗了太多的内存。拥有 10gb 可用内存和一个相当大的交换分区的机器正在猛烈地颠簸。经过一些调查，我们意识到这是我们在流水线开始时将一个任务的所有相关输入图像加载到内存中的结果。当流水线第一次组装时，每个作业的最大图像数量约为 20 个，这并不是一个问题，但这个数字突然开始增长。我们在一个有 210 个图像的作业中发现了这个问题，一个 52 兆的图像占用了 11 兆的内存。</p><p id="4109" class="pw-post-body-paragraph lh li iq lj b lk mc lm ln lo md lq lr ku me lt lu ky mf lw lx lc mg lz ma mb ij bi translated">太好了。我们遇到了一个问题。解决这一难题的简单方法是只在需要的时候将图像加载到内存中，而不要保留对它的不必要的引用。这是一个不错的解决方案(尽管它本身有一些问题是可以解决的，但我不会在本文中深入讨论)，但这似乎需要大量的重构。为了理解为什么，请允许我向您展示一些(非常简单的)示例代码:</p><pre class="jv jw jx jy gt mh mi mj mk aw ml bi"><span id="812b" class="kl km iq mi b gy mm mn l mo mp"># The class that holds onto the image<br/>class ImageHolder:<br/>    def __init__(self, image_path):<br/>        self.image = load_image_from_path(image_path)</span><span id="5770" class="kl km iq mi b gy mq mn l mo mp"><br/>holders = []<br/># The bit of code that loads the images<br/>for image_path in large_list_of_paths:<br/>    holders.append(ImageHolder(image_path))</span><span id="b8e6" class="kl km iq mi b gy mq mn l mo mp"><br/># Various parts of the pipeline that do something with the images<br/>for holder in holders:<br/>    do_something(holder.image)</span></pre><h2 id="e958" class="kl km iq bd kn ko kp dn kq kr ks dp kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated"><strong class="ak">现实世界的解决方案</strong></h2><p id="a270" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr ku ls lt lu ky lv lw lx lc ly lz ma mb ij bi translated">在大多数其他语言(如 C++)中，最简单的解决方案是:</p><pre class="jv jw jx jy gt mh mi mj mk aw ml bi"><span id="cd6e" class="kl km iq mi b gy mm mn l mo mp">class ImageHolder:<br/>    def __init__(self, image_path):<br/>        self.image_path = image_path</span><span id="a706" class="kl km iq mi b gy mq mn l mo mp">    def get_image(self):<br/>        return load_image_from_path(self.image_path)</span></pre><p id="14e7" class="pw-post-body-paragraph lh li iq lj b lk mc lm ln lo md lq lr ku me lt lu ky mf lw lx lc mg lz ma mb ij bi translated">但是这产生了一个问题:我们现在必须确保所有对<code class="fe mr ms mt mi b">ImageHolder.image</code>的引用都变成了<code class="fe mr ms mt mi b">ImageHolder.get_image()</code>。我们还需要确保程序员记得更改未来的代码(尽管有些人会认为我们应该从一开始就这样做，如果属性不存在，我也会同意)。虽然这两个任务都不是特别重要的任务，但是它们仍然很烦人，而且它们扰乱了代码本身的语义(也就是说，<code class="fe mr ms mt mi b">operate_on(holder.image)</code>比<code class="fe mr ms mt mi b">operate_on(holder.get_image())</code>读起来要好得多)。谢天谢地，在 python 中，我们可以这样做:</p><pre class="jv jw jx jy gt mh mi mj mk aw ml bi"><span id="1624" class="kl km iq mi b gy mm mn l mo mp">class ImageHolder:<br/>    def __init__(self, image_path):<br/>        self.image_path = image_path</span><span id="cbe9" class="kl km iq mi b gy mq mn l mo mp">@property<br/>def image(self):<br/>        return load_image_from_path(self.image_path)</span></pre><p id="778b" class="pw-post-body-paragraph lh li iq lj b lk mc lm ln lo md lq lr ku me lt lu ky mf lw lx lc mg lz ma mb ij bi translated">现在<code class="fe mr ms mt mi b">ImageHolder.image</code>(看起来<em class="mu">不像</em>函数调用)返回图像，就好像它是一个指向图像的字段。<strong class="lj ir">这个</strong>就是 python 属性的魔力。他们将我们从最初糟糕的设计中解救出来(从一开始就没有设置 getters 和 setters ),同时使我们的代码看起来不那么笨拙。</p><h2 id="6aa2" class="kl km iq bd kn ko kp dn kq kr ks dp kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated"><strong class="ak">另一个不太“现实”的例子</strong></h2><p id="f80a" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr ku ls lt lu ky lv lw lx lc ly lz ma mb ij bi translated">当然，使用这样的抽象还有无数的其他原因，它确实有助于保持对象中的<em class="mu">状态</em>的总大小较小，并提高可维护性。考虑一个<code class="fe mr ms mt mi b">Circle</code>类的简单实现:</p><pre class="jv jw jx jy gt mh mi mj mk aw ml bi"><span id="b4b3" class="kl km iq mi b gy mm mn l mo mp">PI = 3.141<br/>class Circle:<br/>    def init(self, radius):<br/>        self.radius = radius<br/>        self.area = PI * self.radius ** 2<br/>        self.circumference = 2 * PI * self.radius</span></pre><p id="7c61" class="pw-post-body-paragraph lh li iq lj b lk mc lm ln lo md lq lr ku me lt lu ky mf lw lx lc mg lz ma mb ij bi translated">并按以下方式使用它:</p><pre class="jv jw jx jy gt mh mi mj mk aw ml bi"><span id="9b69" class="kl km iq mi b gy mm mn l mo mp">c = Circle(1)<br/>print c.area  # prints 3.141<br/>print c.circumference  # prints 6.282</span><span id="f8dc" class="kl km iq mi b gy mq mn l mo mp">c.radius = 2<br/>print c.area  # prints 3.141 which is incorrect<br/>print c.circumference  # prints 6.282 which is incorrect</span></pre><p id="5e7a" class="pw-post-body-paragraph lh li iq lj b lk mc lm ln lo md lq lr ku me lt lu ky mf lw lx lc mg lz ma mb ij bi translated">一旦我们更改了<code class="fe mr ms mt mi b">radius</code>,<code class="fe mr ms mt mi b">area</code>和<code class="fe mr ms mt mi b">circumference</code>字段在更新之前都是无用的(我们可以在这里使用 setters 来缓解这种情况，但那是另一篇文章了)。与下面的实现进行比较:</p><pre class="jv jw jx jy gt mh mi mj mk aw ml bi"><span id="a7be" class="kl km iq mi b gy mm mn l mo mp">PI = 3.141<br/>class Circle:<br/>    def init(self, radius):<br/>        self.radius = radius</span><span id="b8d7" class="kl km iq mi b gy mq mn l mo mp">    def area(self):<br/>        return PI * self.radius ** 2</span><span id="3e06" class="kl km iq mi b gy mq mn l mo mp">    def circumference(self):    <br/>        return 2 * PI * self.radius</span></pre><p id="160e" class="pw-post-body-paragraph lh li iq lj b lk mc lm ln lo md lq lr ku me lt lu ky mf lw lx lc mg lz ma mb ij bi translated">再次对其运行相同的测试，我们得到:</p><pre class="jv jw jx jy gt mh mi mj mk aw ml bi"><span id="0cd5" class="kl km iq mi b gy mm mn l mo mp">c = Circle(1)<br/>print c.area  # prints 3.141<br/>print c.circumference  # prints 6.282</span><span id="0b91" class="kl km iq mi b gy mq mn l mo mp">c.radius = 2<br/>print c.area  # prints 12.564 which is correct!<br/>print c.circumference  # prints 12.564 which is correct!</span></pre><p id="f097" class="pw-post-body-paragraph lh li iq lj b lk mc lm ln lo md lq lr ku me lt lu ky mf lw lx lc mg lz ma mb ij bi translated">只有<code class="fe mr ms mt mi b">radius</code>成为该对象的<em class="mu">状态</em>才有意义，因为其他两个值都可以从中导出。Python 属性允许我们封装这种现实，而不会使语法看起来笨拙。</p><h2 id="74f5" class="kl km iq bd kn ko kp dn kq kr ks dp kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated"><strong class="ak">结论</strong></h2><p id="2e3c" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr ku ls lt lu ky lv lw lx lc ly lz ma mb ij bi translated">我想展示 Python 属性在现实环境中的用处。我希望这篇文章能做到这一点。关于属性(以及设置器)更详细的讨论可以在<a class="ae kk" href="https://www.programiz.com/python-programming/property" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我将在另一篇文章中讨论 setters，在那篇文章中，我将解释如何更新一个没有加载到内存中的图像(以及其他内容)。</p></div></div>    
</body>
</html>