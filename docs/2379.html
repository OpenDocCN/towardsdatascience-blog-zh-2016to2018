<html>
<head>
<title>Basics of image classification with Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Keras图像分类基础</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/basics-of-image-classification-with-keras-43779a299c8b?source=collection_archive---------1-----------------------#2018-01-19">https://towardsdatascience.com/basics-of-image-classification-with-keras-43779a299c8b?source=collection_archive---------1-----------------------#2018-01-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8f170b44be9ef5a56bbc7c0ca2c241db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XG1JuTaoDEscvky07n5ngA.jpeg"/></div></div></figure><p id="cb07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我之前的帖子中，我深入研究了人工神经网络的一些理论概念。在这篇文章中，我将解释一些你在keras中经常需要的常见操作。首先，如何保存模型并在以后使用它们进行预测，显示来自数据集的图像，从我们的系统加载图像并预测它们的类别。</p><p id="f535" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您还没有启动IDE，请继续阅读。</p><p id="7124" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">保存模型</p><p id="a921" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">训练模型是一个非常缓慢的过程，没有人希望每次都这样做，幸运的是，我们只需要训练我们的模型一次，保存它，然后我们可以随时加载它，并用它来预测新的图像。</p><p id="0562" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Keras以. h5格式保存模型，所以如果您在我发布的第一篇教程中跳过了安装h5py，请运行</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="416f" class="lf lg iq lb b gy lh li l lj lk">pip3 install h5py</span></pre><p id="9df2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要matplotlib来可视化我们的图像，因此，运行</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="f4e2" class="lf lg iq lb b gy lh li l lj lk">pip3 install matplotlib</span></pre><p id="6ba5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是第一个教程的代码</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="b10e" class="lf lg iq lb b gy lh li l lj lk">import keras<br/>from keras.datasets import mnist<br/>from keras.layers import Dense<br/>from keras.models import Sequential<br/>from keras.optimizers import SGD<br/></span><span id="96d7" class="lf lg iq lb b gy ll li l lj lk">(train_x, train_y) , (test_x, test_y) = mnist.load_data()<br/>#train_x = train_x.astype('float32') / 255<br/>#test_x = test_x.astype('float32') / 255</span><span id="7bc4" class="lf lg iq lb b gy ll li l lj lk">print(train_x.shape)<br/>print(train_y.shape)<br/>print(test_x.shape)<br/>print(test_y.shape)</span><span id="9717" class="lf lg iq lb b gy ll li l lj lk">train_x = train_x.reshape(60000,784)<br/>test_x = test_x.reshape(10000,784)</span><span id="6538" class="lf lg iq lb b gy ll li l lj lk">train_y = keras.utils.to_categorical(train_y,10)<br/>test_y = keras.utils.to_categorical(test_y,10)</span><span id="148b" class="lf lg iq lb b gy ll li l lj lk">model = Sequential()<br/>model.add(Dense(units=128,activation="relu",input_shape=(784,)))<br/>model.add(Dense(units=128,activation="relu"))<br/>model.add(Dense(units=128,activation="relu"))<br/>model.add(Dense(units=10,activation="softmax"))</span><span id="3f8f" class="lf lg iq lb b gy ll li l lj lk">model.compile(optimizer=SGD(0.001),loss="categorical_crossentropy",metrics=["accuracy"])<br/>model.fit(train_x,train_y,batch_size=32,epochs=10,verbose=1)</span><span id="bcd3" class="lf lg iq lb b gy ll li l lj lk">accuracy = model.evaluate(x=test_x,y=test_y,batch_size=32)</span><span id="82b6" class="lf lg iq lb b gy ll li l lj lk">print("Accuracy: ",accuracy[1])</span></pre><p id="d87d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要保存模型，只需在model.fit()后添加以下内容</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="c002" class="lf lg iq lb b gy lh li l lj lk">model.save("mnist-model.h5")</span></pre><p id="e244" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">推理</p><p id="8921" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">推理是指使用我们的模型预测新图像的过程。</p><p id="6247" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在代码中，注释掉</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="ff30" class="lf lg iq lb b gy lh li l lj lk">model.fit</span></pre><p id="c67b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">取而代之的是</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="b722" class="lf lg iq lb b gy lh li l lj lk">model.load_weights("mnistmodel.h5")</span></pre><p id="546c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的代码现在看起来像这样</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="9c3c" class="lf lg iq lb b gy lh li l lj lk">import keras<br/>from keras.datasets import mnist<br/>from keras.layers import Dense<br/>from keras.models import Sequential<br/>from keras.optimizers import SGD</span><span id="ec8f" class="lf lg iq lb b gy ll li l lj lk">(train_x, train_y) , (test_x, test_y) = mnist.load_data()<br/>#train_x = train_x.astype('float32') / 255<br/>#test_x = test_x.astype('float32') / 255</span><span id="264f" class="lf lg iq lb b gy ll li l lj lk">print(train_x.shape)<br/>print(train_y.shape)<br/>print(test_x.shape)<br/>print(test_y.shape)</span><span id="23dc" class="lf lg iq lb b gy ll li l lj lk">train_x = train_x.reshape(60000,784)<br/>test_x = test_x.reshape(10000,784)</span><span id="66a9" class="lf lg iq lb b gy ll li l lj lk">train_y = keras.utils.to_categorical(train_y,10)<br/>test_y = keras.utils.to_categorical(test_y,10)</span><span id="1099" class="lf lg iq lb b gy ll li l lj lk">model = Sequential()<br/>model.add(Dense(units=128,activation="relu",input_shape=(784,)))<br/>model.add(Dense(units=128,activation="relu"))<br/>model.add(Dense(units=128,activation="relu"))<br/>model.add(Dense(units=10,activation="softmax"))</span><span id="5d06" class="lf lg iq lb b gy ll li l lj lk">model.compile(optimizer=SGD(0.001),loss="categorical_crossentropy",metrics=["accuracy"])<br/>model.load_weights("mnist-model.h5")<br/>#model.fit(train_x,train_y,batch_size=32,epochs=10,verbose=1)</span><span id="cbf5" class="lf lg iq lb b gy ll li l lj lk">#model.save("mnistmodel.h5")</span><span id="a89e" class="lf lg iq lb b gy ll li l lj lk">accuracy = model.evaluate(x=test_x,y=test_y,batch_size=32)</span><span id="236e" class="lf lg iq lb b gy ll li l lj lk">print("Accuracy: ",accuracy[1])</span></pre><p id="86b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在这里做的是从保存的模型文件中加载模型的参数，evaluate函数在测试数据集上运行预测，并返回我们预测的准确性。</p><p id="dcd9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，我已经演示了如何保存模型并在以后使用它们进行预测，然而，这都是些无聊的东西，真正的问题是能够加载特定的图像并确定它属于哪个类。</p><p id="9a39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一步是添加下面的代码，从测试中获得特定图像的预测</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="46fc" class="lf lg iq lb b gy lh li l lj lk">img = test_x[130]<br/>test_img = img.reshape((1,784))</span><span id="af26" class="lf lg iq lb b gy ll li l lj lk">img_class = model.predict_classes(test_img)<br/>prediction = img_class[0]</span><span id="95ce" class="lf lg iq lb b gy ll li l lj lk">classname = img_class[0]</span><span id="6dc1" class="lf lg iq lb b gy ll li l lj lk">print("Class: ",classname)</span></pre><p id="188e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们只是从测试集中选取一个随机图像，在这个例子中，在索引130处，我们创建一个展平的副本，它被整形为</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="cc4b" class="lf lg iq lb b gy lh li l lj lk">(1,784)</span></pre><p id="5987" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们把这个拷贝输入到我们的模型中，然后我们得到预测并打印出来。</p><p id="7487" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注释掉代码中的model.evaluate，添加上面的代码并运行它。</p><p id="a1ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您的输出应该是这样的:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="17ec" class="lf lg iq lb b gy lh li l lj lk">Class: 6</span></pre><p id="2cc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了预测，我们使用matplotlib来显示图像及其预测的类</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="02c8" class="lf lg iq lb b gy lh li l lj lk">img = img.reshape((28,28))<br/>plt.imshow(img)<br/>plt.title(classname)<br/>plt.show()</span></pre><p id="719a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的整形操作对于matplotlib显示图像是必要的</p><p id="9b88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您更新的代码应该都是这样的</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="7f10" class="lf lg iq lb b gy lh li l lj lk">import keras<br/>from keras.datasets import mnist<br/>from keras.layers import Dense<br/>from keras.models import Sequential<br/>from keras.optimizers import SGD<br/>import matplotlib.pyplot as plt<br/></span><span id="bb9c" class="lf lg iq lb b gy ll li l lj lk">(train_x, train_y) , (test_x, test_y) = mnist.load_data()</span><span id="8d37" class="lf lg iq lb b gy ll li l lj lk">train_x = train_x.reshape(60000,784)<br/>test_x = test_x.reshape(10000,784)</span><span id="0e66" class="lf lg iq lb b gy ll li l lj lk">train_y = keras.utils.to_categorical(train_y,10)<br/>test_y = keras.utils.to_categorical(test_y,10)</span><span id="3ea8" class="lf lg iq lb b gy ll li l lj lk">model = Sequential()<br/>model.add(Dense(units=128,activation="relu",input_shape=(784,)))<br/>model.add(Dense(units=128,activation="relu"))<br/>model.add(Dense(units=128,activation="relu"))<br/>model.add(Dense(units=10,activation="softmax"))</span><span id="f173" class="lf lg iq lb b gy ll li l lj lk">model.compile(optimizer=SGD(0.001),loss="categorical_crossentropy",metrics=["accuracy"])<br/>model.load_weights("mnistmodel.h5")</span><span id="4d5f" class="lf lg iq lb b gy ll li l lj lk">img = test_x[130]<br/>test_img = img.reshape((1,784))</span><span id="e112" class="lf lg iq lb b gy ll li l lj lk">img_class = model.predict_classes(test_img)<br/>prediction = img_class[0]</span><span id="b65c" class="lf lg iq lb b gy ll li l lj lk">classname = img_class[0]</span><span id="ddf1" class="lf lg iq lb b gy ll li l lj lk">print("Class: ",classname)</span><span id="5150" class="lf lg iq lb b gy ll li l lj lk">img = img.reshape((28,28))<br/>plt.imshow(img)<br/>plt.title(classname)<br/>plt.show()</span></pre><p id="17d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行这个，你的输出应该是这样的</p><p id="94c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！非常简单，我们已经建立了一个基本的数字识别系统。</p><p id="b4f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我鼓励您尝试测试图像的不同索引，亲自看看结果会是什么。</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/1d5e248fcb458a62caa44f3159793788.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*d75HPXy_ZDtN-EsUwUQa9w.png"/></div></figure><p id="9baf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如果我们想要引入一个不包含在测试集中的图像，对于这个测试，请将下面的图像保存到您的系统中，并将其复制到python文件所在的目录中。</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/d084aedb49060a7e6ab5fff2656f0eba.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*0D7K4JZNABjK2RMQyM5zVQ.png"/></div></figure><p id="9da3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行下面的代码</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="1410" class="lf lg iq lb b gy lh li l lj lk">import keras<br/>from keras.datasets import mnist<br/>from keras.layers import Dense<br/>from keras.models import Sequential<br/>from keras.optimizers import SGD<br/>import matplotlib.pyplot as plt<br/>from keras.preprocessing import image<br/></span><span id="4849" class="lf lg iq lb b gy ll li l lj lk">(train_x, train_y) , (test_x, test_y) = mnist.load_data()</span><span id="ce5b" class="lf lg iq lb b gy ll li l lj lk">train_x = train_x.reshape(60000,784)<br/>test_x = test_x.reshape(10000,784)</span><span id="61b8" class="lf lg iq lb b gy ll li l lj lk">train_y = keras.utils.to_categorical(train_y,10)<br/>test_y = keras.utils.to_categorical(test_y,10)</span><span id="7510" class="lf lg iq lb b gy ll li l lj lk">model = Sequential()<br/>model.add(Dense(units=128,activation="relu",input_shape=(784,)))<br/>model.add(Dense(units=128,activation="relu"))<br/>model.add(Dense(units=128,activation="relu"))<br/>model.add(Dense(units=10,activation="softmax"))</span><span id="3d5c" class="lf lg iq lb b gy ll li l lj lk">model.compile(optimizer=SGD(0.001),loss="categorical_crossentropy",metrics=["accuracy"])<br/>model.load_weights("mnistmodel.h5")</span><span id="6fe1" class="lf lg iq lb b gy ll li l lj lk">img = image.load_img(path="testimage.png",grayscale=True,target_size=(28,28,1))<br/>img = image.img_to_array(img)<br/>test_img = img.reshape((1,784))</span><span id="2e08" class="lf lg iq lb b gy ll li l lj lk">img_class = model.predict_classes(test_img)<br/>prediction = img_class[0]</span><span id="d214" class="lf lg iq lb b gy ll li l lj lk">classname = img_class[0]</span><span id="22f0" class="lf lg iq lb b gy ll li l lj lk">print("Class: ",classname)<br/>img = img.reshape((28,28))<br/>plt.imshow(img)<br/>plt.title(classname)<br/>plt.show()</span></pre><p id="af1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能会注意到一些新的东西，首先我们从keras.preprocessing导入图像</p><p id="3a4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来我们添加了</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="00dd" class="lf lg iq lb b gy lh li l lj lk">img = image.load_img(path="testimage.png",grayscale=True,target_size=(28,28,1))<br/>img = image.img_to_array(img)</span></pre><p id="ea34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第一行中，我们从磁盘加载图像，并指定它的大小应该调整为28 x 28 x 1，记住这是原始mnist图像的大小，所以我们保持不变是有好处的。</p><p id="225e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将图像转换成像素数组，就这样。</p><p id="a275" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行它并亲自检查结果，看预测值是否为3。</p><p id="7795" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">任何问题或评论请在下面的评论框中留下，你也可以通过twitter联系我，电话:<a class="ae lo" href="https://twitter.com/johnolafenwa" rel="noopener ugc nofollow" target="_blank"> @johnolafenwa </a></p><p id="f8bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢这个教程，给一些掌声。</p><p id="51e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一篇文章将是关于使用卷积神经网络，这将把我们的准确率提高到99%以上！！！保持联系就好。</p></div></div>    
</body>
</html>