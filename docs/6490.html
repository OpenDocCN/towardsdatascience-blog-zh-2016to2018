<html>
<head>
<title>Develop a NLP Model in Python &amp; Deploy It with Flask, Step by Step</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 开发一个 NLP 模型&amp;用 Flask 逐步部署它</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/develop-a-nlp-model-in-python-deploy-it-with-flask-step-by-step-744f3bdd7776?source=collection_archive---------1-----------------------#2018-12-16">https://towardsdatascience.com/develop-a-nlp-model-in-python-deploy-it-with-flask-step-by-step-744f3bdd7776?source=collection_archive---------1-----------------------#2018-12-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/4c8e92075aab30c74cb83df05750d6f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z-eijUGPqYQDBHutQ6sMYA.png"/></div></div></figure><div class=""/><div class=""><h2 id="fc23" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">Flask API，文档分类，垃圾邮件过滤器</h2></div><p id="500c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">到目前为止，我们已经开发了许多机器学习模型，根据测试数据生成数值预测，并测试结果。我们在网下做所有的事情。实际上，生成预测只是机器学习项目的一部分，尽管在我看来这是最重要的一部分。</p><p id="9f87" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">考虑使用机器学习来检测垃圾 SMS 文本消息的系统。我们的 ML 系统工作流程是这样的:离线训练-&gt;将模型作为服务提供-&gt;在线预测。</p><ul class=""><li id="5296" class="lm ln jb ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated">用垃圾邮件和非垃圾邮件消息离线训练分类器。</li><li id="0635" class="lm ln jb ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">经过训练的模型被部署为服务用户的服务。</li></ul><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ma"><img src="../Images/706eecd1678ba7349593ed1380e16c3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QverR-xExd4UvfLh3Iq79w.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">Figure 1</figcaption></figure><p id="ddc5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当我们开发一个机器学习模型时，我们需要考虑如何部署它，也就是如何让这个模型可供其他用户使用。</p><p id="55b9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae mj" href="https://www.kaggle.com/" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>和<a class="ae mj" href="https://www.cio.com/article/3051124/careers-staffing/10-boot-camps-to-kick-start-your-data-science-career.html" rel="noopener ugc nofollow" target="_blank">数据科学训练营</a>非常适合学习如何构建和优化模型，但它们不会教工程师如何将他们带到下一步，在这一步，构建模型和实际准备好让人们在他们的产品和服务中使用模型之间存在重大差异。</p><p id="5de6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在本文中，我们将关注这两个方面:为垃圾短信分类建立一个机器学习模型，然后使用用于构建 web 应用程序的 Python 微框架<a class="ae mj" href="http://flask.pocoo.org/" rel="noopener ugc nofollow" target="_blank"> Flask </a>为该模型创建一个 API。这个 API 允许我们通过 HTTP 请求利用预测能力。我们开始吧！</p><h1 id="b101" class="mk ml jb bd mm mn mo mp mq mr ms mt mu kh mv ki mw kk mx kl my kn mz ko na nb bi translated">ML 模型构建</h1><p id="558a" class="pw-post-body-paragraph kq kr jb ks b kt nc kc kv kw nd kf ky kz ne lb lc ld nf lf lg lh ng lj lk ll ij bi translated">这些数据是一组被标记为垃圾短信的短信，可以在这里找到。首先，我们将使用这个数据集来建立一个预测模型，该模型将准确地分类哪些文本是垃圾邮件。</p><p id="3fcd" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae mj" href="https://en.wikipedia.org/wiki/Naive_Bayes_spam_filtering" rel="noopener ugc nofollow" target="_blank">朴素贝叶斯分类器是一种流行的电子邮件过滤统计技术。他们通常使用单词包功能来识别垃圾邮件</a>。因此，我们将使用朴素贝叶斯定理构建一个简单的消息分类器。</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">NB_spam.py</figcaption></figure><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nj"><img src="../Images/427c09687a6c03951f046b8d6faf5c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xaqwi9YmbKZQ6iY8iPkRtA.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">Figure 2</figcaption></figure><p id="9f7e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">朴素贝叶斯分类器不仅易于实现，而且能提供非常好的结果。</p><p id="fa06" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在对模型进行训练之后，需要有一种方法来保存模型以供将来使用，而不必重新训练。为了实现这一点，我们添加了下面几行代码，将我们的模型保存为一个. pkl 文件，供以后使用。</p><pre class="mb mc md me gt nk nl nm nn aw no bi"><span id="31e6" class="np ml jb nl b gy nq nr l ns nt">from sklearn.externals import joblib<br/>joblib.dump(clf, 'NB_spam_model.pkl')</span></pre><p id="c47e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们可以像这样在以后加载和使用保存的模型:</p><pre class="mb mc md me gt nk nl nm nn aw no bi"><span id="86f3" class="np ml jb nl b gy nq nr l ns nt">NB_spam_model = open('NB_spam_model.pkl','rb')<br/>clf = joblib.load(NB_spam_model)</span></pre><p id="816d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">上述过程称为“以标准格式持久化模型”，即模型以特定于开发中语言的某种格式持久化。</p><p id="7a5d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">并且该模型将在微服务中提供服务，该微服务公开端点以接收来自客户端的请求。这是下一步。</p><h1 id="167d" class="mk ml jb bd mm mn mo mp mq mr ms mt mu kh mv ki mw kk mx kl my kn mz ko na nb bi translated">将垃圾邮件分类器转变为 Web 应用程序</h1><p id="d8d6" class="pw-post-body-paragraph kq kr jb ks b kt nc kc kv kw nd kf ky kz ne lb lc ld nf lf lg lh ng lj lk ll ij bi translated">在前面的部分中已经准备好了对 SMS 消息进行分类的代码，我们将开发一个 web 应用程序，它由一个简单的 web 页面组成，该页面带有一个表单字段，可以让我们输入消息。在将消息提交给 web 应用程序后，它将在一个新页面上呈现它，这给我们一个垃圾邮件或非垃圾邮件的结果。</p><p id="342e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">首先，我们为这个项目创建一个名为<code class="fe nu nv nw nl b">SMS-Message-Spam-Detector</code>的文件夹，这是文件夹中的目录树。我们将解释每个文件。</p><pre class="mb mc md me gt nk nl nm nn aw no bi"><span id="ea0a" class="np ml jb nl b gy nq nr l ns nt">spam.csv<br/>app.py<br/>templates/<br/>        home.html<br/>        result.html<br/>static/<br/>        style.css</span></pre><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nx"><img src="../Images/20c773480502c05328e0c6e484847385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*27jpgc1-1nYeFpnQKPSZeg.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">SMS-Message-Spam-Detector folder</figcaption></figure><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ny"><img src="../Images/2ba62f29dc4d3d496e81499ebace7cf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1-2TAD9vqf0zDrnnOY96lQ.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">templates folder</figcaption></figure><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nz"><img src="../Images/c56e45756486b219e541fe52282f1700.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fDryBnwqH7Vw1dcThPrAOA.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">static folder</figcaption></figure><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="oa ni l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">SMS Message Spam Detector folder</figcaption></figure><p id="6d53" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">子目录<code class="fe nu nv nw nl b">templates</code>是 Flask 在 web 浏览器中查找静态 html 文件的目录，在我们的例子中，我们有两个 HTML 文件:<code class="fe nu nv nw nl b">home.html</code>和<code class="fe nu nv nw nl b">result.html</code>。</p><h2 id="93fd" class="np ml jb bd mm ob oc dn mq od oe dp mu kz of og mw ld oh oi my lh oj ok na ol bi translated">app.py</h2><p id="7dd3" class="pw-post-body-paragraph kq kr jb ks b kt nc kc kv kw nd kf ky kz ne lb lc ld nf lf lg lh ng lj lk ll ij bi translated"><code class="fe nu nv nw nl b">app.py</code>文件包含了 Python 解释器运行 Flask web 应用程序所要执行的主要代码，它包含了对 SMS 消息进行分类的 ML 代码:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">app.py</figcaption></figure><ul class=""><li id="bac1" class="lm ln jb ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated">我们将应用程序作为一个单独的模块运行；因此，我们用参数<code class="fe nu nv nw nl b">__name__</code>初始化了一个新的 Flask 实例，让 Flask 知道它可以在它所在的同一个目录中找到 HTML 模板文件夹(<code class="fe nu nv nw nl b">templates</code>)。</li><li id="a364" class="lm ln jb ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">接下来，我们使用 route decorator ( <code class="fe nu nv nw nl b">@app.route('/')</code>)来指定应该触发<code class="fe nu nv nw nl b">home </code>函数执行的 URL。</li><li id="8a8b" class="lm ln jb ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">我们的<code class="fe nu nv nw nl b">home </code>函数只是呈现了位于<code class="fe nu nv nw nl b">templates</code>文件夹中的<code class="fe nu nv nw nl b">home.html</code> HTML 文件。</li><li id="d494" class="lm ln jb ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">在<code class="fe nu nv nw nl b">predict</code>函数中，我们访问垃圾邮件数据集，预处理文本，进行预测，然后存储模型。我们访问用户输入的新消息，并使用我们的模型对其标签进行预测。</li><li id="2e3c" class="lm ln jb ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">我们使用<code class="fe nu nv nw nl b">POST</code>方法在消息体中将表单数据传输到服务器。最后，通过在<code class="fe nu nv nw nl b">app.run</code>方法中设置<code class="fe nu nv nw nl b">debug=True</code>参数，我们进一步激活了 Flask 的调试器。</li><li id="e33a" class="lm ln jb ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">最后，我们使用了<code class="fe nu nv nw nl b">run</code>函数，仅在 Python 解释器直接执行该脚本时在服务器上运行应用程序，这是通过使用带有<code class="fe nu nv nw nl b"> __name__ == '__main__'</code>的<code class="fe nu nv nw nl b">if</code>语句来确保的。</li></ul><h2 id="b731" class="np ml jb bd mm ob oc dn mq od oe dp mu kz of og mw ld oh oi my lh oj ok na ol bi translated">home.html</h2><p id="aff3" class="pw-post-body-paragraph kq kr jb ks b kt nc kc kv kw nd kf ky kz ne lb lc ld nf lf lg lh ng lj lk ll ij bi translated">以下是<code class="fe nu nv nw nl b">home.html</code>文件的内容，该文件将呈现一个文本表单，用户可以在其中输入消息:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">home.html</figcaption></figure><h2 id="aa77" class="np ml jb bd mm ob oc dn mq od oe dp mu kz of og mw ld oh oi my lh oj ok na ol bi translated">style.css</h2><p id="a1f3" class="pw-post-body-paragraph kq kr jb ks b kt nc kc kv kw nd kf ky kz ne lb lc ld nf lf lg lh ng lj lk ll ij bi translated">在<code class="fe nu nv nw nl b">home.html</code>的头段，我们加载了<code class="fe nu nv nw nl b">styles.css</code>文件。CSS 决定了 HTML 文档的外观和感觉。<code class="fe nu nv nw nl b">styles.css</code>必须保存在一个名为<code class="fe nu nv nw nl b">static</code>的子目录中，这是默认目录，Flask 会在这个目录中查找 CSS 等静态文件。</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">style.css</figcaption></figure><h2 id="9312" class="np ml jb bd mm ob oc dn mq od oe dp mu kz of og mw ld oh oi my lh oj ok na ol bi translated">result.html</h2><p id="bc7e" class="pw-post-body-paragraph kq kr jb ks b kt nc kc kv kw nd kf ky kz ne lb lc ld nf lf lg lh ng lj lk ll ij bi translated">我们创建一个<code class="fe nu nv nw nl b">result.html</code>文件，该文件将通过<code class="fe nu nv nw nl b">predict</code>函数中的<code class="fe nu nv nw nl b">render_template('result.html', prediction=my_prediction)</code>行返回来呈现，我们在<code class="fe nu nv nw nl b">app.py</code>脚本中定义该函数来显示用户通过文本字段提交的文本。<code class="fe nu nv nw nl b">result.html</code>文件包含以下内容:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">result.html</figcaption></figure><p id="6245" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">从<code class="fe nu nv nw nl b">result.htm</code>我们可以看到一些代码使用了 HTML 文件中通常没有的语法:<code class="fe nu nv nw nl b">{% if prediction ==1%},{% elif prediction == 0%},{% endif %}</code>这是<a class="ae mj" href="http://jinja.pocoo.org/docs/2.10/templates/" rel="noopener ugc nofollow" target="_blank"> jinja </a>语法，它用于在 HTML 文件中访问从我们的 HTTP 请求返回的预测。</p><p id="e5c6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们快到了！</p><p id="0288" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">完成上述所有操作后，您可以通过双击<code class="fe nu nv nw nl b">appy.py</code>或从终端执行命令来开始运行 API:</p><pre class="mb mc md me gt nk nl nm nn aw no bi"><span id="77a9" class="np ml jb nl b gy nq nr l ns nt">cd SMS-Message-Spam-Detector<br/>python app.py</span></pre><p id="4159" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">您应该得到以下输出:</p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi om"><img src="../Images/d652b5b631c726f37477b498d9298199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8SENYW08bh7JVtpvqDcOEQ.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">Figure 3</figcaption></figure><p id="3c12" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在，您可以打开 web 浏览器并导航到<a class="ae mj" href="http://127.0.0.1:5000/" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:5000/ </a>，我们应该会看到一个简单的网站，内容如下:</p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi on"><img src="../Images/e8252dff0879f6d3eee41d2c0e07c10f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z_tb_WXsgQp6hDsvwY8p2Q.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">Figure 4</figcaption></figure><p id="a864" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">让我们测试我们的工作！</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="oa ni l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">spam_detector_app</figcaption></figure><p id="921a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">恭喜你！我们现在已经以零成本创建了一个端到端的机器学习(NLP)应用。回过头来看，整体流程一点都不复杂。只要有一点耐心和学习的欲望，任何人都可以做到。所有的开源工具让一切成为可能。</p><p id="094c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">更重要的是，我们能够将我们的机器学习理论知识扩展到一个有用和实用的 web 应用程序，并让我们能够向外界提供我们的垃圾短信分类器！</p><p id="08e3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">完整的工作源代码可以在这个<a class="ae mj" href="https://github.com/susanli2016/SMS-Message-Spam-Detector" rel="noopener ugc nofollow" target="_blank">库</a>获得。祝你一周愉快！</p><p id="7ee2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">参考:</p><p id="f41b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">本书:<a class="ae mj" href="https://www.amazon.ca/Python-Machine-Learning-Sebastian-Raschka/dp/1787125939/ref=dp_ob_title_bk" rel="noopener ugc nofollow" target="_blank"> Python 机器学习</a></p></div></div>    
</body>
</html>