<html>
<head>
<title>Clean your data with unsupervised machine learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用无监督的机器学习清理您的数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/clean-your-data-with-unsupervised-machine-learning-8491af733595?source=collection_archive---------5-----------------------#2018-12-01">https://towardsdatascience.com/clean-your-data-with-unsupervised-machine-learning-8491af733595?source=collection_archive---------5-----------------------#2018-12-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7cb8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">清理数据不一定是痛苦的！这篇文章是一个快速的例子，展示了如何使用无监督的机器学习来清理堆积如山的杂乱的文本数据，使用现实生活中的数据。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c9d121ef2d432b0c681baf8a259599bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m8aUECb1-y5xjky17K_McA.jpeg"/></div></div></figure><h2 id="b3c6" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">我们在对付什么？</h2><p id="cd85" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">在这个例子中，我们面对的是从 HMTL 和 PDF 文件中抓取的数千篇文本文章。返回文本的质量在很大程度上取决于抓取过程。从抽样检查的一些结果中，我们知道存在从坏链接、不可读的 pdf 到已经成功读入的项目的问题，但内容本身完全是垃圾。</p><p id="b1d6" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">与公司现代奴隶制相关的文章从这个数据库返回:<a class="ae ml" href="https://www.modernslaveryregistry.org/" rel="noopener ugc nofollow" target="_blank">https://www.modernslaveryregistry.org/</a></p><p id="e705" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">这些现在存在于 Pandas 数据框中，每一项都有“元数据”,如公司名称和出版年份，以及从回复中提取的文本:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mm"><img src="../Images/6d3540651dfaae44990b9e0bcb6ccded.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V0A1iKwIdUv5DphHgb9fGw.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">This is the starting point — the text data is the last column in the data frame</figcaption></figure><h2 id="822b" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">快速题外话:错过没有</h2><p id="9f0b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">python Missingno 包超级有用。它可以用 4 行代码在数据框上<strong class="lp ir">安装和运行，如果数据框中有任何缺失信息，它会快速突出显示。它还能够对数据集中的行进行采样，因此可以轻松处理非常大的数据帧。</strong></p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="1af3" class="kr ks iq ms b gy mw mx l my mz">!conda install -c conda-forge missingno — y<br/>import missingno as msno<br/>%matplotlib inline<br/>msno.matrix(combined.sample(250)) #combined is the df</span></pre><p id="090c" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">在我们的数据框上运行这个程序，显示出除了一列之外，数据是完整的。由于我们不使用它进行分析，所以不需要做进一步的工作，但是如果在其他区域有缺口，我们必须考虑如何最好地处理这些缺口(例如删除这些行或尝试估算缺失值)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/c603833a4a68bc31757e87bd6fa12098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d1gnTrxlIBWrLpHDmmRMOw.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">The chart shows all but one column are complete — we can now focus on our text data</figcaption></figure><h2 id="8904" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">…回到清理文本数据</h2><p id="cfdd" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">浏览数据框中的文本显然存在问题。例如，读取此项目中的 PDF 文件时出现问题:</p><blockquote class="nb nc nd"><p id="2792" class="ln lo ne lp b lq mg jr ls lt mh ju lv nf mi lx ly ng mj ma mb nh mk md me mf ij bi translated">CMR644311ABP 英国现代奴隶制声明 2017 年 9 月)ABP 英国现代奴隶制声明 2017 年 9 月 ABP 英国现代奴隶制声明 2017 年 9 月 AABP 英国现代奴隶制声明 2017 年 9 月 bABP…..</p></blockquote><p id="1721" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">这个看起来更糟:</p><blockquote class="nb nc nd"><p id="82ea" class="ln lo ne lp b lq mg jr ls lt mh ju lv nf mi lx ly ng mj ma mb nh mk md me mf ij bi translated">！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！"#!)*%!+!,(-&amp;*(#!。/&amp;0#&amp;-*!！1!！2–34!5!5/6!！1!！7–8(&amp;9%!！1!！7:;！&lt;=&gt;！.3–8(%&amp;-*($9!！！！！！！！！！！！！！学术界有限公司现代奴隶制合规状态。</p></blockquote><p id="22c8" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">这些显然是无法修复的——但是我们如何将它们从正确读取的文本文件中分离出来呢？</p><h2 id="3164" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">机器学习拯救世界</h2><p id="f0fc" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">我们可能会花费大量时间试图从真实数据中分离出这些损坏的信息，但这正是机器学习的亮点。希望我们可以用它来发现数据中的模式，并自动将其聚类成干净和杂乱的数据，从而节省大量工作。使用 Python，只需三个步骤就能快速轻松地完成这项工作:</p><p id="b5cd" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">第一步。为算法创建特征:</strong></p><p id="11b7" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">以下代码将单词计数、字符计数和唯一单词数作为新列显示在我们的数据框中:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="b12a" class="kr ks iq ms b gy mw mx l my mz">#The data frame is called 'combined'<br/>def uniqueWords(X):<br/>    X = X.split(' ')<br/>    X = set(X)<br/>    X = len(X)<br/>    return X</span><span id="8766" class="kr ks iq ms b gy ni mx l my mz">combined['charCount']   = combined['text'].str.len()<br/>combined['wordCount']   = combined['text'].str.split(' ').str.len()<br/>combined['uniqueWords'] = combined['text'].apply(uniqueWords)</span></pre><p id="5e6a" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">第二步。将数据可视化:</strong></p><p id="4e2d" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">使用 Spotify 真正优秀的图表库，<strong class="lp ir"> Chartify，</strong>我们可以使用我们刚刚创建的新功能快速绘制数据图表:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="00cc" class="kr ks iq ms b gy mw mx l my mz">ch = chartify.Chart(blank_labels=True)<br/>ch.plot.scatter(<br/>    data_frame=combined,<br/>    x_column='wordCount',<br/>    y_column='uniqueWords',<br/>    size_column='charCount',<br/>    alpha = 0.3)<br/>ch.set_title("Text data quality")<br/>ch.set_subtitle("Size is the character count")<br/>ch.axes.set_yaxis_label('Unique words')<br/>ch.axes.set_xaxis_label('Total words')<br/>ch.show()</span></pre><p id="575f" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">这个图表告诉我们大量关于数据集的信息。有明显的词、字、独字增多的趋势。这是意料之中的，但是在这下面还有一大串项目，在底部有一行项目，它们的字数很少，但是字符数很高:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/576f98abc3c9f2096d61282a04296f8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rlP5e0i0TR59_Kp8246f5Q.png"/></div></div></figure><p id="b70d" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">第三步。创建集群:</strong></p><p id="0673" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">通过使用机器学习对数据进行聚类，我们应该能够自动分割出我们在图表中看到的每个区域，并进一步研究这些区域。以下代码缩放数据，然后对其应用 K-Means 聚类:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="57f4" class="kr ks iq ms b gy mw mx l my mz">from sklearn.cluster import KMeans<br/>from sklearn.preprocessing import StandardScaler</span><span id="1d3a" class="kr ks iq ms b gy ni mx l my mz">#The data frame is called 'combined'<br/>X = combined[['charCount','wordCount','uniqueWords']]<br/>scaler = StandardScaler()<br/>X = scaler.fit_transform(X)<br/>kmeans = KMeans(n_clusters=7, random_state=0).fit(X)<br/>combined['Cluster'] = kmeans.labels_</span></pre><p id="40e6" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">再次运行我们的观想，我们得到以下结果:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="21da" class="kr ks iq ms b gy mw mx l my mz"># Overview<br/>ch = chartify.Chart(blank_labels=True)<br/>ch.plot.scatter(<br/>    data_frame=combined,<br/>    x_column='wordCount',<br/>    y_column='uniqueWords',<br/>    size_column='charCount',<br/>    alpha = 0.3,<br/>    color_column='Cluster')<br/>ch.set_title("7 clusters help to split out issues")<br/>ch.set_subtitle("Color represents each cluster, size is the character count")<br/>ch.axes.set_yaxis_label('Unique words')<br/>ch.axes.set_xaxis_label('Total words')<br/>ch.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/6b9352867ddc0fab9cbc6367f1cec529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oEuQW8kjTkHVbnnhnvATcA.png"/></div></div></figure><p id="c25d" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">这在划分问题领域方面做得很好。看起来集群 1、4 和 5 需要一些进一步的调查。在此之前，让我们放大图表的左下方，以确保聚类仍在此处工作，因为在当前图中很难看到:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/bfb3f7fa3336a843e617510ef2aa6756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AkzMQnMo8NGhiSlpNv7Dcg.png"/></div></div></figure><p id="851a" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">魔法；即使在点之间有重叠的地方，该算法也足够健壮，能够仅基于字符数来区分它们。</p><p id="fbb0" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">为什么我们决定选择 7 个集群？反复试验。7 是仍然以有效方式分割数据集的最小数字。</p><h2 id="e18e" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">检查结果</h2><p id="13cb" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">这一切看起来很棒，但是我们真的实现了我们设定的目标吗？我们可以通过检查每个集群中的内容来检查这一点，特别是集群 1、4 和 5。</p><p id="562d" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">卡斯特 1:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="b98a" class="kr ks iq ms b gy mw mx l my mz">#locate cluster 1 and return the text column as a list:<br/>combined.loc[combined[‘Cluster’]==1].text.values</span><span id="3fd4" class="kr ks iq ms b gy ni mx l my mz">returns:<br/>3M United Kingdom PLC: modern slavery statement. This statement has been published in accordance with the provisions of the Modern Slavery Act 2015. It sets out the steps taken by 3M United Kingdom PLC ending 31 December 2016 to prevent modern slavery and human trafficking in its business and supply chains. Introduction from Christiane Gruen, Managing Director of 3M UK.  We, as an organisation, are proud of the steps we have taken, and continue to take, to combat slavery and human trafficking. Global Human Rights Policy was adopted in 2013...</span></pre><p id="f25c" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">这很有趣，文本在这里看起来完全没问题。上面的例子来自 3M，但其他返回区域也是干净的。因此，聚类 1 是从现代奴隶制陈述中获得的真实数据的一部分，而不是较差的数据质量。当我们进一步分析数据时，我们希望研究为什么这个集群存在</p><p id="dbc8" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">群组 4 和 5:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="91a2" class="kr ks iq ms b gy mw mx l my mz">#locate cluster 4 and 5 and return the text column as a list:<br/>combined.loc[(combined['Cluster']==4) | (combined['Cluster']==5)].text.values</span><span id="6f91" class="kr ks iq ms b gy ni mx l my mz">returns:<br/>...UK MODERNSLAVERY ACTStatement for the financial year ending 31 December 2016lUK MODERNSLAVERY ACTStatement for the financial year ending 31 December 2016oUK MODERNSLAVERY ACTStatement for the financial year ending 31 December 2016yUK MODERNSLAVERY ACTStatement for the financial year ending 31 December 2016eUK MODERNSLAVERY ACTStatement for the financial year ending 31 December 2016eUK MODERNSLAVERY ACTStatement for the financial year ending 31 December 2016sUK MODERNSLAVERY ACTStatement for the financial year ending 31 December 2016 UK MODERNSLAVERY ACTStatement for the financial year ending 31 December 2016aUK MODERNSLAVERY ACTStatement for the financial year ending 31 December 2016n...</span></pre><p id="f184" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">这是我们杂乱的数据。令人印象深刻的是，即使单个单词有意义，该算法也足够智能，可以正确地对上面的例子进行聚类。</p><p id="8e8f" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">我们现在需要做的就是从数据集中排除这些聚类，然后继续分析一组漂亮、干净的数据。</p></div></div>    
</body>
</html>