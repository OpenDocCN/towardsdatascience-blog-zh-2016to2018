<html>
<head>
<title>Conway’s Game Of Life in Blender</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">康威在搅拌机中的生活游戏</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/conways-game-of-life-in-blender-6dd84cd22fa1?source=collection_archive---------3-----------------------#2017-07-08">https://towardsdatascience.com/conways-game-of-life-in-blender-6dd84cd22fa1?source=collection_archive---------3-----------------------#2017-07-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c64a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">《生命的游戏》( GOL)可能是细胞自动机最臭名昭著的例子之一。</p><p id="8a0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由数学家约翰·何顿·康威定义，它在一个二维网格上展开，每个细胞可以处于两种可能状态中的一种。从初始网格配置开始，系统在每个单元步骤中仅考虑前一个配置。如果对于每个小区，我们将周围的八个小区视为<em class="km">邻居</em>，则系统转换由<a class="ae kl" href="https://en.wikipedia.org/wiki/Conway's_Game_of_Life#Rules" rel="noopener ugc nofollow" target="_blank">四个简单规则</a>定义。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kn"><img src="../Images/32522d9ad86fc3373e323c30c2fd8c6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*HuS0jfHc6D1GI_QljmWQxQ.gif"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">A basic plain-2D example</figcaption></figure><p id="f50c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我对用 Blender 探索这种现象的可视化很感兴趣。以下是一些实验结果。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="kz la l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">25x25 Cubes Grid with shrinking update function</figcaption></figure><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="kz la l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">20x20 Ico-Spheres Grid with shrinking update function</figcaption></figure><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="kz la l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">40x40 Cubes Grid with hiding update function</figcaption></figure><p id="b275" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/5agado/data-science-learning/tree/master/cellular%20automata" rel="noopener ugc nofollow" target="_blank">这里的代码如果有人感兴趣</a>。这是一个可重用的脚本，你可以直接在 Blender 脚本界面中导入和运行。它定义了 GOL 逻辑，并将 GOL 网格到 Blender 的移植分解为两个可定制的组件:</p><ul class=""><li id="322a" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated"><strong class="jp ir">生成器</strong>—负责生成将被映射到原始 GOL 网格中的单元格的 Blender 对象。一个生成器被精确地用来建立初始的混合网格，并带有首选的网格(例子:立方体，球体，猴子)。</li><li id="4136" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir">更新器</strong> —基于 GOL 网格值定义 Blender 对象的更新行为。应该根据相应的网格值是 0 还是 1 来指定对象的变化(例如:缩放、隐藏)。</li></ul><p id="62fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">剩下的只是注册更新处理程序的帮助器代码，这样一个帧的改变会导致 GOL 网格的更新(可能包括关键帧)。<br/>我建议一旦你得到你喜欢的结果就删除处理程序，这样额外的帧变化就不会再次触发更新并破坏你的结果。</p><h2 id="565f" class="lp lq iq bd lr ls lt dn lu lv lw dp lx jy ly lz ma kc mb mc md kg me mf mg mh bi translated">3D 版本</h2><p id="6552" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">我还试验了一个三维网格，它使用相同的规则集，同时将邻居的数量扩展到新的维度。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="e27e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我计划更深入地研究 3D 概念，以找到更稳定的配置。另一个有趣的改进是拥有不受约束的网格，这意味着从初始配置开始的自动机可以在空间中无限增长。对于这种方法，我不得不重新制定我目前的代码逻辑，可能首先用一些替代 Blender 的方法进行实验，因为这里的家伙消耗了大量的资源，即使是这些简单的渲染，所以这方面的任何建议都是非常受欢迎的！</p><h2 id="cfe6" class="lp lq iq bd lr ls lt dn lu lv lw dp lx jy ly lz ma kc mb mc md kg me mf mg mh bi translated">离题</h2><p id="e926" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">玩这些细胞自动机的可视化在我的脑海中引发了像因果关系/目的论和<a class="ae kl" href="http://www.gregegan.net/PERMUTATION/FAQ/FAQ.html" rel="noopener ugc nofollow" target="_blank">尘埃理论</a>这样的概念。所有系统状态都是确定性定义的，但只能根据前一时间步的状态进行计算。有了缩放/收缩功能，系统的行为方式与其他类型的更新功能完全相同，改变的是单元相对于系统状态的行为。一个细胞在外力的作用下会立即收缩，以反映一个等于零的状态，但随后会随着自由意志的幻觉而进化到一个完整大小的新状态。实际上，这种增长只不过是关键帧填充。不是一个细胞的故事决定了它的未来，而是系统的未来决定了所有细胞生命的故事。</p></div></div>    
</body>
</html>