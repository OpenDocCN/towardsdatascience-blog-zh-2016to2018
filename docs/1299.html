<html>
<head>
<title>COUNTLESS — High Performance 2x Downsampling of Labeled Images Using Python and Numpy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无数—使用Python和Numpy对标签图像进行高性能2倍缩减采样</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/countless-high-performance-2x-downsampling-of-labeled-images-using-python-and-numpy-e70ad3275589?source=collection_archive---------4-----------------------#2017-08-21">https://towardsdatascience.com/countless-high-performance-2x-downsampling-of-labeled-images-using-python-and-numpy-e70ad3275589?source=collection_archive---------4-----------------------#2017-08-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/61597ee525bdcbe327cfbdb69cb3a4fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Z-0WR0nX_hTCuAtDuQUvQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 1. A partial of a slice of <a class="ae kc" href="http://brainiac2.mit.edu/SNEMI3D/home" rel="noopener ugc nofollow" target="_blank">SNEMI3D</a>, a machine learning contest dataset for neuroscience.</figcaption></figure><p id="91d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">管理terravoxel图像上的convnet输出通常涉及生成可在廉价硬件上更容易下载、显示和处理的摘要图像。对普通照片或显微镜图像进行下采样的常用方法是在图像上定义一个窗口，然后应用averaging或lanczos3 (sinc)等过滤器将窗口内容汇总到一个较小的像素集中。这些混合方法不适用于分段标签。一组分割标签的下采样必须包含来自输入图像的实际像素值，因为标签是分类的，混合标签是无意义的。如果标记为1的像素指的是汽车，标记为3的像素指的是鸟，那么这两个像素的平均值(2指的是人)就不是底层图像的忠实表示。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="6df0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，下采样分类标签包括在图像上定义窗口并从该块中选择样本。一种常见的方法是通过在块中最频繁的像素中挑选来选择样本，也称为寻找模式。实现这一点最明显的方法是计算每个标签的频率，这在C等高性能语言中很容易实现。然而，Python循环非常慢，这使得这种方法在不使用C扩展(Cython)的情况下无法实现，这使得项目维护起来更加麻烦，并且需要专业知识。在这里，我给出了一个方法neutrally，它计算四个无符号整数的模，同时给出了一个Numpy实现，用于生成标签图像的2x缩减采样。</p><h1 id="b09c" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">无数算法</h1><p id="1548" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">要解决的最简单的2D下采样问题是4像素2x2图像。2x2图像可以通过其最常见的单个像素来概括，以在每一侧实现2倍的缩减。现在坚持使用均匀大小的图像，一个较大的图像可以被分成2×2的块，如果这个过程在每个块上独立重复，这将导致整个图像整体缩小2倍。</p><p id="665f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2x2图像由图1中列出的五个问题组成。在1(a)、1(c)和1(e)中，所有像素都在最频繁的类别中，因此是有效的解决方案。1(b)和1(d)需要更复杂的方法。值得注意的是，在所有五种情况下，选择随机像素更有可能是大多数，这表明为什么大步走可以是一种可接受的，尽管不是完美的方法。形成该算法基础的关键见解是，在所有情况下，如果两个像素匹配，则它们占多数。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/26cccb9f0b7e6774aa0e40583cc95a7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h4Vw1p1sMgeFM_nPkHSE4w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 2. The Five Cases. Capital letters A,B,C,D refer to the identity of a non-zero pixel. (a) All the same. (b) Two the same. (c) Two pairs the same. (d) Three the same. (e) All different.</figcaption></figure><p id="7b71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下文中，大写字母A、B、C、D指的是像素位置的非零值。我们定义了比较操作符PICK(A，B ),它生成一个实像素值或零。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="39f5" class="mv lj iq mr b gy mw mx l my mz">PICK(A,B) := A if A == B else 0                             EQN. 1</span></pre><p id="0f4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Python/numpy这样的框架中，True和False分别表示为1和0，这可以用数字实现为:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="99df" class="mv lj iq mr b gy mw mx l my mz">PICK(A,B) := A * (A == B)                                   EQN. 2</span></pre><p id="0c2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们考虑A、B和c之间的各种相互作用。在下表中，符号AB表示PICK(A，B ),小写字母表示特定值，因此两列中重复的字母“A”表示两个像素都是红色。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="2694" class="mv lj iq mr b gy mw mx l my mz">Pixel    PICK(X,Y)<br/>A B C    AB BC AC<br/>a a a =&gt; a  a  a<br/>a b a =&gt; 0  0  a<br/>a a b =&gt; a  0  0<br/>b a a =&gt; 0  a  0<br/>a b c =&gt; 0  0  0  &lt;-- Only fully zeroed row</span><span id="cefb" class="mv lj iq mr b gy na mx l my mz">TABLE 1. PICK(X,Y) (denoted XY) interactions between A, B, and C</span></pre><p id="5c4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">表1显示A、B和C中仅有的多数像素或零点将作为拾取操作的结果出现。在A、B和C都不相同的情况下，所有选择都将返回零。这使得像素选择的问题服从于简单的逻辑。a、B和C都不同，对应于图1中的情况1(b)或1(e ),在1(b)的情况中D占大多数。如果情况是1(b)，这意味着D是一个可接受的解决方案。如果情况是1(e)，则不存在多数像素，D也是可接受的解决方案。</p><p id="aea1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，当A、B或C匹配时，选择匹配项，当它们都不匹配时，选择d。这可以在计算机语言中用短路逻辑OR (||)表示为:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="ce3d" class="mv lj iq mr b gy mw mx l my mz">MODE(A,B,C,D) := PICK(A,B) || PICK(B,C) || PICK(A,C) || D   EQN. 3</span></pre><p id="fe73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将逻辑或数字实现为:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="0967" class="mv lj iq mr b gy mw mx l my mz">LOGICAL_OR(X,Y) := X + (X == 0) * Y                          EQN. 4</span></pre><p id="e247" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">EQN。3和EQN。4将正确处理除零以外的所有无符号整数值。因此，在零是有效像素的情况下，我们可以在算法开始时给图像加一，然后在返回结果之前减一。</p><p id="2f39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2x2方法可以很容易地扩展到覆盖任何偶数尺寸的图像。只需用不重叠的2x2块覆盖图像，并求解每个块中的模式，即可生成缩减采样图像。然而，我们仍然必须处理奇数图像，其中边缘没有被2x2块完全覆盖。</p><p id="2b34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，有一个简单的解决方案。对于任何奇数图像，镜像边缘以生成偶数图像。有两种情况:角(1x1)和边(2x1或1x2)。镜像一个角将产生情况1(a ),这将导致绘制相同的像素。镜像一条边将导致情况1(a )(如果像素相同)或者情况1(c ),这两种情况都将被无数个正确处理。</p><h1 id="8ce4" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">履行</h1><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/fe336d9f41ab657c34207a44facf2ae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cjNwx5j6bpNIp9AcIhXnkQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 3. Results of applying COUNTLESS. (a) A source image of 128 x 128 pixels is reduced to (b) an image of 64 x 64 pixels.</figcaption></figure><p id="5137" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Numpy中无数的实现是简单明了的。首先，图像必须被分成2×2块的覆盖。这可以通过创建四个2D数组a、b、c和d来表示，每个数组在概念上表示图1中与其同名的像素，但在图像中的每个2x2块上并行执行。这是通过从左上角跨越(2，2)偏移(0，0)、(0，1)、(1，0)和(1，1)来实现的。接下来，我们开始用无数的。Numpy不支持逻辑OR，但它支持按位OR。幸运的是，根据表1，从PICK(A，B)、PICK(A，C)和PICK(B，C)得到的值要么是单个值，可能是重复值，要么为零。因此，在这种特殊情况下，按位“或”的行为与逻辑“或”相同，为我们节省了一些在EQN中需要的运算。4.清单1展示了实现:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Listing 1. The simplest implementation of countless that doesn’t handle black pixels.</figcaption></figure><p id="9c0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种实现适用于大多数情况，但是它有一个重要的故障模式。如果匹配像素为零，我们将意外地选择D，因为结果看起来与表1中的最后一行相同。不幸的是，当使用有限整数表示时，这个问题无法完全消除，但是我们可以非常接近。</p><p id="751a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">策略是在执行无数次之前给图像加一，之后减一。这会将0变成1，并使算法正确工作，但它会导致最大值整数溢出(uint 8为255，uint16为65，535，依此类推)。但是，在添加数据类型之前转换为下一个最大的数据类型可以消除溢出效应(例如，将uint8数组转换为uint16)。在目前的硬件上，这种方法在uint64以下是可行的。uint8、uint16、uint32完全消除了零点问题，但uint64没有。这意味着，如果您的标注包含大约为1.84 x 10 ⁹.的2⁶⁴-1，该算法将会失败对于许多用途，这应该是可以接受的。减去一后强制转换回原始数据类型。对于将最大uint64视为特殊标志的编码方案，只需充分改变偏移量即可。</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Listing 2. zero_corrected_countless.py: simplest_countless.py updated to handle black pixels correctly.</figcaption></figure><p id="aa95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一件事，我们添加了一些操作来解决零标签问题，但是这会影响性能。我们可以通过注意到<em class="ne"> ab </em>和<em class="ne"> ac </em>都乘以<em class="ne"> a来恢复其中的一部分。</em></p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Listing 3. zero_corrected_countless.py augmented with an algebraic simplification to slightly improve performance.</figcaption></figure><h1 id="b6fe" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">表演</h1><p id="997d" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">为了确定这种算法的速度，我们开发了一个比较套件，并在双核2.8 GHz、i7 Macbook Pro(大约2014年)、256 kB L2高速缓存和4MB三级高速缓存上运行。虽然该算法是为分割标签开发的，但普通照片也包括在内，以展示当数据不均匀时该算法如何执行。最大汇集、平均和大步跑包括在速度比较中，尽管它们不适合这项任务。</p><p id="f056" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我用Python 3.6.2配合numpy-1.13.3和clang-802.0.42做了以下实验。</p><p id="924a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">经过测试的算法:</p><ul class=""><li id="0593" class="nf ng iq kf b kg kh kk kl ko nh ks ni kw nj la nk nl nm nn bi translated"><strong class="kf ir">大步走:</strong>每隔一个像素拾取一次。</li><li id="8153" class="nf ng iq kf b kg no kk np ko nq ks nr kw ns la nk nl nm nn bi translated"><strong class="kf ir">统计:</strong>统计每个标签出现的频率。</li><li id="9c74" class="nf ng iq kf b kg no kk np ko nq ks nr kw ns la nk nl nm nn bi translated"><strong class="kf ir">最简单_无数:</strong>最简单_无数. py</li><li id="fd17" class="nf ng iq kf b kg no kk np ko nq ks nr kw ns la nk nl nm nn bi translated"><strong class="kf ir">快速_无数:</strong>最简单_无数. py +代数化简</li><li id="83b7" class="nf ng iq kf b kg no kk np ko nq ks nr kw ns la nk nl nm nn bi translated"><strong class="kf ir">零_校正_无数:</strong>零_校正_无数. py</li><li id="f714" class="nf ng iq kf b kg no kk np ko nq ks nr kw ns la nk nl nm nn bi translated"><strong class="kf ir">无数:</strong>无数. py</li><li id="23f7" class="nf ng iq kf b kg no kk np ko nq ks nr kw ns la nk nl nm nn bi translated"><strong class="kf ir">无数_if: </strong>用if语句代替花里胡哨的把戏</li></ul><p id="7605" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管这些算法不适合处理分割，但也对它们进行了测试，以便为其他图像处理算法提供比较点:</p><ul class=""><li id="f04e" class="nf ng iq kf b kg kh kk kl ko nh ks ni kw nj la nk nl nm nn bi translated"><strong class="kf ir">down sample _ with _ averaging:</strong>对2x2窗口中的像素进行平均。</li><li id="28e3" class="nf ng iq kf b kg no kk np ko nq ks nr kw ns la nk nl nm nn bi translated"><strong class="kf ir">down sample _ with _ max _ pooling:</strong>在2x2窗口中选取最高值像素。</li><li id="7424" class="nf ng iq kf b kg no kk np ko nq ks nr kw ns la nk nl nm nn bi translated"><strong class="kf ir"> ndzoom: </strong>使用scipy函数ndimage.interpolation.zoom缩小到2x2。</li></ul><p id="360e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用于测试算法的代码可以在<a class="ae kc" href="https://github.com/william-silversmith/countless" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="e50e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章发表后<a class="ae kc" href="https://github.com/zlateski" rel="noopener ugc nofollow" target="_blank"> Aleks Zlateski </a>贡献了一个骑士登陆(KNL)的矢量化版本bitwise neutrally，据报道在随机int32数据上运行速度为1 GPx/sec，4 GB/sec。可以在<a class="ae kc" href="https://github.com/william-silversmith/countless" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p><h1 id="e149" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">试验1–神经组织的分割</h1><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/8754cd8cc2e3f3e04a9292bec0c85043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a0eLS56SVP0HA0S0IQ-Cjg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 4. Integer labels representing a segmentation of a neural tissue micrograph.</figcaption></figure><p id="011e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">RGB分割是由卷积神经网络分配的像素标签的1024x1024图像，有趣地看着神经组织。这是无数在设计时就考虑到的那种形象<em class="ne">。每个像素是一个RGB三元组，合起来表示一个无符号整数。比如，(R，G，B): (15，1，0)代表271 (15 + 1 * 256)。</em></p><p id="4ff2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在表2中，虽然它不符合我们选择最频繁像素的标准，但<em class="ne">大步走</em>显然是速度恶魔。它似乎只受到内存带宽的限制。单纯的<em class="ne">计数</em>运行速度仅为38 kPx/秒，这意味着计算一张图像需要大约27.6秒。</p><p id="9880" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无数算法的各种版本在从986 kPx/秒到38.59 MPx/秒的宽范围内运行，轻松击败了<em class="ne">计数</em>。<em class="ne">无数_if </em>实际上是使用if语句测试两个像素是否匹配的<em class="ne">计数</em>实现<em class="ne"> </em>的变体。其他无数变体之间的主要性能差异取决于我们是否正确地处理零(在<em class="ne">无数</em>和<em class="ne">快速_无数</em>之间有37%的差异，在<em class="ne">最简单_无数</em>和<em class="ne">零_校正_无数</em>之间有39%的差异)以及乘法是否被简化掉(在<em class="ne">最简单_无数</em>和<em class="ne">快速_无数之间有13.8%的加速，以及</em> 15.6% 【T34</p><p id="8ab5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将该算法最快的综合变体<em class="ne">与其他两种常见的下采样方法进行比较，结果表明它比平均法慢1.7倍，比最大池法慢3.1倍。如果我们要处理不包含零作为有效像素的图像，相对差异将分别慢1.3倍和2.3倍。</em></p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/6ac661c780f7d1533b648aa1a6a921c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F7TxPjwZpy0gsy8ySViwVQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Table 2. Python algorithm performance on a three channel 1024x1024 segmentation image. N=200 except where noted.</figcaption></figure><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/20189bb53dd216ef56628186ebe4842c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e6ONn_7kfeEqKrfaAQCdiQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 5. Python algorithm performance on three channel 1024 x 1024 segmentation. Striding omitted to better show the other algorithms.</figcaption></figure><h1 id="474e" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">试验2 —灰色分割</h1><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/0924764b6f397485569062b97cf1c7ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Te1njL2Li9axxgYMu810g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 6. A grayscale version of the RGB segmentation from Trial 1.</figcaption></figure><p id="09d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">三通道存储器布局对算法性能有什么影响？在灰度(即单通道)版本的试用1图像上运行相同的一组测试。这个试验比试验1更类似于测量现实世界任务的性能，尽管我们更经常在uint16、uint32和uint64阵列上操作而不是uint8。</p><p id="72e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">灰色图像的每像素字节数比RGB少三倍。如果这种关系是简单的线性关系，那么人们会认为MB/秒的数字大致保持不变，而MPx/秒会提高三倍，但事实并非如此。对于<em class="ne">最简单_无数</em>来说，MB/秒在灰度上快了17.4倍左右。这可能是由于内存中RGB通道的非连续布局，而灰度得益于这种内存访问效率的提高。该试验的迭代次数增加到1000次，以允许试验运行与试验1大致相似的时间长度。由于<em class="ne">计数</em>和<em class="ne">无数_if </em>已经被认为是缓慢的，为了方便起见，它们在五次迭代中被测量，这仍然导致大量挂钟时间。</p><p id="dabc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还测试了counting、quick _ neutrally和neutrally _ if的C实现。正如所料，在MPx/sec测量上，C代码以大约2.9倍(对于<em class="ne">quick _ neutrable</em>)到1025倍(对于<em class="ne">neutrable _ if</em>)的速度击败了Python。虽然看到<em class="ne">quick _ neutrally</em>从C实现中获得巨大的速度提升并不令人惊讶，但<em class="ne">neutrally _ if</em>中的巨大增益令人印象深刻，以3.12 GPx/sec成为赢家。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/7b8174d465b4a04b5d5231dcf64ff394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fy4fBCKKYaeIWN5-IYOuLA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Table 3. Python algorithm performance on a one channel 1024 x 1024 version of the image from Trial 1. N=1000 except where noted.</figcaption></figure><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/e32fc7dc459c0fcd504fe9d5fd566d43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LmfcQR4QQN81K81XgMZrEQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 7. Python algorithm performance on a single uint8 channel 1024 x 1024 image. Striding is omitted from this figure because it’s so fast it makes the differences between the other algorithms hard to see.</figcaption></figure><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/f0a281893db9e8b47b963b9c6f22fb30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*orJBHnTLfV_mTcvwhfSv8w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 8. C implementation performance on counting, quick_countless, and countless_if. All three far exceed Python implementations and reach into the GPx/sec range. countless_if is by far the winner.</figcaption></figure><h1 id="6d45" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">试验3——灰色冰淇淋人(GICM)</h1><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/f5cad1313dc91a4188f91c817ed5065a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kIon0DJPl9azMapXBu5R3g.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 9. Photograph of a man eating ice cream. 5456 × 3632 pixels, uint8</figcaption></figure><p id="7c52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">灰色冰淇淋人(GICM)是一个相对较大的DSLR照片转换成灰度。存在显著的动态范围和模糊效果，使得图像在像素与像素之间变化显著。这意味着CPU管道中的分支预测将比试验2中更频繁地失败。图像的大尺寸使得每次测试更加稳定，同时也为CPU性能的均衡提供了更多的时间。</p><p id="5a94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，在表4中，<em class="ne">大步走</em>显然是赢家。简单的<em class="ne">计数</em>运行速度仅为44 kPx/秒，这意味着计算一张图像需要大约171秒。无数算法的各种版本在从2.4 MPx/秒到594.7 MPx/秒的广泛范围内运行，轻松击败了计数算法。</p><p id="aa51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他无数变体之间的主要性能差异取决于我们是否正确处理零(无数和<em class="ne">之间的3.2倍差异，以及<em class="ne">最简单_无数</em>和<em class="ne">之间的3.2倍差异)。代数化简在<em class="ne">最简单_无数</em>和<em class="ne">快速_无数</em>之间占14.9%，在<em class="ne">无数</em>和<em class="ne">零_校正_无数</em>之间占16.2%。</em></em></p><p id="a9ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有趣的是，在这种情况下，与灰度分割相比，<em class="ne">quick _ neutrally</em>比<em class="ne">down sample _ with _ averaging</em>和<em class="ne">down sample _ with _ max _ pooling</em>表现得更好。</p><p id="e4dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的C结果与试验2非常相似，但是有一些有趣的特点需要注意。<em class="ne">无数_如果</em>跌了617 MPx/秒(~20%)。这可能是由于在非同质映像上分支预测失败的增加。<em class="ne">快速_无数</em>在定性而非定量测量的误差范围内保持稳定。<em class="ne">无数_if </em>要快得多，但quick _ numbery在不同图像上的性能更可预测，尽管<em class="ne">无数_if </em>在测试图像上的性能变化似乎始终高于<em class="ne">quick _ numbery</em>。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/d5549b7e50f61a7e8dd6310b2d266a47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fQOHbmWjRz8wXcnhZ4Q9JQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Table 4. Python/numpy algorithm performance on Gray Ice Cream Man. N = 200 except where noted.</figcaption></figure><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/c46e25270f2404de269d5474afdf3b45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zPPdnhibMMP-qnXTt2d9Zg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 10. Python Algorithm Performance on GICM. Striding is omitted from this figure because it’s so fast it makes the differences between the other algorithms hard to see.</figcaption></figure><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/fa02f3bf132e33cffba306cf37abf691.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zRK9K60XS_QiJoX0Hd00Jg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 11. C Implementation of three algorithms. counting is still in last place, but countless_if is now far ahead of standard countless.</figcaption></figure><h1 id="e1fd" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">讨论</h1><p id="a9e3" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">neutrally的标准Python/numpy实现相对于计数方法的原始实现表现出了巨大的性能增益，并且在性能上与图像处理社区中大量使用的简单方法平均值和最大池相当。在Seung Lab的生产图像处理管道中，我们经常处理大小为2048x2048的64个图像块进行下采样。重要的是，处理时间与下载时间相当，以确保有效的管道，无数做这项工作。</p><p id="b049" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在C实现中有数不清的好处。一个优化的计数实现能够在GICM上实现880 MPx/sec，比最快的Python实现<em class="ne">quick _ neutrable</em>快大约1.48倍。然而，<em class="ne">quick _ numbered</em>最快的基于位运算符的C实现达到了1.9 GPx/秒，而基于if语句的实现<em class="ne">numbered _ if</em>达到了2.5 GPx/秒，这意味着单个内核每秒可以处理大约9个2048x2048x64块，而使用<em class="ne">计数</em>大约可以处理3个。作为参考，一个给定的数据集可以包含数万个或更多这样的块。</p><p id="97fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，似乎至少在C语言中，与按位运算符相关的巧妙之处可能并不那么有用。毕竟，简单的if语句打败了它们。然而，有一个技术领域，按位运算符会胜出。我们已经证明了在Python/numpy中无数的方法是有用的，然而，一般的方法在其他带有矢量化运算符的解释语言中似乎也能成功。尽管Julia是一种编译语言，但在MATLAB、Octave、R和Julia中，按位无数可能也是值得的。按位变量似乎特别适合GPU实现，其中if语句非常昂贵。虽然要实现这一点，环境必须相当特殊，但如果使用Z顺序曲线重新排列输入，似乎有可能通过向量化指令大大加快C实现逐位无数的速度。(这篇文章发表后，Aleks Zlateski的KNL矢量化实现达到了4gb/秒的速度，最大限度地提高了内存带宽。)</p><p id="51f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无数算法允许基于最频繁的值快速生成分割的2x下采样。可以想象，这种能力可能在各种机器学习管道中有用，甚至可能在算法中有用(尽管这种情况需要特殊，以支持模式而不是最大池)。无数是寻找四个数的模式的一般方法，甚至可能有其他与图像处理无关的应用。</p><p id="aa1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无数确实有两个缺点。第一个是，虽然它可以递归使用，但只有第一次迭代才能保证是原始图像的模式。4x4图像的模式可能不同于四个2x2图像的模式。第二个缺点是Python中的按位无数(虽然C中没有)比<em class="ne">计数</em>需要更多的内存。原始图像、<em class="ne"> a </em>、<em class="ne"> b </em>、<em class="ne"> c </em>、<em class="ne"> d </em>以及中间运算的结果，并且在算法运行时必须保留最终结果，这导致至少四倍的存储器增加，而计数只需要比原始数据多存储少量的整数。如果在生成<em class="ne"> a </em>、<em class="ne"> b </em>、<em class="ne"> c </em>和<em class="ne"> d </em>后可以丢弃原始数据，那么只需要增加三倍。需要注意的是<em class="ne">无数_if </em>同样只需要几个整数。</p><p id="71b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在它的首次应用中，使用Python/numpy递归生成了从脑组织的大型电子显微照片中得到的分割的MIP图。虽然只有第一个MIP级别保证是模式，但生成的MIP级别比大步流星混合得更好，后者往往会随着新MIP级别的加载而沿对角线穿过屏幕。</p><p id="ad18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是无数的新？这种图像处理算法可能以前已经被发明过，并且基本的数学几乎肯定已经被用在像纯数学这样的其他环境中。但是，我还没有找到它的参考文献。</p><p id="ebca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有几个潜在的卓有成效的方向来扩展无数的算法。第一个涉及随机图像的问题，第二个涉及将算法扩展到三维以处理体积组织图像。</p><p id="864d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于随机图像，回过头来看案例1(e ),我们将始终选择右下角，在随机或病理数据上，它可能会导致与天真大步走相同的对角线偏移效果。这种伪像是由1(c)和1(e)中出现的d的按位或引起的。也许可以通过增加一项(a！来把1(c)和1(e)分开。= b！= c！= d)然而，考虑到1e，如何在图像中的所有2x2块上并行化a、b、c或d的随机选择并不明显。这种改变也可能是不希望的，因为它使输出不确定。</p><p id="2c7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于体积图像，由于我的实验室处理脑组织的3D图像，因此提出了这样一个问题，即这种方法是否可以扩展到2x2x2立方体(8的模式)。分析这个问题的最简单的方法是考虑一个更简单的情况，即我们是否可以扩展这种方法，采取五个整数的模式而不计数。在这种情况下，如果至少有三个像素匹配，那么匹配的像素保证是正确的。然而，如果没有匹配，则取决于两个是否匹配，如果没有两个匹配，则任何像素都是候选。很明显，扩展这种方法需要进行大量的组合比较。虽然可以想象这比数五个数更有效，但回报会迅速减少。</p><p id="78f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在某种程度上，基于if语句的neutrally是一种识字前的算法，如果没有人学会如何计数，它就会被使用。很明显，试图在C语言中对大数模式的计数上胜出是很困难的。然而，在Python中，<em class="ne">quick _ neutral</em>比<em class="ne">count</em>on<em class="ne"/>GICM有5263倍的优势，这意味着即使在3D情况下效率很低，仍有很大的改进空间。一个早期的演示<em class="ne"> </em>表明，在Python/numpy中，3D neutrally可能快至约4兆体素/秒，比2D计数快约35倍。还会有更多的实验。</p><p id="6593" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">编辑2018年2月14日:</strong>在即将发表的一篇关于无数3D的文章中，我将使用Python3/numpy记录高达24.9 MVx/sec的速度。</p><p id="e051" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">编辑2018 . 2 . 20:</strong>无数的<a class="ae kc" href="https://medium.com/@willsilversmith/countless-3d-vectorized-2x-downsampling-of-labeled-volume-images-using-python-and-numpy-59d686c2f75" rel="noopener">3D文章</a>现已出。</p><p id="6259" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">编辑2018年6月21日:</strong>如果你想在稀疏数据上使用无数的2D而不把上部下采样变黑，试试<a class="ae kc" href="https://medium.com/@willsilversmith/countless-2d-inflated-2x-downsampling-of-labeled-images-holding-zero-values-as-background-4d13a7675f2d" rel="noopener">点画无数的2D </a>。</p><h1 id="cc35" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">感谢</h1><p id="6845" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">几个人提供了有益的建议和援助，在开发无数。Chris Jordan提供了C实现<em class="ne">计数</em>和<em class="ne">无数</em>的种子。<a class="ae kc" href="https://github.com/zlateski" rel="noopener ugc nofollow" target="_blank">阿列克斯·兹拉特斯基博士</a>在这篇文章发表后贡献了一个骑士道SIMD版本。ndzoom基准测试由<a class="ae kc" href="https://github.com/davidbuniat" rel="noopener ugc nofollow" target="_blank"> Davit Buniatyan </a>提供。George Nagy博士建议测试<em class="ne">无数_if </em>并在同质和非同质图像上测试性能差异。谷歌的Jeremy Maitin-Shepard最初开发的Python代码用于与neuroglancer一起使用的<em class="ne">大步走</em>和<em class="ne">下采样平均</em>。特别感谢<a class="ae kc" href="http://seunglab.org/" rel="noopener ugc nofollow" target="_blank"> Seung Lab </a>提供神经分段标签。</p><h1 id="9f82" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">密码</h1><p id="f708" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">用于测试该管道的代码可以在<a class="ae kc" href="https://github.com/william-silversmith/countless" rel="noopener ugc nofollow" target="_blank"> github </a>上找到。欢迎其他语言的贡献和反馈，并将记入贷方。</p><p id="f671" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">2019年3月11日:</strong>现已作为<a class="ae kc" href="https://github.com/seung-lab/tinybrain/" rel="noopener ugc nofollow" target="_blank"> tinybrain </a> <a class="ae kc" href="https://pypi.org/project/tinybrain/" rel="noopener ugc nofollow" target="_blank"> PyPI包</a>的一部分提供。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="cb91" class="li lj iq bd lk ll od ln lo lp oe lr ls lt of lv lw lx og lz ma mb oh md me mf bi translated">更新和勘误表</h1><p id="54be" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated"><strong class="kf ir">2019 . 12 . 10:</strong>之所以跨步这么快，是因为测试的操作只是更新numpy数组的内部跨步数；它实际上并没有复制数组。应该重新进行这些实验来反映这一点。</p><p id="65fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">2018年7月9日:</strong>找到了消除变量<em class="ne"> bc </em>的方法，重用<em class="ne"> ab_ac </em>进行小加速(~2%？).请查看github获取此更新。</p><p id="defa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">2018年2月14日:</strong>更新了图表和文本，具有现在使用Python3.6.2的Python代码的更新基准。表2、3、&amp; 4和图5、7、&amp; 10已被替换。基准现在包括由<a class="ae kc" href="https://github.com/davidbuniat" rel="noopener ugc nofollow" target="_blank">戴维·布尼亚延</a>贡献的scipy函数ndimage.interpolation.zoom的代码。❤️</p><p id="357c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">2018年2月1日:</strong>我在Python基准测试代码中发现了一个错误，该错误导致大多数算法的速度被低估了4倍。我将很快更新这篇文章，带来新的结果。我已经找到了一种方法，使无数的实现更快，更有效的内存。Python3也比Python2快。最新见<a class="ae kc" href="https://github.com/william-silversmith/countless" rel="noopener ugc nofollow" target="_blank"> Github </a>。</p><p id="f931" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">2017年8月21日:</strong>在这篇文章发表后<a class="ae kc" href="https://github.com/zlateski" rel="noopener ugc nofollow" target="_blank"> Aleks Zlateski </a>贡献了一个骑士登陆(KNL)矢量化版本的bitwise neutral，据报道，该版本在随机int32数据上以1 GPx/sec，4 GB/sec的速度运行。可以在<a class="ae kc" href="https://github.com/william-silversmith/countless" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p></div></div>    
</body>
</html>