<html>
<head>
<title>Productizing ML Models with Dataflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用数据流生产 ML 模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/productizing-ml-models-with-dataflow-99a224ce9f19?source=collection_archive---------2-----------------------#2018-02-10">https://towardsdatascience.com/productizing-ml-models-with-dataflow-99a224ce9f19?source=collection_archive---------2-----------------------#2018-02-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/5fab94ae29080b757ca2305d0425c94b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0NNH408G8kI6CfbgloXyYA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Source (PublicDomainPicture): <a class="ae jd" href="https://pixabay.com/en/baby-boy-child-childhood-computer-84627/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/en/baby-boy-child-childhood-computer-84627/</a></figcaption></figure><div class=""/><p id="79b7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的数据科学职业生涯中，我面临的一个关键挑战是将探索性分析的发现转化为可扩展的模型，为产品提供动力。在游戏行业，我建立了几个预测模型来识别玩家流失，但将这些模型投入生产总是很困难。我曾经写过 Twitch 上用于生产<a class="ae jd" href="https://blog.twitch.tv/productizing-data-science-at-twitch-67a643fd8c44" rel="noopener ugc nofollow" target="_blank">模型的一些流程，但是每个产品团队都需要独特的方法和不同的基础设施。</a></p><p id="4403" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<a class="ae jd" href="https://angel.co/windfall-data" rel="noopener ugc nofollow" target="_blank">意外收获</a>，我们授权我们的数据科学团队拥有产品化模型的过程。我们没有依赖工程团队将模型规范转化为生产系统，而是为我们的数据科学家提供缩放模型所需的<a class="ae jd" href="https://medium.com/windfalldata/the-data-science-stack-at-windfall-data-e1e6bc3c4c8f" rel="noopener">工具</a>。为了实现这一点，我们使用预测模型标记语言(<a class="ae jd" href="https://en.wikipedia.org/wiki/Predictive_Model_Markup_Language" rel="noopener ugc nofollow" target="_blank"> PMML </a>)和谷歌的<a class="ae jd" href="https://github.com/GoogleCloudPlatform/DataflowJavaSDK" rel="noopener ugc nofollow" target="_blank">云数据流</a>。以下是我们在意外收获构建和部署模型的工作流程:</p><ol class=""><li id="48f4" class="lb lc jg kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">模型是用 R 或 Python 离线训练的</li><li id="a118" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">训练有素的模型被翻译到 PMML</li><li id="382a" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">数据流作业接收用于生产的 PMML 模型</li></ol><p id="cb91" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法使数据科学家能够在本地使用采样数据集来训练模型，然后在我们的整个数据集上使用结果模型规范。步骤 3 可能需要工程团队的一些初始支持，但只需要设置一次。使用这种方法意味着我们的数据科学团队可以使用 PMML 支持的任何预测模型，利用托管数据流服务意味着团队无需担心维护基础架构。</p><p id="7d21" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本教程介绍了使用 Java SDK for Cloud Dataflow 从 R 中训练的离线模型转换为产品化模型的步骤。本教程中的所有代码都可以在我的<a class="ae jd" href="https://github.com/bgweber/StartupDataScience/tree/master/misc" rel="noopener ugc nofollow" target="_blank"> github 档案</a>中找到。我们使用可用于 BigQuery 的出生率<a class="ae jd" href="https://cloud.google.com/bigquery/sample-tables" rel="noopener ugc nofollow" target="_blank">公共数据集</a>，并训练一个线性回归模型来基于许多因素预测婴儿出生体重。数据流作业从公共数据集中读取记录，将训练好的回归模型应用于每条记录，并将结果写入我们的 BigQuery 项目中的一个表。这是我们的数据科学团队在为客户构建定制模型时采用的工作流，例如使用随机森林模型进行线索评分。</p><p id="68bc" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要做的第一件事是熟悉出生率数据集，它记录了 1969 年至 2008 年间美国的出生人数。本<a class="ae jd" href="https://medium.com/@ImJasonH/exploring-natality-data-with-bigquery-ed9b7fc6478a" rel="noopener">中的帖子</a>提供了关于该数据集的更多详细信息。我们使用 BigQuery web 接口编写一个查询来对数据集进行采样。该查询为每次出生提取以下属性:</p><ul class=""><li id="b1d0" class="lb lc jg kf b kg kh kk kl ko ld ks le kw lf la lp lh li lj bi translated"><strong class="kf jh">年份:</strong>出生的年份</li><li id="f1ba" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lp lh li lj bi translated"><strong class="kf jh">复数:</strong>分娩的孩子数</li><li id="54c4" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lp lh li lj bi translated"><strong class="kf jh"> apgar_5min: </strong>新生儿出生 5 分钟后的健康评分</li><li id="53b5" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lp lh li lj bi translated"><strong class="kf jh">母亲 _ 年龄:</strong>母亲的年龄</li><li id="f9fe" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lp lh li lj bi translated"><strong class="kf jh">父亲 _ 年龄:</strong>父亲的年龄</li><li id="6f10" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lp lh li lj bi translated"><strong class="kf jh">妊娠周数:</strong>进入妊娠的周数</li><li id="851c" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lp lh li lj bi translated">这位母亲生了几个孩子</li><li id="0e17" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lp lh li lj bi translated">母亲已婚:孩子出生时，母亲已婚吗？</li><li id="0c52" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lp lh li lj bi translated">体重 _ 磅:婴儿的体重(我们预测的)</li></ul><p id="1f5f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了在 R 中处理这个数据集，我们使用了优秀的<a class="ae jd" href="https://github.com/r-dbi/bigrquery" rel="noopener ugc nofollow" target="_blank"> bigrquery </a>库，这使得将 BigQuery 结果读入数据帧变得很容易。我们提取一个样本数据集如下:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="e729" class="lz ma jg lv b gy mb mc l md me"><strong class="lv jh">library</strong>(bigrquery)<br/>project &lt;- "gcp_project_id"</span><span id="fdd4" class="lz ma jg lv b gy mf mc l md me">sql &lt;- "<br/> SELECT year, plurality, apgar_5min, mother_age, father_age,    <br/>       gestation_weeks, ever_born, mother_married, weight_pounds<br/> FROM `bigquery-public-data.samples.natality`<br/> order by rand() <br/> LIMIT 10000 <br/>"</span><span id="5b94" class="lz ma jg lv b gy mf mc l md me">df &lt;- query_exec(sql, project = project, use_legacy_sql = <strong class="lv jh">FALSE</strong>)</span></pre><p id="40b8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以对数据集进行各种操作，如<code class="fe mg mh mi lv b">summary(df)</code>和<code class="fe mg mh mi lv b">hist(df$df$weight_pounds)</code>，这将生成下面的图表，显示婴儿体重在采样数据集中的分布。</p><figure class="lq lr ls lt gt is gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/f8185e0d1a37b4bfaef88e9c339ea00a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*hxk83SocexbusUoYBNAN1Q.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Distribution of birth weights in the sampled data set.</figcaption></figure><p id="899a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们训练一个线性回归模型来预测出生体重，并计算误差指标:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="e77a" class="lz ma jg lv b gy mb mc l md me">lm &lt;- lm(weight_pounds ~ ., data = df)<br/>summary(lm)</span><span id="3e83" class="lz ma jg lv b gy mf mc l md me">cor(df$weight_pounds, predict(lm, df))<br/>mean(abs(df$weight_pounds - predict(lm, df))) sqrt(mean(abs(df$weight_pounds - predict(lm, df)^2)))</span></pre><p id="b378" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这会产生以下结果:</p><ul class=""><li id="3a85" class="lb lc jg kf b kg kh kk kl ko ld ks le kw lf la lp lh li lj bi translated">相关系数:0.335</li><li id="4308" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lp lh li lj bi translated">平均误差:0.928</li><li id="e84d" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lp lh li lj bi translated">RMSE: 6.825</li></ul><p id="898b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模型性能相当弱，可以探索其他算法和功能来改进它。由于这篇文章的目标是专注于将模型产品化，因此经过训练的模型就足够了。用于训练模型的完整笔记本可在<a class="ae jd" href="https://github.com/bgweber/StartupDataScience/blob/master/misc/TrainNatality.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="0375" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">翻译成 PMML <br/> </strong>下一步就是把训练好的模型翻译成 PMML。<a class="ae jd" href="https://github.com/jpmml/r2pmml" rel="noopener ugc nofollow" target="_blank"> r2pmml </a> R 包和<a class="ae jd" href="https://github.com/jpmml/jpmml-r" rel="noopener ugc nofollow" target="_blank"> jpmml-r </a>工具使这一过程变得简单，并支持各种不同的算法。第一个库将 R 模型对象直接转换成 PMML 文件，而第二个库需要将模型对象保存到 RDS 文件，然后运行命令行工具。我们使用第一个库直接进行翻译:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="a844" class="lz ma jg lv b gy mb mc l md me"><strong class="lv jh">library</strong>(r2pmml)<br/>r2pmml(lm, "natality.pmml")</span></pre><p id="92a0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这段代码生成下面的<a class="ae jd" href="https://github.com/bgweber/StartupDataScience/blob/master/misc/natality.pmml" rel="noopener ugc nofollow" target="_blank"> pmml 文件</a>。PMML 文件格式指定用于模型的数据字段、要执行的计算类型(回归)以及模型的结构。在这种情况下，模型的结构是一组系数，定义如下:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="7ee9" class="lz ma jg lv b gy mb mc l md me">&lt;RegressionTable intercept="7.5619"&gt;   <br/>  &lt;NumericPredictor name="year" coefficient="3.6683E-4"/&gt;   <br/>  &lt;NumericPredictor name="plurality" coefficient="-2.0459"/&gt;   <br/>  &lt;NumericPredictor name="apgar_5min" coefficient="9.4773E-5"/&gt;   <br/>  ...<br/>  &lt;NumericPredictor name="mother_married" coefficient="0.2784"/&gt;  <br/>&lt;/RegressionTable&gt;</span></pre><p id="de13" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在有了一个模型规范，可以将其产品化并应用于我们的整个数据集。</p><p id="4d9c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">使用云数据流进行产品化<br/> </strong>使用 Dataflow Java SDK 时，您可以定义一个要在一组对象上执行的操作图，服务将根据需要自动配置硬件进行扩展。在这种情况下，我们的图是一组三个操作:从 BigQuery 读取数据，计算每条记录的模型预测，并将结果写回 BigQuery。本教程生成以下数据流 DAG:</p><figure class="lq lr ls lt gt is gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/ac9c4f44e56cac90f4c9b925b1ee7db0.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/format:webp/1*u_fLswlIqP0YuMjqG4us8g.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">The Dataflow graph of operations used in this tutorial.</figcaption></figure><p id="6ea4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用 IntelliJ IDEA 来创作和部署数据流作业。虽然设置 Java 环境超出了本教程的范围，但是用于构建项目的 pom 文件可以在这里<a class="ae jd" href="https://github.com/bgweber/StartupDataScience/blob/master/misc/pom.xml" rel="noopener ugc nofollow" target="_blank">获得</a>。它包括对<a class="ae jd" href="https://github.com/GoogleCloudPlatform/DataflowJavaSDK" rel="noopener ugc nofollow" target="_blank">数据流 sdk </a>和<a class="ae jd" href="https://github.com/jpmml" rel="noopener ugc nofollow" target="_blank"> JPMML </a>库的以下依赖关系:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="6505" class="lz ma jg lv b gy mb mc l md me">&lt;dependency&gt;            <br/>  &lt;groupId&gt;com.google.cloud.dataflow&lt;/groupId&gt;              <br/>  &lt;artifactId&gt;google-cloud-dataflow-java-sdk-all&lt;/artifactId&gt;   <br/>  &lt;version&gt;2.2.0&lt;/version&gt;        <br/>&lt;/dependency&gt;</span><span id="79c5" class="lz ma jg lv b gy mf mc l md me">&lt;dependency&gt;            <br/>  &lt;groupId&gt;org.jpmml&lt;/groupId&gt;            <br/>  &lt;artifactId&gt;pmml-evaluator&lt;/artifactId&gt;            <br/>  &lt;version&gt;1.3.9&lt;/version&gt;  <br/>&lt;/dependency&gt;</span></pre><p id="08bc" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如上图所示，我们的数据流工作由三个步骤组成，我们将详细介绍这三个步骤。在讨论这些步骤之前，我们需要创建管道对象:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="c556" class="lz ma jg lv b gy mb mc l md me">PmmlPipeline.Options options = PipelineOptionsFactory<br/>  .fromArgs(args).withValidation().as(PmmlPipeline.Options.class); <br/>Pipeline pipeline = Pipeline.create(options);</span></pre><p id="a60c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建一个管道对象，它定义了应用于对象集合的一组操作。在我们的例子中，管道正在对一组<a class="ae jd" href="https://developers.google.com/resources/api-libraries/documentation/bigquery/v2/java/latest/com/google/api/services/bigquery/model/TableRow.html" rel="noopener ugc nofollow" target="_blank"> TableRow </a>对象进行操作。我们将一个选项类作为输入传递给 pipeline 类，该类为数据流作业定义了一组运行时参数，例如用于运行作业的 GCP 临时位置。</p><p id="875c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">管道中的第一步是从公共 BigQuery 数据集中读取数据。从这一步返回的对象是 TableRow 对象的一个<a class="ae jd" href="https://beam.apache.org/documentation/sdks/javadoc/0.5.0/org/apache/beam/sdk/values/PCollection.html" rel="noopener ugc nofollow" target="_blank">p 集合</a>。特征查询字符串定义要运行的查询，并且我们指定在运行查询时要使用标准 SQL。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="a9f1" class="lz ma jg lv b gy mb mc l md me">private static final String featureQuery =     <br/>  "SELECT year, plurality, apgar_5min ... weight_pounds\n" +<br/>  "FROM `bigquery-public-data.samples.natality`";</span><span id="b341" class="lz ma jg lv b gy mf mc l md me">pipeline.apply(BigQueryIO.read().fromQuery(featureQuery)           <br/>       .usingStandardSql().withoutResultFlattening())</span></pre><p id="a70f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是将模型预测应用于数据集中的每条记录。我们定义了一个 PTransform 来加载模型规范，然后应用一个 DoFn 在每个 TableRow 上执行模型计算。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="97d9" class="lz ma jg lv b gy mb mc l md me">.apply("PMML Application", new PTransform&lt;PCollection&lt;TableRow&gt;,<br/>  PCollection&lt;TableRow&gt;&gt;() {</span><span id="5f0d" class="lz ma jg lv b gy mf mc l md me">model = new RegressionModelEvaluator(PMMLUtil.unmarshal(<br/>  Resources.getResource("natality.pmml").openStream()));</span><span id="56e6" class="lz ma jg lv b gy mf mc l md me">return input.apply("To Predictions", ParDo.of(<br/>    new DoFn&lt;TableRow, TableRow&gt;() {           <br/>     @ProcessElement          <br/>     public void processElement(ProcessContext c) throws Exception {<br/>     <br/>     /* Apply Model */<br/>}})))</span></pre><p id="fc5f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">应用模型代码段如下所示。它检索 TableRow 以创建估计值，为 pmml 对象创建输入字段的映射，使用模型估计出生体重，创建新的 TableRow 以存储出生的实际和预测体重，然后将此对象添加到此 DoFn 的输出中。总而言之，这个应用步骤加载模型，定义一个函数来转换输入集合中的每个记录，并创建预测对象的输出集合。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="a7c5" class="lz ma jg lv b gy mb mc l md me">TableRow row = c.element();</span><span id="68b9" class="lz ma jg lv b gy mf mc l md me">HashMap&lt;FieldName, Double&gt; inputs = new HashMap&lt;&gt;();            <br/>for (String key : row.keySet()) {              <br/>  if (!key.equals("weight_pounds")) {                   <br/>    inputs.put(FieldName.create(key), Double<br/>        .parseDouble(row.get(key).toString()));              <br/>  }<br/>}</span><span id="db8b" class="lz ma jg lv b gy mf mc l md me">Double estimate =(Double)model.evaluate(inputs)<br/>  .get(FieldName.create("weight_pounds"));</span><span id="7198" class="lz ma jg lv b gy mf mc l md me">TableRow prediction = new TableRow();            prediction.set("actual_weight", Double.parseDouble(<br/>    row.get("weight_pounds").toString()));            prediction.set("predicted_weight", estimate);</span><span id="f010" class="lz ma jg lv b gy mf mc l md me">c.output(prediction);</span></pre><p id="e4f7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一步是将结果写回 BigQuery。在本课的前面，我们定义了将记录写回 BigQuery 时要使用的模式。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="4233" class="lz ma jg lv b gy mb mc l md me">List&lt;TableFieldSchema&gt; fields = new ArrayList&lt;&gt;();    <br/>fields.add(new TableFieldSchema()<br/>   .setName("actual_weight").setType("FLOAT64"));    <br/>fields.add(new TableFieldSchema()<br/>   .setName("predicted_weight").setType("FLOAT64"));    <br/>TableSchema schema = new TableSchema().setFields(fields);</span><span id="0021" class="lz ma jg lv b gy mf mc l md me">.apply(BigQueryIO.writeTableRows()<br/>  .to(String.format("%s:%s.%s",  PROJECT_ID, dataset, table))   <br/>  .withCreateDisposition(BigQueryIO.Write.CreateDisposition     <br/>  .CREATE_IF_NEEDED).withSchema(schema));</span><span id="b45e" class="lz ma jg lv b gy mf mc l md me">pipeline.run();</span></pre><p id="f4a3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在已经定义了一个管道，可以运行它来为整个数据集创建预测。这个类的完整代码清单可以在<a class="ae jd" href="https://github.com/bgweber/WindfallData/blob/master/natality/PmmlPipeline.java" rel="noopener ugc nofollow" target="_blank">这里</a>找到。运行这个类将启动一个数据流作业，该作业将生成上面显示的 DAG，并将提供许多 GCE 实例来完成该作业。下面是一个用于运行此管道的自动缩放示例:</p><figure class="lq lr ls lt gt is gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/e3ed0b25e91423e9b91f32918d55dd76.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*wIId5wanJTXK6QJteXgJaw.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Autoscaling the Model Predicting Task</figcaption></figure><p id="b145" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当作业完成时，输出是 BigQuery 项目中的一个新表，它存储了出生率数据集中所有记录的预测和实际权重。如果我们想要运行一个新的模型，我们只需要在数据流作业中指向一个新的 PMML 文件。运行离线分析和数据流项目所需的所有文件都可以在<a class="ae jd" href="https://github.com/bgweber/WindfallData/tree/master/natality" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。</p><p id="b164" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据流是一个伟大的工具，使数据科学家能够将他们的模型产品化。它提供了一个可扩展到大型数据集的托管环境，并使数据科学团队能够拥有更多生产流程。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><p id="5c55" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae jd" href="https://www.linkedin.com/in/ben-weber-3b87482/" rel="noopener ugc nofollow" target="_blank">本·韦伯</a>是<a class="ae jd" href="https://angel.co/windfall-data" rel="noopener ugc nofollow" target="_blank">意外收获数据</a>的首席数据科学家，我们的任务是确定世界上每个家庭的净资产。</p></div></div>    
</body>
</html>