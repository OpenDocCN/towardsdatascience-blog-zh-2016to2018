<html>
<head>
<title>Digit recognition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数字识别</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mnist-with-k-nearest-neighbors-8f6e7003fab7?source=collection_archive---------0-----------------------#2017-03-12">https://towardsdatascience.com/mnist-with-k-nearest-neighbors-8f6e7003fab7?source=collection_archive---------0-----------------------#2017-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="9040" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="f3a6" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">就像在传统编程中，我们首先学习打印<code class="fe lj lk ll lm b">"Hello, world!"</code>，类似地，在机器学习中，我们首先理解识别手写数字图像的解决方案。此类任务的著名数据集是<a class="ae ln" href="http://yann.lecun.com/exdb/mnist/" rel="noopener ugc nofollow" target="_blank"> MNIST </a>(简称“修改后的<a class="ae ln" href="https://en.wikipedia.org/wiki/National_Institute_of_Standards_and_Technology" rel="noopener ugc nofollow" target="_blank">国家标准与技术研究院</a>数据库”)。</p><p id="a5f5" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在这篇文章中，我将使用一个最简单的机器学习算法来解决这个著名的识别手写数字的问题。</p><h1 id="307e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">MNIST数据集</h1><p id="e438" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">MNIST由6万张手写数字图像组成，包括从0到9的所有数字。每个图像都有其对应的标签号，代表图像中的编号。例如，下图中第一个图像的标签为5，第二个图像的标签为4，依此类推。该数据集通常分为三个子集:40，000个用于训练，10，000个用于验证，另外10，000个用于测试。在本文中，我们将只关注培训和测试。</p><p id="5829" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在MNIST，每幅图像都包含一个手绘的灰度数字。每个图像都是一个784维的浮点数向量(高度和宽度都是28个像素),其中每个值代表一个像素的亮度。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/212e3c933c3ace0431ab91c6f9dd37ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*_4Ua9Zp84He8OxlZ4cy0DQ@2x.png"/></div></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="0cf3" class="jn jo iq bd jp jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk bi translated">那么，KNN是什么？</h1><p id="ffb4" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">k近邻是一种分类算法。它将新数据点(测试数据)分类到某个类别中。为此，它主要查看新数据点与训练集中所有其他数据点的距离。然后，在<em class="lt"> k </em>个最接近的训练数据点中，大多数类被分配给该新的测试数据点。</p><p id="6e5b" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">距离度量的选择取决于为分类任务选择的问题。因为，举例来说，两个程序员的技能之间的距离(比赛中的分数)将不同于两个风筝在空中飞行的距离(3D空间中的欧几里德距离)，等等。我们选择使用由以下公式给出的图像之间的欧几里德距离。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mo"><img src="../Images/ec4034f9c8d7507c603dbe0bcee28790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qkYsz0NJYNRrf2fn1_n16A.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Euclidean distance between two n-dimensional points p and q. <a class="ae ln" href="https://en.wikipedia.org/wiki/Euclidean_distance" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="7013" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这个等式描述了两个n维点p和q之间的欧几里德距离。在我们的例子中，n = 784，因为MNIST的每个图像是784维的。</p><p id="d46d" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这就是关于k个最近邻居的全部内容！算法非常简单。现在让我们开始编程</p><h2 id="17ce" class="mx jo iq bd jp my mz dn jt na nb dp jx kw nc nd kb la ne nf kf le ng nh kj ni bi translated">寻找距离</h2><p id="500d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">两幅图像之间的距离可以用许多不同的方法计算。但是这里我用了欧几里德距离。其计算方法(此处为图像)是对两幅图像的相应像素之间的L2范数求和。</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Euclidean Distance</figcaption></figure><p id="f6c9" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">相应像素距离的平方也消除了负距离。另一种方法是找到相应欧几里得距离的绝对值。</p><h2 id="7ceb" class="mx jo iq bd jp my mz dn jt na nb dp jx kw nc nd kb la ne nf kf le ng nh kj ni bi translated">多数表决</h2><p id="e70d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">找到距离并排序后(我们稍后将对其进行排序),是时候在最近的<em class="lt"> k </em>训练点中找到多数类来测试数据点。这里，我们采用最接近的训练点的标签/类别，并找到出现最多的一个，并将其分配给新的测试数据点。这就是分类是如何发生的。</p><p id="d062" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">下面的代码描述了多数算法。</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Voting for majority</figcaption></figure><h1 id="3b0e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">分类手写数字</h1><p id="26ac" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们有了对手写数字进行分类所需的一切。我们剩下要做的就是我们在这里的真正目的。</p><p id="726a" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">下面的分类代码描述了它自己。</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Classifying handwritten digits</figcaption></figure><p id="f762" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">我运行我的代码对前2500张测试图像进行分类，并获得了<strong class="kn ir"> 95.32% </strong>的分类准确率，对于这样一个简单的机器学习模型来说，这真的不算太差。可以通过使用分类过程的所有测试图像来检查完整的准确性，但这将花费很长时间(甚至可能一天)。</p><h2 id="3130" class="mx jo iq bd jp my mz dn jt na nb dp jx kw nc nd kb la ne nf kf le ng nh kj ni bi translated">结论</h2><p id="e40e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">所以，<em class="lt"> k近邻</em>是一种简单的分类任务算法。我们用它来对手写数字进行分类，取得了9<strong class="kn ir">5.32%</strong>T8w的准确率，对于这样一个简单的分类算法来说已经很不错了。</p></div></div>    
</body>
</html>