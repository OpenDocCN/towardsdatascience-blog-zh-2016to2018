<html>
<head>
<title>Integer Programming in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的整数编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/integer-programming-in-python-1cbdfa240df2?source=collection_archive---------0-----------------------#2018-03-09">https://towardsdatascience.com/integer-programming-in-python-1cbdfa240df2?source=collection_archive---------0-----------------------#2018-03-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3843e623d4ca8c9b141d67c970cef175.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VVAFznAQgHd89wVE"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">We’ll use integer programming to make optimal decisions. Photo from <a class="ae kc" href="https://unsplash.com/photos/u0vgcIOQG08" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="03c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">整数规划(IP)问题是优化问题，其中所有变量都被约束为整数。知识产权问题是如何最好地分配资源的有用的数学模型。假设您正在为一位政治候选人组织一场营销活动，您正在决定向哪些选民发送营销材料。你可以给每个选民发一张醒目的传单、一本解释你议程的详细小册子，或者一张保险杠贴纸(或者三者结合)。如果你有办法根据人们收到的营销材料来衡量他们投票给你的候选人的可能性，你会如何决定发送哪些材料，同时注意不要超出你的供应量？</p><p id="6e6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">传统的优化算法假设变量可以采用浮点值，但在我们的情况下，给某人送半个保险杠贴纸或四分之三的小册子是不合理的。我们将使用一个名为<a class="ae kc" href="http://www.cvxpy.org/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> cvxpy </a>的特殊python包来解决我们的问题，这样解决方案才有意义。</p><p id="6a93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将向您展示如何使用cvxpy来解决政治候选人问题，但是我将首先从一个称为背包问题的简单问题开始，向您展示cvxpy语法是如何工作的。</p><h2 id="c695" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">背包问题</h2><p id="a80d" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">让我们假设你要去远足，你正在计划你可以带哪些物品。每个物体都有重量，单位是磅w_i，会给你u_i单位的效用。你想把它们都带走，但是你的背包只能装P磅。假设你要么拿一个对象，要么不拿。你的目标是在不超过包的重量限制的情况下最大化你的效用。</p><p id="ac24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">cvxpy问题有三个部分:</p><ol class=""><li id="5f59" class="lz ma iq kf b kg kh kk kl ko mb ks mc kw md la me mf mg mh bi translated"><strong class="kf ir">创建变量:</strong>我们将用一个由1和0组成的向量来表示我们的选择。1表示我们选择了那个对象，0表示我们把它留在了家里。我们用cvxpy构造了一个只能取1和0的变量。布尔对象。</li><li id="2fa3" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">指定约束:</strong>我们只需要确保我们的对象的总和不超过重量限制p。我们可以使用选择向量和权重向量的点积来计算我们的对象的总重量。请注意，cvxpy重载了*运算符来执行矩阵乘法。</li><li id="86d6" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">公式化目标函数:</strong>我们想要找到最大化我们效用的选择。任何给定选择的效用是选择向量和效用向量的点积。</li></ol><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Complete cvxpy code for the Knapsack problem</figcaption></figure><p id="756c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们有了一个成本函数和约束，我们就把它们传递给一个cvxpy问题对象。在这种情况下，我们已经告诉cvxpy，我们试图用cvxpy.Maximize最大化效用。之后，我们可以通过查看选择向量的值属性来检查它的最优值。</p><pre class="mn mo mp mq gt mt mu mv mw aw mx bi"><span id="a99f" class="lb lc iq mu b gy my mz l na nb">print(selection.value)</span><span id="50d0" class="lb lc iq mu b gy nc mz l na nb">matrix([[1.],<br/>        [1.],<br/>        [1.],<br/>        [1.],<br/>        [0.],<br/>        [1.],<br/>        [0.],<br/>        [0.],<br/>        [0.],<br/>        [0.]])</span></pre><p id="d729" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们选择了前四项和第六项。这是有道理的，因为这些有很高的实用重量比，而不会太重。</p><h2 id="5d84" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">营销问题</h2><p id="1b39" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">现在我们已经介绍了基本的cvxpy语法，我们可以为我们的政治候选人解决营销优化问题。比方说，我们有一个模型，它接受一个选民的属性，并预测他们为我们发送给他们的营销材料的每个组合投票给我们的候选人的概率。我在这里使用了假数据，但让我们假设模型输出以下概率:</p><pre class="mn mo mp mq gt mt mu mv mw aw mx bi"><span id="234f" class="lb lc iq mu b gy my mz l na nb">print(test_probs[0:5])</span><span id="eebd" class="lb lc iq mu b gy nc mz l na nb">array([[0.0001, 0.0001, 0.3   , 0.0001, 0.2   , 0.0001, 0.2   , 0.3   ],<br/>       [0.1   , 0.1   , 0.1   , 0.2   , 0.2   , 0.2   , 0.1   , 0.0001],<br/>       [0.1   , 0.0001, 0.2   , 0.0001, 0.1   , 0.2   , 0.0001, 0.4   ],<br/>       [0.3   , 0.0001, 0.0001, 0.2   , 0.1   , 0.2   , 0.2   , 0.0001],<br/>       [0.2   , 0.3   , 0.1   , 0.0001, 0.2   , 0.1   , 0.1   , 0.0001]])</span></pre><p id="fa5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个成分有八个总概率，因为我们可以发送给个人的材料总共有八种组合。以下是每个1 x 8向量的条目所代表的内容:</p><p id="385a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">【1张传单，1张小册子，1张保险杠贴纸，传单和小册子，传单和保险杠贴纸，小册子和保险杠贴纸，三个都有，无】。</p><p id="a4b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果第一个选民收到传单或小册子，他有0.0001的概率投票给我们的候选人，但如果我们给他寄去保险杠贴纸，他有0.3的概率投票给我们的候选人。</p><p id="ec54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们进入cvxpy代码之前，我们将通过取负对数把这些概率转化为成本。这使得数学结果更好，它有一个很好的解释:如果概率接近1，负对数将接近0。这意味着向选民发送特定组合的材料几乎没有成本，因为我们确信这将引导他们投票给我们的候选人。如果概率接近于0，反之亦然。</p><pre class="mn mo mp mq gt mt mu mv mw aw mx bi"><span id="3c1c" class="lb lc iq mu b gy my mz l na nb">#clipping so that we don't take log of 0 or 1<br/>test_probs = np.clip(test_probs, 0.0001, 0.9999)</span><span id="e89a" class="lb lc iq mu b gy nc mz l na nb">#turning into costs<br/>model_costs = -np.log10(test_probs)</span></pre><p id="8c7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，假设我们不能发送超过150份传单、80份小册子和25张保险杠贴纸。</p><pre class="mn mo mp mq gt mt mu mv mw aw mx bi"><span id="b919" class="lb lc iq mu b gy my mz l na nb">supply = np.atleast_2d([150, 80, 25])</span></pre><p id="8970" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经完成了所有的设置，我们可以开始有趣的部分了:</p><ol class=""><li id="d08d" class="lz ma iq kf b kg kh kk kl ko mb ks mc kw md la me mf mg mh bi translated"><strong class="kf ir">创建变量:</strong>我们将使用cvxpy。因为我们在这里只能做二进制选择。我们将指定它必须与我们的概率矩阵形状相同:</li></ol><pre class="mn mo mp mq gt mt mu mv mw aw mx bi"><span id="c9a4" class="lb lc iq mu b gy my mz l na nb">selection = cvxpy.Bool(*test_probs.shape)</span></pre><p id="7298" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.<strong class="kf ir">指定约束:</strong>我们的选择变量将只告诉我们为每个组成部分做了8个选择中的哪一个，但它不会告诉我们决定给他们发送多少个材料。我们需要一种方法将我们的1 x 8选择向量转换成1 x 3向量。我们可以通过将选择向量乘以以下矩阵来实现:</p><pre class="mn mo mp mq gt mt mu mv mw aw mx bi"><span id="afe2" class="lb lc iq mu b gy my mz l na nb">TRANSFORMER = np.array([[1,0,0],<br/>                        [0,1,0],<br/>                        [0,0,1],<br/>                        [1,1,0],<br/>                        [1,0,1],<br/>                        [0,1,1],<br/>                        [1,1,1],<br/>                        [0,0,0]])</span></pre><p id="c566" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果这一部分有一点混乱，请解出下面的例子:</p><pre class="mn mo mp mq gt mt mu mv mw aw mx bi"><span id="6e3c" class="lb lc iq mu b gy my mz l na nb">print(np.dot(np.array([0,0,0,1,0,0,0,0]), TRANSFORMER))</span><span id="26c3" class="lb lc iq mu b gy nc mz l na nb">array([1, 1, 0])</span></pre><p id="7c64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的决策向量的第四个条目表示向选民发送传单和小册子，乘以TRANSFORMER告诉我们的就是这一点！所以我们会告诉cvxpy，我们的选择矩阵乘以transformer不能超过我们的电源:</p><pre class="mn mo mp mq gt mt mu mv mw aw mx bi"><span id="2901" class="lb lc iq mu b gy my mz l na nb">supply_constraint = cvxpy.sum_entries(selection * TRANSFORMER, axis=0) &lt;= supply</span></pre><p id="d9bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我用cvxpy.sum_entries对这些行求和，以合计我们发送给所有委托人的材料总数。</p><p id="5a22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要确保每个成分只做一次选择，否则求解器可以通过不向任何人发送任何东西来实现零成本。</p><pre class="mn mo mp mq gt mt mu mv mw aw mx bi"><span id="a32b" class="lb lc iq mu b gy my mz l na nb"># We must make our choice per constituent<br/># remember that the last column is for "no materials"</span><span id="bada" class="lb lc iq mu b gy nc mz l na nb">feasibility_constraint = cvxpy.sum_entries(selection, axis=1) == 1</span><span id="fe83" class="lb lc iq mu b gy nc mz l na nb">constraints = [supply_constraint, feasibility_constraint]</span></pre><p id="e76f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.<strong class="kf ir">公式化目标函数:</strong>我们任务的总成本将是我们为每个组成部分所发生的成本的总和。我们将使用cvxpy.mul_elemwise函数将我们的选择矩阵乘以我们的成本矩阵，这将为每个成分选择成本，cvxpy.sum_elemwise函数将通过将各个成本相加来计算总成本。</p><pre class="mn mo mp mq gt mt mu mv mw aw mx bi"><span id="6ad3" class="lb lc iq mu b gy my mz l na nb">cost = cvxpy.sum_entries(cvxpy.mul_elemwise(model_costs, selection))</span></pre><p id="da2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一步是创建cvxpy。问题并解决它。</p><pre class="mn mo mp mq gt mt mu mv mw aw mx bi"><span id="5674" class="lb lc iq mu b gy my mz l na nb"># Solving the problem</span><span id="d67d" class="lb lc iq mu b gy nc mz l na nb">problem = cvxpy.Problem(cvxpy.Minimize(cost), constraints=constraints)</span><span id="1b05" class="lb lc iq mu b gy nc mz l na nb">problem.solve(solver=cvxpy.GLPK_MI)</span></pre><p id="c1a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！下面是我们期末作业的快照。我们决定不给第一个选民寄任何材料。这是有道理的，因为无论我们给他们寄去保险杠贴纸还是什么都不寄，他们投票给我们候选人的概率都是0.3。</p><p id="3232" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实证明，最佳作业耗尽了我们的小册子和保险杠贴纸，但只用了总共150张传单中的83张。我们应该告诉我们的候选人，她的传单没有她想象的那么有说服力。</p><pre class="mn mo mp mq gt mt mu mv mw aw mx bi"><span id="ce05" class="lb lc iq mu b gy my mz l na nb">print(hard_assignments.value[0:5])</span><span id="24ff" class="lb lc iq mu b gy nc mz l na nb">matrix([[0., 0., 0., 0., 0., 0., 0., 1.],<br/>        [0., 0., 0., 1., 0., 0., 0., 0.],<br/>        [0., 0., 0., 0., 0., 0., 0., 1.],<br/>        [1., 0., 0., 0., 0., 0., 0., 0.],<br/>        [1., 0., 0., 0., 0., 0., 0., 0.]])</span><span id="f61b" class="lb lc iq mu b gy nc mz l na nb">print(np.dot(hard_assignments.value, TRANSFORMER).sum(axis=0))</span><span id="e497" class="lb lc iq mu b gy nc mz l na nb">matrix([[83., 80., 25.]])</span></pre><p id="d9bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是打包在一起的所有代码:</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="4b8b" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">结束语</h2><p id="df63" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我希望您喜欢学习整数编程问题以及如何用Python解决这些问题。信不信由你，我们已经涵盖了你解决自己的优化问题所需的大约80%的cvxpy知识。我鼓励你阅读官方的<a class="ae kc" href="http://www.cvxpy.org/en/latest/tutorial/functions/index.html" rel="noopener ugc nofollow" target="_blank">文档</a>来了解剩下的20%。CVXPY能解决的不仅仅是IP问题，看看他们的<a class="ae kc" href="http://www.cvxpy.org/en/latest/examples/index.html" rel="noopener ugc nofollow" target="_blank">教程</a>页面，看看cvxpy还能解决什么问题。</p><p id="5dc4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要安装cvxpy，请遵循他们网站上的<a class="ae kc" href="http://www.cvxpy.org/en/latest/install/index.html" rel="noopener ugc nofollow" target="_blank">说明</a>。我还会安装<a class="ae kc" href="http://cvxopt.org/install/index.html" rel="noopener ugc nofollow" target="_blank"> cvxopt </a>来确保cvxpy附带的所有解算器都能在你的机器上工作</p><p id="4eca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经指定cvxpy应该在求解方法中使用GLPK _米求解器。这是一个专门为IP问题设计的求解器。在你解决你自己的问题之前，参考这个<a class="ae kc" href="http://www.cvxpy.org/en/latest/tutorial/advanced/" rel="noopener ugc nofollow" target="_blank">表</a>来看看哪个预先打包的cvpxy解算器最适合你的问题。</p><p id="b922" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">快乐优化！</p></div></div>    
</body>
</html>