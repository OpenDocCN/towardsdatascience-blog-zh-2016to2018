<html>
<head>
<title>Deep Learning For Beginners Using Transfer Learning In Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Keras 中的迁移学习为初学者提供深度学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/keras-transfer-learning-for-beginners-6c9b8b7143e?source=collection_archive---------0-----------------------#2018-10-17">https://towardsdatascience.com/keras-transfer-learning-for-beginners-6c9b8b7143e?source=collection_archive---------0-----------------------#2018-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="aa38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">本博客由三部分组成:</em> </strong></p><ol class=""><li id="f689" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">什么是迁移学习？</li><li id="fda4" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">为什么迁移学习效果这么好？</li><li id="9a4d" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">使用迁移学习编写您的第一个图像识别器。</li></ol><p id="7bfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae la" href="https://github.com/aditya9898/transfer-learning" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="kl">直奔 Github 上的代码。</em> </strong> </a></p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi li"><img src="../Images/830d5d70090b05341e8f2cfc76aad7ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5-vaYnBpaTux6d45"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">“galaxy with starry night” by <a class="ae la" href="https://unsplash.com/@bryangoffphoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Bryan Goff</a> on <a class="ae la" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="92ce" class="ly lz iq bd ma mb mc dn md me mf dp mg jy mh mi mj kc mk ml mm kg mn mo mp mq bi translated">什么是迁移学习？</h2><p id="5cf8" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">如果不是为了<strong class="jp ir">迁移学习</strong>，机器学习对于一个绝对的初学者来说是一件相当艰难的事情。在最底层，机器学习包括计算一个函数，该函数将一些输入映射到它们相应的输出。虽然函数本身只是一堆加法和乘法运算，但当通过非线性激活函数并将这些层堆叠在一起时，<strong class="jp ir">函数可以用来学习任何东西</strong>，只要有足够的数据可以学习，以及巨大的计算能力。</p><p id="8c68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">欢迎来到深度学习。</em> </strong></p><p id="4876" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当在足够多的数据上训练时，卷积神经网络可以学习极其复杂的映射函数。我们还不能理解卷积网络是如何学习如此复杂的函数的。</p><p id="ce13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在基本水平上，CNN(卷积神经网络)的权重由<strong class="jp ir">过滤器</strong>组成。把过滤器想象成一个由特定数字组成的(<strong class="jp ir"> <em class="kl"> n*n) </em> </strong>矩阵。现在这个过滤器是<strong class="jp ir">回旋(滑动和乘)</strong>通过提供的图像。假设输入图像的大小为(10，10 ),滤波器的大小为(3，3 ),首先将滤波器与输入图像左上角的 9 个像素相乘，该乘法产生另一个(3，3)矩阵。该矩阵的 9 个像素值相加，该值成为 CNN<strong class="jp ir">layer _ 2</strong>左上角的单个像素值。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi mw"><img src="../Images/51130b526eb79a458aa38cc1c67beaf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3aT9KWCeQ6wIYdLLhD4mCw.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">representation of convolutional networks</figcaption></figure><p id="2410" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上，CNN 的训练包括在每个滤波器上找到正确的值，使得输入图像在通过多个层时，激活最后一层的某些神经元，从而预测正确的类别。</p><p id="9f5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然从头开始训练 CNN 对于小项目来说是可能的，但是大多数应用程序需要训练非常大的 CNN，正如你所猜测的，这需要极其大量的处理数据和计算能力。这两者现在都不容易找到了。</p><p id="3bd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是迁移学习发挥作用的地方。在迁移学习中，我们采用已经训练好的模型的预训练权重(该模型已经在几天内在几个高功率 GPU 上对属于 1000 个类别的数百万幅图像进行了训练),并使用这些已经学习的特征来预测新的类别。</p><p id="8559" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">迁移学习的优势在于:</em> </strong></p><p id="b700" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl"> 1:不需要特别大的训练数据集。</em>T9】</strong></p><p id="294f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl"> 2:不需要太多计算能力。因为我们使用预先训练的权重，并且只需要学习最后几层的权重。</em>T13】</strong></p><p id="9bac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有几个模型已经在 image net 数据集上进行了训练，并且是开源的。</p><p id="10f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">比如 VGG 16，VGG 19，盗梦空间 V3 等等。有关这些型号的更多详细信息，请阅读 keras 官方文档<a class="ae la" href="https://keras.io/applications/" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h2 id="ad2b" class="ly lz iq bd ma mb mc dn md me mf dp mg jy mh mi mj kc mk ml mm kg mn mo mp mq bi translated">为什么迁移学习效果这么好？</h2><p id="0cba" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">为了了解为什么迁移学习如此有效，我们必须首先看看卷积神经网络的不同层真正在学习什么。</p><p id="b8fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们在图像数据集上训练深度卷积神经网络时，在训练过程中，通过在每层的图像上应用几个过滤器，图像穿过网络。滤波器矩阵的值与每层图像的激活相乘。来自最终层的激活用于找出图像属于哪一类。</p><p id="ee84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们训练一个深度网络时，我们的目标是找到每个滤波器矩阵的最优值，这样当一个图像通过网络传播时，输出激活可以用来准确地找到图像所属的类别。用于找到这些滤波器矩阵值的过程是梯度下降。</p><p id="91f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们在 imagenet 数据集上训练一个 conv 网络，然后看看 conv 网络每一层上的过滤器已经学会识别什么，或者每个过滤器被什么激活时，我们能够看到一些真正有趣的事情。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi mx"><img src="../Images/a9e4481f57f42ff047cd630ffcf56aee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jPCEik198_CjtmSL2H6o4g.png"/></div></div></figure><p id="eadb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">conv 网前几层的过滤器学会识别颜色和某些水平线和垂直线。</p><p id="6d20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来的几层慢慢学会使用前几层学到的线条和颜色来识别微小的形状。</p><p id="3869" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后下一层学习识别纹理，然后像腿，眼睛，鼻子等物体的一部分。</p><p id="3c55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，最后一层的过滤器被整个物体激活，比如狗、汽车等等。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi my"><img src="../Images/566d9937feebab5242ea0fa1f0a00bb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Y6HZxK-lOmqB8KnizTCow.png"/></div></div></figure><p id="ae8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们开始转移学习。它工作得如此好的原因是，我们使用了一个在 imagenet 数据集上预先训练的网络，这个网络已经学会了在其初始层中识别不同对象的微小形状和小部分。通过使用预训练网络进行迁移学习，我们只需在预训练网络的末端添加几个密集层，并了解这些已学习特征的组合有助于识别新数据集中的对象。</p><p id="646f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们只训练几个密集层。此外，我们正在使用这些已经学习的琐碎特征的组合来识别新的对象。所有这些有助于使训练过程非常快，并且与从头开始训练 conv 网络相比，需要非常少的训练数据。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="98f9" class="mz lz iq bd ma na nb nc md nd ne nf mg ng nh ni mj nj nk nl mm nm nn no mp np bi translated">现在让我们使用 Keras 中的迁移学习建立一个实际的图像识别模型。</h1><p id="795c" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">我们将在这里使用的模型是 MobileNet。</p><p id="c9eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">移动网是一种给出相当好的图像网分类精度并且占用非常少空间的模型。(根据 keras 文档显示为 17 MB)。</p><p id="c41f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">所需依赖关系:</strong></p><ul class=""><li id="7ace" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk nq ks kt ku bi translated">Keras(带 tensorflow 后端)</li><li id="f607" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk nq ks kt ku bi translated">Numpy</li><li id="7986" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk nq ks kt ku bi translated">Matplotlib</li><li id="51fb" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk nq ks kt ku bi translated">熊猫</li></ul><p id="f456" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">数据要求:</strong></p><ul class=""><li id="e522" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk nq ks kt ku bi translated">训练数据必须以特定的格式存储，以便输入网络进行训练。我们将使用 keras 中提供的 ImageDataGenerator 来根据可用数据训练我们的模型。这样，这个过程在代码方面就变得简单多了。</li><li id="947a" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk nq ks kt ku bi translated">必须有一个主数据文件夹，在该数据文件夹中，必须有一个包含相应图像的每类数据的文件夹。文件夹的名称必须是它们各自的类名。</li></ul><p id="55f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">模型的建立分三步走:</strong></p><ol class=""><li id="8352" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">导入预训练模型并添加密集层。</li><li id="0ba2" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">正在将列车数据加载到 ImageDataGenerators 中。</li><li id="534e" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">培训和评估模型。</li></ol><p id="5309" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> &lt;开始编码/ &gt; </strong></p><p id="bb68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先加载依赖项。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e1b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后导入预先训练好的 MobileNet 模型。Mobilenet(在 imagenet 数据集上训练了一千个类)将具有由 1000 个神经元组成的最后一层(每个类一个)。我们希望在网络的最后一层有多少神经元，就有多少我们希望识别的类别。因此，我们放弃了 1000 个神经元层，并为网络添加了我们自己的最后一层。</p><p id="45a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可以通过在导入模型时设置(<em class="kl"> IncludeTop=False </em>)来实现。</p><p id="c65d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，假设你想训练一个狗品种分类器来识别 120 个不同的品种，我们需要在最后一层有 120 个神经元。这可以使用下面的代码来完成。</p><p id="fae8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">这是</em> <strong class="jp ir"> <em class="kl">流程的第 1 步</em> </strong> <em class="kl">。导入和构建所需的模型。</em></p><p id="f7b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们导入没有最后一层的 MobileNet 模型，并添加一些密集层，以便我们的模型可以学习更复杂的函数。密集层必须具有 relu 激活功能，并且最后一层必须具有 softmax 激活，该层包含与类的数量一样多的神经元。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="6540" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们根据我们提供的架构制作一个模型。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="aaf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了检查我们模型的架构，我们只需要使用下面给出的这行代码。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="eb89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了模型，因为我们将使用预训练的权重，我们的模型已经在其上训练过(imagenet 数据集)，我们必须将所有权重设置为不可训练的。我们将只训练我们以前制作的最后的密集层。下面给出了执行此操作的代码。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="fbdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们进入流程的<strong class="jp ir"> <em class="kl">步骤 2 </em> </strong>，将训练数据加载到 ImageDataGenerator 中。</p><p id="8693" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ImageDataGenerators 内置在 keras 中，帮助我们训练模型。我们只需指定训练数据的路径，它就会自动批量发送训练数据。这使得代码更加简单。</p><p id="7c0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们需要博客前面提到的特定格式的训练数据。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9e40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来我们进入<strong class="jp ir"> <em class="kl">步骤 3 </em> </strong>，在数据集上训练模型。</p><p id="8061" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们首先编译我们制作的模型，然后用我们的生成器训练我们的模型。这可以使用下面的代码来完成。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="34aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这个，我们就训练出了一个模型。然后，通过使用 model.predict(new_image ),训练好的模型可用于预测新的看不见的图像属于哪一类。</p><p id="98c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae la" href="https://github.com/aditya9898/transfer-learning" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="kl">获取 Github 上的代码。</em> </strong> </a></p><p id="47f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一如既往，快乐学习。</p></div></div>    
</body>
</html>