<html>
<head>
<title>Big O</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大 O</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/big-o-d13a8b1068c8?source=collection_archive---------8-----------------------#2018-11-05">https://towardsdatascience.com/big-o-d13a8b1068c8?source=collection_archive---------8-----------------------#2018-11-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8dfd0016ea2e73d2ee79c48a0e7e1fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j8fUQjaUlmrQEN_udU0_TQ.jpeg"/></div></div></figure><p id="9d09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在准备我的编码面试的过程中，我阅读了许多教程和建议，关于我们应该把时间集中在什么上。我可以肯定地说，大 O 符号的概念是永远不会消失的。大 O 符号说明了一个算法如何根据其输入大小来扩展复杂度。它描述了函数增长的上限。大 O 符号中常见的一个误解是，它谈论算法执行的速度。有可能在不影响算法复杂度的情况下，使算法<strong class="ka ir">显著加快</strong>。大 O 表示当输入变大时，一个算法还需要做多少“工作”。</p><p id="16c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以现在你可能想知道，大 o 到底是什么，让我们给它一个正式的定义。</p><p id="aa0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在数学中，维基百科对大 O 的定义是:</p><blockquote class="kw"><p id="657b" class="kx ky iq bd kz la lb lc ld le lf kv dk translated">大 O 符号是一种数学符号，它描述了当自变量趋向特定值或无穷大时函数的极限行为。它是保罗·巴赫曼、埃德蒙·朗道等人发明的记数法家族中的一员，统称为巴赫曼-朗道记数法或渐近记数法。</p></blockquote><p id="23fc" class="pw-post-body-paragraph jy jz iq ka b kb lg kd ke kf lh kh ki kj li kl km kn lj kp kq kr lk kt ku kv ij bi translated">更具体地说，这篇文章将计算机科学中的大 O 定义为:</p><blockquote class="kw"><p id="b045" class="kx ky iq bd kz la lb lc ld le lf kv dk translated">在计算机科学中，大 O 符号用于根据算法的运行时间或空间需求如何随着输入大小的增长而增长来对算法进行分类。在解析数论中，大 O 符号通常用于表示算术函数和更好理解的近似之间的差的界限；</p></blockquote><p id="272f" class="pw-post-body-paragraph jy jz iq ka b kb lg kd ke kf lh kh ki kj li kl km kn lj kp kq kr lk kt ku kv ij bi translated">实际上，还有一些其他符号与大 O 符号密切相关，例如ω和θ。</p><p id="2f6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大ω有两个广泛存在且不相容的定义。出于本文的考虑，我们将把大ω定义为渐近下限，或者换句话说，最好的情况。例如，如果我们对一个数组进行排序，最好的情况是数组已经排序了。另一个例子是，如果我们在一个数组中搜索一个数字，它是我们检查的第一项。</p><p id="af9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，大θ指的是算法的平均运行时间。一个算法在平均输入量下会有怎样的表现？</p><p id="4321" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然在为特定解决方案选择最佳算法时考虑最佳运行时间或平均运行时间是件好事，但最好总是考虑最坏的情况。如果我们总是为最坏的情况做准备，我们可以肯定地说，我们的算法将总是比一些阈值执行得更好。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><p id="9bc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么我们如何计算一个算法的大 O 呢？</p><p id="1749" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从一个简单的例子开始:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="90b2" class="mb mc iq lx b gy md me l mf mg">int sumTwoNumbers(int a, int b) {<br/>    return a + b<br/>}</span></pre><p id="89f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们再想想大 O 是什么意思；这是一个算法的复杂性如何随着它的输入增加而增加，或者换句话说，当我们给它越来越多的输入时，一个算法还会做多少“工作”。</p><p id="6413" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在花点时间想想这个例子中的大 O 是什么…</p><p id="1f68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不，真的尝试一下…</p><p id="b4ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想想…</p><p id="7293" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想想…</p><p id="d4ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你说 O(1)，你是对的。不管我们给这个函数一个多大的数，它总会做一次加法。我们称之为恒定时间，因为我们的复杂性总是恒定的。</p><p id="c383" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看另一个例子:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="587f" class="mb mc iq lx b gy md me l mf mg">void printMatrix(int a)    {<br/>    for(int i=0; i &lt;= a; i++)    {<br/>        for(int j=0; j &lt;= a; j++)    {<br/>            cout &lt;&lt; j// Prints out a square matrix<br/>        }<br/>    }<br/>}</span></pre><p id="bc17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我们有嵌套循环，<strong class="ka ir">对于外部循环的每次</strong>迭代，我们将遍历<strong class="ka ir">整个内部循环</strong>。因此，对于我们的第一次外循环迭代，我们的内循环，假设<code class="fe mh mi mj lx b">a</code>是任意数，比如 4，它将打印:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="91b3" class="mb mc iq lx b gy md me l mf mg">1234</span></pre><p id="5d77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的下一次迭代中(i = 1 ),它将打印:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="efd1" class="mb mc iq lx b gy md me l mf mg">1234<br/>1234 </span></pre><p id="7fb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">跳到最后我们得到:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="1352" class="mb mc iq lx b gy md me l mf mg">1234<br/>1234<br/>1234<br/>1234</span></pre><p id="4238" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们把 4 个字符打印了 4 次，换句话说就是 4 个。如果使用<code class="fe mh mi mj lx b">a = 8</code>，您预计我们的代码片段会打印多少个数字。我们将为每次迭代打印 8 个字符，总共 8 个，所以是 8。你能看出模式吗？因此，对于这个片段，我们得到 O(n ),因为无论输入的大小如何，我们都将打印 n 次。</p><p id="08bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这是一个非常简单的例子，但我希望它能让你对什么是大 O 以及它是如何计算的有所了解。如果您想了解更多关于 Big O 的信息，请查看以下资源:</p><p id="60f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mk" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank">大 O 的定义</a></p><p id="9a1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mk" href="https://www.youtube.com/watch?v=v4cd1O4zkGw&amp;t=10s" rel="noopener ugc nofollow" target="_blank">大 O 上的 HackerRanks 视频</a></p><p id="c019" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读！</p><p id="13c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">**如果您喜欢这篇文章，请在底部留下评论* *</p></div></div>    
</body>
</html>