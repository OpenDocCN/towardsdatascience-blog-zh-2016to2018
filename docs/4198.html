<html>
<head>
<title>Client-side prediction with TensorFlow.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 TensorFlow.js 进行客户端预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/client-side-prediction-with-tensorflow-js-e143ed53235b?source=collection_archive---------1-----------------------#2018-07-28">https://towardsdatascience.com/client-side-prediction-with-tensorflow-js-e143ed53235b?source=collection_archive---------1-----------------------#2018-07-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1241" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大家好，我叫 Matvii，是一名<strong class="jp ir">数据科学家</strong>。我的工作包括数据预处理、<strong class="jp ir">开发/训练和部署模型</strong>。所以今天我将尝试分享我的知识，并展示如何部署一个模型，一些<strong class="jp ir">计算</strong>将由<strong class="jp ir">客户端</strong>完成<strong class="jp ir">。下面的帖子是为那些创建了一个模型，并想通过将<strong class="jp ir">预测</strong>部分委托给客户端来减少服务器负载的人准备的。尤其是对于日常使用<strong class="jp ir"> Python </strong>并且对<strong class="jp ir"> JavaScript </strong>一知半解的数据科学家来说。可以跳过这个帖子，直接进入我的<a class="ae kl" href="https://github.com/MattKovtun/TensorFlowJSClientSidePrediction" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">Github</strong></a><strong class="jp ir"/>资源库。</strong></p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="eb7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">指标<br/> </strong> 0。<strong class="jp ir"> </strong>简介<br/> 1。创建模型<br/> 2。设置<strong class="jp ir">烧瓶</strong>服务器<br/> 3。正在创建<strong class="jp ir">index.html<br/>T34】4。正在创建<strong class="jp ir">main . js</strong>T37】5。更新<strong class="jp ir">烧瓶</strong>服务器</strong></p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="8906" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 0。简介</strong> <br/>让我们想象你已经创建了一些深刻而令人敬畏的模型，它做了一些<strong class="jp ir">伟大的事情</strong> <strong class="jp ir">并且帮助人们</strong>。例如，该模型通过人们杯子的照片来预测他们最喜欢的表情符号。你把这个模型放在网上，每天的使用量大约是 1000 次查询，不是很多。简单的服务器可以处理它，但是有一天这个模型被公众发现了，你开始每天接收 10 万个查询，同一个服务器可能会<strong class="jp ir">死掉</strong>。因此，现在您可以扩展服务器并添加越来越多的内存，或者尝试在客户端重写预测。如果你选择第二个选项，这里有一个教程给你。</p><p id="8f23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现目标，我们将拥有以下<strong class="jp ir">组件</strong>。<br/> <strong class="jp ir">后端</strong> : Flask，任何你想在 python 中对一个图像进行预处理的库<br/> <strong class="jp ir">前端</strong> : tensorflowjs <br/>最近 tensorflowjs 增加了对<strong class="jp ir"> node.js </strong>的支持，不过，我们将使用<strong class="jp ir"> Flask </strong>，这是一个 python 库。通常，一些经过训练的模型需要数据<strong class="jp ir">预处理</strong>才能正确执行。到目前为止，预处理在 python 中比在 javascript 中更方便。(我希望有一天也能在客户端进行预处理)</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="60ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 1。创建模型</strong> <br/>你可以通过运行<code class="fe kt ku kv kw b">train_model.py</code>为 MNIST 训练模型，或者你可以创建和训练任何你想要的模型。这里重要的一点是保存模型的拓扑和权重。如果你的模型是用<strong class="jp ir"> keras </strong>写的，简单的加上这个。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="7805" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">保存模型后，您将拥有一个包含以下内容的文件夹。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi le"><img src="../Images/884c0c99eee16841f65154ad8326b571.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qgSGPMYlrtJAxlc6E1EEKw.png"/></div></div></figure><p id="2677" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中\* — 的<strong class="jp ir">group \ *-shard \ *是二进制权重文件的集合，<br/> <strong class="jp ir"> model.json — </strong>是模型拓扑和配置。</strong></p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="63a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2。设置 Flask 服务器</strong> <br/>是因为我们希望用户访问我们的模型。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="14eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单的服务器到目前为止，没有什么复杂的，只是一个路径返回我们的静态页面<strong class="jp ir">index.html。<br/> </strong>还有，系统的一般架构会是这样的。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ll"><img src="../Images/d5762ddb1ab2f8c67634f0dd6dbf3452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6VIdCRbFVkkHuXhmBkvB7g.jpeg"/></div></div></figure></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="1c4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3。创建 index.html<br/></strong>我们需要一些入口点，用户将与它交互，我们将在那里运行我们的预测。因此，让我们设置<strong class="jp ir">index.html。</strong></p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="e320" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的第一个版本将是这样的。这里唯一重要的是在<strong class="jp ir">第 6 行</strong>上，它从 cdn 添加了<strong class="jp ir"> tensorflowjs。<br/> </strong>下一步是添加一些<strong class="jp ir"> HTML 主体</strong>以便用户能够上传图像和点击按钮。:)在这里。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="7eea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的<strong class="jp ir"> HTML 部分</strong>的下一步也是最后一步，是给我们的页面添加一些样式，从而给 HTML 元素带来类，同时创建<strong class="jp ir"> main.js </strong>文件，该文件将包含我们的<strong class="jp ir">神奇预测部分</strong>。现在让我们看看<strong class="jp ir">index.html 的最终版本。</strong></p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="8801" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您的<strong class="jp ir">index.html</strong>可能与我的不同，您也可以添加或删除一些部分，但是，这里重要的是:<br/> — <strong class="jp ir">第 6 行</strong>(在头部添加来自<strong class="jp ir"> CDN </strong>的脚本——对于生产版本的代码来说是一个不好的做法，但是，我不想麻烦任何人解释什么是<strong class="jp ir"> npm </strong>和<strong class="jp ir">node _ modules</strong>)<br/>—<strong class="jp ir">第 13 行<strong class="jp ir"> 如果你想让用户上传一张图片，你也可以使用不同类型的输入)<br/> — <strong class="jp ir">第 20 行</strong>(我们的脚本做客户端预测)</strong></strong></p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="6367" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 4。Creating main.js <br/> </strong>现在是带来魔力的时候了。首先我们需要<strong class="jp ir">初始化按钮、输入、模型</strong>和预测的<strong class="jp ir">功能。</strong></p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="8673" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir">第 3 行</strong>我们有我们模型的 URL，到目前为止它在我的<strong class="jp ir">本地机器</strong>上，但是一般来说它可以部署在任何地方。此外，稍后我们将在 Flask 中为该模型创建一条路线。<br/>现在让我们添加将<strong class="jp ir">下载</strong>我们的<strong class="jp ir">模型</strong>的部分，然后拍摄用户上传的图像并将其发送到服务器进行<strong class="jp ir">预处理</strong>。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="dba0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将图像发送到<strong class="jp ir"> /api/prepare/ </strong>我们稍后将添加的路线。我们还将来自服务器的响应从字段<strong class="jp ir">图像</strong>放到<code class="fe kt ku kv kw b">tf.tensor2d</code>。<br/>现在是时候为我们的张量添加<strong class="jp ir">预测，然后<strong class="jp ir">将预测</strong>和图像渲染到用户的视图中。最后就是添加一些按钮例程和函数调用。</strong></p><p id="78ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以带有客户端预测的神奇脚本的最后一个版本看起来会像这样。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="b76a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请随意重写获取部分，以便在一个帖子中发送完整的<strong class="jp ir">批文件</strong>。<br/>不要忘记根据用于训练模型的形状对返回的数组进行整形！</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="8518" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 5。更新 Flask 服务器</strong> <br/>现在我们必须更新我们的服务器，这样它就可以为<strong class="jp ir"> /api/prepare </strong>对图像进行<strong class="jp ir">预处理</strong>，并且<strong class="jp ir">还可以为<strong class="jp ir"> /model </strong>的 model </strong>提供前端服务。服务器的最终版本将类似于此。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="648c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于<strong class="jp ir">的预处理</strong>部分，我们有两个函数:<br/> — <strong class="jp ir">准备</strong>(调用<strong class="jp ir">/API/prepare</strong>)<br/>—<strong class="jp ir">预处理</strong>(拍摄一幅图像，将调整后的图像返回到<strong class="jp ir"> numpy 数组，</strong>这个函数可以做任何你喜欢的预处理，只要它返回 numpy 数组，一切都会正常工作)<br/> <strong class="jp ir">模型部分:</strong>—<br/>—<strong class="jp ir"/></p><blockquote class="lm ln lo"><p id="197b" class="jn jo lp jp b jq jr js jt ju jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj kk ij bi translated">为什么我们需要两个函数和两个独立的 API 来服务一个模型，而不是一个？</p></blockquote><p id="4d50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir"> tensorflowjs </strong>的下一个版本中，当我们为某个 API <code class="fe kt ku kv kw b">model = await tf.loadModel(modelURL);<br/></code>加载模型时，它首先从<code class="fe kt ku kv kw b">modelURL</code>加载模型，这是一个 JSON 文件，然后它自动向<strong class="jp ir">域名根</strong>发送几个帖子，以便加载<strong class="jp ir">碎片</strong>(在服务器日志中的演示中查看这些帖子)。<strong class="jp ir"> </strong>因为我不想把我的模型放在服务器旁边的根目录中，所以我需要两个函数，一个用于<strong class="jp ir"> model.json </strong>，另一个用于<strong class="jp ir"> shards </strong>。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="6d32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！现在，你可以将预测人们最喜欢的表情符号(根据他们杯子的照片)发送到客户端，或者像我一样，只发送 MNIST！此外，如果一切正常，您将会看到类似这样的内容。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/ccdecde2ac86772aa55d13c556e501b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*k2PEnkM1l9Nbh3_QHcDhxw.gif"/></div></figure><p id="9880" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢您的阅读！随意添加/重写你喜欢的任何部分！尽情享受吧！<br/> <a class="ae kl" href="https://github.com/MattKovtun/TensorFlowJSClientSidePrediction" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> Github </strong> </a></p></div></div>    
</body>
</html>