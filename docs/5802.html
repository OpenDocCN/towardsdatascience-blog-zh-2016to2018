<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://towardsdatascience.com/plant-ai-plant-disease-detection-using-convolutional-neural-network-9b58a96f2289?source=collection_archive---------3-----------------------#2018-11-10">https://towardsdatascience.com/plant-ai-plant-disease-detection-using-convolutional-neural-network-9b58a96f2289?source=collection_archive---------3-----------------------#2018-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><p id="9f1a" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">下面是我如何使用<a class="ae jn" href="https://en.wikipedia.org/wiki/Convolutional_neural_network" rel="noopener ugc nofollow" target="_blank">卷积神经网络</a>(最初是为<a class="ae jn" href="https://naijahacks.com/" rel="noopener ugc nofollow" target="_blank">NaijaHacks 2018</a>黑客马拉松建造的)建立一个植物疾病检测模型</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi jo"><img src="../Images/7c91f4db68d7771b4e199ee529209f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u5W3EjhWr1-zUFxTB4mWaQ.png"/></div></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk"><strong class="bd ke">PlantAI</strong> logo Designed By <a class="kf kg ep" href="https://medium.com/u/f0034e0a6ace?source=post_page-----9b58a96f2289--------------------------------" rel="noopener" target="_blank">Victor Aremu</a></figcaption></figure><p id="b1ca" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">让我们开始吧。</p><p id="491f" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated"><strong class="ir kh">数据集</strong></p><p id="a0b1" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">我在获取患病植物叶片的数据集时遇到了一点困难。我最初不得不写一个<a class="ae jn" href="https://github.com/ahkohd/ecosia.org-image-scrapper" rel="noopener ugc nofollow" target="_blank"><strong class="ir kh">web scraper</strong></a><strong class="ir kh"/>用<strong class="ir kh"/><a class="kf kg ep" href="https://medium.com/u/f0034e0a6ace?source=post_page-----9b58a96f2289--------------------------------" rel="noopener" target="_blank"><strong class="ir kh">Victor Aremu</strong></a>来刮<a class="ae jn" href="http://ecosia.org" rel="noopener ugc nofollow" target="_blank">ecosia.org</a>直到我在<a class="ae jn" href="https://www.crowdai.org" rel="noopener ugc nofollow" target="_blank"> crowdAI </a>上发现这个数据集来自<a class="ae jn" href="https://www.crowdai.org/challenges/plantvillage-disease-classification-challenge/dataset_files" rel="noopener ugc nofollow" target="_blank"><strong class="ir kh"><em class="ki">plant village Disease</em></strong>分类挑战</a>。我终于从<a class="ae jn" href="https://github.com/spMohanty" rel="noopener ugc nofollow" target="_blank"> spMohanty </a>的 Github 上找到了这个<a class="ae jn" href="https://github.com/spMohanty/PlantVillage-Dataset/tree/master/raw/color" rel="noopener ugc nofollow" target="_blank">数据</a>并选定了它。我用下面的命令下载了彩色图像</p><blockquote class="kj kk kl"><p id="d18d" class="io ip ki ir b is it iu iv iw ix iy iz km jb jc jd kn jf jg jh ko jj jk jl jm ij bi translated">svn 导出<a class="ae jn" href="https://github.com/spMohanty/PlantVillage-Dataset/trunk/raw/color" rel="noopener ugc nofollow" target="_blank">https://github . com/spMohanty/plant village-Dataset/trunk/raw/color</a></p></blockquote><p id="408a" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">这是我的数据集文件结构的样子。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/93957941b3920be1bd245ae5f8fc1cb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*FDm3Qo4mC7z9KqiVd7Jojw.png"/></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk">File structure for the dataset used</figcaption></figure><p id="76cf" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">下载数据集后，我在我的系统上编写了代码(MacBook pro 2.3 GHz 英特尔酷睿 i5，8Gb 内存，英特尔高清显卡 3000 512 MB)。相信我，这是令人沮丧的(我的系统在某个时候挂起)。然后<a class="kf kg ep" href="https://medium.com/u/10cf0dba197a?source=post_page-----9b58a96f2289--------------------------------" rel="noopener" target="_blank">瑞星 Odegua </a>告诉我用<a class="ae jn" href="https://www.kaggle.com/" rel="noopener ugc nofollow" target="_blank"> Kaggle 内核。</a>天哪！！我有一个 kaggle 账户，我用<a class="ae jn" href="https://www.kaggle.com/" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>参加<a class="ae jn" href="https://www.datasciencenigeria.org/" rel="noopener ugc nofollow" target="_blank">尼日利亚</a>的数据科学竞赛。我就是没想到。我只是有这种免费的处理能力和 GPU 躺在那里未被利用。</p><p id="9ac1" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">另一个问题，我以前没有使用过<a class="ae jn" href="https://www.kaggle.com/" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>内核，我不用笔记本来编码，所以像这样的问题</p><ul class=""><li id="7a2b" class="kq kr iq ir b is it iw ix ja ks je kt ji ku jm kv kw kx ky bi translated">如何导入数据集？</li><li id="35bd" class="kq kr iq ir b is kz iw la ja lb je lc ji ld jm kv kw kx ky bi translated">是不是类似于 Linux 系统，我要安装包？</li><li id="c394" class="kq kr iq ir b is kz iw la ja lb je lc ji ld jm kv kw kx ky bi translated">它是免费的吗？？我可以免费使用 GPU 吗？</li></ul><p id="8e86" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">我决定尝试一下。它很容易使用，必要的软件包已经安装。我只需要开始编码。由于我的数据集在<a class="ae jn" href="https://www.kaggle.com/" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>上不可用，我不得不上传。然后我开始了。</p><p id="80d7" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">如果你不想使用 Kaggle 内核，你必须安装这个软件包</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div class="gh gi le"><img src="../Images/8ed12b39e989e3edbf1aa37d1f5fdf5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*88SjM6M8wdiz6jx0I7savQ.png"/></div></figure><ul class=""><li id="80dc" class="kq kr iq ir b is it iw ix ja ks je kt ji ku jm kv kw kx ky bi translated">在此下载数据集<a class="ae jn" href="https://www.kaggle.com/emmarex/plantdisease" rel="noopener ugc nofollow" target="_blank">或直接在 Kaggle 上使用</a></li><li id="8f0c" class="kq kr iq ir b is kz iw la ja lb je lc ji ld jm kv kw kx ky bi translated">接下来的事情是导入必要的包</li></ul><ol class=""><li id="68bb" class="kq kr iq ir b is it iw ix ja ks je kt ji ku jm lf kw kx ky bi translated"><a class="ae jn" href="http://www.numpy.org/" rel="noopener ugc nofollow" target="_blank">Numpy</a>:Python 编程语言的库，增加了对大型多维数组和矩阵的支持，以及对这些数组进行操作的大量高级数学函数。(来源:<a class="ae jn" href="https://en.wikipedia.org/wiki/Scikit-learn" rel="noopener ugc nofollow" target="_blank">维基百科</a>)</li><li id="3297" class="kq kr iq ir b is kz iw la ja lb je lc ji ld jm lf kw kx ky bi translated"><a class="ae jn" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> Sklearn </a>:一个<a class="ae jn" href="https://en.wikipedia.org/wiki/Free_software" rel="noopener ugc nofollow" target="_blank">免费软件</a> <a class="ae jn" href="https://en.wikipedia.org/wiki/Machine_learning" rel="noopener ugc nofollow" target="_blank">机器学习</a> <a class="ae jn" href="https://en.wikipedia.org/wiki/Library_(computing)" rel="noopener ugc nofollow" target="_blank">库</a>为<a class="ae jn" href="https://en.wikipedia.org/wiki/Python_(programming_language)" rel="noopener ugc nofollow" target="_blank"> Python </a>编程语言。它具有各种<a class="ae jn" href="https://en.wikipedia.org/wiki/Statistical_classification" rel="noopener ugc nofollow" target="_blank">分类</a>、<a class="ae jn" href="https://en.wikipedia.org/wiki/Regression_analysis" rel="noopener ugc nofollow" target="_blank">回归</a>和<a class="ae jn" href="https://en.wikipedia.org/wiki/Cluster_analysis" rel="noopener ugc nofollow" target="_blank">聚类</a>算法，包括<a class="ae jn" href="https://en.wikipedia.org/wiki/Support_vector_machine" rel="noopener ugc nofollow" target="_blank">支持向量机</a>、<a class="ae jn" href="https://en.wikipedia.org/wiki/Random_forests" rel="noopener ugc nofollow" target="_blank">随机森林</a>、<a class="ae jn" href="https://en.wikipedia.org/wiki/Gradient_boosting" rel="noopener ugc nofollow" target="_blank">梯度推进</a>、<a class="ae jn" href="https://en.wikipedia.org/wiki/K-means_clustering" rel="noopener ugc nofollow" target="_blank">、<em class="ki"> k </em> -means </a>和<a class="ae jn" href="https://en.wikipedia.org/wiki/DBSCAN" rel="noopener ugc nofollow" target="_blank"> DBSCAN </a>，并且被设计为与 Python 数值和科学库<a class="ae jn" href="https://en.wikipedia.org/wiki/NumPy" rel="noopener ugc nofollow" target="_blank"> NumPy </a>和<a class="ae jn" href="https://en.wikipedia.org/wiki/SciPy" rel="noopener ugc nofollow" target="_blank">互操作(来源:</a><a class="ae jn" href="https://en.wikipedia.org/wiki/Scikit-learn" rel="noopener ugc nofollow" target="_blank">维基百科</a>)</li><li id="0313" class="kq kr iq ir b is kz iw la ja lb je lc ji ld jm lf kw kx ky bi translated"><a class="ae jn" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank"> Keras </a> : Keras 是用 Python 编写的开源神经网络库。它能够在 TensorFlow、微软认知工具包或 Theano 上运行。旨在实现深度神经网络的快速实验，它专注于用户友好、模块化和可扩展。(来源:<a class="ae jn" href="https://en.wikipedia.org/wiki/Scikit-learn" rel="noopener ugc nofollow" target="_blank">维基百科</a>)</li><li id="315f" class="kq kr iq ir b is kz iw la ja lb je lc ji ld jm lf kw kx ky bi translated">Matplotlib:Python 编程语言及其数值数学扩展的绘图库。</li></ol><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi lg"><img src="../Images/5cfe165b56a6445350faca83c3a15d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*60o7stsLHhbjc2yTrrayQQ.png"/></div></div></figure><ul class=""><li id="62da" class="kq kr iq ir b is it iw ix ja ks je kt ji ku jm kv kw kx ky bi translated">我做的下一件事是加载数据集——患病植物的图像</li></ul><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi lh"><img src="../Images/1eae8e60f577964e1457fd1f322f6ccf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*Piz_pfoNO6etlZb50XdUHQ.png"/></div></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk">Loading of the images from the data set</figcaption></figure><p id="2604" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">从上面的图片来看</p><p id="6de2" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">我从每个文件夹中只挑选了 200 张图片，但是你可以选择添加更多</p><p id="1395" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated"><strong class="ir kh"> B </strong> -我使用下面的函数将每张图片转换成一个数组。在使用同样的函数将每个图像转换成一个数组后，你应该得到类似于下图(右)中每个图像的东西。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div class="gh gi li"><img src="../Images/eb7159c0f45eaf796116578abe2beda8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*_WBO6sfN399jfim5sLsisw.png"/></div></figure><ul class=""><li id="228a" class="kq kr iq ir b is it iw ix ja ks je kt ji ku jm kv kw kx ky bi translated">使用<a class="ae jn" href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelBinarizer.html" rel="noopener ugc nofollow" target="_blank"> Scikit-learn 的标签二进制化器</a>，我将每个图像标签转换成二进制等级。然后我使用<a class="ae jn" href="https://docs.python.org/3/library/pickle.html" rel="noopener ugc nofollow" target="_blank"> pickle </a>保存了标签二进制化实例，之后我打印了标签二进制化器中的类。</li></ul><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi lj"><img src="../Images/3c51abb97c2ccee4797613cc68d09ee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HJ8eFILMtsrcGfvKAtUD0A.png"/></div></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk">Converting the image labels to binary using Scikit-learn’s Label Binarizer</figcaption></figure><ul class=""><li id="8be6" class="kq kr iq ir b is it iw ix ja ks je kt ji ku jm kv kw kx ky bi translated">在<strong class="ir kh">单元格 8 </strong>(下图)中，我通过将数据点从[0，255](图像的最小和最大 RGB 值)缩放到范围[0，1]来进一步预处理输入数据。在<strong class="ir kh">单元格 9 </strong>中，我对数据进行了训练/测试分割，将 80%的图像用于训练，20%用于测试。在<strong class="ir kh">单元格 10 </strong>中，我<strong class="ir kh"> </strong>创建了一个图像生成器对象，它可以对我们的图像数据集执行随机旋转、移动、翻转、裁剪和剪切。这使得我们可以使用更小的数据集，但仍然可以获得高质量的结果。</li></ul><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi lk"><img src="../Images/7819f0b7024464772d5a5865ee77fc1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1UjBvMwYvIkn5Y0lho6mfQ.png"/></div></div></figure><ul class=""><li id="fec5" class="kq kr iq ir b is it iw ix ja ks je kt ji ku jm kv kw kx ky bi translated">接下来，我创建了我的模型。在该模型中，我们默认采用“<strong class="ir kh"> channel_last </strong>”体系结构，但也为支持第四行“<strong class="ir kh"> channel_first </strong>”的后端创建了一个交换机。然后我创建了第一个<strong class="ir kh">conv</strong>=&gt;<strong class="ir kh">RELU</strong>=&gt;<strong class="ir kh">池</strong>。我们的<strong class="ir kh"> CONV </strong>层有 32 个 3×3 内核的滤镜和<strong class="ir kh"> RELU </strong>激活(整流线性单元)。我们应用批量标准化、最大池化和 25% (0.25)的退出率。</li></ul><blockquote class="kj kk kl"><p id="45de" class="io ip ki ir b is it iu iv iw ix iy iz km jb jc jd kn jf jg jh ko jj jk jl jm ij bi translated"><strong class="ir kh"> Dropout </strong>是一种正则化技术，通过防止对训练数据进行复杂的自适应来减少神经网络中的过拟合。这是用神经网络进行模型平均的一种非常有效的方法。(来源:<a class="ae jn" href="https://en.wikipedia.org/wiki/Dropout_(neural_networks)" rel="noopener ugc nofollow" target="_blank">维基百科</a>)</p></blockquote><p id="5cb3" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">接下来我创建了两组(<strong class="ir kh">conv</strong>=&gt;T36】RELU)* 2 =&gt;<strong class="ir kh">池</strong>块。然后只有一组<strong class="ir kh"> FC </strong>(全连接层)=&gt;<strong class="ir kh"/>层</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi ll"><img src="../Images/cf4f8aa24886c4944e61699e8206f760.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nGAVUhas_okQAH-AptJm3w.png"/></div></div></figure><ul class=""><li id="89d6" class="kq kr iq ir b is it iw ix ja ks je kt ji ku jm kv kw kx ky bi translated">在<strong class="ir kh">单元 13，</strong>中，我为我的模型使用了<a class="ae jn" href="https://keras.io/optimizers/#adam" rel="noopener ugc nofollow" target="_blank"> Keras Adam 优化器</a>。在<strong class="ir kh">单元 14 </strong>中开始训练我们的网络，在这里我们调用<strong class="ir kh"> model.fit_generator </strong>，提供我们的数据扩充对象、训练/测试数据以及我们希望训练的时期数。我为这个项目使用了 25 的<strong class="ir kh"> epochs 值。</strong></li></ul><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi lm"><img src="../Images/29ecd545b75e0a13f92ea8842d4b9668.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SvPTmnmFjSsnB9TgxkWw0A.png"/></div></div></figure><ul class=""><li id="e6b0" class="kq kr iq ir b is it iw ix ja ks je kt ji ku jm kv kw kx ky bi translated">图表绘制—使用<a class="ae jn" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> matplotlib </a>，我在<strong class="ir kh">单元格 15 </strong>中绘制了一个关于训练和验证准确性以及训练和验证损失的图表</li></ul><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi ln"><img src="../Images/51a9c6f233950413e7213f780b6fb283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N-xTfa2-Po6KtkHYswf81Q.png"/></div></div></figure><figure class="jp jq jr js gt jt gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/7625d571a20df321394c8710f25591bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*3HD42g4lIhoa2-JWg5KfTg.png"/></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk">Training and Validation accuracy and Training and Validation loss graph</figcaption></figure><ul class=""><li id="c0bb" class="kq kr iq ir b is it iw ix ja ks je kt ji ku jm kv kw kx ky bi translated">最后，在<strong class="ir kh">单元格 16 </strong>中，我使用之前创建的验证数据(x_test 和 y_test)计算了我的模型的准确性。我得到了<strong class="ir kh"> 96.77 </strong> %的准确率。在<strong class="ir kh">单元格 17 </strong>中，我使用<a class="ae jn" href="https://docs.python.org/3/library/pickle.html" rel="noopener ugc nofollow" target="_blank"> Pickle </a>保存了训练好的模型以备将来使用。</li></ul><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi lp"><img src="../Images/c263da922a6a8121a647111c8867c7f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RqD8HFfDJTJTAB6SG41ukw.png"/></div></div></figure><p id="bbfb" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">你可以在 Kaggle <a class="ae jn" href="https://www.kaggle.com/emmarex/plant-disease-detection-using-keras" rel="noopener ugc nofollow" target="_blank">这里</a>找到完整的源代码。查看我的下一篇文章，在那里我讨论了如何通过一个<strong class="ir kh"> API </strong>将这个模型部署到一个移动应用程序中。</p></div></div>    
</body>
</html>