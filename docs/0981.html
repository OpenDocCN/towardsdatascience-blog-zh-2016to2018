<html>
<head>
<title>Aggregation and Grouping</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">聚合和分组</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/aggregation-and-grouping-66396f26dd95?source=collection_archive---------6-----------------------#2017-07-17">https://towardsdatascience.com/aggregation-and-grouping-66396f26dd95?source=collection_archive---------6-----------------------#2017-07-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2b2b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">GSoC:在 Pharo 中实现数据框架</h2></div><p id="b7d7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是 Pharo <code class="fe lb lc ld le b">DataFrame</code>中聚合和分组的第一个实现。它仅涵盖基本功能，例如按相应大小的另一个系列的值对数据框或系列进行分组，然后将聚合函数应用于分组的数据结构。</p><p id="67bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在接下来的迭代中，该功能将根据目标用户场景进行扩展。实现也很有可能发展成更加优化的东西。</p><h2 id="cb1c" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">什么是 DataFrame？</h2><p id="2155" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">数据框是一种类似电子表格的表格数据结构，它提供了一个用于切割、清理和分析数据的 API。在<a class="ae md" href="http://pharo.org/" rel="noopener ugc nofollow" target="_blank"> Pharo </a>中实现数据帧是我今年<a class="ae md" href="https://summerofcode.withgoogle.com/about/" rel="noopener ugc nofollow" target="_blank">谷歌代码之夏</a>项目的一部分。您可以在这个库中找到代码:<a class="ae md" href="https://github.com/PolyMathOrg/DataFrame" rel="noopener ugc nofollow" target="_blank">https://github.com/PolyMathOrg/DataFrame</a>，并使用下面的 Metacello 脚本将其加载到您的映像中:</p><pre class="me mf mg mh gt mi le mj mk aw ml bi"><span id="a6ed" class="lf lg iq le b gy mm mn l mo mp">Metacello new<br/>  baseline: 'DataFrame';<br/>  repository: 'github://PolyMathOrg/DataFrame';<br/>  load.</span></pre><p id="0ebc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想了解更多关于 DataFrame 项目的信息，请查阅文档并遵循您可以在资源库中找到的教程。文档仍在开发中，所以如果你找不到问题的答案，请随时给我写信:<em class="mq">olk.zaytsev@gmail.com</em>。</p><h2 id="0a7b" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">拆分-应用-合并</h2><blockquote class="mr ms mt"><p id="a056" class="kf kg mq kh b ki kj jr kk kl km ju kn mu kp kq kr mv kt ku kv mw kx ky kz la ij bi translated">分割-应用-组合是一种策略，你把一个大问题分解成可管理的小块，独立地处理每一块，然后把所有的小块组合起来。</p></blockquote><p id="7d56" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据聚合和分组允许我们为显示或分析创建汇总，例如，在计算平均值或创建计数或总和表时。这是一个遵循分割-应用-组合策略的过程:</p><ol class=""><li id="9e22" class="mx my iq kh b ki kj kl km ko mz ks na kw nb la nc nd ne nf bi translated">根据某些标准将数据分组</li><li id="e011" class="mx my iq kh b ki ng kl nh ko ni ks nj kw nk la nc nd ne nf bi translated">将该函数独立应用于每个组</li><li id="db68" class="mx my iq kh b ki ng kl nh ko ni ks nj kw nk la nc nd ne nf bi translated">将结果组合成一个数据结构</li></ol><h1 id="22bb" class="nl lg iq bd lh nm nn no lk np nq nr ln jw ns jx lq jz nt ka lt kc nu kd lw nv bi translated">履行</h1><p id="eb83" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">在这一节中，我将解释聚合和分组功能目前是如何实现的。如果您对这些细节不感兴趣，可以跳过这一部分，跳到下一部分。</p><p id="3173" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑以下发送到<code class="fe lb lc ld le b">firstSeries</code>对象的消息:</p><pre class="me mf mg mh gt mi le mj mk aw ml bi"><span id="cc18" class="lf lg iq le b gy mm mn l mo mp">firstSeries groupBy: secondSeries.</span></pre><p id="b660" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">收到这个消息后，<code class="fe lb lc ld le b">firstSeries</code>创建了一个对象<code class="fe lb lc ld le b">DataSeriesGrouped</code>，它根据<code class="fe lb lc ld le b">secondSeries</code>的值将<code class="fe lb lc ld le b">firstSeries</code>分割成一系列子序列。然后，子系列的集合被存储为<code class="fe lb lc ld le b">DataSeries</code>(名为<code class="fe lb lc ld le b">groups</code>的实例变量)的对象，其键等于<code class="fe lb lc ld le b">secondSeries</code>的唯一值，值存储<code class="fe lb lc ld le b">firstSeries</code>的子系列，对应于这些唯一值中的每一个。</p><figure class="me mf mg mh gt nx gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/4cedfa0c53b30bdb13c180e5f670ebe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*MIRvPVpekjqG6Sm1yX8UaQ.png"/></div></figure><p id="a21f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当一个<code class="fe lb lc ld le b">groupBy:</code>消息的接收者是一个<code class="fe lb lc ld le b">DataFrame</code>时，它创建一个<code class="fe lb lc ld le b">DataFrameGrouped</code>的实例，该实例以类似于<code class="fe lb lc ld le b">DataSeriesGroup</code>的方式分割数据，除了<code class="fe lb lc ld le b">groups</code>系列的值是子数据帧，而不是子系列。换句话说，<code class="fe lb lc ld le b">groups</code>是一个<code class="fe lb lc ld le b">DataSeries</code>，其关键字对应于数据帧分组所依据的系列的唯一值(<code class="fe lb lc ld le b">secondSeries</code>)，并且<code class="fe lb lc ld le b">groups</code>的每个值存储一个较小的数据帧，该数据帧具有由数字指定的行，其中<code class="fe lb lc ld le b">secondSeries</code>的值等于<code class="fe lb lc ld le b">groups</code>的对应关键字。如果数据框按其中一列进行分组，则在分组之前，该列将从数据框中排除。这样我们避免了数据重复，因为相同的值将作为<code class="fe lb lc ld le b">groups</code>变量的关键字存储。</p><p id="28d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lb lc ld le b">DataSeriesGrouped</code>的情况下，每个子序列将被聚合成一个标量，所有这些标量将被组合成一个新的<code class="fe lb lc ld le b">DataSeries</code>。至于<code class="fe lb lc ld le b">DataFrameGrouped</code>，它会将块应用于每个子数据帧的每一列，并将结果标量矩阵作为新的<code class="fe lb lc ld le b">DataFrame</code>返回。</p><p id="1758" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">聚合是通过<code class="fe lb lc ld le b">apply:</code>消息完成的。它将一个块作为参数，并将其应用于 groups 系列的每个值，并将结果组合成一个新的数据结构。对于一些常用的聚合函数，如<code class="fe lb lc ld le b">max</code>、<code class="fe lb lc ld le b">min</code>、<code class="fe lb lc ld le b">average</code>等。，<code class="fe lb lc ld le b">DataGrouped</code>提供更短的消息。在这个迭代中，所有这些消息都只是方便的快捷方式</p><pre class="me mf mg mh gt mi le mj mk aw ml bi"><span id="48be" class="lf lg iq le b gy mm mn l mo mp">average<br/>   ^ self apply: [ :each | each average ].</span></pre><p id="93e9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是在将来，这些消息将包含相应聚合的优化实现，因为这些函数的时间和内存效率非常重要。</p><h1 id="7c0b" class="nl lg iq bd lh nm nn no lk np nq nr ln jw ns jx lq jz nt ka lt kc nu kd lw nv bi translated">用法示例</h1><p id="c56b" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">在这一节中，我将提供一些简单的示例，例如按另一个系列的值对一个系列进行分组，按一个系列的值对一个数据框进行分组，最后我将展示如何将聚合函数应用于分组后的数据。</p><h2 id="b828" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">餐馆小费数据集</h2><p id="1f61" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">我将把我的例子建立在餐馆小费的数据集上。它最初出现在 Bryant &amp; Smith 1995 年关于商业统计的文章中。您可以在这个 GitHub 资源库中获得一个带有 tipping 数据集的 CSV 文件:<a class="ae md" href="https://github.com/wesm/pydata-book/blob/master/ch08/tips.csv" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/wesm/pydata-book/blob/master/ch08/tips . CSV</a>。</p><p id="7450" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们使用<code class="fe lb lc ld le b">fromCSV:</code>方法将数据读入<code class="fe lb lc ld le b">DataFrame</code></p><pre class="me mf mg mh gt mi le mj mk aw ml bi"><span id="3dad" class="lf lg iq le b gy mm mn l mo mp">tips := DataFrame fromCSV: '/path/to/tips.csv'.</span></pre><p id="30b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">快速了解存储在数据框中的数据集的最简单的方法是查看其标题-前 5 行(<code class="fe lb lc ld le b">tips head</code>)</p><pre class="me mf mg mh gt mi le mj mk aw ml bi"><span id="63e0" class="lf lg iq le b gy mm mn l mo mp">  |  total_bill  tip    sex     smoker  day  time    size<br/>--+------------------------------------------------------<br/>1 |  16.99       1.01   Female  No      Sun  Dinner  2<br/>2 |  10.34       1.66   Male    No      Sun  Dinner  3<br/>3 |  21.01       3.5    Male    No      Sun  Dinner  3<br/>4 |  23.68       3.31   Male    No      Sun  Dinner  2<br/>5 |  24.59       3.61   Female  No      Sun  Dinner  4</span></pre><p id="90a0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，tipping 数据集有 2 个定量变量:<code class="fe lb lc ld le b">total_bill</code>和<code class="fe lb lc ld le b">tip</code>，5 个分类变量:<code class="fe lb lc ld le b">sex</code>、<code class="fe lb lc ld le b">smoker</code>、<code class="fe lb lc ld le b">day</code>、<code class="fe lb lc ld le b">time</code>和<code class="fe lb lc ld le b">size</code>。在下面提供的例子中，我们将只根据分类变量对数据结构进行分组。从技术上来说，也可以通过数量变量进行分组，但在大多数情况下，这种分组不是很有用(更不用说它在教程中看起来不太好)。</p><h2 id="e865" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">分组系列</h2><p id="5b06" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">应用<code class="fe lb lc ld le b">groupBy</code>操作符的最简单的例子是将一个系列的值按照另一个相同大小的值进行分组。</p><pre class="me mf mg mh gt mi le mj mk aw ml bi"><span id="79fd" class="lf lg iq le b gy mm mn l mo mp">bill := tips column: #total_bill.<br/>sex := tips column: #sex.</span><span id="4673" class="lf lg iq le b gy oa mn l mo mp">bill groupBy: sex.</span></pre><p id="0104" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个查询的结果将是一个对象<code class="fe lb lc ld le b">DataSeriesGrouped</code>，它将<code class="fe lb lc ld le b">bill</code>分成两个系列，映射到<code class="fe lb lc ld le b">sex</code>系列的<code class="fe lb lc ld le b">‘Male’</code>和<code class="fe lb lc ld le b">‘Female’</code>值。</p><pre class="me mf mg mh gt mi le mj mk aw ml bi"><span id="ba03" class="lf lg iq le b gy mm mn l mo mp">Female  (16.99 24.59 35.26 14.83 ... 18.78)<br/>Male    (10.34 21.01 23.68 25.29 ... 17.82)</span></pre><p id="03d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于大多数情况下我们需要对属于单个数据框的两列序列进行分组，因此有一个方便的快捷方式:</p><pre class="me mf mg mh gt mi le mj mk aw ml bi"><span id="830c" class="lf lg iq le b gy mm mn l mo mp">tips group: #total_bill by: #sex.</span></pre><h2 id="8ff8" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">分组数据框</h2><p id="c09b" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">除了上面演示的对其列进行分组的快捷方式之外，<code class="fe lb lc ld le b">DataFrame</code>还提供了一种通过其中一列对自身进行分组的方法。</p><pre class="me mf mg mh gt mi le mj mk aw ml bi"><span id="bf8e" class="lf lg iq le b gy mm mn l mo mp">tips groupBy: #smoker</span></pre><p id="1ea6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该查询的结果将是一个对象<code class="fe lb lc ld le b">DataFrameGrouped</code>，存储两个独立的数据帧——一个针对所有吸烟者，一个针对非吸烟者。<code class="fe lb lc ld le b">smoker</code>列将从这些数据框中排除，因为它的值将作为键存储在<code class="fe lb lc ld le b">DataFrameGrouped</code>对象中，吸烟者和非吸烟者的单独分组将允许我们在需要时完全重建<code class="fe lb lc ld le b">smoker</code>列。</p><h2 id="e0f9" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">聚集分组数据</h2><p id="62a1" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">聚合函数将一个序列作为输入，并返回一个汇总该序列值的标量值。这些是统计函数:<code class="fe lb lc ld le b">min</code>、<code class="fe lb lc ld le b">max</code>、<code class="fe lb lc ld le b">average</code>、<code class="fe lb lc ld le b">stdev</code>等。，像<code class="fe lb lc ld le b">sum</code>、<code class="fe lb lc ld le b">count</code>等很多功能。</p><p id="5eed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦数据被分组，我们就可以对组成的组应用聚合函数，并接收汇总初始数据的组合数据结构</p><pre class="me mf mg mh gt mi le mj mk aw ml bi"><span id="3cd7" class="lf lg iq le b gy mm mn l mo mp">grouped := tips group: #total_bill by: #day.<br/>grouped apply: [ :each | each average round: 2].</span></pre><p id="42d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们是按照另一列对<code class="fe lb lc ld le b">DataFrame</code>的一列进行分组，所以结果将是一个<code class="fe lb lc ld le b">DataSeries</code>的对象</p><pre class="me mf mg mh gt mi le mj mk aw ml bi"><span id="3920" class="lf lg iq le b gy mm mn l mo mp">a DataSeries<br/>Sun   21.41<br/>Sat   20.44<br/>Thur  17.68<br/>Fri   17.15</span></pre><p id="a639" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如前所述，<code class="fe lb lc ld le b">DataGrouped</code>提供了一些常用聚合函数的快捷方式，如<code class="fe lb lc ld le b">min</code>、<code class="fe lb lc ld le b">max</code>、<code class="fe lb lc ld le b">average</code>、<code class="fe lb lc ld le b">sum</code>、<code class="fe lb lc ld le b">count</code>等。目前它们只是快捷方式，但以后它们将实现应用速度更快的优化聚合(对于像<em class="mq"> tipping </em>这样的小数据集，速度不是一个严重的问题)</p><pre class="me mf mg mh gt mi le mj mk aw ml bi"><span id="9dfe" class="lf lg iq le b gy mm mn l mo mp">grouped min.<br/>grouped max.<br/>grouped average.</span></pre><p id="6639" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦数据帧被分组到一个对象<code class="fe lb lc ld le b">DataFrameGrouped</code>中，我们也可以对这个对象应用一个聚合函数。DataFrameGrouped 实现 apply:消息的方式是将函数应用于每个子数据帧的每一列，从而产生标量值。这些标量然后被组合成一个新的数据帧。</p><pre class="me mf mg mh gt mi le mj mk aw ml bi"><span id="429c" class="lf lg iq le b gy mm mn l mo mp">(tips groupBy: #sex) count.</span></pre><p id="4e68" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此查询的结果将是一个数据框，其中包含每一列的非空单元格的数量，对应于“男性”和“女性”行</p><pre class="me mf mg mh gt mi le mj mk aw ml bi"><span id="8a43" class="lf lg iq le b gy mm mn l mo mp">       | total_bill  tip  smoker  day  time  size<br/>-------+-----------------------------------------<br/>Female | 87          87   87      87   87    87<br/>Male   | 157         157  157     157  157   157</span></pre><h1 id="4858" class="nl lg iq bd lh nm nn no lk np nq nr ln jw ns jx lq jz nt ka lt kc nu kd lw nv bi translated">资源</h1><ol class=""><li id="2458" class="mx my iq kh b ki ly kl lz ko ob ks oc kw od la nc nd ne nf bi translated">McKinney Wes，用于数据分析的 Python，O'Reilly Media，Inc .，2012 年</li><li id="71b8" class="mx my iq kh b ki ng kl nh ko ni ks nj kw nk la nc nd ne nf bi translated">哈德利·威克姆(2011)。数据分析的分离-应用-组合策略。统计软件杂志，40(1)，1–29。网址 http://www.jstatsoft.org/v40/i01/<a class="ae md" href="http://www.jstatsoft.org/v40/i01/" rel="noopener ugc nofollow" target="_blank"/>。</li><li id="abba" class="mx my iq kh b ki ng kl nh ko ni ks nj kw nk la nc nd ne nf bi translated"><a class="ae md" href="https://pandas.pydata.org/pandas-docs/stable/groupby.html" rel="noopener ugc nofollow" target="_blank">https://pandas.pydata.org/pandas-docs/stable/groupby.html</a></li><li id="da5e" class="mx my iq kh b ki ng kl nh ko ni ks nj kw nk la nc nd ne nf bi translated"><a class="ae md" href="https://www.postgresql.org/docs/9.5/static/tutorial-agg.html" rel="noopener ugc nofollow" target="_blank">https://www . PostgreSQL . org/docs/9.5/static/tutorial-agg . html</a></li><li id="9d0c" class="mx my iq kh b ki ng kl nh ko ni ks nj kw nk la nc nd ne nf bi translated"><a class="ae md" href="https://github.com/wesm/pydata-book/blob/master/ch08/tips.csv" rel="noopener ugc nofollow" target="_blank">https://github . com/wesm/pydata-book/blob/master/ch08/tips . CSV</a></li></ol></div></div>    
</body>
</html>