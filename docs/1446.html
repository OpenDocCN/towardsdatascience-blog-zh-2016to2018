<html>
<head>
<title>Python Speed Test: 5 Methods To Remove The ‘$’ From Your Data in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 速度测试:用 Python 从数据中删除“$”的 5 种方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-methods-to-remove-the-from-your-data-in-python-and-the-fastest-one-281489382455?source=collection_archive---------1-----------------------#2017-09-06">https://towardsdatascience.com/5-methods-to-remove-the-from-your-data-in-python-and-the-fastest-one-281489382455?source=collection_archive---------1-----------------------#2017-09-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="19b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae ko" href="https://medium.com/@chaimgluck1/predicting-iowa-liquor-sales-9f3932ab1ed" rel="noopener">之前的一篇关于爱荷华州白酒销售回归项目的帖子</a>中，我提到这是我第一次处理足够大的数据，以至于担心编写代码来优化速度。在这篇文章中，我将介绍一个相对简单的例子。</p><p id="aeff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我们正在处理的数据。注意“state_bottle_retail”列。每个条目都以美元符号开始，为了使值变成数字，我需要删除这些美元符号。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/ba14a990fdbcb2c4b140bff10a1c077c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B1tdUKcO91VjSHwjOZvnGg.png"/></div></div></figure><p id="71d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在 Python 中有很多不同的方法来完成这个任务。但是由于这个数据集的大小，优化变得很重要。我将演示一些方法，并报告它们花费了多少时间。一个注意事项:我将在整个数据集的 10%的一个小的子集上做这些测试。因此，尽管速度都非常快，最慢的只有 130 毫秒多一点，但当规模变大时，问题就更大了。这也是为了表示优化的重要性和实践。这是一个相对简单的例子，但是在某些情况下，这样的实践可以节省几个小时甚至几天。</p><p id="066a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于这些测试，我将使用 Jupyter 笔记本中的<code class="fe lb lc ld le b">%timeit</code> cell magic。这是一个方便的工具，它运行操作的多个循环，并报告其最佳性能时间。要做到这一点，您只需在行首键入<code class="fe lb lc ld le b">%timeit</code>，运行单元格，然后查看结果。</p><p id="4e82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我将向您展示我运行的所有测试的图片，然后我们将一个一个地浏览它们。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lf"><img src="../Images/829482332c2828755be4de51482a47c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zRtCJlhI6CZU8h4DgxuULw.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Faster, faster, faster!</figcaption></figure><p id="09bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我在整篇文章中使用了<code class="fe lb lc ld le b">str.replace('$','')</code>方法。这是最直接的方法，因为它只是用一个空格来替换列中每一项的' $ '。正如你所看到的，这是最慢的选择，但它仍然像我上面提到的那样相对较快。这意味着在超过 200 万行的完整数据集上，只需要一秒钟就可以完成。真快。但是这篇文章是关于变得更快。</p><p id="dc13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一个方法使用 pandas 的“apply”方法，该方法被优化为对 pandas 列执行操作。“apply”方法要求对列中的每个值运行一个函数，所以我编写了一个 lambda 函数来执行相同的功能。在<a class="ae ko" href="https://medium.com/@chaimgluck1/have-messy-text-data-clean-it-with-simple-lambda-functions-645918fcc2fc" rel="noopener">这篇文章</a>中，我将更多地讨论 lambda 函数的“应用”方法。在本例中，它看起来像这样:</p><pre class="kq kr ks kt gt lk le ll lm aw ln bi"><span id="a88a" class="lo lp it le b gy lq lr l ls lt">%timeit df.state_bottle_retail.apply(lambda x: x.replace('$',''))</span></pre><p id="a9b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">.apply</code>方法的工作就像它应该做的那样，将运算速度加快到 117 ms. Lookin ' good。</p><p id="ba11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于下一步，我将<code class="fe lb lc ld le b">.replace</code>方法改为<code class="fe lb lc ld le b">.strip</code>方法。它少做了一次手术。它没有用空格替换“$”，而是去掉了“$ .”看起来像这样:</p><pre class="kq kr ks kt gt lk le ll lm aw ln bi"><span id="3bae" class="lo lp it le b gy lq lr l ls lt">%timeit df.state_bottle_retail.apply(lambda x: x.strip('$'))</span></pre><p id="15e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这使得整个列的速度提高到了不到 100 毫秒。越来越好！</p><p id="b5bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来是列表理解。在 Python 中，列表理解是一种非常有效的迭代大量对象的方法。所以我用同样的<code class="fe lb lc ld le b">.strip</code>方法和列表理解代替了<code class="fe lb lc ld le b">.apply</code>方法。看起来像这样:</p><pre class="kq kr ks kt gt lk le ll lm aw ln bi"><span id="48a0" class="lo lp it le b gy lq lr l ls lt">%timeit [x.strip('$') for x in df.state_bottle_retail]</span></pre><p id="2eb0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">列表理解让我们达到了 72.3 分，尼斯女士！</p><p id="b2a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我尝试了另一种方法。我没有使用函数来取出' $ '，而是使用了 Python 内置的<code class="fe lb lc ld le b">[]</code>切片。它通常用于从列表中切割和选择您需要的值，但它也可以切割字符串。所以<code class="fe lb lc ld le b">[1:]</code>从第二个值开始分割每个字符串，直到结束。因为 Python 是零索引的，这意味着它从 0 开始计数，所以数字 1 是第二个值。“:”告诉它切片，直到字符串结束。下面是使用字符串切片方法的最终列表理解:</p><pre class="kq kr ks kt gt lk le ll lm aw ln bi"><span id="aa59" class="lo lp it le b gy lq lr l ls lt">%timeit [x[1:] for x in df.state_bottle_retail]</span></pre><p id="fcb2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一时间达到了惊人的 31.4 毫秒，这不仅是最快的时间，也是这些测试中速度增长最快的一次。这种方法无疑是最快的，但是使用它有一个注意事项。如果任何值前面没有' $ '，这实际上会去掉该字符串中的第一个数字。所以在使用这种方法时你必须小心。我个人的选择是使用第四种方法，用<code class="fe lb lc ld le b">.strip</code>方法进行列表理解。尽管它不是最快的，但风险更小。根据您的数据规模和您对数据完整性的信心，您必须做出决定。</p><p id="1197" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个小注意事项:要使这些更改真正起作用，您必须将更改后的值赋回数据框中正在更改的列。看起来会像这样:</p><pre class="kq kr ks kt gt lk le ll lm aw ln bi"><span id="59be" class="lo lp it le b gy lq lr l ls lt">df.state_bottle_retail = [x.strip('$') for x in df.state_bottle_retail]</span></pre><p id="84b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">优化代码的速度是一个有趣的过程。这并不总是必要的，但习惯于以这种方式思考是一个好主意，特别是如果您想要处理大数据或向客户部署代码。玩得开心！</p><p id="0978" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">更新:'</strong> nzdatascientist '用下面的不同方法进行了评论。我在相同的数据上进行了尝试，结果非常快。到目前为止，它优于其他方法，而且如果条目没有“$”就没有删除其他值的危险。这是:</p><pre class="kq kr ks kt gt lk le ll lm aw ln bi"><span id="38e8" class="lo lp it le b gy lq lr l ls lt">np.fromstring(df.state_bottle_retail.values.astype('|S7').tobytes().replace(b'$',b''), dtype='|S6')</span></pre><p id="5023" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一时间达到了惊人的 14.3 ms，比危险的字符串切片方法快了一倍多，几乎是最慢的演示方法的 10 倍。看起来 numpy 的<code class="fe lb lc ld le b">.fromstring</code>方法是为这种类型的过程优化的。此外，转换成字节并替换它们也加快了这个过程。感谢‘nzdatascientist’！</p></div></div>    
</body>
</html>