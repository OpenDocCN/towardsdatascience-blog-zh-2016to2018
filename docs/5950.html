<html>
<head>
<title>TDD explained with an example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TDD 举例说明</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tdd-explained-with-an-example-738d702f87e?source=collection_archive---------13-----------------------#2018-11-17">https://towardsdatascience.com/tdd-explained-with-an-example-738d702f87e?source=collection_archive---------13-----------------------#2018-11-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fe35" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">建立一个 ASP.NET 维基来学习 TDD，这是一种使用小测试用例来构建更好软件的技术</h2></div><p id="7f9e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将尝试解释什么是 TDD，以及它如何在开发过程中提供帮助。有很多资源和书籍是这样做的，但我将尝试用一个简单的实际例子来介绍它。这更像是一个“哲学”概述，而不是你能在书中读到的严格定义。反正我也没想走纯理论的路子，而是更实践的方式，让你明白我们日常生活中真正需要的是什么。这种方法的纯粹主义支持者可能会发现这个解释有点不完整(抱歉…)，但我认为这足以开始学习和理解基础知识。</p><blockquote class="le"><p id="2c9f" class="lf lg it bd lh li lj lk ll lm ln ld dk translated">也许你不需要再读一本关于 TDD 的书，只要用清晰简单的文字理解它是什么就行了</p></blockquote><p id="4f15" class="pw-post-body-paragraph ki kj it kk b kl lo ju kn ko lp jx kq kr lq kt ku kv lr kx ky kz ls lb lc ld im bi translated">这对初学者来说很好，可以激发兴趣，进行深入的探索，然后终生拥抱它。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/84af0e779722ee4e17c8b644ec3c9427.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*nEKprKbGN6c1w92HdzN9fA.jpeg"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk">What is TDD? Test-driven development is a technique to build software using small test cases</figcaption></figure><h1 id="ef19" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">什么是 TDD</h1><p id="558c" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">从维基百科的定义开始:</p><blockquote class="nc nd ne"><p id="27e9" class="ki kj nf kk b kl km ju kn ko kp jx kq ng ks kt ku nh kw kx ky ni la lb lc ld im bi translated"><strong class="kk iu"> <em class="it">测试驱动开发</em></strong><em class="it">(</em><strong class="kk iu"><em class="it">TDD</em></strong><em class="it">)是一种</em> <a class="ae nj" href="https://en.wikipedia.org/wiki/Software_development_process" rel="noopener ugc nofollow" target="_blank"> <em class="it">软件开发过程，它依赖于一个非常短的开发周期的重复</em> </a> <em class="it">:需求被转化为非常具体的</em> <a class="ae nj" href="https://en.wikipedia.org/wiki/Test_case" rel="noopener ugc nofollow" target="_blank"> <em class="it">测试用例</em> </a> <em class="it">，然后软件被改进以通过新的测试，只。这与允许添加未被证明满足需求的软件的软件开发相反。</em></p></blockquote><p id="66a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">清楚了吗？TDD 的主要目的是创建一种策略，在这种策略中，测试将驱动开发过程，以便使编码更加高效、多产，减少回归。</p><p id="5cf1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">先决条件是将一个大任务分解成更小的步骤，并使用单元测试进行开发。这允许您处理一小段代码，使它们工作，然后将许多工作部分集成在一起。</p><h1 id="3dfa" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">TDD 的好处</h1><p id="2e8a" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">将 TDD 引入您的编码体验将会达到一个转折点。以下是一些最重要的优势:</p><ol class=""><li id="bdc8" class="nk nl it kk b kl km ko kp kr nm kv nn kz no ld np nq nr ns bi translated">关注真正重要的点:你会被要求分解问题，这将有助于你把注意力集中在最重要的事情上。</li><li id="a92b" class="nk nl it kk b kl nt ko nu kr nv kv nw kz nx ld np nq nr ns bi translated">处理更简单的任务:每次处理一个更小的任务可以简化故障排除，加快开发速度。你不会陷入这样的情况:你会写所有的代码，然后有些东西不工作，你不知道为什么。</li><li id="3432" class="nk nl it kk b kl nt ko nu kr nv kv nw kz nx ld np nq nr ns bi translated"><strong class="kk iu">简化集成</strong>:当多个工作特性完成时，将所有特性组合在一起将是一件愉快而轻松的任务。在回归的情况下，你会提前知道代码的哪一部分是坏的。</li><li id="6a50" class="nk nl it kk b kl nt ko nu kr nv kv nw kz nx ld np nq nr ns bi translated"><strong class="kk iu">免费测试</strong>:一旦全部任务完成，大量的单元测试仍然存在，可以作为集成\单元测试来验证代码，避免回归。</li></ol><h1 id="c197" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">TDD 不是什么</h1><p id="0c5f" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">TDD 是一种很好的方法，但不是:</p><ul class=""><li id="fff8" class="nk nl it kk b kl km ko kp kr nm kv nn kz no ld ny nq nr ns bi translated">测试的替换(单元测试、验收测试、UI 测试)</li><li id="7e0d" class="nk nl it kk b kl nt ko nu kr nv kv nw kz nx ld ny nq nr ns bi translated">一天就能学会的东西</li><li id="da4e" class="nk nl it kk b kl nt ko nu kr nv kv nw kz nx ld ny nq nr ns bi translated">为你写代码的东西</li><li id="3b3a" class="nk nl it kk b kl nt ko nu kr nv kv nw kz nx ld ny nq nr ns bi translated">一个从代码中驱除 bug 圣人</li></ul><h1 id="7a3d" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">TDD 生命周期</h1><p id="a81f" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">TDD 主要由三个步骤组成:</p><ol class=""><li id="bf0a" class="nk nl it kk b kl km ko kp kr nm kv nn kz no ld np nq nr ns bi translated">编写单元测试(红色)。</li><li id="cc47" class="nk nl it kk b kl nt ko nu kr nv kv nw kz nx ld np nq nr ns bi translated">让它工作(绿色)。</li><li id="af80" class="nk nl it kk b kl nt ko nu kr nv kv nw kz nx ld np nq nr ns bi translated">重构。</li></ol><p id="86da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在示例中，您可以编写单元测试，使用其中的代码来实现该功能，直到它工作为止，然后在需要的地方重构这段代码。</p><h2 id="381d" class="nz mg it bd mh oa ob dn ml oc od dp mp kr oe of mr kv og oh mt kz oi oj mv ok bi translated">步骤 1，2:让测试工作</h2><pre class="lu lv lw lx gt ol om on oo aw op bi"><span id="1288" class="nz mg it om b gy oq or l os ot">public class StripTest<br/>{<br/>    [Fact]<br/>    public static void StripHTml()<br/>    {<br/>        string test="&lt;h1&gt;test&lt;/h1&gt;";<br/>        string expected="test";<br/>        string result=StripHTML(test);<br/>        Assert.Equal(expected,result);<br/>    }<br/><br/>    public static string StripHTML(string input)<br/>    {<br/>        return Regex.Replace(input, "&lt;.*?&gt;", String.Empty);<br/>    }    <br/>}</span></pre><h2 id="2458" class="nz mg it bd mh oa ob dn ml oc od dp mp kr oe of mr kv og oh mt kz oi oj mv ok bi translated">步骤 3:重构</h2><pre class="lu lv lw lx gt ol om on oo aw op bi"><span id="8856" class="nz mg it om b gy oq or l os ot">public class StripTest<br/>{<br/>    [Fact]<br/>    public static void StripHTml()<br/>    {<br/>        string test="&lt;h1&gt;test&lt;/h1&gt;";<br/>        string expected="test";<br/>        string result=HtmlHelper.StripHTML(test);<br/>        Assert.Equal(expected,result);<br/>    }    <br/>}<br/><br/><em class="nf">//somewhere else</em><br/>public static class HtmlHelper<br/>{<br/>    public static string StripHTML(string input)<br/>    {<br/>        return Regex.Replace(input, "&lt;.*?&gt;", String.Empty);<br/>    }<br/>}</span></pre><h1 id="121d" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">限制</h1><p id="426a" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">在许多情况下，很难编写涵盖真实代码使用的单元测试。对于完全符合逻辑的过程来说，这很容易，但是当我们要涉及数据库或 UI 时，编写工作将会增加，并且在许多情况下，可能会超过好处。有一些最佳实践和框架对此有所帮助，但一般来说，并不是应用程序的所有部分都容易使用简单的单元测试来测试。</p><h1 id="4d38" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">什么是 BDD？</h1><p id="3013" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">BDD 是 TDD 的增强，它考虑了单元测试受限的情况。这个扩展将开发者作为一个单元测试，保持 BDD 背后的哲学。您仍然可以将复杂的任务分解成更小的任务，使用用户行为进行测试，并在纯后端任务上利用 TDD 的优势。</p><h1 id="643a" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">TDD 先决条件</h1><p id="59bf" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">在团队中工作时，除了掌握所有相关技术的知识之外，所有的队友都必须了解并接受这一理念。</p><p id="cb21" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，您的代码必须得到强大的单元测试系统的支持:</p><ul class=""><li id="1ede" class="nk nl it kk b kl km ko kp kr nm kv nn kz no ld ny nq nr ns bi translated">。网，。NET Core:内置 Visual Studio 或者 Xunit(第二个是我个人，首选)</li><li id="92a1" class="nk nl it kk b kl nt ko nu kr nv kv nw kz nx ld ny nq nr ns bi translated">Java: JUnit 工作得非常好，我不需要寻找另一种解决方案</li><li id="696b" class="nk nl it kk b kl nt ko nu kr nv kv nw kz nx ld ny nq nr ns bi translated">PHP: PHP 单元在所有情况下都为我工作</li></ul><p id="a1bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，重要且强制的是:拥有一个允许在测试期间模仿或重现正确行为的架构。我说的是一个 ORM，它可以在测试期间在内存或本地数据库上工作，但也可以使用服务或存储库模式。使用阿迪框架(内置。NET core，Autofac 或其他什么…)也有帮助。</p><p id="1fec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后但同样重要的是:一个做得好的构建过程，集成到一个持续的集成流程中，除了正确的配置之外，还要定义在集成期间在其上运行哪些单元测试是有意义的，以及哪些单元测试只是在本地运行。</p><h1 id="75b6" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">这个例子</h1><p id="204d" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">让我们试着在一个真实的例子中把我们学到的关于 TDD 的东西付诸实践。我想用这种方法创建一个维基。我指的是一个简单的 wiki，用户可以在这里登录、编写减价页面并发布。听起来很复杂？</p><blockquote class="nc nd ne"><p id="d159" class="ki kj nf kk b kl km ju kn ko kp jx kq ng ks kt ku nh kw kx ky ni la lb lc ld im bi translated">那非常容易。多亏了 TDD 和管理小任务，我很快完成了所有的微特征，最后我把已经工作的部分组装起来。</p></blockquote><p id="904a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我会将“长期”任务分解成更小的后续活动。每个子部分将使用小单元测试来开发。我会把重点放在维基页面上。</p><h1 id="9414" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">步骤 1:实体到 DTO 的映射</h1><p id="48e8" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">从这里开始听起来不太好。实体到 DTO 的映射是一件非常原始的事情，很难抑制我们想要从最酷的部分开始的编码本能。无论如何，这是第一个，自动一致的功能。映射两个类只需要这两个类的定义，仅此而已。无论数据库连接，网络错误等等。我们只需要创建两个类(d to 和实体)，然后进行映射。最后，测试将是一段代码，它将检查实体中的字段是否被复制到 d to。轻松点。</p><p id="5ce7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们总结一下步骤:</p><ol class=""><li id="fd54" class="nk nl it kk b kl km ko kp kr nm kv nn kz no ld np nq nr ns bi translated">写实体。</li><li id="97ca" class="nk nl it kk b kl nt ko nu kr nv kv nw kz nx ld np nq nr ns bi translated">写维基页面 DTO。</li><li id="195a" class="nk nl it kk b kl nt ko nu kr nv kv nw kz nx ld np nq nr ns bi translated">编写将实体映射到 DTO 的代码。</li></ol><pre class="lu lv lw lx gt ol om on oo aw op bi"><span id="ce6f" class="nz mg it om b gy oq or l os ot"><em class="nf">// Database entity</em><br/> public class WikiPageEntity<br/>{<br/>    [DatabaseGenerated(DatabaseGeneratedOption.Identity)]<br/>    public Guid Id { get; set; }<br/>    <br/>    public int Version { get; set; }<br/>    public string Slug { get; set; }<br/><br/>    public string Body { get; set; }<br/>    public string Title { get; set; }<br/>}<br/><br/><em class="nf">// DTO model in BLL</em><br/>namespace WikiCore.Lib.DTO<br/>{<br/>    public  class WikiPageDTO<br/>    {<br/>        public string Title { get; set; }<br/>        public string BodyMarkDown { get; set; }<br/>        public string BodyHtml { get; set; }<br/>        public int Version { get; set; }<br/>        public string Slug { get; set; }<br/>    }<br/>}<br/><br/><em class="nf">// From unit test, code omitted for brevity</em><br/>public void EntityToDTO()<br/>{<br/>    WikiPageEntity source = new WikiPageEntity()<br/>    {<br/>        Title = "title",<br/>        Slug = "titleslug",<br/>        Version =1<br/>    };<br/><br/>    var result = Mapper.Map&lt;wikipagedto&gt;(source);<br/>    Assert.Equal("title", result.Title);<br/>    Assert.Equal(1, result.Version);<br/>}<br/><br/><em class="nf">// From Mapping configuration, code omitted for brevity</em><br/> public MappingProfile()<br/>{<br/>    CreateMap&lt;wikipageentity, wikipagedto=""&gt;().ReverseMap();<br/>}</span></pre><h1 id="bb10" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">步骤 2:降价到 HTML 转换</h1><p id="be6a" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">第二步是制作一个将<code class="fe ou ov ow om b">markdown</code>转换成 HTML 的方法。这将是一个非常简单的方法，它将接受一个 markdown 字符串，并检查它的转换是否与预期的 HTML 匹配。</p><pre class="lu lv lw lx gt ol om on oo aw op bi"><span id="ee78" class="nz mg it om b gy oq or l os ot"><em class="nf">//Before refactoring public class MarkdownTest</em><br/>{<br/>[Fact]<br/>public void ConvertMarkDown()<br/>{<br/>    var options = new MarkdownOptions<br/>    {<br/>        AutoHyperlink = true,<br/>        AutoNewLines = true,<br/>        LinkEmails = true,<br/>        QuoteSingleLine = true,<br/>        StrictBoldItalic = true<br/>    };<br/><br/>    Markdown mark = new Markdown(options);<br/>    var testo = mark.Transform("#testo");<br/>    Assert.Equal("&lt;h1&gt;testo&lt;/h1&gt;", testo);<br/>}<br/><em class="nf">// after refactoring ( method moved to helper )</em><br/>[Fact]<br/>public void ConvertMarkDownHelper()<br/>{<br/>    Assert.Equal("&lt;h1&gt;testo&lt;/h1&gt;", MarkdownHelper.ConvertToHtml("#testo"));<br/>}<br/><br/><em class="nf">// From markdown helper</em><br/>public static class MarkdownHelper<br/>{<br/>    static MarkdownOptions options;<br/>    static Markdown converter;<br/>    static MarkdownHelper()<br/>    {<br/>        options = new MarkdownOptions<br/>        {<br/>            AutoHyperlink = true,<br/>            AutoNewLines = true,<br/>            LinkEmails = true,<br/>            QuoteSingleLine = true,<br/>            StrictBoldItalic = true<br/>        };<br/><br/>        converter = new Markdown(options);<br/>    }<br/><br/>    public static string ConvertToHtml(string input)<br/>    {<br/>        Markdown mark = new Markdown(options);<br/>        return mark.Transform(input);<br/>    }<br/>}</span></pre><h1 id="677f" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">步骤 3:用降价增强映射</h1><p id="bf4e" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">干得好！我们有从 markdown 生成 HTML 的方法和将实体翻译成 DTP 的映射器。下一步？把所有的放在一起！</p><p id="c28a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一段代码包含 HTML 字段计算的映射:</p><pre class="lu lv lw lx gt ol om on oo aw op bi"><span id="5b14" class="nz mg it om b gy oq or l os ot"><em class="nf">// mapped profile changed</em><br/>public class MappingProfile : Profile<br/>{<br/>  <br/><br/>    public MappingProfile()<br/>    {<br/>        SlugHelper helper = new SlugHelper();<br/>        CreateMap&lt;wikipageentity, wikipagedto=""&gt;()<br/>            .ForMember(dest =&gt; dest.BodyMarkDown, (expr) =&gt; expr.MapFrom&lt;string&gt;(x =&gt; x.Body))<br/>            .ForMember(dest =&gt; dest.BodyHtml, <br/>            (expr) =&gt; expr.MapFrom&lt;string&gt;(x =&gt; MarkdownHelper.ConvertToHtml(x.Body)))<br/>            .ReverseMap();<br/><br/><br/><br/>        CreateMap&lt;wikipagebo,wikipageentity&gt;()<br/>            .ForMember(dest =&gt; dest.Body, (expr) =&gt; expr.MapFrom&lt;string&gt;(x =&gt; x.BodyMarkDown))<br/>            .ForMember(dest =&gt; dest.Slug, <br/>                      (expr) =&gt; expr.MapFrom&lt;string&gt;(x =&gt; helper.GenerateSlug(x.Title)));<br/>    }<br/>}<br/><br/><em class="nf">// From unit test, code omitted for brevity</em><br/>public void EntityToDTO()<br/>{<br/>    WikiPageEntity source = new WikiPageEntity()<br/>    {<br/>        Body = "# prova h1",<br/>        Title = "title",<br/>        Slug = "titleslug",<br/>        Version =1<br/>    };<br/><br/>    var result = Mapper.Map&lt;wikipagedto&gt;(source);<br/>    Assert.Equal("title", result.Title);<br/>    Assert.Equal(1, result.Version);<br/>    Assert.Equal("&lt;h1&gt;prova h1&lt;/h1&gt;", result.BodyHtml);<br/>}</span></pre><h1 id="1b28" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">步骤 4:设置数据库迁移</h1><p id="35ae" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">另一步是整合数据库。要记住的一件重要的事情是，我们只需要测试一件事情…而数据库访问是一件复杂的事情。对数据库的第一个要求是结构。所以，检查的第一步是确保这个思想实体框架的迁移。</p><p id="39fa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要执行的步骤:</p><ol class=""><li id="60ac" class="nk nl it kk b kl km ko kp kr nm kv nn kz no ld np nq nr ns bi translated">运行<code class="fe ou ov ow om b">Add-Migration</code>脚本。</li><li id="8e38" class="nk nl it kk b kl nt ko nu kr nv kv nw kz nx ld np nq nr ns bi translated">创建一个在内存中工作的单元测试来测试它。</li></ol><pre class="lu lv lw lx gt ol om on oo aw op bi"><span id="7f6c" class="nz mg it om b gy oq or l os ot">[Fact]<br/>public void MigrateInMemory()<br/>{<br/>    <br/>    var optionsBuilder = new DbContextOptionsBuilder&lt;DatabaseContext&gt;();<br/>    optionsBuilder.UseInMemoryDatabase();<br/><br/>    using (var db = new DatabaseContext(optionsBuilder.Options))<br/>    {<br/>        db.Database.Migrate();<br/>    }<br/>    <em class="nf">// No error assert migration was OK</em><br/>}</span></pre><h1 id="e2dd" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">步骤 5:实体积垢</h1><p id="6732" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">在我们设置好迁移之后，我们可以假设数据结构一切正常。让我们从证明 CRUD 特性的单元测试开始。</p><p id="bb82" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">步骤:</p><ol class=""><li id="52db" class="nk nl it kk b kl km ko kp kr nm kv nn kz no ld np nq nr ns bi translated">编写一个 CRUD 测试。</li><li id="659a" class="nk nl it kk b kl nt ko nu kr nv kv nw kz nx ld np nq nr ns bi translated">测试一下。</li></ol><pre class="lu lv lw lx gt ol om on oo aw op bi"><span id="616d" class="nz mg it om b gy oq or l os ot">[Fact]<br/>public void CrudInMemory()<br/>{<br/>    var optionsBuilder = new DbContextOptionsBuilder&lt;DatabaseContext&gt;();<br/>    optionsBuilder.UseInMemoryDatabase();<br/><br/>    using (var db = new DatabaseContext(optionsBuilder.Options))<br/>    {<br/>        db.Database.Migrate(); <br/><br/>        db.WikiPages.Add(new Lib.DAL.Model.WikiPageEntity()<br/>        {<br/>            Title = "title",<br/>            Body = "#h1",<br/>            Slug = "slug"<br/><br/>        });<br/><br/>        db.SaveChanges();<br/><br/>        var count=db.WikiPages.Where(x =&gt; x.Slug == "slug").Count();<br/><br/>        Assert.Equal(1, count);<br/>        <em class="nf">// update, delete steps omitted for brevity</em><br/>    }<br/>}</span></pre><h1 id="7f0d" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">步骤 6:测试服务</h1><p id="5c73" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">在我们的架构中，服务层将提供业务逻辑的抽象。在这个简单的例子中，我们的服务将包装插入或更新特性，在保存后返回一个 DTO。</p><p id="d1b0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个单元测试的步骤:</p><ol class=""><li id="bb83" class="nk nl it kk b kl km ko kp kr nm kv nn kz no ld np nq nr ns bi translated">用业务逻辑创建服务。</li><li id="9e30" class="nk nl it kk b kl nt ko nu kr nv kv nw kz nx ld np nq nr ns bi translated">测试一下</li></ol><pre class="lu lv lw lx gt ol om on oo aw op bi"><span id="cb14" class="nz mg it om b gy oq or l os ot">[Fact]<br/>public void TestSave()<br/>{<br/>    var optionsBuilder = new DbContextOptionsBuilder&lt;DatabaseContext&gt;();<br/>    optionsBuilder.UseInMemoryDatabase();<br/><br/>    using (var db = new DatabaseContext(optionsBuilder.Options))<br/>    {<br/>        db.Database.Migrate();<br/>        db.SaveChanges();<br/>        <br/>        <em class="nf">//this recreate same behaviour of asp.net MVC usage</em><br/>        DatabaseWikiPageService service = new DatabaseWikiPageService(db, Mapper.Instance);<br/>        service.Save(new Lib.BLL.BO.WikiPageBO()<br/>        {<br/>            BodyMarkDown="#h1",<br/>            Title="prova prova"<br/>        });<br/><br/>        var item = service.GetPage("prova-prova");<br/>        Assert.NotNull(item);<br/>    }<br/>}</span></pre><h1 id="583e" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">步骤 7:在用户界面上继续</h1><p id="5ebb" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">一旦使用单元测试测试 UI 变得复杂，我就从纯粹的 TDD 方法切换到一个更有弹性的测试版本，并参与到这个过程中。这有助于将所有工作分成多个步骤来完成 UI。因此，我没有编写所有代码然后测试它，而是将问题分解成多个子活动，然后逐一测试:</p><p id="a60e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">编辑</strong></p><ol class=""><li id="b064" class="nk nl it kk b kl km ko kp kr nm kv nn kz no ld np nq nr ns bi translated">准备表单，并测试它。</li><li id="fb55" class="nk nl it kk b kl nt ko nu kr nv kv nw kz nx ld np nq nr ns bi translated">准备模型，测试从表单提交的内容填充后端模型。</li><li id="c3a9" class="nk nl it kk b kl nt ko nu kr nv kv nw kz nx ld np nq nr ns bi translated">集成服务以保存数据，测试数据。</li></ol><p id="47d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">视图</strong></p><ol class=""><li id="bd55" class="nk nl it kk b kl km ko kp kr nm kv nn kz no ld np nq nr ns bi translated">准备模型，传递给视图，测试它。</li><li id="c9ba" class="nk nl it kk b kl nt ko nu kr nv kv nw kz nx ld np nq nr ns bi translated">将模型与服务集成，以获得真实数据。测试一下。</li></ol><p id="f6a0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">列表</strong></p><ol class=""><li id="160a" class="nk nl it kk b kl km ko kp kr nm kv nn kz no ld np nq nr ns bi translated">准备视图模型，传递假数据到 UI，测试它。</li><li id="9b34" class="nk nl it kk b kl nt ko nu kr nv kv nw kz nx ld np nq nr ns bi translated">集成服务，测试它。</li></ol><p id="f4ca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个微特征都可以快速实现并易于测试。这将促进完整的实现。</p><h1 id="a607" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">结论</h1><blockquote class="nc nd ne"><p id="c137" class="ki kj nf kk b kl km ju kn ko kp jx kq ng ks kt ku nh kw kx ky ni la lb lc ld im bi translated">TDD 是一种驱动测试支持的开发过程的方法。</p></blockquote><p id="43c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这有助于在许多方面编码，但要求所有的队友都有一些基础知识。一旦完成了这一步，您将处理一个更简单的任务和许多可以重用的测试。</p><blockquote class="nc nd ne"><p id="fefa" class="ki kj nf kk b kl km ju kn ko kp jx kq ng ks kt ku nh kw kx ky ni la lb lc ld im bi translated">这个过程将有助于避免回归，并更快地达到目标，如果在开发的同时努力编写单元测试也是如此。</p></blockquote><p id="e5b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，如果您的应用程序由于复杂性而难以测试，您可以保持同样的理念执行一些手动步骤。</p></div><div class="ab cl ox oy hx oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="im in io ip iq"><p id="601c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">觉得这篇文章有用？在 Medium 上关注我(<a class="ae nj" href="https://medium.com/@daniele.fontani" rel="noopener">丹尼尔·丰塔尼</a>)，看看我下面最受欢迎的文章！请👏这篇文章分享一下吧！</p><ul class=""><li id="5dae" class="nk nl it kk b kl km ko kp kr nm kv nn kz no ld ny nq nr ns bi translated"><a class="ae nj" href="https://medium.com/swlh/what-is-docker-28bd2b618eee" rel="noopener">Docker 到底是什么？</a></li><li id="b52e" class="nk nl it kk b kl nt ko nu kr nv kv nw kz nx ld ny nq nr ns bi translated">【Kubernetes 到底是什么？</li><li id="168d" class="nk nl it kk b kl nt ko nu kr nv kv nw kz nx ld ny nq nr ns bi translated"><a class="ae nj" href="https://medium.com/swlh/how-to-deploy-an-asp-net-application-with-kubernetes-3c00c5fa1c6e" rel="noopener">如何使用 Kubernetes 部署 web 应用程序</a></li></ul><h1 id="2a2b" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">资源</h1><ul class=""><li id="097c" class="nk nl it kk b kl mx ko my kr pe kv pf kz pg ld ny nq nr ns bi translated">完整的 git 源代码<a class="ae nj" href="https://github.com/zeppaman/wiki.asp.net.core" rel="noopener ugc nofollow" target="_blank">https://github.com/zeppaman/wiki.asp.net.core</a></li><li id="e81f" class="nk nl it kk b kl nt ko nu kr nv kv nw kz nx ld ny nq nr ns bi translated">原文发表于 2018 年 11 月 17 日<a class="ae nj" href="https://www.codeproject.com/Articles/1267361/Build-an-ASP-NET-Wiki-to-Explain-TDD" rel="noopener ugc nofollow" target="_blank">www.codeproject.com</a>。</li><li id="aa71" class="nk nl it kk b kl nt ko nu kr nv kv nw kz nx ld ny nq nr ns bi translated">关于 TDD<a class="ae nj" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Test-driven_development</a>维基百科告诉了什么</li></ul></div></div>    
</body>
</html>