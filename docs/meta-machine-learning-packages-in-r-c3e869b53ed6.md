# R 中的“元”机器学习包

> 原文：<https://towardsdatascience.com/meta-machine-learning-packages-in-r-c3e869b53ed6?source=collection_archive---------4----------------------->

> 本帖发表于 2018 年年中左右。
> 
> 还可以查看 2019 年底关于[第二代元包](https://medium.com/analytics-vidhya/meta-machine-learning-aggregator-packages-in-r-round-ii-71ee1ff68642)的后续帖子。

你还记得在统计学课上学过线性回归吗？恭喜你！你现在是一个由统计学家、数学家、数据科学家、计算机科学家、工程师和许多(许多)使用“机器学习”方法的人组成的多样化社区的幸运成员！管它呢，你甚至可以告诉你的朋友，你正在做一些花哨的“人工智能”。

线性回归只是众多监督模型中的一种。还有数百种其他模型，包括:非线性模型、多项式模型、基于树的模型(如 CART、XGBoost)、SVM、神经网络等。这些监督模型既可以处理连续结果(回归)，也可以处理二元和多类结果(分类)。

如果我告诉你，不是看多个包，每个包只关注一个单一的方法/模型，而是有一个单一的包，这里称为“元包”，它将使你能够更容易地访问所有这些依赖的模型。这个元包还可以促进多个模型的并行部署，然后聚合结果。每个模型的各种参数仍然可以仔细控制，但是“元包”在更高的分析层促进了元分析方法，将单个模型的结果包装和捆绑在一起。

事实上，集中在元级别，单个模型可以通过简单地列出被考虑的特定模型的名称来应用，并带有一组它们的缺省参数，如果需要的话可以进行调整。这使得可能不完全熟悉模型细节的用户可以将它作为某种“黑盒”来使用。

在这篇文章中，我将对整个机器学习框架使用汽车力学的类比，对任何多元模型使用汽车引擎的类比。早期性能基本的车，以前都是发动机简单。随着技术的进步，今天的汽车速度更快，也更可靠。简单的传动系统被自动齿轮取代。现代汽车是一个由先进部件组成的复杂系统，每个部件都经过精心设计，并很好地集成到一个更广泛的系统中，很好地同步，最终使汽车能够平稳运行。

不同的编程语言对此方法有不同的实现。这篇文章关注的是我自己探索这个主题的旅程，特别是在 r。

![](img/5f543e00d259d983e9eeb414e1136652.png)

pixabay

*旧剧本:*

过去，我学到的第一个统计模型是线性回归。这可能是引入预测模型的最基本方法。然而，还有许多其他具有相同范围的模型，包括监督的(分类、回归)和非监督的(聚类)，它们曾经(现在仍然)像雨后春笋般涌现。此外，由于该领域本身非常多样化，很难审查数百篇科学论文；每一种都有自己独特的框架和数学符号。然后，大约在 2002 年，我得到了一本很棒的书的参考资料，《统计学习的要素》，作者是这个新兴领域的创始人。这本书的 764 页涵盖了人们需要知道的一切，从线性回归模型到神经网络。它还涵盖了过度拟合、交叉验证和集成的主题。方法用详细一致的数学符号描述，并由说明性的彩色可视化支持。

唉，这本书可能不适合所有人，特别是那些缺乏数学背景的人，包括我自己。看完之后，我真希望能有一本类似的更实用的书。理想情况下，它应该涵盖完全相同的主题，但可能有简化的数学概念，更多的应用示例，以及一些针对真实数据集的实际代码演示。我最大的梦想是代码在 r 中。

我的梦想在 2013 年左右实现了，当时上述书籍原作者的学生和一些原作者写了另一本书，《[《统计学习导论》》](https://www-bcf.usc.edu/~gareth/ISL/)，目的完全相同。他们甚至能够将其压缩到(仅仅)441 页。

![](img/a0c55c4e7ac008e763f63e66793ac949.png)

pixabay

*森林中的第一步*

即使在 R 的早期，也有不止一个包可以做几乎任何事情。然而，我感到无所畏惧。在第二本书的指引下，我感到安全可靠，我确切地知道每个模型应该使用哪个推荐的 R 包。我很高兴了解 GLM、卡特和其他人的特定包。

我对应用单个模型了解得越多，我就越好奇(也越贪婪)去了解更多的新模型，尽管它们通常很容易理解并在我的数据集上实现。我学习和实现更多模型的动机部分是为了实现我的模型和数据集的更高性能(就模型预测的准确性而言)。然而，这场竞争并不是唯一的原因。在 Wolpert 和 Macready 提出的“没有免费的午餐”定理的指导下，我有一个合理的科学理由继续尝试尽可能多的模型，该定理认为没有一个单一的模型总是对任何类型的数据集都具有最佳性能。

![](img/9c37bc8a78fadc17f40bd5583165b6ca.png)

pixabay

*太早兴奋？*

对于有大量文档和示例的基本模型，学习如何应用它们几乎是简单明了的。然而，仍然有许多其他复杂的模型不那么容易应用。对我来说，它们的复杂性通常是由于额外的可调参数，这些参数要么缺乏关于如何使用的具体明确的指南，要么可能是这样做的技术超出了我的理解。例如，为一个[惩罚回归](https://web.stanford.edu/~hastie/glmnet/glmnet_alpha.html)、LASSO、通过内部交叉验证技术或其他参数调整方法选择 alpha 和 beta 参数。

在我不断寻找新模型的同时，我经历的另一个挑战是实现处理过度拟合问题的方法，比如交叉验证和引导。尽管有专门处理这些方法的包，但是集成它们并把它们包装在不同的模型/包中并不容易。调谐参数的高级搜索方法和系综(特别是叠加)也是如此。

尽管我认为我已经有了如何在各种模型和包中导航的导航图，但很快还是出现了一些失望。将所有这些方法整合在一起太难了。这些模型中的每一个都很难理解，将多个模型包装在一起，相互嵌套，并与其他“繁重”的方法(如重采样、基准测试、堆叠等)联系在一起，使其变得更加复杂和难以应付。

虽然感到沮丧和疲惫，但我仍然希望有一些有效的方法将它们集成在一起，因为最终，所有这些方法都共享相同的“统计学习”工作流:根据训练集训练/拟合模型，用新的数据集(测试)预测结果，以及测量一些性能指标。事实上，这些包中的每一个都有自己的“方言”，反映了开源 R 开发者社区的不同背景。然而，在上述预测模型的框架下，应该有一种方法来统一和重新格式化每个模型/包的输入和输出，以便它们都可以在同一个罩下，然后聚合在一起。

![](img/a2efbbd6abd643232b7344392aa5db13.png)

Photo by [Neil Thomas](https://unsplash.com/@finleydesign?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

*第(首？)缺少链接:脱字符包*

尽管有这些挑战，我仍然感到有决心！我不会让一些数学符号或文档较少的包吓走我，我也没有失去希望。

大约在前一本书的同时，另一本书也出版了，[【应用预测建模】](http://appliedpredictivemodeling.com/)，这本书大多只用了一个单独的软件包， [*【脱字符号*](http://topepo.github.io/caret/index.html) 。这个包试图填补上面的空白，提供我一直在拼命寻找的元方法。它统一了来自许多(目前有 237 个)监督模型(分类和回归)的访问(输入)和返回输出。没有必要从头重新编写这些模型。相反，插入符号包将单个包作为依赖项来调用。

一旦多个模型被统一和集成，开发人员继续在更高的元级别上集成其他高级方法:1。基准测试(包括作为私人案例的调优)；2.重采样(交叉验证)；第三。整体(装袋、增压和堆叠)。

那时我更加兴奋了！尽管我可能还没有完全理解和欣赏 caret 包的全面功能(也许甚至今天也没有)，但我比以往任何时候都更愿意开始使用这个非常高效、运行良好的“机器”。

*必须有多个元包才能做到！mlr 和 SuperLearner 软件包:*

怀着相似的目标，开发了另外两个元包(我不知道确切的历史和时间。这篇文章仅仅代表了我自己，自我选择性偏见，学习这些软件包的方式)。这些元包各有不同的侧重点。除了监督模型之外， [*mlr*](https://mlr-org.github.io/mlr/index.html) 包还实现了用于非监督(聚类)分析的其他模型组(称为“学习者”)以及事件时间(生存)模型。它还列出了大量性能度量标准，以及非常详细的通用分析工作流文档。[super leaner](https://cran.r-project.org/web/packages/SuperLearner/index.html)封装强调整体(堆叠)部分和通过多核优化的可扩展性。

![](img/92e5b303e685321fe853b3386c61a2a9.png)

pixabay

*特征工程:可组合预处理步骤/操作/管道的特定扩展:*

预测模型性能成功的关键步骤是“特征工程”。这是在将多变量模型应用于数据之前的早期预处理步骤中完成的。它可能包括数据集的转换、缺失值的插补以及特征或样本/观察值的过滤(早期筛选)。它还可以包括这些运算符的任意组合，以任意顺序排列。一旦编译在一起，它就被集成回学习者/模型。

此步骤的推荐实现是将在训练数据集上完成的任何转换也应用到测试/验证数据集。然而，在交叉验证中嵌套这些步骤并不简单。这不像编写一个包含所有预处理步骤的长函数那么简单。相反，它需要一个更一般化的功能框架，该框架将允许对数据的不同步骤/操作组合在一起，可以以任何顺序的方式集成，并且还允许将转换的特定参数适当地传递到测试/验证部分。这个可组合函数的另一个(明显的)用途是直接应用于实际的原始数据集本身，在嵌套重采样之外，以试错的方式简单地检查数据。

上述元包最近用新的补充包进行了扩展，以便于这种可组合的预处理操作。 [recipes](https://cran.r-project.org/web/packages/recipes/index.html) 包提供了多个共同的“步骤”,这些步骤通过管道连接在一起，可以在嵌套重采样之外“烘焙”成原始数据。同样的， [*mlrCPO*](https://github.com/mlr-org/mlrCPO) 扩展 *mlr* 包 [*sl3*](https://sl3.tlverse.org/) 扩展*super loader*。最近，*脱字符/选择*软件包的作者写了一本新书《特征工程和选择:预测模型的实用方法》来讨论这种转换。

*这三个元包选哪个？无可争议的*

品味是无法解释的。列出每个元包的优点或缺点是不公平的，主要是因为每个元包都在不断更新，并使用最新的新工具进行扩展。尽管如此，这场卓有成效的竞赛也有来自其他编程语言的选手(这里就不一一列举了)，他们都瞄准了同一个最终目标。

真正重要的是用户学习每个元包的能力，以及用他们自己的数据集成功实现这些解决方案。这取决于所需的特定解决方案的可用性，以及实施所需的文档和支持的级别。这些元包中的每一个都有不同风格的文档/支持(例如 github issues、stackoverflow 等)，或者受其开发者背景(行业、学术界等)的影响，或者只是个人风格。可伸缩性也可能是一个应该关注的关键瓶颈。每个元包都以不同的方式处理它。mlr 提供了自己的云环境 [OpenML](https://www.openml.org/) ，用于部署大型管道。*super leaker*有一个并行化的框架扩展，叫做[](https://delayed.tlverse.org/)*。*

*如果你很有动力(像我一样)，我会鼓励你尝试这三个包中的每一个。理论上，你应该得到同样的结果。*

*![](img/4a484b00a6d3fcf489310da78db6c13f.png)*

*pixabay*

**元元包(这不是错别字)。**

*还不确定选哪个元包？当你可以尝试所有的时候，为什么只妥协于一个元包呢？考虑尝试下一个更高层次的“元”分析:元(多个)“元包”。等等，什么？！？我知道，这个想法乍一看可能很吓人，但是请原谅我。这三个元包中的每一个都为单个模型提供了高级元解决方案。为什么不尝试围绕这三个元包做完全相同的事情呢？我们已经知道需要做什么。它们在单个包中做的是完全相同的事情，但这次是在下一个更高的级别:统一、聚合、比较、堆栈。*

*事实上，已经有跨元包的功能可以将具有相同目的的对象从一个包渲染到另一个包。例如，mlr 包有一个将*插入符号*的预处理对象转换成 *mlr* 的函数。虽然目前只对一个组件进行了这种操作，而且只在一个方向上进行，但我猜想不久将会有更多的跨包对象转换函数可用，对于跨“recipes”、“mlrCPO”和“sl3”的所有可能组合和方向的可组合预处理操作符也是如此。也许这种元-元方法甚至可以扩展到 R 之外，还可以跨不同的编程语言。*

*![](img/10d5a2cd9312bcf99a6a8dc9ab899d6c.png)*

*pixabay*

**《两种文化》(oy vey):**

*到目前为止，我小心翼翼地不想卷入关于[【两种文化】](https://projecteuclid.org/download/pdf_1/euclid.ss/1009213726)的无休止的讨论中，尽管猜测我的血统并不困难。我对这个有争议的话题的理解，用我的车来比喻，不仅是关于一个人制造的汽车/发动机，还关于你用它来驾驶的风格。你是一个谨慎的司机吗？为了安全到达目的地，你会仔细评估你周围的环境吗？或者你愿意超速，错过-遵守一些交通法规，只是为了你可以第一个到达？也许你两者都有一点，要看情况而定。我对此的看法是，至少有一个统一的方法来访问和评估不同的汽车/发动机，允许我们以更好的系统方式回答这些问题。*

*![](img/bcbc03bd409b990c342e968053428db8.png)*

*pixabay*

**如何设计一个好的复杂系统？有凝聚力的设计:**

*集成多个模型、比较它们并在重采样中嵌套它们的想法绝对不是新的。然而，将所有这些放在一起是上述每个元包试图实现的目标。如果您曾经试图自己编写交叉验证技术，您可能很快就会面临一些编程设计差距问题(边缘情况或其他错误)和其他计算瓶颈，如可伸缩性。*

*将输入和输出名称/格式统一成一个单一的公共名称/格式只是一个技术性的语义呈现任务。然而，一旦统一，设计一个有凝聚力的系统，将所有不同的组件很好地结合在一起，编织在一起，以拥有一个强大的良好运转的机器，同时也允许各个组件的独立开发，这一点都不简单。*

*![](img/1c23b50960f2f6d72f61bec308d29fb0.png)*

*pixabay*

**(今天)谁都会开车，但是你知道车坏了怎么修吗？！？**

*偶尔我会回到上面描述的“旧脚本”,寻找特定模型的一些细节。我为能接触到这些资源而感到幸运，这些资源引导我走过了统计学学习的艰难历程。虽然我仍然不确定我是否也应该感到荣幸，在这条道路出现时跟随它，而不是在未来的某个地方开始，立即获得这些现代工具。毕竟，这些“旧剧本”，实际上并没有那么老。它们是最近才写的。假设我对这个领域一无所知，并且读了这篇评论，一夜之间成为这些元包的专家，我还会拥有我通过漫长而曲折的道路慢慢获得的技能吗？*

*我们生活在一个激动人心的时代，这样强大的工具唾手可得，开源发行版让所有人都可以免费使用。这些类型的元包允许我们访问一个全面的工具，该工具允许模型、性能测量、预处理步骤和可调参数值等的多种组合的集成。所有这些组合都可以很好地打包成一长串参数组，并在一次基准测试函数运行中进行评估。*

*使用这些元包，它不再是一个难以完成的任务。复杂的组件可以很容易地分解，拆卸成更简单的子组件，仔细测试他们的行为和对整体性能的影响。它还使初学者能够跳过对这些子组件的方法理解，并把每个子组件作为一组相互关联的黑盒来处理。*

*回到汽车驾驶的类比。驾驶汽车不需要了解汽车复杂的机械结构。然而，如果司机有兴趣提高汽车的性能，他应该更好地了解引擎盖下发生了什么，或者有机会接触到好的机械师。*

*在这篇文章中，我描述了自己成为汽车“机械师”的历程。对我来说，是从几本书开始的。希望读完之后，你可能会找到一个更好的起点。在熟悉了这些工具之后，您可能很快就会想要自己修改方法中的某些东西，或者根据您自己的特定需求对其进行裁剪，或者建议对现有方法进行改进。我的朋友，那是你无法再逃避肮脏工作的时刻。现在是时候长吸一口气，学习如何扩展这些方法，并投入进去了。我可以向你保证，你会像我一样在途中学到很多有用的东西。玩得开心！*

> *还可以查看 2019 年底关于[第二代元包](https://medium.com/analytics-vidhya/meta-machine-learning-aggregator-packages-in-r-round-ii-71ee1ff68642)的后续帖子。*

*查看我的博客:【https://medium.com/@drorberel *

*点击此处查看更多相关话题:【https://drorberel.github.io/】T4*

# *顾问:目前接受新项目！*