<html>
<head>
<title>Locality Sensitive Hashing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">位置敏感散列法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-locality-sensitive-hashing-49f6d1f6134?source=collection_archive---------0-----------------------#2018-06-29">https://towardsdatascience.com/understanding-locality-sensitive-hashing-49f6d1f6134?source=collection_archive---------0-----------------------#2018-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="79cd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">减少数据维数的有效方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/27f19d1ee1f4fa8e241476a624e06d62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3AuO6iBNMJuMgFEc.jpg"/></div></div></figure><h1 id="6935" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">动机</h1><p id="c6a5" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">寻找最近邻居的任务很常见。您可以考虑像查找重复或相似文档、音频/视频搜索这样的应用程序。虽然使用暴力来检查所有可能的组合会给你精确的最近邻，但它根本不可伸缩。完成这项任务的近似算法一直是积极研究的领域。虽然这些算法不能保证给你准确的答案，但通常它们会提供一个很好的近似值。这些算法速度更快，可伸缩性更强。</p><p id="2938" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">位置敏感散列(LSH)就是这样一种算法。LSH 有许多应用，包括:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/1225c342e2dcd5894c09dbf58e3f2533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ph214h94u43vgb9A4FwHXw.png"/></div></div></figure><ul class=""><li id="cfd5" class="mo mp it lo b lp mi ls mj lv mq lz mr md ms mh mt mu mv mw bi translated">近似重复检测:LSH 通常用于对大量文档、网页和其他文件进行重复数据删除。</li><li id="562c" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">全基因组关联研究:生物学家经常使用 LSH 在基因组数据库中识别相似的基因表达。</li><li id="26cd" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">大规模图片搜索:谷歌使用 LSH 和 PageRank 来构建他们的图片搜索技术。</li><li id="187b" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">音频/视频指纹识别:在多媒体技术中，LSH 被广泛用作音频/视频数据的指纹识别技术。</li></ul><p id="2dac" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在这篇博客中，我们将试图理解这种算法的工作原理。</p><h1 id="cfd2" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">大意</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/0785f74ba0281c9e7f10d04d91355681.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*9-XHwDPzGqky2O3JdOU9IA.png"/></div></figure><p id="2f40" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"/>是指一族函数(称为 LSH 族)将数据点散列到桶中，使得彼此靠近的数据点<em class="ne">大概率位于同一个桶中</em>，而彼此远离的数据点<em class="ne">很可能在不同的桶中</em>。这使得识别具有不同相似度的观察结果变得更加容易。</p><h1 id="b332" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">查找相似的文档</h1><p id="fdcb" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">让我们试着去理解我们如何利用 LSH 来解决一个实际问题。我们试图解决的问题是:</p><blockquote class="nf"><p id="7b67" class="ng nh it bd ni nj nk nl nm nn no mh dk translated">目标:您已经收到了大量的文档。您希望找到“近似重复”的配对。</p></blockquote><p id="63f8" class="pw-post-body-paragraph lm ln it lo b lp np ju lr ls nq jx lu lv nr lx ly lz ns mb mc md nt mf mg mh im bi translated">在这个问题的背景下，我们可以将 LSH 算法分解为 3 个主要步骤:</p><ol class=""><li id="f975" class="mo mp it lo b lp mi ls mj lv mq lz mr md ms mh nu mu mv mw bi translated"><strong class="lo iu">皱缩</strong></li><li id="9744" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh nu mu mv mw bi translated"><strong class="lo iu">最小哈希</strong></li><li id="b5f5" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh nu mu mv mw bi translated"><strong class="lo iu">区分位置的散列法</strong></li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/d958745426b62d8579e21e9acb6a727a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*27nQOTC79yfh5lzmL06Ieg.png"/></div></div></figure><p id="1d49" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">暂时不要过多地解读这个数字。它只是给你一个流程的概念。我们将详细讨论每个步骤。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h1 id="89c3" class="ku kv it bd kw kx od kz la lb oe ld le jz of ka lg kc og kd li kf oh kg lk ll bi translated">叠瓦作用</h1><p id="2494" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在这一步中，我们将每个文档转换成一个长度为 k 的<em class="ne">字符集(也称为 k-瓦片区或 k-grams)。</em>关键思想是将我们集合中的每个文档表示为一组 k 瓦片区。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/f1c1ab00ba71c92d44902815b2a6f891.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*SYzH6iJ3Y-5kGbA4psnTDw.png"/></div></figure><p id="f327" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">举个例子:你的一个文档(D):“纳达尔”。如果我们对 2-带状疱疹感兴趣，那么我们的集合:{Na，ad，da，al}。类似的 3-带状疱疹集:{Nad，ada，dal}。</p><ul class=""><li id="b30f" class="mo mp it lo b lp mi ls mj lv mq lz mr md ms mh mt mu mv mw bi translated">相似的文档更有可能共享更多的瓦片区</li><li id="38ad" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">在改变单词的文档中重新排序段落对带状疱疹没有太大影响</li><li id="f608" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated"><em class="ne">实际中一般采用 8–10</em>的 k 值。较小的值将导致出现在大多数文档中的许多带状疱疹(<em class="ne">不利于区分文档</em></li></ul><h1 id="d47a" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">Jaccard 索引</h1><p id="0602" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们以瓦片的形式表示每个文档。现在，我们需要一个度量来衡量文档之间的相似性。Jaccard Index 是一个很好的选择。文档 A &amp; B 之间的 Jaccard 索引可以定义为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/0abd49f8c953455c5fe61474a51845dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/0*dJEYEHaYx7NOuDM-.png"/></div></figure><p id="fc09" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">它也被称为<em class="ne">(IOU)</em>。</p><p id="f54e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">假设 A:“Nadal”和 B:“Nadia”，那么 2-带状疱疹表示将是:</p><p id="4dd9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">A: {Na，ad，da，al}和 B: {Na，ad，di，ia}。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/63def59d6f56ae3638afa7f47a06bdbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NgmaNdqXk3_hQbtGNtyRPw.png"/></div></div></figure><p id="bf9b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">雅克卡指数= 2/6</p><p id="b342" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">更多数量的公共瓦片区将导致更大的 Jaccard 索引，因此文档更可能是相似的。</p><p id="95e6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们讨论一下我们需要解决的两个大问题:</p><h1 id="0f21" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">时间复杂度</h1><p id="4bb8" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在你可能认为我们可以就此打住。但是如果考虑到可伸缩性，仅仅这样做是行不通的。对于 n 个文档的集合，需要做<em class="ne"> n*(n-1)/2 </em>比较，基本上就是<em class="ne"> O(n ) </em>。假设你有 100 万个文档，那么比较的数量将是 5*10(完全不可伸缩！).</p><h1 id="630e" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">空间复杂性</h1><p id="e414" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">文档矩阵是一个稀疏矩阵，按原样存储它将是一个很大的内存开销。解决这个问题的一种方法是散列法。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h1 id="8033" class="ku kv it bd kw kx od kz la lb oe ld le jz of ka lg kc og kd li kf oh kg lk ll bi translated">散列法</h1><p id="b49c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">散列的思想是使用散列函数<strong class="lo iu"> H <em class="ne">将每个文档转换成一个小签名。</em> </strong>假设我们语料库中的一个文档用<strong class="lo iu"> d. </strong>表示，那么:</p><ul class=""><li id="e652" class="mo mp it lo b lp mi ls mj lv mq lz mr md ms mh mt mu mv mw bi translated">H(d)是签名，它足够小，可以放在内存中</li><li id="15ed" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">如果<em class="ne">相似度(d1，d2) </em>高，则<strong class="lo iu"> <em class="ne">概率(H(d1)==H(d2)) </em> </strong>高</li><li id="fbc2" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">如果<em class="ne">相似度(d1，d2) </em>低，则<strong class="lo iu"> <em class="ne">概率(H(d1)==H(d2)) </em> </strong>低</li></ul><p id="2aa1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">哈希函数的选择与我们使用的相似性度量紧密相关。对于 Jaccard 相似性，合适的散列函数是<strong class="lo iu">最小散列</strong>。</p><h2 id="2aff" class="ol kv it bd kw om on dn la oo op dp le lv oq or lg lz os ot li md ou ov lk ow bi translated">最小散列法</h2><p id="c8cd" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这是这个算法最关键也是最神奇的地方，所以请注意:</p><p id="5aeb" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">第一步:文档瓦片矩阵<em class="ne">行索引</em>的</strong>随机排列<em class="ne"> (π) </em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/fd57af35d88b811966f89e5c54b2649b.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*_o4WE7tW0qIjefYzjlpqJA.png"/></div></figure><p id="abec" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">第二步:</strong>哈希函数是 C 列值为 1 的第一行(按排列顺序)的<em class="ne">索引。</em>这样做几次(使用不同排列)来创建列的签名。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/04866e3c02666e5f8b4c09fb389b29e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*BEXAQmgCUZN8Rp-11AX53g.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/97e20cca580eda65ef5989557092c3f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*wkjgq-9UPR2rDjQ68bI9tg.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/451a26b88622f2f041fa3890fea2e683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*JSPUfzDnwwxt7tjsxOCchw.png"/></div></div></figure><h2 id="82b5" class="ol kv it bd kw om on dn la oo op dp le lv oq or lg lz os ot li md ou ov lk ow bi translated">最小散列属性</h2><p id="e9e0" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">签名的相似性是它们一致的最小散列函数(行)的分数。所以 C1 和 C3 的签名相似度是 2/3，因为第一行和第三行是相同的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/606b14ca48ca4ee8b1af5cd9f82b10fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*WKNfxHCviPHTFavK_dQflw.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/402b02212e830537ed3ac8835c1b6649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GGOcKpOGm2QQ5OAPJ0rHqA.png"/></div></div></figure><blockquote class="nf"><p id="1bff" class="ng nh it bd ni nj pd pe pf pg ph mh dk translated">两个签名的预期相似性等于列的 Jaccard 相似性。签名越长，误差越小</p></blockquote><p id="0109" class="pw-post-body-paragraph lm ln it lo b lp np ju lr ls nq jx lu lv nr lx ly lz ns mb mc md nt mf mg mh im bi translated">在下面的例子中，你可以在某种程度上看到这一点。有所不同，因为我们只有长度为 3 的签名。但是如果增加长度，这两个相似点会更接近。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/ab9437d1edba4087011263d1bdf29b14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J6-PNkaa73y9SpHCLE-9nw.png"/></div></div></figure><p id="0883" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">因此，使用最小散列法，我们通过消除稀疏性并同时保持相似性的<em class="ne">，解决了<em class="ne">空间复杂度</em>的问题。在实际实施中，他们是一个创造指数排列的技巧，我不会覆盖，但你可以在 15:52 左右检查这个视频。<a class="ae nc" href="https://www.youtube.com/watch?v=96WOGPUgMfw" rel="noopener ugc nofollow" target="_blank"> <strong class="lo iu"> Min-hash 实现</strong> </a></em></p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h1 id="6e96" class="ku kv it bd kw kx od kz la lb oe ld le jz of ka lg kc og kd li kf oh kg lk ll bi translated">局部敏感散列法</h1><blockquote class="nf"><p id="ca1d" class="ng nh it bd ni nj nk nl nm nn no mh dk translated">目标:找到 Jaccard 相似度至少为 t 的文档</p></blockquote><p id="6851" class="pw-post-body-paragraph lm ln it lo b lp np ju lr ls nq jx lu lv nr lx ly lz ns mb mc md nt mf mg mh im bi translated">LSH 的总体思想是找到一种算法，使得如果我们输入两个文档的签名，它告诉我们这两个文档是否形成候选对，即它们的相似性大于阈值<strong class="lo iu"> t </strong>。请记住，我们将签名的相似性作为原始文档之间 Jaccard 相似性的代理。</p><p id="6709" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">专门针对最小哈希签名矩阵:</strong></p><ul class=""><li id="9b8c" class="mo mp it lo b lp mi ls mj lv mq lz mr md ms mh mt mu mv mw bi translated">使用几个散列函数散列签名矩阵<strong class="lo iu"> M </strong>的列</li><li id="b4fb" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">如果对于至少一个散列函数的<strong class="lo iu">来说，两个文档散列到同一个桶中，我们可以将这两个文档作为候选对</strong></li></ul><p id="66c7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在的问题是如何创建不同的散列函数。为此，我们进行波段划分。</p><h2 id="bd94" class="ol kv it bd kw om on dn la oo op dp le lv oq or lg lz os ot li md ou ov lk ow bi translated">波段划分</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/8528907d217639380667aa23b09c05c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*0fyOrHUWlynkNNfCQaN5NQ.png"/></div></div></figure><p id="1f8b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">算法是这样的:</p><ul class=""><li id="9e18" class="mo mp it lo b lp mi ls mj lv mq lz mr md ms mh mt mu mv mw bi translated">将签名矩阵分成<em class="ne"> b 个带</em>，每个带有<em class="ne"> r 行</em></li><li id="04d3" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">对于每个带，用 k 个桶将它在每列中的部分散列到一个散列表中</li><li id="cc80" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">候选列对是那些对于<em class="ne">至少 1 个带</em>散列到相同桶的列对</li><li id="bae3" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">调整 b 和 r 以捕捉最相似的对，但很少捕捉不相似的对</li></ul><p id="f5b3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这里的考虑很少。理想情况下，对于每个波段，我们希望 k 等于一个列在一个波段内可以采用的所有可能的值组合。这将等同于身份匹配。但是这样，k 将是一个巨大的数字，在计算上是不可行的。举个例子:如果一个乐队有 5 行。现在，如果签名中的元素是 32 位整数，那么这种情况下的 k 将是(2 )⁵ ~ 1.4615016e+48。你可以看到这里有什么问题。通常 k 取 100 万左右。</p><p id="ce46" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">其思想是，如果两个文档相似，那么它们将作为候选对出现在至少一个波段中。</p><h2 id="9915" class="ol kv it bd kw om on dn la oo op dp le lv oq or lg lz os ot li md ou ov lk ow bi translated"><strong class="ak">选择 b &amp; r </strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/b8048faeaeeb3c9faf202e5c9b2b5d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*NdAEYKfMLikerNpXjXv8FQ.png"/></div></figure><p id="c131" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果我们取 b 大，即更多数量的散列函数，那么我们减少 r，因为 b*r 是常数(签名矩阵中的行数)。直觉上，这意味着我们正在增加找到候选配对的可能性。这个案例相当于取了一个小<strong class="lo iu"> t(相似度阈值)</strong></p><p id="1dd4" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">假设你的签名矩阵有 100 行。考虑两种情况:</p><p id="64fc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">b1 = 10 → r = 10</p><p id="d939" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">b2 = 20 → r = 5</p><p id="f5c2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在第二种情况下，两个文档在同一个桶中出现至少一次的可能性更大，因为它们有<em class="ne">更多的机会(20 比 10) </em>和<em class="ne">更少的签名元素被比较(5 比 10)。</em></p><blockquote class="nf"><p id="3d63" class="ng nh it bd ni nj nk nl nm nn no mh dk translated">更高的 b 意味着更低的<strong class="ak">相似性阈值(更高的假阳性)，而更低的 b 意味着更高的相似性阈值(更高的假阴性)</strong></p></blockquote><p id="1392" class="pw-post-body-paragraph lm ln it lo b lp np ju lr ls nq jx lu lv nr lx ly lz ns mb mc md nt mf mg mh im bi translated">我们试着通过一个例子来理解这一点。</p><p id="afb2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">设置:</strong></p><ul class=""><li id="5253" class="mo mp it lo b lp mi ls mj lv mq lz mr md ms mh mt mu mv mw bi translated">100k 文档存储为长度为 100 的签名</li><li id="4dae" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">签名矩阵:100*100000</li><li id="e74e" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">签名的暴力比较将导致 100C2 比较= 50 亿(相当多！)</li><li id="909c" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">让我们取 b = 20 → r = 5</li></ul><p id="105a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">相似度阈值(t) : 80% </strong></p><p id="9e8a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们希望 20 个波段中至少有一个波段的两个文档(D1 和 D2)具有 80%的相似性，在同一个桶中进行哈希运算。</p><p id="479c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">P(D1 和 D2 在特定波段相同)= (0.8)⁵ = 0.328</p><p id="f056" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">P(D1 和 D2 在所有 20 个波段中不相似)=(1–0.328)^20 = 0.00035</p><p id="8ce5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这意味着在这种情况下，我们有大约 0.035%的机会出现 80%相似文档的假阴性。</p><p id="916f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们还希望对于 20 个波段中的任何一个(阈值= 80%)，具有 30%相似性的 2 个文档(D3 和 D4)不在同一个桶中被散列。</p><p id="db1c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">P(D3 和 D4 在特定波段中相同)= (0.3)⁵ = 0.00243</p><p id="9d2d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">P(D3 和 D4 在 20 个波段中的至少一个波段中相似)= 1-(1–0.00243)^20 = 0.0474</p><p id="2311" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这意味着在这种情况下，我们有大约 4.74%的机会在 30%的相似文档中出现误报。</p><p id="fd28" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">所以我们可以看到，我们有一些假阳性和几个假阴性。这些比例将随着 b 和 r 选择而变化</p><p id="f37f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们在这里想要的是像下面这样的东西。如果我们有两个相似度大于阈值的文档，那么它们在至少一个波段中共享同一个桶的概率应该是 1，否则为 0。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/f3b9ea72351eadd6b9733a626ea2b396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*OV2dFrYU4RzSnsO4k_DI9w.png"/></div></figure><p id="db8d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最坏的情况是，如果我们有如下所示的签名矩阵中的<em class="ne"> b =行数。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/6042de9ba4c42ef5319013c95d14d472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gp9q2loy7_FixgnblhfbfA.png"/></div></div></figure><p id="bba3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">任何 b 和 r 的一般情况如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/d53734f8c4793e8c52bebe9d06b003d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BfydUdTowQIF_KeHHOyJfw.png"/></div></div></figure><blockquote class="nf"><p id="104e" class="ng nh it bd ni nj pd pe pf pg ph mh dk translated">选择 b 和 r 以获得最佳的 S 曲线，即最小的假阴性和假阳性率</p></blockquote><figure class="po pp pq pr ps kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/83b1f6536bb23c803328655648403910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*iVfiM1wApga7bUMAWK5iAw.png"/></div></figure><h2 id="e98f" class="ol kv it bd kw om on dn la oo op dp le lv oq or lg lz os ot li md ou ov lk ow bi translated">LSH 摘要</h2><ul class=""><li id="f54a" class="mo mp it lo b lp lq ls lt lv pt lz pu md pv mh mt mu mv mw bi translated">调整<strong class="lo iu"> M，b，r </strong>以获得几乎所有具有相似签名的文档对，但排除大多数没有相似签名的对</li><li id="a5d2" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">在主存储器中检查<em class="ne">候选对</em>确实有<em class="ne">相似的签名</em></li></ul></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h1 id="c3d8" class="ku kv it bd kw kx od kz la lb oe ld le jz of ka lg kc og kd li kf oh kg lk ll bi translated">结论</h1><p id="1180" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我希望你很好地理解这个强大的算法，以及它如何减少搜索时间。你可以想象 LSH 如何适用于几乎任何类型的数据，以及它在当今的大数据世界中有多大的相关性。</p><p id="cc88" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">要阅读更多关于 LSH 的代码实现，请查看本文。<a class="ae nc" href="https://santhoshhari.github.io/Locality-Sensitive-Hashing/" rel="noopener ugc nofollow" target="_blank"><strong class="lo iu">https://santhoshhari.github.io/Locality-Sensitive-Hashing/</strong></a></p><h1 id="815a" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">参考</h1><ol class=""><li id="969e" class="mo mp it lo b lp lq ls lt lv pt lz pu md pv mh nu mu mv mw bi translated"><a class="ae nc" href="http://joyceho.github.io/cs584_s16/slides/lsh-11.pdf" rel="noopener ugc nofollow" target="_blank">http://joyceho.github.io/cs584_s16/slides/lsh-11.pdf</a></li><li id="f6b8" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh nu mu mv mw bi translated">https://www.youtube.com/watch?v=96WOGPUgMfw<a class="ae nc" href="https://www.youtube.com/watch?v=96WOGPUgMfw" rel="noopener ugc nofollow" target="_blank"/></li><li id="a2b6" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh nu mu mv mw bi translated">【https://eng.uber.com/lsh/ T4】</li><li id="f11a" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh nu mu mv mw bi translated"><a class="ae nc" href="https://medium.com/engineering-brainly/locality-sensitive-hashing-explained-304eb39291e4" rel="noopener">https://medium . com/engineering-brainly/locality-sensitive-hashing-explained-304 EB 39291 E4</a></li><li id="4963" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh nu mu mv mw bi translated"><a class="ae nc" href="http://www.mit.edu/~andoni/LSH/" rel="noopener ugc nofollow" target="_blank">http://www.mit.edu/~andoni/LSH/</a></li></ol></div></div>    
</body>
</html>