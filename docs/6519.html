<html>
<head>
<title>Analyzing Hacker News book suggestions in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 分析黑客新闻书籍建议</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/hacker-news-book-suggestions-64b88099947?source=collection_archive---------9-----------------------#2018-12-17">https://towardsdatascience.com/hacker-news-book-suggestions-64b88099947?source=collection_archive---------9-----------------------#2018-12-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="460a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个黑客新闻线程的分析，使用 Python，黑客新闻 API 和 Goodreads API，以及权威的前 20 名书籍建议列表！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/354cf4c6a4588e6e43afe47ae2348300.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MMmlzztUmGro_ij6RBYMDg.jpeg"/></div></div></figure><p id="d713" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">几天前，传统的“你今年读了什么书”主题出现在黑客新闻上。<a class="ae ln" href="https://news.ycombinator.com/item?id=18661546" rel="noopener ugc nofollow" target="_blank">线程</a>充满了非常好的书籍建议。我试图为明年做一份阅读清单，我认为收集数据并分析它会很有趣。在接下来的文章中，我将展示我如何使用 Hacker News 的 API 来收集文章内容，我如何选择最常见的标题并对照 Goodreads API 进行检查，最后我如何得出最值得推荐的 20 本书。和往常一样，处理文本数据一点也不简单。不过最后的结果还是挺满意的！</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="61a6" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">抓取线程:黑客新闻 API</h1><p id="bf8b" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">第一步是获取数据。幸运的是，黑客新闻提供了一个<a class="ae ln" href="https://github.com/HackerNews/API" rel="noopener ugc nofollow" target="_blank">非常好的 API </a>来免费抓取它的所有内容。API 有帖子、用户、热门帖子和其他一些的端点。对于本文，我们将使用一个帖子。用起来很简单，下面是基本语法:<code class="fe ms mt mu mv b">v0/item/{id}/.json</code>其中 id 是我们感兴趣的项目。在这种情况下，线程的 id 是<a class="ae ln" href="https://hacker-news.firebaseio.com/v0/item/18661546.json').json()" rel="noopener ugc nofollow" target="_blank"> 18661546 </a>，因此这里有一个关于如何获取主页面数据的示例:</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="a0ea" class="na lw iq mv b gy nb nc l nd ne">import requests <br/>main _page = requests.request(‘GET’, ‘<a class="ae ln" href="https://hacker-news.firebaseio.com/v0/item/18661546.json').json()" rel="noopener ugc nofollow" target="_blank">https://hackernews.firebaseio.com/v0/item/18661546.json').json()</a>)</span></pre><p id="dd9a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">相同的 API 调用也用于线程或帖子的子帖子，其 id 可以在父帖子的<code class="fe ms mt mu mv b">kids</code>键中找到。在孩子们身上循环，我们可以得到线程中每个帖子的文本。</p><h1 id="6c8f" class="lv lw iq bd lx ly nf ma mb mc ng me mf jw nh jx mh jz ni ka mj kc nj kd ml mm bi translated">清理数据</h1><p id="bf8c" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">现在我们有了文本数据，我们想从中提取书名。一种可能的方法是寻找文章中所有的 Amazon 或 Goodreads 链接，并按此分组。这是一种干净的方法，因为它不依赖于任何文本处理。然而，只要快速浏览一下这个帖子，就可以清楚地看到，绝大多数建议都没有任何关联。所以我决定走一条更难的路:将 n gram 分组，并将这些 n gram 与可能的书籍匹配。</p><p id="3f55" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，在从文本中剔除特殊字符后，我将二元模型、三元模型、四元模型和五元模型组合在一起，并计算出现的次数。这是一个计算二元模型的例子:</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="9276" class="na lw iq mv b gy nb nc l nd ne">import re<br/>from collections import Counter<br/>import operator</span><span id="e77d" class="na lw iq mv b gy nk nc l nd ne"># clean special characters<br/>text_clean = [re.sub(r"[^a-zA-Z0-9]+", ' ', k)  for t in text for k in t.split("\n")]</span><span id="fc01" class="na lw iq mv b gy nk nc l nd ne"># count occurrences of bigrams in different posts<br/>countsb = Counter()<br/>words = re.compile(r'\w+')<br/>for t in text_clean:<br/>    w = words.findall(t.lower())<br/>    countsb.update(zip(w,w[1:]))</span><span id="7e73" class="na lw iq mv b gy nk nc l nd ne"># sort results<br/>bigrams = sorted(<br/>    countsb.items(),<br/>    key=operator.itemgetter(1),<br/>    reverse=True<br/>)</span></pre><p id="5760" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通常在文本应用中，处理数据时首先要做的事情之一是消除停用词，即一种语言中最常见的词，如冠词和介词。在我们的例子中，我们还没有从我们的文本中删除停用词，因此这些 ngrams 中的大多数几乎都是由停用词组成的。事实上，下面是我们数据中最常见的 10 个二元模型的输出示例:</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="44d2" class="na lw iq mv b gy nb nc l nd ne">[((u'of', u'the'), 147),<br/> ((u'in', u'the'), 76),<br/> ((u'it', u's'), 67),<br/> ((u'this', u'book'), 52),<br/> ((u'this', u'year'), 49),<br/> ((u'if', u'you'), 45),<br/> ((u'and', u'the'), 44),<br/> ((u'i', u've'), 44),<br/> ((u'to', u'the'), 40),<br/> ((u'i', u'read'), 37)]</span></pre><p id="bb15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的数据中有停用词是好的，大多数标题书中都会有停用词，所以我们希望保留这些停用词。然而，为了避免查找太多的组合，我们排除了仅由停用词组成的 ngrams，保留了所有其他的。</p><h1 id="e76c" class="lv lw iq bd lx ly nf ma mb mc ng me mf jw nh jx mh jz ni ka mj kc nj kd ml mm bi translated">检查书名:Goodreads API</h1><p id="3062" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">现在我们有了一个可能的 n gram 列表，我们将使用<a class="ae ln" href="https://www.goodreads.com/api" rel="noopener ugc nofollow" target="_blank"> Goodreads API </a>来检查这些 n gram 是否对应于书名。如果有多个匹配项可供搜索，我决定将最近的出版物作为搜索结果。这是假设最近出版的书最有可能与这种环境相匹配。这当然是一个可能导致错误的假设。</p><p id="bf2a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Goodreads API 使用起来没有 Hacker News 那么简单，因为它以 XML 格式返回结果，比 JSON 格式更不友好。在这个分析中，我使用了<code class="fe ms mt mu mv b">xmltodict</code> python 包将 XML 转换成 JSON。我们需要的 API 方法是<code class="fe ms mt mu mv b"><a class="ae ln" href="https://www.goodreads.com/api/index#search.books" rel="noopener ugc nofollow" target="_blank">search.books</a></code>，它允许通过标题、作者或 ISBN 来搜索书籍。以下是获取最近发布的搜索结果的书名和作者的代码示例:</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="2b40" class="na lw iq mv b gy nb nc l nd ne">import xmltodict</span><span id="1c96" class="na lw iq mv b gy nk nc l nd ne">res = requests.get("<a class="ae ln" href="https://www.goodreads.com/search/index.xml" rel="noopener ugc nofollow" target="_blank">https://www.goodreads.com/search/index.xml</a>" , params={"key": grkey, "q":'some book title'})</span><span id="9bc5" class="na lw iq mv b gy nk nc l nd ne">xpars = xmltodict.parse(res.text)<br/>json1 = json.dumps(xpars)<br/>d = json.loads(json1)</span><span id="8424" class="na lw iq mv b gy nk nc l nd ne">lst = d['GoodreadsResponse']['search']['results']['work']<br/>ys = [int(lst[j]['original_publication_year']['#text']) for j in range(len(lst))]</span><span id="422c" class="na lw iq mv b gy nk nc l nd ne">title = lst[np.argmax(ys)]['best_book']['title']<br/>author = lst[np.argmax(ys)]['best_book']['author']['name']</span></pre><p id="8d75" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个方法允许我们将 ngrams 与可能的书籍关联起来。我们用 Goodreads API 对照全文数据检查匹配所有 ngrams 的图书列表。在进行实际检查之前，我们删除了书名，去掉了标点符号(尤其是半栏)和副标题。我们只考虑主标题，假设大部分时间只使用标题的这一部分(列表中的一些完整标题实际上很长！).根据线程中出现的次数对我们得到的结果进行排序，我们得到以下列表:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/7129fb11df16dabebd4c049354310d3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eXcaYdTqdo2WNDDV9kn3rA.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk">Books with more than 3 counts in the thread</figcaption></figure><p id="4e47" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以《坏血》看起来是帖子里最受推荐的书。检查其他结果大部分似乎是有意义的，并与线程匹配，包括计数。我能在列表中发现的唯一一个大错误是在第二位，这本书<em class="nq">被列为魔法师</em>而不是列夫·格罗斯曼的《魔术师 T2》。后者在文中确实被引用了 7 次。这个错误是由于我们假设 Goodreads API 的结果中考虑了最新的书。至于原始数据上的结果，没有出现在列表中，除了<em class="nq">三体</em>，我找不到任何明显的结果。这本书或同一三部曲中的其他书在文中被多次引用，但因为它们被不同的名称或不同的标点符号引用，所以没有被这种方法提取出来。解决这个问题的一个方法是在这个步骤中使用模糊匹配。</p><h1 id="f13f" class="lv lw iq bd lx ly nf ma mb mc ng me mf jw nh jx mh jz ni ka mj kc nj kd ml mm bi translated">结论</h1><p id="b7af" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">在本文的结论中，我展示了如何从黑客新闻中提取数据，解析数据以提取书名，使用 Goodreads API 检查书名，并将最终列表与原文进行匹配。这个任务被证明是相当复杂的，因为它需要几个假设和处理两个不同的 API。而且最终的结果还是有一些不正确的结果。</p><p id="522f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管如此，我设法得到了一个好的最终结果。以下是《黑客新闻》推荐的前 20 本书的名单:</p><ul class=""><li id="6d66" class="nr ns iq kt b ku kv kx ky la nt le nu li nv lm nw nx ny nz bi translated">《恶感:硅谷的秘密和谎言》约翰·卡瑞鲁</li><li id="e832" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">我们为什么睡觉:释放睡眠的力量，马修·沃克著</li><li id="cc69" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">列夫·格罗斯曼的《魔术师》</li><li id="f464" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">鞋狗:耐克创始人菲尔·奈特回忆录</li><li id="bfeb" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">迈克尔·波伦《如何改变你的想法》</li><li id="bf56" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">真实:汉斯·罗斯林的《我们看错世界的十个理由》</li><li id="3d2b" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">维克多·e·弗兰克尔《人类对意义的探索》</li><li id="ac10" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">卡尔·纽波特的深入研究</li><li id="b9dd" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">《德乌斯人:明日简史》尤瓦尔·诺亚·哈拉里著</li><li id="4b7d" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">D.M .凯恩的凤凰计划</li><li id="8b1d" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">尤瓦尔·诺亚·哈拉里的《21 世纪的 21 课》</li><li id="c51f" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">系统中的思考:多内拉·h·梅多斯的初级读本</li><li id="3825" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">沃尔特·伊萨克森的达芬奇</li><li id="3122" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">克里斯·沃斯的《永不分裂》</li><li id="e68b" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">Jocko Willink 的极端所有权</li><li id="5359" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">吉姆·赫夫龙的线性代数</li><li id="00a9" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">生活的 12 条规则:混乱的解毒剂</li><li id="1dde" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">蒂姆·马歇尔的《地理囚犯》</li><li id="6755" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">纳西姆·尼古拉斯·塔勒布的《游戏中的皮肤》</li><li id="505d" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">詹姆斯·克利尔的原子习惯</li></ul></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="963c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nq">源码可以在</em><a class="ae ln" href="https://github.com/AlessandroMozzato/hn_books" rel="noopener ugc nofollow" target="_blank"><em class="nq">Github</em></a><em class="nq">上查看。任何形式的评论或批评都将不胜感激。</em></p></div></div>    
</body>
</html>