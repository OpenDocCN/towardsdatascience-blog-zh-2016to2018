<html>
<head>
<title>Here’s how you can get a 2–6x speed-up on your data pre-processing with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以下是如何使用 Python 将数据预处理速度提高 2-6 倍的方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/heres-how-you-can-get-a-2-6x-speed-up-on-your-data-pre-processing-with-python-847887e63be5?source=collection_archive---------5-----------------------#2018-09-25">https://towardsdatascience.com/heres-how-you-can-get-a-2-6x-speed-up-on-your-data-pre-processing-with-python-847887e63be5?source=collection_archive---------5-----------------------#2018-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d088" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用这 3 行代码，您的预处理速度提高了 2-6 倍！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/48cab8f7da9455408d8ada4eb48e5157.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9F6HVKXZPs4x44VN.jpg"/></div></div></figure><blockquote class="ku kv kw"><p id="dc5c" class="kx ky kz la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想获得灵感？快来加入我的<a class="ae lu" href="https://www.superquotes.co/?utm_source=mediumtech&amp;utm_medium=web&amp;utm_campaign=sharing" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">超级行情快讯</strong> </a>。😎</p></blockquote><p id="a7cb" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">Python 是所有机器学习的首选编程语言。它易于使用，有许多奇妙的库，使处理数据变得轻而易举！但是，当我们处理大量数据时，事情就变得更加棘手了。</p><p id="b9db" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">如今,“大数据”一词通常指的是至少有几十万甚至<em class="kz">百万</em>个数据点的数据集！在这样的规模下，每一个小的计算都会累积起来，我们在对流水线的每一步进行编码时都需要考虑效率。当考虑我们的机器学习系统的效率时，一个经常被忽略的关键步骤是<em class="kz">预处理</em>阶段，在这里我们必须对我们所有的数据点应用某种操作。</p><p id="cb3b" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">默认情况下，Python 程序使用单个 CPU 作为单个进程执行。大多数为机器学习而制造的现代机器都有<em class="kz">至少</em> 2 个 CPU 内核。这意味着，以 2 个 CPU 内核为例，当您运行预处理时，默认情况下 50%或更多的计算机处理能力不会做任何事情！当您使用 4 核(现代英特尔 i5)或 6 核(现代英特尔 i7)时，情况会变得更糟。</p><p id="06e9" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">但是值得庆幸的是，在一个内置的 Python 库中有一个隐藏的特性，让我们可以利用我们所有的 CPU 内核！多亏了 Python 的<code class="fe ly lz ma mb b">concurrent.futures</code>模块，只需要 3 行代码就可以将一个普通的程序变成一个可以跨 CPU 内核并行处理数据的程序。</p><h1 id="7521" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">标准方法</h1><p id="38d4" class="pw-post-body-paragraph kx ky it la b lb mu ju ld le mv jx lg lv mw lj lk lw mx ln lo lx my lr ls lt im bi translated">让我们举一个简单的例子，我们在一个文件夹中有一个图像数据集；也许我们甚至有成千上万张这样的图片！为了缩短处理时间，我们这里使用 1000。我们希望在将图像传递到我们的深度神经网络之前，将所有图像的大小调整为 600x600。这是你在 GitHub 上经常看到的一些非常标准的 Python 代码的样子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="bda7" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">这个程序遵循一个您在数据处理脚本中经常看到的简单模式:</p><ol class=""><li id="5af6" class="nb nc it la b lb lc le lf lv nd lw ne lx nf lt ng nh ni nj bi translated">您从想要处理的文件(或其他数据)列表开始。</li><li id="6287" class="nb nc it la b lb nk le nl lv nm lw nn lx no lt ng nh ni nj bi translated">使用一个<code class="fe ly lz ma mb b">for</code>循环一次处理一条数据，然后在每次循环迭代中运行预处理</li></ol><p id="263d" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">让我们在一个有 1000 个 jpeg 文件的文件夹上测试这个程序，看看它需要运行多长时间:</p><pre class="kj kk kl km gt np mb nq nr aw ns bi"><span id="ca5d" class="nt md it mb b gy nu nv l nw nx">time python standard_res_conversion.py</span></pre><p id="29fc" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">我的 i7–8700k 有 6 个 CPU 内核，运行时间为<strong class="la iu"> 7.9864 秒</strong>！对于这么高端的 CPU 来说似乎有点慢。让我们看看我们能做些什么来加快速度。</p><h1 id="239d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最快的方法</h1><p id="3b4f" class="pw-post-body-paragraph kx ky it la b lb mu ju ld le mv jx lg lv mw lj lk lw mx ln lo lx my lr ls lt im bi translated">为了理解我们希望 Python 如何并行处理事物，直观地思考并行处理本身是有帮助的。假设我们必须执行同样的任务，将钉子敲进一块木头，我们的桶里有 1000 颗钉子。如果我们说每个钉子需要 1 秒钟，那么用一个人我们可以在 1000 秒内完成这项工作。但是如果我们团队有 4 个人，我们会把桶分成 4 个相等的堆，然后团队中的每个人都会处理他们自己的钉子堆。用这种方法，我们只需 250 秒就能完成！</p><p id="c961" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">在我们有 1000 张图片的例子中，我们可以让 Python 为我们做类似的事情:</p><ol class=""><li id="6e39" class="nb nc it la b lb lc le lf lv nd lw ne lx nf lt ng nh ni nj bi translated">将 jpg 文件列表分成 4 个小组。</li><li id="6cac" class="nb nc it la b lb nk le nl lv nm lw nn lx no lt ng nh ni nj bi translated">运行 Python 解释器的 4 个独立实例。</li><li id="34a5" class="nb nc it la b lb nk le nl lv nm lw nn lx no lt ng nh ni nj bi translated">让 Python 的每个实例处理 4 组较小数据中的一组。</li><li id="31fe" class="nb nc it la b lb nk le nl lv nm lw nn lx no lt ng nh ni nj bi translated">综合 4 个过程的结果，得到最终的结果列表</li></ol><p id="e3e9" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">最棒的是 Python 为我们处理了所有困难的工作。我们只需告诉它我们想要运行哪个函数，以及要使用多少 Python 实例，然后它会完成所有其他的工作！我们只需要修改<strong class="la iu"> 3 行代码</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7f54" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">从上面的代码可以看出:</p><pre class="kj kk kl km gt np mb nq nr aw ns bi"><span id="aed2" class="nt md it mb b gy nu nv l nw nx"><strong class="mb iu">with </strong>concurrent.futures.ProcessPoolExecutor() <strong class="mb iu">as </strong>executor:</span></pre><p id="9316" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">启动的 Python 进程和 CPU 内核一样多，在我的例子中是 6 个。实际的处理线是这样的:</p><pre class="kj kk kl km gt np mb nq nr aw ns bi"><span id="aa1b" class="nt md it mb b gy nu nv l nw nx">executor.map(load_and_resize, image_files)</span></pre><p id="1ecc" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated"><strong class="la iu"> executor.map() </strong>将您想要运行的函数和一个列表作为输入，其中列表的每个元素都是函数的一个<strong class="la iu">单个输入。由于我们有 6 个内核，我们将同时处理列表中的 6 个项目！</strong></p><p id="e7a3" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">如果我们再次运行我们的程序，使用:</p><pre class="kj kk kl km gt np mb nq nr aw ns bi"><span id="0fdf" class="nt md it mb b gy nu nv l nw nx">time python fast_res_conversion.py</span></pre><p id="ecf3" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">我们得到了 1.14265 秒的运行时间，接近 x6 的加速！</p><p id="aba6" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated"><em class="kz">注意:产生更多的 Python 进程和在它们之间移动数据会有一些开销，所以你不会总是获得这么大的速度提升。但总的来说，你的速度提升通常会非常显著</em></p><h1 id="a990" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">总是超级快吗？</h1><p id="37a5" class="pw-post-body-paragraph kx ky it la b lb mu ju ld le mv jx lg lv mw lj lk lw mx ln lo lx my lr ls lt im bi translated">当您有一系列要处理的数据，并且要对每个数据点执行类似的计算时，使用 Python 并行池是一个很好的解决方案。但是，它并不总是完美的解决方案。并行池处理的数据不会以任何可预测的顺序进行处理。如果您需要将处理的结果按照特定的顺序排列，那么这种方法可能不适合您。</p><p id="d1a9" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">您正在处理的数据也需要是 Python 知道如何“处理”的类型。幸运的是，这些很常见。来自官方 Python 文档:</p><ul class=""><li id="b4a2" class="nb nc it la b lb lc le lf lv nd lw ne lx nf lt ny nh ni nj bi translated"><code class="fe ly lz ma mb b">None</code>、<code class="fe ly lz ma mb b">True</code>和<code class="fe ly lz ma mb b">False</code></li><li id="dd0d" class="nb nc it la b lb nk le nl lv nm lw nn lx no lt ny nh ni nj bi translated">整数、浮点数、复数</li><li id="e865" class="nb nc it la b lb nk le nl lv nm lw nn lx no lt ny nh ni nj bi translated">字符串，字节，字节数组</li><li id="85a1" class="nb nc it la b lb nk le nl lv nm lw nn lx no lt ny nh ni nj bi translated">仅包含可选择对象的元组、列表、集合和字典</li><li id="ec44" class="nb nc it la b lb nk le nl lv nm lw nn lx no lt ny nh ni nj bi translated">在模块顶层定义的函数(使用<code class="fe ly lz ma mb b"><a class="ae lu" href="https://docs.python.org/3/reference/compound_stmts.html#def" rel="noopener ugc nofollow" target="_blank">def</a></code>，而不是<code class="fe ly lz ma mb b"><a class="ae lu" href="https://docs.python.org/3/reference/expressions.html#lambda" rel="noopener ugc nofollow" target="_blank">lambda</a></code></li><li id="a7c6" class="nb nc it la b lb nk le nl lv nm lw nn lx no lt ny nh ni nj bi translated">在模块顶层定义的内置函数</li><li id="0ef5" class="nb nc it la b lb nk le nl lv nm lw nn lx no lt ny nh ni nj bi translated">在模块顶层定义的类</li><li id="9809" class="nb nc it la b lb nk le nl lv nm lw nn lx no lt ny nh ni nj bi translated">此类类的实例，其<code class="fe ly lz ma mb b"><a class="ae lu" href="https://docs.python.org/3/library/stdtypes.html#object.__dict__" rel="noopener ugc nofollow" target="_blank">__dict__</a></code>或调用<code class="fe ly lz ma mb b"><a class="ae lu" href="https://docs.python.org/3/library/pickle.html#object.__getstate__" rel="noopener ugc nofollow" target="_blank">__getstate__()</a></code>的结果是可 picklable 的(详见<a class="ae lu" href="https://docs.python.org/3/library/pickle.html#pickle-inst" rel="noopener ugc nofollow" target="_blank">章节 pick Class Instances</a>)。</li></ul></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><h1 id="60a7" class="mc md it bd me mf og mh mi mj oh ml mm jz oi ka mo kc oj kd mq kf ok kg ms mt bi translated">喜欢学习？</h1><p id="84a5" class="pw-post-body-paragraph kx ky it la b lb mu ju ld le mv jx lg lv mw lj lk lw mx ln lo lx my lr ls lt im bi translated">在推特<a class="ae lu" href="https://twitter.com/GeorgeSeif94" rel="noopener ugc nofollow" target="_blank">上关注我，我会在这里发布所有最新最棒的人工智能、技术和科学！也请在 LinkedIn</a><a class="ae lu" href="https://www.linkedin.com/in/georgeseif/" rel="noopener ugc nofollow" target="_blank">上与我联系！</a></p></div></div>    
</body>
</html>