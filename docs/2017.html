<html>
<head>
<title>Data science with Python: Turn your conditional loops to Numpy vectors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 数据科学:将条件循环转化为 Numpy 向量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-science-with-python-turn-your-conditional-loops-to-numpy-vectors-9484ff9c622e?source=collection_archive---------0-----------------------#2017-12-05">https://towardsdatascience.com/data-science-with-python-turn-your-conditional-loops-to-numpy-vectors-9484ff9c622e?source=collection_archive---------0-----------------------#2017-12-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d747" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">矢量化技巧是数据科学家非常熟悉的，通常用于编码，以加速整体数据转换，其中简单的数学转换是在可迭代对象(如列表)上执行的。不太为人所知的是，对非平凡的代码块(如条件循环)进行矢量化也是值得的。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f43e85ba87bda3bcf0c5bcd3eec4c2c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4WEl5486nBnS7JzuGidzVw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">”<a class="ae ky" href="http://www.freepik.com" rel="noopener ugc nofollow" target="_blank">http://www.freepik.com</a>" Designed by Harryarts / Freepik</figcaption></figure><p id="a20d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 正迅速成为数据科学家选择的事实上的编程语言。但与 R 或 Julia 不同，它是一种通用语言，没有现成的函数语法来分析和转换数字数据。因此，它需要专门的图书馆。</p><p id="1155" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Numpy </strong>，简称<a class="ae ky" href="http://numpy.org" rel="noopener ugc nofollow" target="_blank">数值 Python </a>，是 Python 生态系统中高性能科学计算和数据分析所需的基础包。它是几乎所有高级工具如<a class="ae ky" href="https://pandas.pydata.org" rel="noopener ugc nofollow" target="_blank"> Pandas </a>和<a class="ae ky" href="http://scikit-learn.org/" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>构建的基础。<a class="ae ky" href="https://www.tensorflow.org" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>使用 NumPy 数组作为基本的构建模块，在此基础上他们构建了用于深度学习任务的张量对象和 graphflow(在一个长列表/向量/数字矩阵上大量使用线性代数运算)。</p><p id="c09f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多 Numpy 操作都是用 C 实现的，避免了 Python 中循环、指针间接和每元素动态类型检查的一般开销。速度提升取决于您正在执行的操作。<strong class="lb iu">对于数据科学和现代机器学习任务来说，这是一个无价的优势。</strong></p><p id="28be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最近的故事<a class="ae ky" rel="noopener" target="_blank" href="/why-you-should-forget-for-loop-for-data-science-code-and-embrace-vectorization-696632622d5f">展示了基于</a><a class="ae ky" href="http://www.numpy.org/" rel="noopener ugc nofollow" target="_blank"> Numpy </a>的简单数据转换任务矢量化的优势，引起了读者的兴趣<a class="ae ky" href="https://www.kdnuggets.com/2017/11/forget-for-loop-data-science-code-vectorization.html" rel="noopener ugc nofollow" target="_blank">也受到了读者的好评</a>。关于向量化对代码简单性的效用，有一些有趣的讨论。</p><p id="5b33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，基于一些预定义条件数学变换在数据科学任务中相当常见。事实证明，通过首先将简单的条件循环块转换成函数，然后使用<code class="fe lv lw lx ly b">numpy.vectorize</code>方法，可以很容易地对其进行矢量化。在我之前的文章<a class="ae ky" rel="noopener" target="_blank" href="/why-you-should-forget-for-loop-for-data-science-code-and-embrace-vectorization-696632622d5f">中，我展示了简单数学转换的 numpy 矢量化</a>的速度提升数量级。对于目前的情况，加速没有那么显著，因为内部条件循环仍然有些低效。然而，与其他普通 Python 代码相比，执行时间至少有 20–50%的改进。</p><p id="fd06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是演示它的简单代码:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="c68f" class="md me it ly b gy mf mg l mh mi">import numpy as np<br/>from math import sin as sn<br/>import matplotlib.pyplot as plt<br/>import time</span><span id="4062" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Number of test points</strong><br/>N_point  = 1000</span><span id="b864" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Define a custom function with some if-else loops</strong><br/>def myfunc(x,y):<br/>    if (x&gt;0.5*y and y&lt;0.3):<br/>        return (sn(x-y))<br/>    elif (x&lt;0.5*y):<br/>        return 0<br/>    elif (x&gt;0.2*y):<br/>        return (2*sn(x+2*y))<br/>    else:<br/>        return (sn(y+x))</span><span id="381e" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># List of stored elements, generated from a Normal distribution</strong><br/>lst_x = np.random.randn(N_point)<br/>lst_y = np.random.randn(N_point)<br/>lst_result = []</span><span id="ff8e" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Optional plots of the data</strong><br/>plt.hist(lst_x,bins=20)<br/>plt.show()<br/>plt.hist(lst_y,bins=20)<br/>plt.show()</span><span id="f100" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># First, plain vanilla for-loop</strong><br/>t1=time.time()<br/>for i in range(len(lst_x)):<br/>    x = lst_x[i]<br/>    y= lst_y[i]<br/>    if (x&gt;0.5*y and y&lt;0.3):<br/>        lst_result.append(sn(x-y))<br/>    elif (x&lt;0.5*y):<br/>        lst_result.append(0)<br/>    elif (x&gt;0.2*y):<br/>        lst_result.append(2*sn(x+2*y))<br/>    else:<br/>        lst_result.append(sn(y+x))<br/>t2=time.time()</span><span id="8f64" class="md me it ly b gy mj mg l mh mi">print("\nTime taken by the plain vanilla for-loop\n----------------------------------------------\n{} us".format(1000000*(t2-t1)))</span><span id="0091" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># List comprehension</strong><br/>print("\nTime taken by list comprehension and zip\n"+'-'*40)<br/>%timeit lst_result = [myfunc(x,y) for x,y in zip(lst_x,lst_y)]</span><span id="1e36" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Map() function</strong><br/>print("\nTime taken by map function\n"+'-'*40)<br/>%timeit list(map(myfunc,lst_x,lst_y))</span><span id="bbfb" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Numpy.vectorize method</strong><br/>print("\nTime taken by numpy.vectorize method\n"+'-'*40)<br/>vectfunc = np.vectorize(myfunc,otypes=[np.float],cache=False)<br/>%timeit list(vectfunc(lst_x,lst_y))</span><span id="c4d1" class="md me it ly b gy mj mg l mh mi"><strong class="ly iu"># Results<br/></strong>Time taken by the plain vanilla for-loop<br/>----------------------------------------------<br/><strong class="ly iu">2000.0934600830078</strong> us<br/><br/>Time taken by list comprehension and zip<br/>----------------------------------------<br/>1000 loops, best of 3: <strong class="ly iu">810 µs</strong> per loop<br/><br/>Time taken by map function<br/>----------------------------------------<br/>1000 loops, best of 3: <strong class="ly iu">726 µs</strong> per loop<br/><br/>Time taken by numpy.vectorize method<br/>----------------------------------------<br/>1000 loops, best of 3: <strong class="ly iu">516 µs</strong> per loop</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/de6faa35b4c510c74f22198bde40bca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YpBNsQ24pyIJ4vTW2cRImA.png"/></div></div></figure><p id="66da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我在任何地方都使用了<strong class="lb iu">% time it</strong><a class="ae ky" href="http://ipython.readthedocs.io/en/stable/interactive/magics.html" rel="noopener ugc nofollow" target="_blank">Jupyter magic command</a>来编写一行表达式。通过这种方式，我有效地运行了至少 1000 次相同表达式的循环，并平均执行时间以避免任何随机影响。因此，如果您在 Jupyter 笔记本上运行整个脚本，您可能会对第一种情况(即普通 for-loop 执行)产生略微不同的结果，但接下来的三种情况应该会给出非常一致的趋势(基于您的计算机硬件)。</p><p id="6b75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有证据表明，对于这种基于一系列条件检查的数据转换任务，使用 numpy 的矢量化方法通常比一般的 Python 方法提高了 20–50%的速度。</p><blockquote class="ml mm mn"><p id="8030" class="kz la mo lb b lc ld ju le lf lg jx lh mp lj lk ll mq ln lo lp mr lr ls lt lu im bi translated"><strong class="lb iu">这可能看起来不是一个巨大的改进，但每一点时间节省都会在数据科学管道中累积起来，从长远来看是值得的！如果数据科学工作需要这种转换发生一百万次，这可能会导致 2 天到 8 小时的差异。</strong></p></blockquote><p id="bf4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，只要您有一个很长的数据列表，并且需要对它们执行一些数学转换，就应该考虑将这些 python 数据结构(列表、元组或字典)转换成<code class="fe lv lw lx ly b">numpy.ndarray</code>对象，并使用固有的矢量化功能。</p><p id="3100" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Numpy 提供了一个 C-API 来实现更快的代码执行，但是它带走了 Python 编程的简单性。<a class="ae ky" href="http://www.scipy-lectures.org/advanced/interfacing_with_c/interfacing_with_c.html" rel="noopener ugc nofollow" target="_blank">这篇简洁的讲稿</a>展示了你在这方面的所有相关选项。</p><p id="fca0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一位法国神经科学研究者写了一整本关于这个主题的开源在线书籍。<a class="ae ky" href="https://www.labri.fr/perso/nrougier/from-python-to-numpy/#id7" rel="noopener ugc nofollow" target="_blank">点击这里查看</a>。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><p id="ce4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有任何问题或想法要分享，请联系作者在<a class="ae ky" href="mailto:tirthajyoti@gmail.com" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">tirthajyoti【AT】Gmail[DOT]com</strong></a>。你可以查看作者的<a class="ae ky" href="https://github.com/tirthajyoti" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> GitHub 资源库</strong> </a>中其他有趣的 Python、R 或 MATLAB 代码片段和机器学习资源。此外，如果你像我一样对机器学习/数据科学/半导体充满热情，请随时<a class="ae ky" href="https://www.linkedin.com/in/tirthajyoti-sarkar-2127aa7/" rel="noopener ugc nofollow" target="_blank">在 LinkedIn 上添加我</a>或<a class="ae ky" href="https://twitter.com/tirthajyotiS" rel="noopener ugc nofollow" target="_blank">在 Twitter 上关注我</a>。</p></div></div>    
</body>
</html>