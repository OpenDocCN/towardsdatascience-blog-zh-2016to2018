<html>
<head>
<title>Reproducible Research: StarCraft Mining</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可再生研究:星际采矿</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/reproducible-research-starcraft-mining-ea140d6789b9?source=collection_archive---------2-----------------------#2017-07-07">https://towardsdatascience.com/reproducible-research-starcraft-mining-ea140d6789b9?source=collection_archive---------2-----------------------#2017-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/323a76bac5ba01bcde9dfe565c7e0b1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bfff780b1KvZrLCXkkmUkw.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Troop movements in StarCraft</figcaption></figure><div class=""/><p id="1485" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2009年，我发表了一篇关于使用不同分类算法预测《星际争霸:繁殖战争》建造顺序的论文。我把T2的数据集T3提供给其他研究人员测试，一些T4的学术项目T5已经使用了这个数据集。然而，我从来没有为实验提供源代码，最终丢失了它，类似于暴雪和最初的星际争霸的源代码。自从转行到游戏行业，我开始倡导我的同事建立可重复的研究。这意味着编写输出结果的代码，删除手动步骤，并使用可以在不同机器和平台上重现的环境。</p><p id="cf60" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">自从宣布<a class="ae la" href="https://starcraft.com/en-us/" rel="noopener ugc nofollow" target="_blank">星际争霸重制版</a>和谷歌的<a class="ae la" href="http://www.gamasutra.com/view/news/284951/DeepMind_and_Blizzard_team_up_to_release_API_aimed_at_AI_enhancement.php" rel="noopener ugc nofollow" target="_blank"> DeepMind </a>应用于星际争霸2以来，人们对星际争霸人工智能的研究又有了新的兴趣。自从我第一次发表这项研究以来，近十年过去了，我很好奇我是否可以重现这个实验，看看最近的技术，如<a class="ae la" href="https://en.wikipedia.org/wiki/Xgboost" rel="noopener ugc nofollow" target="_blank"> XGBoost </a>是否会优于我之前测试的分类算法。</p><p id="77c4" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">初始设置<br/> </strong>我对这些实验的初始设置是Java代码和<a class="ae la" href="http://www.cs.waikato.ac.nz/ml/weka/" rel="noopener ugc nofollow" target="_blank"> Weka </a>库的混合。我首先使用交互式Weka GUI测试了不同的分类器，然后当我想要运行实验时，就切换到使用Weka API。我的Java脚本会运行实验并将结果输出到文本文件中，在制作图表时，我会手动将这些文本文件复制到excel中。我在我的Windows笔记本电脑和大学的Unix服务器上都进行了实验。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/e1395b8fcf6d4e78ede6dbf3b819e892.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*oSgxgTVwi1zyzqj7Bl76jA.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Protoss vs. Terran Build Order Prediction</figcaption></figure><p id="c9fd" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我想重现的关键实验是预测对手在游戏中不同模拟时间的建造顺序。我的论文中的这个实验的输出如上所示。随着不同的算法获得更多的信息，它们在识别对手的建造顺序方面变得更好。这1000多个回放被标记为6个不同的构建顺序，我标记构建顺序的方法在本文中有更详细的介绍。</p><p id="42e2" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">新脚本<br/> </strong>我的<strong class="ke jg"> </strong>以可重复的方式运行这个实验的新方法是使用<a class="ae la" href="http://rmarkdown.rstudio.com/" rel="noopener ugc nofollow" target="_blank"> R Markdown </a>，这是一种可以嵌入R代码和可视化的Markdown语言。这种方法的目标是在运行实验时消除所有手动步骤。markdown脚本从github下载必要的数据文件，运行实验，并将结果呈现为pdf文档或html文件。脚本在<a class="ae la" href="https://github.com/bgweber/StarCraftMining/blob/master/SC_Data_Mining.Rmd" rel="noopener ugc nofollow" target="_blank">这里</a>可用，结果在<a class="ae la" href="https://github.com/bgweber/StarCraftMining/blob/master/SC_Data_Mining.pdf" rel="noopener ugc nofollow" target="_blank"> pdf </a>和<a class="ae la" href="https://github.com/bgweber/StarCraftMining/blob/master/SC_Data_Mining.html" rel="noopener ugc nofollow" target="_blank"> html </a>格式可用。该脚本的输出之一如下图所示。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/c49f77bc41401f8bea36ac1be5d64120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*OFNbpQGWUYwthB3n29YqJg.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Reproduced Experiment for Protoss vs Terran Build Order prediction</figcaption></figure><p id="38cf" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该脚本直接从Github加载神族对人族建造命令的数据帧。这消除了在本地复制实验文件的需要。</p><pre class="lc ld le lf gt lh li lj lk aw ll bi"><span id="a9cf" class="lm ln jf li b gy lo lp l lq lr">df &lt;- read.csv("https://github.com/bgweber/StarCraftMining/<br/>                         raw/master/data/scmPvT_Protoss_Mid.csv")</span></pre><p id="ee67" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">实验从12分钟的游戏时间开始，然后后退以模拟游戏过程中不同的时间步长。我使用这种方法来避免多次重新加载数据框。下面的片段显示了数据帧(<em class="ls"> df </em>)如何被过滤到特定的比赛时间(<em class="ls">帧</em>)。</p><pre class="lc ld le lf gt lh li lj lk aw ll bi"><span id="2fe6" class="lm ln jf li b gy lo lp l lq lr">for (i in colnames(df)) {<br/>  if (i != 'label') {<br/>    index &lt;- df[i] &gt; frame <br/>    df[i][index] &lt;- 0<br/>  }<br/>}</span></pre><p id="3c5f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我应用了以下包中的分类器:最近邻(<em class="ls"> class </em>)、决策树(<em class="ls"> rpart </em>)、神经网络(<em class="ls"> nnet </em>)和xgboost( <em class="ls"> xgboost </em>)。</p><pre class="lc ld le lf gt lh li lj lk aw ll bi"><span id="8e23" class="lm ln jf li b gy lo lp l lq lr">predict &lt;- knn(train, test, train$label, use.all = FALSE)<br/>reg &lt;- nnet::multinom(label ~ ., data=train, trace = FALSE)<br/>model&lt;- rpart(factor(label) ~ ., data = train)<br/>bst &lt;- xgboost(data = trainM, label = train$label, ... )</span></pre><p id="ed6a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">并使用ggplot2绘制结果，生成上图:</p><pre class="lc ld le lf gt lh li lj lk aw ll bi"><span id="5014" class="lm ln jf li b gy lo lp l lq lr">ggplot(data=melt(results, id="minutes"), aes(x=minutes, y=value,   <br/>                         colour=variable)) + geom_line() + ...</span></pre><p id="744e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">结果显示，xgboost在10分钟的游戏时间内，以96%对94%的准确率，确实优于论文中性能最好的算法<a class="ae la" href="https://en.wikipedia.org/wiki/LogitBoost" rel="noopener ugc nofollow" target="_blank"> LogitBoost </a>。然而，在早期游戏中最近邻方法优于其他分类器的最初发现仍然存在。</p><p id="cf9e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该脚本还生成了第二个图表，这是游戏开始8分钟时不同特性的重要性。这是一种我在原始论文中没有包括的分析，但在这里包括是有趣的，因为它显示了球员在侦察对手时应该注意什么。基于训练好的模型，特征的重要性随着时间而变化。下面的可视化是使用xgboost函数<em class="ls"> xgb.importance </em>和<em class="ls"> xgb.plot.importance </em>生成的。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/00272e235986d82ca9b3514306e9e4d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*o27zeea8QuVV05TLo5l2Sg.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Feature importance at 8 minutes game time identified by xgboost</figcaption></figure><p id="5d80" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">新环境<br/> </strong>我在我的Windows笔记本电脑上写了R Markdown脚本进行测试。为了使实验在不同的机器和环境中可重复，我使用了<a class="ae la" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>。我从CentOS映像开始，安装R，设置库和其他依赖项，如pandoc，然后运行脚本，输出一个带有可视化效果的html文件。我使用Amazon Linux实例在AWS上构建了一个EC2实例，并运行了下面的<a class="ae la" href="https://github.com/bgweber/StarCraftMining/blob/master/Docker_Setup" rel="noopener ugc nofollow" target="_blank">命令</a>。以下部分突出显示了一些命令:</p><pre class="lc ld le lf gt lh li lj lk aw ll bi"><span id="5437" class="lm ln jf li b gy lo lp l lq lr"># install and start docker <br/>sudo yum -y install docker <br/>sudo service docker start</span><span id="cc82" class="lm ln jf li b gy lu lp l lq lr"># get the centos image, and start it in interactive mode <br/>sudo docker pull centos <br/>sudo docker run -t -i centos /bin/bash</span><span id="03b5" class="lm ln jf li b gy lu lp l lq lr"># install R, which requires updating the repo <br/>yum -y install R</span><span id="b773" class="lm ln jf li b gy lu lp l lq lr"># install required R packages <br/>R -e "install.packages('caTools', repos='<a class="ae la" href="http://cran.us.r-project.org'" rel="noopener ugc nofollow" target="_blank">http://cran.us.r-project.org'</a>)"<br/>...</span><span id="d6cc" class="lm ln jf li b gy lu lp l lq lr"># download the RMD file <br/>wget <a class="ae la" href="https://github.com/bgweber/StarCraftMining/raw/master/SC_Data_Mining.Rmd" rel="noopener ugc nofollow" target="_blank">https://github.com/bgweber/StarCraftMining/SC_Data_Mining.Rmd</a></span><span id="bdec" class="lm ln jf li b gy lu lp l lq lr"># run the script! <br/>Rscript -e "rmarkdown::render('SC_Data_Mining.Rmd')"</span></pre><p id="d193" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于这个例子，我在交互模式下运行容器。如果我想在将来持久化运行实验的环境，我将创建并应用一个docker文件，并将结果图像保存到docker注册表中。这将确保对R库或其他依赖项的更改不会影响实验环境。</p><p id="100a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">结论<br/> </strong>如果我今天要重写这篇研究论文，我会推荐使用让实验可重复的工具。使用R Markdown和Docker是帮助实现这个目标的一种方法。</p></div></div>    
</body>
</html>