<html>
<head>
<title>Bookreview: ‘Streaming Data’ by Andrew G. Psaltis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">书评:安德鲁·g·普萨尔蒂斯的《流式数据》</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bookreview-streaming-data-by-andrew-g-psaltis-79154c4cf724?source=collection_archive---------21-----------------------#2018-09-10">https://towardsdatascience.com/bookreview-streaming-data-by-andrew-g-psaltis-79154c4cf724?source=collection_archive---------21-----------------------#2018-09-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e3d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">流处理</em>近年来，由于需要更快地处理(大)数据，系统在行业中不断受到关注和采用。为了实现这一点，对一系列数字信号，即所谓的<em class="kl">数据流</em>进行处理和分析，以产生(接近)实时的洞察。Andrew Psaltis 所著的《流数据》一书收集了设计和实现端到端系统的最佳实践。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/15075e52d7e1115960469d9c15dc19e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E8tUqx2lmQ57Wyw65ddeNw.jpeg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Enns.join(Steyr)</figcaption></figure><p id="d9cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇评论主要作为书中内容的个人参考。但我会很高兴，如果这本书对其他人也有用，也许会激励一个或另一个人购买和深入阅读这本书。它的结构是内容的总结，接着是我个人对这本书的看法，最后是一些关键的收获。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="2753" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这本书的内容被分解成一个<em class="kl">数据流</em>系统的主要层。然后，通过一个动手的 pet 项目来完成，该项目的目标是构建一个系统，该系统可以实时分析 Meetup-RSVP。</p><h1 id="f4bb" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">集合层</h1><p id="52f3" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">这一章是关于常见的交互模式和容错。<a class="kn ko ep" href="https://medium.com/u/4bbba304ef8?source=post_page-----79154c4cf724--------------------------------" rel="noopener" target="_blank"> Andrew Psaltis </a>深入描述了以下交互模式，并将其应用于各种用例:</p><ul class=""><li id="2b28" class="mp mq iq jp b jq jr ju jv jy mr kc ms kg mt kk mu mv mw mx bi translated"><em class="kl">请求/响应</em></li><li id="e858" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated"><em class="kl">发布/订阅</em></li><li id="186f" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated"><em class="kl">单向模式</em></li><li id="23b0" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated"><em class="kl">请求/确认</em></li><li id="85dd" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated"><em class="kl">流型</em></li></ul><p id="2b59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不出所料，重点特别放在了<em class="kl">流模式</em>上，它颠覆了客户端与服务交互的常规设置。在这里，服务成为客户机并连接到流源(而不是在其他模式中客户机向服务发出请求)。此外，这些不同类型的交互模式的扩展概念也在书中进行了阐述。</p><p id="816f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在通用的<em class="kl">容错</em>技术部分，介绍了<em class="kl">消息记录</em>的三种变体:<em class="kl">基于接收者的</em>、<em class="kl">基于发送者的</em>和<em class="kl">混合</em>。在第一种情况下，在对每条接收到的消息采取任何操作之前，它们都被保存在磁盘上。相反，<em class="kl">基于发送方的消息日志记录</em>在消息发送之前将其写入存储。<em class="kl">混合消息日志</em>旨在提供两种方法的最佳效果，但与两种技术都用于保护系统数据不丢失并使其可恢复的情况相比，它简化了数据流。基本上，这种方法所做的是一收到消息就将它记录在稳定的存储器上，类似于基于<em class="kl">接收者的</em>方法，但是<em class="kl">是异步的</em>。与基于发送方的消息记录器类似，只有当<em class="kl">消息队列层</em>的确认到达时，该日志才会被删除。Andrew Psaltis 认为，只要有可能，就应该实施这种方法，因为它保留了容错性和安全性，而没有设置两个单独的<em class="kl">消息记录器</em>的开销，每个记录器都有一个持久存储。</p><h1 id="bbbe" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">消息队列层</h1><p id="c9e0" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">关于<em class="kl">消息队列</em>的章节首先介绍了三个主要组件:<em class="kl">生产者</em>、<em class="kl">代理</em>和<em class="kl">消费者</em>。它是技术不可知的，因此所解释的原理可以应用于该领域的各种产品(例如<a class="ae km" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>、<a class="ae km" href="http://zeromq.org/" rel="noopener ugc nofollow" target="_blank"> ZeroMQ </a>或<a class="ae km" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Kafka </a>)。</p><p id="dcf0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重要的是<em class="kl">消息传递语义</em>的引入(对于下面的<em class="kl">分析层</em>也是如此):</p><ul class=""><li id="2932" class="mp mq iq jp b jq jr ju jv jy mr kc ms kg mt kk mu mv mw mx bi translated"><em class="kl">最多一次</em> —消息可能会丢失，但不会被处理超过一次</li><li id="02f0" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated"><em class="kl">至少一次</em> —消息不会丢失，但可能会被处理多次</li><li id="83e4" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated"><em class="kl">恰好一次</em> —消息不会丢失，并且只处理一次</li></ul><p id="378c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安全也是本章的一个关注点，但不幸的是，如何实现它实际上只是作为进一步阅读的参考。<em class="kl">容错</em>也是一个大话题，在设计<em class="kl">消息队列</em>解决方案时，您应该回答一系列类似清单的问题。</p><h1 id="398e" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">分析层</h1><p id="e206" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">关于这一层的内容实际上分为两个独立的章节。第一个引入分布式<em class="kl">流处理</em>架构和框架，将其转化为行动。第二个是关于<em class="kl">流分析</em>的算法。</p><p id="a278" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在所有分布式<em class="kl">流处理</em>系统都由三部分组成:</p><ul class=""><li id="8905" class="mp mq iq jp b jq jr ju jv jy mr kc ms kg mt kk mu mv mw mx bi translated">一个<em class="kl">管理组件</em>，它分发提交的应用程序</li><li id="a0b0" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated"><em class="kl">集群中执行算法的工作节点</em></li><li id="899a" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated"><em class="kl">数据源</em>，作为算法工作的输入</li></ul><p id="b155" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">讨论用于这一层的框架是<a class="ae km" href="https://spark.apache.org/streaming/" rel="noopener ugc nofollow" target="_blank"> Spark Streaming </a>、<a class="ae km" href="http://storm.apache.org/" rel="noopener ugc nofollow" target="_blank"> Storm </a>、<a class="ae km" href="https://flink.apache.org/" rel="noopener ugc nofollow" target="_blank"> Flink </a>和<a class="ae km" href="http://samza.apache.org/" rel="noopener ugc nofollow" target="_blank"> Samza </a>。<em class="kl">消息交付语义</em>、<em class="kl">状态管理</em>和<em class="kl">容错</em>，每一个都与分析层相关，是进一步的主题。</p><p id="a16e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于流数据的算法处理，时间是一个最重要的概念。需要区分<em class="kl">事件时间</em>(事件实际发生时)和<em class="kl">流时间</em>(事件数据进入系统时)。由于流本质上永远不会结束，它们不能保存在内存中进行分析，就像传统的<em class="kl">批处理</em>一样。为了克服这个问题，引入了窗口<em class="kl">的概念</em>(在其上执行计算的定义量的流数据)。有两种<em class="kl">开窗</em>技术:</p><ul class=""><li id="9d94" class="mp mq iq jp b jq jr ju jv jy mr kc ms kg mt kk mu mv mw mx bi translated"><em class="kl">滑动窗口</em> —由窗口长度和滑动间隔定义</li><li id="0537" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated"><em class="kl">滚动窗口</em>带有<em class="kl">基于计数的</em>或<em class="kl">基于时间的</em>触发策略</li></ul><p id="a2e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于<em class="kl">摘要</em>是分析的核心，所以最后介绍与<em class="kl">流处理</em>相关的各种技术。</p><h1 id="6e3c" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">内存中数据存储</h1><p id="7d12" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">本章是关于存储之前收集和处理的数据。<em class="kl">长期存储</em>选项只是浅尝辄止，详细介绍<em class="kl">内存</em>解决方案(<em class="kl">嵌入式内存</em>和<em class="kl">缓存系统</em>)。需要区分使用<em class="kl">磁盘优先</em>方法构建的系统(提供<em class="kl">内存中</em>选项的传统数据库)和<em class="kl">内存优先</em>设计的<em class="kl">内存中数据库</em>【IMDB】。选择哪种产品在很大程度上取决于具体的使用情况，但遵循后一种方法的产品通常最适合快速流解决方案。</p><h1 id="902e" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">数据访问层</h1><p id="5260" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">构建最后一层是为了让客户端可以访问数据，主要是通过 API。有四种主要模式可以实现这一目的，本章将对此进行讨论:</p><ul class=""><li id="7420" class="mp mq iq jp b jq jr ju jv jy mr kc ms kg mt kk mu mv mw mx bi translated"><em class="kl">数据同步</em></li><li id="8f7d" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated"><em class="kl">远程方法调用</em>【RMI】/<em class="kl">远程过程调用</em>【RPC】</li><li id="0981" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated"><em class="kl">信息传递</em></li><li id="715c" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated"><em class="kl">发布/订阅</em></li></ul><p id="2de6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">详细讨论了构建流式 API 的常用协议。分别是<em class="kl"> Webhooks </em>、<em class="kl"> HTTP 长轮询</em>、<em class="kl">服务器发送事件</em>和<em class="kl"> WebSockets </em>。它们还在通信方向和不同因素(如频率、延迟、效率或可靠性)方面进行比较。</p><p id="9d37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，讨论了减少流式客户端感兴趣的事件数量的过滤类型。尽管大多数过滤方法都应参与<em class="kl">分析层</em>，但也有一些消费者特定的使用案例，其中<em class="kl">数据访问层</em>中的过滤是有意义的(例如基于地理位置的过滤器)。基本上，系统最后一层中的<em class="kl">静态- </em>(预定义决策)与<em class="kl">动态过滤</em>(运行时决策)的优缺点是相互比较的。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="0c9e" class="lm ln iq bd lo lp nd lr ls lt ne lv lw lx nf lz ma mb ng md me mf nh mh mi mj bi translated">个人评论</h1><p id="60d3" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">总的来说，我真的很喜欢读这本书。它有高质量的结构良好的内容。复杂的概念以一种易于理解的方式被分解。就我个人而言，文本中有太多的图表，这有时会妨碍流畅的阅读，尤其是当图表是多余的时候(例如，具有基础层架构的图表在每章中被绘制多次)。我发现文中对书籍或文章的引用非常有用，而且组织得很好。经常出现的优点和缺点列表也非常有用。浏览一下比较表是快速了解各种方法或技术差异的一个很好的方式。</p><p id="062e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我唯一不太满意的部分是关于分析层的部分(这有点令人难过，因为我最初买这本书是为了了解这个主题)。核心概念描述得很好，但我期待更多的细节和至少一些关于流分析算法实际实现的内容。框架的比较很好，但是我遗漏了一些代码片段(例如，每个框架的简短 hello-world)。特别是因为分析层部分也只是松散地包含在最后一章的 pet 项目中。</p><p id="2b43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我不是 Java 人士(Scala &amp; Python FTW)，我不是评判最终项目的合适人选。无论如何，这个项目的范围和领域是个不错的选择。它的核心代码逻辑很容易理解，对于那些不熟悉 Java 的人来说也是如此。</p><h1 id="c9d4" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">关键要点</h1><ul class=""><li id="756b" class="mp mq iq jp b jq mk ju ml jy ni kc nj kg nk kk mu mv mw mx bi translated">对于当今的流数据系统，没有适合所有人的解决方案。每一种相关的技术都有优点和缺点。选择最适合您特定使用情形的产品。</li><li id="1dfc" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated">这本书是一个很好的提醒，尽可能应用<a class="ae km" href="https://en.wikipedia.org/wiki/KISS_principle" rel="noopener ugc nofollow" target="_blank">接吻原则</a>。您添加的每个不必要的功能都是系统的潜在故障点。</li><li id="47aa" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated">对于流分析来说,<em class="kl">的时间概念</em>非常重要。</li><li id="35eb" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated">批处理模式下的简单分析任务(如计数)在流式系统中变得非常复杂。</li><li id="c91a" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated">持久层中的产品功能在不断改进，不同方法之间的界限正在变得模糊(远远超过 SQL 和 NoSQL 二分法)。</li></ul></div></div>    
</body>
</html>