<html>
<head>
<title>A Simple Example of Pipeline in Machine Learning with Scikit-learn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Scikit-learn 实现机器学习中流水线的一个简单例子</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-simple-example-of-pipeline-in-machine-learning-with-scikit-learn-e726ffbb6976?source=collection_archive---------0-----------------------#2018-11-12">https://towardsdatascience.com/a-simple-example-of-pipeline-in-machine-learning-with-scikit-learn-e726ffbb6976?source=collection_archive---------0-----------------------#2018-11-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0b036ddcca3eff76bb60eeb25e7b6c32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NhirwvMJraElPXg-IeGf5g.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Akagiyama: (Image Source: Author)</figcaption></figure><p id="a7e2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">今天的帖子将简短明了，我将带你看一个在 python 机器学习中使用管道的例子。我将使用其他一些重要的工具，如<code class="fe ld le lf lg b">GridSearchCV</code>等。，演示管道的实现，最后解释为什么管道在某些情况下确实是必要的。我们开始吧</p><p id="9935" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">根据 scikit-learn 对<code class="fe ld le lf lg b">pipeline</code>类的定义是</p><blockquote class="lh li lj"><p id="fb69" class="kf kg lk kh b ki kj kk kl km kn ko kp ll kr ks kt lm kv kw kx ln kz la lb lc im bi translated">顺序应用变换列表和最终估计器。流水线的中间步骤必须实现 fit 和 transform 方法，而最终的估计器只需要实现 fit。</p></blockquote><p id="999b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一旦我们开始在一个简单的数据集上实现 pipeline，上面的语句就更有意义了。这里我使用的是红酒数据集<a class="ae lo" href="https://github.com/suvoooo/Machine_Learning/blob/master/winequality-red.csv" rel="noopener ugc nofollow" target="_blank">，</a>，其中的“标签”是葡萄酒的质量，范围从 0 到 10。就数据预处理而言，这是一个相当简单的数据集，因为它没有缺失值。</p><pre class="lp lq lr ls gt lt lg lu lv aw lw bi"><span id="8237" class="lx ly it lg b gy lz ma l mb mc">import pandas as pd </span><span id="4295" class="lx ly it lg b gy md ma l mb mc">winedf = pd.read_csv('winequality-red.csv',sep=';')<br/># print winedf.isnull().sum() # check for missing data</span><span id="adb2" class="lx ly it lg b gy md ma l mb mc">print winedf.head(3)</span><span id="f508" class="lx ly it lg b gy md ma l mb mc">&gt;&gt;&gt; fixed ac.  volat. ac.  citric ac.  res. sugar chlorides  \<br/>0     7.4       0.70         0.00             1.9   0.076   <br/>1     7.8       0.88         0.00             2.6   0.098   <br/>2     7.8       0.76         0.04             2.3   0.092</span><span id="7d66" class="lx ly it lg b gy md ma l mb mc">free sulfur diox.  tot. sulfur diox.  dens.  pH  sulphates  \<br/>0     11.0            34.0           0.9978  3.51       0.56   <br/>1     25.0            67.0           0.9968  3.20       0.68   <br/>2     15.0            54.0           0.9970  3.26       0.65</span><span id="37bc" class="lx ly it lg b gy md ma l mb mc">   alcohol  quality  <br/>0      9.4        5  <br/>1      9.8        5  <br/>2      9.8        5</span></pre><p id="32b9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们总是可以用<code class="fe ld le lf lg b">seaborn</code>来检查相关图，或者我们可以用散点图来绘制一些特征，下面是两个这样的图..</p><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi me"><img src="../Images/a713bc61add1bcf8d01562b705eb353e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3j4KvpBKEiujGeJllCDx1g.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Correlation between pH and Acidity (Image: Author)</figcaption></figure><p id="0e79" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">正如预期的那样，与残糖和酸度相比，酸度和 pH 具有很高的负相关性。一旦我们熟悉并充分利用了数据集，让我们来讨论和实现管道。</p><p id="d72f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">顾名思义，<code class="fe ld le lf lg b"><em class="lk">pipeline</em></code> <em class="lk">类允许将多个进程粘贴到一个 scikit-learn 估计器中。</em> <code class="fe ld le lf lg b"><em class="lk">pipeline</em></code> <em class="lk">类有拟合、预测和评分方法，就像任何其他估计器一样</em>(例如。<code class="fe ld le lf lg b">LinearRegression</code>)。</p><p id="251e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了实现 pipeline，通常我们首先从数据集分离特征和标签。</p><pre class="lp lq lr ls gt lt lg lu lv aw lw bi"><span id="fab2" class="lx ly it lg b gy lz ma l mb mc">X=winedf.drop(['quality'],axis=1)<br/>Y=winedf['quality']</span></pre><p id="469b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你仔细观察了<code class="fe ld le lf lg b">pd.head(3)</code>的输出，你会发现数据集的特性变化很大。正如我之前解释的，就像<a class="ae lo" rel="noopener" target="_blank" href="/dive-into-pca-principal-component-analysis-with-python-43ded13ead21">主成分分析</a>一样，一些拟合算法需要缩放，这里我将使用一个这样的算法，称为 SVM(支持向量机)。关于 SVM 的更多理论，你可以查看我的<a class="ae lo" rel="noopener" target="_blank" href="/understanding-support-vector-machine-part-1-lagrange-multipliers-5c24a52ffc5e">其他帖子</a>。</p><pre class="lp lq lr ls gt lt lg lu lv aw lw bi"><span id="f18a" class="lx ly it lg b gy lz ma l mb mc">from sklearn.svm import SVC<br/>from sklearn.preprocessing import StandardScaler<br/>from sklearn.model_selection import train_test_split, GridSearchCV</span></pre><p id="6c2e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里我们使用<code class="fe ld le lf lg b">StandardScaler</code>，它从每个特征中减去平均值，然后缩放到单位方差。</p><p id="f1a5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，我们准备通过提供步骤列表来创建管道对象。我们的步骤是——标准标量和支持向量机。<em class="lk">这些步骤是由转换器或估算器的名称和实例组成的元组列表。</em>让我们来看看下面这段代码，以便澄清<em class="lk"> - </em></p><pre class="lp lq lr ls gt lt lg lu lv aw lw bi"><span id="664f" class="lx ly it lg b gy lz ma l mb mc">steps = [('scaler', StandardScaler()), ('SVM', SVC())]</span><span id="0c7a" class="lx ly it lg b gy md ma l mb mc">from sklearn.pipeline import Pipeline<br/>pipeline = Pipeline(steps) # define the pipeline object.</span></pre><p id="9703" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">字符串(' scaler '，' SVM ')可以是任何东西，因为这些只是为了清楚地识别转换器或估计器的名称。我们可以用<code class="fe ld le lf lg b">make_pipeline</code>代替流水线，避免<em class="lk"> </em>命名估计器或变换器。<em class="lk">最后一步必须是元组列表中的估计器。</em></p><p id="2bb7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们用一个<code class="fe ld le lf lg b">random_state=30</code>将数据集分为训练集和测试集。</p><pre class="lp lq lr ls gt lt lg lu lv aw lw bi"><span id="57c4" class="lx ly it lg b gy lz ma l mb mc">X_train, X_test, y_train, y_test = train_test_split(X,Y,test_size=0.2, random_state=30, stratify=Y)</span></pre><p id="8c06" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="lk">有必要使用</em> <code class="fe ld le lf lg b"><em class="lk">stratify</em></code> <em class="lk">正如我之前提到的，标签是不平衡的，因为大部分葡萄酒质量属于 5、6 级。</em>您可以使用 pandas <code class="fe ld le lf lg b">value_counts()</code>进行检查，它返回包含唯一值计数的对象。</p><pre class="lp lq lr ls gt lt lg lu lv aw lw bi"><span id="573a" class="lx ly it lg b gy lz ma l mb mc">print winedf['quality'].value_counts() </span><span id="a539" class="lx ly it lg b gy md ma l mb mc">&gt;&gt;&gt; 5    681<br/>    6    638<br/>    7    199<br/>    4     53<br/>    8     18<br/>    3     10</span></pre><p id="4de7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">SVM 通常使用两个参数<code class="fe ld le lf lg b">gamma,C</code>进行优化。我已经在另一篇文章的<a class="ae lo" rel="noopener" target="_blank" href="/visualizing-support-vector-machine-decision-boundary-69e7591dacea">中讨论了这些参数的影响，但是现在，让我们定义一个我们将在<code class="fe ld le lf lg b">GridSearchCV</code>中使用的参数网格。</a></p><pre class="lp lq lr ls gt lt lg lu lv aw lw bi"><span id="d174" class="lx ly it lg b gy lz ma l mb mc">parameteres = {'SVM__C':[0.001,0.1,10,100,10e5], 'SVM__gamma':[0.1,0.01]}</span></pre><p id="6713" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在我们用管道实例化<code class="fe ld le lf lg b">GridSearchCV</code>对象，用 5 重交叉验证实例化参数空间。</p><pre class="lp lq lr ls gt lt lg lu lv aw lw bi"><span id="af5b" class="lx ly it lg b gy lz ma l mb mc">grid = GridSearchCV(pipeline, param_grid=parameteres, cv=5)</span></pre><p id="f790" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们可以用它来拟合训练数据集，并在测试数据集上测试算法。我们还可以找到最适合 SVM 的参数，如下所示</p><pre class="lp lq lr ls gt lt lg lu lv aw lw bi"><span id="da7b" class="lx ly it lg b gy lz ma l mb mc">grid.fit(X_train, y_train)</span><span id="406a" class="lx ly it lg b gy md ma l mb mc">print "score = %3.2f" %(grid.score(X_test,y_test))</span><span id="8d26" class="lx ly it lg b gy md ma l mb mc">print grid.best_params_</span><span id="1c91" class="lx ly it lg b gy md ma l mb mc">&gt;&gt;&gt; score = 0.60<br/>    {'SVM__C': 100, 'SVM__gamma': 0.1}</span></pre><p id="c7b0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">由此，我们看到了一个有效地使用网格搜索流水线来测试支持向量机算法的例子。</p><p id="b859" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae lo" rel="noopener" target="_blank" href="/visualizing-support-vector-machine-decision-boundary-69e7591dacea">在另一篇文章</a>中，我已经详细讨论了如何应用 pipeline 和 GridSearchCV 以及如何为 SVM 绘制决策函数。你可以使用任何其他算法，如逻辑回归，而不是 SVM，来测试哪种学习算法最适合红酒数据集。<em class="lk">为了在更真实的数据集上应用包括 GridSearchCV 在内的管道中的决策树算法，您可以查看</em> <a class="ae lo" rel="noopener" target="_blank" href="/understanding-decision-tree-classification-with-scikit-learn-2ddf272731bd"> <em class="lk">这篇文章</em> </a> <em class="lk">。</em></p><h2 id="fc34" class="lx ly it bd mf mg mh dn mi mj mk dp ml kq mm mn mo ku mp mq mr ky ms mt mu mv bi translated">为什么选择管道:</h2><p id="5a48" class="pw-post-body-paragraph kf kg it kh b ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky na la lb lc im bi translated">我将用一个简单直观的解释来结束这篇文章，解释为什么管道有时是必要的。它有助于执行所需的应用步骤顺序，创建一个方便的工作流程，确保工作的可重复性。但是，管道中还有更多东西，因为我们使用了网格搜索交叉验证，我们可以更好地理解它。</p><p id="0712" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">上例中的管道对象是用<code class="fe ld le lf lg b">StandardScaler</code>和<code class="fe ld le lf lg b">SVM</code>创建的。如果单独使用管道，那么对于<code class="fe ld le lf lg b">StandardScaler</code>，可以如下进行</p><pre class="lp lq lr ls gt lt lg lu lv aw lw bi"><span id="fb25" class="lx ly it lg b gy lz ma l mb mc">scale = StandardScaler().fit(X_train)<br/>X_train_scaled = scale.transform(X_train)<br/>grid = GridSearchCV(SVC(), param_grid=parameteres, cv=5)<br/>grid.fit(X_train_scaled, y_train)</span></pre><p id="7125" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里我们看到了单独应用变压器和估计器的固有问题，其中估计器(SVM)的参数是使用<code class="fe ld le lf lg b">GridSearchCV</code>确定的。用于交叉验证的缩放特征被分成测试和训练文件夹，但是网格搜索内的测试文件夹已经包含关于训练集的信息，因为整个训练集(X_train)被用于标准化。更简单地说，当<code class="fe ld le lf lg b">SVC.fit()</code>使用交叉验证完成时，特性已经包括来自测试文件夹的信息，因为<code class="fe ld le lf lg b">StandardScaler.fit()</code>是在整个训练集上完成的。</p><p id="2082" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">人们可以通过使用管道绕过这种过分简化。使用管道，我们将<code class="fe ld le lf lg b">StandardScaler()</code>和<code class="fe ld le lf lg b">SVC()</code>粘合在一起，这确保了在交叉验证期间<code class="fe ld le lf lg b">StandardScaler</code>仅适用于训练折叠，与用于<code class="fe ld le lf lg b">SVC.fit()</code>的折叠完全相似。安德烈亚斯·穆勒的书给出了上述描述的一个奇妙的图示。</p><p id="ffdf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">[1]安德烈亚斯·穆勒、萨拉·圭多；用 Python 进行机器学习的介绍；PP-305–320；第一版；莱利·奥出版公司；<a class="ae lo" href="https://www.amazon.com/Introduction-Machine-Learning-Python-Scientists/dp/1449369413" rel="noopener ugc nofollow" target="_blank">亚马逊链接</a></p><p id="d3a9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你可以在 G <a class="ae lo" href="https://github.com/suvoooo/Machine_Learning/blob/master/pipelineWine.py" rel="noopener ugc nofollow" target="_blank"> itHub 中找到完整的代码。</a></p><p id="d505" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">干杯！保持坚强！！</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="cc35" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> <em class="lk">如果你对更深入的基础机器学习概念感兴趣，可以考虑加盟 Medium 使用</em> </strong> <a class="ae lo" href="https://saptashwa.medium.com/membership" rel="noopener"> <strong class="kh iu"> <em class="lk">我的链接</em> </strong> </a> <strong class="kh iu"> <em class="lk">。你不用额外付钱，但我会得到一点佣金。感谢大家！！</em> </strong></p></div></div>    
</body>
</html>