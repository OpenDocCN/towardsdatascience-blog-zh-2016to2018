<html>
<head>
<title>Hyper-parameters in Action! Introducing DeepReplay</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超参数在起作用！DeepReplay 简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/hyper-parameters-in-action-introducing-deepreplay-31132a7b9631?source=collection_archive---------1-----------------------#2018-05-03">https://towardsdatascience.com/hyper-parameters-in-action-introducing-deepreplay-31132a7b9631?source=collection_archive---------1-----------------------#2018-05-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f157ebd297a8d1d7b6d7a7164b75dc03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZB4D380Kh2Y33925."/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://unsplash.com/@makroman?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Immo Wegmann</a> on <a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="492b" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">介绍</h1><p id="09fe" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在我之前的<a class="ae kf" rel="noopener" target="_blank" href="/hyper-parameters-in-action-a524bf5bf1c">帖子</a>中，我邀请你去好奇<strong class="lg iu">当你训练一个神经网络的时候，在引擎盖下</strong>到底发生了什么。然后我研究了<strong class="lg iu"> <em class="mc">激活函数</em> </strong>的作用，用<strong class="lg iu">图</strong>和<strong class="lg iu">动画</strong>说明了它们对<strong class="lg iu"> <em class="mc">特征空间</em> </strong>的影响。</p><p id="6a40" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated">现在，我邀请<strong class="lg iu">你</strong>在调查中发挥积极作用！</p><p id="ea59" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated">原来这些<strong class="lg iu">情节</strong>和<strong class="lg iu">动画</strong>引起了相当多的关注。所以我决定组织我的代码，把它构造成一个合适的<strong class="lg iu"> Python 包</strong>，这样<strong class="lg iu">你</strong>就可以绘制<strong class="lg iu">你自己的深度学习模型</strong>！</p><p id="fff5" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated">你会问，它们看起来怎么样？好吧，如果你还没有查看最初的<a class="ae kf" rel="noopener" target="_blank" href="/hyper-parameters-in-action-a524bf5bf1c">帖子</a>，这里有一个快速浏览:</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mi"><img src="../Images/e4e5bbb99083d9ef8f4a6fad8a611874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Rs8Uom83oiw-t142cQD6ow.gif"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">This is what animating with DeepReplay looks like :-)</figcaption></figure><p id="c3e3" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated">所以，事不宜迟，我为你呈现… <strong class="lg iu">深度回放</strong>！</p><h1 id="99ec" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">深度回放</h1><p id="34bb" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这个包被称为<strong class="lg iu"> DeepReplay </strong>，因为这正是它允许你做的事情:<strong class="lg iu">重放</strong>训练你的深度学习模型的过程，<strong class="lg iu">绘制</strong>和<strong class="lg iu">动画制作</strong>它的几个方面。</p><p id="5c1d" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated">这个过程很简单，由<strong class="lg iu">五个步骤</strong>组成:</p><ol class=""><li id="ad3c" class="mn mo it lg b lh md ll me lp mp lt mq lx mr mb ms mt mu mv bi translated">这一切都从创建一个<strong class="lg iu">回调</strong>的实例开始！</li><li id="ddd2" class="mn mo it lg b lh mw ll mx lp my lt mz lx na mb ms mt mu mv bi translated">然后，一切照旧:构建并训练你的模型。</li><li id="6f19" class="mn mo it lg b lh mw ll mx lp my lt mz lx na mb ms mt mu mv bi translated">接下来，将收集的数据加载到<strong class="lg iu">重放</strong>中。</li><li id="c756" class="mn mo it lg b lh mw ll mx lp my lt mz lx na mb ms mt mu mv bi translated">最后，创建一个图形，然后<strong class="lg iu">将可视化效果</strong>附加到它上面。</li><li id="c6ae" class="mn mo it lg b lh mw ll mx lp my lt mz lx na mb ms mt mu mv bi translated"><strong class="lg iu">剧情</strong>和/或<strong class="lg iu">动画</strong>吧！</li></ol><p id="f5ab" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated">让我们逐一完成这些步骤！</p><h2 id="00bc" class="nb kh it bd ki nc nd dn km ne nf dp kq lp ng nh ku lt ni nj ky lx nk nl lc nm bi translated">1.创建回调的实例</h2><p id="c2ea" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">回调应该是<a class="ae kf" href="http://deepreplay.readthedocs.io/en/latest/deepreplay.html#deepreplay.callbacks.ReplayData" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> ReplayData </strong> </a>的一个实例。</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="b0dc" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated"><strong class="lg iu">回调</strong>将模型输入(<strong class="lg iu"> <em class="mc"> X </em> </strong>和<strong class="lg iu"> <em class="mc"> y </em> </strong>)以及<strong class="lg iu"> <em class="mc">文件名</em> </strong>和<strong class="lg iu"> <em class="mc">组名</em> </strong>作为参数，用于存储收集的训练数据。</p><p id="07b8" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated">要记住两件事:</p><ul class=""><li id="1bbc" class="mn mo it lg b lh md ll me lp mp lt mq lx mr mb np mt mu mv bi translated">对于玩具数据集，在你的模型拟合中使用相同的<strong class="lg iu"> <em class="mc"> X </em> </strong>和<strong class="lg iu"> <em class="mc"> y </em> </strong>就可以了。这些是将要绘制的示例-因此，如果使用较大的数据集，您可以选择数据集的随机子集来保持合理的计算时间。</li><li id="db15" class="mn mo it lg b lh mw ll mx lp my lt mz lx na mb np mt mu mv bi translated">数据存储在一个 HDF5 文件中，你可以多次使用<strong class="lg iu"> <em class="mc">同一个文件</em> </strong> <strong class="lg iu">超过</strong>，但是<strong class="lg iu">永远不要</strong><strong class="lg iu"><em class="mc">同一个组</em> </strong>！如果你尝试使用同一个组名运行它两次，你会得到一个<strong class="lg iu">错误</strong>。</li></ul><h2 id="bc9f" class="nb kh it bd ki nc nd dn km ne nf dp kq lp ng nh ku lt ni nj ky lx nk nl lc nm bi translated">2.构建并训练您的模型</h2><p id="a672" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">就像我说的，一切照常，这里没什么可看的…只是不要忘记在装配时<strong class="lg iu">将您的回调实例</strong>添加到回调列表中！</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="8ac0" class="nb kh it bd ki nc nd dn km ne nf dp kq lp ng nh ku lt ni nj ky lx nk nl lc nm bi translated">3.将收集的数据加载到重放中</h2><p id="d2de" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">所以，给整件事起名字的部分…是时候<strong class="lg iu">重播</strong>它了！</p><p id="825f" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated">应该够简单了:创建一个<a class="ae kf" href="http://deepreplay.readthedocs.io/en/latest/deepreplay.html#deepreplay.replay.Replay" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Replay </strong> </a>的实例，提供<strong class="lg iu"> <em class="mc">文件名</em> </strong>和您在<strong class="lg iu">步骤 1 </strong>中选择的<strong class="lg iu"> <em class="mc">组名</em> </strong>。</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="d720" class="nb kh it bd ki nc nd dn km ne nf dp kq lp ng nh ku lt ni nj ky lx nk nl lc nm bi translated">4.创建一个图形并附加可视化效果</h2><p id="4079" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">实际上，这是事情变得有趣的一步。只需使用<strong class="lg iu"> Matplotlib <em class="mc"> </em> </strong>创建一个图形，就像示例中的图形一样简单，或者像<a class="ae kf" href="https://matplotlib.org/users/gridspec.html" rel="noopener ugc nofollow" target="_blank"> <em class="mc"> subplot2grid </em> </a>允许您创建的图形一样复杂，并开始从您的<strong class="lg iu"> Replay </strong>对象向图形附加<strong class="lg iu">可视化效果</strong>。</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="c946" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated">上面的例子建立了一个<strong class="lg iu"> <em class="mc">特征空间</em> </strong>基于层的输出命名，暗示性地，<strong class="lg iu"> <em class="mc">隐藏</em> </strong>。</p><p id="4d50" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated">但是有五种类型的可视化可用:</p><ul class=""><li id="4c13" class="mn mo it lg b lh md ll me lp mp lt mq lx mr mb np mt mu mv bi translated"><a class="ae kf" href="http://deepreplay.readthedocs.io/en/latest/deepreplay.html#deepreplay.replay.Replay.build_feature_space" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">特征空间</strong> </a>:表示<strong class="lg iu"> <em class="mc">扭曲旋转特征空间</em> </strong>的图形，对应一个<strong class="lg iu">隐藏</strong>层的输出(目前只支持 2 单元隐藏层)，包括二维输入的<strong class="lg iu">网格线</strong>；</li></ul><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/4c578f3e5110c16ec1d2ced9cf79a2bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*3ad69HTz0S6Z0LWBzriJRw.png"/></div></figure><ul class=""><li id="5147" class="mn mo it lg b lh md ll me lp mp lt mq lx mr mb np mt mu mv bi translated"><a class="ae kf" href="http://deepreplay.readthedocs.io/en/latest/deepreplay.html#deepreplay.replay.Replay.build_decision_boundary" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">判定边界</strong> </a>:表示<strong class="lg iu"> <em class="mc">原始特征空间</em> </strong>的二维网格图，连同<strong class="lg iu"> <em class="mc">判定边界</em> </strong>(目前仅支持二维输入)；</li></ul><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/d2b454cdaf1afd0565fd07cc5016680a.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*uqguPrz6Vn3FHN1FkIsO2A.png"/></div></figure><ul class=""><li id="bd65" class="mn mo it lg b lh md ll me lp mp lt mq lx mr mb np mt mu mv bi translated"><a class="ae kf" href="http://deepreplay.readthedocs.io/en/latest/deepreplay.html#deepreplay.replay.Replay.build_probability_histogram" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">概率直方图</strong> </a> : <strong class="lg iu">两个</strong>得到的<strong class="lg iu">输入的分类概率</strong>的直方图，每个类别一个，对应模型输出(目前只支持二元分类)；</li></ul><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mi"><img src="../Images/19566ac7155fdae52eee6dcd771bb9a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QzEpx5aH1ksHP5V4xQdXZw.png"/></div></div></figure><ul class=""><li id="7b35" class="mn mo it lg b lh md ll me lp mp lt mq lx mr mb np mt mu mv bi translated"><a class="ae kf" href="http://deepreplay.readthedocs.io/en/latest/deepreplay.html#deepreplay.replay.Replay.build_loss_and_metric" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">损失和度量</strong> </a>:损失<strong class="lg iu">和选择的度量</strong>的线图，计算所有作为回调参数传递的输入；</li></ul><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/7154ea44d808b823ff4cea7fa5d3c650.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*0eDxE9-E68XWEWYOS6Wo0A.png"/></div></figure><ul class=""><li id="e432" class="mn mo it lg b lh md ll me lp mp lt mq lx mr mb np mt mu mv bi translated"><a class="ae kf" href="http://deepreplay.readthedocs.io/en/latest/deepreplay.html#deepreplay.replay.Replay.build_loss_histogram" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">损失直方图</strong> </a>:对作为回调参数传递的所有输入计算的<strong class="lg iu">损失</strong>的直方图(目前仅支持二进制交叉熵损失)。</li></ul><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/9fc284e0dd8e70a20fb9bc23118804b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*9CrubjabWaXMSTqr9fCUCA.png"/></div></figure><h2 id="f9b6" class="nb kh it bd ki nc nd dn km ne nf dp kq lp ng nh ku lt ni nj ky lx nk nl lc nm bi translated">5.绘制和/或制作动画！</h2><p id="c3ea" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">对于这个例子，用一个<strong class="lg iu">单个</strong> <strong class="lg iu">可视化</strong>，就可以直接使用它的<strong class="lg iu"> <em class="mc">剧情</em> </strong>和<strong class="lg iu"> <em class="mc">动画</em> </strong>方法。这些方法将分别返回一个图形和一个动画，然后您可以将它们保存到文件中。</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="b3fb" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated">如果您决定使用<strong class="lg iu">多个同时可视化</strong>，有两个<strong class="lg iu">辅助方法</strong>返回合成的情节和动画，分别是:<a class="ae kf" href="http://deepreplay.readthedocs.io/en/latest/deepreplay.html#deepreplay.plot.compose_plots" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu"><em class="mc">compose _ plots</em></strong></a>和<a class="ae kf" href="http://deepreplay.readthedocs.io/en/latest/deepreplay.html#deepreplay.plot.compose_animations" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu"><em class="mc">compose _ animations</em></strong></a>。</p><p id="1341" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated">为了说明这些方法，这里有一个<strong class="lg iu">要点</strong>，它来自我在最初的帖子中使用的“<strong class="lg iu"><em class="mc"/></strong>”<a class="ae kf" href="https://github.com/dvgodoy/deepreplay/blob/master/examples/part1_activation_functions.py" rel="noopener ugc nofollow" target="_blank">示例</a>。有<strong class="lg iu">四个</strong>可视化和<strong class="lg iu">五个</strong>图(<strong class="lg iu"> <em class="mc">概率直方图</em> </strong>有<strong class="lg iu">两个图</strong>，用于阴性和阳性情况)。</p><p id="68c9" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated">本帖开头的<strong class="lg iu">动画 GIF </strong>其实就是<strong class="lg iu">这个</strong>构图动画的结果！</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="5e70" class="nb kh it bd ki nc nd dn km ne nf dp kq lp ng nh ku lt ni nj ky lx nk nl lc nm bi translated">限制</h2><p id="d552" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">此时，你大概注意到了，两个<strong class="lg iu">最酷的</strong>可视化，<strong class="lg iu"> <em class="mc">特征空间</em> </strong> <em class="mc">和</em> <strong class="lg iu"> <em class="mc">决策边界</em> </strong>，都被限制在<strong class="lg iu">两个维度</strong>。</p><p id="7fce" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated">我还计划在<strong class="lg iu">三维</strong>中添加可视化支持，但大多数数据集和模型要么有<strong class="lg iu">更多输入</strong>要么有<strong class="lg iu">更多单元</strong>的隐藏层。</p><p id="a61a" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated">所以，这些是你的选择:</p><ul class=""><li id="0255" class="mn mo it lg b lh md ll me lp mp lt mq lx mr mb np mt mu mv bi translated">2D 输入，2 单元隐藏层:<strong class="lg iu"> <em class="mc">特征空间</em> </strong>带可选网格(查看<a class="ae kf" href="https://github.com/dvgodoy/deepreplay/blob/master/notebooks/part1_activation_functions.ipynb" rel="noopener ugc nofollow" target="_blank">激活函数</a>示例)；</li><li id="5f25" class="mn mo it lg b lh mw ll mx lp my lt mz lx na mb np mt mu mv bi translated">3D+输入，2 单元隐藏层:<strong class="lg iu"> <em class="mc">特征空间</em> </strong>，但无网格；</li><li id="024e" class="mn mo it lg b lh mw ll mx lp my lt mz lx na mb np mt mu mv bi translated">2D 输入，隐藏层用 3+单位:<strong class="lg iu"> <em class="mc">决定边界</em> </strong>用可选网格(查看<a class="ae kf" href="https://github.com/dvgodoy/deepreplay/blob/master/notebooks/circles_dataset.ipynb" rel="noopener ugc nofollow" target="_blank">圆圈</a>示例)；</li><li id="5d09" class="mn mo it lg b lh mw ll mx lp my lt mz lx na mb np mt mu mv bi translated">没有什么是二维的:嗯…总有一个<strong class="lg iu">解决方法</strong>，对吗？</li></ul><h1 id="11f8" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">围绕多维度工作</h1><p id="4f1e" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们想要实现什么？因为我们只能做二维图，我们想要<strong class="lg iu">二维输出</strong>——很简单。</p><p id="7b64" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated"><strong class="lg iu">如何获得二维输出？</strong>增加一个<strong class="lg iu">额外隐藏层</strong>用<strong class="lg iu">两个单位</strong>当然！好的，我知道这是<strong class="lg iu">次优</strong>，因为它实际上是在修改模型(<em class="mc">我提到过这是一个变通办法吗？！</em>)。然后我们可以使用这个额外图层的输出进行绘图。</p><p id="2889" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated">你可以查看<a class="ae kf" href="https://github.com/dvgodoy/deepreplay/blob/master/notebooks/moons_dataset.ipynb" rel="noopener ugc nofollow" target="_blank"> <em class="mc">月亮</em> </a> <em class="mc"> </em>或者<a class="ae kf" href="https://github.com/dvgodoy/deepreplay/blob/master/notebooks/UCI_spambase_dataset.ipynb" rel="noopener ugc nofollow" target="_blank"> <em class="mc"> UCI Spambase </em> </a>笔记本，查看添加一个额外的隐藏层并绘制它的示例。</p><blockquote class="ns nt nu"><p id="feab" class="le lf mc lg b lh md lj lk ll me ln lo nv mf lr ls nw mg lv lw nx mh lz ma mb im bi translated"><strong class="lg iu">继续进行，风险自负:-)</strong></p></blockquote><p id="2de6" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated"><strong class="lg iu">不管怎样，我们对这个模型做了什么？</strong>通过添加一个额外的隐藏层，我们可以认为我们的模型有<strong class="lg iu">两个组件</strong>:一个<strong class="lg iu"> <em class="mc">编码器</em> </strong>和一个<strong class="lg iu"> <em class="mc">解码器</em> </strong>。让我们稍微深入一点:</p><ul class=""><li id="cea9" class="mn mo it lg b lh md ll me lp mp lt mq lx mr mb np mt mu mv bi translated"><strong class="lg iu">编码器</strong>:编码器从输入一直到我们的<strong class="lg iu">额外隐藏层</strong>。让我们把它的二维输出看作是<strong class="lg iu">特征</strong>并把它们叫做<strong class="lg iu"> <em class="mc"> f1 </em> </strong>和<strong class="lg iu"> <em class="mc"> f2 </em> </strong>。</li><li id="1a13" class="mn mo it lg b lh mw ll mx lp my lt mz lx na mb np mt mu mv bi translated"><strong class="lg iu">解码器</strong>:在这种情况下，解码器只是一个简单明了的<strong class="lg iu">逻辑回归</strong>，它接受两个输入，比如说<strong class="lg iu"> <em class="mc"> f1 </em> </strong>和<strong class="lg iu"> <em class="mc"> f2 </em> </strong>，并输出一个分类概率。</li></ul><p id="384c" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated">让我试着用一个网络图来说得更清楚些:</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/886f0b800c24da1959a6a10193f71598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EcznfdnFdpUR7XOmS4bj9A.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Encoder / Decoder after adding an extra hidden layer</figcaption></figure><p id="9d3e" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated">这是什么？一个 9 维输入，一个有 5 个单元的原始隐藏层，一个有两个单元的额外隐藏层，其对应的两个输出(特征)和一个单个单元输出层。</p><p id="28f7" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated">那么，<strong class="lg iu">在输入</strong>的过程中会发生什么？让我们看看:</p><ol class=""><li id="fb84" class="mn mo it lg b lh md ll me lp mp lt mq lx mr mb ms mt mu mv bi translated">输入(<strong class="lg iu"> <em class="mc"> x1 </em> </strong> <em class="mc"> </em>到<em class="mc"> </em> <strong class="lg iu"> <em class="mc"> x9 </em> </strong>)被馈入<strong class="lg iu"> <em class="mc">编码器</em> </strong>部分的模型。</li><li id="0370" class="mn mo it lg b lh mw ll mx lp my lt mz lx na mb ms mt mu mv bi translated">原<strong class="lg iu">层</strong>隐<strong class="lg iu">层<em class="mc">曲折</em>层</strong>层投入。隐藏层的<strong class="lg iu">输出</strong>也可以被认为是<strong class="lg iu">特征</strong>(这些将是图中单元<em class="mc"/><strong class="lg iu"><em class="mc">h1</em></strong><em class="mc"/>到<em class="mc"/><strong class="lg iu"><em class="mc">H5</em></strong><em class="mc">的输出)，但是这些被假定为<strong class="lg iu"> n 维</strong>，因此不适合绘图。到目前为止，一切如常。</em></li><li id="2570" class="mn mo it lg b lh mw ll mx lp my lt mz lx na mb ms mt mu mv bi translated">然后是<strong class="lg iu">额外的</strong>隐藏层。它的<strong class="lg iu">权重矩阵</strong>具有形状<strong class="lg iu"> (n，2) </strong>(在图中，<strong class="lg iu"> <em class="mc"> n = 5 </em> </strong>并且我们可以在<strong class="lg iu"><em class="mc"/></strong>和<strong class="lg iu"> <em class="mc"> e </em> </strong>节点之间计数<strong class="lg iu"> 10 </strong>个箭头)。如果我们假设一个<strong class="lg iu"> <em class="mc">线性激活函数</em> </strong>，这一层实际上是在执行一个<a class="ae kf" href="https://medium.com/hipster-color-science/computing-2d-affine-transformations-using-only-matrix-multiplication-2ccb31b52181" rel="noopener"><strong class="lg iu"/></a>仿射变换，将点从一个<strong class="lg iu"> n 维</strong>映射到一个<strong class="lg iu">二维</strong>特征空间。这些是我们的功能，<strong class="lg iu"><em class="mc"/></strong><strong class="lg iu"><em class="mc">【F2】</em></strong><strong class="lg iu"><em class="mc">编码器的输出</em> </strong>部分。</li><li id="0f1b" class="mn mo it lg b lh mw ll mx lp my lt mz lx na mb ms mt mu mv bi translated">既然我们假设一个<strong class="lg iu"> <em class="mc">线性激活函数</em> </strong>用于额外的隐藏层，那么<strong class="lg iu"> <em class="mc"> f1 </em> </strong>和<strong class="lg iu"> <em class="mc"> f2 </em> </strong>将被直接馈送到<strong class="lg iu"> <em class="mc">解码器</em> </strong>(输出层)，也就是说，馈送到一个具有<strong class="lg iu"><em class="mc"/></strong><em class="mc">的单个单元这是一个简单明了的逻辑回归。</em></li></ol><p id="2184" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated"><strong class="lg iu">这一切意味着什么？</strong>意味着我们的模型也在学习一个<strong class="lg iu"> <em class="mc">潜在空间</em> </strong>与<strong class="lg iu"> <em class="mc">两个潜在因素</em> </strong> ( <strong class="lg iu"> <em class="mc"> f1 </em> </strong>与<strong class="lg iu"> <em class="mc"> f2 </em> </strong>)现在！很奇特，是吧？！不过，不要被这些术语的花哨所吓倒……这基本上意味着模型学会了将信息最好地压缩为两个特征，给定手头的任务<strong class="lg iu">——二进制分类。</strong></p><p id="e640" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated">这是<a class="ae kf" rel="noopener" target="_blank" href="/deep-inside-autoencoders-7e41f319999f"> <strong class="lg iu">自动编码器</strong> </a>的基本原理，主要区别在于自动编码器的任务是<strong class="lg iu">重建其输入</strong>，而不是以任何方式对其进行分类。</p><h1 id="c548" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">最后的想法</h1><p id="0e43" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我希望这篇文章能吸引你尝试一下深度回放</p><p id="8bbf" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated">如果你为不同的数据集，或者使用不同的网络架构或超参数，想出了<strong class="lg iu">好看又酷的</strong>可视化，请<strong class="lg iu">在<strong class="lg iu">评论</strong>部分分享</strong>它。如果有足够的兴趣，我正在考虑开始一个<strong class="lg iu">画廊</strong>页面。</p><p id="3bd4" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated">有关<strong class="lg iu"> DeepReplay </strong>包的更多信息，如安装、文档、示例和<strong class="lg iu">笔记本</strong>(你可以使用<strong class="lg iu"> Google Colab </strong>来玩)，请访问我的 GitHub 资源库:</p><div class="nz oa gp gr ob oc"><a href="https://github.com/dvgodoy/deepreplay" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">DVD godoy/deep replay</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">深度回放-深度回放-生成可视化效果，如我的“超参数运行！”系列！</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">github.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq jz oc"/></div></div></a></div><p id="e362" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated">祝你的模型动画制作愉快！:-) </p><p id="2c17" class="pw-post-body-paragraph le lf it lg b lh md lj lk ll me ln lo lp mf lr ls lt mg lv lw lx mh lz ma mb im bi translated"><em class="mc">如果你有什么想法、评论或问题，请在下方留言或联系我</em> <a class="ae kf" href="https://twitter.com/dvgodoy" rel="noopener ugc nofollow" target="_blank"> <em class="mc">推特</em> </a> <em class="mc">。</em></p></div></div>    
</body>
</html>