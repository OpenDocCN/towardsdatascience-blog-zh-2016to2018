<html>
<head>
<title>How I predicted the stock market at Numerai ML tournament</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我是如何在锦标赛中预测股市的</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-i-predicted-the-stock-market-at-numerai-ml-tournament-6f74e1c8809e?source=collection_archive---------1-----------------------#2016-09-21">https://towardsdatascience.com/how-i-predicted-the-stock-market-at-numerai-ml-tournament-6f74e1c8809e?source=collection_archive---------1-----------------------#2016-09-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3db2fb940114aa8dccfc826e02651654.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7DWTbr12476sz035QTn2Vg.jpeg"/></div></div></figure><p id="bc74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在此之前，我的机器学习教程是无聊的故事和理论:)，在这篇文章中，我将分享我在人工智能竞赛中的第一次代码体验。我在数字上尝试了我的基本机器学习技能。</p><p id="4039" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Github源代码:</strong>【https://github.com/andela-ysanni/numer.ai T2】</p><p id="1213" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据他们比赛的网站，<em class="kx">数字</em>是一个预测股票市场的全球人工智能比赛。Numerai有点类似于Kaggle，但是数据集干净整洁；你下载数据，建立模型，然后上传你的预测。很难找到一个比赛，你可以应用你喜欢的任何方法，而不需要太多的数据清理和特征工程。在这场锦标赛中，你可以做到这一点。</p><p id="e22d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">哦，是的，我最初开始学过<a class="ae kw" href="https://www.udacity.com/course/intro-to-machine-learning--ud120" rel="noopener ugc nofollow" target="_blank"> Udacity机器学习入门</a>，并且有一些关于使用scikit-learn的监督机器学习算法的基础知识。一开始我很害怕；像我这样的新手如何参加有排行榜的在线比赛？我不在排行榜末尾的可能性有多大？总之，我不畏艰险。</p><p id="a771" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">本项目使用的包</strong></p><p id="2f72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Pandas </strong>是一个用Python编写的包，用于数据结构和数据分析，<strong class="ka ir"> numpy </strong>用于创建大型多维数组和矩阵，您可以使用<a class="ae kw" href="https://packaging.python.org/installing/" rel="noopener ugc nofollow" target="_blank"> pip install </a>命令简单地安装这些包。我们还将从sklearn库导入一些包，sklearn库由简单高效的数据挖掘和数据分析工具组成，包括监督和非监督算法。</p><p id="149a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">数据概述</strong></p><p id="79d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这场比赛，我们有两个数据集，即我们的训练数据和测试数据。我建议你用数字加载你的数据集(默认情况下，它是Mac OS自带的)，看看它看起来怎么样，否则，感谢微软Excel。您还可以使用Sublime或Atom等文本编辑器来加载数据集。</p><p id="1ec3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用panda库方法“read_csv”将数据解析成DataFrame对象。read_csv方法接受file_path和一些其他可选参数。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="edd2" class="lh li iq ld b gy lj lk l ll lm">import pandas as pd</span><span id="6b77" class="lh li iq ld b gy ln lk l ll lm">training_data = pd.read_csv('numerai_training_data.csv')</span><span id="4966" class="lh li iq ld b gy ln lk l ll lm">tournament_data = pd.read_csv('numerai_tournament_data.csv')</span></pre><p id="6014" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">训练数据集</strong>有22列。第21列包括从特征1到特征21的特征，而最后一列是目标值；将用于训练我们的分类器的1或0值。我们大约有96321行。</p><p id="c076" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">锦标赛数据集</strong>是我们的测试集，它也有22列。列1是t_id，它是来自我们训练数据的目标id。剩下的21列是我们的特性值。</p><p id="c2c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">交叉验证</strong></p><p id="ba7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">交叉验证主要是衡量统计模型对独立数据集的预测性能的一种方式(从<a class="ae kw" href="http://robjhyndman.com)." rel="noopener ugc nofollow" target="_blank"> http://robjhyndman.com检索)。</a>衡量模型预测能力的一种方法是在一组未用于训练数据的数据上进行测试。数据挖掘者称之为“测试集”，用于估计的数据是“训练集”。</p><p id="485b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">验证的主要目的是避免过度拟合。当机器学习算法(如分类器)不仅识别数据集中的信号，还识别噪声时，就会发生过拟合。<em class="kx">噪声</em>这里意味着模型对数据集的特征过于敏感，而这些特征实际上没有任何意义。过度拟合的实际结果是，对其训练数据表现良好的分类器可能对来自相同问题的新数据表现不佳，甚至可能非常差。</p><p id="8177" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了开发我们的分类器，我们使用70%的数据将数据集分成两部分来训练算法。然后，我们对剩下的30%进行分类，并记录这些结果。下面是我们自己的交叉验证版本:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="7e81" class="lh li iq ld b gy lj lk l ll lm">from sklearn import cross_validation</span><span id="746a" class="lh li iq ld b gy ln lk l ll lm">features_train, features_test, labels_train, labels_test = cross_validation.train_test_split(training_data.iloc[:,0:21], training_data['target'], test_size=0.3, random_state=0)</span></pre><p id="4dd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用了sklearn的cross_validation方法，从训练数据中提取了30%的测试集。让我解释一下参数:</p><p id="2668" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> train_test_split </strong>获取我们的训练数据数组，该数组包括特征训练，但不包括我们的目标值，后跟我们的目标值数组。</p><p id="bcca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> test_size </strong>是我们百分之三十的数据比例。</p><p id="60f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> random_state </strong>取用于随机采样的伪随机数发生器状态的整数值。</p><p id="e86e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的交叉验证返回四个数组，其中包括70%的features_train和labels_train，剩余30%的features_test和labels_test。</p><p id="29b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">分类器的实现和装配</strong></p><p id="5227" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个项目中，任务是二进制分类，输出变量也称为我们的目标预计是1或0。我将使用SVC(支持向量分类)作为分类器。一个<strong class="ka ir">支持向量机</strong> ( <strong class="ka ir"> SVM </strong>)是一个判别<strong class="ka ir">分类器</strong>形式上<strong class="ka ir">由一个分离超平面定义</strong>。换句话说，给定标记的训练数据(监督学习)，算法输出一个分类新例子的最佳超平面。</p><p id="5536" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">支持向量机的优势在于:</p><ul class=""><li id="6923" class="lo lp iq ka b kb kc kf kg kj lq kn lr kr ls kv lt lu lv lw bi translated">在高维空间有效。</li><li id="91bd" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated">在维数大于样本数的情况下仍然有效。</li><li id="9e46" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated">在决策函数中使用训练点的子集(称为支持向量)，因此它也是内存高效的。</li><li id="7ed2" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated">通用:可以为决策函数指定不同的<a class="ae kw" href="http://scikit-learn.org/stable/modules/svm.html#svm-kernels" rel="noopener ugc nofollow" target="_blank">内核函数</a>。提供了通用内核，但是也可以指定定制内核。</li></ul><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="c43c" class="lh li iq ld b gy lj lk l ll lm">from sklearn.svm import SVC as svc</span><span id="5a6a" class="lh li iq ld b gy ln lk l ll lm">clf = svc(C=1.0).fit(features_train, labels_train)</span></pre><p id="3991" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> C </strong>这里控制训练数据的误分类成本。大的C给你低偏差和高方差。低偏差是因为你对错误分类的代价进行了大量的惩罚，而小的C给了你更高的偏差和更低的方差。</p><p id="7f45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">。fit() </strong>方法根据给定的训练数据来拟合SVM模型，即特征训练和标签训练。</p><p id="7f3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">做预测</strong></p><p id="4a7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步是使用30%的数据集对我们训练的分类器进行预测。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="e4dc" class="lh li iq ld b gy lj lk l ll lm">predictions = clf.predict(features_test)</span></pre><p id="0351" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> predict() </strong>方法获取一个数组并对该数组执行分类。</p><p id="37b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">精度</strong></p><p id="b754" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">精确度是我们建立的模型的精确度的加权算术平均值。我将使用sklearn测量准确度分数。该方法返回给定测试数据和标签的平均准确度。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="0b33" class="lh li iq ld b gy lj lk l ll lm">from sklearn.metrics import accuracy_score</span><span id="b58e" class="lh li iq ld b gy ln lk l ll lm">accuracy = accuracy_score(predictions,labels_test)</span></pre><p id="da7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">accuracy_score()接受两个数组；我们之前做的预测和真实的目标测试数据。</p><p id="ba25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里得到的准确度分数是<strong class="ka ir">0.51849391。</strong>非常低，所以我决定将C的值提高到100.0，以获得更好的分类和高方差。这实际上几乎花了很长时间(15分钟)来运行分类，但给出的分数为<strong class="ka ir"> 0.518133997785 </strong>，比之前的分数略高。它仍然是低的，但是我很高兴知道它稍微高于平均水平。对新手来说够公平了:)</p><p id="ac7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">重大挑战</strong></p><p id="d0bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用的分类器非常慢，当C=1.0时需要大约10分钟，当C=100.0时需要15分钟才能获得更好的分数，如果我们的数据集大小增加两倍，这将是不可伸缩的。<strong class="ka ir">为什么？</strong>实现基于libsvm。因此，拟合时间复杂度大于样本数量的平方，这使得难以扩展到具有超过10000个样本的数据集。</p><p id="e8f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">改进与结论</strong></p><p id="5bbe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的下一篇文章中，我将谈论我如何微调我的分类器的参数，以及我如何切换到使用另一种算法来优化我的结果。我希望到目前为止你喜欢这个教程。欢迎在评论区发表评论和问题。再见<br/>更新:这里是<a class="ae kw" href="https://medium.com/@Yettie/how-i-predicted-the-stock-market-at-numerai-ml-tournament-final-tutorial-1b46c459b7ba#.vltzpvwm0" rel="noopener">链接</a>到最终教程。</p></div></div>    
</body>
</html>