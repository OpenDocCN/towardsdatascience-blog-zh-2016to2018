<html>
<head>
<title>Generating Indonesian Lyric using Deep Learning - First part</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用深度学习生成印度尼西亚歌词-第一部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/generating-indonesian-lyric-using-deep-learning-first-part-2c7634237475?source=collection_archive---------12-----------------------#2018-10-05">https://towardsdatascience.com/generating-indonesian-lyric-using-deep-learning-first-part-2c7634237475?source=collection_archive---------12-----------------------#2018-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5c6e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">循序渐进。从刮擦到从零开始生成“？lalala”。(英文)</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/462da26df581c1191d95562a8bb34f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xEt8dUOzUsZVUDzj"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">“shallow focus photography of audio mixer” by <a class="ae kv" href="https://unsplash.com/@htroupe?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Hannah Troupe</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8cd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated"><span class="l lt lu lv bm lw lx ly lz ma di"> H </span> ello 各位，我对现在真正炒作的<em class="mb">人工智能</em> (AI)真的很感兴趣。我也对用它来制作东西很感兴趣。目前，创建几个人工智能应用程序是我的爱好之一。在我的空闲时间，有时，我会制作一个人工智能应用程序来释放我的无聊。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mc"><img src="../Images/5564ca9cf482132d6f8624eb36350156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HvfL6HNtpv3kxvGryy7Y-g.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">source: pexels.com</figcaption></figure><p id="150e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想习惯写作。为了练习，我需要开始写作。由于我有制作人工智能的爱好，我想分享我制作人工智能的知识和经验来练习我的写作技巧。“印度尼西亚歌词生成器”是我在空闲时间制作的一个人工智能应用程序。</p><p id="b871" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我会让这篇文章对新手友好。希望这篇文章对你有用:d。</p><p id="4ef8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文的目标读者是对人工智能感兴趣的人，尤其是对机器学习和深度学习感兴趣的人。我也会让这篇文章<em class="mb">没有数学</em>。如果你想知道它是如何工作的，我会在源代码部分附上一些文章。</p><p id="dce6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们的介绍歌词。</p><blockquote class="md me mf"><p id="d43d" class="kw kx mb ky b kz la jr lb lc ld ju le mg lg lh li mh lk ll lm mi lo lp lq lr ij bi translated">saat senyum manismu kalbuku</p><p id="7198" class="kw kx mb ky b kz la jr lb lc ld ju le mg lg lh li mh lk ll lm mi lo lp lq lr ij bi translated">杨振宁说</p><p id="475f" class="kw kx mb ky b kz la jr lb lc ld ju le mg lg lh li mh lk ll lm mi lo lp lq lr ij bi translated">terakhir kali ku hilang dariku</p><p id="1b53" class="kw kx mb ky b kz la jr lb lc ld ju le mg lg lh li mh lk ll lm mi lo lp lq lr ij bi translated">yang kau ajak kau disana</p></blockquote><p id="45f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想看这篇文章的实现和代码，你可以在这个<a class="ae kv" href="https://github.com/haryoaw/indonesia_lyric_generator" rel="noopener ugc nofollow" target="_blank"> GitHub </a>链接中看到笔记本</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h1 id="0250" class="mq mr iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">介绍</h1><p id="30fc" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">新音乐总是会出现取代旧音乐。人们应该在创作新歌时有创造性。他们需要时间创作一首新歌。他们在制作歌曲时应该考虑的一个因素是歌词。对于那些很难找到一个合适的词来创作歌词的人(比如我)，这将是一个问题。他们会花很多时间来做歌词。你想过帮助他们解决问题吗？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/cfdc789b10855b82f441735975c9e9d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*39BpqZ96OLzOBudFPAingw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source : pixabay.com</figcaption></figure><p id="da63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我想创建一个应用程序，可以让他们轻松地创作歌词。我会做一个基于人工智能的应用程序。人工智能知识是我的兴趣之一，我希望能帮助他们。</p><p id="4585" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前，人工智能是最热门的时髦词汇之一，人们在每个角落谈论它。它可以轻松解决一些对人类来说相当困难的问题。人工智能的一个分支是机器学习。机器学习是人工智能领域的一个分支，它可以根据给定的数据预测输出。它会从数据中学习。当我们想写一首歌词时，我认为我们应该偷看一些老歌，以了解他们是如何写歌词的。我们需要搜索他们如何连接每个单词的“模式”。这类似于从给定数据中学习的机器学习。</p><p id="1bfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将基于我丢弃的歌词数据集生成一个新的歌词。我们将使用深度学习，一种机器学习技术。我们将使用递归神经网络(RNN)来制作发电机的模型。</p><p id="4cd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使我选择的歌词是印度尼西亚语，不要担心。我将用英语写这篇文章。如果你想知道歌词的意思，用谷歌翻译或其他熟悉的工具翻译。</p><p id="f699" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你对深度学习的术语还不熟悉，不要担心。我将告诉你每个人的简要描述。我会告诉你如何从开始(刮)管道。正如我在开始时所说的，我会尽可能让它对新手友好。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h1 id="853f" class="mq mr iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">概述</h1><p id="6d20" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">我将按以下顺序写这篇文章:</p><ol class=""><li id="f001" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nt nu nv nw bi translated">工具</li><li id="0474" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">步骤</li><li id="f5a8" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">收集数据</li><li id="b599" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">预处理数据</li><li id="ca69" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">建立模型</li><li id="6f43" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">生成歌词</li><li id="466c" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">结论</li><li id="04f8" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">编后记</li><li id="f86d" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">来源</li></ol></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h1 id="3734" class="mq mr iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">工具</h1><p id="268e" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">将使用的库、工具和语言编程包括:</p><ol class=""><li id="6933" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nt nu nv nw bi translated">Python 3.6</li><li id="31cb" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">Python 库 numpy，python 中的数学工具</li><li id="a54a" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">Python 库 pandas，python 中的数据表格工具</li><li id="0cd9" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">Python 库— <a class="ae kv" href="http://keras.io" rel="noopener ugc nofollow" target="_blank"> Keras </a>，深度学习框架。必须有 Tensorflow、CNTK 或 Theano 库</li><li id="73f7" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">Python 库— <a class="ae kv" href="http://scrapy.org" rel="noopener ugc nofollow" target="_blank"> Scrapy </a>，Python 中流行的 scrapper 工具</li><li id="8f04" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">Jupyter 笔记本，(可选)牛逼的 Python IDE，也可以用来做演示或者教育代码。</li></ol><p id="ed84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用图形处理器英伟达 GTX 1050 来训练我的模型。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h1 id="9b81" class="mq mr iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">步骤或管道</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/804b7d100fbe9b310885239c76dadfd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*kp3ZmFHCk14pPwKBfbcUaQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image 1 : Step or Pipeline</figcaption></figure><p id="6397" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们制作发电机的步骤。</p><p id="7524" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，通过使用<em class="mb"> scrapy </em>抓取一些包含印度尼西亚歌词的网站来收集数据。然后使用 regex 清理仍然包含 HTML 标签的文本歌词。之后，处理歌词中的文本，以便它可以用于模型的输入。我们将需要构建深度学习架构。最后训练模型生成歌词。我会告诉你我是如何做到每一步的。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h1 id="8642" class="mq mr iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">收集数据(网络搜集)</h1><p id="61ae" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">我从一个印尼歌词收集网站(<a class="ae kv" href="http://lirik.kapanlagi.com" rel="noopener ugc nofollow" target="_blank">lirik.kapanlagi.com</a>)搜集了所有的歌词。网络抓取是从网站中提取数据。所有的工作都是由一个应用程序，我们将创建。我们将使用<em class="mb"> scrapy </em>库来抓取一个网站。我们要提取的信息是宋的歌词和歌名。</p><p id="c738" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将使用 lirik.kapanlagi.com 作为我们的目标。</p><p id="d754" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，在终端或命令提示符下使用以下命令创建 scrapy 项目:</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="243a" class="oi mr iq oe b gy oj ok l ol om">scrapy startproject lyric_scrapper</span></pre><p id="c792" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它将创建一个新的目录。切换到新目录并执行以下命令</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="2537" class="oi mr iq oe b gy oj ok l ol om">scrapy genspider lyric_scrapper lirik.kapanlagi.com</span></pre><p id="c9cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它将在 tutorial/spiders 文件夹中创建一个<code class="fe on oo op oe b">lyricscrapper.py</code>。我们称之为网络爬虫，因为它通过“爬行”进入目标网站。这是我们的代码:</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="c89d" class="oi mr iq oe b gy oj ok l ol om"># -*- coding: utf-8 -*-<br/>import scrapy<br/>from scrapy.spiders import CrawlSpider, Rule<br/>from scrapy.linkextractors import LinkExtractor</span><span id="f8b7" class="oi mr iq oe b gy oq ok l ol om">class LyricScrapperSpider(CrawlSpider):<br/>    name = 'lyric_scrapper'<br/>    allowed_domains = ['lirik.kapanlagi.com']<br/>    start_urls = ['<a class="ae kv" href="https://lirik.kapanlagi.com/lagu/a_id'" rel="noopener ugc nofollow" target="_blank">https://lirik.kapanlagi.com/lagu/a_id'</a>]<br/>    rules = (Rule(LinkExtractor(allow=(), restrict_css=(".pagination2 ul li a",".col-lirik .div-horizontal2-list a", "div .letterLinksAnchor")), callback="parse_page", follow=True),)<br/>    def parse_page(self, response):<br/>        song = response.css('.col-lirik').extract_first()<br/>        title= response.css('.head-lirik h5::text').extract_first()<br/>        if len(title) &gt; 0 and len(song) &gt; 0:</span><span id="a764" class="oi mr iq oe b gy oq ok l ol om">scraped_info = {<br/>            'song' : song,<br/>            'title' : title,<br/>        }</span><span id="b868" class="oi mr iq oe b gy oq ok l ol om">yield scraped_info</span></pre><p id="9527" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看这一部分:</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="02f5" class="oi mr iq oe b gy oj ok l ol om">start_urls = ['<a class="ae kv" href="https://lirik.kapanlagi.com/lagu/a_id'" rel="noopener ugc nofollow" target="_blank">https://lirik.kapanlagi.com/lagu/a_id'</a>]<br/>    rules = (Rule(LinkExtractor(allow=(), restrict_css=(".pagination2 ul li a",".col-lirik .div-horizontal2-list a", "div .letterLinksAnchor")), callback="parse_page", follow=True),)</span></pre><p id="3235" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将从<code class="fe on oo op oe b">start_urls</code>中的 URL 开始。为了确定起始 URL，我们应该找到包含歌词索引列表的页面。我发现<a class="ae kv" href="https://lirik.kapanlagi.com/lagu/a_id'" rel="noopener ugc nofollow" target="_blank">是 https://lirik.kapanlagi.com/lagu/a_id</a>的索引列表。</p><p id="2fee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">爬行器将通过在当前网页中查找 URL 来找到下一个要抓取的目标。为了让爬虫跟踪我们想要的页面，我们必须指定爬虫必须看到网页的哪个部分。在这种情况下，我们需要瞄准图 2 所示的这部分:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/6d1369e1d63c71522ed76421498efffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wOqrS_pnjSvIdELdCJ2CKg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image 2 : We will target these parts (blue marker)</figcaption></figure><p id="876c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要通过检查 HTML 代码来得到我们想要的部分。对我来说，我用 Inspect Element 来做(Firefox)。对于这个网站，我们将限制爬虫将目标<code class="fe on oo op oe b">(“.pagination2 ul li a”,”.col-lirik .div-horizontal2-list a”, “div .letterLinksAnchor”)</code>。它将抓取网站，直到没有更多的网址抓取(它还会检查该网址是否已被访问)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/2d83e43dbba5e098189970072e7768b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*o8HeRHzEBTU1KYPNnG-qUQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image 3: Part that we want to extract</figcaption></figure><p id="b8a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们要从网页中提取歌词和标题的歌曲。为此，我们需要找到包含它们的 HTML 标签(图 3 中红色和蓝色的标签)。</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="ec7d" class="oi mr iq oe b gy oj ok l ol om">song = response.css('.col-lirik').extract_first() <br/>title = response.css('.head-lirik h5::text').extract_first()</span></pre><p id="e0c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于歌词(我将其命名为' song '变量)，我们需要 HTML 代码，因为这个网站的 HTML 组成有点乱。我们一会儿需要清理它。</p><p id="cb76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">救你的<code class="fe on oo op oe b">lyricscrapper.py</code>。然后，打开文件夹内的<code class="fe on oo op oe b">settings.py</code>。</p><p id="4a59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加或取消注释这些行:</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="1241" class="oi mr iq oe b gy oj ok l ol om">FEED_FORMAT = "csv"<br/>FEED_URI = "scrape.csv"</span><span id="a033" class="oi mr iq oe b gy oq ok l ol om">DOWNLOAD_DELAY = 1 # important, sometimes you will get banned if you set it to 0. </span></pre><p id="6e0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">保存它，然后在控制台上执行以下命令:</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="e394" class="oi mr iq oe b gy oj ok l ol om">scrapy crawl lyric_scrapper</span></pre><p id="5be1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">瞧，我们的爬虫将爬行我们的目标站点。只要等到它结束或强迫它结束，如果你很无聊。结束后，它会在文件夹内生成<code class="fe on oo op oe b">scrape.csv</code>。您可以使用电子表格工具打开它来查看。有点乱，不是吗？。如上所述，我们需要清理歌词的文本。所以让我们进入下一步。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h1 id="c968" class="mq mr iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">清除报废数据</h1><p id="5617" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">现在是时候清理我们的脏数据了。因为我们只想生成歌词，所以我们只需要来自<code class="fe on oo op oe b">scrape.csv</code>的歌曲列。在开始之前，我建议我们使用 Python IDE，如 Jupyter Notebook 或 Spyder，以便更好地查看我们的数据。在这一部分，我们将使用 pandas 库来查看表格中的数据。</p><p id="5cd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开您的代码，然后让我们导入我们的 csv 数据，并将其转换成 dataframe 类型(<code class="fe on oo op oe b">pd.DataFrame</code>)。为了检查歌词的歌曲，我们将采样 5 个实例。一定要把<code class="fe on oo op oe b">scrape.csv</code>文件放到我们 python 的代码文件夹中。</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="81d6" class="oi mr iq oe b gy oj ok l ol om">import pandas as pd<br/>scrape_lyric = pd.read_csv('scrape.csv')<br/>scrape_lyric.sample(5)</span></pre><p id="3b1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要确保我们的数据没有缺失数据。然后，如果提取了一些错误页面，我们就移除不想要的数据。在我们的例子中，我们会发现我们的歌词网页应该包含 span 标签。所以删除没有 span 标签的实例。我们将删除包含“Belum ada Lirik”文本实例(翻译:没有任何歌词)。</p><p id="3c7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在清理之前，我们应该检查数据的大小。使用<code class="fe on oo op oe b">scrape_lyric.shape</code>进行检查。我有 20259 行。</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="e6da" class="oi mr iq oe b gy oj ok l ol om">scrape_lyric = scrape_lyric.dropna()<br/>scrape_lyric = scrape_lyric[scrape_lyric.song.str.contains('span')]<br/>scrape_lyric = scrape_lyric[~(scrape_lyric.song.str.contains('Belum Ada Lirik'))]</span></pre><p id="98eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检查你的数据帧<code class="fe on oo op oe b">scrape_lyric.shape</code>的大小，我有 13791 行。它遗漏了 6468 行！</p><p id="0246" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们只会看到‘宋’一栏。通过查看 song 列，我们会看到文本仍然有 HTML 标记。我们需要清理它。我们将使用正则表达式来做这件事。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/6694f09bc2e48d3318147d5b39480db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ZZbJ-7_fJ27dbPnSaN-0w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image 4: Example of 1 instance in the data</figcaption></figure><p id="2746" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个清理正则表达式只适用于我们的目标网站。如果我们的目标是其他网站，我们需要看看 HTML 模式是怎样的，并使用适当的正则表达式来清理它(或者如果网站很好解析，可能不需要清理数据)。</p><p id="bf0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是清理我们的网页的正则表达式:</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="d182" class="oi mr iq oe b gy oj ok l ol om">def clean_text_lyric(lyric, max_length):<br/> lyric_sample = lyric.split('&lt;/span&gt;')<br/> lyric_sample = lyric_sample[:-1]<br/>    <br/> clean_song_lyric = ""<br/> for sentence in lyric_sample:<br/>   if 'http' not in sentence:<br/>      sentence = re.sub(r'&lt;div .*&gt;','',sentence)<br/>      sentence = re.sub(r'&lt;span .*&gt;','',sentence)<br/>      sentence = sentence.strip()<br/>      if len(sentence) &gt; 0:<br/>        sentence = re.sub(r'[^a-zA-Z0-9&lt;\/&gt;\s]',' ', sentence)</span><span id="36d2" class="oi mr iq oe b gy oq ok l ol om">        sentence = " &lt;div&gt; " + sentence + " &lt;/div&gt; "<br/>        sentence = re.sub(r'&lt;div&gt;\s+&lt;br&gt;','&lt;br&gt; &lt;div&gt; ', sentence)<br/>        sentence = re.sub(r'(\d|\r|\t|\n)','',sentence)</span><span id="8c2d" class="oi mr iq oe b gy oq ok l ol om">        clean_song_lyric += sentence</span><span id="8511" class="oi mr iq oe b gy oq ok l ol om">        clean_song_lyric = ' &lt;start&gt; ' * (max_length-1) +                  clean_song_lyric<br/>    return clean_song_lyric</span></pre><p id="1eef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将逐一看到:</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="53e2" class="oi mr iq oe b gy oj ok l ol om">lyric_sample = lyric.split('&lt;/span&gt;')<br/>lyric_sample = lyric_sample[:-1]</span></pre><p id="5f76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们查看我们提取的歌词，他们用 HTML 标签“<code class="fe on oo op oe b">&lt;br&gt;</code>”来分隔他们的诗句。1 节包含几行。每行由 HTML 标记“<code class="fe on oo op oe b">&lt;/span&gt;</code>”分隔。我们需要通过使用“<code class="fe on oo op oe b">&lt;/span&gt;</code>”来拆分行。</p><p id="b227" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们移除 HTML 标签(div，span)</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="ca5c" class="oi mr iq oe b gy oj ok l ol om">sentence = re.sub(r'&lt;div .*&gt;','',sentence)<br/>sentence = re.sub(r'&lt;span .*&gt;','',sentence)</span></pre><p id="c973" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们将删除除了<code class="fe on oo op oe b"> [^a-zA-Z0–9&lt;\/&gt;\s]</code>以外的所有字符。我们删除了转义字符和多余的空白。如果你不熟悉 regex，建议你试试<a class="ae kv" href="http://regex101.com" rel="noopener ugc nofollow" target="_blank">这个</a>站点玩 regex。</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="9980" class="oi mr iq oe b gy oj ok l ol om">sentence = re.sub(r'[^a-zA-Z0-9&lt;\/&gt;\s]',' ', sentence)</span><span id="b6d6" class="oi mr iq oe b gy oq ok l ol om">sentence = " &lt;div&gt; " + sentence + " &lt;/div&gt; "<br/>sentence = re.sub(r'&lt;div&gt;\s+&lt;br&gt;','&lt;br&gt; &lt;div&gt; ', sentence)<br/>sentence = re.sub(r'(\d|\r|\t|\n)','',sentence)</span></pre><p id="0dbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我讨厌这个网站的 HTML 代码。提取的歌词有时在歌词内有 URL。这就是为什么我设置了循环保护来确保里面没有 URL。</p><p id="5511" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们清理文本之后，我们想要标记我们的开始和结束歌词的行。</p><p id="75d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对我来说，我使用了<code class="fe on oo op oe b">&lt;div&gt;</code>和<code class="fe on oo op oe b">&lt;/div&gt;</code>标签来标记我们歌词的开始和结束。</p><p id="199a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不会删除<code class="fe on oo op oe b">&lt;br&gt;</code>标签。这是一个标记，用来分隔每一节。</p><p id="8b86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将在所需的<code class="fe on oo op oe b">max_length-1</code>的歌词开头添加<code class="fe on oo op oe b">&lt;start&gt;</code>标签。我们为什么要这么做？我以后会告诉你。</p><p id="2679" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将其应用到数据框中:</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="be55" class="oi mr iq oe b gy oj ok l ol om">scrape_lyric['song'] = scrape_lyric['song'].apply(lambda x: clean_text_lyric(x))</span></pre><p id="d723" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们想要使用的歌词格式文本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/938639f9ca874c90df584ae1d3d2c879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kd9aSc4mZeAjD5ypVcG9GQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image 5: desired lyric’s format</figcaption></figure></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h1 id="8712" class="mq mr iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">预处理数据</h1><p id="0e26" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">清理完数据后，让我们进入数据预处理。为什么我们需要这样做？我们的深度学习模型的输入是一系列文本。它不能在字符串模式下读取文本。我们需要将数据集中的所有单词编码到索引号中，在一次热编码中将索引号映射到单词中。当我们使用嵌入时，在 keras 中，我们不必将文本编码成一个热编码。我们可以使用键索引映射来映射模型中带有索引号的单词。</p><p id="525d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在此之前，让我们将包含几行的歌词转换成一个具有所需长度的序列文本数组集合。</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="a482" class="oi mr iq oe b gy oj ok l ol om">def generate_train_dataset(song_series, window):<br/>    train_data = []<br/>    train_label = []<br/>    for song_string in song_series:<br/>        song_arr = song_string.split()<br/>        len_song_arr = len(song_arr)</span><span id="da24" class="oi mr iq oe b gy oq ok l ol om">        for i in range(0,len_song_arr-window+1):<br/>            train_data.append(' '.join(song_arr[i:i+window-1]))<br/>            train_label.append(song_arr[i+window-1])<br/>    return np.array(train_data), np.array(train_label)</span></pre><p id="c40d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请看图 6，想象一下<code class="fe on oo op oe b">generate_train_dataset </code>功能是如何工作的。它将从开始切片到<code class="fe on oo op oe b">window-1</code>并将其添加到 train_data 列表中。然后将最后一个索引添加到<code class="fe on oo op oe b">train_label </code>列表中。这叫做<strong class="ky ir">滑动窗口</strong>，窗口长度等于我们的<code class="fe on oo op oe b">window</code>参数。在本文中，我们将设置窗口等于 10。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/d0309b5abc868db5abd3f532c7e88feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QEYDafAHGDDRE9khKbVGoQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image 6: sent_len parameter set to 5</figcaption></figure><p id="40fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们创建的函数需要一个<code class="fe on oo op oe b">pandas.Series</code>类型作为输入。</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="ec3f" class="oi mr iq oe b gy oj ok l ol om">max_length = 10 #window<br/>X, y = generate_train_dataset(scrape_lyric.song, sent_len=max_length)</span></pre><p id="75cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">成功了吗？很好，接下来我们将使用<code class="fe on oo op oe b">keras.preprocessing.text.Tokenizer </code>库来创建一个输入映射，它将一个单词映射到函数选择的索引号。确保更改参数过滤器，不包括<code class="fe on oo op oe b">‘&lt;’</code>和<code class="fe on oo op oe b">‘&gt;’</code>。</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="89ac" class="oi mr iq oe b gy oj ok l ol om">pre = keras.preprocessing.text.Tokenizer(filters='!"#$%&amp;()*+,-.:;=?@[\\]^_`{|}~\t\n')<br/>pre.fit_on_texts(X.flatten()) # need to flatten the array</span></pre><p id="f6f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将得到词汇量，它包含了我们的数据中有多少独特的单词。</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="0950" class="oi mr iq oe b gy oj ok l ol om">vocab_size = len(pre.word_index)</span></pre><p id="6162" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将数据转换成单词索引序列:</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="7bad" class="oi mr iq oe b gy oj ok l ol om">X = pre.texts_to_sequences(X)<br/>y = pre.texts_to_sequences(y)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/980d40514875272f6edca0cd5618efbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YD9ErCNpgIRe8DysnblGPw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image 7: How Our Tokenization works</figcaption></figure><p id="d0f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经完成了对输入数据的预处理。我有大约 200 万个例子。</p><p id="cfcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们继续创建模型。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h1 id="70f4" class="mq mr iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">定义深度学习的架构</h1><p id="0791" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">在我们深入研究代码和实现之前，让我们回忆一下什么是深度学习、密集层、RNN、LSTM 层和激活函数。我们会召回他们。</p><h2 id="6dda" class="oi mr iq bd ms ox oy dn mw oz pa dp na lf pb pc nc lj pd pe ne ln pf pg ng ph bi translated">深度学习</h2><p id="ba65" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">深度学习是机器学习技术的一个子集。根据 Yoshua Bengio 的说法，他说“<em class="mb">深度学习算法寻求利用输入分布中的未知结构，以便发现良好的表示，通常是在多个级别，较高级别的学习特征根据较低级别的特征来定义”。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/506d99648ff54cde1e669ec487a49ba1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3tqHU30GdG6CdU8d.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source : pixabay.com</figcaption></figure><p id="13c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">深度学习将从数据中学习特征表示。我们不必从数据中提取特征。它不同于其他需要提取特征的机器学习算法。它由模仿人脑的几个层次和网络组成。它有许多别名，如深度神经网络。深度神经网络的主要部分是<strong class="ky ir">反向传播</strong>算法，它将使用优化器算法更新我们的模型权重，使误差最小。如果你想了解更多，请访问这个<a class="ae kv" href="https://machinelearningmastery.com/what-is-deep-learning/" rel="noopener ugc nofollow" target="_blank">网站</a>。</p><h2 id="dd8d" class="oi mr iq bd ms ox oy dn mw oz pa dp na lf pb pc nc lj pd pe ne ln pf pg ng ph bi translated">把...嵌入</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pj"><img src="../Images/3c20ca1613919bb8ce4464b9096c7a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ji2CGbIZZ5YTe4eK.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source : ruder.io</figcaption></figure><p id="fcc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嵌入是一种技术，它将使我们在数据集中的实例成为一种经过学习的表示。在本教程中，我们将使用单词嵌入。单词嵌入将把我们的单词表示成作为实值向量的学习表示。它通常由十维或数百维向量组成。向量通常会捕捉单词的意思。</p><p id="c940" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有几种算法可以进行单词嵌入。有:</p><ol class=""><li id="c6f2" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nt nu nv nw bi translated">嵌入层</li><li id="fb74" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">Word2vec</li><li id="090d" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">手套</li><li id="99ca" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">节目预留装置</li><li id="d48e" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">埃尔莫(<strong class="ky ir">新</strong>)</li></ol><p id="d761" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的模型中，我们将使用嵌入层。它将根据我们的模型更新向量。</p><h2 id="dddf" class="oi mr iq bd ms ox oy dn mw oz pa dp na lf pb pc nc lj pd pe ne ln pf pg ng ph bi translated">致密层</h2><p id="97f8" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">这是全连接层的别名。它是一个线性层，传播一个<strong class="ky ir">线性函数</strong>，并使用该函数的导数(梯度)从一个神经元反向传播到另一个神经元。更简单地说，这是一个网络，它只接受输入并乘以从反向传播中学习到的权重。我找到了一篇中型文章，可以帮助你更好地理解<a class="ae kv" rel="noopener" target="_blank" href="/under-the-hood-of-neural-networks-part-1-fully-connected-5223b7f78528">全连接层。</a></p><h2 id="bc41" class="oi mr iq bd ms ox oy dn mw oz pa dp na lf pb pc nc lj pd pe ne ln pf pg ng ph bi translated">RNN 和 LSTM</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pk"><img src="../Images/5075bee1859d8d9a09fbc1a2618360d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*c5lS5niuEP0lNS2M.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source : colah.github.io</figcaption></figure><p id="af3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">递归神经网络(RNN)是一个具有内部存储器的层，因此它可以记住输入的序列信息。神经元之间连接是一系列有向图。它会记住前一个神经元的信息(权重),并将其传递给当前神经元。</p><p id="4916" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用 RNN 有几个缺点。它学不会'<em class="mb">长期依赖</em>'。它会遇到一个问题，叫做“<em class="mb">消失梯度</em>”。它不会再更新神经元的权重。为了解决这个问题，长短期记忆(LSTM)被使用。</p><p id="788d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">LSTM 是 RNN 问题的一剂良药。它有能力解决“长期依赖”问题。LSTM 有能力通过一种叫做“门”的结构给新神经元添加或删除信息。LSTM 有三个门:遗忘门、输入门和输出门。他们将控制神经元的状态。如需了解更多信息，您可以访问此<a class="ae kv" href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/" rel="noopener ugc nofollow" target="_blank">网站</a>。</p><h2 id="b944" class="oi mr iq bd ms ox oy dn mw oz pa dp na lf pb pc nc lj pd pe ne ln pf pg ng ph bi translated">批量标准化</h2><p id="1df2" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">归一化目标图层的输出值。它们的平均输出激活为 0，标准偏差为 1。它有几个好处，如加快我们的训练速度。如果你想了解更多关于 BatchNormalization 的细节，请看这篇<a class="ae kv" href="https://medium.com/deeper-learning/glossary-of-deep-learning-batch-normalisation-8266dcd2fa82" rel="noopener">文章</a>。</p><h2 id="1e09" class="oi mr iq bd ms ox oy dn mw oz pa dp na lf pb pc nc lj pd pe ne ln pf pg ng ph bi translated">激活功能</h2><p id="e1a8" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">它用于确定一个层的输出是否被激活。它将输出映射到激活函数的范围。要了解更多细节，请访问<a class="ae kv" rel="noopener" target="_blank" href="/activation-functions-neural-networks-1cbd9f8d91d6">这篇</a>文章。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h1 id="86dc" class="mq mr iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">体系结构</h1><p id="457d" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">回忆完了吗？让我们进入代码</p><p id="11b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将建立的是一个简单的架构深度网络。它由嵌入层、LSTM 层和密集层组成，以<em class="mb">分类交叉熵</em>和<em class="mb"> softmax 激活</em>作为输出。图 7 是我们想要创建的架构的可视化。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/8f2f0021b8a81a61b7c2902356b731ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IltZljtHO2W_qlfehwQATQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image 7 : Visualization of our architecture</figcaption></figure><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="9e9c" class="oi mr iq oe b gy oj ok l ol om"><br/>model = Sequential()<br/>e = Embedding(vocab_size,100 ,input_length=max_length-1, trainable=True)<br/>model.add(e)<br/>model.add(keras.layers.BatchNormalization())<br/>model.add(keras.layers.Bidirectional(keras.layers.CuDNNLSTM(100)))<br/>model.add(keras.layers.BatchNormalization())</span><span id="815b" class="oi mr iq oe b gy oq ok l ol om">model.add(Dense(100, activation='relu'))<br/>model.add(keras.layers.BatchNormalization())</span><span id="2535" class="oi mr iq oe b gy oq ok l ol om">model.add(Dense(vocab_size+1, activation='softmax')) <br/># vocab_size +1 to avoid out of bound<br/># compile the model<br/>model.compile(optimizer='adam', loss='categorical_crossentropy')</span></pre><p id="6851" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将使用具有所述超参数的模型。当然，你可以调整我们模型的超参数。为了简单起见，我们将只使用一个双 LSTM 和一个密集层。我们使用批处理标准化来加速我们的学习者。如果用 GPU，就要用 CuDNNLSTM 来加快训练速度。</p><p id="0a06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用亚当优化，因为它是一个流行的优化现在。该算法速度快，能很好地适应反向传播模型的学习速度。</p><h1 id="3512" class="mq mr iq bd ms mt pm mv mw mx pn mz na jw po jx nc jz pp ka ne kc pq kd ng nh bi translated">火车模型</h1><p id="a2a1" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">在我们调整或训练我们的模型之前。我们有一个问题要解决。如果我们看到我们的 vocab_size，它有大约 45000 个独特的单词。在 keras 中，我们应该将火车标签编码成一个热编码[0 0 0 … 1 … 0]。如果我们将我们所有训练标签改变成一个热编码，这将导致<strong class="ky ir">内存错误</strong>(它需要 45.000 * 2 兆* 4 字节内存。不可能保存到内存中)。因此，我们需要将我们的火车标签批量更改为一个热编码。</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="5c7d" class="oi mr iq oe b gy oj ok l ol om">def batch_data(start,end):<br/>    global X,y,y_input, X_input<br/>    X_input = np.array(X)[start:end]<br/>    y_input = np.array(y)[start:end]<br/>    y_input = keras.utils.to_categorical(y_input,vocab_size+1)</span><span id="9695" class="oi mr iq oe b gy oq ok l ol om">max_epoch = 40<br/>instance_max = len(X)<br/>batch_size = 10000</span><span id="6059" class="oi mr iq oe b gy oq ok l ol om">for i in range(max_epoch):<br/>    start_idx_counter = 0<br/>    while start_idx_counter &lt; instance_max:<br/>        batch_data(start_idx_counter, min(start_idx_counter+batch_size,instance_max))<br/>        model.fit(X_input, y_input, epochs=1, batch_size=64) <br/>        start_idx_counter += batch_size</span></pre><p id="341d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将 10000 定义为我们的批量。你可以随意增减尺寸。我们用 40 个时期(迭代)来拟合我们的模型。执行代码！fit 方法中的 batch_size 也可以调整。</p><blockquote class="pr"><p id="1f31" class="ps pt iq bd pu pv pw px py pz qa lr dk translated">等着吧！！</p></blockquote><figure class="qc qd qe qf qg kk gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/5ddaf9eab1686ad32d5ebb175f23a00a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*AOB79BeiNAD6xvR9.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">source: me.me</figcaption></figure><p id="0bf0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用 GPU 训练我的模型花了 1 天。如果你不想等那么久，减小<code class="fe on oo op oe b">max_epoch</code>。</p><p id="d2f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成了吗？不要忘记保存模型和记号赋予器。你想再等一天来训练我们的模特吗？没有吗？<strong class="ky ir">不要忘记保存模型！</strong></p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="ee21" class="oi mr iq oe b gy oj ok l ol om">model.save('lyric_gen_model.h5')</span></pre><p id="0cd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用<code class="fe on oo op oe b">pickle </code>库来保存我们的标记器</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="7b17" class="oi mr iq oe b gy oj ok l ol om">import pickle<br/>pickle.dump( pre, open( "tokenizer_pre_lyric.p", "wb" ) )</span></pre><p id="db27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们完了。让我们创作我们的歌词吧！！！</p><h1 id="ceae" class="mq mr iq bd ms mt pm mv mw mx pn mz na jw po jx nc jz pp ka ne kc pq kd ng nh bi translated">生成歌词</h1><p id="93ab" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">让我们使用我们的模型来生成歌词。我们已经训练了我们的模型，我们将使用它。为此，我们需要加载我们的模型和标记器。</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="9aba" class="oi mr iq oe b gy oj ok l ol om">model = keras.models.load_model('lyric_gen_model.h5')<br/>pre = pickle.load( open( "tokenizer_pre_lyric.p", "rb" ) )</span></pre><p id="b566" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们需要首先预处理我们的输入。</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="92fe" class="oi mr iq oe b gy oj ok l ol om">def preprocess_predict(X):<br/>    X = pre.texts_to_sequences(X)<br/>    return X</span></pre><p id="bdce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的文章中，我们在歌词的开头插入了“<start>”符号。我们这样做是为了标志这首歌歌词的开始。如果我们想在没有任何起始词的情况下生成。我们可以这样做:</start></p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="6258" class="oi mr iq oe b gy oj ok l ol om">seed = "&lt;start&gt; " * (max_length-1)</span></pre><p id="c702" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，您也可以包含一些起始单词。</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="b88f" class="oi mr iq oe b gy oj ok l ol om">seed = "&lt;start&gt; " * (max_length-3)<br/>seed = "&lt;div&gt; love"</span></pre><p id="8fed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们应该定义函数来帮助我们生成歌词</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="9c88" class="oi mr iq oe b gy oj ok l ol om">def is_word_in_dict(words, word_idx):<br/>    for word in words.split():<br/>        if word not in word_idx:<br/>            return False<br/>    return True</span><span id="a2ef" class="oi mr iq oe b gy oq ok l ol om">def generate_song_by_model(model, idx_word, X_sent, word_idx, total_classes, word_generated=80):<br/>    string_returned = X_sent<br/>    if is_word_in_dict(X_sent, word_idx):<br/>        X = np.array(preprocess_predict([X_sent]))<br/>        counter = 1<br/><br/> <br/>        for i in range(word_generated):<br/>           y_pred = model.predict(X)<br/>           rnd_choice = np.random.choice(range(0,total_classes),size=1,replace=False, p=y_pred[0])<br/>           word_predict = idx_word[rnd_choice[0]]<br/>           string_returned += " " + word_predict<br/>           X = ' '.join(string_returned.split()[counter:])<br/>           X = np.array(preprocess_predict([X]))<br/>           counter += 1</span><span id="8065" class="oi mr iq oe b gy oq ok l ol om">  return string_returned</span></pre><p id="e48e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个函数中，我们将根据我们的种子(generate 函数中的<strong class="ky ir"> X_sent </strong>变量)来预测单词。我们将窗口大小长度为 1 的标记作为我们的模型的输入，并且该模型将预测下一个标记。在下一个循环中，它将把预测的输出和 size-length-2 标记带入模型。它会一直循环到我们设定的终点。我们将根据 softmax 的输出产生的概率分布得到一个随机单词。如果您正在使用 Jupyter Notebook，使用此命令显示生成的歌词</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="f4a2" class="oi mr iq oe b gy oj ok l ol om">from IPython.display import HTML<br/>generated_lyric = generate_song_by_model(model, pre.index_word, seed, max_length, pre.word_index, vocab_size+1,loop_count=50)<br/>HTML(generated_lyric)</span></pre><p id="45fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它将生成 50 个新的令牌/单词(包括标签)。生成的歌词应该有 HTML 标签<div>和<br/>，作为行和诗的分隔符。我们使用 IPython.display 中的 HTML 函数来清理显示中的标签。这里有一些我们生成的歌词的例子。</div></p><blockquote class="md me mf"><p id="a484" class="kw kx mb ky b kz la jr lb lc ld ju le mg lg lh li mh lk ll lm mi lo lp lq lr ij bi translated">我试着带你回家</p><p id="1d27" class="kw kx mb ky b kz la jr lb lc ld ju le mg lg lh li mh lk ll lm mi lo lp lq lr ij bi translated">我是救世主之光</p><p id="5303" class="kw kx mb ky b kz la jr lb lc ld ju le mg lg lh li mh lk ll lm mi lo lp lq lr ij bi translated">总有一天沙漠会飞走</p><p id="50c3" class="kw kx mb ky b kz la jr lb lc ld ju le mg lg lh li mh lk ll lm mi lo lp lq lr ij bi translated">谁俯视着我的双手</p><p id="8c19" class="kw kx mb ky b kz la jr lb lc ld ju le mg lg lh li mh lk ll lm mi lo lp lq lr ij bi translated">如果我做得不好</p><p id="053b" class="kw kx mb ky b kz la jr lb lc ld ju le mg lg lh li mh lk ll lm mi lo lp lq lr ij bi translated">你开始想办法</p></blockquote><p id="c5fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个生成的歌词里。使用英语单词非常一致。虽然有些令人困惑的意思，但还不错。我们的结果是基于随机性的。如果你的模型学得少，它会产生糟糕的歌词！</p><p id="24a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想知道为什么它会产生英语单词，有时印尼歌曲包含混合语言。有些歌曲包含完整的英文单词。</p><p id="f379" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是另一个生成的歌词。</p><blockquote class="md me mf"><p id="48e8" class="kw kx mb ky b kz la jr lb lc ld ju le mg lg lh li mh lk ll lm mi lo lp lq lr ij bi translated">dara kau bertanya siapa namamu</p><p id="f365" class="kw kx mb ky b kz la jr lb lc ld ju le mg lg lh li mh lk ll lm mi lo lp lq lr ij bi translated">杨森永坦吉斯穆</p><p id="2a66" class="kw kx mb ky b kz la jr lb lc ld ju le mg lg lh li mh lk ll lm mi lo lp lq lr ij bi translated">pasti pahit di ayahku</p><p id="4908" class="kw kx mb ky b kz la jr lb lc ld ju le mg lg lh li mh lk ll lm mi lo lp lq lr ij bi translated">帕达·贝尔穆拉·迪潘当·卢卡</p><p id="a78a" class="kw kx mb ky b kz la jr lb lc ld ju le mg lg lh li mh lk ll lm mi lo lp lq lr ij bi translated">dan semua karena cintamu</p><p id="27eb" class="kw kx mb ky b kz la jr lb lc ld ju le mg lg lh li mh lk ll lm mi lo lp lq lr ij bi translated">这是我第一次见到你。</p><p id="ebc2" class="kw kx mb ky b kz la jr lb lc ld ju le mg lg lh li mh lk ll lm mi lo lp lq lr ij bi translated">ku tak ingin sendiri</p></blockquote><p id="dbf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想知道歌词的意思就翻译一下。关于用印尼语和谈情说爱也很一致。同样，它的随机性将决定歌词的好坏。</p><h1 id="6a6e" class="mq mr iq bd ms mt pm mv mw mx pn mz na jw po jx nc jz pp ka ne kc pq kd ng nh bi translated">结论</h1><p id="fbd9" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">如果你关注这篇文章，我们已经建立了一个工具来生成印度尼西亚歌词。我们利用网络爬虫和深度学习库来构建生成器。它可以产生一些好的歌词，虽然这取决于我们的运气(随机性对概率)。</p><p id="932d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们跳过了一些步骤，如探索性分析。我们应该尝试另一种架构或超参数。我们还需要评估生成的歌词。</p><h1 id="7fb2" class="mq mr iq bd ms mt pm mv mw mx pn mz na jw po jx nc jz pp ka ne kc pq kd ng nh bi translated">编后记</h1><p id="dd26" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">感谢您阅读我的第一篇关于人工智能的文章。由于这是我的第一次，我在这方面还不太专业，我需要一些建设性的反馈，让我在写作和深度学习方面做得更好。请手下留情&gt; _ </p><p id="6e93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">抱歉任何拼写错误，语法，和低效的代码。</p><p id="d8f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哦，我提到第一部分了吗？是的，我计划通过使架构更复杂(可能使用 GAN)，使用另一种嵌入和超参数来改进这个歌词生成器。</p><p id="7051" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一篇文章中，我将从一个将从头开发的游戏中进行一些强化学习。</p><p id="e671" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一篇文章再见！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/995868f00c9205e6fa399f3cf0d14c5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6v_zarr34kQOm_TQ.jpg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: pixabay.com</figcaption></figure></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h1 id="6fce" class="mq mr iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">来源</h1><ol class=""><li id="361e" class="no np iq ky b kz ni lc nj lf qh lj qi ln qj lr nt nu nv nw bi translated"><a class="ae kv" href="https://www.upwork.com/hiring/for-clients/web-scraping-tutorial/" rel="noopener ugc nofollow" target="_blank">https://www . up work . com/hiring/for-clients/web-scraping-tutorial/</a></li><li id="d411" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">https://colah.github.io/posts/2015-08-Understanding-LSTMs/<a class="ae kv" href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/" rel="noopener ugc nofollow" target="_blank"/></li><li id="69dc" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><a class="ae kv" href="https://machinelearningmastery.com/what-are-word-embeddings/" rel="noopener ugc nofollow" target="_blank">https://machine learning mastery . com/what-are-word-embedding/</a></li><li id="9e50" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><a class="ae kv" href="https://medium.com/deeper-learning/glossary-of-deep-learning-batch-normalisation-8266dcd2fa82" rel="noopener">https://medium . com/deep-learning/glossary-of-deep-learning-batch-normalization-8266 dcd2fa 82</a></li><li id="60ef" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/activation-functions-neural-networks-1cbd9f8d91d6">https://towards data science . com/activation-functions-neural-networks-1 CBD 9 F8 d 91d 6</a></li></ol></div></div>    
</body>
</html>