<html>
<head>
<title>Geospatial Operations at Scale with Dask and Geopandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Dask和Geopandas进行大规模地理空间操作</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/geospatial-operations-at-scale-with-dask-and-geopandas-4d92d00eb7e8?source=collection_archive---------1-----------------------#2017-06-02">https://towardsdatascience.com/geospatial-operations-at-scale-with-dask-and-geopandas-4d92d00eb7e8?source=collection_archive---------1-----------------------#2017-06-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6c80606a82acb5b238062b094a026f4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HevTonUoRkTNolFPO2P8Kw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">May 2016 New York City Taxi Dropoffs Heatmap by Taxi Zone.</figcaption></figure><p id="dc5c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在本文中，我将给出一个空间连接的示例，然后描述如何使用GeoPandas和Dask执行大规模的空间连接。</p><p id="a59b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注意:</strong>为了精简这篇文章，我删除了交互式图形和大部分代码。你可以在<a class="ae la" href="https://nbviewer.jupyter.org/github/r-shekhar/NYC-transport/blob/master/15_dataframe_analysis/spatialjoin_geopandas_dask.ipynb" rel="noopener ugc nofollow" target="_blank"> nbviewer </a>上查看Jupyter的原始笔记本。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="221f" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">第1部分:对空间连接的简单介绍</h1><p id="7063" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">我在分析纽约市<a class="ae la" href="http://www.nyc.gov/html/tlc/html/about/trip_record_data.shtml" rel="noopener ugc nofollow" target="_blank">出租车数据集</a>时遇到的一个问题是，从2009年到2016年6月，出租车行程的起点和终点都是以经度和纬度点的形式给出的。2016年7月之后，为了在向公众发布数据时提供一定程度的匿名性，出租车和豪华轿车委员会(TLC)只提供一次旅行的开始和结束“出租车区域”，以及一个指定边界的shapefile，<a class="ae la" href="https://s3.amazonaws.com/nyc-tlc/misc/taxi_zones.zip" rel="noopener ugc nofollow" target="_blank">可在此处获得</a>。为了获得连续的数据集，我需要一种有效的方法将经纬度坐标对转换成“出租车区域”。让我们在Geopandas中加载shapefile，将坐标系设置为' epsg:4326 '，这是经纬度坐标。以下是前几行。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/0834fe2fdb836bd85ec4b5c4aa7e0d7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*atP7w3nAkXhw33A-h4VTAA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The first few rows of the dataset.</figcaption></figure><p id="c6b1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们看到几何列由多边形(来自Shapely)组成，这些多边形的顶点由经度和纬度点定义。让我们按照LocationID的升序来绘图。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/f51e3d38bf31de95f8f3d9498365886f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BdZRit7riVo50WiQ3nTTNQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Taxi Zones chloropleth colored by taxi zone ID</figcaption></figure><p id="196d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是一张熟悉的纽约地图，显示了262个出租车区域，用出租车区域的id进行着色。我发现LocationID没有任何特定的地理顺序。我在洋红色加了一个随机点(-73.966 \u E，40.78˚ N)，正好落在中央公园中间。分配一个点在滑行区域内是人类可以很容易做到的事情，但在计算机上，这需要解决多边形问题中的<a class="ae la" href="https://en.wikipedia.org/wiki/Point_in_polygon" rel="noopener ugc nofollow" target="_blank">点。幸运的是，</a><a class="ae la" href="http://toblerity.org/shapely/project.html" rel="noopener ugc nofollow" target="_blank"> Shapely </a>库为Python中的这种几何运算提供了一个简单的接口。但是，多边形中的点在计算上是昂贵的，并且使用24亿(纬度，经度)对上的Shapely库来分配出租车区域，就像在纽约出租车数据集中一样，将花费现代单核cpu大约四年的时间。为了加快速度，我们计算每个滑行区域的边界框，如下所示:</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/4e3de75dca4b163deaade2ee80b701dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B1hpDbJLYh_dk7w4W-8XBA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Bounding boxes for each Taxi Zone</figcaption></figure><p id="72ed" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，给定一个(经度，纬度)坐标对，包含该坐标对的边界框可以用一个<a class="ae la" href="https://en.wikipedia.org/wiki/R-tree" rel="noopener ugc nofollow" target="_blank"> R树</a>有效地计算出来。你可以在这里找到关于R树<a class="ae la" href="https://medium.com/@agafonkin/a-dive-into-spatial-search-algorithms-ebd0c5e39d2a" rel="noopener">的精彩介绍</a>。只需要检查具有包含坐标对的边界框的多边形(滑行区域),然后为这几个滑行区域(希望如此)求解多边形中的点。这将计算量减少了大约100-1000倍。将坐标对分配给滑行区域的过程就是空间连接的一个例子。<a class="ae la" href="http://geopandas.org/" rel="noopener ugc nofollow" target="_blank"> Geopandas </a>为Python中的高效空间连接提供了一个很好的接口，它负责为您计算边界框和R树，如执行左空间连接的代码片段所示。</p><pre class="mm mn mo mp gt ms mt mu mv aw mw bi"><span id="2b04" class="mx lj iq mt b gy my mz l na nb">import geopandas as gpd<br/>from shapely.geometry import Point</span><span id="7143" class="mx lj iq mt b gy nc mz l na nb">df = gpd.read_file('taxi_zones.shp').to_crs({'init': 'epsg:4326'})<br/>df = df.drop(['Shape_Area', 'Shape_Leng', 'OBJECTID'], axis=1)</span><span id="6cf9" class="mx lj iq mt b gy nc mz l na nb">gpd.sjoin(gpd.GeoDataFrame(crs={'init': 'epsg:4326'},<br/>    geometry=[Point(-73.966, 40.78)]), <br/>    df, how='left', op='within')</span></pre><p id="ef5a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此代码对上面地图上的单个点(用洋红色绘制)进行合并，并在中央公园正确地识别它</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/67cc88e5d4aa81c68be1acb34add7df5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rFrCuaGEU5m-iwXhlOc2qQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The spatial join for the magenta point in the figures above</figcaption></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="735c" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">第2部分:使用Dask进行大规模空间连接</h1><p id="8dd9" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">在我的纽约公交项目中，我下载并处理了整个200GB的出租车数据集。在这里，我从taxi数据集(2016年5月)加载一个文件到Dask，并显示前几行和几列。该文件1.8GB有点大，Dask选择将数据帧划分为30个分区，以提高计算效率。每个分区都是一个pandas数据帧，dask负责所有的逻辑，将组合视为一个单独的数据帧。这里有几个栏目。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/1c2b822382eb67fc556491704ac471eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w6VopY3A-k_ExBL58zGhvw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The first few rows of time and location data in May 2016</figcaption></figure><p id="cd53" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以每次旅行都有接送(经度，纬度)坐标对。为了让您对数据有个感觉，我画出了第一次旅行的起点和终点，终点在东村。驾驶方向带来了很多额外的复杂性，所以这里我只画了一个直线箭头。空间连接将出租车区域标识为克林顿东和东村。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8abdbc9a3b3a60c065b790c0f0dc3ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SuHsA_vh-ejwVXwXcbywuQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The first trip in May 2016 — As the crow flies</figcaption></figure><p id="355f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以，Dask数据帧<a class="ae la" href="http://dask.pydata.org/en/latest/dataframe-overview.html" rel="noopener ugc nofollow" target="_blank">只是熊猫数据帧</a>的集合，我知道如何在熊猫数据帧上执行空间连接。让我们利用Dask的<code class="fe nf ng nh mt b"><a class="ae la" href="http://dask.pydata.org/en/latest/dataframe-api.html#dask.dataframe.DataFrame.map_partitions" rel="noopener ugc nofollow" target="_blank">map_partitions</a></code>函数对每个分区上的滑行区域进行空间连接。下面是执行空间连接的函数，给定一个Pandas数据帧，以及经度、纬度和taxizone id列的名称。代码直接链接到<a class="ae la" href="https://gist.github.com/r-shekhar/7625fd524e9639933371da5560b6dccc" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="b0b2" class="mx lj iq bd lk nk nl dn lo nm nn dp ls kn no np lw kr nq nr ma kv ns nt me nu bi translated">按比例</h2><p id="0502" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">使用<code class="fe nf ng nh mt b">map_partitions</code>函数，我将空间连接应用于组成Dask数据帧的每个熊猫数据帧。为了简单起见，我只调用该函数两次，一次用于取货地点，一次用于卸货地点。为了帮助dask确定返回数据的模式，我们将它指定为一列浮点数(允许NaN值)。</p><pre class="mm mn mo mp gt ms mt mu mv aw mw bi"><span id="7ba5" class="mx lj iq mt b gy my mz l na nb">trips['pickup_taxizone_id'] = trips.map_partitions(<br/>    assign_taxi_zones, "pickup_longitude", "pickup_latitude",<br/>    "pickup_taxizone_id", meta=('pickup_taxizone_id', np.float64))<br/>trips['dropoff_taxizone_id'] = trips.map_partitions(<br/>    assign_taxi_zones, "dropoff_longitude", "dropoff_latitude",<br/>    "dropoff_taxizone_id", meta=('dropoff_taxizone_id', np.float64))<br/>trips[['pickup_taxizone_id', 'dropoff_taxizone_id']].head()</span></pre><p id="6c9b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此时，trips Dask数据帧将具有有效的taxizone_id信息。让我们将这些数据保存到<a class="ae la" href="https://parquet.apache.org/" rel="noopener ugc nofollow" target="_blank"> Parquet </a>中，这是一种<a class="ae la" href="https://en.wikipedia.org/wiki/Column-oriented_DBMS" rel="noopener ugc nofollow" target="_blank">列格式</a>，在Dask和Apache Spark中得到很好的支持。这可以防止Dask在每次需要对trips数据帧进行操作时重新计算空间连接(这是非常昂贵的)。</p><pre class="mm mn mo mp gt ms mt mu mv aw mw bi"><span id="caf4" class="mx lj iq mt b gy my mz l na nb">trips.to_parquet('trips_2016-05.parquet', has_nulls=True,<br/>     object_encoding='json', compression="SNAPPY")<br/>trips = dd.read_parquet('trips_2016-05.parquet',<br/>    columns=['pickup_taxizone_id', 'dropoff_taxizone_id'])</span></pre><p id="641c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了结束这篇文章，我将使用Dask生成一个出租车下车地点的热图，按出租车区域进行汇总。不出所料(至少对纽约人来说)，绝大多数出租车停靠点都在曼哈顿的市中心和中城区。我将在以后的文章中进一步分析这个数据集。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6c80606a82acb5b238062b094a026f4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HevTonUoRkTNolFPO2P8Kw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">May 2016 New York City Taxi Dropoffs by Taxi Zone.</figcaption></figure><h1 id="2a9c" class="li lj iq bd lk ll nv ln lo lp nw lr ls lt nx lv lw lx ny lz ma mb nz md me mf bi translated">摘要</h1><p id="55c4" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">在这篇文章中，我描述了空间连接的过程，并使用Dask和Pandas在集群上进行大规模的空间连接。我忽略了对整个纽约出租车数据集<a class="ae la" href="http://www.nyc.gov/html/tlc/html/about/trip_record_data.shtml" rel="noopener ugc nofollow" target="_blank">很重要的一些细节</a>，但是我的完整代码可以在Github 上的<a class="ae la" href="https://github.com/r-shekhar/NYC-transport" rel="noopener ugc nofollow" target="_blank">这里找到。在以后的文章中，我将更彻底地分析这些数据，并可能将处理后的数据作为一个parquet文件发布，供其他人分析。</a></p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h2 id="e945" class="mx lj iq bd lk nk nl dn lo nm nn dp ls kn no np lw kr nq nr ma kv ns nt me nu bi translated">关于空间连接性能的补充说明</h2><p id="99d1" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">上面使用GeoPandas编写的空间连接使用纽约出租车数据集，可以在4 GHz 4核i5系统上为每小时大约4000万次出租车行程分配出租车区域。许多支持这种连接的代码是Python和包装C代码的某种融合。</p><p id="68f0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这比在高度优化的<a class="ae la" href="http://www.postgis.net/" rel="noopener ugc nofollow" target="_blank"> PostGIS </a> C/C++代码中执行相同的空间连接大约慢两倍。然而，PostGIS并没有有效地使用多个内核(至少在没有多个空间连接同时运行的情况下)，更重要的是，往返PostgreSQL数据库的网络和序列化开销使PostgreSQL/PostGIS的速度与我在本文中描述的GeoPandas实现的速度大致相同，需要打破的移动部分要多得多。</p><p id="d4a3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">基本上，对于这些类型的数据结构操作，Python实际上是相当快的T2 T3。</p></div></div>    
</body>
</html>