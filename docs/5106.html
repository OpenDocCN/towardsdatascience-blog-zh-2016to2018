<html>
<head>
<title>Extracting ML-Features from Graph Data with DeepGL on Neo4j</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 DeepGL 在 Neo4j 上提取图形数据的 ML 特征</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deepgl-on-neo4j-b27e8c64190f?source=collection_archive---------12-----------------------#2018-09-27">https://towardsdatascience.com/deepgl-on-neo4j-b27e8c64190f?source=collection_archive---------12-----------------------#2018-09-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="44ab" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">图的深度特征学习</h1><p id="3cef" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">2013 年，托马斯·米科洛夫和他的谷歌同事发布了一篇描述<a class="ae lj" href="https://arxiv.org/pdf/1301.3781.pdf" rel="noopener ugc nofollow" target="_blank"> word2vec </a>的论文，并推广了生成嵌入来表示数据片段的想法。</p><h1 id="a334" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">什么是嵌入？</h1><p id="58a8" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">嵌入是一个数组或数字向量，用来表示某种东西，在 word2vec 中是一个单词。</p><p id="244f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">Adrian Colyer 有一个很好的图表，展示了一个词汇的非常简单的 hot 编码表示(下面有一个元素“hot”):</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/b4199519edc631cb8225bacdd65b7813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*TQ-JN_mjuCUpOC2yRZfe6Q.png"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">One hot encoding of a vocabulary of words</figcaption></figure><p id="eb30" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在这个例子中，每个单词有一列，一个单词的向量在适当的列中为 1，在其他地方为 0。</p><p id="c65a" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">使用这种简单的表示，我们实际上无法在我们的嵌入之间进行任何有意义的比较，但是 word2vec 比这更进一步，它为每个单词提供了一种表示，这是这些元素之间的权重分布。</p><p id="dca0" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">例如，我们可能会以这样的单词表示法结束:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mb"><img src="../Images/031829d80c11ebe3469ab94a6e81ee4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*pYCug-vbu5URYM1kp57MQw.png"/></div></div></figure><p id="b643" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">自从 word2vec 发布以来，其他人已经使用类似的方法为单词之外的东西提供了嵌入。Pinterest 创建了<a class="ae lj" href="https://medium.com/the-graph/applying-deep-learning-to-related-pins-a6fee3c92f5e" rel="noopener"> pin2vec </a>，用于向用户推荐 pin，Airbnb 使用嵌入功能<a class="ae lj" href="https://medium.com/airbnb-engineering/listing-embeddings-for-similar-listing-recommendations-and-real-time-personalization-in-search-601172f7603e" rel="noopener">寻找相似的房产列表</a>。</p><h1 id="887f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">我们如何处理这些嵌入？</h1><p id="1438" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">嵌入可以被认为是<a class="ae lj" href="https://en.wikipedia.org/wiki/Feature_learning" rel="noopener ugc nofollow" target="_blank">表征学习</a>的一种实现，在这种情况下，我们会自动提出一些特征来输入我们的机器学习模型，而不是手动创建它们。</p><p id="85dd" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">例如，这些算法的输出可以用作张量流模型的<em class="mg">输入。</em></p><p id="72e7" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们还可以<em class="mg">使用图形算法库 3.4.7.0 版本中引入的<a class="ae lj" href="https://neo4j.com/docs/graph-algorithms/current/algorithms/similarity-cosine/" rel="noopener ugc nofollow" target="_blank">余弦相似性过程</a>从嵌入中构建一个 kNN 相似性图</em>。</p><p id="c8b2" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">然后，可以使用相似性图作为 k-最近邻查询的一部分来进行推荐。</p><h1 id="c1fc" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">图形嵌入</h1><p id="5eaa" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有几种算法可以用来生成图嵌入。这些是我们知道的:</p><ul class=""><li id="0827" class="mh mi iq kn b ko lk ks ll kw mj la mk le ml li mm mn mo mp bi translated"><a class="ae lj" href="https://snap.stanford.edu/node2vec/" rel="noopener ugc nofollow" target="_blank">节点 2Vec </a></li><li id="caf3" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated"><a class="ae lj" href="https://arxiv.org/abs/1704.03165" rel="noopener ugc nofollow" target="_blank"> struc2vec:从结构同一性中学习节点表示</a></li><li id="90e9" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated"><a class="ae lj" href="https://arxiv.org/abs/1403.6652" rel="noopener ugc nofollow" target="_blank">DeepWalk——在线学习社交表征</a></li></ul><p id="7b98" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这个想法和单词嵌入算法是一样的。我们希望为图中的每个实体(通常是节点)确定一个向量表示，然后将这些表示输入到机器学习算法中。</p><p id="fe8c" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">列表中最近增加了一个由 Ryan A. Rossi、Rong Zhou 和 Nesreen K. Ahmed 创建的<a class="ae lj" href="https://arxiv.org/abs/1704.08829" rel="noopener ugc nofollow" target="_blank">图形深度特征学习</a> (DeepGL)。</p><p id="1c4a" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这个对我们来说非常有趣，因为它是专门设计来保持低内存使用率的，并且还返回它提出的功能的名称，这在机器学习模型可解释性和功能提取的这些天很有帮助。另一个很好的特性是，它允许你将数字节点属性传递给算法，而其他的<em class="mg">只有</em>依赖于图形结构。</p><h1 id="bfeb" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">DeepGL 是如何工作的？</h1><h2 id="3af8" class="mv jo iq bd jp mw mx dn jt my mz dp jx kw na nb kb la nc nd kf le ne nf kj ng bi translated">提供初始功能</h2><p id="0b39" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们首先为每个节点构建一组基本特征:入度、出度和两个度。我们还可以选择包含节点的任何其他数字属性(或投影)。</p><p id="6868" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这篇论文描述了更多可以通过本地 graphlet 分解生成的基本特性，但是我们还没有实现。</p><p id="aa37" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">对于一个包含 4 个节点的非常简单的图形，这些基本特征可能如下所示:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nh"><img src="../Images/30317d8cd4c257a74a186cb30c0f2d59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ToIXKt76pE-5mCLcL9w_GQ.png"/></div></div></figure><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="9902" class="mv jo iq bd jp mw mx dn jt my mz dp jx kw na nb kb la nc nd kf le ne nf kj ng bi translated">Bin 值</h2><p id="6381" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然后我们对这些值按列应用<a class="ae lj" href="https://en.wikipedia.org/wiki/Data_binning" rel="noopener ugc nofollow" target="_blank">对数宁滨</a>。这导致以下嵌入:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="b01f" class="mv jo iq bd jp mw mx dn jt my mz dp jx kw na nb kb la nc nd kf le ne nf kj ng bi translated">对每个邻域的要素应用运算符</h2><p id="0f9a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">接下来，我们对每个节点的(入、出、整体)邻域的这组特征应用一组操作符。我们应用的运算符有</p><ul class=""><li id="ad01" class="mh mi iq kn b ko lk ks ll kw mj la mk le ml li mm mn mo mp bi translated">哈达玛，</li><li id="f170" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">意思是，</li><li id="dcb7" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">总和，</li><li id="7eb7" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">最大值，</li><li id="ffd6" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">L1·诺姆，</li><li id="1bc1" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">和径向基函数。</li></ul><p id="ea47" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这意味着，比方说，对于<strong class="kn ir"> sum </strong>运算符，我们将为每个节点创建 9 个新列:</p><ul class=""><li id="b201" class="mh mi iq kn b ko lk ks ll kw mj la mk le ml li mm mn mo mp bi translated">在邻域中我们<strong class="kn ir">的入度之和</strong></li><li id="2f7e" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">我们的<strong class="kn ir">在</strong>邻域的外向度之和</li><li id="18bf" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">我们的<strong class="kn ir">在</strong>邻域中的双度之和</li><li id="8eb6" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">我们的<strong class="kn ir">出</strong>邻域的入度之和</li><li id="62ad" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">我们的<strong class="kn ir"> out </strong>邻域的 out 度之和</li><li id="f12b" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">我们<strong class="kn ir">外</strong>邻区的双度之和</li><li id="b8be" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">我们<strong class="kn ir">整个</strong>邻居的入度之和</li><li id="7339" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">我们<strong class="kn ir">整个</strong>邻居的外向度之和</li><li id="83a1" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">我们的<strong class="kn ir">整体</strong>邻域的双度之和</li></ul><p id="3d61" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">让我们看看，如果我们将<strong class="kn ir">和</strong>运算符应用于邻域中的<strong class="kn ir">，会发生什么。我们以 3 个额外的列结束，汇总了每个节点的邻居对于<em class="mg">入度</em>、<em class="mg">出度</em>和<em class="mg">双度</em>的得分。</strong></p><p id="00ae" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们得到的一组特征如下所示:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="0d98" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们为我们的其他邻域以及所有其他操作符计算相同的值，这给我们一个 57 列 4 行的矩阵<strong class="kn ir">。</strong></p><h2 id="5c4e" class="mv jo iq bd jp mw mx dn jt my mz dp jx kw na nb kb la nc nd kf le ne nf kj ng bi translated">在邻居之间分配分数</h2><p id="f4ca" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然后我们应用一个<em class="mg">扩散过程</em>，其中每个节点<em class="mg">将其分数分配给其邻居</em>。我们实现这一点的方式是，每个节点为每个特征取其所有邻居的平均值。</p><p id="9a02" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">扩散过程不包括基本特征，因此在我们的示例中，我们将只扩散<em class="mg">输入求和</em>、<em class="mg">输出求和</em>和<em class="mg">输入和输出求和。</em></p><p id="3439" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们得到的一组特征如下所示:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ff74" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在我们继续下一阶段之前，我们再次应用对数宁滨，从而产生这组特征:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="60f9" class="mv jo iq bd jp mw mx dn jt my mz dp jx kw na nb kb la nc nd kf le ne nf kj ng bi translated">修剪特征</h2><p id="dc49" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这一步之后，我们应用<em class="mg">特征修剪</em>，这包括在<em class="mg">特征相似性图</em>上运行<strong class="kn ir">弱连通分量算法</strong>，然后只保留每个连通分量的一列。</p><p id="2339" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们通过对每一列中的值进行逐项比较来计算特征的相似性。如果两列中的所有值都相同，则该列的相似性得分为 1。在我们的例子中，<em class="mg">扩散入和</em>和<em class="mg">扩散入和</em>以及其他几对列就是这种情况。</p><p id="982a" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">假设剪枝λ为 0.7 以移除较低等级的关系，这是我们最终得到的特征图:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nk"><img src="../Images/8340968dd60373ee441eeaca48cda1c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hpQ2nem3AIt7JA3JRXqSog.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Our feature graph</figcaption></figure><p id="9631" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">连通分量算法将给出 3 个分量:</p><ul class=""><li id="2d57" class="mh mi iq kn b ko lk ks ll kw mj la mk le ml li mm mn mo mp bi translated"><em class="mg">累计金额</em></li><li id="f6b9" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated"><em class="mg">两者相加</em>、<em class="mg">入度</em>、<em class="mg">出度和</em></li><li id="d236" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated"><em class="mg">双学位</em>、<em class="mg">双学位</em>、<em class="mg">双学位</em>、<em class="mg">双学位</em>、<em class="mg">双学位</em></li></ul><p id="a756" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们倾向于保留早期迭代中的特性，这意味着基础特性。我们为每个组件保留一个特性，这在本例中意味着我们保留:</p><ul class=""><li id="e1fe" class="mh mi iq kn b ko lk ks ll kw mj la mk le ml li mm mn mo mp bi translated"><em class="mg">求和输入</em></li><li id="0307" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated"><em class="mg">输入度数</em></li><li id="5b34" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated"><em class="mg">双学位</em>或<em class="mg">双学位</em>(我们在这两者之间随机选择)</li></ul><h2 id="190e" class="mv jo iq bd jp mw mx dn jt my mz dp jx kw na nb kb la nc nd kf le ne nf kj ng bi translated">反复重复该过程</h2><p id="c751" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们根据需要重复这个过程。在第二次和随后的迭代中，我们将把操作符应用到上一次迭代留下的<em class="mg">特征上，而不是再次应用到基础特征上。</em></p><h2 id="ab70" class="mv jo iq bd jp mw mx dn jt my mz dp jx kw na nb kb la nc nd kf le ne nf kj ng bi translated">结果</h2><p id="9d80" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一旦算法完成，我们将为图中的每个节点获得等长的向量。</p><p id="02b0" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在我们的例子中，这些向量是:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="a6f1" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">因此，节点 0 的向量是<em class="mg">【0，0，0】</em>，节点 1 的向量是<em class="mg">【1，1，0】</em>，节点 2 的向量是<em class="mg">【2，0，2】</em>，节点 3 的向量是<em class="mg">【0，2，1】</em></p><h1 id="6a71" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">我如何使用 DeepGL？</h1><p id="0c91" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在过去的几个月里<a class="ae lj" href="https://www.linkedin.com/in/pete-meltzer-400607148/" rel="noopener ugc nofollow" target="_blank"> Pete Meltzer </a>，他作为研究助理在<a class="ae lj" href="http://braintree.com/" rel="noopener ugc nofollow" target="_blank"> BrainTree </a>工作，并且正在<a class="ae lj" href="https://www.ucl.ac.uk/" rel="noopener ugc nofollow" target="_blank"> UCL </a>攻读博士学位，我已经将这个算法作为 Neo4j 程序来实现，并且<strong class="kn ir">现在已经有了一个版本供您试用！</strong></p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/170c51fa23e736faeadd6e9f652bc664.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*2JO24JvQalbI4jZ4j18ATA.png"/></div></figure><p id="1a75" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">DeepGL 算法作为<a class="ae lj" href="https://github.com/neo4j-graph-analytics/ml-models/" rel="noopener ugc nofollow" target="_blank"> ml-models </a>库的一部分可用。你会想抓住<a class="ae lj" href="https://github.com/neo4j-graph-analytics/ml-models/releases/tag/1.0.2" rel="noopener ugc nofollow" target="_blank"> 1.0.2 版本</a>。</p><p id="a66a" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">一旦你安装了它(存储库中的指令)，你会找到两个版本的算法供你使用:</p><ul class=""><li id="2cc3" class="mh mi iq kn b ko lk ks ll kw mj la mk le ml li mm mn mo mp bi translated"><em class="mg"> embedding.deepgl </em> —这将嵌入作为每个节点上的属性进行存储</li><li id="fdce" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated"><em class="mg">embedding . deepgl . stream</em>—返回<em class="mg">节点的流，嵌入</em></li></ul><p id="031f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">当你在玩算法的时候，流式可能是有意义的，但是一旦你想在一个合适的数据集上使用它，我建议使用第一个版本。</p><p id="dec9" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这是算法的签名:</p><pre class="lq lr ls lt gt nm nn no np aw nq bi"><span id="105b" class="mv jo iq nn b gy nr ns l nt nu">CALL embedding.deepgl("NodeLabel" ,"RelationshipType", {<br/>  nodeFeatures: [string]<br/>  pruningLambda: double,<br/>  diffusions: integer, <br/>  iterations: integer,<br/>  writeProperty: string<br/>})</span></pre><ul class=""><li id="2437" class="mh mi iq kn b ko lk ks ll kw mj la mk le ml li mm mn mo mp bi translated"><em class="mg"> nodeFeatures </em> —包含一个附加属性名的数组，您希望将其用作算法基本功能的一部分(默认为[])</li><li id="21f0" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated"><em class="mg"> pruningLambda </em> —移除相似特征时算法应该有多严格。较低意味着积极修剪莫尔斯(默认为 0.7)</li><li id="61ac" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated"><em class="mg">扩散</em> —算法应该执行多少次扩散(默认为 10 秒)</li><li id="1e89" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated"><em class="mg">迭代</em> —算法应该运行多少次迭代(默认为 10 次)</li><li id="e33f" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated"><em class="mg"> writeProperty </em> —将存储嵌入数组的属性的名称(默认为“deepgl”)</li></ul><p id="0ab7" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">您还可以通过传递<em class="mg"> graph: "cypher" </em> config 参数并提供对节点 id 和关系列表的 cypher 查询来利用<a class="ae lj" href="https://neo4j.com/docs/graph-algorithms/current/introduction/#cypher-projection" rel="noopener ugc nofollow" target="_blank">图形投影</a>(视图)，而不是<em class="mg">节点标签</em>和<em class="mg">关系类型。</em></p><p id="f530" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们设置的默认值似乎在我们测试的数据集上工作得很好，但它们与论文中建议的不同，所以 YMMV。</p><h1 id="b10c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">效果如何？</h1><p id="c42e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们已经在论文中引用的 Enzyme 和 EU 网络数据集上测试了该算法，与使用其他算法创建的嵌入相比，它似乎工作得相当好。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nv"><img src="../Images/ce1f112eca9203fb75a3debc0eb02e5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RJuM_npybvnFp-NdKc0JGA.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">F1 scores of graph embeddings on various datasets</figcaption></figure><h1 id="1a02" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">后续步骤</h1><p id="bc33" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们希望这种算法是有用的，并且你能在你自己的数据集上使用它。</p><p id="12da" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">如果你对我们下一步应该做什么有任何问题或建议，请在评论中告诉我们，或者给我们发电子邮件到<a class="ae lj" href="mailto:devrel@neo4j.com" rel="noopener ugc nofollow" target="_blank">devrel@neo4j.com</a>。您也可以在我们新的<a class="ae lj" href="https://community.neo4j.com/c/integrations/ai-ml-nlp" rel="noopener ugc nofollow" target="_blank"> Neo4j 社区论坛</a>中提出任何问题。</p><p id="3c05" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">如果你想和皮特·梅尔策联系，你可以在 p.meltzer@braintree.com 的<a class="ae lj" href="mailto:p.meltzer@braintree.com" rel="noopener ugc nofollow" target="_blank">找到他。</a></p></div></div>    
</body>
</html>