<html>
<head>
<title>Different ways to iterate over rows in a Pandas Dataframe — performance comparison</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Pandas 数据框架中迭代行的不同方法——性能比较</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/different-ways-to-iterate-over-rows-in-a-pandas-dataframe-performance-comparison-dc0d5dcef8fe?source=collection_archive---------1-----------------------#2018-09-13">https://towardsdatascience.com/different-ways-to-iterate-over-rows-in-a-pandas-dataframe-performance-comparison-dc0d5dcef8fe?source=collection_archive---------1-----------------------#2018-09-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4072" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">为什么我对迭代的性能感兴趣</strong></p><p id="3430" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你是一个像我一样经常处理结构化数据集的 python 用户，你可能会出于很多原因经常使用 pandas。该软件包包含大量有用的功能，这些功能已经针对其用途和目的进行了优化(例如描述性统计、分组汇总)。大多数时候，这些功能足以满足您的需求。但是当涉及到时间序列数据时，我经常需要在我的 python 代码中遍历数据框并执行特别的滑动窗口计算。</p><p id="4485" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这让我思考——迭代熊猫数据框最省时的方式是什么？</p><p id="4be1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用这个简单的问题来比较各种迭代方法的性能:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="76b8" class="ku kv iq kq b gy kw kx l ky kz">N = 1000<br/>repeats = 100<br/>a = np.repeat(1000, N)<br/>pd_dataset = pd.DataFrame({'a': a})</span><span id="51a3" class="ku kv iq kq b gy la kx l ky kz"># Goal is compute the column b where b(i) = a(i) + 1<br/>b = a + 1</span></pre><p id="4cdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这实际上可以通过对整列应用一个操作符来快速解决，从而生成如上所示的新列。操作在这里并不重要，我们的想法是，如果列操作不可行，比较获得相同结果的替代方法。在这个练习中，我实现了 6 个备选方法，并对它们进行了比较。</p><p id="3e80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我从<a class="ae lb" href="https://medium.com/pythonhive/python-decorator-to-measure-the-execution-time-of-methods-fa04cb6bb36d" rel="noopener">这篇博文</a>中借用了 timeit 方法，通过用@ timeit 注释方法来测量每个方法的执行时间。这是我修改过的 timeit 方法——它将执行时间附加到一个作为名为<em class="lc"> log_time </em>的输入变量传入的列表中:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="9e18" class="ku kv iq kq b gy kw kx l ky kz"># Credits to <a class="ae lb" href="https://medium.com/@fahimsakri?source=post_header_lockup" rel="noopener">Fahim Sakri</a></span><span id="0b73" class="ku kv iq kq b gy la kx l ky kz">def timeit(method):<br/>    def timed(*args, **kw):<br/>        ts = time.time()<br/>        result = method(*args, **kw)<br/>        te = time.time()<br/>        kw['log_time'].append(int((te - ts) * 1000))<br/>        return result<br/>    return timed</span></pre><p id="a2ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们将 a + 1 操作封装到它自己的方法中，这样它就可以计时了。以列操作为例，下面是使用给定方法获得平均执行时间的初始代码:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="efe8" class="ku kv iq kq b gy kw kx l ky kz"><strong class="kq ir">def my_compute</strong>(x):<br/>    return x + 1<br/><br/>@timeit<br/><strong class="kq ir">def use_column</strong>(dataset, **kwargs):<em class="lc"><br/>    </em>dataset['b'] = my_compute(dataset.a)</span><span id="4942" class="ku kv iq kq b gy la kx l ky kz"><strong class="kq ir">def time_this</strong>(func, method_name):<br/>    <em class="lc">""" Execute the given function 100 times and measure the execution time for each run.<br/>        Returns a dictionary containing the statistics based on the execution times<br/>    """<br/>    </em>N = 1000<br/>    repeats = 100<br/>    a = np.repeat(1000, N)<br/>    pd_dataset = pd.DataFrame({'a': a})<br/><br/>    timing = []<br/>    for i in range(repeats):<br/>        func(pd_dataset.copy(), log_time=timing)<br/>    return {'method': method_name, 'average': np.average(timing), 'min': np.min(timing), 'max': np.max(timing)}</span><span id="ab64" class="ku kv iq kq b gy la kx l ky kz"><br/>results = pd.DataFrame()<br/>results = results.append([time_this(use_for_loop_loc,'use_for_loop_loc')])</span></pre><p id="b019" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">迭代行的方法</strong></p><p id="0715" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总之，我比较了 8 种基于现有列生成新的值列的方法(需要对整个列/值数组进行一次迭代)。这些都是在一个 python 文件中实现的。</p><p id="5658" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前两种是在 dataframe 列上应用列方式函数的方法:</p><ol class=""><li id="55c1" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk li lj lk ll bi translated"><strong class="jp ir">使用 _ 列</strong>:使用熊猫列操作</li><li id="9b73" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated"><strong class="jp ir">使用 _ 熊猫 _ 应用</strong>:使用熊猫<a class="ae lb" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.apply.html" rel="noopener ugc nofollow" target="_blank">应用</a>功能</li></ol><p id="6861" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来是在 for 循环中使用<a class="ae lb" href="https://pandas.pydata.org/pandas-docs/stable/indexing.html" rel="noopener ugc nofollow" target="_blank"> pandas 索引方法</a>访问变量的三种不同方法:</p><p id="11f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3 <strong class="jp ir">。use_for_loop_loc </strong>:使用熊猫<a class="ae lb" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.loc.html" rel="noopener ugc nofollow" target="_blank"> loc </a>功能</p><p id="e93d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.<strong class="jp ir"> use_for_loop_at: </strong>使用 pandas <a class="ae lb" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.at.html" rel="noopener ugc nofollow" target="_blank"> at </a>函数(访问单个值的函数)</p><p id="a9b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.<strong class="jp ir"> use_for_loop_iat: </strong>使用 pandas <a class="ae lb" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iat.html" rel="noopener ugc nofollow" target="_blank"> iat </a>函数(访问单个值的函数)</p><p id="94e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有其他不使用 pandas 索引的方法:</p><p id="da8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">6.<strong class="jp ir"> use_numpy_for_loop </strong>:从 column 中获取底层 numpy 数组，迭代、计算并将值作为新列赋给 dataframe</p><p id="533f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">7.<strong class="jp ir"> use_iterrows </strong>:使用 pandas <a class="ae lb" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iterrows.html" rel="noopener ugc nofollow" target="_blank"> iterrows </a>函数获取要迭代的 iterables</p><p id="7b6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">8.<strong class="jp ir"> use_zip </strong>:使用 python 内置的<a class="ae lb" href="https://docs.python.org/3.3/library/functions.html#zip" rel="noopener ugc nofollow" target="_blank"> zip </a>函数进行迭代，将结果存储在一个 numpy 数组中，然后在完成后将值作为一个新列赋给 dataframe</p><p id="081b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是每种方法的平均执行持续时间(秒)，使用不同的数据集大小(N=1000、10000、10000)重复测试:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="436c" class="ku kv iq kq b gy kw kx l ky kz">N = 1000<br/>               method  average  min  max<br/>          use_column     0.00    0    0<br/>     use_panda_apply     1.95    1    9<br/>    use_for_loop_loc   409.69  398  474<br/>     use_for_loop_at    13.01   12   14<br/>    use_for_loop_iat    13.39   13   15<br/>  use_numpy_for_loop     9.59    9   11<br/>  use_panda_iterrows    58.31   57   60<br/>             use_zip     0.02    0    1</span><span id="8369" class="ku kv iq kq b gy la kx l ky kz">N = 10000</span><span id="58d5" class="ku kv iq kq b gy la kx l ky kz">              method  average   min   max<br/>          use_column     0.06     0     1<br/>     use_panda_apply     1.01     1     2<br/>    use_for_loop_loc  4220.30  4182  4418<br/>     use_for_loop_at   127.79   126   130<br/>    use_for_loop_iat   134.03   132   138<br/>  use_numpy_for_loop    94.64    93    96<br/>  use_panda_iterrows   574.54   564   579<br/>             use_zip     3.00     3     3</span><span id="e3e0" class="ku kv iq kq b gy la kx l ky kz">N = 100000</span><span id="cda2" class="ku kv iq kq b gy la kx l ky kz">              method   average    min    max<br/>          use_column      0.43      0      1<br/>     use_panda_apply      6.01      4     10<br/>    use_for_loop_loc  54340.47  53415  55124<br/>     use_for_loop_at   1263.17   1238   1431<br/>    use_for_loop_iat   1326.79   1313   1365<br/>  use_numpy_for_loop    939.02    926    956<br/>  use_panda_iterrows   5676.55   5609   6184<br/>             use_zip     28.00     27     29</span></pre><p id="ede1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的预期和结果是正确的:</p><ul class=""><li id="1679" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk lr lj lk ll bi translated">列操作和应用都相对较快</li><li id="23bc" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk lr lj lk ll bi translated">使用 at()和 iat()选择比 loc()快</li><li id="8771" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk lr lj lk ll bi translated">在 numpy 数组上基于位置的索引比在 pandas 数据帧上基于位置的索引快</li></ul><p id="6995" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">令人惊讶的是:</p><ul class=""><li id="6138" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk lr lj lk ll bi translated">对于小数据集，zip()相对较快——对于 N &lt; 1000 的数据集，甚至比 apply()更快</li><li id="f2c3" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk lr lj lk ll bi translated">iat()和 at()索引比 loc()快 30 倍</li><li id="1edd" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk lr lj lk ll bi translated">即使使用索引进行访问，loc()也比预期慢</li></ul><p id="704d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于这些结果，从现在开始我会做些什么:</p><ul class=""><li id="776e" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk lr lj lk ll bi translated">如果我不能使用列操作或 apply()实现我想要的，我将使用 zip()代替(而不是 iterrows()！)</li><li id="d034" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk lr lj lk ll bi translated">我将避免使用 loc()来更新或访问单个值，而是使用 iat()和 at()</li><li id="0843" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk lr lj lk ll bi translated">考虑将基础值提取为 numpy 数组，然后执行处理/分析</li></ul></div></div>    
</body>
</html>