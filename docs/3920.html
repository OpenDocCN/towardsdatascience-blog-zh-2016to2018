<html>
<head>
<title>Using Machine Learning To Simulate World Cup Matches</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用机器学习来模拟世界杯比赛</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-machine-learning-to-simulate-world-cup-matches-959e24d0731?source=collection_archive---------2-----------------------#2018-07-01">https://towardsdatascience.com/using-machine-learning-to-simulate-world-cup-matches-959e24d0731?source=collection_archive---------2-----------------------#2018-07-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/0ea7f9bc578e8ec600fde7545a25209c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J3As-b35qhrtuhoT7jCuQw.jpeg"/></div></div></figure><div class=""/><p id="565d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">世界杯正在进入一个新的阶段，很少有人能够预测小组赛的结果。现在是时候进入一个更加激动人心的阶段了，世界上最伟大的人将会面对面。本文的目标是，通过 Python 使用数据科学的力量，尝试揭示这些游戏将呈现的一些统计数据。</p><p id="ce0b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本帖中，我们将:</p><ul class=""><li id="1d05" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">创建一个爬虫，从网上获取团队统计数据</li><li id="eb61" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">预处理、探索和可视化数据</li><li id="7b5a" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">下载具有匹配结果的另一种数据</li><li id="c7f5" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">组合这两个数据集并构建一个模型来预测匹配结果</li><li id="e873" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">创建一个简单的蒙特卡洛模拟，并获得 2018 年世界杯淘汰赛阶段的赢家赔率</li></ul><p id="8b21" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将要使用的一些库:</p><ul class=""><li id="e8f4" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">熊猫</li><li id="75d5" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">Numpy</li><li id="d562" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">Sklearn</li><li id="dfd6" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">Plotly</li></ul><p id="2727" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的想法是制作一个机器学习算法来预测单场比赛的获胜者，并从那里建立一个蒙特卡洛模拟，可以推断出每个淘汰赛获胜者的概率，以及随后世界冠军的概率。</p><p id="1361" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章将提供一些图表和代码，但是如果你愿意的话，可以随意跳过它，我会尽量让它更直观。</p><h1 id="f847" class="lk ll jb bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">我们的策略</h1><p id="64d4" class="pw-post-body-paragraph jy jz jb ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">大多数游戏模拟器倾向于使用一个代表团队表现的总数。在这里，我们正在尝试一种不同的方法，以一种更复杂的方式，不仅与整体，而且与其他三个价值观(进攻、防守、中路)一起工作，以避免简单地将所有特征集中到一个决定球队实力的单一因素上。</p><p id="10d3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该模型将建立在 Sklearn 库的基础上，使用 Pandas dataframes 来操作表中的数据，并 Plotly 来可视化一些有趣的功能。</p><h1 id="3f97" class="lk ll jb bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">获取数据</h1><p id="3f1c" class="pw-post-body-paragraph jy jz jb ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">因此，获取数据的第一步是制作一个小爬虫，从国际足联索引中获取信息，这是从 2004 年开始收集国际队数据的一个很好的来源。以下是表格在网站上的排列方式:</p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mo"><img src="../Images/ad11afd4f07714cf373495720a1e2ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G9iH2jMDwUh0PiV6JnsNUg.png"/></div></div></figure><p id="cdf6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用这种方式显示表格，很容易就能得到这样一个网站。为此，我使用了漂亮的 Soup 库来访问 HTML 代码，并使用 Pandas <a class="ae mn" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_html.html" rel="noopener ugc nofollow" target="_blank"> read_html </a>函数将其转换成可读的数据帧。</p><p id="3699" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我必须承认这个爬虫有点懒惰，它可能会在我们的数据集上复制一些东西。不过，不用担心，因为我们可以稍后删除那些关于熊猫的重复数据(在本文中，我还将提供一些原始数据集的链接)。</p><p id="dfd5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不会进入这个 scrapper 是如何建立的细节，但代码将留在下面，如果你想检查一下。如果你有其他兴趣，请随时联系我。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="426e" class="my ll jb mu b gy mz na l nb nc">web_address = '<a class="ae mn" href="https://www.fifaindex.com/teams/fifa%27" rel="noopener ugc nofollow" target="_blank">https://www.fifaindex.com/teams/fifa'</a></span><span id="519d" class="my ll jb mu b gy nd na l nb nc">df = pd.DataFrame()</span><span id="5e80" class="my ll jb mu b gy nd na l nb nc">for day in range(1,260,1):<br/>     for pag in range(1,30):<br/>     <br/>         source_address = web_address + '05_' + str(day) + '/' + str(pag) + '/' + '?type=1'<br/>         print('Day:', str(day))<br/>         print(pag)</span><span id="f939" class="my ll jb mu b gy nd na l nb nc">try:<br/>             soup = get_soup(source_address)<br/>             result_list =  soup.find('div', {'id': 'no-more-tables'})<br/>         except:<br/>             print('Page not found.')<br/>             break</span><span id="40f8" class="my ll jb mu b gy nd na l nb nc">date = str(soup.find('ol', {'class': 'breadcrumb'}))</span><span id="e41a" class="my ll jb mu b gy nd na l nb nc">if df.empty:<br/>             df = pd.read_html(str(result_list))[0]<br/>             df['date'] = date<br/>         else:<br/>             temp_df = pd.read_html(str(result_list))[0]<br/>             temp_df['date'] = date<br/>             df = df.append(temp_df)</span></pre><p id="3eaa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">弄乱原始数据集后，我保存了一个更干净的版本(使用<a class="ae mn" href="https://docs.python.org/3/library/pickle.html" rel="noopener ugc nofollow" target="_blank"> Pickle </a>),我们将使用这个数据集作为起点。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="5e7f" class="my ll jb mu b gy mz na l nb nc">df = read_pickle('team_stats.pickle')<br/>df.head()</span></pre><figure class="mp mq mr ms gt is gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/4c50e587a90a6081660793e0f0d401c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*d-vbmNM74Ulf3BJNDnRNuQ.png"/></div></figure><h1 id="aeec" class="lk ll jb bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">探索和可视化</h1><p id="d245" class="pw-post-body-paragraph jy jz jb ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">该表包含了 2004 年至 2018 年国际足联对多支国际球队的评分。原始数据也包括月和日，但是为了简单起见，我将每个团队的表现按年进行了平均，因此我们需要处理的数据点很少。让我们使用<a class="ae mn" href="https://plot.ly/" rel="noopener ugc nofollow" target="_blank"> Plotly </a>在散点图中查看各队每年的总得分:</p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nf"><img src="../Images/5603d7a1ed1a01a8383cddcb6868e909.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WWeg2TPe-WmaMKhHDhM1Hg.png"/></div></div></figure><p id="6e49" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Plotly 拥有令人惊叹的交互式图表，当你悬停在它上面时，它实际上可以显示信息。不过，这份报告信息量不大。让我们试着在条形图中检查每个日期表现最好的团队，看看它们在这些年中是如何变化的。下图显示了按年度排名的最佳团队以及所有团队的平均表现(如白线所示)。</p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ng"><img src="../Images/d54d8bd35bc240d5eb06f7639ae4877a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JKQcETTAwVK2UcaULKDMJg.jpeg"/></div></div></figure><p id="a272" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个很好的图表！西班牙长期以来一直处于领先地位。现在让我们打开包含国际队比赛结果信息的 CSV 文件:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="9ac7" class="my ll jb mu b gy mz na l nb nc">results = pd.read_csv('match_results.csv')<br/>results.head()</span></pre><figure class="mp mq mr ms gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nh"><img src="../Images/4b253aec67a94a0f1b8e4832782c70c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HIHJYGGjn2AVTz0QgIHEzQ.png"/></div></div></figure><p id="2277" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果数据集来自<a class="ae mn" href="https://github.com/ZenoZero/5100-project-world-cup-prediction-on-history" rel="noopener ugc nofollow" target="_blank"> github </a>，由 1872 年的足球比赛结果组成，包括球队、比分和其他一些信息。让我们清理一下，只保留对我们有用的特性。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="c0a9" class="my ll jb mu b gy mz na l nb nc">results = results.drop(['city', 'tournament', 'country'], axis=1)<br/>results.home_team = results.home_team.apply(text_norm) #lower_case<br/>results.away_team = results.away_team.apply(text_norm) #lower_case<br/>results.index = pd.DatetimeIndex(results.date).year<br/>results = results.drop('date', 1)<br/>results.head()</span></pre><figure class="mp mq mr ms gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ni"><img src="../Images/4cbe4f3bbc2cd82ef3a50a23ac788988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c1_auCtnipbP17fNbbe6mQ.png"/></div></div></figure><p id="3f17" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">三个步骤对我们利用这些数据非常重要:</p><ul class=""><li id="47db" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">首先，由于我们只有 2004 年的统计数据，我们应该去掉其他年份的数据(不幸的是)。</li><li id="278a" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">其次，我们不应该与不在我们主要数据框架内的团队合作，因为我们没有他们的评分。</li><li id="3806" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">最后，我们必须解决这种主客场球队的情况，因为对于世界杯的预测，我们将考虑所有体育场是中立的。</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="5995" class="my ll jb mu b gy mz na l nb nc">results = results.loc[2004:2017]</span><span id="917c" class="my ll jb mu b gy nd na l nb nc">df_teams = list(df.name.unique())<br/>results = results.reset_index()</span><span id="90dd" class="my ll jb mu b gy nd na l nb nc">for index, row in results.iterrows():<br/>    if row.home_team not in df_teams:<br/>        results.loc[index, 'home_team'] = None<br/>    if row.away_team not in df_teams:<br/>        results.loc[index, 'away_team'] = None<br/>        <br/>results = results.dropna()</span></pre><p id="9637" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们将团队的统计数据输入到结果数据框中。为此，我们将创建 8 个新列，代表每个团队的 4 项技能(赢家和输家)。这是我们现在得出的结论:</p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nj"><img src="../Images/4e3df386cf85c2bf3ca02b5a89aee9f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dQEsI57z_LxvvMK3EOVgYg.png"/></div></div></figure><p id="5bf0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要从<strong class="ka jc"> away_score </strong>中减去<strong class="ka jc"> home_score </strong>，这样我们就只有一个因素代表哪支球队赢了(负的或正的进球数)。请注意，我使用术语“主场”和“客场”只是因为这是原始数据集的来源，但这不会对我们的分析产生任何影响，因为我们将只研究世界杯比赛中的中立比赛。从现在开始，我将只称他们为<strong class="ka jc">团队 1 </strong>和<strong class="ka jc">团队 2 </strong>(从左到右，团队 1 总是第一个出现在我们的数据集中)。</p><p id="e2bb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，让我们将每个团队的目标数量压缩到一个单独的特性中，并创建一个 winner 列，这将是要预测的目标。如果 winner &gt; 0，表示<strong class="ka jc">队 1 </strong>胜，&lt; 0 表示<strong class="ka jc">队 2 </strong>胜。我们也将丢弃有平局的数据点，因为淘汰赛总是有赢家。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="d6eb" class="my ll jb mu b gy mz na l nb nc">results['score'] = results.home_score - results.away_score<br/>results = results.drop(['home_score', 'away_score', 'home_team', 'away_team'], 1)</span><span id="6d56" class="my ll jb mu b gy nd na l nb nc">results['winner'] = None<br/>results['winner'][results.score &gt; 0] = 1<br/>results['winner'][results.score &lt; 0] = -1<br/>results['winner'][results.score == 0] = 0</span><span id="c5f5" class="my ll jb mu b gy nd na l nb nc">results = results[results.winner != 0]</span></pre><p id="18c5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了进一步简化问题，我将“帮助”模型从数据中提取信息，提供技能之间的差异，而不是处理性能本身。例如，<strong class="ka jc">的攻击</strong> (att) <strong class="ka jc"> </strong>将会是<strong class="ka jc">队的 1 次攻击</strong>减去<strong class="ka jc">队的 2 次攻击</strong>。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="1191" class="my ll jb mu b gy mz na l nb nc">results['att'] = results['att1'] - results['att2']<br/>results['def'] = results['def1'] - results['def2']<br/>results['mid'] = results['mid1'] - results['mid2']<br/>results['ovr'] = results['ovr1'] - results['ovr2']</span><span id="5683" class="my ll jb mu b gy nd na l nb nc">to_drop = results[results.winner == 1].sample(247)<br/>results = results.drop(labels=to_drop.index, axis=0)</span></pre><p id="7d2c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是我们目前的数据:</p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nk"><img src="../Images/f2c440c0dd9cf7ac2b0962272d8f6762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jVNtbI2xv45vSrRrQy1usA.png"/></div></div></figure><p id="f89b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们检查一下<strong class="ka jc">团队</strong> 1 的<strong class="ka jc">总体</strong>和<strong class="ka jc">得分</strong>之间的相关性:</p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nl"><img src="../Images/edb1801c05a52da0c3f6779271e40cab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wGsYNqDwcTNbBUUTG8wiQQ.jpeg"/></div></div></figure><p id="4b3c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这对我们有好处。您可以看到这些特征之间的正相关，这表明我们的数据似乎是有意义的(团队的整体得分越高，我们应该期望的目标数量就越多)。</p><h1 id="0f01" class="lk ll jb bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">创建模型</h1><p id="50c0" class="pw-post-body-paragraph jy jz jb ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">为了应用机器学习，我构建了一个小函数来准备数据，删除不必要的属性，使用 Numpy 将其转换为数组格式，并将其分成<strong class="ka jc">训练</strong>和<strong class="ka jc">测试</strong>集，以便我们可以评估我们模型的精度。</p><p id="168a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我将上下文视为一个<a class="ae mn" href="https://machinelearningmastery.com/classification-versus-regression-in-machine-learning/" rel="noopener ugc nofollow" target="_blank">分类问题</a>，我们的目标是:</p><ul class=""><li id="1718" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">1: <strong class="ka jc">第一队</strong>获胜</li><li id="b8cb" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">-1: <strong class="ka jc">第二队</strong>获胜</li></ul><p id="3c37" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用的分类器算法是逻辑回归、随机森林分类器和线性支持向量分类器:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="cedd" class="my ll jb mu b gy mz na l nb nc">lr = LogisticRegression()<br/>lr.fit(x_train, y_train)</span><span id="df23" class="my ll jb mu b gy nd na l nb nc">rf = RandomForestClassifier()<br/>rf.fit(x_train, y_train)</span><span id="e796" class="my ll jb mu b gy nd na l nb nc">svc = SVC(kernel='linear')<br/>svc.fit(x_train, y_train)</span></pre><p id="50cc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是这些模型的准确度得分:</p><p id="845f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">LR → 68.4%</p><p id="5c17" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">射频→ 67.9%</p><p id="1e91" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">SVC → 70.1%</p><p id="3916" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，SVC 似乎比其他产品的性能更好，让我们分别检查一下每个类的性能:</p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nm"><img src="../Images/547fbbe614460b9c6323f1abbc889b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f9E7va-AQoEMURHHo6gJ0g.jpeg"/></div></div></figure><p id="08c9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以在<strong class="ka jc"> Team 1 上观察到多一点的准确性。这可能与这样一个事实有关，即在原始数据集中，这支球队是主队，也许它有更多的胜利，这可能以某种方式影响了模型的行为。但除此之外，这也可能是随机的，所以我继续。</strong></p><p id="aea6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的。我们有一个预测器，可以以 70%的准确率猜测哪个队会赢。足够建立一个模拟。我们走吧。</p><h1 id="00e7" class="lk ll jb bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">模拟比赛</h1><p id="3051" class="pw-post-body-paragraph jy jz jb ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">我们首先需要的是通过小组赛的世界杯球队的表现数据。我们将建立一个类似于我们前些年建立的刮刀，但现在使用的是国际足联指数中的 2018 年世界杯数据。</p><p id="3aaa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，这一数据似乎与 2018 年(非世界杯)的数据没有太大差异，因为德国仍然占据排名第二的位置，而实际上它已经出局了。无论如何，我们将坚持这个来源来收集我们的数据。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="6a8d" class="my ll jb mu b gy mz na l nb nc">wc = read_pickle('world_cup_teams.pickle')<br/>wc.head()</span></pre><figure class="mp mq mr ms gt is gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/36d8afae1c0e3876bca7e9f07f806472.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*XqTA3-XcasFW54IwcTuPjw.png"/></div></figure><p id="1521" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了。我们现在离拥有模拟器只有几步之遥。我们将使用我们的机器学习模型作为蒙特卡洛模拟的规则。如果你很少或没有接触过蒙特卡洛，我推荐你从麻省理工学院开放课程软件的这个课程开始。</p><p id="041d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们构建一个比较团队能力的函数，用我们的 SVC 模型评估获胜者(分别为<strong class="ka jc">团队 1 </strong>或<strong class="ka jc">团队 2、</strong>的 1 或-1)，并返回获胜者姓名。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="6692" class="my ll jb mu b gy mz na l nb nc">def match(wc, team1, team2, model):<br/>    <br/>    match = pd.DataFrame(columns=['att1','def1','mid1','ovr1','att2','def2','mid2','ovr2'], index=[0])<br/>    <br/>    match['att1'] = wc[wc.name == team1]['att'].iloc[0]<br/>    match['def1'] = wc[wc.name == team1]['def'].iloc[0]<br/>    match['mid1'] = wc[wc.name == team1]['mid'].iloc[0]<br/>    match['ovr1'] = wc[wc.name == team1]['ovr'].iloc[0]</span><span id="4c9b" class="my ll jb mu b gy nd na l nb nc">match['att2'] = wc[wc.name == team2]['att'].iloc[0]<br/>    match['def2'] = wc[wc.name == team2]['def'].iloc[0]<br/>    match['mid2'] = wc[wc.name == team2]['mid'].iloc[0]<br/>    match['ovr2'] = wc[wc.name == team2]['ovr'].iloc[0]<br/>    <br/>    match['att'] = match['att1'] - match['att2']<br/>    match['def'] = match['def1'] - match['def2']<br/>    match['mid'] = match['mid1'] - match['mid2']<br/>    match['ovr'] = match['ovr1'] - match['ovr2']<br/>    <br/>    match = match[['att', 'def', 'mid', 'ovr']]<br/>    <br/>    match_array = match.values<br/>    <br/>    prediction = model.predict(match_array)<br/>    <br/>    winner = None<br/>    <br/>    if prediction == 1:<br/>        winner = team1<br/>    elif prediction == -1:<br/>        winner = team2<br/>    <br/>    return winner</span></pre><p id="e302" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯……巴西对西班牙会有什么表现？</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="b012" class="my ll jb mu b gy mz na l nb nc">match(wc, 'brazil', 'spain', svc)</span><span id="dac0" class="my ll jb mu b gy nd na l nb nc">&gt;&gt;&gt; 'spain'</span></pre><p id="4606" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">哦不。没想到我们会有如此悲惨的结局！但是这里有一个主要的问题，球队的表现有很大的不同，本届世界杯的第一阶段就证明了这一点。因此，让我们添加一些随机性，以避免每次运行模拟时结果都相同。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="9fd7" class="my ll jb mu b gy mz na l nb nc">def match(wc, team1, team2, model, random_scale=5):<br/>    <br/>    match = pd.DataFrame(columns=['att1','def1','mid1','ovr1','att2','def2','mid2','ovr2'], index=[0])<br/>    <br/>    att1 = wc[wc.name == team1]['att'].iloc[0]<br/>    def1 = wc[wc.name == team1]['def'].iloc[0]<br/>    mid1 = wc[wc.name == team1]['mid'].iloc[0]<br/>    ovr1 = wc[wc.name == team1]['ovr'].iloc[0]</span><span id="097e" class="my ll jb mu b gy nd na l nb nc">att2 = wc[wc.name == team2]['att'].iloc[0]<br/>    def2 = wc[wc.name == team2]['def'].iloc[0]<br/>    mid2 = wc[wc.name == team2]['mid'].iloc[0]<br/>    ovr2 = wc[wc.name == team2]['ovr'].iloc[0]<br/>    <br/>    match['att1'] = np.random.normal(att1, scale=random_scale)<br/>    match['def1'] = np.random.normal(def1, scale=random_scale)<br/>    match['mid1'] = np.random.normal(mid1, scale=random_scale)<br/>    match['ovr1'] = np.random.normal(ovr1, scale=random_scale)</span><span id="cbd4" class="my ll jb mu b gy nd na l nb nc">match['att2'] = np.random.normal(att2, scale=random_scale)<br/>    match['def2'] = np.random.normal(def2, scale=random_scale)<br/>    match['mid2'] = np.random.normal(mid2, scale=random_scale)<br/>    match['ovr2'] = np.random.normal(ovr2, scale=random_scale)<br/>    <br/>    match['att'] = match['att1'] - match['att2']<br/>    match['def'] = match['def1'] - match['def2']<br/>    match['mid'] = match['mid1'] - match['mid2']<br/>    match['ovr'] = match['ovr1'] - match['ovr2']<br/>    <br/>    match = match[['att', 'def', 'mid', 'ovr']]<br/>    <br/>    match_array = match.values<br/>    <br/>    prediction = model.predict(match_array)<br/>    <br/>    winner = None<br/>    <br/>    if prediction == 1:<br/>        winner = team1<br/>    elif prediction == -1:<br/>        winner = team2<br/>    <br/>    return winner</span></pre><p id="63f7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，<strong class="ka jc"> random_scale </strong>将是决定我们想要对一个团队的表现应用多少随机性的因素。</p><p id="4fd2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步也是最后一步是创建一个函数，多次运行<strong class="ka jc"> match </strong>函数，并计算每个团队的胜利概率。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="b405" class="my ll jb mu b gy mz na l nb nc">def simulate_matches(team1, team2, n_matches=10000):<br/>    <br/>    match_results = []<br/>    for i in range(n_matches):<br/>        match_results.append(match(wc, team1, team2, svc, random_scale=5))<br/>        <br/>    team1_proba = match_results.count(team1)/len(match_results)*100<br/>    team2_proba = match_results.count(team2)/len(match_results)*100<br/>    <br/>    print(team1, str(round(team1_proba, 2)) + '%')<br/>    print(team2, str(round(team2_proba,2)) + '%')<br/>    print('-------------------------')<br/>    print()<br/>    <br/>    if team1_proba &gt; team2_proba:<br/>        overall_winner = team1<br/>    else:<br/>        overall_winner = team2<br/>    <br/>    return {'team1': team1,<br/>            'team2': team2,<br/>            'team1_proba': team1_proba, <br/>            'team2_proba': team2_proba, <br/>            'overall_winner': overall_winner,<br/>            'match_results': match_results}</span></pre><p id="dcfb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看下周日克罗地亚击败丹麦有多难:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="1835" class="my ll jb mu b gy mz na l nb nc">simulation_test = simulate_matches('croatia', 'denmark', n_matches=10000)</span></pre><blockquote class="no"><p id="d467" class="np nq jb bd nr ns nt nu nv nw nx kv dk translated">克罗地亚:40.62% <br/>丹麦:59.38%</p></blockquote><p id="1ee2" class="pw-post-body-paragraph jy jz jb ka b kb ny kd ke kf nz kh ki kj oa kl km kn ob kp kq kr oc kt ku kv ij bi translated">好的，这里你看到模型估计丹麦击败克罗地亚的概率更高，那可能是因为 Fifa 指数数据集很可能没有考虑克罗地亚在世界杯开始后的表现。</p><p id="2e5f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着我们进行越来越多的模拟，让我们来衡量两个团队概率之间的差异:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="7ebe" class="my ll jb mu b gy mz na l nb nc">p_list = []<br/>for i in range(len(simulation_test['match_results'])):<br/>    denmark = simulation_test['match_results'][:i].count('denmark') / (i+1) * 100<br/>    croatia = simulation_test['match_results'][:i].count('croatia') / (i+1) * 100<br/>    p_list.append(denmark - croatia)</span></pre><figure class="mp mq mr ms gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi od"><img src="../Images/2872cc5eebb3b82bd0f07104bd07422f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yGe803BmIoqy0vnrhQn7Ig.jpeg"/></div></div></figure><p id="18be" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到，赢家概率稳定在大约 8，000 场比赛模拟中，这就是我们要使用的值。让我们建立冠军树:</p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oe"><img src="../Images/9d07ec3ab3602649c1ee37c3c5c087aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pGMcAXMttA6W4-FVNNRa1A.jpeg"/></div></div></figure><p id="5a57" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">仅此而已。2018 世界杯全模拟——淘汰赛！</p><p id="3ebb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑到我们的模型有 30%的误差，让我们计算一下西班牙击败所有球队并实际成为冠军的几率:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="7b1f" class="my ll jb mu b gy mz na l nb nc">spain_proba = 0.817 * 0.862 * 0.718 * 0.593 * 100 * (0.7 ** 4)</span><span id="4482" class="my ll jb mu b gy nd na l nb nc">print('Chance of Spain winning:', str(round(spain_proba,2)) + '%')</span></pre><blockquote class="no"><p id="bb8f" class="np nq jb bd nr ns nt nu nv nw nx kv dk translated">西班牙获胜的几率:7.2%</p></blockquote><p id="013e" class="pw-post-body-paragraph jy jz jb ka b kb ny kd ke kf nz kh ki kj oa kl km kn ob kp kq kr oc kt ku kv ij bi translated">嗯，我觉得这很公平。只是仍然希望巴西证明它是错的！</p></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><p id="202b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个帖子到此为止。本文旨在展示如何使用机器学习来计算模拟中的概率，并不试图实际获得正确的结果，因为使用的数据还不够(或者事件本身根本不可预测)。请把这当成一个教程，用世界杯比赛只是因为这是一个很酷的和最新的主题。应该使用更深入的方法来提高结果的清晰度，使它们在任何级别都有意义！</p><p id="29c4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以增加一些步骤来改进模型，包括:</p><ul class=""><li id="f07f" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">尝试更复杂的机器学习算法和微调超参数</li><li id="9ba8" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">收集更多的数据，不仅仅是国际数据，还有国家队的训练数据</li><li id="6b4b" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">更进一步，基于玩家统计数据建立一个模型，<a class="ae mn" href="https://www.uruit.com/blog/2018/02/16/soccer-and-machine-learning-tutorial/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>对这种方法有很好的介绍</li></ul><p id="a2d1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我的第一篇文章，所以谢谢你一直读到最后。我会试着每个月发布一些与数据科学和机器学习相关的好材料。欢迎发表任何评论或关注，如果你喜欢，别忘了为<strong class="ka jc">鼓掌！</strong>谢谢，下次发帖再见。</p></div></div>    
</body>
</html>