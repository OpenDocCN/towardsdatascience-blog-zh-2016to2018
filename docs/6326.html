<html>
<head>
<title>“Artist” in Matplotlib — something I wanted to know before spending tremendous hours on googling how-tos.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Matplotlib 中的“艺术家”——这是我在花大量时间在谷歌上搜索如何做之前想知道的。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/artist-in-matplotlib-something-i-wanted-to-know-before-spending-tremendous-hours-on-googling-ca3ab05ab08d?source=collection_archive---------14-----------------------#2018-12-07">https://towardsdatascience.com/artist-in-matplotlib-something-i-wanted-to-know-before-spending-tremendous-hours-on-googling-ca3ab05ab08d?source=collection_archive---------14-----------------------#2018-12-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/cdc16c533c8e55298ed9059e3ea576dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZqgIGW-9616gdCi7R3xfgA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk"><em class="kf">Cover Photo by </em><a class="ae kg" href="https://unsplash.com/photos/zpeA42RVIQg" rel="noopener ugc nofollow" target="_blank"><em class="kf">Caleb Salomons on Unsplash</em></a></figcaption></figure><p id="5fab" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><em class="lf">最初发表于</em> <a class="ae kg" href="https://dev.to/skotaro/artist-in-matplotlib---something-i-wanted-to-know-before-spending-tremendous-hours-on-googling-how-tos--31oo" rel="noopener ugc nofollow" target="_blank"> <em class="lf"> dev.to </em> </a> <em class="lf">并稍作修改以适应 Medium 的编辑系统。</em></p><p id="22e9" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">matplotlib 确实是 Python 中一个非常棒的可视化工具。但是在 matplotlib 中调整细节确实是一件痛苦的事情。你可能很容易失去几个小时来找出如何改变你的一小部分情节。有时你甚至不知道零件的名称，这使得谷歌搜索变得更加困难。即使您发现了关于堆栈溢出的提示，您可能还需要花费几个小时来使它适合您的情况。通过了解 matplotlib 中的图形由什么组成以及可以用它们做什么，可以避免这些没有回报的任务。我想，和你们大多数人一样，我已经通过阅读 matplotlib 大师关于堆栈溢出的大量回答克服了我的绘图问题。最近，我注意到<a class="ae kg" href="https://matplotlib.org/tutorials/index.html" rel="noopener ugc nofollow" target="_blank">一个关于</a> <code class="fe lg lh li lj b"><a class="ae kg" href="https://matplotlib.org/tutorials/index.html" rel="noopener ugc nofollow" target="_blank">Artist</a></code> <a class="ae kg" href="https://matplotlib.org/tutorials/index.html" rel="noopener ugc nofollow" target="_blank">对象</a>的官方教程非常有用，有助于理解我们使用 matplotlib 绘图时发生的事情，并减少调整所花费的大量时间。在这篇文章中，我想分享一些关于 matplotlib 中的<code class="fe lg lh li lj b">Artist</code>对象的基本知识，这将避免你花费数小时进行调整。</p><h1 id="cfef" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">这个职位的目的</h1><p id="38de" class="pw-post-body-paragraph kh ki it kj b kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la mm lc ld le im bi translated">我不打算写像“当你想这样做时就这样做”这样的操作方法，而是 matplotlib 中<code class="fe lg lh li lj b">Artist</code>的一个基本概念，它可以帮助你选择合适的搜索查询，并为类似的问题安排一个解决方案。读完这篇文章后，你可能会更清楚地理解网上那些海量的食谱。这也适用于那些使用 seaborn 和熊猫绘图特性的人，这些特性是 matplotlib 的包装。</p><h1 id="d270" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">内容</h1><p id="aad0" class="pw-post-body-paragraph kh ki it kj b kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la mm lc ld le im bi translated">这个帖子基本上是我用日语写的<a class="ae kg" href="https://qiita.com/skotaro/items/08dc0b8c5704c94eafb9" rel="noopener ugc nofollow" target="_blank">原文的英文版，大部分基于</a><a class="ae kg" href="https://matplotlib.org/tutorials/intermediate/artists.html" rel="noopener ugc nofollow" target="_blank">艺术家教程</a>和<a class="ae kg" href="https://matplotlib.org/tutorials/introductory/usage.html" rel="noopener ugc nofollow" target="_blank">使用指南</a>(原文发表时为 2.1.1)</p><h1 id="5c2e" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">这是给谁的？</h1><p id="f763" class="pw-post-body-paragraph kh ki it kj b kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la mm lc ld le im bi translated">Matplotlib 用户</p><ul class=""><li id="9170" class="mn mo it kj b kk kl ko kp ks mp kw mq la mr le ms mt mu mv bi translated">如果需要的话，他们能够制作情节，但通常很难使其适合出版或展示(并且对“最后一英里”是你真正想要的感到恼火)。</li><li id="e06c" class="mn mo it kj b kk mw ko mx ks my kw mz la na le ms mt mu mv bi translated">已经成功地找到了堆栈溢出的精确解决方案，但仍然不清楚它是如何工作的，也不能将其应用于其他问题。</li><li id="28dc" class="mn mo it kj b kk mw ko mx ks my kw mz la na le ms mt mu mv bi translated">找到了一个问题的多个提示，但不确定应该遵循哪一个。</li></ul><h1 id="cbb1" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">环境</h1><ul class=""><li id="cf16" class="mn mo it kj b kk mi ko mj ks nb kw nc la nd le ms mt mu mv bi translated">Python 3.6</li><li id="c3cd" class="mn mo it kj b kk mw ko mx ks my kw mz la na le ms mt mu mv bi translated">matplotlib 2.2</li></ul><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="e12a" class="nm ll it lj b gy nn no l np nq">%matplotlib inline<br/>import matplotlib.pyplot as plt<br/>import numpy as np<!-- --> </span></pre><p id="2201" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><code class="fe lg lh li lj b">plt.show()</code>在本文中省略，因为我用的是 Jupyter notebook 的内联情节。</p><h1 id="9222" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">你应该知道的两种绘图风格</h1><p id="bf09" class="pw-post-body-paragraph kh ki it kj b kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la mm lc ld le im bi translated">在研究<code class="fe lg lh li lj b">Artist</code>对象之前，我想提一下<code class="fe lg lh li lj b">plt.plot</code>和<code class="fe lg lh li lj b">ax.plot</code>的区别，或者 Pyplot 和面向对象的 API。虽然官方推荐使用面向对象的 API 风格，但是仍然有很多例子和代码片段使用 Pyplot 风格，包括官方文档。有些人甚至毫无意义地混合了两种风格，这给初学者造成了不必要的困惑。由于官方文档对它们有很好的注释，如<a class="ae kg" href="https://matplotlib.org/tutorials/introductory/lifecycle.html#a-note-on-the-object-oriented-api-vs-pyplot" rel="noopener ugc nofollow" target="_blank">关于面向对象 API vs Pyplot 的注释</a>和<a class="ae kg" href="https://matplotlib.org/tutorials/introductory/usage.html#coding-styles" rel="noopener ugc nofollow" target="_blank">编码风格</a>，这里我只对它们做一些评论。如果你要找他们的介绍，我推荐官方教程。</p><h1 id="947f" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">面向对象的 API 接口</h1><p id="49d1" class="pw-post-body-paragraph kh ki it kj b kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la mm lc ld le im bi translated">这是推荐的风格，通常以<code class="fe lg lh li lj b">fig, ax = plt.subplots()</code>或其他类似的开头，后面是<code class="fe lg lh li lj b">ax.plot</code>、<code class="fe lg lh li lj b">ax.imshow</code>等。<code class="fe lg lh li lj b">fig</code>和<code class="fe lg lh li lj b">ax</code>其实就是<code class="fe lg lh li lj b">Artist</code> s，下面是一些最简单的例子。</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="aa81" class="nm ll it lj b gy nn no l np nq"># example 1<br/>fig, ax = plt.subplots()<br/>ax.plot(x,y)<!-- --> </span><span id="a0bf" class="nm ll it lj b gy nr no l np nq"># example 2<br/>fig = plt.figure()<br/>ax = fig.add_subplot(1,1,1)<br/>ax.plot(x, y)</span></pre><p id="6f1b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">有些教程使用<code class="fe lg lh li lj b">fig = plt.gcf()</code>和<code class="fe lg lh li lj b">ax = plt.gca()</code>。当你从 Pyplot 接口切换到 OO 接口时应该使用这些，但是一些基于 Pyplot 的代码包括，例如，无意义的<code class="fe lg lh li lj b">ax = plt.gca()</code>，它显然是在没有理解的情况下从基于 OO 的代码中复制的。如果有人有意切换界面，使用<code class="fe lg lh li lj b">plt.gcf()</code>或<code class="fe lg lh li lj b">plt.gca()</code>并不是一件坏事。考虑到隐式切换可能会给初学者带来困惑，如果<code class="fe lg lh li lj b">plt.subplots</code>或<code class="fe lg lh li lj b">fig.add_subplot</code>是公开可用的，那么从一开始就使用它们将是大多数情况下的最佳实践。</p><h1 id="8226" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">Pyplot 界面</h1><p id="0414" class="pw-post-body-paragraph kh ki it kj b kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la mm lc ld le im bi translated">这是一种 MATLAB 用户友好的风格，所有的事情都用<code class="fe lg lh li lj b">plt.***</code>来完成。</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="99da" class="nm ll it lj b gy nn no l np nq"># <a class="ae kg" href="https://matplotlib.org/tutorials/introductory/pyplot.html" rel="noopener ugc nofollow" target="_blank">https://matplotlib.org/tutorials/introductory/pyplot.html</a></span><span id="e556" class="nm ll it lj b gy nr no l np nq">def f(t):<br/>    return np.exp(-t) * np.cos(2*np.pi*t)</span><span id="0cad" class="nm ll it lj b gy nr no l np nq">t1 = np.arange(0.0, 5.0, 0.1)<br/>t2 = np.arange(0.0, 5.0, 0.02)<br/>plt.figure(1)<br/>plt.subplot(211)<br/>plt.plot(t1, f(t1), 'bo', t2, f(t2), 'k')<br/>plt.subplot(212)<br/>plt.plot(t2, np.cos(2*np.pi*t2), 'r--')<br/>plt.show()<!-- --> </span></pre><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/9d67e60ac86465fc39932f3b64738989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*WwshhbrShmZy5kq1.png"/></div></figure><p id="45af" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">起初，它看起来非常简单，因为不需要考虑您正在处理哪些对象。你只需要知道你处于哪种“状态”，这也是为什么这种风格也被称为“有状态接口”。这里的“状态”指的是你当前所处的人物和支线剧情。正如你在<a class="ae kg" href="https://matplotlib.org/tutorials/introductory/pyplot.html" rel="noopener ugc nofollow" target="_blank"> Pyplot 教程</a>中看到的，如果你的情节不是那么复杂，它会给出一个不错的数字。虽然 Pyplot 界面提供了很多改变绘图设置的功能，但你可能会在几个小时、几天、几个月内达到它的极限(如果你足够幸运的话，可能永远也不会),这取决于你想做什么。这个阶段需要切换到 OO 界面。这也是我一开始就推荐使用 OO 接口的原因。但 Pyplot 对于快速检查或任何需要粗略绘图的场合仍然有用。</p><h1 id="720a" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">matplotlib 中的层次结构</h1><p id="4fe1" class="pw-post-body-paragraph kh ki it kj b kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la mm lc ld le im bi translated">谷歌几次后，你会注意到 matplotlib 有一个层次结构，由通常被称为<code class="fe lg lh li lj b">fig</code>和<code class="fe lg lh li lj b">ax</code>的东西组成。matplotlib 1.5 的旧文档有一个很好的图像来解释这一点。</p><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/2e605a3ae0d5a954b39b6e2eb8f79186.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/0*LVABKLWV2ZBZdy7M.png"/></div></figure><p id="0440" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">实际上，这三个组件是被称为“容器”的特殊<code class="fe lg lh li lj b">Artist</code>(还有第四个容器<code class="fe lg lh li lj b">Tick</code>，我们稍后会看到。这种层次结构使得上面的简单例子更加清晰。</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="69cd" class="nm ll it lj b gy nn no l np nq"># example 1<br/>fig, ax = plt.subplots()<br/># make Figure and Axes which belongs to 'fig'</span><span id="83c8" class="nm ll it lj b gy nr no l np nq"># example 2<br/>fig = plt.figure()<br/># make Figure<br/>ax = fig.add_subplot(1,1,1)<br/># make Axes belonging to fig<!-- --> </span></pre><p id="7cfa" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">进一步查看<code class="fe lg lh li lj b">fig</code>和<code class="fe lg lh li lj b">ax</code>的属性有助于您更好地理解层次结构。</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="38fa" class="nm ll it lj b gy nn no l np nq">fig = plt.figure()<br/>ax = fig.add_subplot(1,1,1) # make a blank plotting area<br/>print('fig.axes:', fig.axes)<br/>print('ax.figure:', ax.figure)<br/>print('ax.xaxis:', ax.xaxis)<br/>print('ax.yaxis:', ax.yaxis)<br/>print('ax.xaxis.axes:', ax.xaxis.axes)<br/>print('ax.yaxis.axes:', ax.yaxis.axes)<br/>print('ax.xaxis.figure:', ax.xaxis.figure)<br/>print('ax.yaxis.figure:', ax.yaxis.figure)<br/>print('fig.xaxis:', fig.xaxis)</span></pre><p id="fa9a" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">输出:</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="db99" class="nm ll it lj b gy nn no l np nq">fig.axes: [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x1167b0630&gt;]<br/>ax.figure: Figure(432x288)<br/>ax.xaxis: XAxis(54.000000,36.000000)<br/>ax.yaxis: YAxis(54.000000,36.000000)<br/>ax.xaxis.axes: AxesSubplot(0.125,0.125;0.775x0.755)<br/>ax.yaxis.axes: AxesSubplot(0.125,0.125;0.775x0.755)<br/>ax.xaxis.figure: Figure(432x288)<br/>ax.yaxis.figure: Figure(432x288)<br/>---------------------------------------------------------------------------<br/>AttributeError                            Traceback (most recent call last)<br/>&lt;ipython-input-21-b9f2d5d9fe09&gt; in &lt;module&gt;()<br/>      9 print('ax.xaxis.figure:', ax.xaxis.figure)<br/>     10 print('ax.yaxis.figure:', ax.yaxis.figure)<br/>---&gt; 11 print('fig.xaxis:', fig.xaxis)<br/><br/>AttributeError: 'Figure' object has no attribute 'xaxis'</span></pre><p id="755f" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">从这些结果中，我们可以预期关于<code class="fe lg lh li lj b">Figure</code>、<code class="fe lg lh li lj b">Axes</code>和<code class="fe lg lh li lj b">Axis</code>的层级的以下规则。</p><ul class=""><li id="8d09" class="mn mo it kj b kk kl ko kp ks mp kw mq la mr le ms mt mu mv bi translated"><code class="fe lg lh li lj b">Figure</code>知道<code class="fe lg lh li lj b">Axes</code>但不知道<code class="fe lg lh li lj b">Axis</code>。</li><li id="69f1" class="mn mo it kj b kk mw ko mx ks my kw mz la na le ms mt mu mv bi translated"><code class="fe lg lh li lj b">Axes</code>知道<code class="fe lg lh li lj b">Figure</code>和<code class="fe lg lh li lj b">Axis</code>两者。</li><li id="13f7" class="mn mo it kj b kk mw ko mx ks my kw mz la na le ms mt mu mv bi translated"><code class="fe lg lh li lj b">Axis</code>知道<code class="fe lg lh li lj b">Axes</code>和<code class="fe lg lh li lj b">Figure</code>两者。</li><li id="8df2" class="mn mo it kj b kk mw ko mx ks my kw mz la na le ms mt mu mv bi translated"><code class="fe lg lh li lj b">Figure</code>可以包含多个<code class="fe lg lh li lj b">Axes</code>，因为<code class="fe lg lh li lj b">fig.axes</code>是<code class="fe lg lh li lj b">Axes</code>的列表。</li><li id="0196" class="mn mo it kj b kk mw ko mx ks my kw mz la na le ms mt mu mv bi translated"><code class="fe lg lh li lj b">Axes</code>可以只属于单个<code class="fe lg lh li lj b">Figure</code>因为<code class="fe lg lh li lj b">ax.figure</code>不是列表。</li><li id="aebb" class="mn mo it kj b kk mw ko mx ks my kw mz la na le ms mt mu mv bi translated">出于类似的原因，<code class="fe lg lh li lj b">Axes</code>可以分别有一个<code class="fe lg lh li lj b">XAxis</code>和<code class="fe lg lh li lj b">YAxis</code>。</li><li id="e994" class="mn mo it kj b kk mw ko mx ks my kw mz la na le ms mt mu mv bi translated"><code class="fe lg lh li lj b">XAxis</code>和<code class="fe lg lh li lj b">YAxis</code>可以属于单个<code class="fe lg lh li lj b">Axes</code>，相应地也可以属于单个<code class="fe lg lh li lj b">Figure</code>。</li></ul><h1 id="d7f1" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">你情节中的一切都是一个<code class="fe lg lh li lj b">Artist</code></h1><p id="6a91" class="pw-post-body-paragraph kh ki it kj b kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la mm lc ld le im bi translated">当前文档中的<a class="ae kg" href="https://matplotlib.org/tutorials/introductory/usage.html" rel="noopener ugc nofollow" target="_blank">使用指南</a>没有使用图来解释层次结构，而是使用“图的剖析”来解释图中的所有组件，这也是一种信息。</p><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/c55e2febca132a984cb0ccbdb04ddbc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1Lc-pqeSYeGg5xqJ.png"/></div></div></figure><p id="5ff6" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">从代表数据的线和点，到 x 轴上的小记号和文本标签，图形中的每一个组件都是一个<code class="fe lg lh li lj b">Artist</code> object⁴.<code class="fe lg lh li lj b">Artist</code>有两种类型，容器和原语。正如我在上一节中所写的，matplotlib 的层次结构中的三个组件，<code class="fe lg lh li lj b">Figure</code>、<code class="fe lg lh li lj b">Axes</code>和<code class="fe lg lh li lj b">Axis</code>是容器，它们可以包含更低的容器和多个原语，例如由<code class="fe lg lh li lj b">ax.plot</code>生成的<code class="fe lg lh li lj b">Line2D</code>、<code class="fe lg lh li lj b">ax.scatter</code>生成的<code class="fe lg lh li lj b">PathCollection</code>或由<code class="fe lg lh li lj b">ax.annotate</code>生成的<code class="fe lg lh li lj b">Text</code>。甚至刻度线和标签实际上都是属于第四个容器<code class="fe lg lh li lj b">Tick</code>的<code class="fe lg lh li lj b">Line2D</code>和<code class="fe lg lh li lj b">Text</code>。</p><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/6e6f7333b9d778d4b332baa68f70384f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JYntimk3x4P1QJny.png"/></div></div></figure><p id="233b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">对于每种类型的原语，容器都有许多“盒子”(Python 列表，技术上来说)。例如，一个<code class="fe lg lh li lj b">Axes</code>对象<code class="fe lg lh li lj b">ax</code>，在实例化之后有一个空列表<code class="fe lg lh li lj b">ax.lines</code>。常用命令<code class="fe lg lh li lj b">ax.plot</code>在列表中添加一个<code class="fe lg lh li lj b">Line2D</code>对象，并静默进行其他伴随设置。</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="c733" class="nm ll it lj b gy nn no l np nq">x = np.linspace(0, 2*np.pi, 100)<br/><br/>fig = plt.figure()<br/>ax = fig.add_subplot(1,1,1)<br/>print('ax.lines before plot:\n', ax.lines) # empty list</span><span id="e6af" class="nm ll it lj b gy nr no l np nq"># add Line2D in ax.lines<br/>line1, = ax.plot(x, np.sin(x), label='1st plot') <br/>print('ax.lines after 1st plot:\n', ax.lines)</span><span id="6165" class="nm ll it lj b gy nr no l np nq"># add another Line2D<br/>line2, = ax.plot(x, np.sin(x+np.pi/8), label='2nd plot') <br/>print('ax.lines after 2nd plot:\n', ax.lines)</span><span id="1e1a" class="nm ll it lj b gy nr no l np nq">ax.legend()<br/>print('line1:', line1)<br/>print('line2:', line2)</span></pre><p id="e731" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">输出:</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="d11c" class="nm ll it lj b gy nn no l np nq">ax.lines before plot:<br/> []<br/>ax.lines after 1st plot:<br/> [&lt;matplotlib.lines.Line2D object at 0x1171ca748&gt;]<br/>ax.lines after 2nd plot:<br/> [&lt;matplotlib.lines.Line2D object at 0x1171ca748&gt;, &lt;matplotlib.lines.Line2D object at 0x117430550&gt;]<br/>line1: Line2D(1st plot)<br/>line2: Line2D(2nd plot)<!-- --> </span></pre><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/33d38ea67534d0b7937e1f17cd5415c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/0*xGr-h6bp-iGHHfxT.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">w</figcaption></figure><p id="4b85" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">以下部分总结了四种容器。表格复制自<a class="ae kg" href="https://matplotlib.org/tutorials/intermediate/artists.html" rel="noopener ugc nofollow" target="_blank">艺人教程</a>。</p><h1 id="8fb9" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><code class="fe lg lh li lj b">Figure</code></h1><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/8ab96c9cff75a9593e7c152e10ff1065.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G8fKZE2FEE7gylAXQ7I5Fg.png"/></div></div></figure><p id="9afb" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">具有复数名称的属性是列表，具有单数名称的属性表示单个对象。值得注意的是，属于<code class="fe lg lh li lj b">Figure</code>的<code class="fe lg lh li lj b">Artist</code>默认使用<code class="fe lg lh li lj b">Figure</code>坐标。这可以用 <code class="fe lg lh li lj b"><a class="ae kg" href="https://matplotlib.org/users/transforms_tutorial.html" rel="noopener ugc nofollow" target="_blank">Transforms</a></code>转换成<code class="fe lg lh li lj b">Axes</code>或者数据坐标<a class="ae kg" href="https://matplotlib.org/users/transforms_tutorial.html" rel="noopener ugc nofollow" target="_blank">，不在本帖讨论范围内。</a></p><h1 id="b282" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><code class="fe lg lh li lj b">fig.legend</code>和<code class="fe lg lh li lj b">ax.legend</code></h1><p id="33ff" class="pw-post-body-paragraph kh ki it kj b kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la mm lc ld le im bi translated"><code class="fe lg lh li lj b">fig.legends</code>是通过<code class="fe lg lh li lj b"><a class="ae kg" href="https://matplotlib.org/api/_as_gen/matplotlib.figure.Figure.html#matplotlib.figure.Figure.legend" rel="noopener ugc nofollow" target="_blank">fig.lenged</a></code> <a class="ae kg" href="https://matplotlib.org/api/_as_gen/matplotlib.figure.Figure.html#matplotlib.figure.Figure.legend" rel="noopener ugc nofollow" target="_blank">方法</a>添加的图例的“框”。你可能会想“那是干什么的？我们有<code class="fe lg lh li lj b">ax.legend</code>。”不同之处在于每种方法的范围。<code class="fe lg lh li lj b">ax.legend</code>只收集属于<code class="fe lg lh li lj b">ax</code>的<code class="fe lg lh li lj b">Artist</code>的标签，<code class="fe lg lh li lj b">fig.legend</code>收集<code class="fe lg lh li lj b">fig</code>下所有<code class="fe lg lh li lj b">Axes</code>的标签。这很有用，例如，当你使用<code class="fe lg lh li lj b">ax.twinx</code>绘图时。简单的用两次<code class="fe lg lh li lj b">ax.legend</code>就做了两个图例，一般不可取。</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="1622" class="nm ll it lj b gy nn no l np nq">x = np.linspace(0, 2*np.pi, 100)<br/><br/>fig = plt.figure()<br/>ax = fig.add_subplot(111)<br/>ax.plot(x, np.sin(x), label='sin(x)')<br/>ax1 = ax.twinx()<br/>ax1.plot(x, 2*np.cos(x), c='C1', label='2*cos(x)') <br/># cf. 'CN' notation<br/># https://matplotlib.org/tutorials/colors/colors.html#cn-color-selection<br/><br/>ax.legend()<br/>ax1.legend()</span></pre><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/9700ecf537e1ec4e0237793c53c22175.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/0*ZSAgBvuz49ecoEej.png"/></div></div></figure><p id="e6ac" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">将它们放在一起的一个著名方法是将两者的图例处理程序和标签结合起来。</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="c288" class="nm ll it lj b gy nn no l np nq"># Executing this part in a different notebook cell shows an updated figure.<br/>handler, label = ax.get_legend_handles_labels()<br/>handler1, label1 = ax1.get_legend_handles_labels()<br/>ax.legend(handler+handler1, label+label1, loc='upper center', title='ax.legend')<br/># Legend made by ax1.legend remains<br/>fig</span></pre><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/86d98ddcd4c00ead682c6154a951f659.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/0*nxrv37umyDSf9eIl.png"/></div></div></figure><p id="110c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这可以通过<code class="fe lg lh li lj b">fig.legend</code>轻松完成，而无需在<a class="ae kg" href="https://matplotlib.org/users/whats_new.html#figure-legend-can-be-called-without-arguments" rel="noopener ugc nofollow" target="_blank">版本 2.1 </a> ⁵.中引入的参数默认情况下，位置由<code class="fe lg lh li lj b">Figure</code>坐标指定，当您想将其放在绘图框中时，该坐标没有用。你可以用<code class="fe lg lh li lj b">bbox_transform</code>关键字把它改成<code class="fe lg lh li lj b">Axes</code>坐标。</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="b7ae" class="nm ll it lj b gy nn no l np nq">fig.legend(loc='upper right', bbox_to_anchor=(1,1), bbox_transform=ax.transAxes, title='fig.legend\nax.transAxes')<br/>fig</span></pre><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/658cd2756a658a29fdd1812ee3c3eb69.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/0*veiWxJdvtBB_a9ra.png"/></div></div></figure><h1 id="b258" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><code class="fe lg lh li lj b">Axes</code></h1><blockquote class="nz"><p id="6981" class="oa ob it bd oc od oe of og oh oi le dk translated"><em class="kf">matplotlib . axes . axes 是 matplotlib 宇宙的中心</em></p></blockquote><p id="f754" class="pw-post-body-paragraph kh ki it kj b kk oj km kn ko ok kq kr ks ol ku kv kw om ky kz la on lc ld le im bi translated">这是引用自<a class="ae kg" href="https://matplotlib.org/tutorials/intermediate/artists.html#axes-container" rel="noopener ugc nofollow" target="_blank">艺人教程</a>的话。这是非常正确的，因为 matplotlib 中数据可视化的重要部分都来自于<code class="fe lg lh li lj b">Axes</code>方法。</p><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oo"><img src="../Images/c5881489d18b585ef5ade09133fb041d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tWMlXSxgV8jT5u_LzROnQg.png"/></div></div></figure><p id="5135" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">经常使用的命令如<code class="fe lg lh li lj b">ax.plot</code>和<code class="fe lg lh li lj b">ax.scatter</code>被称为“助手方法”,它们在适当的容器中添加相应的<code class="fe lg lh li lj b">Artist</code>,并做其他杂七杂八的工作。</p><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi op"><img src="../Images/10237ff20a80509be5d23b4412bbc72a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j7QBdI4EIUyZrWygoM5Kvg.png"/></div></div></figure><p id="b684" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这个例子显示了<code class="fe lg lh li lj b">ax.plot</code>和<code class="fe lg lh li lj b">ax.scatter</code>在相应的列表中添加<code class="fe lg lh li lj b">Line2D</code>和<code class="fe lg lh li lj b">PathCollection</code>对象。</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="2a25" class="nm ll it lj b gy nn no l np nq">x = np.linspace(0, 2*np.pi, 100)<br/><br/>fig = plt.figure()<br/>ax = fig.add_subplot(1,1,1)<br/># empty Axes.lines<br/>print('ax.lines before plot:\n', ax.lines) </span><span id="a9dd" class="nm ll it lj b gy nr no l np nq"># add Line2D in Axes.lines<br/>line1, = ax.plot(x, np.sin(x), label='1st plot') <br/>print('ax.lines after 1st plot:\n', ax.lines)</span><span id="bc2c" class="nm ll it lj b gy nr no l np nq"># add another Line2D<br/>line2, = ax.plot(x, np.sin(x+np.pi/8), label='2nd plot') <br/>print('ax.lines after 2nd plot:\n', ax.lines)<br/><br/>print('ax.collections before scatter:\n', ax.collections)<br/>scat = ax.scatter(x, np.random.rand(len(x)), label='scatter') # add PathCollection in Axes.collections<br/>print('ax.collections after scatter:\n', ax.collections)<br/>ax.legend()<br/>print('line1:', line1)<br/>print('line2:', line2)<br/>print('scat:', scat)<br/>ax.set_xlabel('x value')<br/>ax.set_ylabel('y value')</span></pre><p id="e4c2" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">输出:</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="53cb" class="nm ll it lj b gy nn no l np nq">ax.lines before plot:<br/> []<br/>ax.lines after 1st plot:<br/> [&lt;matplotlib.lines.Line2D object at 0x1181d16d8&gt;]<br/>ax.lines after 2nd plot:<br/> [&lt;matplotlib.lines.Line2D object at 0x1181d16d8&gt;, &lt;matplotlib.lines.Line2D object at 0x1181d1e10&gt;]<br/>ax.collections before scatter:<br/> []<br/>ax.collections after scatter:<br/> [&lt;matplotlib.collections.PathCollection object at 0x1181d74a8&gt;]<br/>line1: Line2D(1st plot)<br/>line2: Line2D(2nd plot)<br/>scat: &lt;matplotlib.collections.PathCollection object at 0x1181d74a8&gt;</span></pre><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/96e6adc38b963b0cc988cf7e15ee1457.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/0*QRmUcEPgBrpOsrQ4.png"/></div></figure><h1 id="a490" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">不建议重复使用打印对象</h1><p id="6cba" class="pw-post-body-paragraph kh ki it kj b kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la mm lc ld le im bi translated">在知道列表中包含绘制的对象后，您可能会想到通过将这些对象附加到另一个<code class="fe lg lh li lj b">Axes.lines</code>列表中来重用这些对象，以加快绘制速度。<a class="ae kg" href="https://matplotlib.org/tutorials/intermediate/artists.html#axes-container" rel="noopener ugc nofollow" target="_blank">艺术家教程</a>明确指出不推荐这样做，因为助手方法除了创建<code class="fe lg lh li lj b">Artist</code>还能做很多事情。一个快速测试告诉我们这不是一个好主意。</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="6000" class="nm ll it lj b gy nn no l np nq">x = np.linspace(0, 2*np.pi, 100)<br/><br/>fig = plt.figure()<br/># upper subplot<br/>ax1 = fig.add_subplot(2,1,1) <br/># create a Line2D object<br/>line, = ax1.plot(x, np.sin(x), label='ax1 line') <br/>ax1.legend()<br/><br/># lower subplot<br/>ax2 = fig.add_subplot(2,1,2) <br/># try to reuse same `Line2D` object in another `Axes`<br/>ax2.lines.append(line)</span></pre><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div class="gh gi or"><img src="../Images/bd91430de432ac4f55a5d25673e1efbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/0*ZfPhHnXQbjG6x8Ur.png"/></div></figure><p id="b308" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">甚至<code class="fe lg lh li lj b">add_line</code>方法也不管用。</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="b510" class="nm ll it lj b gy nn no l np nq">ax2.add_line(line)</span></pre><p id="aaf8" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">输出:</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="25e9" class="nm ll it lj b gy nn no l np nq">ValueError: Can not reset the axes. You are probably trying to re-use an artist in more than one Axes which is not supported</span></pre><p id="9d45" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这个错误消息表明一个<code class="fe lg lh li lj b">Artist</code>，容器或者原语，不能包含在多个容器中，这与每个<code class="fe lg lh li lj b">Artist</code>将父容器作为一个空对象而不是在一个列表中的事实是一致的</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="f140" class="nm ll it lj b gy nn no l np nq">print('fig:', id(fig)) <br/>print('ax1:', id(ax1))<br/>print('line.fig:', id(line.figure))<br/>print('line.axes:', id(line.axes))</span></pre><p id="21d9" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">输出:</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="a8d2" class="nm ll it lj b gy nn no l np nq">fig: 4707121584<br/>ax1: 4707121136<br/>line.fig: 4707121584<br/>line.axes: 4707121136</span></pre><p id="1965" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">如果你以适当的方式做了所有必要的事情，这也许是可能的，但是这远不是仅仅把一个对象附加到一个列表中的第一想法，并且是不这样做的足够的理由。</p><h1 id="b9f2" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><code class="fe lg lh li lj b">Axis</code></h1><p id="7e5f" class="pw-post-body-paragraph kh ki it kj b kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la mm lc ld le im bi translated">虽然<code class="fe lg lh li lj b">Axis</code>以<code class="fe lg lh li lj b">XAxis</code>或<code class="fe lg lh li lj b">YAxis</code>出现，只包含与记号和标签相关的<code class="fe lg lh li lj b">Artist</code>，但它经常需要一些谷歌搜索进行细微调整，偶尔需要一个小时。我希望这一部分能帮助你快速完成工作。</p><p id="e5dd" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">由于<a class="ae kg" href="https://matplotlib.org/tutorials/intermediate/artists.html#axis-containers" rel="noopener ugc nofollow" target="_blank">美工教程</a>不像其他容器一样有表，所以我做了一个类似的表。</p><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi os"><img src="../Images/e641d6196d961a1b12b8ba5aae975400.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*euNZXZO3YXe3c7wdIGm6VA.png"/></div></div></figure><p id="8167" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们在示例中使用<code class="fe lg lh li lj b">ax.set_xlabel</code>和<code class="fe lg lh li lj b">ax.set_ylabel</code>来表示<code class="fe lg lh li lj b">Axes</code>容器。你可能认为这些方法改变了<code class="fe lg lh li lj b">Axes</code>实例(<code class="fe lg lh li lj b">ax</code>)的 X 和 Y 标签，但实际上它们分别改变了<code class="fe lg lh li lj b">XAxis</code>和<code class="fe lg lh li lj b">YAxis</code>、<code class="fe lg lh li lj b">ax.xaxis.label</code>和<code class="fe lg lh li lj b">ax.yaxis.label</code>的<code class="fe lg lh li lj b">label</code>属性。</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="dbe5" class="nm ll it lj b gy nn no l np nq">xax = ax.xaxis<br/>print('xax.label:', xax.label)</span><span id="7903" class="nm ll it lj b gy nr no l np nq"># seven major ticks (from 0 to 6) and<br/># two invisible ticks locating outside of the figure<br/>print('xax.majorTicks:\n', xax.majorTicks) <!-- --> </span><span id="8601" class="nm ll it lj b gy nr no l np nq"># two ticks outside the figure<br/>print('xax.minorTicks:\n', xax.minorTicks) <!-- --> </span></pre><p id="90ad" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">输出:</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="e71f" class="nm ll it lj b gy nn no l np nq">xax.label: Text(0.5,17.2,'x value')<br/>xax.majorTicks:<br/> [&lt;matplotlib.axis.XTick object at 0x117ae4400&gt;, &lt;matplotlib.axis.XTick object at 0x117941128&gt;, &lt;matplotlib.axis.XTick object at 0x11732c940&gt;, &lt;matplotlib.axis.XTick object at 0x1177d0470&gt;, &lt;matplotlib.axis.XTick object at 0x1177d0390&gt;, &lt;matplotlib.axis.XTick object at 0x1175058d0&gt;, &lt;matplotlib.axis.XTick object at 0x1175050b8&gt;, &lt;matplotlib.axis.XTick object at 0x117bf65c0&gt;, &lt;matplotlib.axis.XTick object at 0x117bf6b00&gt;]<br/>xax.minorTicks:<br/> [&lt;matplotlib.axis.XTick object at 0x117ab5940&gt;, &lt;matplotlib.axis.XTick object at 0x117b540f0&gt;]</span></pre><h1 id="ae15" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><code class="fe lg lh li lj b">ax.set_***</code>方法是临时的</h1><p id="7a05" class="pw-post-body-paragraph kh ki it kj b kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la mm lc ld le im bi translated"><code class="fe lg lh li lj b">Axes</code>有许多“set_***”辅助方法来修改<code class="fe lg lh li lj b">Axis</code>和<code class="fe lg lh li lj b">Tick</code>实例的属性和值。它们非常方便，matplotlib 初学者遇到的大部分问题都可以用它们来解决。值得注意的是，这些“set_***”方法是静态的。当某些内容发生变化时，对它们所做的更改不会更新。例如，如果您使用<code class="fe lg lh li lj b">ax.set_xticks</code>更改 X 刻度以使它们在第一个图中看起来更好，而第二个图超出了第一个图的 X 范围，结果看起来不像它应该的样子。</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="f441" class="nm ll it lj b gy nn no l np nq">x = np.linspace(0, 2*np.pi, 100)<br/><br/>fig = plt.figure()<br/>ax = fig.add_subplot(1,1,1)</span><span id="2b28" class="nm ll it lj b gy nr no l np nq"># X range: 0 to 2pi<br/>line1, = ax.plot(x, np.sin(x), label='') <br/>ax.set_xticks([0, 0.5*np.pi, np.pi, 1.5*np.pi, 2*np.pi])</span><span id="1156" class="nm ll it lj b gy nr no l np nq"># X range: 0 to 3p<br/>iline2, = ax.plot(1.5*x, np.sin(x), label='')</span></pre><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/a543e68f7fb5d7e4820371ffb24b21e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/0*A2Pux7O1vQ9o-KB7.png"/></div></figure><h1 id="9cb7" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><code class="fe lg lh li lj b">Ticker</code>那你呢</h1><p id="6884" class="pw-post-body-paragraph kh ki it kj b kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la mm lc ld le im bi translated">如果不使用“set_***”方法更改与记号相关的设置，则记号和记号标签会相应地为每个新绘图自动更新。这是由<code class="fe lg lh li lj b">Ticker</code>完成的，更具体地说，是由格式化程序和定位器完成的。尽管它们对于与 tick 相关的设置非常重要，但是如果您已经通过复制和粘贴堆栈溢出 answers⁶.解决了问题，那么您可能对它们知之甚少让我们看看前面的例子中发生了什么。</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="e2c5" class="nm ll it lj b gy nn no l np nq">xax = ax.xaxis<br/>yax = ax.yaxis<br/>print('xax.get_major_formatter()', xax.get_major_formatter())<br/>print('yax.get_major_formatter()', yax.get_major_formatter())<br/>print('xax.get_major_locator():',  xax.get_major_locator())<br/>print('yax.get_major_locator():',  yax.get_major_locator())</span></pre><p id="ee53" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">输出:</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="9f44" class="nm ll it lj b gy nn no l np nq">xax.get_major_formatter() &lt;matplotlib.ticker.ScalarFormatter object at 0x118af4d68&gt;<br/>yax.get_major_formatter() &lt;matplotlib.ticker.ScalarFormatter object at 0x118862be0&gt;<br/>xax.get_major_locator(): &lt;matplotlib.ticker.FixedLocator object at 0x1188d5908&gt;<br/>yax.get_major_locator(): &lt;matplotlib.ticker.AutoLocator object at 0x118aed1d0&gt;</span></pre><p id="ad81" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><code class="fe lg lh li lj b">ScalarFormatter</code>是为 X 轴和 Y 轴设置的，因为它是默认的格式化程序，我们没有改变它。另一方面，当默认<code class="fe lg lh li lj b">AutoLocator</code>被设置为 Y 轴时，<code class="fe lg lh li lj b">FixedLocator</code>被设置为 X 轴，我们使用<code class="fe lg lh li lj b">ax.set_xticks</code>方法改变了刻度位置。从它的名字可以想象，<code class="fe lg lh li lj b">FixedLocator</code>固定刻度位置，即使绘图范围改变也不更新。</p><p id="2e3e" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们把前面例子中的<code class="fe lg lh li lj b">Ticker</code>换成<code class="fe lg lh li lj b">ax.set_xticks</code>。</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="015b" class="nm ll it lj b gy nn no l np nq"># this is required to used `Ticker`<br/>import matplotlib.ticker as ticker<!-- --> </span><span id="beba" class="nm ll it lj b gy nr no l np nq"># locate ticks at every 0.5*piax.xaxis.set_major_locator(ticker.MultipleLocator(0.5*np.pi))</span><span id="729e" class="nm ll it lj b gy nr no l np nq"># display the figure again with new locator.<br/>fig</span></pre><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/91b44d8fdcbb87411734a1539269c0e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/0*oIQxahVjrPklRB_n.png"/></div></figure><p id="8016" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">格式化程序怎么样？</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="19c3" class="nm ll it lj b gy nn no l np nq"># FuncFormatter can be used as a decorator<br/>@ticker.FuncFormatter <br/>def major_formatter_radian(x, pos):<br/>    # probably not the best way to show radian tick labels<br/>    return '{}$\pi$'.format(x/np.pi) <br/><br/>ax.xaxis.set_major_formatter(major_formatter_radian)<br/>fig</span></pre><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/9f03388efff219e5f07656faafac70d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/0*hM3QJaeh0sfLhXGn.png"/></div></figure><p id="de2a" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">好吧，也许你还想做些调整，但我想这已经足够清楚了。</p><p id="ed8a" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">可以在 matplotlib 图库了解更多。<br/> <a class="ae kg" href="https://matplotlib.org/gallery/ticks_and_spines/tick-formatters.html" rel="noopener ugc nofollow" target="_blank">图库&gt;记号格式化器</a> <br/> <a class="ae kg" href="https://matplotlib.org/gallery/ticks_and_spines/tick-locators.html" rel="noopener ugc nofollow" target="_blank">图库&gt;记号定位器</a></p><h1 id="3a68" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><code class="fe lg lh li lj b">xunits</code>关键字为<code class="fe lg lh li lj b">ax.plot</code></h1><p id="570f" class="pw-post-body-paragraph kh ki it kj b kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la mm lc ld le im bi translated">供您参考，<code class="fe lg lh li lj b">ax.plot</code>有<code class="fe lg lh li lj b">xunits</code>关键词，是文档中暂时没有描述的<a class="ae kg" href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.plot.html#matplotlib.axes.Axes.plot" rel="noopener ugc nofollow" target="_blank">。我从未尝试过使用这个选项，但是你可以在</a><a class="ae kg" href="https://matplotlib.org/gallery/units/radian_demo.html" rel="noopener ugc nofollow" target="_blank">图库&gt;弧度刻度</a>中看到一个例子，并在这里了解更多关于<code class="fe lg lh li lj b">matplotlib.units.ConversionInterface</code>的信息。</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="078b" class="nm ll it lj b gy nn no l np nq">import numpy as np<br/>from basic_units import radians, degrees, cos<br/>from matplotlib.pyplot import figure, show<br/><br/>x = [val*radians for val in np.arange(0, 15, 0.01)]<br/><br/>fig = figure()<br/>fig.subplots_adjust(hspace=0.3)<br/><br/>ax = fig.add_subplot(211)<br/>line1, = ax.plot(x, cos(x), xunits=radians)<br/><br/>ax = fig.add_subplot(212)<br/>line2, = ax.plot(x, cos(x), xunits=degrees)</span></pre><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/772b1d5d6e2d289643f9e72fb71865c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*tF5IkSTa64DHjISm.png"/></div></figure><h1 id="feed" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><code class="fe lg lh li lj b">Tick</code></h1><p id="06e9" class="pw-post-body-paragraph kh ki it kj b kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la mm lc ld le im bi translated">最后，我们到达了 matplotlib 层次结构的底部。<code class="fe lg lh li lj b">Tick</code>是一个小容器，主要存放刻度本身的短线和刻度标签的文本。</p><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ot"><img src="../Images/7bcba39629ff079059a72c80e57bfc06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eQgUHt8G7tNxP7OcIkTNUA.png"/></div></div></figure><p id="134b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">正如我们在<code class="fe lg lh li lj b">Axis</code>中看到的，<code class="fe lg lh li lj b">Tick</code>也作为<code class="fe lg lh li lj b">XTick</code>或<code class="fe lg lh li lj b">YTick</code>出现。第一个和第二个表示<code class="fe lg lh li lj b">XTick</code>上下两侧的刻度，而第二个表示<code class="fe lg lh li lj b">YTick</code>左右两侧的刻度。默认情况下，后面的记号不可见。</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="49bd" class="nm ll it lj b gy nn no l np nq"># tick at 0.5 pi in the previous figure<br/>xmajortick = ax.xaxis.get_major_ticks()[2] <br/>print('xmajortick', xmajortick)<br/>print('xmajortick.tick1line', xmajortick.tick1line)<br/>print('xmajortick.tick2line', xmajortick.tick2line)<br/>print('xmajortick.gridline', xmajortick.gridline)<br/>print('xmajortick.label1', xmajortick.label1)<br/>print('xmajortick.label2', xmajortick.label2)<br/>print('xmajortick.gridOn', xmajortick.gridOn)<br/>print('xmajortick.tick1On', xmajortick.tick1On)<br/>print('xmajortick.tick2On', xmajortick.tick2On)<br/>print('xmajortick.label1On', xmajortick.label1On)<br/>print('xmajortick.label2On', xmajortick.label2On)</span></pre><p id="02b5" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">输出:</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="225a" class="nm ll it lj b gy nn no l np nq">xmajortick &lt;matplotlib.axis.XTick object at 0x11eec0710&gt;<br/>xmajortick.tick1line Line2D((1.5708,0))<br/>xmajortick.tick2line Line2D()<br/>xmajortick.gridline Line2D((0,0),(0,1))<br/>xmajortick.label1 Text(1.5708,0,'0.5$\\pi$')<br/>xmajortick.label2 Text(0,1,'0.5$\\pi$')<br/>xmajortick.gridOn False<br/>xmajortick.tick1On True<br/>xmajortick.tick2On False<br/>xmajortick.label1On True<br/>xmajortick.label2On False</span></pre><p id="3630" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">由于有许多助手方法、<code class="fe lg lh li lj b">Ticker</code>和<code class="fe lg lh li lj b"><a class="ae kg" href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.tick_params.html" rel="noopener ugc nofollow" target="_blank">Axes.tick_params</a></code>，我们几乎不需要直接处理<code class="fe lg lh li lj b">Tick</code>。</p><h1 id="d1f9" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">是时候定制你的默认风格了</h1><p id="8ce8" class="pw-post-body-paragraph kh ki it kj b kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la mm lc ld le im bi translated">看一下默认样式的参数列表。<br/> <a class="ae kg" href="https://matplotlib.org/tutorials/introductory/customizing.html#a-sample-matplotlibrc-file" rel="noopener ugc nofollow" target="_blank">教程&gt;定制 matplotlib &gt;一个示例 matplotlibrc 文件</a> <br/>我想现在你不仅能弄清楚一个参数是干什么的，还能弄清楚一个参数实际上对哪个<code class="fe lg lh li lj b">Artist</code>有影响，这让你为 googling⁷.节省时间您还可以自定义默认样式，而不需要生成 matplotlibrc 文件，只需在代码的开头键入如下内容。</p><pre class="ne nf ng nh gt ni lj nj nk aw nl bi"><span id="be3c" class="nm ll it lj b gy nn no l np nq">plt.rcParams['lines.linewidth'] = 2</span></pre><h1 id="f836" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">(再次)去看医生</h1><p id="e567" class="pw-post-body-paragraph kh ki it kj b kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la mm lc ld le im bi translated">你们中的一些人可能对 matplotlib 的文档有负面的印象。我同意很难从一长串列表中找到适合你的问题的例子。但是自从 2.1⁸.版本以来，它已经有了很大改进如果您比较改进前后的相应页面，这一点很明显。</p><ul class=""><li id="cacb" class="mn mo it kj b kk kl ko kp ks mp kw mq la mr le ms mt mu mv bi translated">2 . 1 . 0(2017 年 10 月)<a class="ae kg" href="https://matplotlib.org/2.1.0/gallery/index.html" rel="noopener ugc nofollow" target="_blank">画廊</a>、<a class="ae kg" href="https://matplotlib.org/2.1.0/tutorials/index.html" rel="noopener ugc nofollow" target="_blank">教程</a>、<a class="ae kg" href="https://matplotlib.org/2.1.0/contents.html" rel="noopener ugc nofollow" target="_blank">概述</a></li><li id="42b2" class="mn mo it kj b kk mw ko mx ks my kw mz la na le ms mt mu mv bi translated">2 . 0 . 2(2017 年 5 月)<a class="ae kg" href="https://matplotlib.org/2.0.2/examples/index.html" rel="noopener ugc nofollow" target="_blank">实例</a>、<a class="ae kg" href="https://matplotlib.org/2.0.2/gallery.html" rel="noopener ugc nofollow" target="_blank">图库</a>、<a class="ae kg" href="https://matplotlib.org/2.0.2/contents.html" rel="noopener ugc nofollow" target="_blank">概述</a></li></ul><p id="5848" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我推荐看一看<a class="ae kg" href="https://matplotlib.org/gallery/index.html" rel="noopener ugc nofollow" target="_blank">最新图库</a>和<a class="ae kg" href="https://matplotlib.org/tutorials/index.html#" rel="noopener ugc nofollow" target="_blank">教程</a>，现在已经很整洁了。</p><p id="9057" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kj iu"> <em class="lf">感谢阅读。享受用 matplotlib 绘图(和谷歌搜索)</em> </strong>📈🤗📊</p><p id="4db8" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">脚注:</p><ol class=""><li id="2762" class="mn mo it kj b kk kl ko kp ks mp kw mq la mr le ou mt mu mv bi translated">是的，如果你没有懒到在使用之前阅读教程的话，教程总是有帮助的。事实上，当我几年前开始用 matplotlib 绘图时，我可能曾经试图阅读过一次关于 Artist 的文档，但我很确定当时我认为“好吧，这不适合我”。(可能不是现在的教程。)</li><li id="41ac" class="mn mo it kj b kk mw ko mx ks my kw mz la na le ou mt mu mv bi translated">下面是这个图的示例代码<a class="ae kg" href="https://matplotlib.org/gallery/showcase/anatomy.html" rel="noopener ugc nofollow" target="_blank">https://matplotlib.org/gallery/showcase/anatomy.html</a></li><li id="7e71" class="mn mo it kj b kk mw ko mx ks my kw mz la na le ou mt mu mv bi translated">当然还有其他的<code class="fe lg lh li lj b">Artist</code><a class="ae kg" href="https://matplotlib.org/api/artist_api.html" rel="noopener ugc nofollow" target="_blank">这一页</a>对于那些想要大图的人来说是一个很好的入口。您可以点击<code class="fe lg lh li lj b">Artist</code>名称获得进一步解释。</li><li id="f853" class="mn mo it kj b kk mw ko mx ks my kw mz la na le ou mt mu mv bi translated">从技术上来说，<code class="fe lg lh li lj b">Artist</code>让我们在 matplotlib 的画布上绘制你漂亮的数据。多么可爱的说辞。</li><li id="e9e0" class="mn mo it kj b kk mw ko mx ks my kw mz la na le ou mt mu mv bi translated"><code class="fe lg lh li lj b">fig.legend</code>没有当前版本有用，因为根据<a class="ae kg" href="https://matplotlib.org/2.0.2/api/figure_api.html?highlight=figure%20legend#matplotlib.figure.Figure.legend" rel="noopener ugc nofollow" target="_blank">版本的文档，它需要图例手柄和标签。2.0.2 </a></li><li id="c3ba" class="mn mo it kj b kk mw ko mx ks my kw mz la na le ou mt mu mv bi translated">当你从“set_***”方法进一步谷歌 tick 相关设置，并放弃为你自己的问题安排它们时，你会经常遇到使用它们的食谱。(没错，就是几个月前的我。)</li><li id="c2b2" class="mn mo it kj b kk mw ko mx ks my kw mz la na le ou mt mu mv bi translated">或者你可以像我一样，利用节省下来的时间深入挖掘。</li><li id="2579" class="mn mo it kj b kk mw ko mx ks my kw mz la na le ou mt mu mv bi translated">这里是一个很好的阅读，以了解如何困难，以改善文件。<a class="ae kg" href="https://www.numfocus.org/blog/matplotlib-lead-developer-explains-why-he-cant-fix-the-docs-but-you-can/" rel="noopener ugc nofollow" target="_blank"> Matplotlib 引导 Dev 解释为什么他不能修复 Docs | NumFOCUS </a></li></ol></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><p id="d3b4" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><em class="lf">原载于</em> <a class="ae kg" href="https://dev.to/skotaro/artist-in-matplotlib---something-i-wanted-to-know-before-spending-tremendous-hours-on-googling-how-tos--31oo" rel="noopener ugc nofollow" target="_blank"> <em class="lf"> dev.to </em> </a> <em class="lf">。</em></p></div></div>    
</body>
</html>