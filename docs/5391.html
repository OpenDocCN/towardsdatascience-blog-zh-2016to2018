<html>
<head>
<title>Numpy — Python made efficient</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">numpy——Python 变得高效</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/numpy-python-made-efficient-f82a2d84b6f7?source=collection_archive---------9-----------------------#2018-10-15">https://towardsdatascience.com/numpy-python-made-efficient-f82a2d84b6f7?source=collection_archive---------9-----------------------#2018-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/707bd6a3a451f08db8805691d32ddeed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qmH_nW3-vys30DFl"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">“person holding sticky note” by <a class="ae kc" href="https://unsplash.com/@hiteshchoudhary?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Hitesh Choudhary</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9350" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几天前，我的一个朋友问我他如何使用<em class="lb"> git 命令</em>来更改提交消息的名称。因为我已经在我的一篇文章中记录了同样的内容，所以我能够指引他去那里，他也能够自己做出必要的改变。就在那时，我意识到我的工作不仅帮助了未来的自己，也帮助了我的朋友和同事。因此，我决定记录下我将学到的任何新东西，因为它可能也会指导其他人。</p><p id="9892" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我将介绍 Numpy 的基础知识以及我最近了解到的一些策略。我将每个<code class="fe lc ld le lf b">print()</code>语句的输出作为注释包含在 Github gist 语句的后面。整个项目也可以作为<a class="ae kc" href="https://github.com/kb22/Understanding-Numpy" rel="noopener ugc nofollow" target="_blank">理解 Numpy </a>库。</p><h1 id="7ba0" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak"> Numpy(数字 Python) </strong></h1><p id="3bbd" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">几天前，当我研究机器学习时，我开始使用 Python 的 Numpy 库。在看过如此多的视频系列和文件后，我确信它的巨大潜力和它带来的计算效率。</p><p id="4ade" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于数据密集型计算，Numpy 为我们提供了广泛的方法，使 Python 中的数据操作变得非常快速和简单。虽然在循环过程中，Python 的执行速度比 Fortran 等其他语言慢，但 Numpy 通过将重复代码转换为编译形式来加快 Python 的操作。</p><blockquote class="mj mk ml"><p id="5335" class="kd ke lb kf b kg kh ki kj kk kl km kn mm kp kq kr mn kt ku kv mo kx ky kz la ij bi translated">NumPy 是使用 Python 进行科学计算的基础包。— <a class="ae kc" href="http://www.numpy.org/" rel="noopener ugc nofollow" target="_blank">数量</a></p></blockquote><p id="10ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这确实是真的。它提供了大量的选项，并且人们可以用简单的语句做大量的事情，这是非常了不起的。</p><pre class="mp mq mr ms gt mt lf mu mv aw mw bi"><span id="df8f" class="mx lh iq lf b gy my mz l na nb">import numpy as np</span></pre><p id="c6ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我首先使用 Python 的 import 语句导入 Numpy。我把它命名为<code class="fe lc ld le lf b">np</code>,这样我就不用每次使用它的一个函数时都写<code class="fe lc ld le lf b">numpy</code>。这是导入库时遵循的一般惯例。</p><h1 id="a200" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">数字阵列</h1><p id="eb0f" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">Numpy 数组非常类似于 Python 列表，但有一个特殊条件，即它的所有元素都必须是同一类型。我们使用函数<code class="fe lc ld le lf b">array()</code>在 numpy 中定义一个数组。它接受第一个参数作为数组，第二个参数作为元素类型，例如<em class="lb"> int </em>、<em class="lb"> float </em>等。在这个例子中，我们定义了一个包含 int (integer)类型的元素 1、2、3 和 4 的数组。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="35db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以索引元素。numpy 数组中的 Index 也是从 0 开始的，所以<code class="fe lc ld le lf b">integerArray[0]</code>指的是第一个为 1 的元素。我们也可以定义一个范围，比如<code class="fe lc ld le lf b">[:2]</code>，它打印从 0 到 1 的所有值。创建这样一个数组非常有用，因为它有巨大的潜力，就像简单地检查数组中的一个元素一样<code class="fe lc ld le lf b">2 in integerArray</code>返回<code class="fe lc ld le lf b">True</code>。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="098d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以使用<code class="fe lc ld le lf b">concatenate()</code>函数连接两个 numpy 数组。创建不同的数组也变得非常容易。我们可以使用函数<code class="fe lc ld le lf b">zeros()</code>创建任意给定大小的 0 数组，使用<code class="fe lc ld le lf b">ones()</code>创建任意给定大小的 1 数组，并通过定义一个<code class="fe lc ld le lf b">range()</code>而不是实际的 Python 列表来创建一个随机数数组。每个函数还接受第二个参数作为可选的元素类型。</p><h2 id="0884" class="mx lh iq bd li ne nf dn lm ng nh dp lq ko ni nj lu ks nk nl ly kw nm nn mc no bi translated">多维数组</h2><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="3119" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用 numpy 库在 Python 中定义多维数组。只需将完整的数组集定义为数组字段的第一个参数。在上面的例子中，我们创建了一个二维数组(矩阵)。使用<code class="fe lc ld le lf b">reshape()</code>函数可以将一维数组转换成二维数组，反之亦然。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="2ab0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">concatenate()</code>函数也适用于 numpy 中的多维数组。默认情况下，连接发生在第一维上。然而，我们也可以使用<code class="fe lc ld le lf b">axis</code>参数定义串联轴。对于表示为<code class="fe lc ld le lf b">matrix[row][column]</code>的矩阵，我们可以通过使用<code class="fe lc ld le lf b">axis = 0</code>连接行或使用<code class="fe lc ld le lf b">axis = 1</code>连接列来连接。</p><h2 id="c27a" class="mx lh iq bd li ne nf dn lm ng nh dp lq ko ni nj lu ks nk nl ly kw nm nn mc no bi translated">Numpy 数组操作</h2><p id="2c5f" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">我们可以在 numpy 数组上应用多种操作。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="e49c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Numpy 重载了所有的基本函数，以便它们可以对数组进行操作，例如加号运算符<code class="fe lc ld le lf b">+</code>、乘号运算符<code class="fe lc ld le lf b">*</code>等。都是为数组重载的。平方根和对数等特殊函数也是可用的。这些操作是按元素进行的，因此当与多个数组交互时，它们必须都具有相同的形状。还有许多其他可能的操作，如<code class="fe lc ld le lf b">exp</code>、<code class="fe lc ld le lf b">sin</code>、<code class="fe lc ld le lf b">cos</code>、<code class="fe lc ld le lf b">tan</code>和<code class="fe lc ld le lf b">abs</code>。我们还可以<code class="fe lc ld le lf b">sort()</code>，找到<code class="fe lc ld le lf b">min()</code>和<code class="fe lc ld le lf b">max()</code>，确定<code class="fe lc ld le lf b">unique()</code>值，矩阵的<code class="fe lc ld le lf b">diagonal()</code>元素和<code class="fe lc ld le lf b">sort()</code>元素。如果我们在 min 或 max 前面加上<code class="fe lc ld le lf b">arg</code>，也可以得到数组中最小值或最大值的索引。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="2358" class="mx lh iq bd li ne nf dn lm ng nh dp lq ko ni nj lu ks nk nl ly kw nm nn mc no bi translated">比较数组</h2><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="ad95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">numpy 数组也可以进行元素比较。这些函数返回布尔值，可以再次用于从结果为真的数组中提取值。</p><h2 id="27b0" class="mx lh iq bd li ne nf dn lm ng nh dp lq ko ni nj lu ks nk nl ly kw nm nn mc no bi translated">向量和矩阵运算</h2><p id="ee8b" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">上面提到的所有函数都非常有用，并导致了使用向量和矩阵的更大目标。所有函数都处理向量和矩阵，使我们能够将 Numpy 用于统计和机器学习应用。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="2bea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个清单并没有到此为止。numpy 库中内置了最重要的函数，如<code class="fe lc ld le lf b">dot()</code>和<code class="fe lc ld le lf b">cross()</code>矩阵运算。令人惊讶的是，我们也可以计算<code class="fe lc ld le lf b">outer()</code>和<code class="fe lc ld le lf b">inner()</code>。</p><h2 id="20af" class="mx lh iq bd li ne nf dn lm ng nh dp lq ko ni nj lu ks nk nl ly kw nm nn mc no bi translated">随机阵列</h2><p id="1b33" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">使用 numpy，很容易定义随机数组和随机矩阵。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="6df3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">np.random</code>使我们能够定义随机数组。如果自变量包括单个整数，例如上面示例中的<code class="fe lc ld le lf b">5</code>，函数<code class="fe lc ld le lf b">rand()</code>定义一个随机数组；如果自变量是整数的组合，例如上面矩阵示例中的<code class="fe lc ld le lf b">(5,4)</code>，函数<code class="fe lc ld le lf b">rand()</code>定义一个随机矩阵。这个函数返回 0 到 1 范围内的值，但是如果我们想要整数，我们应该使用<code class="fe lc ld le lf b">randint()</code>。它将第一个参数作为起始值，第二个参数作为结束值，第三个参数作为数组的形状。</p><h1 id="87b6" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">数字策略</h1><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/afee1f59facc3e1608fdd4dd1017bdf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5Vm7OjlSdQ42H9ZC"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">“four person fist bumping” by <a class="ae kc" href="https://unsplash.com/@rawpixel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">rawpixel</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bc71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在非常熟悉 numpy 数组以及可以在其上执行的无限功能。在部署这些功能时，我们使用了一些固有的策略，包括:</p><ol class=""><li id="cc72" class="nq nr iq kf b kg kh kk kl ko ns ks nt kw nu la nv nw nx ny bi translated">通用函数</li><li id="ddcf" class="nq nr iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated">聚集</li><li id="e121" class="nq nr iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated">广播</li><li id="4880" class="nq nr iq kf b kg nz kk oa ko ob ks oc kw od la nv nw nx ny bi translated">切片、蒙版和花式索引</li></ol><p id="601f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经在上面的例子中使用了它们，但是现在我们可以明确地定义和区分它们。我在 PyCon 2015 youtube 视频中发现了这些关于<a class="ae kc" href="https://www.youtube.com/watch?v=EEUXKG97YRw" rel="noopener ugc nofollow" target="_blank">丢失循环</a>的策略。</p><h2 id="4e0f" class="mx lh iq bd li ne nf dn lm ng nh dp lq ko ni nj lu ks nk nl ly kw nm nn mc no bi translated">通用函数</h2><p id="77f6" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">这些函数被定义为对数组元素进行元素操作的函数，不管它是一个单维数组还是多维数组。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="2ef0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的例子使用通用函数将数组<code class="fe lc ld le lf b">arr</code>的每个元素乘以 10，生成一个新的数组。</p><h2 id="aa7f" class="mx lh iq bd li ne nf dn lm ng nh dp lq ko ni nj lu ks nk nl ly kw nm nn mc no bi translated">聚合函数</h2><p id="d75f" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">当我们希望总结数组中包含的信息时，这些函数非常有用。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b457" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的例子显示了我们如何使用<code class="fe lc ld le lf b">std()</code>函数来计算数组元素的标准偏差，它大约是<code class="fe lc ld le lf b">2.87</code>。</p><h2 id="40dc" class="mx lh iq bd li ne nf dn lm ng nh dp lq ko ni nj lu ks nk nl ly kw nm nn mc no bi translated">广播</h2><p id="a158" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">这些是通用函数如何在 numpy 数组上操作的一组规则。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="bcf1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，我们看到一方面我们有一个矩阵<code class="fe lc ld le lf b">mat</code>，另一方面我们有一个数组<code class="fe lc ld le lf b">arr</code>。在添加这两个时，broadcasting 复制数组两次(理解为用两行创建一个临时矩阵作为<code class="fe lc ld le lf b">[1,1,1]</code>)并添加这两个，这是可能的，因为它们现在具有相同的维度并产生结果。</p><h2 id="703c" class="mx lh iq bd li ne nf dn lm ng nh dp lq ko ni nj lu ks nk nl ly kw nm nn mc no bi translated">切片、蒙版和花式索引</h2><p id="e9c9" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">最后一个策略也包含了一些技巧。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="3fa9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用一系列索引来索引数组，例如上面示例中的<code class="fe lc ld le lf b">0 to 4</code>。当我们将值设置为<code class="fe lc ld le lf b">[:5]</code>时，它从索引<code class="fe lc ld le lf b">0</code>的开头开始读取，直到比索引<code class="fe lc ld le lf b">4</code>的结尾小 1。</p><p id="2514" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">屏蔽使我们能够使用运算符来获得满足条件的数组中每个元素的布尔答案。如果条件满足，返回值为<code class="fe lc ld le lf b">True</code>，否则为<code class="fe lc ld le lf b">False</code>。例如，在上面的例子中，当我们定义掩码<code class="fe lc ld le lf b">bigArray &gt; 6 | bigArray &lt; 3</code>时，我们得到掩码为<code class="fe lc ld le lf b">[True True True False False False False True True True]</code>。然后，我们可以使用它来定义要在<code class="fe lc ld le lf b">bigArray</code>数组中读取的值，并获得输出。</p><p id="c37b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">花式索引是指我们定义一个索引列表，然后用它来获取<code class="fe lc ld le lf b">bigArray</code>数组的元素。</p><p id="7bad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们可以将它们结合起来。在上面的最后一个例子中，我们首先选择值大于 6 的所有值，因此我们得到布尔值<code class="fe lc ld le lf b">[False False False False False False False True True True]</code>，它通过<code class="fe lc ld le lf b">bigArray[bigArray &gt; 6]</code>返回<code class="fe lc ld le lf b">[7,8,9]</code>，我们从中选择第一个元素，从而得到输出<code class="fe lc ld le lf b">[7]</code>。</p><h1 id="ab0e" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结论</h1><p id="c602" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">本文详细介绍了什么是 Numpy 数组及其众多的功能和策略。理解 Numpy 有助于我们理解基于它的许多其他库，例如 Sklearn。</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><p id="2a0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望你喜欢我的作品。请分享、评论和表达你的想法和观点。</p></div></div>    
</body>
</html>