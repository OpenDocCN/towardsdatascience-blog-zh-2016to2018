<html>
<head>
<title>Detecting facial features using Deep Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用深度学习检测面部特征</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/detecting-facial-features-using-deep-learning-2e23c8660a7a?source=collection_archive---------7-----------------------#2017-08-02">https://towardsdatascience.com/detecting-facial-features-using-deep-learning-2e23c8660a7a?source=collection_archive---------7-----------------------#2017-08-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="572e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也许你想知道如何在实时视频聊天中在人脸上放置有趣的物体或检测情绪？在这里，我将向您展示一种利用深度学习的可能方法，并略读一种较老的方法。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/7110120ff648ed6f73a981cffda1ef22.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*y9Z-gMLPPCR_yqhiO_EANw.jpeg"/></div></figure><p id="aa72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在过去，一项具有挑战性的任务是检测人脸及其特征，如眼睛、鼻子、嘴巴，甚至从它们的形状中提取情感。这项任务现在可以通过深度学习“神奇地”解决，任何有天赋的青少年都可以在几个小时内完成。我将在这篇文章中向你展示这样一种方法。</p><h1 id="cf03" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">【古典】法(CLM) </strong></h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/4fd495d357fd6de49ca54fee907d43cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*gXmxeqKo-vNu5F0i8hIh7w.png"/></div></figure><p id="5727" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你像我一样，需要执行面部跟踪(在我的情况下，将一个人的手势从网络摄像头转移到动画角色)，你可能会发现，最好的执行算法之一曾经是受约束的本地模型(<a class="ae ls" href="https://sites.google.com/site/xgyanhome/home/projects/clm-implementation/ConstrainedLocalModel-tutorial%2Cv0.7.pdf?attredirects=0" rel="noopener ugc nofollow" target="_blank">【CLM】</a>)，例如由<a class="ae ls" href="https://github.com/TadasBaltrusaitis/CLM-framework" rel="noopener ugc nofollow" target="_blank">剑桥面部跟踪器</a>或其更新的<a class="ae ls" href="https://github.com/TadasBaltrusaitis/OpenFace" rel="noopener ugc nofollow" target="_blank"> OpenFace </a>化身实现。这是基于将检测任务分成检测形状向量特征(<a class="ae ls" href="http://slidegur.com/doc/3183242/face-and-facial-feature-tracking-asm--aam--clm" rel="noopener ugc nofollow" target="_blank"> ASM </a>)和小块图像模板(<a class="ae ls" href="http://slidegur.com/doc/3183242/face-and-facial-feature-tracking-asm--aam--clm" rel="noopener ugc nofollow" target="_blank"> AAM </a>)，并使用预训练的线性 SVM 来改进检测。</p><p id="7351" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它的工作原理是首先粗略估计关键点的位置，然后对包含面部部分的预训练图像应用 SVM，并调整关键点的位置。重复这一过程，直到误差对于我们的目的来说足够低。此外，值得一提的是，它假设图像上的人脸位置已经被估计，例如通过使用<a class="ae ls" href="https://en.wikipedia.org/wiki/Viola%E2%80%93Jones_object_detection_framework" rel="noopener ugc nofollow" target="_blank"> Viola-Jones 检测器</a> ( <a class="ae ls" href="https://en.wikipedia.org/wiki/Haar-like_feature" rel="noopener ugc nofollow" target="_blank"> Haar cascades </a>)。然而，CLM 过程是相当复杂和重要的，肯定不会由一个高中巫师来实现。您可以在这里看到整体架构:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lt"><img src="../Images/d45d6bf360ce170dd399661468accfdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FSji4dBB_q23hLyeZ4fgrw.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Well, fairly complicated, right?</figcaption></figure><h1 id="71bd" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">深度学习</strong></h1><p id="9ae6" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">相反，我们可以使用一个非常简单的卷积神经网络(<a class="ae ls" href="https://en.wikipedia.org/wiki/Convolutional_neural_network" rel="noopener ugc nofollow" target="_blank"> CNN </a>)并在我们预期包含人脸的图像部分上执行关键点检测。为此，我们需要一个训练数据集；我们可以使用由<a class="ae ls" href="https://www.kaggle.com/" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>为他们的<a class="ae ls" href="https://www.kaggle.com/c/facial-keypoints-detection/data" rel="noopener ugc nofollow" target="_blank">面部关键点检测挑战</a>提供的一个，包含 15 个关键点，或者一个更复杂的<a class="ae ls" href="http://www.milbo.org/muct/" rel="noopener ugc nofollow" target="_blank"> MUCT 数据集</a>包含 76 个关键点(耶！).</p><p id="8c69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然，拥有高质量的训练数据集在这里是必不可少的，我们都应该纪念那些不得不牺牲他们的时间和精力来注释一堆人脸以获准毕业的贫困本科生，这样我们就可以轻松地表演这些神奇的把戏。</p><p id="3640" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一张巴洛克风格的脸和它在 Kaggle 数据集中的关键点的样子:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/7c91ae55f70f77a1295ebf156a53d3b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*1e9NG46qPoybYZeeTCfGBw.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">James Madison Jr.</figcaption></figure><p id="22d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据集包含分辨率为 96x96 的灰度图像和 15 个关键点，每只眼睛 5 个，嘴/鼻子位置 5 个。</p><p id="ab13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于任意图像，我们首先需要检测图像中人脸的位置；可以使用前面提到的基于哈尔级联的 Viola-Jones 检测器(如果你看看它是如何工作的，它有点像 CNN)。或者，如果你更有冒险精神，你也可以使用全卷积网络(<a class="ae ls" href="https://people.eecs.berkeley.edu/%7Ejonlong/long_shelhamer_fcn.pdf" rel="noopener ugc nofollow" target="_blank"> FCN </a>)和深度估计来执行图像分割。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mi"><img src="../Images/467c4611f6636549241c834fe0553122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rwF91aP0qoNZ5IenPij5uQ.jpeg"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">OpenCV does the trick</figcaption></figure><p id="14f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无论如何，使用 OpenCV 是小菜一碟:</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="57f5" class="mo ku iq mk b gy mp mq l mr ms">Grayscale_image = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)</span><span id="9f61" class="mo ku iq mk b gy mt mq l mr ms">face_cascade = cv2.CascadeClassifier(‘haarcascade_frontalface_default.xml’)</span><span id="477d" class="mo ku iq mk b gy mt mq l mr ms">bounding_boxes = face_cascade.detectMultiScale(grayscale_image, 1.25, 6)</span></pre><p id="723c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这段代码返回图像上所有可能的人脸包围盒。</p><p id="7bcc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，对于 Viola-Jones 返回的每个边界框，我们提取相应的子图像，将其转换为灰度，并将其大小调整为 96x96。它们将成为我们最终的 CNN 的输入，用于推理。</p><p id="29c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CNN 架构超级猥琐；一堆 5×5 卷积层(实际上是 3 层，每层有 24、36 和 48 个滤波器)，然后是另外 2 层 3×3 卷积层(每层 64 个滤波器)，最后是 3 个全连接层(有 500、90 和 30 个节点)。一些防止过度拟合的最大池和减少展平参数数量的全局平均池。输出将是 30 个浮点数，表示 15 个关键点的 x，y 坐标序列。</p><p id="8f36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是在<a class="ae ls" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank"> Keras </a>中的实现:</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="1513" class="mo ku iq mk b gy mp mq l mr ms">model = Sequential()</span><span id="623d" class="mo ku iq mk b gy mt mq l mr ms">model.add(BatchNormalization(input_shape=(96, 96, 1)))</span><span id="cc5d" class="mo ku iq mk b gy mt mq l mr ms">model.add(Convolution2D(24, 5, 5, border_mode=”same”, init=’he_normal’, input_shape=(96, 96, 1), dim_ordering=”tf”))<br/>model.add(Activation(“relu”))<br/>model.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2), border_mode=”valid”))</span><span id="f4da" class="mo ku iq mk b gy mt mq l mr ms">model.add(Convolution2D(36, 5, 5))<br/>model.add(Activation(“relu”))<br/>model.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2), border_mode=”valid”))</span><span id="0657" class="mo ku iq mk b gy mt mq l mr ms">model.add(Convolution2D(48, 5, 5))<br/>model.add(Activation(“relu”))<br/>model.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2), border_mode=”valid”))</span><span id="3b7e" class="mo ku iq mk b gy mt mq l mr ms">model.add(Convolution2D(64, 3, 3))<br/>model.add(Activation(“relu”))<br/>model.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2), border_mode=”valid”))</span><span id="eb27" class="mo ku iq mk b gy mt mq l mr ms">model.add(Convolution2D(64, 3, 3))<br/>model.add(Activation(“relu”))</span><span id="6139" class="mo ku iq mk b gy mt mq l mr ms">model.add(GlobalAveragePooling2D());</span><span id="7d34" class="mo ku iq mk b gy mt mq l mr ms">model.add(Dense(500, activation=”relu”))<br/>model.add(Dense(90, activation=”relu”))<br/>model.add(Dense(30))</span></pre><p id="3eb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能希望选择<a class="ae ls" href="http://Root Mean Square Propagation" rel="noopener ugc nofollow" target="_blank">均方根传播</a> (rmsprop)优化器和<a class="ae ls" href="https://en.wikipedia.org/wiki/Mean_squared_error" rel="noopener ugc nofollow" target="_blank">均方误差</a> (MSE)作为您的损失函数和精度指标。</p><p id="eeb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅仅通过一些琐碎的技巧，如对输入图像的<a class="ae ls" href="https://arxiv.org/abs/1502.03167" rel="noopener ugc nofollow" target="_blank">批量归一化</a>，全局平均池以及<a class="ae ls" href="https://www.tensorflow.org/api_docs/python/tf/contrib/keras/initializers/he_normal" rel="noopener ugc nofollow" target="_blank">正常</a>权重初始化，你可以在大约 30 个训练时期获得 80-90%的验证准确率和损失&lt; 0.001:</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="121d" class="mo ku iq mk b gy mp mq l mr ms">model.compile(optimizer=’rmsprop’, loss=’mse’, metrics=[‘accuracy’])</span><span id="b8e3" class="mo ku iq mk b gy mt mq l mr ms">checkpointer = ModelCheckpoint(filepath=’face_model.h5', verbose=1, save_best_only=True)</span><span id="7516" class="mo ku iq mk b gy mt mq l mr ms">epochs = 30</span><span id="2309" class="mo ku iq mk b gy mt mq l mr ms">hist = model.fit(X_train, y_train, validation_split=0.2, shuffle=True, epochs=epochs, batch_size=20, callbacks=[checkpointer], verbose=1)</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/afd17f23c569604bafa9f71d594f927b.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*wQ6QBOJimsVXhpNUivQLdw.png"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/62d9504f011a7705d989a90ca70869c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*VbKZ8xJrDeX4wgZWRtHVqQ.png"/></div></figure><p id="0fe2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，要预测关键点的位置，只需运行:</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="6986" class="mo ku iq mk b gy mp mq l mr ms">features = model.predict(region, batch_size=1)</span></pre><p id="8029" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就这样。你现在已经掌握了检测面部关键点的艺术！</p><p id="94cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，预测的结果将是每个关键点的 15 对 x，y 坐标，顺序如下图所示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/0196b7fefc405627311607eb99d3796e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*aKejx96JSAAV6UqMGEAPcg.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Saving you some time…</figcaption></figure><p id="f367" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想做得更好，你可能需要做一些额外的功课:</p><ul class=""><li id="db11" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated">尝试如何减少卷积层数和滤波器尺寸，同时保持准确性并提高推断速度</li><li id="a3bb" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">用迁移学习代替卷积部分(<a class="ae ls" href="https://arxiv.org/abs/1610.02357" rel="noopener ugc nofollow" target="_blank">例外</a>是我的最爱)</li><li id="b22a" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">使用更详细的数据集</li><li id="834b" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">做一些先进的图像增强，以提高鲁棒性</li></ul><p id="c449" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能会发现这一切都太容易了；如果你想要一个挑战，那就转向 3D，看看<a class="ae ls" href="https://research.fb.com/wp-content/uploads/2016/11/deepface-closing-the-gap-to-human-level-performance-in-face-verification.pdf" rel="noopener ugc nofollow" target="_blank">脸书</a>和<a class="ae ls" href="http://research.nvidia.com/sites/default/files/publications/laine2017sca_paper_0.pdf" rel="noopener ugc nofollow" target="_blank">英伟达</a>是如何追踪人脸的。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="8a53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然，你可以使用这种新学到的魔法来完成一些你一直想做但不知道如何做的重要事情:</p><ul class=""><li id="f478" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated">在视频聊天时，在脸上放置令人讨厌的物体，如太阳镜、怪异的帽子、胡子等。</li><li id="69e6" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">在朋友、敌人、动物和物品之间交换面孔</li><li id="3f9c" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">通过允许在自拍实时视频上测试新发型、珠宝或化妆品，增加了人们的虚荣心</li><li id="f1e8" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">检测您的员工是否喝得太醉(或不够醉)而无法执行分配的任务</li><li id="04ef" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">如果出于某种奇怪的原因，你想自动处理情绪，就要识别视频中人们的主要情绪</li><li id="ddc3" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">使用<a class="ae ls" href="https://en.wikipedia.org/wiki/Generative_adversarial_networks" rel="noopener ugc nofollow" target="_blank"> GANs </a>进行实时面部到卡通的转换，并根据网络摄像头上你自己的面部弯曲卡通面部，以模仿你的动作、说话和情绪</li></ul></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="9ba8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你知道如何制作自己的视频聊天过滤器了吧！现在就写一个怎么样？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nr"><img src="../Images/ef71c9f038e9aef090dcf81a13d53c2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kphA-vO990dlXHT7Je0-7w.png"/></div></div></figure></div></div>    
</body>
</html>