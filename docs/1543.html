<html>
<head>
<title>Full Stack Basics for Data Scientists and Other Non-Web Developers, Part 2: jQuery, D3, AJAX and Flask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向数据科学家和其他非Web开发人员的完整堆栈基础知识，第2部分:jQuery、D3、AJAX和Flask</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/full-stack-basics-for-data-scientists-and-other-non-web-developers-part-2-jquery-d3-ajax-and-90f629c6b952?source=collection_archive---------5-----------------------#2017-09-17">https://towardsdatascience.com/full-stack-basics-for-data-scientists-and-other-non-web-developers-part-2-jquery-d3-ajax-and-90f629c6b952?source=collection_archive---------5-----------------------#2017-09-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d09d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是关于基本的全栈web开发工具的2部分系列的第2部分，数据科学家需要这些工具来在web上构建基本的交互式可视化。第一部分涵盖了HTML和CSS。在这一部分中，我们将实现我们的承诺，教你如何制作<em class="km">交互式</em>可视化，包括目前最流行的web编程语言JavaScript，两个最流行的库jQuery和D3.js，以及一个优秀的Python后端框架Flask。</p><h1 id="2770" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">Java Script语言</h1><p id="5853" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">基本上，HTML用于在页面上放置元素，CSS用于设置这些元素的样式，包括将它们放置在页面上相对于彼此的特定位置，Javascript用于在元素被放置在页面上后对其进行操作。例如，D3.js只是一堆处理特定HTML元素类的代码——即，<a class="ae kl" href="https://en.wikipedia.org/wiki/Scalable_Vector_Graphics" rel="noopener ugc nofollow" target="_blank">支持向量图形</a> (SVG)元素，如矩形和圆形。</p><p id="4281" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Javascript可以用来以你能想到的所有方式操纵元素。它可以改变元素的样式，或者直接改变样式，或者给元素分配一个不同的CSS类。它可以在页面上移动元素。</p><p id="463d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些都可以用普通的Javascript来完成。然而，我们甚至不会在这里深入讨论如何做到这一点，因为最好的做法是使用目前最流行的Javascript库<a class="ae kl" href="https://en.wikipedia.org/wiki/JQuery" rel="noopener ugc nofollow" target="_blank">、</a><a class="ae kl" href="https://jquery.com" rel="noopener ugc nofollow" target="_blank"> jQuery </a>来完成这样的任务。</p><h1 id="265a" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">jQuery</h1><p id="89dc" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">jQuery允许您使用<code class="fe lq lr ls lt b">$</code>语法轻松地选择页面上的元素，特别是如果它们有一个指定的“id”或“class”的话。您可以使用与CSS类似的语法选择特定类的所有元素，例如，<code class="fe lq lr ls lt b">$(".fruit")</code>选择所有具有类<code class="fe lq lr ls lt b">fruit</code>的元素，<code class="fe lq lr ls lt b">$("#banana")</code>将只选择具有<em class="km"> id </em>的<code class="fe lq lr ls lt b">banana</code>的元素。</p><p id="c588" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们做到了这一点，就有了相对直观、简单的语法来操作这些元素。例如，假设我们已经选择了页面上class <code class="fe lq lr ls lt b">fruit</code>的所有元素；默认情况下，jQuery会将它们读入一个数组，所以我们可以使用下面的<code class="fe lq lr ls lt b">$</code>和<code class="fe lq lr ls lt b">each</code>语法遍历它们并更改它们的属性:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="b930" class="mc ko iq lt b gy md me l mf mg">var bananas = $(".banana");<br/>bananas.each(function() {<br/>  $(this).text("My text now says 'banana'");<br/>  $(this).addClass("fruit");<br/>}</span></pre><p id="1f26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你明白了。我们将在下面的函数中广泛使用这种模式。</p><p id="aa11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有另外两个基础工具，每个数据科学家都应该知道，它们被用来构建这个数独应用<code class="fe lq lr ls lt b"><a class="ae kl" href="https://d3js.org" rel="noopener ugc nofollow" target="_blank">D3.JS</a></code>和<code class="fe lq lr ls lt b"><a class="ae kl" href="http://adaptivepath.org/ideas/ajax-new-approach-web-applications/" rel="noopener ugc nofollow" target="_blank">AJAX</a></code>。</p><h1 id="8344" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">D3。射流研究…</h1><p id="e870" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">你可能在网上看过非常酷的<a class="ae kl" href="https://bl.ocks.org/mbostock" rel="noopener ugc nofollow" target="_blank"/><code class="fe lq lr ls lt b"><a class="ae kl" href="https://bl.ocks.org/mbostock" rel="noopener ugc nofollow" target="_blank">D3.JS</a></code><a class="ae kl" href="https://bl.ocks.org/mbostock" rel="noopener ugc nofollow" target="_blank">可视化</a>。我认为这些展示了<code class="fe lq lr ls lt b">D3.JS</code>的力量是很棒的，但是华而不实的演示从根本上来说是为了记忆和让正在发生的事情看起来像魔术，而不是照亮表面下正在发生的事情。事实上，你说“他们是怎么做到的？”是好设计的标志。这是相反的——我想让你确切地知道我是怎么做的！</p><p id="02d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，华丽的D3可视化掩盖了D3在做什么。 D3到底在做什么？D3是一个Javascript库。基本上，它选择和操作页面上的HTML元素——就是这样。它使用的语法虽然需要时间来适应，但却非常有表现力和简洁。在我看来，初学者纠结D3的很大一部分原因。他们的头脑中没有这样的思维模式:</p><ul class=""><li id="a50c" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">一个页面上存在HTML元素——即使这些是像<code class="fe lq lr ls lt b">&lt;svg&gt;</code>或<code class="fe lq lr ls lt b">&lt;circle&gt;</code>这样的元素(通常是D3操作的元素),它们仍然是HTML元素。</li><li id="5ba9" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><em class="km"> D3。JS只是使用Javascript来操作这些元素</em>——仅此而已。</li></ul><p id="994b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那是D3。我们一会儿会谈到它是如何在数独应用程序中使用的。首先:什么是AJAX，我们为什么要了解它？</p><h1 id="0b92" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">创建交互式、快速动态网页应用的网页开发技术</h1><p id="86bf" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated"><a class="ae kl" href="https://en.wikipedia.org/wiki/Ajax_(programming)" rel="noopener ugc nofollow" target="_blank"> AJAX </a>代表异步Javascript和XML。它用于以下在现代web上非常常见的用例:当一个页面加载时，它最初只是加载向用户显示“初始”页面所需的所有HTML和CSS想象一下脸书在你的新闻提要上加载前几个条目。但是，一旦在页面上执行了操作(例如，用户向下滚动或单击按钮)，您可能希望用新信息更新页面上的内容。此外，这些信息可能必须来自外部来源，比如服务器。为了做到这一点，Javascript有一个名为<a class="ae kl" href="http://api.jquery.com/jquery.ajax/" rel="noopener ugc nofollow" target="_blank"> AJAX </a>的内置函数，它可以向外部服务器或函数发出请求，获取所需的信息，然后根据这些信息更新页面上的内容，完成所有这些——这是关键部分— <em class="km">,而无需重新加载页面</em>。AJAX是你可以向下滚动脸书新闻提要的原因，脸书不必把你带到一个包含“第二页”信息的新网站——它发出一个AJAX请求，得到的响应只是被添加到当前页面。</p><p id="025b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，让我们介绍一个更接近核心数据科学工具包的工具:Flask。</p><h1 id="a0a9" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">瓶</h1><p id="967c" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">对于这个项目来说，Flask 允许您定义不同的路径，将Javascript数据路由到实际操作这些数据的Python函数。因此，如果您想拥有一个接受一个数字并将其乘以2的Python函数，您可以定义一个<code class="fe lq lr ls lt b">multiply</code>路由，在该路由后面有一个Python中的<code class="fe lq lr ls lt b">multiply_by_two</code>函数，并让Javascript调用该路由(使用AJAX，我们将会看到)。或者，如果你想有一个函数，例如，接受一个数独板，并从板上消除一个数字作为候选，你也可以这样做。理论上，我们可以用Javascript完成所有这些工作。但是，因为Python是数据科学的标准语言，也因为它是一种比Javascript更简洁的通用语言——以及(真正的原因)Peter Norvig用Python写了他的文章“<a class="ae kl" href="http://norvig.com/sudoku.html" rel="noopener ugc nofollow" target="_blank">如何解决每一个数独</a>”——我们将使用Python编写数独函数，并使用Flask和AJAX在两者之间建立接口。</p><h1 id="d573" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">这些工具如何组合在一起</h1><p id="3193" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">数独应用的代码是<a class="ae kl" href="https://github.com/SethHWeidman/Sudoku_solver" rel="noopener ugc nofollow" target="_blank">这里是</a>。我们现在将介绍各种功能及其作用。</p><p id="8f6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当用户导航到数独应用程序的<a class="ae kl" href="http://sethweidman.com/app/sudoku/" rel="noopener ugc nofollow" target="_blank">时，他们正在前往</a><a class="ae kl" href="https://github.com/SethHWeidman/Sudoku_solver/blob/master/main.py" rel="noopener ugc nofollow" target="_blank">烧瓶应用程序</a>中的路线<code class="fe lq lr ls lt b"><a class="ae kl" href="https://github.com/SethHWeidman/Sudoku_solver/blob/master/main.py#L28" rel="noopener ugc nofollow" target="_blank">/</a></code>。</p><p id="9ab3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当用户点击<a class="ae kl" href="https://github.com/SethHWeidman/Sudoku_solver/blob/ac6c36495657ead14dd7fa69c0d26a969b986923/templates/index.html#L307" rel="noopener ugc nofollow" target="_blank">“逐步求解”</a>并点击<a class="ae kl" href="https://github.com/SethHWeidman/Sudoku_solver/blob/ac6c36495657ead14dd7fa69c0d26a969b986923/templates/index.html#L309" rel="noopener ugc nofollow" target="_blank">“开始”</a>时，它调用Python路由<code class="fe lq lr ls lt b"><a class="ae kl" href="https://github.com/SethHWeidman/Sudoku_solver/blob/master/main.py#L44" rel="noopener ugc nofollow" target="_blank">sudoku_action</a></code>。Flask知道如何将单选按钮的值作为一个<code class="fe lq lr ls lt b">request</code>对象读入数据，该对象的值是一个可以通过<code class="fe lq lr ls lt b">request.form</code>访问的字典。特别是，它可以计算出使用<code class="fe lq lr ls lt b"><a class="ae kl" href="https://github.com/SethHWeidman/Sudoku_solver/blob/ac6c36495657ead14dd7fa69c0d26a969b986923/main.py#L56" rel="noopener ugc nofollow" target="_blank">request.form['type']</a></code>选择了哪个单选按钮。如果它检测到“逐步求解”已被选中，它将简单地呈现HTML模板<code class="fe lq lr ls lt b"><a class="ae kl" href="https://github.com/SethHWeidman/Sudoku_solver/blob/master/templates/sudoku_action.html" rel="noopener ugc nofollow" target="_blank">sudoku_action.html</a></code>。</p><p id="671f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该模板将立即启动<code class="fe lq lr ls lt b">callFlaskUpdateOne</code>功能:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="dcec" class="mc ko iq lt b gy md me l mf mg">function callFlaskUpdateOne() {      <br/>  $.ajax({        <br/>    url: {{ url_for('update_one')}},<br/>    data: extractData(),<br/>    type: 'POST',<br/>    success: function(response) {<br/>      updateClasses(response['values']);  <br/>      displayMessage(response['message'])<br/>      highlightCell(response['peer']);          <br/>      callFlaskUpdateOne();        <br/>    },        <br/>    error: function(error) {<br/>      console.log(error);<br/>    }    <br/>  })  <br/>};</span></pre><p id="7390" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个函数使用jQuery中特定的<code class="fe lq lr ls lt b">ajax</code>函数。作为参数，该函数需要</p><ul class=""><li id="c6cb" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">一个<code class="fe lq lr ls lt b">url</code>，定义在哪里进行函数调用。</li><li id="4270" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe lq lr ls lt b">data</code>，告诉它向那个函数发送什么数据。</li><li id="5530" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">请求的<code class="fe lq lr ls lt b">type</code>，对于我们的目的来说是一个<code class="fe lq lr ls lt b">POST</code>请求。</li></ul><p id="7eb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以:启动这个函数首先调用函数<code class="fe lq lr ls lt b">update_one</code>的Python route。将发送到该函数的数据在<code class="fe lq lr ls lt b">extractData() </code>函数中。这个函数的目标是从实际的网页中获取关于数独板当前状态的所有数据。这样做的方式是我们到目前为止所学概念的直接应用，它利用了这样一个事实，即我们可以将关于数独板的实际数据存储在Python和Javascript都能理解的结构中。</p><p id="adbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Python和JavaScript都“理解”的数独棋盘结构就是这个结构</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="99b0" class="mc ko iq lt b gy md me l mf mg">{‘A1’: ‘123456789’, 'A2': '1245', 'A3': 8, ...} </span></pre><p id="beb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也就是说，它是一本有81个词条的词典。这些物品的81个键是字母A-I和数字1-9的81种组合。作为值，它们是包含所有尚未从方块中消除的数字的字符串。此外，每个<code class="fe lq lr ls lt b"><a class="ae kl" href="https://github.com/SethHWeidman/Sudoku_solver/blob/master/templates/sudoku_action.html#L11" rel="noopener ugc nofollow" target="_blank">cell</a></code>都被赋予了一个职业<code class="fe lq lr ls lt b"><a class="ae kl" href="https://github.com/SethHWeidman/Sudoku_solver/blob/master/templates/sudoku_action.html#L11" rel="noopener ugc nofollow" target="_blank">sudoku-solving</a></code>和一个<code class="fe lq lr ls lt b"><a class="ae kl" href="https://github.com/SethHWeidman/Sudoku_solver/blob/master/templates/sudoku_action.html#L11" rel="noopener ugc nofollow" target="_blank">name</a></code> <a class="ae kl" href="https://github.com/SethHWeidman/Sudoku_solver/blob/master/templates/sudoku_action.html#L11" rel="noopener ugc nofollow" target="_blank">属性</a>，对应于前面提到的名字字母组合之一，比如<code class="fe lq lr ls lt b">D5</code>。</p><p id="f044" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，在任何给定的时间，我们都可以使用jQuery提取具有该类名的所有HTML <em class="km">元素</em>，然后简单地遍历每个元素，并将“data”中的元素赋值为将HTML元素的“name”作为其键，将HTML元素的<em class="km"> text </em>作为其值。</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="0b71" class="mc ko iq lt b gy md me l mf mg">function extractData() {<br/>      output_dict = {};<br/>      var numbers = $(".sudoku-solving");<br/>      numbers.each(function() {<br/>         output_dict[$(this).attr('name')] = $(this).text();<br/>      })<br/>      return output_dict;<br/>    };</span></pre><p id="bf20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，在以<code class="fe lq lr ls lt b">output_dict</code>开始的行中，我们使用<code class="fe lq lr ls lt b">[]</code>符号在字典中查找元素，就像我们在Python中一样。</p><p id="f78a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们用<code class="fe lq lr ls lt b">ajax</code>函数中的<a class="ae kl" href="https://github.com/SethHWeidman/Sudoku_solver/blob/ac6c36495657ead14dd7fa69c0d26a969b986923/templates/sudoku_action.html#L393" rel="noopener ugc nofollow" target="_blank">行</a>和<code class="fe lq lr ls lt b">data: extractData()</code>将数据发送给Python。这是一个很好的例子，说明了HTML、CSS、jQuery和AJAX是如何交互的，我们将在这个应用中介绍的其他功能也是根据类似的原理运行的。</p><p id="ab9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦Python接收到数据，它<a class="ae kl" href="https://github.com/SethHWeidman/Sudoku_solver/blob/master/main.py#L74" rel="noopener ugc nofollow" target="_blank">就以相同的形式将数据发送回Javascript </a>，除了Python Sudoku代码已经修改了数据，以便从棋盘上的一个单元格中删除一个数字作为候选。它还向Javascript发回一条将显示在屏幕上的“消息”,以及一个表示已经去掉数字的单元格的“对等体”:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="41e0" class="mc ko iq lt b gy md me l mf mg">return jsonify(values=new_values, message=message, peer=peer)</span></pre><p id="07ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(阅读<a class="ae kl" href="http://norvig.com/sudoku.html" rel="noopener ugc nofollow" target="_blank">经典的Peter Norvig数独文章</a>并查看<code class="fe lq lr ls lt b"><a class="ae kl" href="https://github.com/SethHWeidman/Sudoku_solver/blob/master/python/sudoku.py" rel="noopener ugc nofollow" target="_blank">sudoku.py</a></code>中的<code class="fe lq lr ls lt b"><a class="ae kl" href="https://github.com/SethHWeidman/Sudoku_solver/blob/master/python/sudoku.py#L96" rel="noopener ugc nofollow" target="_blank">eliminate_one</a></code>功能)</p><p id="59e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此响应由<code class="fe lq lr ls lt b">ajax</code>功能:<code class="fe lq lr ls lt b">success: function(response)</code>接收；收到此响应后，将运行几个JavaScript函数:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="8e53" class="mc ko iq lt b gy md me l mf mg">updateClasses(response['values']);          displayNewData(response['values']);          displayMessage(response['message'])          highlightCell(response['peer']);</span></pre><p id="1b98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们一个接一个地看一下:</p><h2 id="d80e" class="mc ko iq bd kp mv mw dn kt mx my dp kx jy mz na lb kc nb nc lf kg nd ne lj nf bi translated">更新类</h2><p id="1fe4" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">第一个功能是<code class="fe lq lr ls lt b">updateClasses</code>。这个函数循环遍历每个数独<code class="fe lq lr ls lt b">cells</code>。对于这些单元中的每一个，它查看从Python接收回的数据，看它接收到的数据的长度是否为1，这意味着单元被“求解”。如果是这样，它将移除一个名为<code class="fe lq lr ls lt b"><a class="ae kl" href="https://github.com/SethHWeidman/Sudoku_solver/blob/master/static/stylesheets/style.css#L18" rel="noopener ugc nofollow" target="_blank">sudoku-not-solved</a></code>的CSS类，该类对单元格中尚未求解的数字进行样式化(例如，定位和调整大小)。移除了该类之后，它添加了一个新的CSS类<code class="fe lq lr ls lt b"><a class="ae kl" href="https://github.com/SethHWeidman/Sudoku_solver/blob/master/static/stylesheets/style.css#L2" rel="noopener ugc nofollow" target="_blank">sudoku_number</a></code>,其效果是增加该单元格中剩余数字的大小，并使其在父单元格中居中:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="7ce7" class="mc ko iq lt b gy md me l mf mg">function updateClasses(input_sudoku) {<br/>  var numbers = $(".sudoku-solving");<br/>  numbers.each(function() {<br/>    var candidate_numbers = input_sudoku[$(this).attr("name")];<br/>    if (candidate_numbers.length == 1) {<br/>       $(this).text(candidate_numbers);        </span><span id="741a" class="mc ko iq lt b gy ng me l mf mg">       $(this).addClass("sudoku_number"); <br/>       $(this).removeClass("sudoku-not-solved"); <br/>      }    <br/>    });  <br/>  };</span></pre><h2 id="4552" class="mc ko iq bd kp mv mw dn kt mx my dp kx jy mz na lb kc nb nc lf kg nd ne lj nf bi translated">显示新数据</h2><p id="b63a" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">一旦更新了类，就调用“displayNewData”函数。这个函数简单地遍历页面上的所有元素，并根据Python接收到的数据更新它们的文本。</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="c895" class="mc ko iq lt b gy md me l mf mg">function displayNewData(update_sudoku) {     <br/>  var numbers = $(".sudoku-solving");<br/>  numbers.each(function() {       <br/>    $(this).text(update_sudoku[$(this).attr('name')]);<br/>    });<br/>  };</span></pre><h2 id="b667" class="mc ko iq bd kp mv mw dn kt mx my dp kx jy mz na lb kc nb nc lf kg nd ne lj nf bi translated">显示消息</h2><p id="5af3" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">现在我们到了涉及D3的部分。在将原始的数独放到页面上时，一个<code class="fe lq lr ls lt b">&lt;svg&gt;</code>元素被附加到数独板的底部，宽度为500，高度为100。</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="f1f3" class="mc ko iq lt b gy md me l mf mg">var message_area = d3.selectAll(".update_message")<br/>  .append("svg")<br/>  .attr("width", 500)<br/>  .attr("height", 100);</span></pre><p id="d335" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成AJAX请求后，JavaScript会收到一条消息。使用D3，我们将消息附加到SVG对象，并将其放在对象底部附近的<code class="fe lq lr ls lt b">y=80</code>处，并使其透明。然后，我们使用d3做一个过渡，将文本向上移动到<code class="fe lq lr ls lt b">y=50</code>并移除透明度，这样它就好像“出现”在屏幕上。然后，我们暂停500毫秒，然后我们从屏幕上移除对象，再用半秒钟将文本移回<code class="fe lq lr ls lt b">y=80</code>，并使其再次透明。以下是所有这些的代码:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="5389" class="mc ko iq lt b gy md me l mf mg">function displayMessage(message) {    <br/>var variable_message = message_area.append("text")<br/>  .text(message)<br/>  .attr("x", 100)<br/>  .attr("y", 80)<br/>  .attr("fill", "red")<br/>  .attr("opacity", 0)<br/>  .transition()<br/>  .duration(500)<br/>  .attr("y", 50)<br/>  .attr("opacity", 1)<br/>  .transition()<br/>  .duration(500)<br/>  .transition()<br/>  .duration(500)<br/>  .attr("y", 80)<br/>  .attr("opacity", 0);<br/>};</span></pre><p id="0e6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该函数突出显示一个特定的单元格，即Python代码返回的单元格。首先，它使用Python返回的函数名选择单元格。然后，它使用JavaScript函数<code class="fe lq lr ls lt b">setTimeout</code>暂停2秒钟，然后从单元格中删除这个类。这比我想象的要简单:CSS中的<code class="fe lq lr ls lt b"><a class="ae kl" href="https://github.com/SethHWeidman/Sudoku_solver/blob/ac6c36495657ead14dd7fa69c0d26a969b986923/static/stylesheets/style.css#L89" rel="noopener ugc nofollow" target="_blank">highlighted-cell</a></code> <a class="ae kl" href="https://github.com/SethHWeidman/Sudoku_solver/blob/ac6c36495657ead14dd7fa69c0d26a969b986923/static/stylesheets/style.css#L89" rel="noopener ugc nofollow" target="_blank">类</a>处理得很好。下面是Javascript代码:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="1a9c" class="mc ko iq lt b gy md me l mf mg">function highlightCell(cell) {</span><span id="da70" class="mc ko iq lt b gy ng me l mf mg">  $('#'.concat(cell)).addClass('highlighted-cell')<br/>  setTimeout(function() {<br/>    $('#'.concat(cell)).removeClass('highlighted-cell');<br/>  }, 2000)<br/>};</span></pre><h2 id="869a" class="mc ko iq bd kp mv mw dn kt mx my dp kx jy mz na lb kc nb nc lf kg nd ne lj nf bi translated">把这些放在一起</h2><p id="de15" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">所以，每三秒钟，我们做以下事情:</p><ol class=""><li id="1720" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk nh mn mo mp bi translated">使用jQuery从页面中提取数据。</li><li id="56a5" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk nh mn mo mp bi translated">调用Python来获取“新数据”以显示在板上。</li><li id="d749" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk nh mn mo mp bi translated">通过更新页面上事物的类别，使页面上任何有一个数字的单元格“变大”。</li><li id="78bb" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk nh mn mo mp bi translated">实际显示新数据。</li><li id="4b25" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk nh mn mo mp bi translated">在屏幕底部的SVG上显示消息。</li><li id="134c" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk nh mn mo mp bi translated">突出显示已更新的单元格。</li></ol><h2 id="465b" class="mc ko iq bd kp mv mw dn kt mx my dp kx jy mz na lb kc nb nc lf kg nd ne lj nf bi translated">看到它的实际应用</h2><p id="cd01" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">导航到<a class="ae kl" href="http://sethweidman.com/app/sudoku" rel="noopener ugc nofollow" target="_blank">sethweidman.com/app/sudoku</a>。这个应用程序预装了我在谷歌上找到的第一个“简单数独”。点击“运行数独”来看看它的行动！</p><h1 id="87b7" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">结论</h1><p id="c76b" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">即使您自己不是web开发人员——我想大多数人都不是——我也希望这个由两部分组成的系列文章能让您了解web开发的基本工具是如何工作的，这样您至少可以更自信地参与到团队关于应该构建什么以及应该如何构建的讨论中。对于正在阅读这篇文章的数据科学家来说:我相信，如果你花时间学习这些工具，你会成为更有效的数据科学家，这样你就可以构建可视化，更好地向你的老板、客户甚至同事说明你正在做什么——毕竟，我们在Metis 教授这些工具是有原因的！</p></div></div>    
</body>
</html>