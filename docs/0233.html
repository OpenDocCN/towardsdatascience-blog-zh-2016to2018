<html>
<head>
<title>A MapReduce overview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MapReduce概述</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-mapreduce-overview-6f2d64d8d0e6?source=collection_archive---------2-----------------------#2017-04-03">https://towardsdatascience.com/a-mapreduce-overview-6f2d64d8d0e6?source=collection_archive---------2-----------------------#2017-04-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="5716" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">针对高级编码人员的介绍说明，试图应对您可能也遇到过的任何劝阻。</p></blockquote><p id="819f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">当我第一次开始阅读MapReduce时，几乎每个教程都有Java或C++先决条件的提示。然而，在科技界还有一种过时(而且越来越少)的思维模式，即成为程序员需要CS学位。我发现这是非常令人惊讶的，有多少教程有这种前兆，只是让他们通过完全可复制的进出反正。</p><p id="6269" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">说到<strong class="jt ir">而不是</strong>重新发明轮子，抽象就是一切。我们发现自己越少需要记住每个算法的二进制执行，我们就越接近实现它。开发的目的是让<strong class="jt ir"> <em class="js">进化</em> </strong>，如果我们不使用这种技术，我们还不如回到勒德派时代，在工会组织的恐龙牧场用套索套住迅猛龙，只为了赚一些诚实的郁金香球茎。</p><p id="06b2" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">“跳进来”的想法听起来很忌讳，但不要误解。这并不是说应该忽视整体的理解。了解你的方法的功能和相关的依赖关系对于避免不可逆转的错误是至关重要的。但是要达到这个目标并不需要回到学校或者学习一门新的语言。</p><p id="591f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">也就是说，我将引用<a class="ae ks" href="https://courses.cs.washington.edu/courses/cse490h/07wi/readings/IntroductionToParallelProgrammingAndMapReduce.pdf" rel="noopener ugc nofollow" target="_blank">这篇</a>文章，来自《并行编程和MapReduce入门》课程。现在让我们开始</p><h1 id="28de" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">历史</h1><p id="78d0" class="pw-post-body-paragraph jq jr iq jt b ju lr jw jx jy ls ka kb kp lt ke kf kq lu ki kj kr lv km kn ko ij bi translated">回到计算的初期，程序是串行的，即由一系列指令组成，每个指令被一个接一个地执行，就像一个人乘坐爱情船的队列。</p><p id="343e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">开发并行化</strong>是为了提高性能和效率。它将进程原子化，并同时执行它们。这些碎片化的指令在不同的CPU上同时运行，要么来自一台机器，要么来自<a class="ae ks" href="https://d21ii91i3y6o6h.cloudfront.net/gallery_images/from_proof/3442/large/1418280711/die-cut-stickers.png" rel="noopener ugc nofollow" target="_blank"><em class="js">clouuddd</em></a><em class="js">中的<em class="js">。</em></em></p><p id="d254" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">除了加速这个过程，它还创造了一个解决方案，当你在本地资源上受到限制时，可以处理<strong class="jt ir">大量的</strong>数据集。然而，一个<strong class="jt ir">实际的先决条件</strong>是您拥有对所有数据的同一个存储系统的块级(物理层)访问权，即</p><h1 id="c48f" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">集群文件系统</h1><p id="0f8b" class="pw-post-body-paragraph jq jr iq jt b ju lr jw jx jy ls ka kb kp lt ke kf kq lu ki kj kr lv km kn ko ij bi translated">一个<strong class="jt ir"> </strong>共享磁盘文件系统。最常见的CFS类型使用一个<strong class="jt ir">存储区域网络</strong> (SAN)来允许多台计算机在块级别获得直接的磁盘访问。这由您的数据库管理系统(DBMS)进一步提取。或者，<strong class="jt ir">分布式文件系统</strong>不这样做，而是使用网络发送数据。</p><p id="4d28" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">操作它的系统增加了并发控制和串行化的机制，将数据结构编译成可存储的格式，用于网络传输、内存缓冲等。</p><p id="57e8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">此外，CFS使用隔离，在级联故障的预防性情况下隔离集群中的单个节点(稍后将更详细地讨论)。</p><p id="b3a9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">一旦确定了这一点，您就可以继续</p><h1 id="6d73" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">考虑到你的计划</h1><p id="9d3e" class="pw-post-body-paragraph jq jr iq jt b ju lr jw jx jy ls ka kb kp lt ke kf kq lu ki kj kr lv km kn ko ij bi translated">创建并行程序的第一步是确定一组可以并发运行的任务和/或数据分区。</p><p id="b36e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">有时，一个进程根本不能同时运行，就像在斐波那契函数中一样:</p><p id="4045" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">Fk = Fk-2 + Fk-1</p><p id="cb3b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">这不能并行化，因为每个计算值都依赖于它前面的值。</p><p id="58d9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">更常见的情况是，您将处理大量一致的数据，这些数据必须进行处理，但也可以进行分区。考虑一个字符串数组:</p><p id="8216" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">['暴躁'，'傀儡'，'蜡笔']</p><p id="0cc7" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">可以分成大小相等的子阵列:</p><p id="f5a7" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">['暴躁'] ['傀儡'] ['蜡笔']</p><p id="73d5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">如果每个子阵列都没有计算依赖性，没有互通需求，并且可以遵循相同的迭代过程，那么它就是并行计算的理想候选！有一种常见的实现技术叫做<em class="js"/><strong class="jt ir"><em class="js">master/worker:</em></strong></p><p id="9726" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">主人:</strong></p><p id="b5bb" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">—初始化数组，并根据可用的<strong class="jt ir">工作线程</strong>将其拆分</p><p id="5310" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">—给每个<strong class="jt ir">工人</strong>发送他们的子阵列</p><p id="e056" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">—接收来自每个<strong class="jt ir">工作者</strong>的响应</p><p id="6e36" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">工人:</strong></p><p id="8bf6" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">—从<strong class="jt ir">主机</strong>接收子阵列</p><p id="bb7b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">—对子阵列执行处理</p><p id="062b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">—将结果返回给<strong class="jt ir">主机</strong></p><p id="71f9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">如果我们使用以前的子阵列，工人们将完成同样多的工作。该模型将实现<em class="js">静态负载平衡</em>。</p><p id="db05" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">负载平衡</strong>指的是在并行系统中的处理器之间分配任务的技术，以避免一些工作人员重复排队，而其他工作人员则处于空闲状态。为了激起一些想象，把它想象成共产主义的理想实现。</p><p id="0b9e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">虽然静态平衡器允许更少的开销，但它们没有考虑当前的网络负载。</p><p id="4edf" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">相反，<strong class="jt ir">dynamic</strong>balancer在考虑网络的同时，提供了更灵活、但计算成本更高的分配。</p><h1 id="48a2" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">主/工人示例:</h1><blockquote class="jn jo jp"><p id="24dc" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><strong class="jt ir"> <em class="iq">让我们以勾股定理为例来实现</em> </strong></p></blockquote><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/013b1c55de2d2e348cbbb03f0f275243.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*-ONW6p03XZIavRhLPub4gA.png"/></div></figure><p id="0018" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">这说明斜边(直角的对边)的平方等于其他两条边的平方之和，</p><p id="db1b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir"> a + b = c </strong></p><p id="f77c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">虽然这本身是一个非常简单的算法，但它还可以进一步分解:</p><blockquote class="jn jo jp"><p id="8d47" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq"> a_sq = a ^ 2 </em></p><p id="8691" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq"> b_sq = b^ 2 </em></p><p id="86dc" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq"> sum_ab =a_sq + b_sq </em></p><p id="f851" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq"> c = sqrt(sum_ab) </em></p></blockquote><p id="202a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">这可以用Python重写:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi me"><img src="../Images/ecd0f81081cc0462d27d049927570f5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*cV-3kgtOet5VQDVPr9KQMQ.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">cool cool. so at this point you are probably wondering</figcaption></figure><h1 id="f151" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是MapReduce rly</h1><p id="5f6d" class="pw-post-body-paragraph jq jr iq jt b ju lr jw jx jy ls ka kb kp lt ke kf kq lu ki kj kr lv km kn ko ij bi translated">在查看了一些并行编程示例之后，我们可以对MapReduce的实际功能有更多的了解。</p><p id="3faa" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">MapReduce是从像Lisp这样的函数式语言的<em class="js"> map </em>和<em class="js"> reduce </em>组合子中派生出来的。</p><p id="e3c4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">在Lisp中，<em class="js">映射</em>以<strong class="jt ir">函数</strong>和<strong class="jt ir">值序列</strong>的形式接受输入。然后，它迭代地将该函数应用于序列中的每个值。</p><p id="381b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">一个<em class="js">归约</em>使用一个二元运算组合一个序列的所有元素。例如，它可以使用“+”将一个序列中的所有元素相加。</p><p id="16cf" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">谷歌利用这一基础作为灵感，因此恰当的标题。与此一起使用的预期数据集非常庞大，通常需要存储在多台服务器上。因此，假定了并行化的必要性。</p><blockquote class="jn jo jp"><p id="3849" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">MapReduce为Google工程师提供了一个抽象概念来执行基本计算，同时隐藏并行化、负载平衡和容错的细节。</p></blockquote><p id="c406" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir"> MAP: </strong>由MapReduce库的用户编写，接受输入对并生成一组中间键/值对。MapReduce库将与同一个中间键<em class="js"> I </em>相关联的所有中间值组合在一起，并将它们传递给Reduce函数。</p><p id="1860" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">化简:</strong>也由用户编写，接受中间密钥I和以及该密钥的一组值。它将这些值合并在一起，形成一个可能更小的值集。</p><p id="d2ac" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">例如，考虑对大量文档中每个单词的出现次数进行计数的问题:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/0802649e310dc08204e43017198fd469.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*Ovv4Wxykkdd3lUL_S0LlTA.png"/></div></figure><p id="75c6" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">map函数发出每个单词以及相关出现次数的计数。然后reduce函数将特定单词发出的所有计数加在一起。</p><h1 id="df54" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak"> MapReduce执行概述</strong></h1><p id="10a5" class="pw-post-body-paragraph jq jr iq jt b ju lr jw jx jy ls ka kb kp lt ke kf kq lu ki kj kr lv km kn ko ij bi translated">通过将输入数据自动划分为一组<strong class="jt ir"> M </strong>分割或<em class="js">碎片</em>，映射调用被分布在多台机器上，这些将在多台机器上被处理。</p><p id="f3f3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">Reduce调用是通过使用用户指定的分区函数将中间密钥空间划分为<strong class="jt ir"> R </strong>个片段来分发的。</p><p id="71d3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">下图描述了MapReduce操作的整个流程序列:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/59f6a17905ec0d4df89a4448ab3e50f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g7loMfDE6uOq4wCxE5Mwug.png"/></div></div></figure><ol class=""><li id="ba24" class="mp mq iq jt b ju jv jy jz kp mr kq ms kr mt ko mu mv mw mx bi translated">用户程序中的MapReduce库首先将输入文件分成M段，通常为16MB-64MB/段。然后，它在一组机器上启动程序的许多副本。</li><li id="34f8" class="mp mq iq jt b ju my jy mz kp na kq nb kr nc ko mu mv mw mx bi translated">该程序的副本之一是特殊的:主程序。其余的是由主人分配工作的工人。有M个映射任务和R个归约任务要分配。主设备挑选空闲的工人，给每个工人分配M或R任务。</li><li id="52f7" class="mp mq iq jt b ju my jy mz kp na kq nb kr nc ko mu mv mw mx bi translated">被分配了地图任务的工作者读取相应输入碎片的内容。它从输入数据中解析出键/值对，并将每一对传递给用户定义的映射函数。产生的中间K/V对在存储器中缓冲。</li><li id="c10e" class="mp mq iq jt b ju my jy mz kp na kq nb kr nc ko mu mv mw mx bi translated">周期性地，缓冲对被写入本地磁盘，由分区函数划分成R个区域。这些缓冲对在本地磁盘上的位置被传递回master，master负责将这些位置转发给reduce workers。</li><li id="4199" class="mp mq iq jt b ju my jy mz kp na kq nb kr nc ko mu mv mw mx bi translated">当reduce worker从master获得位置时，它使用远程调用从磁盘读取缓冲的数据。当reduce worker读取了所有中间数据后，它会按照中间键对数据进行排序，这样所有相同的事件就会被分组在一起。(<strong class="jt ir">注意:如果中间数据量太大而不适合内存，则使用外部排序)</strong></li><li id="9a1c" class="mp mq iq jt b ju my jy mz kp na kq nb kr nc ko mu mv mw mx bi translated">reduce工作器遍历排序后的中间数据，对于遇到的每个唯一的中间键，它会将该键和相应的一组中间值传递给用户的Reduce函数。reduce函数的输出被附加到这个Reduce分区的最终输出文件中。</li><li id="75b8" class="mp mq iq jt b ju my jy mz kp na kq nb kr nc ko mu mv mw mx bi translated">当所有的map任务和reduce任务完成后，主机唤醒用户程序。此时，用户程序中的MapReduce调用返回到用户代码。</li></ol><p id="cda9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">执行注意事项:</strong></p><ul class=""><li id="c56e" class="mp mq iq jt b ju jv jy jz kp mr kq ms kr mt ko nd mv mw mx bi translated">成功完成后，MapReduce执行的输出可以在R输出文件中获得。</li><li id="8d1c" class="mp mq iq jt b ju my jy mz kp na kq nb kr nc ko nd mv mw mx bi translated">为了检测故障，主服务器会定期pings每个工作线程。如果在某个点之后没有工作者响应，则该工作者被标记为“失败”,并且该工作者的所有先前任务工作被重置，以变得有资格在其他工作者上重新调度。</li><li id="a768" class="mp mq iq jt b ju my jy mz kp na kq nb kr nc ko nd mv mw mx bi translated">发生故障时，会重新执行已完成的映射任务，因为它们的输出存储在故障机器的本地磁盘上，因此无法访问。完成的reduce任务不需要重新执行，因为它们的输出存储在全局文件系统中。</li></ul><h1 id="80d6" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">MapReduce示例</h1><p id="2c21" class="pw-post-body-paragraph jq jr iq jt b ju lr jw jx jy ls ka kb kp lt ke kf kq lu ki kj kr lv km kn ko ij bi translated">我将用几个程序示例来结束本文，这些程序可以很容易地表示为MapReduce计算，并有助于描绘M/R worker进程的画面:</p><p id="8744" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir"> Distributed Grep — </strong>如果匹配到一个模式，Map函数会发出一条线。reduce函数是一个恒等函数，它只是将提供的中间数据复制到输出中。</p><p id="202d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">URL访问频率统计—</strong>map函数处理网页请求日志，输出<strong class="jt ir"> &lt; URL，1 &gt; </strong>。reduce函数将同一URL的所有值加在一起，并发出一个<strong class="jt ir"> &lt; URL，total count &gt; </strong>对。</p><p id="c813" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">反向网络链接图— </strong>映射函数为每个链接输出<strong class="jt ir"> &lt;目标、源&gt; </strong>对，这些链接指向在名为“源”的页面中找到的目标URL。reduce函数连接与给定目标URL相关联的所有源URL的列表，并发出一对:<strong class="jt ir"> &lt; target，list(source) &gt; </strong>。</p><p id="54c5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">每台主机的术语向量— </strong>术语向量将文档中出现的最重要的单词概括为一列<strong class="jt ir"> &lt;单词、频率&gt; </strong>对。map函数为每个输入文档发出一个<strong class="jt ir"> &lt;主机名，术语向量&gt; </strong>对(其中主机名是从文档的URL中提取的)。reduce函数被传递给给定主机的所有每个文档的术语向量。它将这些术语向量加在一起，丢弃不常用的术语，并发出最终的<strong class="jt ir"> &lt;主机名、术语向量&gt; </strong>对。</p><p id="8c77" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">倒排索引—</strong>map函数解析每个文档，发出一个序列的<strong class="jt ir"> &lt; word，document ID &gt; </strong>对。reduce函数接受给定单词的所有对，对相应的文档ID进行排序，并发出一个<strong class="jt ir"> &lt;单词，列表(文档ID &gt; </strong>对。所有输出对的集合形成了一个简单的倒排索引。也很容易增加这个计算来跟踪单词<em class="js">的位置</em>。</p></div></div>    
</body>
</html>