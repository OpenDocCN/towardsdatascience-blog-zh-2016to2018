<html>
<head>
<title>Word Representation in Natural Language Processing Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自然语言处理中的词表示(一)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/word-representation-in-natural-language-processing-part-i-e4cd54fed3d4?source=collection_archive---------7-----------------------#2018-12-09">https://towardsdatascience.com/word-representation-in-natural-language-processing-part-i-e4cd54fed3d4?source=collection_archive---------7-----------------------#2018-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a1319abdee869d1c187ddccc9c3e1451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WALRM3RW8XGSbV_Avouqeg.jpeg"/></div></div></figure><div class=""/><p id="1309" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇博文中，我将讨论自然语言处理(NLP)中单词的表示。它是自然语言处理，尤其是神经网络的基本构件之一。它对深度学习模型的性能有着重要的影响。在博客文章的这一部分，我将描述相对简单的方法及其特点。</p><h2 id="3d5a" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">字典查找</h2><p id="9e32" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">最简单的方法是在字典中查找单词 ID。这种方法的基本步骤如下。</p><p id="76c6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，取语料库，可以是单词、句子或文本的集合。将它们预处理成预期的格式。一种方法是使用词汇化，这是一个将单词转换为其基本形式的过程。例如，给定单词<em class="lu"> walk，walking，walks </em>和<em class="lu">walk，</em>它们的引理将是<em class="lu"> walk </em>。然后，将预处理后的词汇保存到文件中，如<em class="lu">“vocabulary . txt”。</em></p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="91ef" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，通过创建单词和 ID 之间的映射来构建查找字典，即词汇表中的每个唯一单词都被分配一个 ID。</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="e67c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，将构建一个简单的查找字典，如下所示，从中可以查找单词 id。</p><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mb"><img src="../Images/de5be773a60894e75cdb269c3e08e586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bJbSQzZCXybakmKY1X59Sg.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Example of sample lookup dictionary.</figcaption></figure><p id="64c1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，对于每个给定的单词，通过在字典中查找返回相应的整数表示。如果字典中不存在该单词，则应该返回与词汇外标记相对应的整数。在实践中，通常将词汇外令牌的值设置为字典的大小加 1，即长度(字典)+ 1。</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="d300" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这是一种相对容易的方法，但它也有需要考虑的缺点。通过将标记视为整数，该模型可能会错误地假设自然排序的存在。例如，字典中包含的条目有<em class="lu"> 1:“机场”和 2:“飞机”。</em>具有较大 ID 值的标记可能被深度学习模型认为比具有较小值的标记更重要，这是一个错误的假设。用这种类型的数据训练的模型容易失败。相反，带有序数值的数据如 size measures <em class="lu"> 1:“小”，2:“中”，3:“大”</em>适合这种情况。因为数据中有一个自然的顺序。</p><h2 id="e76c" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">一键编码</h2><p id="2d60" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">单词表示的第二种方法是一键编码。主要思想是创建一个词汇大小向量，其中除了 1 之外都填充了 0。对于单个单词，只有相应的列用值 1 填充，其余的是零值。编码的记号将由维度为<em class="lu"> 1 × (N+ 1) </em>的向量组成，其中<em class="lu"> N </em>是字典的大小，并且对于超出词汇表的记号，额外的 1 被加到 N。让我们看看字典中的单词是如何转换成一键编码的:</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="1e66" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们所看到的，对于每个单词，只有对应于单词的列被激活。</p><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mg"><img src="../Images/67b7e6eddbdac5ac05a9c3a46899a39c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ze_-nGn7r7-V3vlX49NHIA.png"/></div></div></figure><p id="b824" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种顺序表示编码的优点是它不会遭受不希望的偏差。然而，其巨大而稀疏的矢量表示需要大量的计算内存。</p><h2 id="d9e1" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">分布表示</h2><p id="2239" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">第三种方法是一系列分布式表示。这种方法背后的主要思想是，通常出现在相似上下文中的单词将具有相似的含义。其思想是存储单词-上下文共现矩阵<strong class="ka jc"> <em class="lu"> F </em> </strong> <em class="lu"> </em>，其中行代表词汇表中的单词，列代表上下文。上下文可以是训练句子上的滑动窗口，甚至是文档。矩阵条目包括频率计数或 tf-idf(术语频率-逆文档频率)得分。这里有一个简单的例子:</p><p id="ea83" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">波士顿有飞往美国主要城市的航班。</p><p id="00b0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于恶劣的天气状况，飞往波士顿的航班被取消了。</p><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mh"><img src="../Images/9b982a2156f55bbb7caff76e7da610eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VRhI35p2XrOARHZuY-Jejg.png"/></div></div></figure><p id="cf29" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，一些函数<em class="lu"> g </em>可以应用于<em class="lu"> F </em>以降低噪声、平滑频率或降低表示向量的维数。函数<em class="lu"> g </em>可以做简单的变换，比如线性分解，但是也有高级的方法，比如潜在的狄利克雷分配。由于上下文的数量可能非常大，例如文档可能包含数千个句子，这些方法被认为是低效的。</p><p id="202a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上述方法易于使用，但具有难以训练和需要大内存的缺点。此外，它们不像高级方法那样将单词的意思结合到表示中。在下面的自然语言处理中的单词表示系列中，我将描述更高级的方法。下一个系列可以在<a class="ae mi" href="https://medium.com/p/1aee2094e08a" rel="noopener"> <strong class="ka jc">这里找到</strong> </a>。</p></div></div>    
</body>
</html>