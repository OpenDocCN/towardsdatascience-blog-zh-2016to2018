<html>
<head>
<title>Using Machine Learning to Predict Hospital Readmission for Patients with Diabetes with Scikit-Learn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Scikit-Learn 使用机器学习预测糖尿病患者的再入院</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/predicting-hospital-readmission-for-patients-with-diabetes-using-scikit-learn-a2e359b15f0?source=collection_archive---------4-----------------------#2018-10-21">https://towardsdatascience.com/predicting-hospital-readmission-for-patients-with-diabetes-using-scikit-learn-a2e359b15f0?source=collection_archive---------4-----------------------#2018-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6128" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用机器学习来识别有再次入院风险的患者！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/3d8ec76655972de91af1c035b8dd2e48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CMR44o1el0qRGQ2NV-notQ.png"/></div></div></figure><h1 id="fdbf" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h1><p id="50a1" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">随着医疗保健系统转向基于价值的护理，CMS 创建了许多项目来提高患者的护理质量。其中一个项目叫做“减少医院再入院项目”(<a class="ae ma" href="https://www.cms.gov/Medicare/Quality-Initiatives-Patient-Assessment-Instruments/Value-Based-Programs/HRRP/Hospital-Readmission-Reduction-Program.html" rel="noopener ugc nofollow" target="_blank"> HRRP </a>)，该项目减少对再入院率高于平均水平的医院的报销。对于那些目前在该计划下受到处罚的医院，一个解决方案是制定干预措施，为再入院风险增加的患者提供额外的帮助。但是我们如何识别这些病人呢？我们可以使用数据科学中的预测模型来帮助确定患者的优先顺序。</p><p id="dca9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个住院和再住院风险增加的患者群体是糖尿病患者。在美国，糖尿病是一种影响大约十分之一患者的医学疾病。根据奥斯特林等人的研究，糖尿病患者住院的几率几乎是普通人群的两倍(<a class="ae ma" href="https://clindiabetesendo.biomedcentral.com/articles/10.1186/s40842-016-0040-x" rel="noopener ugc nofollow" target="_blank">奥斯特林等人 2017 </a>)。因此，在本文中，我将重点预测糖尿病患者的再入院。</p><p id="3567" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个项目中，我将演示如何使用以下步骤在 Python 中建立一个预测再入院的模型</p><ul class=""><li id="5a58" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">数据探索</li><li id="cf30" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">特征工程</li><li id="18a5" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">构建培训/验证/测试样本</li><li id="7916" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">型号选择</li><li id="75f0" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">模型评估</li></ul><p id="d402" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以跟随我的 github(【https://github.com/andrewwlong/diabetes_readmission】)上提供的 Jupyter 笔记本。</p><h1 id="b97d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">项目定义</h1><p id="b08b" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">预测糖尿病患者是否会在 30 天内再次入院。</p><h1 id="6fe7" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">数据探索</h1><p id="6904" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这个项目中使用的数据最初来自 UCI 机器学习知识库(<a class="ae ma" href="https://archive.ics.uci.edu/ml/datasets/diabetes+130-us+hospitals+for+years+1999-2008" rel="noopener ugc nofollow" target="_blank">链接</a>)。该数据包括 1999 年至 2008 年间美国 130 家医院超过 100000 例住院的糖尿病患者。</p><p id="2b9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个项目中，我们将利用 Python 来构建预测模型。让我们从加载数据和研究一些列开始。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/d6ae68acd597e77cc4c7da2988c36ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*cDoWkrNU-s-QVwOyuYQRWQ.png"/></div></figure><p id="398a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，浏览数据列，我们可以看到有一些标识列、一些数字列和一些分类(自由文本)列。下面将更详细地描述这些列。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mq"><img src="../Images/2478c54194ba3703938fed3e909adecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WljEiVg-lQymM-Q2LbPDsQ.png"/></div></div></figure><p id="a2bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有些缺失的数据用问号(？).我们将在特性工程部分处理这个问题。</p><p id="9414" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里最重要的一栏是<code class="fe mr ms mt mu b">readmitted</code>，它告诉我们患者是在 30 天内住院、超过 30 天还是没有再次入院。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/d70fbdd0bf72eeb7eea11bc33888c4e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*nfSQle4WwioyM6P0x_x5YA.png"/></div></figure><p id="1f4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个重要的列是<code class="fe mr ms mt mu b">discharge_disposition_id</code>，它告诉我们病人住院后去了哪里。如果我们查看 UCI 提供的 IDs_mapping.csv，我们可以看到 11，13，14，19，20，21 与死亡或临终关怀有关。我们应该从预测模型中移除这些样本，因为它们不能被重新接纳。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/0138f89cd953e15aafc67ba3a919ae70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*zNM9FPELx5xl8QkUhVYoVw.png"/></div></figure><p id="af95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们为二元分类定义一个输出变量。在这里，我们将尝试预测患者是否有可能在出院后 30 天内再次入院。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/c87cb9271a56a5dc836970e810d95a38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*zSt0uMSc4c83tOvvggERjQ.png"/></div></figure><p id="8166" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们定义一个函数来计算 30 天内再次入院人口的患病率。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/2472ef5341862913e44dcf15c5861348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*G4G62N7xCgRcNbzJmN8bXw.png"/></div></figure><p id="d5bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大约 11%的人口再次住院。这代表了一个不平衡的分类问题，所以我们将在下面解决这个问题。</p><p id="1db6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从对列的进一步分析中，我们可以看到分类(非数字)和数字数据的混合。有几件事需要指出，</p><ul class=""><li id="754a" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">encounter_id 和 patient_nbr:这些只是标识符，不是有用的变量</li><li id="d8b8" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">年龄和体重:在这个数据集中是分类的</li><li id="499e" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">入院 _ 类型 _id，出院 _ 处置 _id，入院 _ 来源 _id:在这里是数字，但都是 id(见 IDs_mapping)。它们应该被认为是绝对的。</li><li id="6b1e" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">examide 和 citoglipton 只有 1 个值，所以我们不会使用这些变量</li><li id="ae1a" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">diag1、diag2、diag3 是分类的，有很多值。我们将不会使用这些作为这个项目的一部分，但你可以分组这些 ICD 代码，以减少维度。我们将使用 number _ diagnoses 来获取一些信息。</li><li id="4285" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">medical _ speciality 有许多分类变量，因此我们在制作特征时应该考虑这一点。</li></ul><h1 id="1506" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">特征工程</h1><p id="9951" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在本节中，我们将为预测模型创建特征。对于每个部分，我们将向数据帧添加新的变量，然后跟踪我们希望使用数据帧的哪些列作为预测模型特征的一部分。我们将把这一部分分解成数字特征、分类特征和额外特征。</p><p id="ff47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个数据集中，缺失的数字被打上了问号。让我们用一个 nan 表示来代替它。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi my"><img src="../Images/a4966c28f8426d881141d48984b82c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*sAughpMhV_G1kJWpB9pD5w.png"/></div></figure><h2 id="80db" class="mz ky iq bd kz na nb dn ld nc nd dp lh jy ne nf ll kc ng nh lp kg ni nj lt nk bi translated">数字特征</h2><p id="32dc" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">最容易使用的特征类型是数字特征。这些特征不需要任何修改。我们将使用的数字列如下所示</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nl"><img src="../Images/3a0bb9d660e2c1501b11b1aba81f5eed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DiKvkptHiwuaoFEpHI1dEg.png"/></div></div></figure><p id="e5e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们检查一下数字数据中是否有缺失值。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/bef7efda29aac557effc80ea43edc7af.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*fH0uEvyKAW2kwKYOYxdF3Q.png"/></div></figure><h2 id="f565" class="mz ky iq bd kz na nb dn ld nc nd dp lh jy ne nf ll kc ng nh lp kg ni nj lt nk bi translated">分类特征</h2><p id="3b8e" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们要创建的下一类特征是分类变量。分类变量是非数字数据，如种族和性别。要将这些非数字数据转换为变量，最简单的方法是使用一种称为 one-hot encoding 的技术，下面将对此进行解释。</p><p id="2d32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将处理的第一组分类数据是这些列:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/89ec15bad00baa3a739bfa1ad347b200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*_4kBptsXKceAdZFKjZf9HQ.png"/></div></figure><p id="6b45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的分类特征中，<code class="fe mr ms mt mu b">race</code>、<code class="fe mr ms mt mu b">payer_code</code>和<code class="fe mr ms mt mu b">medical_specialty</code>有缺失数据。由于这些是分类数据，最好的办法是使用“fillna”函数为 unknown 添加另一个分类类型。。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi no"><img src="../Images/2cb9341d874d9bfa1c1f2fa0af312309.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*6AOVNgbLytpGlC6HRqOjfg.png"/></div></figure><p id="6efc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意<code class="fe mr ms mt mu b">medical_specialty </code>没有包含在上面的列表中，因为我们需要多做一个处理步骤。在我们开始一键编码之前，让我们先研究一下医学专业。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi np"><img src="../Images/6262f6a219828cfd1162adf538fb2666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*JtvJ8So-aKEj8lFe5msgFw.png"/></div></figure><p id="3d49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到，其中大多数是未知的，而且数量下降得相当快。我们不想增加 73 个新变量，因为其中一些只有很少的样本。作为替代，我们可以创建一个只有 11 个选项的新变量(前 10 个专业，然后是另一个类别)。显然，还有其他的分桶选项，但这是减少可能类别数量的最简单的方法之一。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/529d7d6c1c83ba5405ea08e16a35a07e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*MxMODUnv7BAuszSb5FeQKQ.png"/></div></figure><p id="94b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了将我们的分类特征转换成数字，我们将使用一种称为一次性编码的技术。在一次性编码中，您为该列中的每个唯一值创建一个新列。如果样本具有唯一值，则该列的值为 1，否则为 0。例如，对于列 race，我们将创建新列(“race_Caucasian”、“race_AfricanAmerican”等)。如果患者的种族是高加索人，则患者在“种族 _ 高加索人”栏下得到 1，在其余种族栏下得到 0。要创建这些一次性编码列，我们可以使用 pandas 提供的<code class="fe mr ms mt mu b">get_dummies</code>功能。</p><p id="209f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在的问题是，如果我们为每个唯一值创建一列，我们就有了相关的列。换句话说，一列中的值可以通过查看其余列计算出来。例如，如果样本不是非洲裔美国人、亚洲人、加拿大人、西班牙人或其他人，那么它必须是 UNK 人。为了处理这个问题，我们可以使用<code class="fe mr ms mt mu b">drop_first</code>选项，它将删除每一列的第一个分类值。</p><p id="1f5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mr ms mt mu b">get_dummies </code>功能不适用于数字数据。为了欺骗<code class="fe mr ms mt mu b">get_dummies</code>，我们可以将 3 个 ID 类型的数字数据转换成字符串，然后它将正常工作。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nr"><img src="../Images/6775b2c3231df742a9ccd29eb0ec2da3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cID-hncuFNBijUkA_f85HQ.png"/></div></div></figure><p id="fc1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们准备好制作我们所有的分类特征</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ns"><img src="../Images/f57f2d191436ffcda41b8ccaa71bdf8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0YWz714nSRFbf98Z41HkLQ.png"/></div></div></figure><p id="a966" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要将独热编码列添加到数据帧中，我们可以使用<code class="fe mr ms mt mu b">concat </code>函数。确保使用 axis = 1 来表示添加列。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/f8a1cb3614efbe6ba162271a5661620a.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*8hFvMV_vsGUs_7lZkmiqNg.png"/></div></figure><p id="8c62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们保存分类数据的列名来跟踪它们。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/2b4a0e7f6816252dda9d4a754bfe677b.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*s83bw_alnlME2BQoY6DkvQ.png"/></div></figure><h2 id="e50c" class="mz ky iq bd kz na nb dn ld nc nd dp lh jy ne nf ll kc ng nh lp kg ni nj lt nk bi translated">额外功能</h2><p id="5cd0" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们想要制作的最后两个专栏是<code class="fe mr ms mt mu b">age</code>和<code class="fe mr ms mt mu b">weight</code>。通常，您会认为这些是数字数据，但它们在该数据集中是分类的，如下所示。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/7148408961a6304fb453fe88e617fd2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*JuxLVF69dly7y_dC3er4ZQ.png"/></div></figure><p id="6019" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一种选择是创建如上所示的分类数据。由于这些值有一个自然的顺序，将它们转换成有序的数字数据可能更有意义。另一个例子，当你想这样做的时候，可能是 t 恤的尺寸(小号，中号，大号)。先说年龄。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/6ed1bab169c4394dc3922c9836faa33c.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*ICjUO89WuP7TPQgvzxhTpQ.png"/></div></figure><p id="e8d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们将这些映射到 0 到 90 乘 10s 的数值数据。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/45c258b696f356970b8b104e623bf573.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*Ub6--rXm9CPomW3WWxJQHg.png"/></div></figure><p id="6d32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们来看看重量。请注意，此功能不经常填写。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/5ee014e5eebf05534080fa20f97ce0cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*Q6ueFbtp5y8W0aA20bRPLA.png"/></div></figure><p id="e41e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们创建一个变量来表示是否填写了权重，而不是像上面那样创建一个序数特征。不管值是多少，变量的存在都可能是预测性的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/2c256317b3ec490118f1f34e1b73ab21.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*TRrWeNoIa-aC0CfvQV5J3A.png"/></div></figure><p id="dca8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们也跟踪这些额外的列。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/ce7197f7f116dda6bdbf585f0c8c4b61.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*tQM8uHSAjaYjFLn4e_O2Dg.png"/></div></figure><h2 id="5aac" class="mz ky iq bd kz na nb dn ld nc nd dp lh jy ne nf ll kc ng nh lp kg ni nj lt nk bi translated">特征工程:概述</h2><p id="413a" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">通过这个过程，我们为机器学习模型创建了 143 个特征。这些功能的细分如下</p><ul class=""><li id="2b80" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">8 个数字特征</li><li id="df65" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">133 个分类特征</li><li id="03d3" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">2 个额外功能</li></ul><p id="a795" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们创建一个只有特性和<code class="fe mr ms mt mu b">OUTPUT_LABEL</code>的新数据帧。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/6d92b03d54ef1c7dd6da9be4dd6a2a5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*j1o_Lnh5msnUdi_nbM4e4A.png"/></div></figure><h1 id="fec3" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">构建培训/验证/测试样本</h1><p id="69ef" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">到目前为止，我们已经研究了我们的数据，并根据分类数据创建了特征。现在是我们拆分数据的时候了。分割数据背后的想法是，这样你就可以衡量你的模型在看不见的数据上做得有多好。我们分成三个部分:<br/> —训练样本:这些样本用于训练模型<br/> —验证样本:这些样本来自训练数据，用于决定如何改进模型<br/> —测试样本:这些样本来自所有决策，用于衡量模型<br/> <br/>的综合性能。在这个项目中，我们将分成 70%的训练、15%的验证和 15%的测试。</p><p id="de3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我喜欢做的第一件事是使用<code class="fe mr ms mt mu b">sample</code>打乱样本，以防出现某种顺序(例如，所有阳性样本都在顶部)。这里的<code class="fe mr ms mt mu b">n</code>是样品的数量。<code class="fe mr ms mt mu b">random_state</code>只是被指定，所以该项目是可复制的。在你自己的项目中，你不一定需要<code class="fe mr ms mt mu b">random_state</code>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/2356c412ff8111f291a6f037ec06717b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*5iJ2_bju7Ta8UP_7-fAtZw.png"/></div></figure><p id="b0bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以再次使用<code class="fe mr ms mt mu b">sample</code>提取 30%的数据(使用<code class="fe mr ms mt mu b">frac</code>)用于验证/测试分割。重要的是，验证和测试来自相似的发行版，这种技术是实现这一点的一种方式。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/2b5591352dca64cd4c7b4ff105925e72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*ZWu7_SjkdLwvhJWy-27teg.png"/></div></figure><p id="a6e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在使用 50%的分数分为测试和验证。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/f92d91d3d4b823dac6801fcce08560b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*kHtWFjdbGyJQT-iDncGZ0w.png"/></div></figure><p id="17d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意<code class="fe mr ms mt mu b">.drop</code>只是删除了<code class="fe mr ms mt mu b">df_test</code>中的行，以获取不属于样本的行。我们可以用同样的方法获得训练数据。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/0774f0beadb6e43fc98ff1cb0f7d1758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*CfrRuktxj-i4Jx0SzcLFhQ.png"/></div></figure><p id="83d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一点上，让我们检查一下 30 天内住院的组的百分比。这就是所谓的流行。理想情况下，这三组人群的患病率相似。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi od"><img src="../Images/247dd2327a978bb81a8141767e280074.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*OcsGv8aTmjBBDI1WuX8aKw.png"/></div></figure><p id="8535" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个群体的患病率大致相同。</p><p id="faa9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，您可能会说，将训练数据放入预测模型中，然后查看结果。然而，如果我们这样做，我们可能会得到一个 89%准确的模型。太好了！干得好！但是，等等，我们从来没有捕捉到任何重新接纳(回忆= 0%)。怎么会这样？</p><p id="d02d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在的情况是，我们有一个不平衡的数据集，其中负样本比正样本多得多，因此模型可能会将所有样本都指定为负样本。</p><p id="c94f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常情况下，最好以某种方式平衡数据，给积极的一面更多的权重。通常使用 3 种策略</p><ul class=""><li id="81b3" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">对更占优势的类别进行二次抽样:使用底片的随机子集</li><li id="50bc" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">对不平衡类进行过采样:多次使用相同的正样本</li><li id="0b57" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">创建合成阳性数据</li></ul><p id="b8e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，如果只有少数几个阳性病例，您会希望使用后两种方法。因为我们有几千个阳性病例，所以让我们使用子样本方法。这里，我们将创建一个 50%正面和 50%负面的平衡训练数据集。也可以玩玩这个比例，看能不能得到一个提升。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oe"><img src="../Images/edadf9a737180e77d44e3bda8a39b63a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aI2qF1vHgpDJR4sloLQ0Kw.png"/></div></div></figure><p id="7040" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数机器学习包喜欢使用输入矩阵 X 和输出向量 y，所以让我们创建它们:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi of"><img src="../Images/5d961bcf7db16e87e6a06eb38d932d24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*WLAsmc5ouTZhFfREEjKp1A.png"/></div></figure><p id="f866" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当变量大小不同时(0–100，vs 0–1000000)，一些机器学习模型会有问题。为了解决这个问题，我们可以扩展数据。在这里，我们将使用 scikit-learn 的标准定标器，该定标器去除了平均值并按单位方差进行定标。在这里，我将使用所有的训练数据创建一个缩放器，但如果你愿意，你也可以使用平衡的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi og"><img src="../Images/f3c33c013cab7681604ca01ca39a9650.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*7MEFyJ4L3pjKJyK-fgAS8w.png"/></div></figure><p id="195b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将需要这个 scaler 来处理测试数据，所以让我们使用一个名为<code class="fe mr ms mt mu b">pickle</code>的包来保存它。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/eceb309a417e8bd7b3859689b322338e.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*NuDjMAfM57V3qcGTovnjvg.png"/></div></figure><p id="d324" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以转换我们的数据矩阵</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/15231c0cc78f582a7252d7e773b0a654.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*EhV4RbUtNzkUs2a6SIOLNA.png"/></div></figure><p id="d9ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还不会转换测试矩阵，所以在完成模型选择之前，我们不会考虑性能。</p><h1 id="9370" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">型号选择</h1><p id="4869" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">哇！为模特做准备有这么多工作。在数据科学中，这总是正确的。您花费 80–90%的时间清理和准备数据。</p><p id="82a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本节中，我们将训练一些机器学习模型，并使用一些技术来优化它们。然后，我们将根据验证集的性能选择最佳模型。</p><p id="3ccd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将利用以下函数来评估模型的性能。关于这些性能指标的讨论，请参阅我以前的文章</p><ul class=""><li id="dfaf" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated"><a class="ae ma" rel="noopener" target="_blank" href="/data-science-performance-metrics-for-everyone-4d68f4859eef">每个人的绩效指标</a></li><li id="c5e7" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated"><a class="ae ma" rel="noopener" target="_blank" href="/understanding-data-science-classification-metrics-in-scikit-learn-in-python-3bc336865019">了解 scikit 中的数据科学分类指标——学习 Python </a></li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oi"><img src="../Images/2ee0ebf0edbe79fa3b6773aa964a6a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YBhOiLSSdOFc8htsPLoZNg.png"/></div></div></figure><p id="f4ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们平衡了训练数据，所以让我们将阈值设置为 0.5，以将预测样本标记为阳性。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/400ab302e043d96248363198000de472.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*u0vDAabmzxrO38CuftclVw.png"/></div></figure><h1 id="603a" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">模型选择:基线模型</h1><p id="0686" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在本节中，我们将首先使用默认超参数比较以下 7 个机器学习模型的性能:</p><ul class=""><li id="3b2d" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">k-最近邻</li><li id="1fda" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">逻辑回归</li><li id="0852" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">随机梯度下降</li><li id="d6ae" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">朴素贝叶斯</li><li id="c31a" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">决策图表</li><li id="d31e" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">随机森林</li><li id="54a5" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">梯度推进分类器</li></ul><h2 id="c6fb" class="mz ky iq bd kz na nb dn ld nc nd dp lh jy ne nf ll kc ng nh lp kg ni nj lt nk bi translated">k 最近邻(KNN)</h2><p id="92a2" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">KNN 是最简单的机器学习模型之一。对于给定的样本点，该模型查看 K 个最接近的数据点，并通过计算阳性标签的数量除以 K 来确定概率。该模型易于实施和理解，但缺点是对 K 敏感，如果训练样本的数量很大，则需要很长时间来评估。我们可以使用 scikit-learn 中的以下代码来拟合 KNN。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/cf9669daf552c0a02edb4ebccd231f13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*n8zi7k570_8QReloGJrfbw.png"/></div></figure><p id="15b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以用下面的代码来评估性能</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ol"><img src="../Images/ea86df049acda5c8bead19dd5a7dba5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RYYsgpRVv029G_eP2lWKwA.png"/></div></div></figure><p id="2b6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为简洁起见，我们将从剩余模型中排除评估，仅显示以下汇总结果。</p><h2 id="d41a" class="mz ky iq bd kz na nb dn ld nc nd dp lh jy ne nf ll kc ng nh lp kg ni nj lt nk bi translated">逻辑回归</h2><p id="926d" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">逻辑回归是一种传统的机器学习模型，适合正负样本之间的线性决策边界。这个线性函数然后通过一个 sigmoid 函数来计算正类的概率。当要素可以线性分离时，逻辑回归是一个很好的模型。逻辑回归的一个优势是模型是可解释的，即我们知道哪些特征对于预测积极或消极是重要的。需要考虑的一点是，建模对特征的缩放很敏感，所以这就是我们缩放上述特征的原因。我们可以使用 scikit-learn 中的以下代码来拟合逻辑回归。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi om"><img src="../Images/313a17a1b38599572a21c0c34a5ddaa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*7xcN3ZnL_KXHJO19hxcybQ.png"/></div></figure><h2 id="6cac" class="mz ky iq bd kz na nb dn ld nc nd dp lh jy ne nf ll kc ng nh lp kg ni nj lt nk bi translated">随机梯度下降</h2><p id="d37e" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">随机梯度下降类似于逻辑回归。这两种方法都使用梯度下降来优化线性函数的系数。在逻辑回归中，每次迭代都使用所有数据样本，而在随机梯度下降中，只使用一小批样本。这允许随机梯度下降来加速训练。我们可以使用 scikit-learn 中的以下代码来拟合随机梯度下降。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi on"><img src="../Images/5a54db39983bc5e61d5d19c0135d36d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*L6A96yhxiv5Dy7y3Pc-bQQ.png"/></div></figure><h2 id="4e84" class="mz ky iq bd kz na nb dn ld nc nd dp lh jy ne nf ll kc ng nh lp kg ni nj lt nk bi translated">朴素贝叶斯</h2><p id="c1a6" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">朴素贝叶斯是机器学习中偶尔使用的另一种模型。在朴素贝叶斯中，我们利用<a class="ae ma" href="https://en.wikipedia.org/wiki/Bayes%27_theorem" rel="noopener ugc nofollow" target="_blank">贝叶斯规则</a>来计算概率。这个模型的“幼稚”之处在于它假设所有的特性都是独立的(事实通常不是这样)。这对于自然语言处理模型来说效果很好，但是不管怎样，让我们在这里尝试一下。我们可以用下面的代码来拟合朴素贝叶斯。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oo"><img src="../Images/26037e90445fc119bc05545dbd59f789.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*Dy5lmqJJ8LqwYvtU9IYQGg.png"/></div></div></figure><h2 id="a6fa" class="mz ky iq bd kz na nb dn ld nc nd dp lh jy ne nf ll kc ng nh lp kg ni nj lt nk bi translated">决策图表</h2><p id="c47d" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">另一类流行的机器学习模型是基于树的方法。最简单的基于树的方法被称为决策树。本质上，在树形方法中，你利用游戏 20 问题背后的方法论来继续划分你的样本。在每个问题中，您询问样本是否有大于某个阈值的特定变量，然后分割样本。最终预测则是树的最后一片叶子(最终分裂)中阳性样本的分数。这种方法背后的机器学习是要找出在每次分裂时使用哪个变量和哪个阈值。基于树的方法的一个优点是，它们没有关于数据结构的假设，并且如果给定足够的树深度，能够拾取非线性效应。我们可以使用下面的代码来拟合决策树。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi op"><img src="../Images/01123446f3916ffd0b8f0f7dd5a2e0d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*eU2Sg-gIlWMX4ERrYNLUfg.png"/></div></figure><h2 id="7783" class="mz ky iq bd kz na nb dn ld nc nd dp lh jy ne nf ll kc ng nh lp kg ni nj lt nk bi translated">随机森林</h2><p id="13e8" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">决策树的一个缺点是，通过记忆训练数据，它们很容易过度拟合。因此，随机森林被创建来减少过度适应。在随机森林模型中，会创建多棵树，并对结果进行汇总。通过使用一组随机样本和每棵树中随机数量的特征，对森林中的树进行去相关。在大多数情况下，随机森林比决策树工作得更好，因为它们更容易归纳。为了适应随机森林，我们可以使用下面的代码。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/a3368cd87b0c16bb54a973678614461a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*tLyjG3fIm6WhTm6pYi37aA.png"/></div></figure><h2 id="5124" class="mz ky iq bd kz na nb dn ld nc nd dp lh jy ne nf ll kc ng nh lp kg ni nj lt nk bi translated">梯度推进分类器</h2><p id="6975" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">另一种改进决策树的方法是使用一种叫做 boosting 的技术。在这种方法中，您创建了一组浅树，试图改善先前训练的树的错误。一种使用这种技术与梯度下降算法(以控制学习速率)相结合的模型被称为梯度提升分类器。为了拟合梯度提升分类器，我们可以使用下面的代码。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi or"><img src="../Images/9d919d4dc5a4865e097b41e759e804ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*T5RZBiHQ2vQvu-X1NkxhLQ.png"/></div></div></figure><h2 id="cacf" class="mz ky iq bd kz na nb dn ld nc nd dp lh jy ne nf ll kc ng nh lp kg ni nj lt nk bi translated">基线模型分析</h2><p id="8852" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">让我们用所有基线模型的结果制作一个数据框架，并用一个名为<code class="fe mr ms mt mu b">seaborn</code>的包来绘制结果。在这个项目中，我们将利用 ROC 曲线下面积(AUC)来评估最佳模型。对于挑选最佳模型来说，这是一个很好的数据科学性能指标，因为它捕捉了真阳性和假阳性之间的权衡，并且不需要选择阈值。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi os"><img src="../Images/59beeb7e20494567f33564e25095f6b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*_mBoVmn2thOxxj5EhqoUyw.png"/></div></figure><p id="46b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所看到的，大多数模型(除了朴素贝叶斯)在验证集上具有相似的性能。正如训练和验证之间的落差所指出的，存在一些过度拟合。让我们看看是否可以使用更多的技术来提高这种性能。</p><h2 id="fa1f" class="mz ky iq bd kz na nb dn ld nc nd dp lh jy ne nf ll kc ng nh lp kg ni nj lt nk bi translated">模型选择:学习曲线</h2><p id="402a" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们可以通过绘制学习曲线来诊断模型的表现。在本节中，我们将利用来自 scikit-learn 的<a class="ae ma" href="http://scikit-learn.org/stable/auto_examples/model_selection/plot_learning_curve.html" rel="noopener ugc nofollow" target="_blank">网站</a>的学习曲线代码，对绘制 AUC 而不是精确度做了一点小小的改变。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/35d45c0c76a15e4ff03fb4c361294aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*tQ_QR1ybQyLmELr4n4_NVQ.png"/></div></figure><p id="d973" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在随机森林的情况下，我们可以看到训练和验证分数相似，但它们的 AUC 分数都很低。这被称为高偏差，是不适应的标志。</p><p id="7d6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据学习曲线，我们可以采用一些策略来改进模型</p><p id="e501" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">高偏差:<br/> -增加新特性<br/> -增加模型复杂度<br/> -减少正则化<br/> -改变模型架构</p><p id="e2e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">高方差:<br/> -添加更多样本<br/> -添加正则化<br/> -减少特征数量<br/> -降低模型复杂度<br/> -添加更好的特征<br/> -改变模型架构</p><p id="61fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些策略的灵感来自吴恩达的<a class="ae ma" href="https://www.coursera.org/specializations/deep-learning?utm_source=gg&amp;utm_medium=sem&amp;campaignid=904733485&amp;adgroupid=54215108588&amp;device=c&amp;keyword=andrew%20ng&amp;matchtype=p&amp;network=g&amp;devicemodel=&amp;adpostion=1t1&amp;creativeid=231631799402&amp;hide_mobile_promo&amp;gclid=Cj0KCQjwk_TbBRDsARIsAALJSOZlkCoqhf68wjopusy6Kzw1qewNAEC-9H0K1LhwOwRZ2llTZtVINicaAiG-EALw_wcB" rel="noopener ugc nofollow" target="_blank"> Coursera class </a>转述<a class="ae ma" href="http://&lt;https://www.learnopencv.com/bias-variance-tradeoff-in-machine-learning/&gt;" rel="noopener ugc nofollow" target="_blank">这里的</a>和吴恩达的机器学习向往<a class="ae ma" href="http://www.mlyearning.org/" rel="noopener ugc nofollow" target="_blank">教材</a>。</p><h2 id="3f16" class="mz ky iq bd kz na nb dn ld nc nd dp lh jy ne nf ll kc ng nh lp kg ni nj lt nk bi translated">模型选择:特征重要性</h2><p id="f159" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">改进模型的一个途径是了解哪些特性对模型是重要的。这通常只能在更简单的模型中进行研究，如逻辑回归或随机森林。这种分析可以在几个方面有所帮助:<br/> <br/> —激发新的特性想法→有助于高偏差和高方差<br/> —获得用于减少特性的顶级特性列表→有助于高方差<br/> —指出管道中的错误→有助于模型的健壮性</p><p id="5ac4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用下面的逻辑回归来获得特征重要性</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ou"><img src="../Images/9ed3fec62ba039f8f0baff6c72d835db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uc8AZzPe-84TaJzdjWnW_w.png"/></div></div></figure><p id="99b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以查看前 50 个正系数和前 50 个负系数来获得一些见解。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/469ac1c55a268b87add90ce0b05ffc18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*Z8BGvzZefTWc-Vy2VnJa0g.png"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/975b507c465e7376b87619fd3c476565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*sm7w_ud4KFZCWBhidxymBA.png"/></div></figure><p id="11f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看这些图后，您可能会受到启发，获得一些与最重要的功能相关的新数据。例如，在这两个模型中，最重要的特征是<code class="fe mr ms mt mu b">number_inpatient</code>，它是去年住院病人的就诊次数。这意味着，如果患者在去年去过医院，他们更有可能再次住院。这可能会激发你获得(如果你有的话)更多关于他们之前录取的数据。另一个例子是<code class="fe mr ms mt mu b">discharge_disposition_id_22</code>,用于患者出院到康复机构的情况。对你的公司来说，你可以研究出院到康复机构的规则，并添加与这些规则相关的功能。因为大多数数据分析师/数据科学家不具备深厚的领域知识。我可能会把其中的一些特征带给其他专家(如医生)，并询问他们关于药物的问题。</p><p id="01b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在高方差的情况下，一种策略是减少变量的数量以最小化过度拟合。在此分析之后，您可以使用前 N 个积极和消极特征或前 N 个重要的随机森林特征。您可能需要调整 N，以便您的性能不会急剧下降。例如，只使用顶级特性可能会大大降低性能。另一种可以用来减少变量数量的策略叫做 PCA(主成分分析)。scikit 中也实现了这一点——感兴趣的话可以学习一下。</p><p id="69ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想提到的最后一点是，特性重要性图也可能指出您的预测模型中的错误。也许，你在清理过程中有一些数据泄露。数据泄露可以被认为是在训练中偶然包含了某种东西，从而允许机器学习算法进行人工作弊的过程。例如，我根据医生的出院记录建立了一个模型(见 TDS 文章<a class="ae ma" rel="noopener" target="_blank" href="/introduction-to-clinical-natural-language-processing-predicting-hospital-readmission-with-1736d52bc709">此处</a>)。当我对最重要的词进行同样的分析时，我发现预测某人不会被重新录取的第一个词是“过期”。这让我意识到自己犯了一个错误，忘记排除当前医院就诊中死亡的患者。从我的错误中吸取教训，我排除了与死亡/临终关怀相关的出院代码。合并数据集时也会发生类似的情况。也许当您合并数据集时，其中一个类的某些变量以 nan 结束。上面的分析将帮助你抓住其中的一些情况。</p><h2 id="1527" class="mz ky iq bd kz na nb dn ld nc nd dp lh jy ne nf ll kc ng nh lp kg ni nj lt nk bi translated">模型选择:超参数调整</h2><p id="a9af" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们应该研究的下一件事是超参数调整。超参数调整本质上是您在建立机器学习模型时做出的设计决策。例如，你的随机森林的最大深度是多少？这些超参数中的每一个都可以被优化以改进模型。</p><p id="3952" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本节中，我们将只优化随机梯度下降、随机森林和梯度增强分类器的超参数。我们不会优化 KNN，因为它需要一段时间来训练。我们不会优化逻辑回归，因为它的表现类似于随机梯度下降。我们不会优化决策树，因为它们往往会过度拟合，性能不如随机森林和梯度推进分类器。</p><p id="184b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">超参数调整的一种技术称为网格搜索，在网格搜索中，您可以在一个值网格上测试所有可能的组合。这是非常计算密集型的。另一种选择是随机测试它们的排列。scikit-learn 中也实现了这种称为随机搜索的技术。这一部分的大部分内容是基于威廉·科尔森的博客文章。我强烈建议跟随他走向数据科学。他写高质量的文章。</p><p id="342b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在一些随机森林超参数上创建一个网格。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ox"><img src="../Images/ed3380fed6d4a7e9c04dda9ccffd5e5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z6vcxdNT1d4QIQUsJe-57A.png"/></div></div></figure><p id="b804" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要使用 RandomizedSearchCV 函数，我们需要对一组超参数进行评分或评估。这里我们将使用 AUC。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/7d06fd326188aac21917b90fb9f343f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*_KKDVp73xLr5dqzhMPtRsw.png"/></div></figure><p id="7b7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mr ms mt mu b">RandomizedSearchCV</code>的三个重要参数是</p><ul class=""><li id="9f5e" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">得分=用于挑选最佳模型的评估指标</li><li id="8a1f" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">n_iter =不同组合的数量</li><li id="01ea" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">cv =交叉验证分裂的数量</li></ul><p id="e471" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">增加最后两项会增加运行时间，但会减少过度拟合的机会。请注意，变量的数量和网格大小也会影响运行时间。交叉验证是一种多次拆分数据以获得更好的性能指标评估的技术。为了这个项目的目的，我们将限制到 2 CV，以减少时间。</p><p id="194c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以用下面的代码来适应我们的随机搜索随机森林。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oz"><img src="../Images/48386fd9c4d484a918b3538036fac240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yjp-Y9ZaH1bL5ctuV4npgQ.png"/></div></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/64b4309e9696356d86d887b703727177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*zcmjCh9Dx7geacjvjWkWbg.png"/></div></figure><p id="a40a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们分析一下最佳模型相对于基线模型的性能。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/b3299be68a26c91acd55dbb37c83d434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*5NGj6ntOtM4HqpaDh7K_qg.png"/></div></figure><p id="1b32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，我们可以优化随机梯度下降和梯度提升分类器的性能。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi pc"><img src="../Images/82d96b4d8863f55f15da676c751d4968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F2zV7J44KR6V1P5Bf-0l1w.png"/></div></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ou"><img src="../Images/06653278ef488df6c2b9f08a7c7dc719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jHeg7FV7BmrW9djAYtiO1A.png"/></div></div></figure><p id="36e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以汇总结果，并与验证集上的基线模型进行比较。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/61d81345bfd8b969f72cdd096803baf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*PaT9GOFxgLC_HjjpeuFfcg.png"/></div></figure><p id="510e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到，超参数调整改进了模型，但不是很多。这很可能是因为我们有一个高偏差的情况。如果我们有高的方差，更多的改进将被期待。</p><h2 id="3097" class="mz ky iq bd kz na nb dn ld nc nd dp lh jy ne nf ll kc ng nh lp kg ni nj lt nk bi translated">模型选择:最佳分类器</h2><p id="60f8" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这里，我们将选择梯度推进分类器，因为它在验证集上具有最佳 AUC。您不会希望每次运行新的预测时都训练您的最佳分类器。因此，我们需要保存分类器。我们将使用包<code class="fe mr ms mt mu b">pickle</code>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi pe"><img src="../Images/17b15d63028d167ce47dbe31cfbaf4b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aO-o0-GtrzHNI2iYF2Eqrw.png"/></div></div></figure><h1 id="edc3" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">模型评估</h1><p id="ccfe" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">现在我们已经选择了我们的最佳模型(优化的梯度推进分类器)。让我们评估一下测试集的性能。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/e3be1c219deafd26f5a7bc7cc2d1f5c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*kq6i8_1huHTa-aDj2BKpFA.png"/></div></figure><p id="8f17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终评价如表所示</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/10ece73037423b2945c95950a3b4b12a.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*RnIIZY7AhR0KQ3givB97oA.png"/></div></figure><p id="f96a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以为 3 个数据集创建 ROC 曲线，如下所示</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/60e82adc3f585c7b12e0ccdc32ce078c.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*HDd5O7PEBc7azmdoTcwEVg.png"/></div></figure><h1 id="576d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="ec44" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">通过这个项目，我们创建了一个机器学习模型，能够预测 30 天内再次入院风险最高的糖尿病患者。最佳模型是具有优化超参数的梯度推进分类器。该模型能够捕捉到 58%的再入院率，比随机选择患者要好 1.5 倍。总的来说，我相信许多医疗保健数据科学家正在研究医院再入院的预测模型。如果你是这种情况，我很乐意与你联系(在<a class="ae ma" href="https://www.linkedin.com/in/awlong/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>)并分享经验。欢迎在下面的评论中留下任何反馈或问题。</p><h1 id="c012" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">参考</h1><p id="a742" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">奥斯特林、威科夫、恰尔科夫斯基、派、崔、巴尔、吉安昌达尼(2017)。<em class="ph">临床糖尿病和内分泌学</em>中的“糖尿病和 30 天再入院率之间的关系”。3:1</p></div></div>    
</body>
</html>