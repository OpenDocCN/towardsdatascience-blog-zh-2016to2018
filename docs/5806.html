<html>
<head>
<title>Want to use BigQuery? Read this</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">想用 BigQuery？读读这个</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/want-to-use-bigquery-read-this-fab36822830?source=collection_archive---------7-----------------------#2018-11-10">https://towardsdatascience.com/want-to-use-bigquery-read-this-fab36822830?source=collection_archive---------7-----------------------#2018-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/37e592b75bb80d8cfe17fabd61ec728d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cc8exApLG6iB4ftp_l_qBQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/photos/qwtCeJ5cLYs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Stephen Dawson</a> on <a class="ae kc" href="https://unsplash.com/search/photos/data-warehouse?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a80c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我最近开始使用 BigQuery，我必须承认我爱上了 DB… <br/>本文试图解释它背后的技术，这是在成本和性能方面有效利用 DB 的一个要求。</p><p id="7878" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">BigQuery 是谷歌发布的 Dremel 的公开实现。</p><p id="4b9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Dremel 是 Google 的查询引擎，它能够将 SQL 查询转换成从 Google 的分布式文件系统中读取数据的执行树。Dremel 具有很高的可伸缩性，无论数据集有多大，它都能够在几秒(或几十秒)内返回查询结果。</p><p id="5868" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">BigQuery 通过 REST API、命令行界面和 Web UI 向第三方提供 Dremel 的核心特性。</p><p id="7c12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是 BigQuery 不仅仅是 Dremel…</p><p id="98c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实上，BigQuery 利用了谷歌开发的多种技术。</p><p id="820d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，它使用 Borg (Google 的集群管理系统)为 Dremel 作业分配计算能力。Dremel jobs 使用 Jupiter 从谷歌的文件系统中读取数据，Jupiter 是谷歌的高速网络，以 10 Gbps 的速度交换数据。</p><p id="337e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于其架构，BigQuery 不需要索引，数据以一种专有的列格式存储在 Colossus (Google 的文件系统)上，每个查询对目标表进行全扫描。</p><p id="2b0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">负载的增加主要通过添加服务器来管理。这对于用户来说是透明的，用户不会像使用 Redshift 或 Postgres 那样“添加服务器”或“使用更大的机器”。</p><p id="0fc4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">术语“无索引”和“全扫描”通常不是“快”的同义词，那么 BigQuery 为什么这么快呢？</p><p id="642e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">主要得益于两个因素:</p><ul class=""><li id="51c2" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kf ir">列存储</strong>:<strong class="kf ir"/>数据按列存储，这样可以实现很高的压缩比和扫描吞吐量。</li><li id="dec1" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">树形架构</strong>:树形执行架构用于在数千台机器上分发查询和聚合结果。</li></ul><h1 id="c5ec" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">柱状存储</h1><p id="166f" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">作为一个分析数据库，BigQuery 存储格式针对访问大量行的少数几列进行了优化。由于这个原因，存储是按列执行的，因此您只能访问更少的不同存储卷(由于可以并行访问它们，所以速度更快)。</p><p id="a72a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据模型与协议缓冲区紧密相关，具有必填、重复和可选字段。<br/>为了以连续的方式存储信息，让我们引入<strong class="kf ir">重复级别</strong>和<strong class="kf ir">定义级别</strong>的概念。</p><ul class=""><li id="5dba" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kf ir">重复级别</strong>:重复发生的场路径中嵌套的级别。</li><li id="16a3" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">定义级别</strong>:字段路径中定义了多少个可选/重复字段。</li></ul><p id="2098" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们举个例子，假设我们有下面的表定义:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="e213" class="nb lq iq mx b gy nc nd l ne nf">message Book {<br/> required string title,<br/> repeated string author,<br/> repeated group price {<br/>   optional int64 discount,<br/>   optional int64 usd,<br/>   optional int64 eur,<br/> }<br/>}</span></pre><p id="18e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有三项记录:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="d093" class="nb lq iq mx b gy nc nd l ne nf">Book1:<br/> author: "AAA"<br/> title: "firstTitle"<br/> price:<br/>  discount: 0<br/>  eur: 11<br/>  usd: 12</span><span id="d651" class="nb lq iq mx b gy ng nd l ne nf">Book2:<br/> author: "BBB"<br/> author: "CCC"<br/> author: "DDD"<br/> title: "secondTitle"</span><span id="3225" class="nb lq iq mx b gy ng nd l ne nf">Book3:<br/> title: "thirdTitle"<br/> price:<br/>  discount: 0<br/>  eur: 11<br/> price:<br/>  discount: 1<br/>  eur: 11</span></pre><p id="ba21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们计算每个值的重复和定义级别。我还将为缺失的可选字段添加显式的空值。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="b49a" class="nb lq iq mx b gy nc nd l ne nf">Book1:<br/> author: "AAA"          R: 0, D: 1<br/> title: "firstTitle"    R: 0, D: 1<br/> price:<br/>  discount: 0           R: 0, D: 2<br/>  eur: 11               R: 0, D: 2<br/>  usd: 12               R: 0, D: 2</span><span id="a38b" class="nb lq iq mx b gy ng nd l ne nf">Book2:<br/> author: "BBB"          R: 0, D: 1<br/> author: "CCC"          R: 1, D: 1<br/> author: "DDD"          R: 1, D: 1<br/> title: "secondTitle"   R: 0, D: 1<br/> (price):<br/>  (discount: null)      R: 0, D: 0<br/>  (eur: null)           R: 0, D: 0<br/>  (usd: null)           R: 0, D: 0</span><span id="3214" class="nb lq iq mx b gy ng nd l ne nf">Book3:<br/> title: "thirdTitle"   R: 0, D: 1<br/> (author: null)        R: 0, D: 0<br/> price:<br/>  discount: 0          R: 0, D: 2<br/>  eur: 11              R: 0, D: 2<br/>  (usd: null)          R: 0, D: 1<br/> price:<br/>  discount: 1          R: 1, D: 2<br/>  eur: 11              R: 1, D: 2<br/>  (usd: null)          R: 1, D: 1</span></pre><p id="1fbf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当没有重复时，重复级别总是零，当字段重复时，例如第二个记录中的<em class="nh"> author </em>，R 是 1，因为重复发生在第一个重复级别，第三个记录中的 price 也是如此。</p><p id="7ade" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">定义级别非常简单，例如在第一条记录中<em class="nh">价格.折扣</em>为 2，因为<em class="nh">价格</em>和<em class="nh">折扣</em>都已定义。另一方面，在记录 3 中，最后一个空值<em class="nh"> price.usd </em>的 D 等于 1，因为<em class="nh"> price </em>被定义，而<em class="nh"> price.usd </em>没有被定义。</p><p id="4cef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每列存储为一组块，如下所示:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="5736" class="nb lq iq mx b gy nc nd l ne nf">compressed value, R, D</span></pre><p id="d368" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">r 和 D 仅在必要时存储，不能推断。空值可以推断为，对它们来说，D 始终是一个小于字段路径中重复字段和可选字段之和的数字(从示例中可以看出)。<br/>根据存储的信息，可以很容易地为每个查询列并行重建每个记录。</p><p id="d16f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，让我们考虑一下<em class="nh"> price.eur </em>列。在磁盘上，我们将有:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="bdb8" class="nb lq iq mx b gy nc nd l ne nf">11 R: 0, D: 2<br/>NULL R: 0, D: 0<br/>11 R: 0, D: 2<br/>11 R: 1, D: 2</span></pre><p id="4c4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">扫描该列，每当 R 为 0 时，我们就遇到一个新记录，而当 R 大于 0 时，我们在同一记录中有重复。如前所述，D 可用于空值。因此，遍历该列，我们得到:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="de7f" class="nb lq iq mx b gy nc nd l ne nf">Book1:<br/> price:<br/>  eur: 11</span><span id="4112" class="nb lq iq mx b gy ng nd l ne nf">Book2:<br/> price:<br/>  eur: null</span><span id="405e" class="nb lq iq mx b gy ng nd l ne nf">Book2:<br/> price:<br/>  eur: 11<br/> price:<br/>  eur: 11</span></pre><p id="1b10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">列存储也带来了存储优势，因为它允许您压缩每一列。两个经典的解决方案是<strong class="kf ir">位图</strong>和<strong class="kf ir">游程编码</strong> (RLE)。</p><p id="014f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您有一个由<em class="nh"> n </em>行组成的列，其中有<em class="nh"> k </em>个不同的值。使用前面的示例，您有一个包含以下值的<em class="nh"> price.eur </em>列(<em class="nh"> n </em> = 10，<em class="nh"> k </em> = 5)</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="9513" class="nb lq iq mx b gy nc nd l ne nf">[10.0, 10.0, 8.99, 8.99, 7.0, 6.0, 7.0, 6.0, 2.0, 2.0]</span></pre><p id="5993" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个列可以很容易地用长度为<em class="nh"> n </em>(行长度)的<em class="nh"> k </em>位图(一个位图对应一个不同的值)来压缩，其中如果某个值在行中，那么在该值的位置有一个设置位。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="6a56" class="nb lq iq mx b gy nc nd l ne nf">price.eur: 10.0 [1, 1, 0, 0, 0, 0, 0, 0, 0, 0]<br/>price.eur: 8.99 [0, 0, 1, 1, 0, 0, 0, 0, 0, 0]<br/>price.eur: 7.0  [0, 0, 0, 0, 1, 0, 1, 0, 0, 0]<br/>price.eur: 6.0  [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]<br/>price.eur: 2.0  [0, 0, 1, 1, 0, 0, 0, 0, 1, 1]</span></pre><p id="7e51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以存储位图而不是实际的列。如果考虑选择、聚合和投影模式，优势甚至更大。在分析数据库中，查询(如下所示)</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/f189368e32b8ef8cb88eb9a5f5a39f5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*S9AnpLeIe5TJwNPOjfM1pA.png"/></div></figure><p id="6823" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以直接执行加载值= 4.0 和&lt; 3.0 的位图，并执行逐位 and。</p><p id="cae1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用 RLE 可以进一步提高压缩率。在这种情况下，你要做的是表示 0 和 1 的序列。例如，前三个位图将变成:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="30cd" class="nb lq iq mx b gy nc nd l ne nf">price.eur: 10.0 – 0,2 (0 0s, 2 1s, rest 0s)<br/>price.eur: 8.99 – 2,2 (2 0s, 2 1s, rest 0s)<br/>price.eur: 7.0 – 4,1,1,1 (4 0s, 1 one, 1 zero, 1 one, rest 0s)</span></pre><p id="f580" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以想象，这种技术的效率很大程度上取决于不同的因素，比如行的顺序、列的类型和用法。电容器所做的是试图找到一种智能的行重新排序，目的是优化(或至少次优化)数据存储和检索。</p><p id="0b4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种选择也有一些缺点。例如，它在更新方面表现不佳。Dremel 通过不支持任何更新操作来解决这个问题。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/a7d0e087e500b9c4ac1f479a6c63d792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mc-jRTMJ3W4Vo9vWH5xhyg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Coffee break (Photo by <a class="ae kc" href="https://unsplash.com/photos/5Z398JOmCKw?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">rawpixel</a> on <a class="ae kc" href="https://unsplash.com/search/photos/coffee-break?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a>)</figcaption></figure><h1 id="d206" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">用于查询执行的树形结构</h1><p id="6761" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">每个 SQL 语句将一个或多个嵌套表及其模式作为输入，并生成一个嵌套表及其输出模式。<br/>嵌套数据结构的思想用于减少阻抗不匹配(也就是应用程序代码和 DBs 数据表示中对象之间的不匹配)。</p><p id="ee85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使查询中没有指定记录构造函数，也总是会产生嵌套结果。</p><p id="52b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们以一个 SQL 查询为例，它执行:<strong class="kf ir">投影</strong> (AS)、<strong class="kf ir">选择</strong> (SELECT/FROM/WHERE)和<strong class="kf ir">记录内聚合</strong> (COUNT — WITHIN)。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/89481d578c130057427ed0e4af631825.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*nGHy75TF8OVmk-RrScjFxQ.png"/></div></figure><p id="8c26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该查询将返回如下内容:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="30ff" class="nb lq iq mx b gy nc nd l ne nf">Book: Book1<br/>price:<br/> discountCnt: 1<br/> str: "AAA,firstTitle"</span></pre><p id="0451" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您将嵌套记录视为一棵带标签的树，那么:</p><ul class=""><li id="b7c4" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kf ir">选择:</strong> WHERE 删除不符合条件的分支，而 SELECT 生成的值与表达式中使用的重复次数最多的字段级别相同。</li><li id="a388" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">聚合:</strong> COUNT/WITHIN 执行记录内聚合，计算价格字段中折扣的出现次数。</li></ul><p id="ef0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是查询是如何执行的呢？<br/>答案是:<strong class="kf ir">使用树执行方法</strong>。</p><p id="0a73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根节点接收查询，读取表元数据，并将查询重新路由到下一级。在底部，叶节点是与分布式文件系统交互的节点，它检索实际的数据，并将其传播回树中。</p><p id="0de2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，假设您执行:</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/7b504ad64ecfe90644a0210d89da4d5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*E5rFLrr0UZZJcGZhToUJkQ.png"/></div></figure><p id="f776" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根节点获取组成 T 的所有分区(可能你们中的一些人更熟悉术语<em class="nh">碎片</em>),而不是将查询重写为</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/5aca3a9e3d136e88c9773c97df390e78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*odJEksWNR4Xu5i2FRftuGg.png"/></div></div></figure><p id="bc85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<em class="nh"> R1i </em> … <em class="nh"> R1n </em>是发送到第一级节点的查询的结果。特别是:</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi gj"><img src="../Images/65211a952741342ec19b93e056db8180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lplHF2SGaezCyvewSUUWUw.png"/></div></div></figure><p id="e8d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<em class="nh"> T1i </em>是在执行树的第一级中由服务器 I 处理的平板(T 的碎片)。</p><p id="8cfb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查询在下一级被修改和推送，直到到达叶子。树叶从分区中读取实际的列数据，然后一切都传播回根。</p><p id="e5da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要注意的是，树叶扫描的数据量是影响查询费用的数据量。</p><p id="440a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于分区，BigQuery 在加载数据时确定表的最佳分区数，然后根据数据访问和查询模式调整分区数。</p><h1 id="fb6a" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">查询调度程序</h1><p id="39a3" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">通常，几个查询同时执行，查询调度器调度查询并平衡负载。</p><p id="1875" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个查询中处理的数据量通常大于<br/>可供执行的处理单元(槽)的数量。一个槽对应于叶服务器上的一个执行线程。通常情况下，每个插槽会被分配给多个平板电脑。<br/>执行查询时，dispatcher 会计算药片处理时间的直方图，并决定重新安排处理时间过长的药片。</p><p id="bfff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就复制而言，每台平板电脑通常都是三向复制，因此如果其中一台不可访问，则叶服务器会访问另一台副本。</p><p id="f33d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们用一些数学知识来理解这种机制在执行查询时为何如此之快。</p><p id="f100" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您有一个包含 50TB 数据、10 列和 1000 个分区的表，考虑到前面讨论的列存储，您有 10 个文件乘以 1000 个平板电脑。</p><p id="f07b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们假设你在桌子上执行了一个<code class="fe nn no np mx b">SELECT *</code>。<br/>如果有 2000 个插槽，每个插槽必须读取 5 个文件(10x1000/2000 ),每个文件的大小为 5GB，总共 25GB，可以并行读取。考虑到木星网络的速度，这些数据可以在 20 秒左右送达。</p><h1 id="86d7" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">实际问题</h1><p id="e6f9" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">让我们通过理解 BigQuery 背后的技术得出一些实际的考虑。</p><ol class=""><li id="76b8" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la nq lh li lj bi translated"><strong class="kf ir">最小化扫描数据量</strong>:永远不要运行<code class="fe nn no np mx b">SELECT *</code>，如果这对于一般的分析数据库来说是真的，那么对于 BigQuery 及其<em class="nh">按查询付费</em>策略来说更是如此。仔细选择您需要的列。除此之外，您可以应用几种策略来减少数据量，比如使用分区表。</li><li id="dbf6" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nq lh li lj bi translated"><strong class="kf ir">不删除</strong>:如果你犯了一个错误，你不能删除或重命名一个列…你只能从<code class="fe nn no np mx b">REQUIRED</code>到<code class="fe nn no np mx b">NULLABLE</code>增加或放松一个列的模式。但是，您仍然可以删除或重命名列。例如，您可以执行一个查询，选择除了要删除的列之外的所有列，并将查询结果作为新表的目标。或者，您可以将现有的表转储到<em class="nh">Google Cloud Storage</em>(GCS)中，然后重新导入它，不包含您想要删除或重命名的列。这些都会带来成本的下降(扫描整个表，创建新表，因此需要额外的存储)。</li><li id="2c47" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nq lh li lj bi translated"><strong class="kf ir">外部数据源</strong> : BigQuery 也可以使用它的查询来定位外部数据源。支持的来源有<em class="nh"> Bigtable </em>、<em class="nh"> Google 云存储</em>和<em class="nh"> Google Drive </em>。数据被动态加载到 Dremel 引擎中。例如，如果您想直接查询存储在 GCS 上的日志，这可能非常有用。另一方面，与定位本地表相比，定位外部数据会导致性能降低。</li></ol></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="a8f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nh">结论:我们深入了解了 BigQuery 的工作原理。特别是，它的存储格式和查询执行机制如何对大量数据执行快速分析查询。然后，根据我们对 BigQuery 架构的了解，我们得出了一些关于如何优化成本和查询性能的实际考虑。</em></p><p id="f068" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您喜欢这篇文章，并且觉得它很有用，请随意👏或者分享。</p><p id="1cec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">干杯！</p></div></div>    
</body>
</html>