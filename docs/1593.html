<html>
<head>
<title>Two cool features of Python NumPy: Mutating by slicing and Broadcasting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python NumPy 的两个很酷的特性:通过切片和广播进行变异</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/two-cool-features-of-python-numpy-mutating-by-slicing-and-broadcasting-3b0b86e8b4c7?source=collection_archive---------1-----------------------#2017-09-24">https://towardsdatascience.com/two-cool-features-of-python-numpy-mutating-by-slicing-and-broadcasting-3b0b86e8b4c7?source=collection_archive---------1-----------------------#2017-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/828c5c2abd0ad8d11ba05416b0d672f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*O2_46c16UdgmXzen4VktMg.png"/></div></figure><div class=""/><div class=""><h2 id="c4ef" class="pw-subtitle-paragraph ju iw ix bd b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dk translated"><a class="ae km" href="http://www.numpy.org/" rel="noopener ugc nofollow" target="_blank"> NumPy </a>是纯金。它快速、易学、功能丰富，因此是 Python 世界中几乎所有流行科学包的核心(包括<a class="ae km" href="https://www.scipy.org/" rel="noopener ugc nofollow" target="_blank"> SciPy </a>和<a class="ae km" href="http://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Pandas </a>，这两个包在数据科学和统计建模领域应用最广泛)。在本文中，让我们简要讨论 NumPy 的两个有趣的特性，即。<em class="kn">切片突变</em>和<em class="kn">播</em>。</h2></div></div><div class="ab cl ko kp hu kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="ij ik il im in"><h1 id="4729" class="kv kw ix bd kx ky kz la lb lc ld le lf kd lg ke lh kg li kh lj kj lk kk ll lm bi translated">切片突变</h1><p id="f9b7" class="pw-post-body-paragraph ln lo ix lp b lq lr jy ls lt lu kb lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">事实证明，如果使用 NumPy 的简单切片/索引来创建子数组，子数组实际上指向主数组。简单地说，内存中的图表看起来像，</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mj"><img src="../Images/23f74370ad33bd5922a487d39b357bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BR_UfFEzY5dev9Q8ck-AWw.png"/></div></div></figure><p id="e6e0" class="pw-post-body-paragraph ln lo ix lp b lq ms jy ls lt mt kb lv lw mu ly lz ma mv mc md me mw mg mh mi ij bi translated">因此，如果切片数组被更改，它也会影响父数组。这可能是一个有用的特性，可以将所需的链传播到食物链的上游，但有时也可能是一个麻烦，因为您需要保持主数据集不变，并且只对子集进行更改。在这些情况下，您必须显式调用<em class="mx"> np.array 方法</em>来定义切片数组，而不仅仅是通过索引来切片。下面的代码说明了这一点，</p><h2 id="5874" class="my kw ix bd kx mz na dn lb nb nc dp lf lw nd ne lh ma nf ng lj me nh ni ll nj bi translated">说明性代码</h2><pre class="mk ml mm mn gt nk nl nm nn aw no bi"><span id="b374" class="my kw ix nl b gy np nq l nr ns">mat = np.array([[11,12,13],[21,22,23],[31,32,33]])<br/>print("Original matrix")<br/>print(mat)<br/><strong class="nl iy">mat_slice = mat[:2,:2] # <em class="mx">Simple indexing</em></strong><br/>print ("\nSliced matrix")<br/>print(mat_slice)<br/>print ("\nChange the sliced matrix")<br/>mat_slice[0,0] = 1000<br/>print (mat_slice)<br/>print("\nBut the original matrix? WHOA! It got changed too!")<br/>print(mat)</span></pre><p id="82ad" class="pw-post-body-paragraph ln lo ix lp b lq ms jy ls lt mt kb lv lw mu ly lz ma mv mc md me mw mg mh mi ij bi translated">结果看起来像是，</p><pre class="mk ml mm mn gt nk nl nm nn aw no bi"><span id="291a" class="my kw ix nl b gy np nq l nr ns">Original matrix<br/>[[11 12 13]<br/> [21 22 23]<br/> [31 32 33]]<br/><br/>Sliced matrix<br/>[[11 12]<br/> [21 22]]<br/><br/>Change the sliced matrix<br/>[[<strong class="nl iy">1000</strong>   12]<br/> [  21   22]]<br/><br/>But the original matrix? WHOA! <strong class="nl iy">It got changed</strong> too!<br/>[[<strong class="nl iy">1000</strong>   12   13]<br/> [  21   22   23]<br/> [  31   32   33]]</span></pre><p id="e62d" class="pw-post-body-paragraph ln lo ix lp b lq ms jy ls lt mt kb lv lw mu ly lz ma mv mc md me mw mg mh mi ij bi translated">为了阻止这种事情发生，这是你应该做的，</p><pre class="mk ml mm mn gt nk nl nm nn aw no bi"><span id="3dc4" class="my kw ix nl b gy np nq l nr ns"># Little different way to create a copy of the sliced matrix<br/>print ("\nDoing it again little differently now...\n")<br/>mat = np.array([[11,12,13],[21,22,23],[31,32,33]])<br/>print("Original matrix")<br/>print(mat)<br/><strong class="nl iy">mat_slice = np.array(mat[:2,:2])<em class="mx"> # Notice the np.array method</em></strong><br/>print ("\nSliced matrix")<br/>print(mat_slice)<br/>print ("\nChange the sliced matrix")<br/>mat_slice[0,0] = 1000<br/>print (mat_slice)<br/>print("\nBut the original matrix? NO CHANGE this time:)")<br/>print(mat)</span></pre><p id="304a" class="pw-post-body-paragraph ln lo ix lp b lq ms jy ls lt mt kb lv lw mu ly lz ma mv mc md me mw mg mh mi ij bi translated">现在，子矩阵中的任何变化都不会改变原始矩阵，</p><pre class="mk ml mm mn gt nk nl nm nn aw no bi"><span id="11d3" class="my kw ix nl b gy np nq l nr ns">Original matrix<br/>[[11 12 13]<br/> [21 22 23]<br/> [31 32 33]]<br/><br/>Sliced matrix<br/>[[11 12]<br/> [21 22]]<br/><br/>Change the sliced matrix<br/>[[<strong class="nl iy">1000</strong>   12]<br/> [  21   22]]<br/><br/>But the original matrix? <strong class="nl iy">NO CHANGE</strong> this time:)<br/>[[<strong class="nl iy">11</strong> 12 13]<br/> [21 22 23]<br/> [31 32 33]]</span></pre><h1 id="17fc" class="kv kw ix bd kx ky nt la lb lc nu le lf kd nv ke lh kg nw kh lj kj nx kk ll lm bi translated">广播</h1><p id="1ee9" class="pw-post-body-paragraph ln lo ix lp b lq lr jy ls lt lu kb lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">NumPy 操作通常是在逐个元素的基础上对数组对进行的。在一般情况下，两个数组必须具有完全相同的形状(或者对于矩阵乘法，内部维度必须一致)。</p><p id="b03e" class="pw-post-body-paragraph ln lo ix lp b lq ms jy ls lt mt kb lv lw mu ly lz ma mv mc md me mw mg mh mi ij bi translated">当数组的形状满足某些约束 时，NumPy 的<strong class="lp iy"> <em class="mx">广播规则放松了这个约束。当操作两个数组时，NumPy 按元素比较它们的形状。它从尾部维度开始，向前推进。在以下情况下，二维是兼容的</em></strong></p><ul class=""><li id="e28a" class="ny nz ix lp b lq ms lt mt lw oa ma ob me oc mi od oe of og bi translated"><strong class="lp iy">它们相等，或者</strong></li><li id="2851" class="ny nz ix lp b lq oh lt oi lw oj ma ok me ol mi od oe of og bi translated"><strong class="lp iy">其中一个是 1 </strong></li></ul><p id="6aa7" class="pw-post-body-paragraph ln lo ix lp b lq ms jy ls lt mt kb lv lw mu ly lz ma mv mc md me mw mg mh mi ij bi translated">如果不满足这些条件，就会抛出一个<em class="mx">value error:frames not aligned</em>异常，表明数组具有不兼容的形状。结果数组的大小是沿着输入数组的每个维度的最大大小。</p><p id="35b3" class="pw-post-body-paragraph ln lo ix lp b lq ms jy ls lt mt kb lv lw mu ly lz ma mv mc md me mw mg mh mi ij bi translated">更多详情请查阅:<a class="ae km" href="https://docs.scipy.org/doc/numpy-1.10.1/user/basics.broadcasting.html" rel="noopener ugc nofollow" target="_blank">https://docs . scipy . org/doc/numpy-1 . 10 . 1/user/basics . broadcasting . html</a>。</p><blockquote class="om on oo"><p id="18c4" class="ln lo mx lp b lq ms jy ls lt mt kb lv op mu ly lz oq mv mc md or mw mg mh mi ij bi translated"><em class="ix">下面的代码块按部就班地说明了这个想法，</em></p></blockquote><p id="d6f7" class="pw-post-body-paragraph ln lo ix lp b lq ms jy ls lt mt kb lv lw mu ly lz ma mv mc md me mw mg mh mi ij bi translated"><em class="mx">用零初始化“开始”矩阵</em></p><pre class="mk ml mm mn gt nk nl nm nn aw no bi"><span id="ce6c" class="my kw ix nl b gy np nq l nr ns">start = np.zeros((4,3))<br/>print(start)</span><span id="9842" class="my kw ix nl b gy os nq l nr ns">[[ 0.  0.  0.]<br/> [ 0.  0.  0.]<br/> [ 0.  0.  0.]<br/> [ 0.  0.  0.]]</span></pre><p id="07e2" class="pw-post-body-paragraph ln lo ix lp b lq ms jy ls lt mt kb lv lw mu ly lz ma mv mc md me mw mg mh mi ij bi translated">创建一个行矩阵(向量)，</p><pre class="mk ml mm mn gt nk nl nm nn aw no bi"><span id="31e5" class="my kw ix nl b gy np nq l nr ns"># create a rank 1 ndarray with 3 values<br/>add_rows = np.array([1, 0, 2])<br/>print(add_rows)</span><span id="fdb0" class="my kw ix nl b gy os nq l nr ns">[1 0 2]</span></pre><p id="c018" class="pw-post-body-paragraph ln lo ix lp b lq ms jy ls lt mt kb lv lw mu ly lz ma mv mc md me mw mg mh mi ij bi translated">将零矩阵(4x3)与(1x3)向量相加。自动地，1×3 向量被复制 4 次以使<em class="mx">匹配零矩阵</em>的行尺寸，并且这些值被添加到 4×3 矩阵中。</p><pre class="mk ml mm mn gt nk nl nm nn aw no bi"><span id="7524" class="my kw ix nl b gy np nq l nr ns">y = start + add_rows  # add to each row of 'start'<br/>print(y)</span><span id="d84d" class="my kw ix nl b gy os nq l nr ns">[[ 1.  0.  2.]<br/> [ 1.  0.  2.]<br/> [ 1.  0.  2.]<br/> [ 1.  0.  2.]]</span></pre><p id="00ad" class="pw-post-body-paragraph ln lo ix lp b lq ms jy ls lt mt kb lv lw mu ly lz ma mv mc md me mw mg mh mi ij bi translated">创建列矩阵(向量)，</p><pre class="mk ml mm mn gt nk nl nm nn aw no bi"><span id="8d2c" class="my kw ix nl b gy np nq l nr ns"># create an ndarray which is 4 x 1 to broadcast across columns<br/>add_cols = np.array([[0,1,2,3]])<br/>add_cols = add_cols.T<br/>print(add_cols)</span><span id="f40b" class="my kw ix nl b gy os nq l nr ns">[[0]<br/> [1]<br/> [2]<br/> [3]]</span></pre><p id="372b" class="pw-post-body-paragraph ln lo ix lp b lq ms jy ls lt mt kb lv lw mu ly lz ma mv mc md me mw mg mh mi ij bi translated">将零矩阵(4x3)与(4x1)向量相加。自动地，4x1 向量被复制 3 次以使<em class="mx">匹配零矩阵</em>的列维度，并且这些值被添加到 4x3 矩阵中。</p><pre class="mk ml mm mn gt nk nl nm nn aw no bi"><span id="3812" class="my kw ix nl b gy np nq l nr ns"># add to each column of 'start' using broadcasting<br/>y = start + add_cols <br/>print(y)</span><span id="7912" class="my kw ix nl b gy os nq l nr ns">[[ 0.  0.  0.]<br/> [ 1.  1.  1.]<br/> [ 2.  2.  2.]<br/> [ 3.  3.  3.]]</span></pre><p id="3fb4" class="pw-post-body-paragraph ln lo ix lp b lq ms jy ls lt mt kb lv lw mu ly lz ma mv mc md me mw mg mh mi ij bi translated">最后，标量被视为 1x1 矩阵，并精确复制到加法矩阵的大小以执行运算。</p><pre class="mk ml mm mn gt nk nl nm nn aw no bi"><span id="ad50" class="my kw ix nl b gy np nq l nr ns"># this will just broadcast in both dimensions<br/>add_scalar = np.array([100])  <br/>print(start+add_scalar)</span><span id="2755" class="my kw ix nl b gy os nq l nr ns">[[ 100.  100.  100.]<br/> [ 100.  100.  100.]<br/> [ 100.  100.  100.]<br/> [ 100.  100.  100.]]</span></pre><p id="c247" class="pw-post-body-paragraph ln lo ix lp b lq ms jy ls lt mt kb lv lw mu ly lz ma mv mc md me mw mg mh mi ij bi translated">当您使用 NumPy 数组为像<a class="ae km" href="http://ufldl.stanford.edu/tutorial/supervised/OptimizationStochasticGradientDescent/" rel="noopener ugc nofollow" target="_blank">梯度下降</a>这样的算法编写矢量化代码时，广播的效用得到了最好的实现。<strong class="lp iy">吴恩达</strong> <a class="ae km" href="https://www.coursera.org/learn/neural-networks-deep-learning/lecture/uBuTv/broadcasting-in-python" rel="noopener ugc nofollow" target="_blank"> <strong class="lp iy">花了一个全视频讲座</strong> </a> <strong class="lp iy">在他新的深度学习课程中用 Python 解释广播的概念。</strong>它使得深度神经网络的前向和反向传播算法的实现相对无痛。</p><p id="fb69" class="pw-post-body-paragraph ln lo ix lp b lq ms jy ls lt mt kb lv lw mu ly lz ma mv mc md me mw mg mh mi ij bi translated">你也可以看看这个关于广播功能演示的视频…</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="ot ou l"/></div><figcaption class="ov ow gj gh gi ox oy bd b be z dk"><strong class="ak">Numpy Broadcasting explanation video</strong></figcaption></figure></div><div class="ab cl ko kp hu kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="ij ik il im in"><p id="5bbe" class="pw-post-body-paragraph ln lo ix lp b lq ms jy ls lt mt kb lv lw mu ly lz ma mv mc md me mw mg mh mi ij bi translated">如有问题或想法分享，请联系作者<a class="ae km" href="mailto:tirthajyoti@gmail.com" rel="noopener ugc nofollow" target="_blank"><strong class="lp iy">tirthajyoti【AT】Gmail . com</strong></a>。你也可以查看作者的<a class="ae km" href="https://github.com/tirthajyoti" rel="noopener ugc nofollow" target="_blank"> <strong class="lp iy"> GitHub 知识库</strong> </a>中其他有趣的 Python、R 或 MATLAB 代码片段和机器学习资源。也可以<a class="ae km" href="https://www.linkedin.com/in/tirthajyoti-sarkar-2127aa7/" rel="noopener ugc nofollow" target="_blank">在 LinkedIn 上关注我</a>。</p></div></div>    
</body>
</html>