<html>
<head>
<title>How to Visualise Black Box Optimization problems with Gaussian Processes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用高斯过程可视化黑盒优化问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-visualise-black-box-optimization-problems-with-gaussian-processes-a6128f99b09d?source=collection_archive---------11-----------------------#2018-10-03">https://towardsdatascience.com/how-to-visualise-black-box-optimization-problems-with-gaussian-processes-a6128f99b09d?source=collection_archive---------11-----------------------#2018-10-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/ca782a850e2472f1256e67619a8b4339.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NTAwSkx1l2k4am-TJwZ9hQ.png"/></div></div></figure><div class=""/><p id="6777" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">更新</strong>:我开了一家科技<a class="ae kw" href="http://www.legislate.tech" rel="noopener ugc nofollow" target="_blank">公司</a>。你可以在这里找到更多<a class="ae kw" href="https://medium.com/legislate/eliminate-the-work-in-paperwork-c053bfb0188c" rel="noopener"/></p><p id="237a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kx translated">缺乏框优化在机器学习中很常见，因为我们试图优化的过程或模型往往没有可以解析求解的代数模型。此外，在目标函数评估昂贵的某些使用情况下，一般方法包括创建目标函数的更简单的替代模型，该替代模型评估起来更便宜，并且将用于解决优化问题。在以前的一篇文章中，我解释了其中一种方法，贝叶斯优化，它使用高斯过程来逼近目标函数。这篇文章是一个 Python 教程，展示了如何使用贝叶斯优化 API<a class="ae kw" href="https://mindfoundry.ai/optaas" rel="noopener ugc nofollow" target="_blank">opta as</a>评估和可视化高斯过程代理。</p><div class="ip iq gp gr ir lg"><a rel="noopener follow" target="_blank" href="/the-intuitions-behind-bayesian-optimization-with-gaussian-processes-7e00fcc898a0"><div class="lh ab fo"><div class="li ab lj cl cj lk"><h2 class="bd jc gy z fp ll fr fs lm fu fw ja bi translated">高斯过程贝叶斯优化背后的直觉</h2><div class="ln l"><h3 class="bd b gy z fp ll fr fs lm fu fw dk translated">在某些应用中，目标函数是昂贵的或难以评估的。在这些情况下，一般…</h3></div><div class="lo l"><p class="bd b dl z fp ll fr fs lm fu fw dk translated">towardsdatascience.com</p></div></div><div class="lp l"><div class="lq l lr ls lt lp lu ix lg"/></div></div></a></div><p id="d0e8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本教程中，我们将使用 OPTaaS 来查找由以下公式定义的 Beale 函数的全局最小值:</p><figure class="lw lx ly lz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lv"><img src="../Images/c49131ecd92732ea3d6b533b9b9dd060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oKWQLUxwK6IX0G1qtyAxHw.png"/></div></div></figure><h2 id="b9af" class="ma mb jb bd mc md me dn mf mg mh dp mi kj mj mk ml kn mm mn mo kr mp mq mr ms bi translated">装置</h2><p id="cc32" class="pw-post-body-paragraph jy jz jb ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">OPTaaS 在<a class="ae kw" href="https://pypi.org/project/mindfoundry-optaas-client/" rel="noopener ugc nofollow" target="_blank"> PyPi </a>上，可以直接 pip 安装:</p><pre class="lw lx ly lz gt my mz na nb aw nc bi"><span id="58b0" class="ma mb jb mz b gy nd ne l nf ng">!pip install mindfoundry-optaas-client</span><span id="9b60" class="ma mb jb mz b gy nh ne l nf ng">%matplotlib inline<br/>from matplotlib import pyplot as plt<br/>import numpy as np</span><span id="6dd5" class="ma mb jb mz b gy nh ne l nf ng">from mindfoundry.optaas.client.client import OPTaaSClient, Goal<br/>from mindfoundry.optaas.client.parameter import FloatParameter</span></pre><h2 id="5375" class="ma mb jb bd mc md me dn mf mg mh dp mi kj mj mk ml kn mm mn mo kr mp mq mr ms bi translated">连接到 OPTaaS</h2><p id="f952" class="pw-post-body-paragraph jy jz jb ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">为了连接到 OPTaaS，您需要一个 API 密钥。你可以在这里得到一个<a class="ae kw" href="http://Charles.brecque@mindfoundry.ai" rel="noopener ugc nofollow" target="_blank"/>。</p><pre class="lw lx ly lz gt my mz na nb aw nc bi"><span id="dc78" class="ma mb jb mz b gy nd ne l nf ng">client = OPTaaSClient(OPTaaS_URL, OPTaaS_API_key)</span></pre><h2 id="ebdc" class="ma mb jb bd mc md me dn mf mg mh dp mi kj mj mk ml kn mm mn mo kr mp mq mr ms bi translated">创建任务</h2><p id="923e" class="pw-post-body-paragraph jy jz jb ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">要开始优化过程，我们需要定义参数并创建一个任务。</p><pre class="lw lx ly lz gt my mz na nb aw nc bi"><span id="126c" class="ma mb jb mz b gy nd ne l nf ng">parameters = [<br/>    FloatParameter(name='x', minimum=-4.5, maximum=4.5),<br/>    FloatParameter(name='y', minimum=-4.5, maximum=4.5),<br/>]</span><span id="b114" class="ma mb jb mz b gy nh ne l nf ng">initial_configurations = 5</span><span id="256a" class="ma mb jb mz b gy nh ne l nf ng">task = client.create_task(<br/>    title='Beale Optimization', <br/>    parameters=parameters, <br/>    goal=Goal.min,<br/>    initial_configurations=initial_configurations,<br/>    <br/>    <br/>)</span><span id="b2ff" class="ma mb jb mz b gy nh ne l nf ng">configurations = task.generate_configurations(initial_configurations)</span></pre><p id="6a3c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们需要生成一些初始均匀采样配置(5)来加权高斯过程代理模型。</p><p id="2fec" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于本教程的目的，我们将把优化过程分解成几个步骤，但是在一个典型的场景中，我们将简单地运行总迭代次数的任务。</p><h2 id="330a" class="ma mb jb bd mc md me dn mf mg mh dp mi kj mj mk ml kn mm mn mo kr mp mq mr ms bi translated">运行任务 5 次迭代</h2><pre class="lw lx ly lz gt my mz na nb aw nc bi"><span id="d5b8" class="ma mb jb mz b gy nd ne l nf ng">number_of_iterations = 5</span><span id="5fdc" class="ma mb jb mz b gy nh ne l nf ng">for i in range(number_of_iterations): <br/>    configuration = configurations[i]<br/>    x = configuration.values['x']<br/>    y = configuration.values['y']<br/>    score = beale_function(x, y) <br/>    next_configuration = task.record_result(configuration=configuration, score=score)<br/>    configurations.append(next_configuration)</span></pre><p id="94bf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们已经用初始配置对代理模型进行了加权，我们将检索它的值来可视化它。</p><h2 id="cf4e" class="ma mb jb bd mc md me dn mf mg mh dp mi kj mj mk ml kn mm mn mo kr mp mq mr ms bi translated">检索代理</h2><p id="2de3" class="pw-post-body-paragraph jy jz jb ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">我们将从 OPTaaS 生成的代理模型中请求预测。高斯过程替代模型的预测以它们的均值和方差为特征。</p><pre class="lw lx ly lz gt my mz na nb aw nc bi"><span id="6863" class="ma mb jb mz b gy nd ne l nf ng">random_configs_values = [{'x': np.random.uniform(-4.5, 4.5), <br/>                          'y': np.random.uniform(-4.5, 4.5)<br/>                          } for _ in range(1000)]</span><span id="699b" class="ma mb jb mz b gy nh ne l nf ng">predictions = task.get_surrogate_predictions(random_configs_values)</span><span id="8891" class="ma mb jb mz b gy nh ne l nf ng">mean = [p.mean for p in predictions]<br/>var = [p.variance for p in predictions]</span></pre><p id="e94d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在将检索对最初 5 种配置的 Beale 函数的评估:</p><pre class="lw lx ly lz gt my mz na nb aw nc bi"><span id="a2e3" class="ma mb jb mz b gy nd ne l nf ng">predictions = task.get_surrogate_predictions(random_configs_values)</span><span id="d10b" class="ma mb jb mz b gy nh ne l nf ng">surrogate_X = [[c['x'], c['y']] for c in random_configs_values]<br/>surrogate_X=np.array(surrogate_X)</span><span id="e22b" class="ma mb jb mz b gy nh ne l nf ng">results = task.get_results(include_configurations=True)</span><span id="32a3" class="ma mb jb mz b gy nh ne l nf ng">evaluations_config_values = [r.configuration.values for r in results]<br/>evaluations_score = [r.score for r in results]</span></pre><h2 id="a041" class="ma mb jb bd mc md me dn mf mg mh dp mi kj mj mk ml kn mm mn mo kr mp mq mr ms bi translated">绘制代理</h2><p id="8b85" class="pw-post-body-paragraph jy jz jb ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">我们现在将重新格式化这些值以绘制它们:</p><pre class="lw lx ly lz gt my mz na nb aw nc bi"><span id="59d5" class="ma mb jb mz b gy nd ne l nf ng">xs = [results[i].configuration.values['x'] for i in range(len(results)) ]<br/>ys = [results[i].configuration.values['y'] for i in range(len(results)) ]<br/>zs=evaluations_score</span><span id="853f" class="ma mb jb mz b gy nh ne l nf ng">beale=np.zeros(len(surrogate_X[:,1]))</span><span id="4fb5" class="ma mb jb mz b gy nh ne l nf ng">for i in range(len(surrogate_X[:,1])):<br/>    beale[i]=beale_function(surrogate_X[i,0], surrogate_X[i,1])</span></pre><p id="b0ce" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们将绘制代理函数与实函数的曲线图，并将曲线图与 OPTaaS 所做的函数求值叠加。</p><pre class="lw lx ly lz gt my mz na nb aw nc bi"><span id="2ff2" class="ma mb jb mz b gy nd ne l nf ng">plt.clf()<br/>fig = plt.figure(figsize=(20, 10))<br/>ax3d = fig.add_subplot(1, 2, 1, projection='3d')<br/>ax3d.view_init(15, 45)</span><span id="3f6c" class="ma mb jb mz b gy nh ne l nf ng">surface_plot = ax3d.plot_trisurf(surrogate_X[:,0], surrogate_X[:,1], np.array(mean), cmap=plt.get_cmap('coolwarm'), zorder=2, label='Surrogate')<br/>surface_plot.set_alpha(0.28)</span><span id="9bc5" class="ma mb jb mz b gy nh ne l nf ng">plt.title('Surrogate after 5 iterations')<br/>ax3d.plot(xs, ys,zs, 'x', label='evaluations')</span><span id="983a" class="ma mb jb mz b gy nh ne l nf ng">plt.xlabel('x')<br/>plt.ylabel('y')</span><span id="3bb7" class="ma mb jb mz b gy nh ne l nf ng">ax3d = fig.add_subplot(1, 2, 2, projection='3d')<br/>ax3d.view_init(15, 45)</span><span id="220b" class="ma mb jb mz b gy nh ne l nf ng">surface_plot_real = ax3d.plot_trisurf(surrogate_X[:,0], surrogate_X[:,1], true, cmap=plt.get_cmap('coolwarm'), zorder=2, label='real')<br/>surface_plot_real.set_alpha(0.28)</span><span id="b594" class="ma mb jb mz b gy nh ne l nf ng">plt.title('Real')<br/>ax3d.plot(xs, ys,zs, 'x', label='evaluations')</span><span id="1d45" class="ma mb jb mz b gy nh ne l nf ng">display(plt.gcf())</span><span id="3e55" class="ma mb jb mz b gy nh ne l nf ng">plt.close('all')</span></pre><p id="d887" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">哪些输出:</p><figure class="lw lx ly lz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ni"><img src="../Images/1edc8c5f42e95bea1cf5c2d0f1f093e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eJiwjIT7Wqk59kPcP9t1sw.png"/></div></div></figure><p id="c5bc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们所看到的，代理在 5 次迭代后看起来不太像真正的函数，但我们希望随着评估次数的增加，随着它对底层函数的了解增加，这种情况会有所改变。</p><h2 id="b082" class="ma mb jb bd mc md me dn mf mg mh dp mi kj mj mk ml kn mm mn mo kr mp mq mr ms bi translated">代理人的进化</h2><p id="2c6a" class="pw-post-body-paragraph jy jz jb ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">随着迭代次数的增加，代理很快适应了 Beale 函数的更真实的表示。这些图是用与上面相同的代码生成的。</p><figure class="lw lx ly lz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nj"><img src="../Images/53f31089a82d3de61550da9c46b758f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tFDoRaEI8T3W9vVwj2R6wA.png"/></div></div></figure><figure class="lw lx ly lz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nk"><img src="../Images/4eda8d3460d94856ea5bd256e6fd2920.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AUbXPCXkEMjs13_1WyNN-g.png"/></div></div></figure><figure class="lw lx ly lz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nl"><img src="../Images/3c195380ac454df7c0d3e3be55362b3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_2qA5IFBZ25cUa5YwQ0r8A.png"/></div></div></figure><p id="f46a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从不同的角度来看，相同的过程显示了 OPTaaS 性能的演变，并突出了接近最优值的推荐的集中程度:</p><figure class="lw lx ly lz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nm"><img src="../Images/c43fe934316e7f27b174c14a2216f7ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VSBt4h7wVXuM7_AbrWSFqw.png"/></div></div></figure><h2 id="5e39" class="ma mb jb bd mc md me dn mf mg mh dp mi kj mj mk ml kn mm mn mo kr mp mq mr ms bi translated">绘制方差的等值线图</h2><p id="bc57" class="pw-post-body-paragraph jy jz jb ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">我们也可以尝试用等值线图来显示替代变量的变化。蓝色阴影越深，表示相关预测的不确定性越低。</p><figure class="lw lx ly lz gt is gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/b6e942d36dde06e42c39ec69c19cce6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*yMkTNGANSl1xvir2EHnEeg.png"/></div></figure><h2 id="4fc8" class="ma mb jb bd mc md me dn mf mg mh dp mi kj mj mk ml kn mm mn mo kr mp mq mr ms bi translated">OPTaaS</h2><p id="f8f3" class="pw-post-body-paragraph jy jz jb ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">如果您有任何问题或想了解更多关于 OPTaaS 的信息，您可以查看以下链接:</p><p id="596b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">教程:<a class="ae kw" href="https://tutorial.optaas.mindfoundry.ai" rel="noopener ugc nofollow" target="_blank">https://tutorial . opta as . mind foundry . ai</a></p><p id="dcc2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">API 文档:<a class="ae kw" href="https://optaas.mindfoundry.ai" rel="noopener ugc nofollow" target="_blank">https://opta as . mind foundry . ai</a></p><p id="1108" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">研</strong><a class="ae kw" href="http://www.robots.ox.ac.uk/~mosb/projects/project/2009/01/01/bayesopt/" rel="noopener ugc nofollow" target="_blank">http://www . robots . ox . AC . uk/~ mosb/projects/project/2009/01/01/bayesopt/</a></p><p id="96a1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你仍然好奇，请随时给我发邮件了解更多信息和 API 密钥:<strong class="ka jc">Charles . bre cque @ mind foundry . ai</strong></p></div></div>    
</body>
</html>