<html>
<head>
<title>Association Rule Mining in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R 中的关联规则挖掘</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/association-rule-mining-in-r-ddf2d044ae50?source=collection_archive---------1-----------------------#2018-05-12">https://towardsdatascience.com/association-rule-mining-in-r-ddf2d044ae50?source=collection_archive---------1-----------------------#2018-05-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/3f6bad6da227da51ac3cc5705aec39cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*4kGZZwtiPOZ3sjLkirqHDQ.png"/></div></figure><div class=""/><p id="cec5" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi ks translated"><span class="l kt ku kv bm kw kx ky kz la di"/>关联规则挖掘(也称为关联规则学习)是一种常用技术，用于发现许多变量之间的关联。杂货店、电子商务网站和任何拥有大型事务数据库的人都经常使用它。我们在日常生活中遇到的一个最常见的例子是——当你在他们的网站上订购一些东西时，亚马逊知道你还想买什么。同样的想法也适用于 Spotify 他们知道你下一首想听的歌。所有这些都在某种程度上结合了数据挖掘概念和关联规则挖掘算法。</p><p id="e45c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi ks translated"><span class="l kt ku kv bm kw kx ky kz la di"> M </span>市场篮子分析类似于 ARM。购物篮分析是一种建模技术，其理论基础是，如果你购买了某一组商品，你就更有可能(或更不可能)购买另一组商品。例如，如果你在一家英国酒吧，你买了一品脱啤酒而没有买酒吧餐，你比没有买啤酒的人更有可能同时买薯片。</p><blockquote class="lb lc ld"><p id="57e4" class="ju jv le jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr ij bi translated"><em class="ix">基于强规则的概念，Rakesh Agrawal、Tomasz Imieliński 和 Arun Swami 引入了关联规则，用于在超市销售点(POS)系统记录的大规模交易数据中发现产品之间的规律性。</em></p></blockquote><p id="180e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw iy">本文解释了关联规则挖掘的概念以及如何在 R </strong>中使用这种技术</p><p id="029c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了在 R 中执行关联规则挖掘，我们使用 R 中的<code class="fe li lj lk ll b">arules</code>和<code class="fe li lj lk ll b">arulesViz</code>包。</p><blockquote class="lb lc ld"><p id="b9a5" class="ju jv le jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr ij bi translated"><a class="ae lm" href="https://cran.r-project.org/web/packages/arules/vignettes/arules.pdf" rel="noopener ugc nofollow" target="_blank"><em class="ix">Michael hassler 等人</em> </a> <em class="ix">创作并维护了两个非常有用的关联规则挖掘 R 包:arules 包和 arulesViz 包。</em></p></blockquote><p id="081c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果您的系统中没有安装这些软件包，请使用以下命令来安装它们。</p><pre class="ln lo lp lq gt lr ll ls lt aw lu bi"><span id="4e46" class="lv lw ix ll b gy lx ly l lz ma">&gt; install.packages("arules")<br/>&gt; install.packages("arulesViz")</span></pre><h1 id="5ab9" class="mb lw ix bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">数据</h1><p id="19d6" class="pw-post-body-paragraph ju jv ix jw b jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr ij bi translated">我使用的是与<code class="fe li lj lk ll b">arules</code>软件包捆绑在一起的 AdultUCI 数据集。</p><pre class="ln lo lp lq gt lr ll ls lt aw lu bi"><span id="96f6" class="lv lw ix ll b gy lx ly l lz ma">&gt; data(“Groceries”)</span></pre><p id="3d68" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们先检查食品杂货数据。</p><pre class="ln lo lp lq gt lr ll ls lt aw lu bi"><span id="1a61" class="lv lw ix ll b gy lx ly l lz ma">&gt; class(Groceries)<br/>      [1] "transactions"<br/>      attr(,"package")<br/>      [1] "arules"</span></pre><p id="a2ba" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是一个事务性数据集。</p><pre class="ln lo lp lq gt lr ll ls lt aw lu bi"><span id="f2ba" class="lv lw ix ll b gy lx ly l lz ma">&gt; inspect(head(Groceries, 2))<br/>          items                                                   <br/>      [1] {citrus fruit,semi-finished bread,margarine,ready soups}<br/>      [2] {tropical fruit,yogurt,coffee}</span></pre><p id="3441" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">从上面的输出中可以观察到前两个事务以及每个事务中涉及的项目。</p><h1 id="61c2" class="mb lw ix bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">生成规则</h1><p id="8794" class="pw-post-body-paragraph ju jv ix jw b jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr ij bi translated">有三个参数控制要生成的规则数量<em class="le">，即。</em> <strong class="jw iy">支持和信心</strong>。另一个参数<strong class="jw iy"> Lift </strong>是使用支持度和置信度生成的，并且是过滤生成的规则的主要参数之一。</p><ul class=""><li id="3622" class="nd ne ix jw b jx jy kb kc kf nf kj ng kn nh kr ni nj nk nl bi translated"><strong class="jw iy"> <em class="le">支持</em> </strong>是项集在数据集中出现频率的指示。只考虑上面输出中的两个事务。项目<em class="le">柑橘类水果</em>的支持度为 1/2，因为它只出现在两个交易中的 1 个中。</li><li id="5593" class="nd ne ix jw b jx nm kb nn kf no kj np kn nq kr ni nj nk nl bi translated"><strong class="jw iy"> <em class="le">置信度</em> </strong>是规则被发现为真的频率的指示。在生成规则之后，我们将讨论更多关于置信度的内容。</li></ul><p id="07f9" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们使用<em class="le">先验</em>算法找出规则。</p><pre class="ln lo lp lq gt lr ll ls lt aw lu bi"><span id="e154" class="lv lw ix ll b gy lx ly l lz ma">&gt; grocery_rules &lt;- apriori(Groceries, parameter = list(support = 0.01, confidence = 0.5))</span><span id="6def" class="lv lw ix ll b gy nr ly l lz ma">Apriori</span><span id="d66a" class="lv lw ix ll b gy nr ly l lz ma">Parameter specification:<br/>      confidence minval smax arem  aval originalSupport maxtime support minlen maxlen target   ext<br/>        0.5    0.1    1 none FALSE            TRUE       5    0.01      1     10  rules FALSE</span><span id="ccc5" class="lv lw ix ll b gy nr ly l lz ma">Algorithmic control:<br/>      filter tree heap memopt load sort verbose<br/>      0.1 TRUE TRUE  FALSE TRUE    2    TRUE</span><span id="0fb1" class="lv lw ix ll b gy nr ly l lz ma">Absolute minimum support count: 98</span><span id="2a81" class="lv lw ix ll b gy nr ly l lz ma">set item appearances ...[0 item(s)] done [0.00s].<br/>      set transactions ...[169 item(s), 9835 transaction(s)] done [0.00s].<br/>      sorting and recoding items ... [88 item(s)] done [0.00s].<br/>      creating transaction tree ... done [0.00s].<br/>      checking subsets of size 1 2 3 4 done [0.00s].<br/>      writing ... [15 rule(s)] done [0.00s].<br/>      creating S4 object  ... done [0.00s].</span></pre><p id="1f41" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Apriori 算法用给定的约束生成了 15 条规则。让我们深入到输出的参数规范部分。</p><ul class=""><li id="81d9" class="nd ne ix jw b jx jy kb kc kf nf kj ng kn nh kr ni nj nk nl bi translated"><strong class="jw iy"> <em class="le"> minval </em> </strong>是一个项集要成为规则的一部分所应满足的支持度的最小值。</li><li id="2565" class="nd ne ix jw b jx nm kb nn kf no kj np kn nq kr ni nj nk nl bi translated"><strong class="jw iy"> <em class="le"> smax </em> </strong>是一个项集的最大支持值。</li><li id="fac9" class="nd ne ix jw b jx nm kb nn kf no kj np kn nq kr ni nj nk nl bi translated"><strong class="jw iy"> <em class="le"> arem </em> </strong>是一个附加的规则评估参数。在上面的代码中，我们使用支持度和置信度限制了规则的数量。在函数中使用<strong class="jw iy"> arem </strong>参数有几种其他的方法来约束规则，我们将在本文后面讨论更多。</li><li id="5c8c" class="nd ne ix jw b jx nm kb nn kf no kj np kn nq kr ni nj nk nl bi translated"><strong class="jw iy"> <em class="le"> aval </em> </strong>是表示是否返回用 arem 选择的附加规则评估度量的逻辑。</li><li id="835b" class="nd ne ix jw b jx nm kb nn kf no kj np kn nq kr ni nj nk nl bi translated"><strong class="jw iy"> <em class="le">原始支持</em> </strong>传统的支持度值在计算支持度时只考虑 LHS 和 RHS 两个项目。如果您想仅使用 LHS 项目进行计算，则需要将其设置为 FALSE。</li><li id="6a46" class="nd ne ix jw b jx nm kb nn kf no kj np kn nq kr ni nj nk nl bi translated"><strong class="jw iy"> <em class="le"> maxtime </em> </strong>是允许检查子集的最大时间量。</li><li id="f6f0" class="nd ne ix jw b jx nm kb nn kf no kj np kn nq kr ni nj nk nl bi translated"><strong class="jw iy"> <em class="le"> minlen </em> </strong>是规则中要求的最小项数。</li><li id="715b" class="nd ne ix jw b jx nm kb nn kf no kj np kn nq kr ni nj nk nl bi translated"><strong class="jw iy"> <em class="le"> maxlen </em> </strong>是规则中可以出现的最大项数。</li></ul><pre class="ln lo lp lq gt lr ll ls lt aw lu bi"><span id="dd24" class="lv lw ix ll b gy lx ly l lz ma">&gt; inspect(head(sort(rules, by = "confidence"), 3))<br/>      lhs                                 rhs                support    confidence lift     count<br/>      [1] {citrus fruit,root vegetables}   =&gt; {other vegetables} 0.01037112 0.5862069  3.029608 102  <br/>      [2] {tropical fruit,root vegetables} =&gt; {other vegetables} 0.01230300 0.5845411  3.020999 121  <br/>      [3] {curd,yogurt}                    =&gt; {whole milk}       0.01006609 0.5823529  2.279125  99</span></pre><p id="b158" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上面显示了按置信度排序的前 3 条规则。</p><h1 id="cbca" class="mb lw ix bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">限制生成的规则数量</h1><p id="c209" class="pw-post-body-paragraph ju jv ix jw b jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr ij bi translated">在许多情况下，您希望限制生成的规则数量。例如，您可以在回归/分类中使用关联规则作为预测器。您可以生成规则，将规则的右侧作为您的响应，并将生成的规则用作建模特征。在这种情况下，您不希望使用所有生成的规则作为预测器，因为许多规则实际上是更大规则的子集，因此您希望消除它们。下面的代码片段显示了如何生成其 RHS 是预定义的规则。</p><pre class="ln lo lp lq gt lr ll ls lt aw lu bi"><span id="3566" class="lv lw ix ll b gy lx ly l lz ma">wholemilk_rules &lt;- <strong class="ll iy">apriori</strong>(data=Groceries, parameter=<strong class="ll iy">list</strong> (supp=0.001,conf = 0.08), appearance = <strong class="ll iy">list</strong> (rhs="whole milk"))</span><span id="faac" class="lv lw ix ll b gy nr ly l lz ma"># The above code shows what products are bought before buying "whole milk" and will generate rules that lead to buying "whole milk".</span></pre><p id="cbd4" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以通过调整一些参数来限制规则的数量。虽然参数调整取决于您正在处理的数据类型，但最常见的方法包括更改支持度、置信度和其他参数，如 minlen、maxlen 等。</p><pre class="ln lo lp lq gt lr ll ls lt aw lu bi"><span id="de0a" class="lv lw ix ll b gy lx ly l lz ma">&gt; grocery_rules_increased_support &lt;- apriori(Groceries, parameter = list(support = 0.02, confidence = 0.5))</span><span id="7dbe" class="lv lw ix ll b gy nr ly l lz ma"># This generates only one rule in the output.</span></pre><p id="de6d" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你想让<strong class="jw iy">变得更强</strong>规则，你必须增加信心。如果您想要<strong class="jw iy">更长的</strong>规则，请增加 maxlen 参数。如果您想消除<strong class="jw iy">较短的</strong>嵌线，减小 minlen 参数。</p><p id="9aa6" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有时，您可能想找到包含最大数量项目的规则，并删除作为较长规则子集的较短规则。下面的代码删除了这些多余的规则。</p><pre class="ln lo lp lq gt lr ll ls lt aw lu bi"><span id="a092" class="lv lw ix ll b gy lx ly l lz ma">&gt; subsets &lt;- which(colSums(is.subset(grocery_rules, groery_rules)) &gt; 1)<br/>&gt; grocery_rules &lt;- grocery_rules[-subsets]</span></pre><p id="79f5" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们看看之前描述过的<strong class="jw iy"> arem </strong>参数。规则生成后，根据参数<em class="le"> arem </em>的值进一步评估。<em class="le"> arem </em>参数取值如下:<em class="le"> none </em>，<em class="le"> diff </em>，<em class="le"> quot </em>，<em class="le"> aimp </em>，<em class="le"> info </em>，<em class="le"> chi2 </em>。</p><pre class="ln lo lp lq gt lr ll ls lt aw lu bi"><span id="4396" class="lv lw ix ll b gy lx ly l lz ma"># This gives more than 1,500,000 rules<br/>&gt; rules &lt;- apriori(Groceries, parameter = list(supp = 0.0001, conf = 0.5))</span><span id="f26f" class="lv lw ix ll b gy nr ly l lz ma"># This gives 982,000 rules.<br/>&gt; rules_chi2 &lt;- apriori(Groceries, parameter = list(supp = 0.0001, conf = 0.5, arem = "chi2"))</span></pre><h1 id="41f3" class="mb lw ix bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">将数据帧转换成事务数据</h1><p id="fd52" class="pw-post-body-paragraph ju jv ix jw b jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr ij bi translated">使用与<code class="fe li lj lk ll b">arules</code>包捆绑的<code class="fe li lj lk ll b">AdultUCI</code>数据集。</p><pre class="ln lo lp lq gt lr ll ls lt aw lu bi"><span id="e016" class="lv lw ix ll b gy lx ly l lz ma">&gt; data("AdultUCI")<br/>&gt; class(AdultUCI)<br/>      "data.frame"</span></pre><p id="70f6" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当您查看 AdultUCI 数据帧的结构时，您会发现有几列是数字。事务性数据集的每个事务都包含该事务中涉及的项的列表。当我们将数据帧转换成事务性数据集时，该数据帧的每一行都将成为一个事务。每一列都将成为一个项目。但是，如果列的值是数字，则不能使用它，因为该列可以接受无限个值。因此，在将 dataframe 转换为事务性数据集之前，我们必须确保将每一列转换为因子或逻辑，以确保该列仅从固定集中取值。</p><pre class="ln lo lp lq gt lr ll ls lt aw lu bi"><span id="e360" class="lv lw ix ll b gy lx ly l lz ma">&gt; str(AdultUCI)<br/>'data.frame':	48842 obs. of  15 variables:<br/> $ age           : int  39 50 38 53 28 37 49 52 31 42 ...<br/> $ workclass     : Factor w/ 8 levels "Federal-gov",..: 7 6 4 4 4 4 <br/> $ fnlwgt        : int  77516 83311 215646 234721 338409 284582 <br/> $ education     : Ord.factor w/ 16 levels "Preschool"&lt;"1st-4th"&lt;..: <br/> $ education-num : int  13 13 9 7 13 14 5 9 14 13 ...<br/> $ marital-status: Factor w/ 7 levels "Divorced","Married-AF-Spouse"<br/> $ occupation    : Factor w/ 14 levels "Adm-clerical",..: 1 4 6 6 10 <br/> $ relationship  : Factor w/ 6 levels "Husband","Not-in-family",..: <br/> $ race          : Factor w/ 5 levels "Amer-Indian-Eskimo",..: 5 5 5 <br/> $ sex           : Factor w/ 2 levels "Female","Male": 2 2 2 2 1 1 1 <br/> $ capital-gain  : int  2174 0 0 0 0 0 0 0 14084 5178 ...<br/> $ capital-loss  : int  0 0 0 0 0 0 0 0 0 0 ...<br/> $ hours-per-week: int  40 13 40 40 40 40 16 45 50 40 ...<br/> $ native-country: Factor w/ 41 levels "Cambodia","Canada",..: 39 39 <br/> $ income        : Ord.factor w/ 2 levels "small"&lt;"large": 1 1 1 1 1 </span></pre><p id="c6bb" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在<code class="fe li lj lk ll b">AdultUCI</code>数据帧中，第 1、3、5、11、12、13 列是整数。所以把每一列都转换成因子。</p><pre class="ln lo lp lq gt lr ll ls lt aw lu bi"><span id="d245" class="lv lw ix ll b gy lx ly l lz ma">&gt; AdultUCI &lt;- lapply(AdultUCI, function(x){as.factor(x)})</span><span id="02a7" class="lv lw ix ll b gy nr ly l lz ma">&gt; str(AdultUCI)<br/>List of 15<br/> $ age           : Factor w/ 74 levels "17","18","19",..: 23 34 22 <br/> $ workclass     : Factor w/ 8 levels "Federal-gov",..: 7 6 4 4 4 4 <br/> $ fnlwgt        : Factor w/ 28523 levels "12285","13492",..: 3462 <br/> $ education     : Ord.factor w/ 16 levels "Preschool"&lt;"1st-4th"&lt;..: <br/> $ education-num : Factor w/ 16 levels "1","2","3","4",..: 13 13 9 7 <br/> $ marital-status: Factor w/ 7 levels "Divorced","Married-AF-<br/> $ occupation    : Factor w/ 14 levels "Adm-clerical",..: 1 4 6 6 10 <br/> $ relationship  : Factor w/ 6 levels "Husband","Not-in-family",..: <br/> $ race          : Factor w/ 5 levels "Amer-Indian-Eskimo",..: 5 5 5 <br/> $ sex           : Factor w/ 2 levels "Female","Male": 2 2 2 2 1 1 <br/> $ capital-gain  : Factor w/ 123 levels "0","114","401",..: 28 1 1 1<br/> $ capital-loss  : Factor w/ 99 levels "0","155","213",..: 1 1 1 1 1<br/> $ hours-per-week: Factor w/ 96 levels "1","2","3","4",..: 40 13 40<br/> $ native-country: Factor w/ 41 levels "Cambodia","Canada",..: 39 39<br/> $ income        : Ord.factor w/ 2 levels "small"&lt;"large": 1 1 1 1 1 </span></pre><p id="917d" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在<code class="fe li lj lk ll b">AdultUCI</code> dataframe 可以使用下面的代码片段转换成事务性数据集。</p><pre class="ln lo lp lq gt lr ll ls lt aw lu bi"><span id="0432" class="lv lw ix ll b gy lx ly l lz ma">&gt; transactional_data &lt;- as(AdultUCI, "transactions")</span></pre><p id="88d6" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这篇关于关联规则挖掘的文章到此结束。</p></div></div>    
</body>
</html>