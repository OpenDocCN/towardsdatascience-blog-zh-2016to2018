<html>
<head>
<title>Depth First Search In Undirected Graphs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无向图中的深度优先搜索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/depth-first-search-in-undirected-graphs-8d563ef4004e?source=collection_archive---------2-----------------------#2017-03-20">https://towardsdatascience.com/depth-first-search-in-undirected-graphs-8d563ef4004e?source=collection_archive---------2-----------------------#2017-03-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/1dfad2b543c7aac205688918e9a1e879.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*iY9Tf8lilfGXXtBGSfe8OQ.png"/></div></figure><p id="c82e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">S. Dasgupta、C. H. Papadimitriou 和 U. V. Vazirani 所著的《算法》一书的第 3 章和第 4 章主要关注图。一个图被指定为一组顶点<code class="fe ks kt ku kv b">V</code>(或节点)和所选顶点对之间的边<code class="fe ks kt ku kv b">E</code>。使用图表的一个很大的优点是，当解决问题时，图表提供了清晰性，因为它们没有杂乱的无关信息，只有数学对象。</p><h1 id="3679" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">图表示</h1><p id="6d5f" class="pw-post-body-paragraph ju jv iq jw b jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr ij bi translated">具有<code class="fe ks kt ku kv b">n=|V|</code>顶点<code class="fe ks kt ku kv b">v1,...,vn</code>的图可以表示为一个矩阵(<code class="fe ks kt ku kv b">n x n</code>的数组)，其<code class="fe ks kt ku kv b">(i, j)th</code>条目为:</p><ul class=""><li id="81e2" class="lz ma iq jw b jx jy kb kc kf mb kj mc kn md kr me mf mg mh bi translated">1 如果从<code class="fe ks kt ku kv b">vi</code>到<code class="fe ks kt ku kv b">vj</code>有边沿</li><li id="fde0" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr me mf mg mh bi translated">否则为 0</li></ul><p id="e7c6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在图的矩阵表示中，可以在恒定时间内检查特定边的存在，但是它需要<code class="fe ks kt ku kv b">O(n^2)</code>存储空间，如果图没有很多边，这可能是浪费。图的另一种表示是邻接表。它由<code class="fe ks kt ku kv b">|V|</code>链表组成(每个顶点一个)。然后，顶点<code class="fe ks kt ku kv b">u</code>的链表保存<code class="fe ks kt ku kv b">u</code>具有的顶点的名称和输出边。与矩阵表示相反，验证特定边的存在现在是线性的(通过运行相应的链表)，但是存储图形所需的内存是<code class="fe ks kt ku kv b">O(|E|)</code>。</p><p id="42c6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个图可以根据它的边数分类如下:</p><ul class=""><li id="d809" class="lz ma iq jw b jx jy kb kc kf mb kj mc kn md kr me mf mg mh bi translated">稠密图:边的数量接近于图所能拥有的最大边数</li><li id="041d" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr me mf mg mh bi translated">稀疏图:边的数量接近于图所能拥有的最小边数</li></ul><p id="2d22" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这一点很重要，因为在处理图形时，它在选择合适的数据结构和算法时起着很大的作用。例如，为了将万维网存储为图(一个网页是一个顶点，并且它具有到它具有超级链接的所有其他网页的边)，使用邻接表更方便，因为万维网图非常稀疏(在数十亿种可能性中，平均一个网页仅具有到大约六个其他网页的超级链接)。</p><h1 id="4e54" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">无向图中的深度优先搜索</h1><p id="7967" class="pw-post-body-paragraph ju jv iq jw b jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr ij bi translated">作者在第三章中考察的第一个算法是无向图中的深度优先搜索。在无向图中，连接在一起的顶点有双向边。</p><p id="8828" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">深度优先搜索是一种线性时间算法，它基本上回答了以下问题:</p><ul class=""><li id="bc9a" class="lz ma iq jw b jx jy kb kc kf mb kj mc kn md kr me mf mg mh bi translated">从给定的顶点可以到达图的哪些部分？</li></ul><p id="4fda" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">深度优先搜索算法的以下实现使用邻接表并返回从指定顶点可达的图的所有顶点。</p><h1 id="a72c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">深度优先搜索算法</h1><h2 id="654d" class="mn kx iq bd ky mo mp dn lc mq mr dp lg kf ms mt lk kj mu mv lo kn mw mx ls my bi translated"><a class="ae mz" href="https://en.wikipedia.org/wiki/Depth-first_search" rel="noopener ugc nofollow" target="_blank">伪代码:</a></h2><pre class="na nb nc nd gt ne kv nf ng aw nh bi"><span id="612a" class="mn kx iq kv b gy ni nj l nk nl">procedure DFS(G,v):<br/>  label v as discovered<br/>  for all edges from v to w in G.adjacentEdges(v) do<br/>    if vertex w is not labeled as discovered then<br/>      recursively call DFS(G,w)</span></pre><h2 id="c6c2" class="mn kx iq bd ky mo mp dn lc mq mr dp lg kf ms mt lk kj mu mv lo kn mw mx ls my bi translated">实施:</h2><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="b21d" class="mn kx iq bd ky mo mp dn lc mq mr dp lg kf ms mt lk kj mu mv lo kn mw mx ls my bi translated">测试:</h2><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h1 id="6793" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="1097" class="pw-post-body-paragraph ju jv iq jw b jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr ij bi translated">深度优先搜索是一个有趣的算法，正如你可能怀疑的那样，它特别适合于检查一个图是否连通；如果深度优先搜索返回的树包含图中的所有顶点，则它是连通的，否则不是。</p></div></div>    
</body>
</html>