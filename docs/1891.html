<html>
<head>
<title>Data comes in different shapes and sizes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据有不同的形状和大小</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-comes-in-different-shapes-and-sizes-ac5b411456c4?source=collection_archive---------2-----------------------#2017-11-11">https://towardsdatascience.com/data-comes-in-different-shapes-and-sizes-ac5b411456c4?source=collection_archive---------2-----------------------#2017-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/2d8393b5493fc6386df273d2096e507a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bfCg9KH87DlEkatWuOwZ1w.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="cd8e" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">让我们来谈谈表格、树和图形</h2></div><p id="b042" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae lm" href="https://en.wikipedia.org/wiki/Table_(information)" rel="noopener ugc nofollow" target="_blank">表格</a> —数据的表格化表示，可能是最古老的数据存储方式。也是最简单的。我们定义了行和列，其中一列代表一个属性，一行代表一个由属性组合而成的条目。</p><p id="3dc4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae lm" href="https://en.wikipedia.org/wiki/Comma-separated_values" rel="noopener ugc nofollow" target="_blank"> CSV </a>是表格数据的简单表示。下面你可以看到一个代表我最亲近的家人的 CSV:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="c10a" class="lw lx jb ls b gy ly lz l ma mb">Maxim,June 12,Berlin<br/>Efim,November 24,Essen<br/>Margarita,August 20,Bochum<br/>Issai,May 9,Bochum</span></pre><p id="9831" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">每行代表一个家庭成员，家庭成员由以下属性表示:</p><ul class=""><li id="ede8" class="mc md jb ks b kt ku kw kx kz me ld mf lh mg ll mh mi mj mk bi translated">名字</li><li id="8ffb" class="mc md jb ks b kt ml kw mm kz mn ld mo lh mp ll mh mi mj mk bi translated">生日</li><li id="76cc" class="mc md jb ks b kt ml kw mm kz mn ld mo lh mp ll mh mi mj mk bi translated">城市</li></ul><p id="777b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这些属性很好地代表了一个人，但是它们没有说明这些人之间的关系。如果我们添加另外三个属性来建立它们之间的关系会怎么样:</p><ul class=""><li id="fb58" class="mc md jb ks b kt ku kw kx kz me ld mf lh mg ll mh mi mj mk bi translated">父亲</li><li id="3f31" class="mc md jb ks b kt ml kw mm kz mn ld mo lh mp ll mh mi mj mk bi translated">母亲</li><li id="48b1" class="mc md jb ks b kt ml kw mm kz mn ld mo lh mp ll mh mi mj mk bi translated">同科</li></ul><p id="860b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这种情况下，CSV 可能如下所示:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="6291" class="lw lx jb ls b gy ly lz l ma mb">Maxim,June 12,Berlin,3,2,1<br/>Efim,November 24,Essen,3,2,0<br/>Margarita,August 20,Bochum,,,<br/>Issai,May 9,Bochum,,,</span></pre><p id="b830" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这些关系被描述为行的索引(索引从 0 开始)。</p><p id="9c51" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">所以马克西姆的父亲是伊萨伊，马克西姆的母亲是玛格丽塔，马克西姆的兄弟姐妹是埃菲姆。在第二行，我们看到 Maxim 是 Efims 的兄弟姐妹(这并不奇怪),他们有相同的父母。Margarita 和 Issai 没有提到父亲、母亲和兄弟姐妹，不是因为他们没有，而是因为这些人没有列在这个数据集中。</p><h2 id="cae1" class="lw lx jb bd mq mr ms dn mt mu mv dp mw kz mx my mz ld na nb nc lh nd ne nf ng bi translated">如果马克西姆有多个兄弟姐妹会怎么样？</h2><p id="5966" class="pw-post-body-paragraph kq kr jb ks b kt nh kc kv kw ni kf ky kz nj lb lc ld nk lf lg lh nl lj lk ll ij bi translated">在 CSV 和一般表格数据表示的情况下，这是非常不幸的。然而，我们有两个选择:</p><ol class=""><li id="8d80" class="mc md jb ks b kt ku kw kx kz me ld mf lh mg ll nm mi mj mk bi translated">为值数组创建自定义语法。例如，使用<code class="fe nn no np ls b">+</code>字符分隔多个行索引<code class="fe nn no np ls b">1+10+12</code>。</li><li id="95c4" class="mc md jb ks b kt ml kw mm kz mn ld mo lh mp ll nm mi mj mk bi translated">有第二个表，表示关系的<a class="ae lm" href="https://en.wikipedia.org/wiki/Adjacency_matrix" rel="noopener ugc nofollow" target="_blank">邻接矩阵</a>。对于 CSV 格式，每个文件只能有一个表，所以我们需要创建另一个文件。</li></ol></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="af16" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们了解到，表格数据表示适用于一对一和多对一的关系，但是如果我们需要一对多的关系，就会变得棘手。</p><h2 id="3148" class="lw lx jb bd mq mr ms dn mt mu mv dp mw kz mx my mz ld na nb nc lh nd ne nf ng bi translated">树呢？</h2><p id="37d6" class="pw-post-body-paragraph kq kr jb ks b kt nh kc kv kw ni kf ky kz nj lb lc ld nk lf lg lh nl lj lk ll ij bi translated"><a class="ae lm" href="https://en.wikipedia.org/wiki/Tree_(data_structure)" rel="noopener ugc nofollow" target="_blank">树</a>中的<a class="ae lm" href="https://en.wikipedia.org/wiki/Node_(computer_science)" rel="noopener ugc nofollow" target="_blank">节点</a>(如果它不是叶子)与其子节点有一对多的关系。让我们试着用<a class="ae lm" href="https://en.wikipedia.org/wiki/XML" rel="noopener ugc nofollow" target="_blank"> XML </a>来表示相同的数据:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="c69f" class="lw lx jb ls b gy ly lz l ma mb">&lt;person name="Maxim" birthday="June 12" city="Berlin"&gt;<br/> &lt;father&gt;<br/>  &lt;person name="Issai" birthday="May 9" city="Bochum"/&gt;<br/> &lt;/father&gt;<br/> &lt;mother&gt;<br/>  &lt;person name="Margarita" birthday="August 20" city="Bochum"/&gt;<br/> &lt;/mother&gt;<br/> &lt;siblings&gt;<br/>  &lt;person name="Efim" birthday="November 24" city="Essen"&gt;<br/>   &lt;!-- 😔 we have to repeat father and mother now --&gt;<br/>   &lt;father&gt;<br/>    &lt;person name="Issai" birthday="May 9" city="Bochum"/&gt;<br/>   &lt;/father&gt;<br/>   &lt;mother&gt;<br/>    &lt;person name="Margarita" birthday="August 20" city="Bochum"/&gt;<br/>   &lt;/mother&gt;<br/>   &lt;siblings&gt;<br/>    &lt;!-- 😨 OMG we have a cycle, abort!!! --&gt;<br/>   &lt;/siblings&gt;<br/>  &lt;/person&gt;<br/> &lt;/siblings&gt;<br/>&lt;/person&gt;</span></pre><p id="d7ff" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一棵树必须有一个根元素。在我们的第一次尝试中，我们改变了数据集的语义，并决定将其表示为 Maxim 的“家谱”。然而，这也强调了我们的数据对于这种表示来说太复杂了。当我们添加 Efim 作为兄弟姐妹时，我们必须复制 Issai 和 Margarita。然后我们意识到 Efim 和 Maxim 建立了一个参考循环。这使得纯粹的<a class="ae lm" href="https://en.wikipedia.org/wiki/Hierarchy" rel="noopener ugc nofollow" target="_blank">层次化</a>表示成为不可能。</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="748a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">好，让我们尝试使用带有显式引用的 XML:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="f534" class="lw lx jb ls b gy ly lz l ma mb">&lt;people&gt;<br/> &lt;person id="0" name="Maxim" birthday="June 12" city="Berlin"&gt;<br/>  &lt;father ref="3"/&gt;<br/>  &lt;mother ref="2"/&gt;<br/>  &lt;sibling ref="1"&gt;<br/>  &lt;!-- could have another sibling tag here<br/>  &lt;sibling ref="123"&gt;<br/>  --&gt;<br/> &lt;/person&gt;<br/> &lt;person id="1" name="Efim" birthday="November 24" city="Essen"&gt;<br/>  &lt;father ref="3"/&gt;<br/>  &lt;mother ref="2"/&gt;<br/>  &lt;sibling ref="0"&gt;<br/> &lt;/person&gt;<br/> &lt;person id="2" name="Margarita" birthday="August 20" city="Bochum"/&gt;<br/> &lt;person id="3" name="Issai" birthday="May 9" city="Bochum"/&gt;<br/>&lt;/people&gt;</span></pre><p id="bf3f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在我们可以在一个<code class="fe nn no np ls b">person</code>节点中拥有多个<code class="fe nn no np ls b">sibling</code>节点。然而，与 CSV 相比，我们有一个小缺点。CSV 中的引用是行的索引。在 XML 中，一个节点可能会根据解析器和 XML producer 的实现来改变它的索引，因此有必要在每个 person 节点上有一个显式的<code class="fe nn no np ls b">id</code>属性，在<code class="fe nn no np ls b">father</code> <code class="fe nn no np ls b">mother</code> <code class="fe nn no np ls b">sibling</code>节点上有一个<code class="fe nn no np ls b">ref</code>属性，它们反映了 person 的 id。当我们写数据时，这不是一个很大的不便，但当我们读数据时，这是一个更大的不便。为了遵循参考，用户将不得不建立某种类型的<a class="ae lm" href="https://en.wikipedia.org/wiki/Lookup_table" rel="noopener ugc nofollow" target="_blank">查找表</a>，其中可以通过<code class="fe nn no np ls b">id</code>找到一个人。</p><h2 id="99f6" class="lw lx jb bd mq mr ms dn mt mu mv dp mw kz mx my mz ld na nb nc lh nd ne nf ng bi translated">JSON 能帮我们解决这个问题吗？</h2><p id="7253" class="pw-post-body-paragraph kq kr jb ks b kt nh kc kv kw ni kf ky kz nj lb lc ld nk lf lg lh nl lj lk ll ij bi translated"><a class="ae lm" href="https://en.wikipedia.org/wiki/JSON" rel="noopener ugc nofollow" target="_blank"> JSON </a>也是一个树形结构，但是如果 XML 是非常同构的——我们只能通过元素和内容来描述数据。JSON 是异构的——我们有数组、对象、字符串、数字、布尔文字和<code class="fe nn no np ls b">null</code>供我们使用。在 JSON 中，我们可以如下表示相同的数据集:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="80c6" class="lw lx jb ls b gy ly lz l ma mb">[<br/> {<br/>  "name":"Maxim",<br/>  "birthday":"June 12",<br/>  "city":"Berlin",<br/>  "father":3,<br/>  "mother":2,<br/>  "siblings":[1]<br/> },{<br/>  "name":"Efim",<br/>  "birthday":"November 24",<br/>  "city":"Essen",<br/>  "father":3,<br/>  "mother":2,<br/>  "siblings":[0]<br/> },{<br/>  "name":"Margarita",<br/>  "birthday":"August 20",<br/>  "city":"Bochum"<br/> },{<br/>  "name":"Issai",<br/>  "birthday":"May 9",<br/>  "city":"Bochum"<br/> }<br/>]</span></pre><p id="d69c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们说根元素是一个数组。它有三个子对象，其中<code class="fe nn no np ls b">siblings</code> property 是一个人员索引数组。数组中的元素有一个稳定的索引，所以我们不需要显式的<code class="fe nn no np ls b">id</code>属性。我们还避免构建显式的查找表，因为数组可以通过索引来访问。</p><h2 id="5d0e" class="lw lx jb bd mq mr ms dn mt mu mv dp mw kz mx my mz ld na nb nc lh nd ne nf ng bi translated">有些事我们还没谈过。</h2><p id="978c" class="pw-post-body-paragraph kq kr jb ks b kt nh kc kv kw ni kf ky kz nj lb lc ld nk lf lg lh nl lj lk ll ij bi translated">CSV、XML 和 JSON 都是基于文本的格式。为了处理数据集并遵循引用，我们需要解析数据集并将其转换成某种内存模型。如果我们有一个大的数据集，这可能会变得非常不方便。</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h2 id="a755" class="lw lx jb bd mq mr ms dn mt mu mv dp mw kz mx my mz ld na nb nc lh nd ne nf ng bi translated">文本与二进制</h2><p id="3129" class="pw-post-body-paragraph kq kr jb ks b kt nh kc kv kw ni kf ky kz nj lb lc ld nk lf lg lh nl lj lk ll ij bi translated">当我们从文本表示切换到二进制表示时，我们可以选择/构建一种允许随机值访问的格式。在这种情况下，引用可以由我们所引用条目的偏移量来表示。</p><p id="c2c1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">偏移量可以是绝对的，也可以是相对的。绝对偏移量对于读、写和验证操作来说更简单。一个相对偏移量，可以帮助你减少二进制文件的大小，用户可以将多个缓冲区合并到一个文件中。如果你有兴趣，可以看看下面这篇文章:<a class="ae lm" href="https://github.com/mzaks/FlatBuffersSwift" rel="noopener ugc nofollow" target="_blank">flatbufferswift</a>是如何解决这种技术的:</p><div class="ip iq gp gr ir nx"><a href="https://medium.com/@icex33/performance-is-not-the-only-thing-you-lose-while-using-json-d7fc788c3056" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd jc gy z fp oc fr fs od fu fw ja bi translated">使用 JSON 时，性能并不是唯一损失的东西</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">这个来自 RSAnimate 的短片告诉我们，我不可能在 100 篇文章中做到这一点。</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">medium.com</p></div></div></div></a></div><h2 id="d915" class="lw lx jb bd mq mr ms dn mt mu mv dp mw kz mx my mz ld na nb nc lh nd ne nf ng bi translated">感谢您抽出宝贵的时间，如果您喜欢这篇文章，请鼓掌。</h2></div></div>    
</body>
</html>