<html>
<head>
<title>Freezing a Keras model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">冻结 Keras 模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/freezing-a-keras-model-c2e26cb84a38?source=collection_archive---------2-----------------------#2018-09-11">https://towardsdatascience.com/freezing-a-keras-model-c2e26cb84a38?source=collection_archive---------2-----------------------#2018-09-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5da9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何为服务和其他应用程序冻结模型</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/71535e0be9827876bda8dd28192b50e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vWBx6y0cjlf-LHK_"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">“landscape photography of snowy mountain and body of water” by <a class="ae kv" href="https://unsplash.com/@theforestbirds?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joel &amp; Jasmin Førestbird</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="8214" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">简介</strong></h1><p id="e167" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Keras 已经成为工业界和学术界开发和测试神经网络的主要 API 之一。由于其各种后端可能性，它结合了用户友好的语法和灵活性，这意味着你可以用 TensorFlow，Theano 或 CNTK 编写并在 Keras 中调用它。</p><p id="e08f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一旦你用 Keras 设计了一个网络，你可能想在另一个 API 中，在网络上，或者在其他媒介上服务它。做上述许多事情的最简单的方法之一是使用预先构建的 TensorFlow 库(例如用于 C++环境中的模型推理的<a class="ae kv" href="https://www.tensorflow.org/api_guides/cc/guide" rel="noopener ugc nofollow" target="_blank"> TensorFlow C++ API </a>)。为了做到这一点，由于这些 API 的后端工作方式，您很可能不得不“冻结”您训练过的 Keras 模型。不幸的是，为了轻松地做到这一点，您必须在 Keras 的 TensorFlow 实现中重新训练您的模型。然而，幸运的是，如果你知道你的目标是什么，这个过程非常简单，这要归功于 Keras 集成到 TensorFlow 的方式，以及 TensorFlow 为此任务提供的各种其他材料。</p><p id="b429" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当我最初研究如何在 C++环境中为模型提供服务时，我从类似的帖子中找到了几个可能的答案，比如关于<a class="ae kv" href="https://stackoverflow.com/questions/36720498/convert-keras-model-to-c" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>的帖子，以及关于<a class="ae kv" href="https://medium.com/@hamedmp/exporting-trained-tensorflow-models-to-c-the-right-way-cf24b609d183" rel="noopener">介质</a>的帖子。类似地，一些人已经制作了各种很棒的开源包来做到这一点，比如<a class="ae kv" href="https://github.com/pplonski/keras2cpp" rel="noopener ugc nofollow" target="_blank"> keras2cpp </a>。然而，我发现这些文章缺乏一些关键的细节，并且经常使用复杂的技术，这些技术在写作时是必要的，但由于 TensorFlow 的更新，这些技术已经大大简化了。</p><p id="1ea7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我希望这篇文章提供了一个简单的、最新的演练，展示了如何为任何一般需求冻结 Keras 模型，而不仅仅是为了在 C++环境中服务。虽然本文中描述的方法是专门为转换 Keras API 中编写的模型(本机或 TensorFlow 实现)而编写的，但它也可以用于任何用本机 TensorFlow 编写的模型。</p><h2 id="db81" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">为什么我需要转换我的模型？</h2><p id="ecda" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果您的模型经过训练并保存在 Keras API 中，那么您可能已经保存了模型的 hdf5 文件，其中网络架构和权重一起保存在一个文件中。这个文件可以被调用并加载回 Keras API 进行推理。然而，遗憾的是，TensorFlow APIs 无法识别这种文件类型，而且存储、加载和执行推理也不必要太大。</p><p id="e531" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">同样，如果你在 TensorFlow Python API 中编写一个模型，那么训练过程将使用 Google 的<a class="ae kv" href="https://www.tensorflow.org/extend/tool_developers/" rel="noopener ugc nofollow" target="_blank"> ProtoBuf 库</a>保存一个 TensorFlow <a class="ae kv" href="https://www.tensorflow.org/guide/graphs" rel="noopener ugc nofollow" target="_blank">图</a>，以及一系列检查点文件。该图存储了关于带有<code class="fe nb nc nd ne b">Variable</code> ops 的网络架构的信息，而检查点文件包含了训练不同阶段的权重值(取决于训练期间您的会话检查点的频率)。这些通常可以在 TensorFlow Python API 会话中加载用于推断，在此期间，来自检查点文件的权重被插入到图中的<code class="fe nb nc nd ne b">Variable</code> ops 中。然而，当仅仅执行推理时，这是低效的。另一方面，一个保存的 Keras <code class="fe nb nc nd ne b">.h5</code>文件仅仅是图形和最终状态检查点文件的组合，同时仍然保持超参数存储为<code class="fe nb nc nd ne b">Variable</code> ops。(注:以上不需要详细了解，我只是给想要更详细解释的人补充一下。)</p><p id="7093" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">冻结模型意味着生成一个包含图和检查点变量信息的单一文件，但是将这些超参数作为常量保存在图结构中。这消除了保存在检查点文件中的额外信息，例如每个点的梯度，这些信息包括在内，以便可以重新加载模型并从您停止的地方继续训练。因为这在为纯粹用于推理的模型服务时是不需要的，所以它们在冻结时被丢弃。冻结模型是一个谷歌<code class="fe nb nc nd ne b">.pb</code>文件类型的文件。</p><h2 id="a19c" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated"><strong class="ak">要求</strong></h2><p id="5ed6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">冻结推理模型的要求很简单，但是，根据您的应用程序，您可能需要安装各种其他包来实际执行推理:</p><ul class=""><li id="df90" class="nf ng iq lq b lr mk lu ml lx nh mb ni mf nj mj nk nl nm nn bi translated">将 Keras 与 TensorFlow 后端一起使用</li><li id="b17d" class="nf ng iq lq b lr no lu np lx nq mb nr mf ns mj nk nl nm nn bi translated">尽管安装了 TensorFlow 应该可以自动运行，但您需要确保<a class="ae kv" href="https://www.tensorflow.org/guide/summaries_and_tensorboard" rel="noopener ugc nofollow" target="_blank"> TensorBoard </a>在您的计算机上运行</li><li id="a15f" class="nf ng iq lq b lr no lu np lx nq mb nr mf ns mj nk nl nm nn bi translated">从 TensorFlow 存储库中，将<a class="ae kv" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/tools/freeze_graph.py" rel="noopener ugc nofollow" target="_blank"> freeze_graph.py </a> python 脚本复制到您的工作目录中。或者，您可以使用定制设计的<code class="fe nb nc nd ne b">freeze_graph</code>函数，我们将在后面看到。</li></ul><h1 id="4b86" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">转换模型</h1><p id="e154" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了生成包含必要信息的<code class="fe nb nc nd ne b">.pb</code>文件，TensorFlow 编写了<code class="fe nb nc nd ne b">freeze_graph.py</code>文件，该文件在被调用时将合并 TensorFlow 图形和检查点文件。使用这个 Python 脚本通常是明智的，因为它是由 TensorFlow 团队编写的，他们确保它可以与他们内部的文件格式一起工作。但是，为了使用它，您必须首先拥有正确格式的图形和检查点文件。Keras API 不会自动生成这个文件，所以您需要重新训练模型来生成它们。</p><p id="3f39" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">有两种相对简单的方法来获取以正确格式保存的训练模型以进行冻结。如果您直接使用 Keras API，那么您将需要切换到在 TensorFlow 环境中实现的 Keras API。</p><p id="9f57" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">注意:</strong>这应该只需要在导入阶段进行更改，例如，您将拥有<code class="fe nb nc nd ne b">from tensorflow.keras.layers import Convolution2D</code>而不是<code class="fe nb nc nd ne b">from keras.layers import Convolution2D</code>。</p><p id="1677" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">第一种方法调用模型，然后将其转换为 TensorFlow <a class="ae kv" href="https://www.tensorflow.org/guide/estimators" rel="noopener ugc nofollow" target="_blank">估计器</a>，后者将处理训练。第二个要求理解 TensorFlow <a class="ae kv" href="https://www.tensorflow.org/guide/graphs" rel="noopener ugc nofollow" target="_blank">会话</a>是如何工作的，因为这种方法训练网络就像你用本地 TensorFlow 编写的一样。实施这些训练方法后，您将能够运行<code class="fe nb nc nd ne b">freeze_graph</code>以获得正确的输出。</p><p id="32e5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们通过一个例子来演示这个过程。在这里，我们将把一个简单的 Keras 模型转换成一个估计量，用于对<a class="ae kv" href="http://yann.lecun.com/exdb/mnist/" rel="noopener ugc nofollow" target="_blank"> MNIST </a>数据集进行数字分类。</p><p id="7f5f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，我们在 TensorFlow 中实现的 Keras API 中构建模型，确保命名您的输入和输出层，因为我们稍后将需要这些名称:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Defining the model, note we do not define an input layer here since the type of input layer depends on which method you choose for training</figcaption></figure><h2 id="af9e" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">选项 1:转换为估计值</h2><p id="2f15" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">一般来说，这种方法可能是两种方法中最简单的，但是，由于处理<a class="ae kv" href="https://www.tensorflow.org/guide/custom_estimators" rel="noopener ugc nofollow" target="_blank">定制估计器</a>的性质，它可以很快变得更复杂，这取决于您想要如何训练模型。如果您只熟悉原生 Keras API 中的训练模型，那么这是最相似的训练模型的方式。TensorFlow 1.4 引入了将 Keras 模型转换为 TensorFlow 估算器的功能，本<a class="ae kv" href="https://cloud.google.com/blog/products/gcp/new-in-tensorflow-14-converting-a-keras-model-to-a-tensorflow-estimator" rel="noopener ugc nofollow" target="_blank">教程</a>对此进行了描述。</p><p id="9acc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要将上述模型转换成估算器，首先使用 TensorFlow 中实现的普通 Keras API 编译模型，然后使用<code class="fe nb nc nd ne b">model_to_estimator()</code>函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Converting the model into an Estimator, here the checkpoint files and graph will be saved in the model directory</figcaption></figure><p id="4bc1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在<code class="fe nb nc nd ne b">estimator_model</code>表现得像一个张量流估计器，我们可以相应地训练模型。有关如何培训评估员的指南，请参见<a class="ae kv" href="https://www.tensorflow.org/api_docs/python/tf/estimator/Estimator" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="05f7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于训练，定义一个输入函数并相应地训练模型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="c9e6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">模型现在已经训练好了，并且<code class="fe nb nc nd ne b">graph.pbtxt</code>和检查点<code class="fe nb nc nd ne b">.ckpt</code>文件将保存在<code class="fe nb nc nd ne b">./Keras_MNIST</code>模型目录中。</p><h2 id="ade3" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">选项 2:像原生张量流模型一样训练</h2><p id="ca26" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">另一种方法是通过启动张量流会话并在会话中训练来训练模型。这需要对会话如何工作有更详细的了解，这超出了本文的范围，我建议读者参考这个<a class="ae kv" href="https://www.tensorflow.org/tutorials/" rel="noopener ugc nofollow" target="_blank"> MNIST 教程</a>作为这种培训的例子。然而，与示例不同的是，您不需要在 native TensorFlow 中<em class="nv">编写</em>模型，相反，我们可以调用上面的模型，只需更改输入层:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="7373" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">剩下的就可以从教程中遵循了。</p><h1 id="2ea2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">冻结模型</h1><p id="36f1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在模型已经训练好了，图形和检查点文件也制作好了，我们可以使用 TensorFlow 的<code class="fe nb nc nd ne b">freeze_graph.py</code>将它们合并在一起。</p><p id="7098" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">注意:</strong>确保<code class="fe nb nc nd ne b">freeze_graph.py</code>与您想要冻结的检查点和图形文件在同一个目录中。</p><p id="c735" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">或者，我发现由<a class="nw nx ep" href="https://medium.com/u/17b66605e1fa?source=post_page-----c2e26cb84a38--------------------------------" rel="noopener" target="_blank">摩根</a>开发的<a class="ae kv" href="https://blog.metaflow.fr/tensorflow-how-to-freeze-a-model-and-serve-it-with-a-python-api-d4f3596b3adc" rel="noopener ugc nofollow" target="_blank">简化版</a>更不容易标记错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Simplified freeze_graph implementation by <a class="nw nx ep" href="https://medium.com/u/17b66605e1fa?source=post_page-----c2e26cb84a38--------------------------------" rel="noopener" target="_blank">Morgan</a></figcaption></figure><p id="0728" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此函数使用图形重新启动临时会话，以恢复最近的检查点。使用这种实现的另一个优点是，您不必确保指定了正确的检查点文件，或者处理语法上更加密集的<code class="fe nb nc nd ne b">freeze_graph.py</code>输入。</p><p id="9dc5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们需要知道输出节点的名称，作为函数的引用点。这和我们用不用<code class="fe nb nc nd ne b">freeze_graph</code>的简化版是一样的。你给最后一层起的名字是不够的，打开 TensorBoard 会给出一个可视化的图形。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/d72e880680016cb89d5f5e739dcb0620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OlGLgCaAnQ7TmfqP_4Jm3A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">TensorBoard output showing input to ‘metrics’ node</figcaption></figure><p id="252a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这个例子中，我们想要的是进入“度量”节点的张量，叫做<code class="fe nb nc nd ne b">output_node/Softmax</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="d325" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这将在模型目录中生成一个冻结的图形。</p><h1 id="44c4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">关键要点</h1><ol class=""><li id="d5c1" class="nf ng iq lq b lr ls lu lv lx nz mb oa mf ob mj oc nl nm nn bi translated">Keras 模型可以在 TensorFlow 环境中训练，或者更方便的是，变成一个语法变化很小的估计器。</li><li id="b643" class="nf ng iq lq b lr no lu np lx nq mb nr mf ns mj oc nl nm nn bi translated">要冻结一个模型，你首先需要生成检查点和图形文件，以便调用<code class="fe nb nc nd ne b">freeze_graph.py</code>或上面的简化版本。</li><li id="5c32" class="nf ng iq lq b lr no lu np lx nq mb nr mf ns mj oc nl nm nn bi translated">TensorFlow 上有许多标记为 Keras GitHubs 的问题，以及关于冻结模型的堆栈溢出，其中许多问题可以通过了解需要生成的文件以及如何指定输出节点来解决。</li><li id="9138" class="nf ng iq lq b lr no lu np lx nq mb nr mf ns mj oc nl nm nn bi translated">输出节点可以很容易地从 TensorBoard 可视化中找到，但它并不总是你指定的最后一层的名称。</li></ol></div></div>    
</body>
</html>