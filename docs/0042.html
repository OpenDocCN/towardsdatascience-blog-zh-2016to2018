<html>
<head>
<title>Deploy Nodejs microservices to a Docker Swarm Cluster [Docker from zero to hero]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Nodejs微服务部署到Docker Swarm集群[Docker从零到英雄]</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploy-a-nodejs-microservices-to-a-docker-swarm-cluster-docker-from-zero-to-hero-464fa1369ea0?source=collection_archive---------0-----------------------#2017-02-20">https://towardsdatascience.com/deploy-a-nodejs-microservices-to-a-docker-swarm-cluster-docker-from-zero-to-hero-464fa1369ea0?source=collection_archive---------0-----------------------#2017-02-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1c0d1e98451be55d161e43f6223ca3d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1LuJFXq50D9g524JEn-xfg.png"/></div></div></figure><blockquote class="jy jz ka"><p id="550e" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是🖐🏽“构建NodeJS影院微服务”系列的第五篇文章。这一系列文章演示了如何使用ES6，ES7 …8，用expressjs<strong class="ke ir"><em class="iq">设计、构建和部署微服务</em> </strong> <em class="iq">？，连接到MongoDB副本集，并将其部署到docker容器中，以模拟云环境的强大功能。</em></p></blockquote><h2 id="4111" class="la lb iq bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">##快速回顾一下我们之前的章节</h2><p id="2e27" class="pw-post-body-paragraph kb kc iq ke b kf lw kh ki kj lx kl km lj ly kp kq ln lz kt ku lr ma kx ky kz ij bi translated">第一篇文章介绍了<strong class="ke ir">微服务架构模式</strong>，并讨论了使用微服务的<strong class="ke ir">好处</strong>和<strong class="ke ir">缺点</strong>。在第二篇文章中，我们讨论了使用<strong class="ke ir"> HTTP/2协议</strong>的<strong class="ke ir">微服务安全性</strong>，并了解了如何实现它<strong class="ke ir">。</strong>本系列的第三篇文章我们描述了<strong class="ke ir">微服务</strong>架构内<strong class="ke ir">通信<strong class="ke ir">的</strong>不同方面，我们解释了关于<strong class="ke ir">设计模式</strong>的<strong class="ke ir"> NodeJS </strong>像<strong class="ke ir">依赖注入、反转控制</strong>和<strong class="ke ir">坚实的原理。</strong>在第四篇文章中，我们谈到了什么是<strong class="ke ir"> API网关，</strong>我们看到了什么是<strong class="ke ir">网络代理</strong>和<strong class="ke ir"> ES6代理对象。我们已经开发了5个服务，我们已经将它们归档，我们也做了很多类型的测试，因为我们是好奇的好开发者。</strong></strong></p><p id="4d4a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">如果你没有读过前面的章节，你会错过一些很棒的东西👍🏽，所以我会把链接放在下面，这样你就可以看看了👀。</p><div class="mb mc gp gr md me"><a href="https://medium.com/@cramirez92/build-a-nodejs-cinema-microservice-and-deploying-it-with-docker-part-1-7e28e25bfa8b" rel="noopener follow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">构建NodeJS影院微服务并使用docker部署它—第1部分</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">这是“构建节点影院微服务”系列的第一章，该系列是关于构建节点影院微服务的</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">medium.com</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms jw me"/></div></div></a></div><div class="mb mc gp gr md me"><a href="https://medium.com/@cramirez92/build-a-nodejs-cinema-microservice-and-deploying-it-with-docker-part-2-e05cc7b126e0" rel="noopener follow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">构建NodeJS影院微服务并使用docker部署它(第2部分)</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">这是✌️“构建NodeJS影院微服务”系列的第二篇文章。</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">medium.com</p></div></div><div class="mn l"><div class="mt l mp mq mr mn ms jw me"/></div></div></a></div><div class="mb mc gp gr md me"><a href="https://medium.com/@cramirez92/build-a-nodejs-cinema-booking-microservice-and-deploying-it-with-docker-part-3-9c384e21fbe0" rel="noopener follow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">构建NodeJS影院预订微服务并使用docker部署它(第3部分)</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">你好社区这是🏰“构建NodeJS影院微服务”系列的第三篇文章。这一系列的…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">medium.com</p></div></div><div class="mn l"><div class="mu l mp mq mr mn ms jw me"/></div></div></a></div><div class="mb mc gp gr md me"><a href="https://medium.com/@cramirez92/build-a-nodejs-cinema-api-gateway-and-deploying-it-to-docker-part-4-703c2b0dd269" rel="noopener follow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">构建NodeJS cinema API网关并将其部署到Docker(第4部分)</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">这是🏛“构建NodeJS影院微服务”系列的第四篇文章。这一系列文章…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">medium.com</p></div></div><div class="mn l"><div class="mv l mp mq mr mn ms jw me"/></div></div></a></div></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="99b3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">我们一直在开发，编码，编程，👩🏻‍💻👨🏻‍💻在最后几集中，我们对如何创建nodejs微服务非常兴奋，我们还没有时间谈论我们系统的架构，我们还没有谈论从第1章开始就一直在使用的东西，那就是<strong class="ke ir"> <em class="kd"> Docker </em>。</strong></p><p id="fdc0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">现在是人们见识力量的时候了💪🏽集装箱化的🗄.如果你想得到你的手🙌🏽肮脏和学习所有关于<a class="ae nd" href="https://docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>的大惊小怪，然后抓住你的座位，系上你的安全带，因为我们的旅程将变得有趣。</p><h2 id="b0cc" class="la lb iq bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">##当前影院微服务架构</h2><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/c7f0ac742cceaa715002d7023032a797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cMvCCosVFZ02K_rf3dbNOg.png"/></div></div></figure><p id="4c13" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">直到我们知道我们已经创建了3个<code class="fe nj nk nl nm b"><strong class="ke ir">docker-machines</strong></code> <strong class="ke ir">，</strong>我们创建了一个<code class="fe nj nk nl nm b"><strong class="ke ir">mongo database replica set cluster</strong></code>，在那里我们在每个docker-machine中放置了一个副本，然后我们创建了我们的微服务，但是我们一直只在<code class="fe nj nk nl nm b"><strong class="ke ir">manager1</strong></code> <strong class="ke ir"> </strong> docker-machine中手动创建和部署它，所以我们一直在浪费其他两个docker-machine中的计算资源，但是我们不再这样做了，因为我们将开始配置<strong class="ke ir"> <em class="kd"> Docker </em> </strong>，<strong class="ke ir"> <em class="kd"/></strong></p><p id="6a8f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">我们将在本文中使用:</p><ul class=""><li id="77c4" class="nn no iq ke b kf kg kj kk lj np ln nq lr nr kz ns nt nu nv bi translated">NodeJS版本7.5.0(针对我们的微服务)</li><li id="f4a4" class="nn no iq ke b kf nw kj nx lj ny ln nz lr oa kz ns nt nu nv bi translated">MongoDB 3.4.2(针对我们的数据库)</li><li id="c3d0" class="nn no iq ke b kf nw kj nx lj ny ln nz lr oa kz ns nt nu nv bi translated">Mac版docker 1 . 13 . 0或同等版本(已安装，版本1.13.1与dockerode不兼容)</li></ul><p id="a541" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">跟进文章的先决条件:</p><ul class=""><li id="54bd" class="nn no iq ke b kf kg kj kk lj np ln nq lr nr kz ns nt nu nv bi translated">bash脚本的基础知识。</li><li id="c3ca" class="nn no iq ke b kf nw kj nx lj ny ln nz lr oa kz ns nt nu nv bi translated">我已经完成了上一章的例子。</li></ul><p id="5d0f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">如果你还没有，我已经上传了一个github库，所以你可以在分支机构<strong class="ke ir">步骤5的<a class="ae nd" href="https://github.com/Crizstian/cinema-microservice/tree/step-4" rel="noopener ugc nofollow" target="_blank">回购链接</a>处获得最新信息。</strong></p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="c270" class="ob lb iq bd lc oc od oe lf of og oh li oi oj ok lm ol om on lq oo op oq lu or bi translated"># Docker是什么？</h1><blockquote class="jy jz ka"><p id="26c9" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Docker是一个开源项目，可以将任何应用程序作为一个轻量级容器来打包、运输和运行。</p><p id="ed45" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Docker容器既与硬件无关，也与平台无关。这意味着它们可以在任何地方运行，从您的笔记本电脑到最大的云计算实例以及二者之间的任何东西，并且它们不需要您使用特定的语言、框架或打包系统。这使得它们成为部署和扩展web应用程序、数据库和后端服务的绝佳构建块，而无需依赖特定的堆栈或提供商。— @Docker</p></blockquote><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi os"><img src="../Images/dc54052f67826140153f5ccefbee9429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fW6NvQ4k04x29piOwlbulw.png"/></div></div><figcaption class="ot ou gj gh gi ov ow bd b be z dk">Docker structure</figcaption></figure><h2 id="fa81" class="la lb iq bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">换句话说docker到底是什么？</h2><p id="ef5f" class="pw-post-body-paragraph kb kc iq ke b kf lw kh ki kj lx kl km lj ly kp kq ln lz kt ku lr ma kx ky kz ij bi translated">换句话说，docker让我们构建模板(<em class="kd">如果我们可以称之为模板，这个模板是docker映像</em>)来创建容纳虚拟机的容器(<em class="kd">如果我们可以称之为虚拟机，因为它们不是</em>)，我们可以在其中包含我们的应用程序，安装它的所有依赖项，并作为一个独立的进程运行它，与主机操作系统或任何IaaS平台中的其他容器共享内核。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi os"><img src="../Images/cf9f29c024671521bdcd88d26d6d4b21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4EaPmvyhWQ_To8HQXmnCBA.png"/></div></div><figcaption class="ot ou gj gh gi ov ow bd b be z dk">Virtual machine structure</figcaption></figure><h2 id="b158" class="la lb iq bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">和虚拟机有什么区别？</h2><blockquote class="jy jz ka"><p id="04a6" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">虚拟机包括应用程序、必要的二进制文件、库和整个客户操作系统，其容量可达数十GB — @Docker</p></blockquote><h1 id="93bf" class="ob lb iq bd lc oc ox oe lf of oy oh li oi oz ok lm ol pa on lq oo pb oq lu or bi translated">#什么是Docker-Machine？</h1><blockquote class="jy jz ka"><p id="2db5" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Docker Machine让我们可以在自己的计算机、云提供商和数据中心内部创建Docker主机。它创建服务器，在服务器上安装Docker，然后配置Docker客户机与服务器对话。— @Docker</p></blockquote><p id="09e0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">Docker Machine是一个让我们在虚拟主机上安装Docker引擎，并使用<code class="fe nj nk nl nm b">docker-machine</code>命令管理主机的工具。您可以使用Machine在本地Mac或Windows box、公司网络、数据中心或AWS或Digital Ocean等云提供商上创建Docker主机。Docker引擎在Linux系统上本地运行。如果你有一个Linux系统作为你的主系统，并且想要运行<code class="fe nj nk nl nm b">docker</code>命令，你需要做的就是下载并安装Docker引擎。</p><h2 id="2593" class="la lb iq bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">但是为什么我们甚至在Linux上也需要Docker-Machine呢？</h2><p id="033f" class="pw-post-body-paragraph kb kc iq ke b kf lw kh ki kj lx kl km lj ly kp kq ln lz kt ku lr ma kx ky kz ij bi translated"><strong class="ke ir"> <em class="kd">如果我们想要高效地管理我们的Docker主机</em> </strong> <strong class="ke ir"> <em class="kd">在网络上、在云中甚至在本地，我们需要它，因为如果我们在本地进行测试，Docker-Machine可以帮助我们模拟云环境。</em></strong></p><h1 id="af01" class="ob lb iq bd lc oc ox oe lf of oy oh li oi oz ok lm ol pa on lq oo pb oq lu or bi translated">#什么是Docker Swarm？</h1><p id="0fd1" class="pw-post-body-paragraph kb kc iq ke b kf lw kh ki kj lx kl km lj ly kp kq ln lz kt ku lr ma kx ky kz ij bi translated">Docker Swarm是Docker的本地集群。它使用API代理系统将一个Docker主机池变成一个单独的虚拟主机。</p><h2 id="c00c" class="la lb iq bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">让我们先理解集群是什么意思。</h2><blockquote class="jy jz ka"><p id="2f58" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq">集群是一组紧密耦合的计算机，像单台机器一样运行。称为节点的单个机器通过非常快速的网络相互通信，并且它们在物理上非常接近，可能在同一个机柜中。通常他们有相同或几乎相同的硬件和软件。所有节点都可以处理相同类型的请求。有时，一个节点接受请求并将其分派给其他节点。— </em> <a class="ae nd" href="https://blog.containership.io/author/phil-dougherty" rel="noopener ugc nofollow" target="_blank"> <em class="iq">菲尔·多尔蒂</em> </a></p></blockquote><p id="45d0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">好了，现在让我们看看创建Docker Swarm集群可以实现什么:</p><ul class=""><li id="8987" class="nn no iq ke b kf kg kj kk lj np ln nq lr nr kz ns nt nu nv bi translated">多主机网络</li><li id="984a" class="nn no iq ke b kf nw kj nx lj ny ln nz lr oa kz ns nt nu nv bi translated">结垢</li><li id="44ba" class="nn no iq ke b kf nw kj nx lj ny ln nz lr oa kz ns nt nu nv bi translated">负载平衡</li><li id="08af" class="nn no iq ke b kf nw kj nx lj ny ln nz lr oa kz ns nt nu nv bi translated">默认安全性</li><li id="b520" class="nn no iq ke b kf nw kj nx lj ny ln nz lr oa kz ns nt nu nv bi translated">集群管理</li></ul><p id="415c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">等等，现在我们已经获得了一些关于Docker生态系统的词汇和知识，是时候看看我们如何创建我们的架构并将我们的<strong class="ke ir"> <em class="kd"> cinema微服务部署到Docker Swarm集群</em> </strong>，该集群可以处理数百、数千或数百万的用户请求，如预订🎟，逛🕹，看🎥、或用户的任何动作👥在我们的电影系统中。</p><blockquote class="jy jz ka"><p id="6ff4" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当不使用swarm模式运行Docker时，执行容器命令。当您在集群模式下运行Docker时，您编排了服务。您可以在同一个Docker实例上运行swarm服务和独立容器。— @Docker</p></blockquote><h1 id="78f9" class="ob lb iq bd lc oc ox oe lf of oy oh li oi oz ok lm ol pa on lq oo pb oq lu or bi translated">#构建架构</h1><h2 id="feb1" class="la lb iq bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤1:创建并初始化docker swarm集群</h2><p id="ac43" class="pw-post-body-paragraph kb kc iq ke b kf lw kh ki kj lx kl km lj ly kp kq ln lz kt ku lr ma kx ky kz ij bi translated">我们将从零开始构建我们的影院微服务架构，所以让我们先来谈谈如何创建我们的<code class="fe nj nk nl nm b"><strong class="ke ir">docker machines</strong></code> <strong class="ke ir"> </strong>以及如何初始化一个<code class="fe nj nk nl nm b"><strong class="ke ir">docker swarm cluster.</strong></code></p><p id="a4a5" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">首先，在开始创建和修改文件之前，我们需要在cinemas项目的根目录下创建一个名为<code class="fe nj nk nl nm b"><strong class="ke ir">_docker_setup</strong></code>的新文件夹，因此我们的项目需要如下所示:</p><pre class="nf ng nh ni gt pc nm pd pe aw pf bi"><span id="2574" class="la lb iq nm b gy pg ph l pi pj">. <br/>|<em class="kd">-- </em><strong class="nm ir"><em class="kd">_docker_setup</em></strong> <br/>|   `<em class="kd">-- ... here we are going to put our bash files</em> <br/>|<em class="kd">-- </em><strong class="nm ir"><em class="kd">api-gateway</em></strong><em class="kd"><br/></em>|   `<em class="kd">-- ... more files<br/></em>|<em class="kd">-- </em><strong class="nm ir"><em class="kd">booking-service</em></strong><em class="kd"><br/></em>|   `<em class="kd">-- ... more files<br/></em>|<em class="kd">-- </em><strong class="nm ir"><em class="kd">cinema-catalog-service</em></strong><em class="kd"><br/></em>|   `<em class="kd">-- ... more files<br/></em>|<em class="kd">-- </em><strong class="nm ir"><em class="kd">movies-service</em></strong><em class="kd"><br/></em>|   `<em class="kd">-- ... more files<br/></em>|<em class="kd">-- </em><strong class="nm ir"><em class="kd">notification-service</em></strong><em class="kd"><br/></em>|   `<em class="kd">-- ... more files<br/></em>|<em class="kd">-- </em><strong class="nm ir"><em class="kd">payment-service</em></strong><em class="kd"><br/></em>|   `<em class="kd">-- ... more files</em></span></pre><p id="9ab6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">因此，让我们在我们的<code class="fe nj nk nl nm b"><strong class="ke ir">_docker_setup folder</strong></code>中创建一个bash文件，名为<code class="fe nj nk nl nm b"><strong class="ke ir">setup-swarm.sh</strong></code>，这将创建并设置我们的<code class="fe nj nk nl nm b"><strong class="ke ir">docker swarm cluster.</strong></code>为什么是bash文件，因为一个好的开发人员可以自动完成很多这样的事情:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="04c6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">好吧，这是一个有点长的脚本，但我想把它全部写下来，因为它让我们更好地了解正在发生的事情，以及我们如何才能完成docker swarm集群设置自动化。</p><p id="68a9" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">所以让我们分开剧本，谈谈那里发生了什么。</p><pre class="nf ng nh ni gt pc nm pd pe aw pf bi"><span id="9167" class="la lb iq nm b gy pg ph l pi pj"><strong class="nm ir"># So first the basics, how do we create a docker-machine.</strong></span><span id="40bc" class="la lb iq nm b gy pm ph l pi pj">$ docker-machine create -d $DRIVER $ADDITIONAL_PARAMS $MACHINE_NAME</span></pre><p id="f265" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">这就是我们创建机器的基本方法，不管它们是管理节点还是工作节点，对两者来说都是相同的命令。驱动程序可能是<em class="kd"> virtualbox、parallels、digital-ocean、AWS等。</em></p><p id="1c64" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">一旦我们创建了我们的机器，它的时间<strong class="ke ir"> <em class="kd">初始化蜂群</em>，</strong>如下:</p><pre class="nf ng nh ni gt pc nm pd pe aw pf bi"><span id="edaf" class="la lb iq nm b gy pg ph l pi pj">$ docker-machine ssh manager1 docker swarm init --advertise-addr $(getIP manager1)</span></pre><p id="6d92" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">它的一个<strong class="ke ir"> <em class="kd">简单的docker命令</em> </strong>，就这么简单，<strong class="ke ir"><em class="kd">docker swarm init</em></strong>，初始化swarm manager配置。我们可以用两种方式来做这件事，像下面的<code class="fe nj nk nl nm b">eval `docker-machine env manager1`</code>一样<strong class="ke ir"> <em class="kd">设置我们的环境</em> </strong>并执行<code class="fe nj nk nl nm b">docker swarm init</code>命令或者<strong class="ke ir"> <em class="kd">我们可以ssh到机器</em> </strong>像下面的<code class="fe nj nk nl nm b">docker-machine ssh manager1 {and here we pass the docker commands}</code>一样，初始化swarm我们需要<code class="fe nj nk nl nm b">docker-machine ip</code>ip可能会因驱动程序提供者而异，所以为了获取ip，我做了一个bash函数，它将检索给定docker-machine的IP。</p><p id="286a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">一旦群管理器<strong class="ke ir"> <em class="kd"> </em> </strong>被启动，我们就准备添加工人节点，为此我们调用函数<code class="fe nj nk nl nm b">join_node_manager</code>，它执行以下操作:</p><pre class="nf ng nh ni gt pc nm pd pe aw pf bi"><span id="292c" class="la lb iq nm b gy pg ph l pi pj">$ docker-machine ssh {name of worker} docker swarm join --token $(get_worker_token) $(getIP manager1):2377</span></pre><p id="6d6f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">我们将在脚本中使用给定数量的workers变量再次循环该命令，该命令首先调用函数<code class="fe nj nk nl nm b">get_worker_token</code>，这将从管理器节点获取令牌，这是将worker节点注册到群集群所需的令牌，接下来它将再次调用检索给定docker-machine的ip的函数，并将<strong class="ke ir"> <em class="kd">完成docker群集群配置</em> </strong>，我们准备好部署我们的<strong class="ke ir"> <em class="kd"> cinema微服务。</em> </strong></p><blockquote class="jy jz ka"><p id="d715" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了利用swarm模式的容错特性，Docker建议您根据组织的高可用性要求实现奇数个节点。— @Docker</p></blockquote><h2 id="1a23" class="la lb iq bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤2:创建docker图像</h2><blockquote class="jy jz ka"><p id="c21c" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">容器是将Node.js应用程序部署到生产环境的最佳方式。容器提供了各种各样的好处，从在生产和开发中拥有相同的环境到为了速度和大小而简化部署。— <a class="ae nd" href="https://nodesource.com/blog/author/bitandbang" rel="noopener ugc nofollow" target="_blank"> <em class="iq">蒂尔尼·赛丽</em> </a></p></blockquote><p id="a5e3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">目前我们有5个微服务和1个api-gateway服务，我们可以在dev box上运行，只要它安装了Node.js的兼容版本。我们想要做的是创建一个<strong class="ke ir"> <em class="kd"> Docker服务(</em> </strong>我们将在后面的章节<strong class="ke ir"> <em class="kd"> ) </em> </strong>中看到这是什么，但是为此我们需要为我们拥有的每个微服务创建一个<strong class="ke ir"> <em class="kd"> Docker映像</em> </strong>。</p><p id="1d13" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">一旦创建了<strong class="ke ir"> <em class="kd"> Docker映像</em> </strong>，我们就能够在任何支持Docker的地方部署我们的服务。</p><p id="5df6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">我们创建一个<strong class="ke ir"> <em class="kd"> Docker图像</em> </strong>的方法是先创建一个<strong class="ke ir"><em class="kd">Docker file(</em></strong><em class="kd">模板</em> <strong class="ke ir"> <em class="kd"> ) </em> </strong>)。Docker文件是一个告诉Docker引擎如何构建我们的图像的配方。</p><p id="f9b8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">由于我们只开发了<strong class="ke ir"> <em class="kd"> nodejs </em> </strong>应用程序，我们可以在项目中的所有微服务中使用相同的Dockerfile规范，<strong class="ke ir"> <em class="kd">但是我们是否尽了一切努力使这个过程尽可能可靠和有活力呢？</em> </strong></p><p id="7ebc" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">这是我们要查看的下一个文件，我们也将对其应用良好的实践。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="2624" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">现在我们可以用这个规范修改我们之前创建的所有微服务<strong class="ke ir"><em class="kd">docker files</em></strong><em class="kd">，</em>。</p><p id="50a4" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">让我们谈一点这是怎么回事，如果这个过程是可靠的。</p><p id="8a21" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">默认情况下，Docker容器中的应用程序进程作为根用户<strong class="ke ir"><em class="kd"/></strong>运行。这在生产运行时会造成<strong class="ke ir"> <em class="kd">潜在的严重安全风险</em> </strong>。这个问题的一个简单的<strong class="ke ir"> <em class="kd">解决方案</em> </strong>是在Docker映像的 中<strong class="ke ir"> <em class="kd">创建一个新用户，并使用该用户来执行我们的应用程序。<strong class="ke ir"><em class="kd">Docker容器内的第一个进程</em> </strong>将是<strong class="ke ir"> <em class="kd"> PID 1 </em> </strong>。Linux内核给予PID 1特殊的待遇，许多应用程序并不是为处理PID 1带来的额外责任而设计的。当以PID 1的身份运行Node.js时，进程无法处理那些责任会有几种表现，其中最痛苦的是进程忽略了<code class="fe nj nk nl nm b">SIGTERM</code>命令。dumb-init被设计成一个超级简单的进程，无论它被告知启动哪个进程，它都负责作为PID 1运行。</em></strong></p><h2 id="e16c" class="la lb iq bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤3:构建并运行我们的docker映像</h2><p id="c500" class="pw-post-body-paragraph kb kc iq ke b kf lw kh ki kj lx kl km lj ly kp kq ln lz kt ku lr ma kx ky kz ij bi translated">要构建我们的<strong class="ke ir"> <em class="kd"> Docker图像</em> </strong>，我们需要运行以下命令:</p><pre class="nf ng nh ni gt pc nm pd pe aw pf bi"><span id="4dcb" class="la lb iq nm b gy pg ph l pi pj"><strong class="nm ir"># This command will create a new docker image</strong></span><span id="9f75" class="la lb iq nm b gy pm ph l pi pj">$ docker build -t movies-service .</span></pre><p id="bb57" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">让我们看看build命令。</p><ol class=""><li id="442f" class="nn no iq ke b kf kg kj kk lj np ln nq lr nr kz pn nt nu nv bi translated"><code class="fe nj nk nl nm b">docker build</code>告诉引擎我们想要创建一个新的图像。</li><li id="52a4" class="nn no iq ke b kf nw kj nx lj ny ln nz lr oa kz pn nt nu nv bi translated"><code class="fe nj nk nl nm b">-t flag</code>用标签<code class="fe nj nk nl nm b">movies-service</code>给这个图像加标签。从现在开始我们可以通过标签来引用这张图片。</li><li id="55d4" class="nn no iq ke b kf nw kj nx lj ny ln nz lr oa kz pn nt nu nv bi translated"><code class="fe nj nk nl nm b">.</code>使用当前目录找到<code class="fe nj nk nl nm b">Dockerfile</code>。</li></ol><p id="dd73" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">现在我们已经准备好使用新的docker映像运行容器，为此我们需要以下命令:</p><pre class="nf ng nh ni gt pc nm pd pe aw pf bi"><span id="08ef" class="la lb iq nm b gy pg ph l pi pj">$ docker run --name movies-service -l=apiRoute='/movies' -p 3000:3000 -d movies-service</span></pre><p id="eb09" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">让我们来看看run命令。</p><ol class=""><li id="4ca1" class="nn no iq ke b kf kg kj kk lj np ln nq lr nr kz pn nt nu nv bi translated"><code class="fe nj nk nl nm b">docker run</code>告诉引擎我们要启动一个新的容器。</li><li id="ef94" class="nn no iq ke b kf nw kj nx lj ny ln nz lr oa kz pn nt nu nv bi translated"><code class="fe nj nk nl nm b">--name</code> flag为容器设置一个名称。从现在开始我们可以用这个名字来称呼这个容器。</li><li id="33ba" class="nn no iq ke b kf nw kj nx lj ny ln nz lr oa kz pn nt nu nv bi translated"><code class="fe nj nk nl nm b">-l</code>标志为容器设置元数据。</li><li id="94ce" class="nn no iq ke b kf nw kj nx lj ny ln nz lr oa kz pn nt nu nv bi translated"><code class="fe nj nk nl nm b">-p</code> flag设置来自{host}:{container}的端口绑定</li><li id="d647" class="nn no iq ke b kf nw kj nx lj ny ln nz lr oa kz pn nt nu nv bi translated"><code class="fe nj nk nl nm b">-d</code>标志在分离模式下运行容器，这保持了容器在后台运行。</li></ol><p id="bcf2" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">所以现在让我们在我们的<code class="fe nj nk nl nm b"><strong class="ke ir">_docker_setup</strong></code> foleder中创建一个bash文件，名为<code class="fe nj nk nl nm b"><strong class="ke ir">create-images.sh</strong></code>，来自动创建我们所有的微服务docker映像。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="3b9e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">在执行这个脚本之前，我们需要修改每个微服务上的<code class="fe nj nk nl nm b"><strong class="ke ir">start-service.sh</strong></code> <strong class="ke ir"> </strong>，并将其重命名为<code class="fe nj nk nl nm b"><strong class="ke ir">create-image.sh</strong></code>，如下所示:</p><pre class="nf ng nh ni gt pc nm pd pe aw pf bi"><span id="4792" class="la lb iq nm b gy pg ph l pi pj">#!/usr/bin/env bash</span><span id="fcb3" class="la lb iq nm b gy pm ph l pi pj">docker rm -f {name of the service}</span><span id="1acb" class="la lb iq nm b gy pm ph l pi pj">docker rmi {name of the service}</span><span id="731f" class="la lb iq nm b gy pm ph l pi pj">docker image prune</span><span id="8120" class="la lb iq nm b gy pm ph l pi pj">docker volume prune</span><span id="8d6e" class="la lb iq nm b gy pm ph l pi pj"><strong class="nm ir"># the previous commands are for removing existing containers, <br/># and image, then we clean our environment and finally <br/># we creat or re-build our image</strong></span><span id="fc4b" class="la lb iq nm b gy pm ph l pi pj">docker build -t {name of the service} .</span></pre><h2 id="3d14" class="la lb iq bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤4:将我们的docker映像发布到docker hub存储库</h2><p id="c4b9" class="pw-post-body-paragraph kb kc iq ke b kf lw kh ki kj lx kl km lj ly kp kq ln lz kt ku lr ma kx ky kz ij bi translated">发布我们的docker图像🤔？，Docker维护着一个巨大的图像库，称为<a class="ae nd" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"><em class="kd">Docker Hub</em></strong></a>，您可以使用它作为起点或免费存储我们自己的图像。这是我们将<code class="fe nj nk nl nm b"><strong class="ke ir">node:7.5.0-alpine</strong></code>映像用于创建微服务映像的地方。<strong class="ke ir"> <em class="kd">但是为什么我们需要发布我们的图片呢？</em> </strong></p><p id="9410" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">因为在本章的后面，我们将创建<strong class="ke ir"> <em class="kd"> Docker服务</em> </strong>，这些服务将在我们的Docker Swarm集群上部署和复制，为了启动我们的服务，集群节点需要服务的映像来启动容器，如果映像不在本地，它将在docker hub中搜索它，然后将它拉至主机，以便在本地拥有映像并能够统计我们的服务。</p><p id="2039" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">但是首先我们需要在<a class="ae nd" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="kd"> Docker Hub网站</em> </strong> </a> <strong class="ke ir"> <em class="kd">，</em> </strong>创建一个帐户，然后我们需要在我们的shell中登录，执行以下命令:</p><pre class="nf ng nh ni gt pc nm pd pe aw pf bi"><span id="8091" class="la lb iq nm b gy pg ph l pi pj">$ docker login          <br/>  Username: *****     <br/>  Password: *****     <br/>  Login Succeeded</span></pre><p id="0227" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">接下来，我们需要标记我们的图像，以便能够通过名称引用它们，并将它们推送到docker hub。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div class="gh gi po"><img src="../Images/3177fe7de208bc4b47c8753faf899456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*atVEIVBBLZTg1fcG3fn3Bw.png"/></div><figcaption class="ot ou gj gh gi ov ow bd b be z dk">docker tagging images structure</figcaption></figure><p id="9c10" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">既然我们已经登录，我们现在知道了如何标记docker图像的结构，现在是修改我们的<code class="fe nj nk nl nm b"><strong class="ke ir">create-images.sh</strong></code>的时候了，所以它可以<strong class="ke ir">创建</strong>我们的图像，<strong class="ke ir">标记</strong>我们的图像，<strong class="ke ir">将</strong>我们的图像推送到<strong class="ke ir"> docker hub </strong>，所有这些都是自动完成的，我们的bash文件需要看起来如下。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="pk pl l"/></div></figure><h2 id="fce0" class="la lb iq bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤5:设置我们的mongodb副本集集群</h2><p id="e26c" class="pw-post-body-paragraph kb kc iq ke b kf lw kh ki kj lx kl km lj ly kp kq ln lz kt ku lr ma kx ky kz ij bi translated">这是docker步骤的一个小主题，但我们需要一个数据库来保存我们的微服务使用的数据，在这一步中，我不会花时间来描述如何做到这一点，我已经写了一篇关于如何将mongodb副本集集群部署到docker的文章，我强烈建议您，如果您还没有，可以看看我的文章。</p><div class="mb mc gp gr md me"><a href="https://medium.com/@cramirez92/how-to-deploy-a-mongodb-replica-set-using-docker-6d0b9ac00e49" rel="noopener follow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">如何使用Docker部署MongoDB副本集</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">本文将介绍如何使用docker设置带身份验证的MongoDB副本集。</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">medium.com</p></div></div><div class="mn l"><div class="pp l mp mq mr mn ms jw me"/></div></div></a></div><p id="0798" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">或者跳过这一步，等到阅读完第7步。<br/>(又搞点暴徒生活😎)</p><h2 id="874e" class="la lb iq bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤6:在我们的docker集群中创建docker服务</h2><p id="f8ac" class="pw-post-body-paragraph kb kc iq ke b kf lw kh ki kj lx kl km lj ly kp kq ln lz kt ku lr ma kx ky kz ij bi translated">做第5步是非常重要的，因为如果我们没有我们的数据库和运行我们的docker服务将无法正确启动。</p><p id="bb51" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">现在让我们在我们的<code class="fe nj nk nl nm b"><strong class="ke ir">_docker_setup</strong></code> <strong class="ke ir"> </strong>文件夹中创建另一个名为<code class="fe nj nk nl nm b"><strong class="ke ir">start-services.sh</strong></code> <strong class="ke ir"> </strong>的文件。这个bash脚本将启动我们所有类型为<strong class="ke ir"> <em class="kd"> Docker服务</em> </strong>的微服务，这样这些服务就可以根据需要扩大或缩小规模。</p><p id="f6f5" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">既然我们的服务规模将会扩大和缩小，我们在调用这些服务时会遇到麻烦，但亲爱的读者们，没有什么可害怕的，因为，我之前说过，创建<strong class="ke ir"><em class="kd"/></strong>Docker swarm集群的好处之一是，它在幕后为我们设置了一个<strong class="ke ir"><em class="kd"/></strong>负载平衡器，Docker负责在请求时处理要调用的服务。让我们回顾下一个文件。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="c4b3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">正如你所看到的，这个文件与我们的<code class="fe nj nk nl nm b"><strong class="ke ir">create-images.sh</strong></code> <strong class="ke ir"> </strong>非常相似，但是这次我们从每个服务中调用<code class="fe nj nk nl nm b"><strong class="ke ir">start-service.sh</strong></code> <strong class="ke ir"> </strong>，现在让我们看看<code class="fe nj nk nl nm b"><strong class="ke ir">start-service.sh</strong></code>文件是如何组成的。</p><pre class="nf ng nh ni gt pc nm pd pe aw pf bi"><span id="5a11" class="la lb iq nm b gy pg ph l pi pj">#!/usr/bin/env bash</span><span id="b033" class="la lb iq nm b gy pm ph l pi pj">docker service create --replicas 3 --name {service name} -l=apiRoute='{our api route}' -p {port binding} --env-file env {microservice image}</span></pre><p id="57d3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">让我们看一下服务命令:</p><ul class=""><li id="53be" class="nn no iq ke b kf kg kj kk lj np ln nq lr nr kz ns nt nu nv bi translated"><code class="fe nj nk nl nm b">docker service create</code>命令创建服务。</li><li id="b176" class="nn no iq ke b kf nw kj nx lj ny ln nz lr oa kz ns nt nu nv bi translated"><code class="fe nj nk nl nm b">--name</code>标志为服务命名，例如<code class="fe nj nk nl nm b">movies-service</code>。</li><li id="d318" class="nn no iq ke b kf nw kj nx lj ny ln nz lr oa kz ns nt nu nv bi translated"><code class="fe nj nk nl nm b">--replicas</code>标志指定了3个运行实例的期望状态。</li><li id="55a0" class="nn no iq ke b kf nw kj nx lj ny ln nz lr oa kz ns nt nu nv bi translated">我们可以附加元数据的<code class="fe nj nk nl nm b">-l</code>标志物种，例如<code class="fe nj nk nl nm b">apiRoute="/movies"</code>。</li><li id="4f3e" class="nn no iq ke b kf nw kj nx lj ny ln nz lr oa kz ns nt nu nv bi translated"><code class="fe nj nk nl nm b">-p</code>标志指定主机和容器上的端口绑定。</li><li id="d74a" class="nn no iq ke b kf nw kj nx lj ny ln nz lr oa kz ns nt nu nv bi translated"><code class="fe nj nk nl nm b">-e</code>标志指定了服务环境变量的can设置。</li></ul><h2 id="7a65" class="la lb iq bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤7:在一个命令中执行所有自动化文件</h2><p id="5307" class="pw-post-body-paragraph kb kc iq ke b kf lw kh ki kj lx kl km lj ly kp kq ln lz kt ku lr ma kx ky kz ij bi translated">好啦好啦，是施展魔法的时候了🔮✨的人们。</p><p id="8209" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">为了执行我们已经创建的所有自动化文件，让我们创建最终的脚本来为我们做所有的事情，<em class="kd">因为开发人员很懒</em>🤓。</p><p id="1cfc" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">所以我们需要在<strong class="ke ir"> <em class="kd">影院微服务</em> </strong>项目的根目录下创建这个文件，我们将把它命名为<code class="fe nj nk nl nm b"><strong class="ke ir">kraken.sh</strong></code> <strong class="ke ir">🦑</strong>只是为了好玩，因为很强大😎。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="ca73" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">它内部没有复杂的编程，但是它所做的，是为我们调用所有的自动化脚本并完成我们的工作。</p><p id="e68f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">最后让我们像下面这样执行它。</p><pre class="nf ng nh ni gt pc nm pd pe aw pf bi"><span id="bc54" class="la lb iq nm b gy pg ph l pi pj">$ bash &lt; kraken.sh</span></pre><p id="c907" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">就这么简单，我们已经做了这么多模块化来简化创建<strong class="ke ir"> <em class="kd"> Docker群集群</em> </strong>的过程，并自动启动我们的<strong class="ke ir"> <em class="kd"> Docker服务。</em>T24】</strong></p><blockquote class="pq"><p id="bc94" class="pr ps iq bd pt pu pv pw px py pz kz dk translated">“简单可能比复杂更难:你必须努力让自己的思维变得清晰，才能变得简单。但最终还是值得的，因为一旦你到了那里，你就可以移山。”—史蒂夫·乔布斯</p></blockquote><p id="b3de" class="pw-post-body-paragraph kb kc iq ke b kf qa kh ki kj qb kl km lj qc kp kq ln qd kt ku lr qe kx ky kz ij bi translated">我上传了一个视频演示，看看当我们执行<code class="fe nj nk nl nm b"><strong class="ke ir">kraken.sh</strong></code> <strong class="ke ir"> </strong>时会发生什么。我稍微加快了视频的速度，但kraken过程可能需要10分钟左右才能完成，这取决于主机的功率。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="qf pl l"/></div></figure><p id="b613" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">最后，我们可以检查docker环境执行以下命令的状态，如下图所示。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi qg"><img src="../Images/5328d3f5e96b94269afe4cd2fb4f62df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O3adI4ST2i58OdzSWC3mBg.png"/></div></div><figcaption class="ot ou gj gh gi ov ow bd b be z dk">docker — bash output</figcaption></figure><p id="1af8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi qh translated"><span class="l qi qj qk bm ql qm qn qo qp di">正如</span>所示，您可以看到我们的集群中已经复制了一些服务，其他的甚至还没有启动，这是因为机器正在获取我们的映像来启动我们的服务，一旦我们的映像被下载并且我们的服务被启动，我们应该会看到类似下图的内容。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi qq"><img src="../Images/ae8d184423eda5d6ecadcce12fa085b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_3_wZTrhzGI-i2CeTdWbxw.png"/></div></div><figcaption class="ot ou gj gh gi ov ow bd b be z dk">docker service ls — bash output</figcaption></figure><p id="0086" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">现在我们的架构看起来如下图所示，其中我们所有的微服务都是动态创建的，通过所有集群复制，并且可以根据需要进行扩展，唯一手动创建的服务是我们的<strong class="ke ir"> <em class="kd"> mongo容器和api-gateways </em> </strong> <em class="kd">，</em>为什么因为它们与我们的主机服务器的规范相关，所以mongo需要持久存储，我们的api需要发现主机docker服务。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi qr"><img src="../Images/c4883fe8785c4ffa833ec2d6bbef342f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W2R1IUGdPxuxO8Nt6v1TXA.png"/></div></div></figure><p id="0055" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">现在，让我们验证我们的服务当前已经启动并正在运行，因此我们需要执行如下图所示的命令。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi qs"><img src="../Images/e44b2b3e1739c861396fb2aca87485e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gcQqRBzvaHY37TjBnGcGWg.png"/></div></div><figcaption class="ot ou gj gh gi ov ow bd b be z dk">docker service ps {service} — bash output</figcaption></figure><p id="c6ca" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">如果我们运行github 上的<strong class="ke ir"> <em class="kd"> Docker Swarm visualizer、</em> </strong> <a class="ae nd" href="https://github.com/ManoMarks/docker-swarm-visualizer" rel="noopener ugc nofollow" target="_blank">，我们可以看到我们的服务(容器)是如何分布在我们的<strong class="ke ir"> <em class="kd"> Docker swarm集群</em> </strong>上的，如下图所示。</a></p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi qt"><img src="../Images/b7b11bcd7d27149ceabe8af282494b16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*um0YNLXrbXngTs2kzd6VNQ.png"/></div></div><figcaption class="ot ou gj gh gi ov ow bd b be z dk">Docker swarm visualizer</figcaption></figure><p id="dd76" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">如果我们缩小一些服务，例如<code class="fe nj nk nl nm b">docker-machine ssh manager1 docker service scale movies-service=1</code>，我们可以看到我们的服务是如何在我们的<strong class="ke ir"><em class="kd"/></strong>集群上重新分布的，如下图所示。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi qu"><img src="../Images/2adf7017a6149a40603a8e68581e5a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SnXBmGyBgCtHgERy0Y-wZQ.png"/></div></div><figcaption class="ot ou gj gh gi ov ow bd b be z dk">Docker swarm visualizer</figcaption></figure><p id="67f6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">我们几乎完成了<strong class="ke ir"> cinemas微服务配置、</strong>以及<strong class="ke ir"> cinemas微服务系统。</strong></p><h2 id="84a3" class="la lb iq bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤8:额外配置</h2><p id="8268" class="pw-post-body-paragraph kb kc iq ke b kf lw kh ki kj lx kl km lj ly kp kq ln lz kt ku lr ma kx ky kz ij bi translated">这是一篇非常大的文章，但是我们已经学到了很多关于docker如何适应我们的开发，以及docker如何补充我们的系统使之更加健壮。</p><p id="7ae3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">我们还需要做一些事情，正确设置并准备运行我们的<strong class="ke ir">影院微服务:</strong></p><ul class=""><li id="e5c0" class="nn no iq ke b kf kg kj kk lj np ln nq lr nr kz ns nt nu nv bi translated">我们需要更新<strong class="ke ir"> api-gateway，</strong>，以便现在可以发现正在运行的docker服务，从而能够进行代理。</li><li id="7934" class="nn no iq ke b kf nw kj nx lj ny ln nz lr oa kz ns nt nu nv bi translated">我们需要填充我们的数据库，为此你可以去查看这里的<a class="ae nd" href="https://github.com/Crizstian/cinema-microservice/tree/master/cinema-catalog-service" rel="noopener ugc nofollow" target="_blank"> github仓库自述文件中的命令。</a></li></ul><p id="db52" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">在我们的<strong class="ke ir"> API网关</strong>中，我们只需要修改我们的<code class="fe nj nk nl nm b"><strong class="ke ir">docker.js</strong></code> <strong class="ke ir"> </strong>中的几行代码，而不是调用<code class="fe nj nk nl nm b">listContainers()</code>函数，我们会调用<code class="fe nj nk nl nm b">listServices()</code>函数并用提供的服务设置我们的路线。</p><p id="ec70" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">为了不使这篇文章变得更长，欢迎您在github仓库检查对<strong class="ke ir"> API网关</strong>的完整代码更改，如果您有任何问题，一如既往地欢迎您给我发推文或在下面发表评论😃📝。</p><h2 id="f82a" class="la lb iq bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤9:测试我们的设置</h2><p id="7656" class="pw-post-body-paragraph kb kc iq ke b kf lw kh ki kj lx kl km lj ly kp kq ln lz kt ku lr ma kx ky kz ij bi translated">因为如果不对我们的系统进行一些测试，我们的文章是不完整的。测试从根本上来说是重要的，因为我们可以从不同的角度，用不同的视角来看待系统，并以不同的期望来测试它。软件测试的最终目的不是找到bug，而是使产品定性。作为一名优秀的测试人员，我们正在为产品质量的提高做出贡献。</p><pre class="nf ng nh ni gt pc nm pd pe aw pf bi"><span id="ee55" class="la lb iq nm b gy pg ph l pi pj"><strong class="nm ir"># we need to locate at the api-gateway folder and execute the test<br/></strong>$ npm run int-test</span></pre><p id="59a9" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">我们将得到如下输出。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi qv"><img src="../Images/17f299ede6d72ef10460af515937e35d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qSlyjkmVstyQqLDKkPCE1A.png"/></div></div></figure><p id="53ad" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">这里我们调用我们的<strong class="ke ir"> api网关服务</strong>，正如你所看到的，我们调用不同的<code class="fe nj nk nl nm b">docker-machine</code> ip，我们的api网关代理我们的请求到我们的<strong class="ke ir"> <em class="kd"> Docker服务</em> </strong> <em class="kd">，</em>，最后我们的测试正确通过😎。</p><p id="246e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">我还对部署在docker swarm集群中的cinema微服务系统进行了jmeter压力测试，因此您可以看到预期的结果。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="qf pl l"/></div></figure><h1 id="149b" class="ob lb iq bd lc oc ox oe lf of oy oh li oi oz ok lm ol pa on lq oo pb oq lu or bi translated">#是时候回顾一下了</h1><p id="14dd" class="pw-post-body-paragraph kb kc iq ke b kf lw kh ki kj lx kl km lj ly kp kq ln lz kt ku lr ma kx ky kz ij bi translated">我们所做的…</p><p id="b2d2" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">我们见过很多码头工人🐋。我们讨论了whale、<strong class="ke ir"> <em class="kd"> Docker、Docker-Machine、Docker-Swarm、Docker-Images、Docker-Hub、Docker-Services </em> </strong>是什么，以及如何进行适当的配置，如何设置自动化流程，以及如何与我们的<strong class="ke ir"> cinemas系统相适应。</strong></p><p id="45c5" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">借助docker，我们使我们的影院微服务和系统更具动态性、容错性、可扩展性和安全性。 但是docker还有太多有趣的东西可以看，比如<strong class="ke ir"> <em class="kd"> Docker网络、Docker撰写、Docker插件等等……</em></strong>Docker是一个不断扩展的devops世界。</p><p id="8baf" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">我们已经看到了使用<strong class="ke ir"> NodeJS </strong>的微服务的大量开发，并且我们已经看到了如何使用<strong class="ke ir"> Docker生态系统</strong>来实现这种微服务，但是我们还可以做和学习更多的东西，这只是更高级的Docker平台的一个小高峰。我希望这已经展示了一些有趣和有用的东西，您可以在您的工作流中使用这些东西。</p><h1 id="8a16" class="ob lb iq bd lc oc ox oe lf of oy oh li oi oz ok lm ol pa on lq oo pb oq lu or bi translated">#还有一件事…</h1><p id="2276" class="pw-post-body-paragraph kb kc iq ke b kf lw kh ki kj lx kl km lj ly kp kq ln lz kt ku lr ma kx ky kz ij bi translated">我知道这篇文章变得很长，但我认为值得再看一步，这将向我们展示如何监控我们的docker swarm集群。</p><h2 id="3e37" class="la lb iq bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤9:监控docker集群</h2><p id="48f4" class="pw-post-body-paragraph kb kc iq ke b kf lw kh ki kj lx kl km lj ly kp kq ln lz kt ku lr ma kx ky kz ij bi translated">因此，要开始监控我们的集群，我们需要在我们的<code class="fe nj nk nl nm b"><strong class="ke ir">manager1 docker-machine</strong></code>中执行以下命令</p><pre class="nf ng nh ni gt pc nm pd pe aw pf bi"><span id="4094" class="la lb iq nm b gy pg ph l pi pj">$ docker-machine ssh manager1 docker run --name rancher --restart=unless-stopped -p 9000:8080 -d rancher/server</span></pre><p id="6d70" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">然后，当容器准备好了，我们需要在浏览器中访问下面的url <code class="fe nj nk nl nm b"><a class="ae nd" href="http://192.168.99.100:9000i" rel="noopener ugc nofollow" target="_blank">http://192.168.99.100:9000</a></code>。</p><p id="ef70" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">然后，rancher gui将向您介绍整个设置过程，最后我们将能够监视我们的群集。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi qw"><img src="../Images/07aa8d5848b01b05cb38e9c378af94e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2NNcTLfBCejVbZaM1mJd3g.png"/></div></div><figcaption class="ot ou gj gh gi ov ow bd b be z dk">Rancher UI of our cluster</figcaption></figure><p id="a49b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">如果我们单击其中一个主机，我们可以看到如下内容。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi qx"><img src="../Images/39fc231a369d96b5c089119f6f858f89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Cd_JY8oCznjPJJmsA78yg.png"/></div></div><figcaption class="ot ou gj gh gi ov ow bd b be z dk">Rancher — Manager 1 logs</figcaption></figure><p id="76c2" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">最后，我们录制了super duper压力集成测试，这样您就可以在视频中看到所有这些配置的结果，以及我们如何通过图形界面或控制台日志来监控我们的群集😎<em class="kd">控制台日志晃动</em>🤘🏽。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="qy pl l"/></div></figure><p id="ab66" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">所以我们已经看到了超能力💪🏽蓝鲸🐋提供给我们的。</p><h2 id="32ec" class="la lb iq bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">##最终意见</h2><p id="83a9" class="pw-post-body-paragraph kb kc iq ke b kf lw kh ki kj lx kl km lj ly kp kq ln lz kt ku lr ma kx ky kz ij bi translated">好了，我们的<strong class="ke ir">影院微服务系统</strong>已经接近完成，但还缺少一些东西，如果我们不开发出缺少的主要部分，我们的影院微服务系统就没有用了，我的朋友们，这是我们的最终用户将与我们的系统交互的前端服务😎，而web用户界面是我们系统中缺少的部分。</p><h1 id="e69d" class="ob lb iq bd lc oc ox oe lf of oy oh li oi oz ok lm ol pa on lq oo pb oq lu or bi translated">#感谢阅读</h1><p id="2e70" class="pw-post-body-paragraph kb kc iq ke b kf lw kh ki kj lx kl km lj ly kp kq ln lz kt ku lr ma kx ky kz ij bi translated">感谢阅读！希望你在文章中找到价值！如果你看过，按下<em class="kd">推荐键</em>，推荐给朋友，分享或者再读一遍。</p><p id="144e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">如果你对这个系列的任何方面有疑问，或者需要我的帮助来理解某些东西，请随时给我发推特或者在下面留下评论。</p><p id="a933" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">让我记住你，这篇文章是“<strong class="ke ir"> <em class="kd">搭建NodeJS影院微服务</em> </strong>”系列的一部分，所以，下周我会再发表一章。</p><p id="10b0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">与此同时，请继续关注，保持对✌的好奇🏼👨🏻‍💻👩🏻‍💻</p><p id="b1f6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">再见了！😁</p><p id="eb23" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lj ko kp kq ln ks kt ku lr kw kx ky kz ij bi translated">你可以在Twitter @ crami rez _ 92<br/><a class="ae nd" href="https://twitter.com/cramirez_92" rel="noopener ugc nofollow" target="_blank">https://twitter.com/cramirez_92</a>关注我</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="893c" class="ob lb iq bd lc oc od oe lf of og oh li oi oj ok lm ol om on lq oo op oq lu or bi translated"># Github的完整代码</h1><p id="f3c0" class="pw-post-body-paragraph kb kc iq ke b kf lw kh ki kj lx kl km lj ly kp kq ln lz kt ku lr ma kx ky kz ij bi translated">您可以在下面的链接中查看文章的完整代码。</p><div class="mb mc gp gr md me"><a href="https://github.com/Crizstian/cinema-microservice" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">GitHub-Crizstian/cinema-微服务:影院微服务示例</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">电影院微服务-电影院微服务示例</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">github.com</p></div></div><div class="mn l"><div class="qz l mp mq mr mn ms jw me"/></div></div></a></div><h1 id="bd8e" class="ob lb iq bd lc oc ox oe lf of oy oh li oi oz ok lm ol pa on lq oo pb oq lu or bi translated">#进一步阅读||阅读互补</h1><ul class=""><li id="111e" class="nn no iq ke b kf lw kj lx lj ra ln rb lr rc kz ns nt nu nv bi translated"><a class="ae nd" href="https://docs.docker.com/engine/swarm/how-swarm-mode-works/services/" rel="noopener ugc nofollow" target="_blank">docker服务如何工作</a></li><li id="4549" class="nn no iq ke b kf nw kj nx lj ny ln nz lr oa kz ns nt nu nv bi translated"><a class="ae nd" href="https://docs.docker.com/engine/swarm/" rel="noopener ugc nofollow" target="_blank">码头工人群体概述</a></li></ul></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="c082" class="ob lb iq bd lc oc od oe lf of og oh li oi oj ok lm ol om on lq oo op oq lu or bi translated">参考数量</h1><ul class=""><li id="a94a" class="nn no iq ke b kf lw kj lx lj ra ln rb lr rc kz ns nt nu nv bi translated"><a class="ae nd" href="https://github.com/docker/docker" rel="noopener ugc nofollow" target="_blank"> Docker GitHub </a></li><li id="6c06" class="nn no iq ke b kf nw kj nx lj ny ln nz lr oa kz ns nt nu nv bi translated"><a class="ae nd" href="https://blog.containership.io/definitions-from-a-developer-what-is-a-cluster" rel="noopener ugc nofollow" target="_blank">来自开发者的定义:什么是集群？</a></li><li id="aeac" class="nn no iq ke b kf nw kj nx lj ny ln nz lr oa kz ns nt nu nv bi translated"><a class="ae nd" href="https://nodesource.com/blog/8-protips-to-start-killing-it-when-dockerizing-node-js/?utm_source=nodeweekly&amp;utm_medium=email#protip1createanonrootuser" rel="noopener ugc nofollow" target="_blank"> 8个Protips在Dockerizing Node.js时开始杀死它</a></li></ul></div></div>    
</body>
</html>