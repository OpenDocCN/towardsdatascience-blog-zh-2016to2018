<html>
<head>
<title>HowTo profile TensorFlow:</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何分析张量流:</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/howto-profile-tensorflow-1a49fb18073d?source=collection_archive---------1-----------------------#2017-03-23">https://towardsdatascience.com/howto-profile-tensorflow-1a49fb18073d?source=collection_archive---------1-----------------------#2017-03-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8b97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在TensorFlow是机器学习最常用的库之一。有时，绘制张量流图并了解哪些操作花费更多时间，哪些花费更少时间可能非常有用。这可以通过tensorflow <code class="fe kl km kn ko b">timeline</code>模块完成。不幸的是，我找不到任何清晰的教程如何使用它。因此，在这篇博文中，我将尝试解决这个问题，涵盖以下主题:</p><ul class=""><li id="d05a" class="kp kq iq jp b jq jr ju jv jy kr kc ks kg kt kk ku kv kw kx bi translated">如何执行张量流代码的剖析？</li><li id="a7f7" class="kp kq iq jp b jq ky ju kz jy la kc lb kg lc kk ku kv kw kx bi translated">如何合并多个会话运行的时间线。</li><li id="6b0c" class="kp kq iq jp b jq ky ju kz jy la kc lb kg lc kk ku kv kw kx bi translated">分析过程中可能会出现哪些问题以及如何解决这些问题。</li></ul><h2 id="f1e4" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">简单的例子</h2><p id="6ff3" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">首先让我们定义一个简单的例子，然后是<a class="ae mb" href="http://stackoverflow.com/questions/34293714/can-i-measure-the-execution-time-of-individual-operations-with-tensorflow/37774470#37774470" rel="noopener ugc nofollow" target="_blank"> StackOverflow回答</a>:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="672f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该注意到为会话运行提供了额外的<code class="fe kl km kn ko b">options</code>和<code class="fe kl km kn ko b">run_metadata</code>。这个脚本应该在CPU和GPU上运行。执行之后，我们将拥有一个<code class="fe kl km kn ko b">timeline_01.json</code>文件，其中包含以Chrome trace格式存储的分析数据。如果您的脚本失败了——请尝试来自【profiling期间的问题部分的第一个解决方案。</p><p id="f556" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要查看存储的数据，我们应该使用Chrome浏览器(不幸的是，据我所知，只有它支持自己的跟踪格式)。进入<code class="fe kl km kn ko b">chrome://tracing</code>页面。在左上角，你会发现<code class="fe kl km kn ko b">Load</code>按钮。按下它并加载我们的JSON文件。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mj"><img src="../Images/9ea64db13315dbba0b46d5981eeed2b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g0ky7NQcMxyCzoQr2xEloQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Example profiling of our simple script on CPU.</figcaption></figure><p id="5ee4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在顶部，你会看到以毫秒为单位的时间轴。要获得一些操作的更精确的信息，只需点击它。同样在右边，有简单的工具存在:选择，平移，缩放和计时。</p><h2 id="223a" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">更复杂的例子</h2><p id="8dac" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">现在让我们用一些占位符和优化器来定义更复杂的例子:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="33ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们的操作存储在变量作用域下。使用这种方法，操作名称将以作用域名称开始，并在时间线上明确区分。</p><p id="68bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，代码存储三次运行的跟踪。如果我们在CPU上执行脚本，我们会收到三个相对相似的时间线，如下所示:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mu"><img src="../Images/e2750309e4c5901b21f6c2c182f02594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AwZdOCneKNnFsTY_NDXvsw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Profiling second script on CPU.</figcaption></figure><p id="bade" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，如果我们检查来自GPU分析的结果，第一个结果将与接下来的结果不同:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mv"><img src="../Images/f9159162a0ed86800ef9da7ef46f8126.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-tBR2uTn7nfXlr6_BFqtg.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Profiling second script on GPU, 1-st run.</figcaption></figure><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mw"><img src="../Images/7c960c931c7dc37bedaac26ddbf43269.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*umS9-4tv3iKSEv6KiboD9w.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Profiling second script on GPU, 2-nd or 3-rd run.</figcaption></figure><p id="7d03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能会注意到，第一次运行比以后的运行花费更多的时间。这是因为tensorflow在第一次运行时会执行一些GPU初始化例程，稍后会对它们进行优化。如果你想要更精确的时间线，你应该在运行一百次左右后存储轨迹。</p><p id="5ea6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，现在所有输入/输出流都以变量作用域名称开始，我们确切地知道一个或另一个操作在源代码中的位置。</p><h2 id="3ee8" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">在一个文件中存储多次运行的时间线</h2><p id="7878" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">如果出于某种原因，我们希望在一个文件中存储多个会话运行，该怎么办？不幸的是，这只能手动完成。Chrome trace格式中存储了每个事件及其运行时间的定义。在第一次迭代中，我们将存储所有数据，但是在下一次运行中，我们将只更新运行时间，而不是定义本身。这里只是合并事件的类定义，完整的例子你可以<a class="ae mb" href="https://github.com/ikhlestov/tensorflow_profiling/blob/master/03_merged_timeline_example.py" rel="noopener ugc nofollow" target="_blank">在这里找到</a>:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="c44a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们收到了很酷的合并时间线:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mv"><img src="../Images/88b754eb8230c7a7d9a29f15f1ef563d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ThWvXv74EC8ttkAiNILVrg.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Merged profiling for 5 runs.</figcaption></figure><p id="d486" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看起来初始化还是需要很多，我们放大到右边:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mx"><img src="../Images/c7191925d7995d1f73a1c6cc06776788.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B7lvjYduHKIz9jv2HPbHuQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Merged profiling for 5 runs zoomed.</figcaption></figure><p id="def5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以看到一些重复的模式。运行之间没有任何特定的分隔符，但我们可以在视觉上区分它们。</p><h2 id="dc6e" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">分析期间的问题</h2><p id="bee7" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在剖析过程中可能存在一些问题。首先，可能根本行不通。如果您遇到了类似这样的错误:</p><pre class="mc md me mf gt my ko mz na aw nb bi"><span id="8f85" class="ld le iq ko b gy nc nd l ne nf">I tensorflow/stream_executor/dso_loader.cc:126] Couldn't open CUDA library libcupti.so.8.0. LD_LIBRARY_PATH:</span></pre><p id="4111" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你确定不按预期对所有作品进行概要分析，它可以通过安装额外的库<code class="fe kl km kn ko b">libcupti-dev</code>根据<a class="ae mb" href="https://github.com/tensorflow/tensorflow/issues/5282" rel="noopener ugc nofollow" target="_blank"> GitHub问题</a>得到解决。此命令应该可以修复所描述的错误:</p><pre class="mc md me mf gt my ko mz na aw nb bi"><span id="4888" class="ld le iq ko b gy nc nd l ne nf">sudo apt-get install libcupti-dev</span></pre><p id="ec4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其次是运行过程中的延迟。在最后一张图片上，我们看到了运行之间的间隙。对于大型网络，这可能会花费大量时间。这个bug不能完全解决，但是使用定制的C++ protobuf库可以减少延迟。在<a class="ae mb" href="https://www.tensorflow.org/install/install_linux#protobuf_pip_package_31" rel="noopener ugc nofollow" target="_blank"> tensorflow文档</a>中清楚地描述了如何执行安装。</p><h2 id="9d27" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">结论</h2><p id="1798" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我希望通过这样的分析，您能更深入地了解tensorflow的内部情况，以及您的图表的哪些部分可以优化。所有已经在CPU和GPU上生成时间线的代码示例都存储在<a class="ae mb" href="https://github.com/ikhlestov/tensorflow_profiling" rel="noopener ugc nofollow" target="_blank">这个repo </a>中。</p><p id="eaac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>