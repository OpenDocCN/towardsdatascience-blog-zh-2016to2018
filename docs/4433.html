<html>
<head>
<title>A comprehensive guide on how to fine-tune deep neural networks using Keras on Google Colab (Free GPU)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于如何在 Google Colab(免费 GPU)上使用 Keras 微调深度神经网络的全面指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-comprehensive-guide-on-how-to-fine-tune-deep-neural-networks-using-keras-on-google-colab-free-daaaa0aced8f?source=collection_archive---------7-----------------------#2018-08-15">https://towardsdatascience.com/a-comprehensive-guide-on-how-to-fine-tune-deep-neural-networks-using-keras-on-google-colab-free-daaaa0aced8f?source=collection_archive---------7-----------------------#2018-08-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/7c6cad5ce8fd8d08a4b3183e4e31f49c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P3L16TfTy-hCwHtC9gyxGQ.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">I like sweet oranges.</figcaption></figure><div class=""/><p id="403e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">在 CPU 上训练深度神经网络比较困难。本教程将指导你如何使用谷歌协作实验室上的 Keras 对 VGG-16 网络进行微调，谷歌协作实验室是一个免费的 GPU 云平台。如果你是谷歌实验室的新手，这是一个适合你的地方，你会学到:</em></p><ul class=""><li id="dac6" class="lb lc jf ke b kf kg kj kk kn ld kr le kv lf kz lg lh li lj bi translated"><em class="la">如何在 Colab 上创建您的第一个 Jupyter 笔记本，并使用免费的 GPU。</em></li><li id="4b39" class="lb lc jf ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><em class="la">如何在 Colab 上上传和使用您的自定义数据集。</em></li><li id="4d7d" class="lb lc jf ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated"><em class="la">如何在前景分割领域对 Keras 预训练模型(VGG-16)进行微调。</em></li></ul><p id="5f6e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，让我们开始吧…</p><h1 id="ead0" class="lp lq jf bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">1.创建您的第一个 Jupyter 笔记本</h1><p id="1b0e" class="pw-post-body-paragraph kc kd jf ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">假设您已经登录了您的 Google 帐户。请遵循以下步骤:</p><p id="0667" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">一)。</strong>导航至<a class="ae ms" href="http://drive.google.com." rel="noopener ugc nofollow" target="_blank">http://drive.google.com</a>。<br/> <strong class="ke jg"> b)。</strong>您将在左侧窗格中看到<strong class="ke jg">我的驱动器</strong>选项卡。现在，在里面创建一个文件夹，比如说<strong class="ke jg"> Colab 笔记本</strong>。<br/> <strong class="ke jg"> c)。</strong>在已创建的文件夹内的右窗格的其他地方单击右键，选择<strong class="ke jg">更多</strong> &gt; <strong class="ke jg">协同实验室</strong>。另一个窗口会弹出来，你可以给你的笔记本起个别的名字，比如说<strong class="ke jg"> myNotebook.ipynb </strong>。加油！！！您已经在 Colab 上创建了您的第一个笔记本😄</p><figure class="mu mv mw mx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mt"><img src="../Images/056bfae738962773ad5f421fb73ad9b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9tQN6y8rc3Qwr7V70F1F5g.png"/></div></div></figure><h1 id="8986" class="lp lq jf bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">2.为笔记本电脑设置 GPU 加速器</h1><p id="aa4c" class="pw-post-body-paragraph kc kd jf ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">在笔记本中，选择<strong class="ke jg">运行时</strong> &gt; <strong class="ke jg">改变运行时类型</strong>。将弹出一个窗口。然后，选择您的运行时类型，从<em class="la">硬件加速器</em>下拉菜单中选择<strong class="ke jg"> GPU </strong>并保存您的设置(如下图)。</p><figure class="mu mv mw mx gt is gh gi paragraph-image"><div class="gh gi my"><img src="../Images/a67488c2875446b94f70caae5aa71339.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*DOg1stgEL9-FiM8fKe42IA.png"/></div></figure><h1 id="0ace" class="lp lq jf bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">3.将您的自定义数据集上传到 Colab</h1><p id="ef10" class="pw-post-body-paragraph kc kd jf ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">您已经完成了在 GPU 上运行笔记本的设置。现在，让我们把你的数据集上传到 Colab。在本教程中，我们工作在<a class="ae ms" href="https://en.wikipedia.org/wiki/Foreground_detection" rel="noopener ugc nofollow" target="_blank">前景分割</a>，从背景中提取前景物体(下图)。</p><figure class="mu mv mw mx gt is gh gi paragraph-image"><div class="gh gi my"><img src="../Images/48c49e1f2ed0bc26fdfaf05b0c5ab357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Sva5RYyCAgfNjIks577WJw.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">images are taken from changedetection.net</figcaption></figure><p id="052f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将数据集上传到 Colab 有几个选项，但是，在本教程中我们考虑两个选项；首先，我们上传到 GitHub 并从它克隆到 Colab，其次，我们上传到 Google Drive 并直接在我们的笔记本上使用。你可以选择任何一个选项。或<strong class="ke jg"> b)。</strong>下图:</p><h2 id="5572" class="mz lq jf bd lr na nb dn lv nc nd dp lz kn ne nf md kr ng nh mh kv ni nj ml nk bi translated">a)。从 GitHub 克隆</h2><p id="643b" class="pw-post-body-paragraph kc kd jf ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">让我们将上述数据集克隆到创建的笔记本中。在你笔记本的单元格中，运行<code class="fe nl nm nn no b">!git clone <a class="ae ms" href="https://github.com/lim-eren/CDnet2014.git" rel="noopener ugc nofollow" target="_blank">https://github.com/lim-eren/CDnet2014.git</a>.</code>你会看到这样的东西:</p><figure class="mu mv mw mx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi np"><img src="../Images/8229ff46f52cd49a0078eda42343d6d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZWBIZuGUmWxQyd9KG5G3uA.png"/></div></div></figure><p id="2cd3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">搞定了。让我们列出训练集，看看它是否有效:</p><figure class="mu mv mw mx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nq"><img src="../Images/6cbc35b5a25434f22ea7d2a43da30183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YduNfGpWYzjD40ure51k9Q.png"/></div></div></figure><p id="6e29" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">开始了。训练集包含 25 个输入帧和 25 个真实帧。跳过<strong class="ke jg">部分 b)。</strong>并跳转到<strong class="ke jg">第 4 节。</strong>如果你做到了这一步。</p><h2 id="e5f1" class="mz lq jf bd lr na nb dn lv nc nd dp lz kn ne nf md kr ng nh mh kv ni nj ml nk bi translated">b)。从 Google Drive 下载</h2><p id="a3fb" class="pw-post-body-paragraph kc kd jf ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">另一个选择是将你的数据集上传到 Google Drive，然后从中克隆。假设你已经压缩了上面的训练集，比如说<strong class="ke jg"> CDnet2014.zip </strong>，上传到 Google Drive 和<strong class="ke jg"> myNotebook.ipynb </strong>在同一个目录下。现在，右键点击<strong class="ke jg">cdnet 2014 net . zip</strong>&gt;<strong class="ke jg">获取可共享链接</strong>。复制文件的<strong class="ke jg"> id </strong>并将其存储在某个地方(我们稍后会用到)。</p><figure class="mu mv mw mx gt is gh gi paragraph-image"><div class="gh gi my"><img src="../Images/c495824ce69e9a101aff42e0ae85b0af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*WIMrfYROhisEfek71lv8nQ.png"/></div></figure><p id="5a78" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，通过运行以下代码验证 Colab 以访问 Google Drive。按照链接获取验证码并粘贴到下面的文本框中，然后按 Enter 键。</p><figure class="mu mv mw mx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/ff938b64a95b64838d62a6176b0b6f17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-xy99iDwWgzYJfMg_356Pg.png"/></div></div></figure><p id="7ba1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，让我们将<strong class="ke jg"> CDnet2014net.zip </strong>文件内容下载到我们的 Jupyter 笔记本中(用上一步获得的<strong class="ke jg"> id </strong>替换<code class="fe nl nm nn no b">YOUR_FILE_ID</code>),并通过运行以下代码将其解压缩:</p><figure class="mu mv mw mx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ns"><img src="../Images/92ee56fd298d0146148ff53caa191222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-bIXZ3naMCCc6d6M5P0iXg.png"/></div></div></figure><p id="7b74" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">搞定了。您已经将数据集从 Google Drive 下载到 Colab。让我们继续<strong class="ke jg">第 4 节</strong>使用这个数据集建立一个简单的神经网络。</p><h1 id="3ef0" class="lp lq jf bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">4.微调你的神经网络</h1><p id="5076" class="pw-post-body-paragraph kc kd jf ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">在您的数据集下载到 Colab 后，现在让我们在前景分割域中微调 Keras 预训练模型。请遵循以下步骤:</p><p id="050f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">一)。</strong>首先，将该代码片段添加到您的笔记本上，以获得跨机器的可再现结果(<em class="la">请在您笔记本的单元格中运行该代码片段</em>):</p><figure class="mu mv mw mx gt is"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="a218" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> b)。</strong>创建一个从 Colab 加载数据的函数。该函数返回输入图像(X)和相应的基本事实(Y):</p><figure class="mu mv mw mx gt is"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1479" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> c)。初始一个普通的编码器-解码器模型。我们采用<a class="ae ms" href="https://github.com/keras-team/keras-applications/blob/master/keras_applications/vgg16.py" rel="noopener ugc nofollow" target="_blank"> VGG-16 预训练模型</a>作为编码器，其中所有全连接层都被移除，只有最后一个卷积层(<code class="fe nl nm nn no b">block5_conv3</code>)被微调，其余层被冻结。我们使用转置卷积层来恢复解码器部分的特征分辨率。</strong></p><p id="8a11" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因为这是一个二元分类问题，所以使用了<code class="fe nl nm nn no b">binary_crossentropy</code>，网络的输出将是 0 和 1 之间的概率值。这些概率值需要被阈值化，以便获得二进制标签 0 或 1，其中标签 0 表示背景，标签 1 表示前景。</p><figure class="mu mv mw mx gt is"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="98e5" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">维。</strong>我们设定学习率为 5e-4，batch_size 为 1，validation_split 为 0.2，max-epochs 为 100，当验证损失在 5 个时期内停止改善时，将学习率降低 10 倍，当验证损失在 10 个时期内停止改善时，提前停止训练。现在，让我们训练模型。</p><figure class="mu mv mw mx gt is"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="mu mv mw mx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nv"><img src="../Images/aebe1f79d942c8c1ab75a9a3a1d81caa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OYwiiYPZ0bRW_zENjy0TKQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Training with GPU</figcaption></figure><p id="b13c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一个纪元大约需要<strong class="ke jg"> 1 秒，太快了！！！在验证集上，最高准确率达到 98%以上。不错吧？现在，让我们暂停一下。我们来对比一下训练<strong class="ke jg">有 GPU </strong>和没有 GPU</strong>的速度吧(<em class="la">如果你愿意</em>可以跳过这个对比直接跳到测试部分)。要在没有 GPU 的情况下进行训练，请将<strong class="ke jg">硬件加速器</strong>设置为<strong class="ke jg">无</strong>(参见第 2 节。以上)。这是训练日志。在没有 GPU 的情况下，一个历元需要大约<strong class="ke jg"> 30 秒，</strong>而使用 GPU 训练时只需要<strong class="ke jg"> 1 秒</strong>(大约快 30 倍👏).</p><figure class="mu mv mw mx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/b8eaa747196bf35490d840c814b9766b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5aB-mvmSkjUJWuwQfrlgVA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Training without GPU</figcaption></figure><p id="aae3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，让我们用 Colab GPU 在<strong class="ke jg">测试集</strong>上测试训练好的模型(<em class="la">你可以运行</em> <code class="fe nl nm nn no b"><em class="la">!ls */test/*</em></code> <em class="la">来查看带有相应地面实况</em>的测试帧)。</p><figure class="mu mv mw mx gt is"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="8d26" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">加油！！！对于一个普通的网络，我们只需要使用 25 个<code class="fe nl nm nn no b">training+validation</code>例子就可以达到 98.94% 的测试精度😄。注意，由于训练样本的随机性，你可能会得到和我相似的结果(不完全相同但只有很小的精度差异)。</p><p id="e085" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">注意一个问题</strong>:我们的模型过度拟合训练数据，解决这个问题是你的工作。<strong class="ke jg">提示</strong>:使用正规化技术，如<a class="ae ms" href="https://keras.io/layers/core/#dropout" rel="noopener ugc nofollow" target="_blank">辍学</a>、<a class="ae ms" href="https://keras.io/regularizers/" rel="noopener ugc nofollow" target="_blank"> L2 </a>、<a class="ae ms" href="https://keras.io/layers/normalization/" rel="noopener ugc nofollow" target="_blank">批量正规化</a>。</p><p id="e5bc" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> e)。</strong>让我们通过运行以下代码来绘制分段掩码:</p><figure class="mu mv mw mx gt is"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="ca0c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">开始了。分割结果一点都不差！大多数对象边界被错误分类，这个问题主要是由于在训练期间的损失计算中考虑了空标签(对象边界周围的模糊像素)的情况。我们可以通过在损耗中省略这些 void 标签来进一步提高性能。你可以参考<a class="ae ms" href="https://github.com/lim-anggun/FgSegNet" rel="noopener ugc nofollow" target="_blank">这里的</a>或者<a class="ae ms" href="https://github.com/lim-anggun/FgSegNet_v2" rel="noopener ugc nofollow" target="_blank">这里的</a>关于如何做。</p><figure class="mu mv mw mx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nw"><img src="../Images/51a5ae2fc4f47ed76ea4bdbdcbba09e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F5lxx3jI-pz4auQlBLdURQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">test result on CDnet2014 dataset (changedetection.net)</figcaption></figure><p id="09c6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">本教程的完整源代码可在<a class="ae ms" href="https://github.com/lim-anggun/tutorials/blob/master/myNotebook.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中获得。</p><h1 id="0d74" class="lp lq jf bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">摘要</h1><p id="7797" class="pw-post-body-paragraph kc kd jf ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">在本教程中，您已经学习了如何使用 Google Colab GPU，并以快速的方式训练了网络。您还学习了如何在前景分割领域中微调 Keras 预训练模型，您可能会在未来的研究中发现这一点。</p><p id="3b8d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你喜欢这个帖子，请随意分享或鼓掌。请过得愉快！🎊😁</p></div></div>    
</body>
</html>