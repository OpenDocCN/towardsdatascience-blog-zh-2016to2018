<html>
<head>
<title>Course 1 — Algorithmic toolbox — Part 3: Divide and Conquer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">课程 1 —算法工具箱—第 3 部分:分而治之</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/course-1-algorithmic-toolbox-part-3-divide-and-conquer-dd9022bfa2c0?source=collection_archive---------0-----------------------#2017-04-12">https://towardsdatascience.com/course-1-algorithmic-toolbox-part-3-divide-and-conquer-dd9022bfa2c0?source=collection_archive---------0-----------------------#2017-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4118" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在本文中讨论各个击破。我对这个话题很感兴趣。我希望你也能。完成作业花了我很多时间。我强烈建议你认真对待作业，并尝试解决两个高级问题。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/1f33e9ffeee81911be205e5349c70f44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Efb7eYvlfYptFHRgo7pB0A.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Divider.</figcaption></figure><h1 id="3cf3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">各个击破</h1><p id="73e1" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">分而治之的步骤:</p><ol class=""><li id="c407" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated">分解成相同类型的不重叠的子问题。</li><li id="0973" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">解决子问题。</li><li id="12e8" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">结合结果。</li></ol><h1 id="dce8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">二分搜索法:在排序数组中搜索。</h1><p id="fa3c" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated"><strong class="jp ir">输入:</strong>一个排序数组 A[low…high] (A[i] &lt; A[i+1])和一个 key k。</p><p id="7631" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出:</strong>一个指标，I，其中 A[i] = k</p><p id="04be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">否则，最大指数 I，其中 A[i] &lt; k.</p><p id="268e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Otherwise (k &lt; A[low]), the result is low — 1.</p><p id="77e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">样本 1: </strong></p><p id="536f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输入:[3，5，9，20，27，52，65]和一个键 20。</p><p id="0910" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出:3。</p><p id="a2a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">样品 2: </strong></p><p id="3019" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输入:[3，5，9，20，27，52，65]和一个键 7。</p><p id="ba25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出:1。</p><p id="f8a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用分治算法来解决这个问题。我们将一步一步地解决它。</p><ol class=""><li id="a41f" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated">分解成相同类型的不重叠的子问题。</li></ol><ul class=""><li id="3b80" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk ms mk ml mm bi translated">输入数组已排序。我们将它分成两半数组。因此在两个子阵列之间没有重叠元素。</li></ul><p id="de7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.解决子问题。</p><ul class=""><li id="562d" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk ms mk ml mm bi translated">我们有两个子问题:A 和 B。我们比较密钥 k 和 B[0]。</li><li id="ffd3" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk ms mk ml mm bi translated">如果 B[0] == k = &gt;我们找到了结果(结果= B[0]的索引)</li><li id="c216" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk ms mk ml mm bi translated">如果 B[0] ≤ k = &gt;我们选择数组 a。(结果= B[0]的索引)</li><li id="df87" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk ms mk ml mm bi translated">如果 B[0] ≥ k = &gt;我们选择数组 B。(结果= A[0]的索引)</li></ul><p id="b059" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.结合结果。</p><ul class=""><li id="a4ed" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk ms mk ml mm bi translated">只需返回结果。</li></ul><p id="388a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">伪代码:</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mt"><img src="../Images/85802f35e8f8f9988a040f41e959b313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gumPkrpUpL73k4NDMXDBXQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Binary Search</figcaption></figure><p id="cdf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">二分搜索法的运行时间是<strong class="jp ir"> O(logn) </strong>。</p><h1 id="40f4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">乘法多项式</h1><p id="e085" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这是非常有趣的部分。我们想要乘以大整数。我们如何做到这一点？除此之外，乘法多项式还应用于纠错码、生成函数、信号处理中的卷积等</p><p id="3ee2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有两个 n 位数:x 和 y(基数 r = 2，10)。</p><p id="6e7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将 x 和 y 表示成两种形式:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mu"><img src="../Images/9f968d345632f277a5637a10e6afc360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QXFdgkvA2OuKpRZgK0aozw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Karatsuba’s method</figcaption></figure><h1 id="a331" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">主定理</h1><p id="d412" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">计算递归算法的 Big-O。我们将公式一般化，并在一般情况下求解。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mv"><img src="../Images/c570bea7de4ab111c8f4a8a0a79dbf6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tGUc6CsSoSIAaFEM2z6EZg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Master Theorem</figcaption></figure><p id="5150" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个公式的证明在[2]中。在本文中，我们将关注问题的解决。:)</p><h1 id="6056" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">合并排序</h1><p id="eeb3" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">MergeSort 喜欢这个名字，分解和合并。这个概念非常简单:</p><ul class=""><li id="8bfa" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk ms mk ml mm bi translated">分成两个子列表，直到只剩下一个元素。</li><li id="8a49" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk ms mk ml mm bi translated">按顺序合并 2 个子列表(排序)。</li></ul><p id="2c55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">伪代码:</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mw"><img src="../Images/d73262874ab77bd2dbd2adb6f05afe2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AGJaTUaymAQK3pgVdSgTbA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">MergeSort</figcaption></figure><p id="c915" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的关键点是合并策略。循环思考 2 个子数组，选择较小的元素，放入第三个数组。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mx"><img src="../Images/b045eb3f55777ac1ce509e717e2ba275.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OgubJ7pQioT5zRiX6NqrPA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Merge strategy</figcaption></figure><p id="c113" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大 O 就是<strong class="jp ir"> O(nlogn)。</strong></p><p id="2f2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意:</strong>下面有一个有趣的问题，需要我们调整合并策略。通过调整，你会完全理解合并排序。</p><h1 id="7bb7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">快速排序</h1><p id="382f" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">快速排序的概念是选择一个支点，重新排列数组，使左支点上的所有元素都小于支点，右支点上的所有元素都大于支点。</p><p id="09f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例</strong>:对于数组 A = [ <strong class="jp ir"> 6 </strong>，4，2，3，9，8，9，4，7，6，1]</p><p id="e9b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们选择 A[1] = 6 是一个支点，我们需要把 A 重新排列成:</p><p id="b6d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[1，4，2，3，4，6，<strong class="jp ir"> 6 </strong>，9，7，8，9]</p><p id="7556" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快速排序算法分两步实现:</p><ul class=""><li id="19db" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk ms mk ml mm bi translated">选择支点，重新排列成 A[left] ≤A[pivot] &lt; A[right].</li><li id="051c" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk ms mk ml mm bi translated">Keep choosing pivot and re-arrange A[left] and A[right].</li></ul><p id="3628" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">The pseudocode for this 2 steps:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi my"><img src="../Images/c6d2e65c45194e03900f31f4fb82b9f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-di84FdfamccF1ZdbFLuQA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">QuickSort</figcaption></figure><p id="8f20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">As you see, l is left index, r is right index.</p><p id="b8fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Partition(A, l, r) function is containing choosing pivot, and rearrange A from l(left-index) to r(right-index) into A[left] ≤ A[pivot] ≤ A[right] and returning the position(index) of A[pivot].</p><p id="ed5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">To choose pivot, we have many strategies. If we know what types of data we have, we will have better choice of pivot. There are common choices of pivot:</p><ul class=""><li id="fedd" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk ms mk ml mm bi translated">Choose A[0] as a pivot.</li><li id="55ab" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk ms mk ml mm bi translated">Choose random from l -&gt; r 作为支点</li><li id="6d54" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk ms mk ml mm bi translated"><a class="ae mz" href="https://en.wikipedia.org/wiki/Median_of_medians" rel="noopener ugc nofollow" target="_blank">中位数的中位数</a>算法。</li></ul><p id="2ad7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以[0]为轴心重新排列数组的伪代码:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi na"><img src="../Images/1edb21af791d9de085b953a4b5b031ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IilMpDuVng3388xPVsEOLg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">QuickSort partition</figcaption></figure><p id="af11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">x 将是 pivot 的值。</p><p id="255c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们想把 A[l…r]重新排列成 A[left] ≤ A[pivot] ≤ A[right]用</p><p id="8ff8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">左=左</p><p id="9654" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">A[右] = A[j+1…r]</p><p id="65cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用最后一个示例来说明如何将 A = [ <strong class="jp ir"> 6 </strong>，4，2，3，9，8，9，4，7，6，1]转换为[1，4，2，3，4，6，<strong class="jp ir"> 6 </strong>，9，7，8，9]。</p><p id="2acc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">left = 0，r = 10，pivot A[0] = 6。</p><p id="3894" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有一个[left]只有一个[l]元素，所以 j = 0。</p><p id="c692" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们从 l+1 到 r 循环 I，每一步都要保证 A[left…j] ≤ A[pivot] ≤ A[j+1…r]。有两种情况:</p><ul class=""><li id="e874" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk ms mk ml mm bi translated">A[i] ≥ A[pivot]，我们什么都不做，因为它已经是 A[i]≥ A[pivot]。</li><li id="71db" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk ms mk ml mm bi translated">A[i] ≤ A[pivot]，我们有 A[j]是小于 A[pivot]的元素的最后一个索引。因此，我们需要交换 A[j+1]和 A[i]并标记 j = j+1，以表明 j 是小于 A[pivot]的元素的最后一个索引。通过交换 A[j+1]和 A[i]，我们确定 A[l…j] ≤ A[pivot] ≤ A[j+1…r]。</li></ul><p id="b2d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您手动运行该算法，我们将得到 A =[ <strong class="jp ir"> 6 </strong>，4，2，3，4，6，1，9，7，8，9]。</p><p id="ab59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们现在有了数组:A[l] + A[1…j] + A[j+1…r]。最后一步是交换 A[j]和 A[0]，这样我们将得到数组:A[0…j-1] + A[pivot] + a[j+1…r]。</p><p id="6485" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">于是我们得到:A = [1，4，2，3，4，6，<strong class="jp ir"> 6 </strong>，9，7，8，9]。</p><h2 id="57e6" class="nb lc iq bd ld nc nd dn lh ne nf dp ll jy ng nh lp kc ni nj lt kg nk nl lx nm bi translated"><strong class="ak">随机化枢纽:</strong></h2><p id="3ef8" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">要实现随机化透视，很简单，只需:</p><ul class=""><li id="93a8" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk ms mk ml mm bi translated">选择随机支点 l ≤ k ≤ r。</li><li id="76f4" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk ms mk ml mm bi translated">交换 A[0]和 A[k]</li><li id="7f21" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk ms mk ml mm bi translated">保持分区就像选择一个[o]作为支点。</li></ul><p id="0448" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随机化 pivot 快速排序的 Big-O 在平均运行时间上是<strong class="jp ir"> O(nlogn) </strong>。最坏的情况运行时间是<strong class="jp ir"> O(n ) </strong>。这个大 O 有点棘手。你可以阅读[3]中的证明。</p><p id="7b3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注:</strong>快速排序最差的情况是<strong class="jp ir"> O(n ) </strong>但是在实践中，快速排序平均给了我们比合并排序更好的性能。</p><h2 id="fe8f" class="nb lc iq bd ld nc nd dn lh ne nf dp ll jy ng nh lp kc ni nj lt kg nk nl lx nm bi translated">Equal Elements:带有一些 uniq 元素的快速排序。</h2><p id="72fe" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">你可以在这里看到快速排序的<a class="ae mz" href="https://www.toptal.com/developers/sorting-algorithms/quick-sort" rel="noopener ugc nofollow" target="_blank">可视化</a>。我们可以观察到，如果数据有许多相等的元素，快速排序需要很长时间才能完成。为了优化，我们应该有不同的分区策略:</p><p id="d6a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而不是把 A 重新排列成 A[左]≤A[支点]≤A[右]。我们将把 A 变成:A[左]≤A[m1…m2]≤A[右]有 A[I]= = A[支点] (m1 ≤ i ≤ m2)。</p><p id="8163" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以在每一步，我们都少了一个[左]，一个[右]项要排序。</p><p id="5323" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相等元素的伪代码:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nn"><img src="../Images/1a80769bd85a8f813a9888b24faa6489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o_GgcVpUL9pDBLffw2JtSw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Equal elements QuickSort</figcaption></figure><p id="1f05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在练习中，我们将了解该算法的实现细节。</p><p id="ed3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完全理解这些排序算法和分而治之技术的最好方法是解决有趣的问题。大家一起解决吧。</p><h1 id="a0b4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">问题 1:实现二分搜索法</h1><p id="9b7b" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">在这个问题中，你将实现二分搜索法算法，该算法允许非常有效地搜索(甚至是巨大的)列表，只要列表是排序的。</p><p id="9be5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入格式。</strong>输入的第一行包含一个整数 n 和一个序列 a0 &lt; a1 &lt;。。。&lt; a(n-1)个按升序排列的 n 个两两不同的正整数。下一行包含一个整数 k 和 k 个正整数 b0，b1，.。。，b(k-1)。</p><p id="bd90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">约束。</strong> 1 ≤ n，<strong class="jp ir">k≤10⁵</strong>；对于所有 0 ≤i &lt; n，1≤ai≤10⁹<strong class="jp ir">t11；对于所有 0≤j &lt; k，1≤bj≤10⁹；</strong></p><p id="1fe6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出格式。</strong>对于所有的 0 ≤ i ≤ k-1，输出一个索引 0≤j≤n-1，使得 aj = bi，如果没有这样的索引，则输出-1。</p><p id="e5d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">样本。</strong></p><p id="0440" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入:</strong></p><p id="aaf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">5 1 5 8 12 13</p><p id="2e0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">5 8 1 23 1 11</p><p id="b697" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出:</strong></p><p id="2ad0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">2 0 –1 0 –1</p><p id="87cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解释:<br/> </strong>在这个例子中，给我们一个长度为五的递增序列 a0 = 1，a1 = 5，a2 = 8，a3 = 12，a4 = 13，五个键进行搜索:8，1，23，1，11。我们看到 a2 = 8，a0 = 1，但是键 23 和 11 没有出现在序列 a 中，为此，我们输出一个序列 2，0，1，0，1。</p><h2 id="b8ad" class="nb lc iq bd ld nc nd dn lh ne nf dp ll jy ng nh lp kc ni nj lt kg nk nl lx nm bi translated">解决方案:</h2><p id="ab0b" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我们只是按照上面的二进制搜索伪代码，实现二进制搜索算法。最后，我们循环搜索关键字 b0，b1，…，bk，并运行<strong class="jp ir"> binary_search(a，bi) </strong>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">BinarySeach</figcaption></figure><h1 id="bdd2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">问题 2:寻找多数元素</h1><p id="3bce" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">多数规则是一种决策规则，它选择拥有多数票(即超过半数的选票)的方案。<br/>给定一系列元素 a1，a2，.。。，您希望检查它是否包含出现 n/2 次以上的元素。下面是一个简单的方法。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e595" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该算法的运行时间是二次的。你的目标是使用分治技术设计一个 O(n log n)算法。</p><p id="3191" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入格式。</strong>第一行包含整数 n，下一行包含 n 个非负整数 a0，a1，.。。，一个 1。</p><p id="fc33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出格式。</strong>如果序列包含一个严格出现次数超过 n/2 次的元素，则输出 1，否则输出 0。</p><p id="14b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">样品 1。</strong></p><p id="0960" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入</strong> : 5</p><p id="6ef9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">2 3 9 2 2</p><p id="57c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出</strong>:</p><p id="020b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">1</p><p id="46b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解释:<br/> </strong> 2 是多数元素。</p><p id="05fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">样品 2。</strong></p><p id="9d7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入</strong> : 4</p><p id="8e71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">1 2 3 1</p><p id="1331" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出</strong>:</p><p id="1e02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">0</p><p id="635b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解释</strong> : <br/>这个序列也没有多数元素(注意元素 1 出现了两次，因此不是多数元素)。</p><p id="16a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能已经猜到了，这个问题可以通过分治算法在时间 O(nlogn)内解决。事实上，如果一个长度为 n 的序列包含一个多数元素，那么这个元素也是它的一半的多数元素。因此，要解决这个问题，首先要将一个给定的序列分成两半，并进行两次递归调用。你看到如何组合两个递归调用的结果了吗？</p><p id="76d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有趣的是，这个问题也可以通过更高级的(非分治)算法在 O(n)时间内解决，该算法只需扫描给定序列两次。</p><h2 id="169e" class="nb lc iq bd ld nc nd dn lh ne nf dp ll jy ng nh lp kc ni nj lt kg nk nl lx nm bi translated"><strong class="ak">解决方案:</strong></h2><p id="d5da" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这是一个超级有趣的问题，如果你用分而治之来解决它。</p><p id="3295" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要分成子问题。在每一步，我们将序列分成两个左半序列和右半序列。主要工作是编写合并策略:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="21f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了确定<strong class="jp ir">序列</strong>的多数，我们将把<strong class="jp ir">的左半部分</strong>或<strong class="jp ir">的右半部分</strong>表示成两个元素的数组:<strong class="jp ir"> A【多数，其他】</strong>。</p><p id="38fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> majorities = A[0] </strong>包含在此序列中占多数的所有元素(相同值)。名为<strong class="jp ir"> A_major_elements </strong></p><p id="b6e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> others = A[1] </strong>是内部没有 A_major_elements 的所有元素。</p><p id="20e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">示例:</p><p id="1b27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">left_half = [[2，2，2]，[3，5，7，7，9]]</p><p id="6c16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">right_half = [[5，5，5，5]，[4，8，10，34，2，10，10]]</p><p id="7a6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> count_merge </strong>函数将基于<strong class="jp ir">左 _half </strong>和<strong class="jp ir">右 _half </strong>返回<strong class="jp ir"> M【多数，其他】</strong>。</p><p id="4439" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们会:</p><ul class=""><li id="5750" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk ms mk ml mm bi translated">从<strong class="jp ir">右半部分[1] </strong> ([4，8，10，34，2，10，10])<strong class="jp ir"/>中取出所有<strong class="jp ir">左半部分主元素</strong>(例:2) <strong class="jp ir"> </strong>放入<strong class="jp ir">左半部分[0】。</strong></li><li id="7866" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk ms mk ml mm bi translated">从<strong class="jp ir">左半部分</strong>(【3，5，7，7，9】)<strong class="jp ir">，</strong>中取出所有<strong class="jp ir">右半部分主元素(ex: 5) </strong>放入<strong class="jp ir">右半部分【0】。</strong></li></ul><p id="1ac1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们得到了:</p><p id="516a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">left_half = [[2，2，2，<strong class="jp ir"> 2 </strong> ]，[3，7，7，9]](加 2，减 5)</p><p id="04c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">right_half = [[5，5，5，5，<strong class="jp ir"> 5 </strong>，[4，8，10，34，10，10]](加 5，减 2)。</p><p id="b081" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们称这个过程为<strong class="jp ir"> chunk_process </strong>:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3c71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir"> count_merge </strong>函数中，我们只需要根据<strong class="jp ir"> chunk_left </strong>和<strong class="jp ir"> chunk_right </strong>选择多数。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="634b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终我们会有一个结果数组:<strong class="jp ir">【多数，其他】</strong>。我们只需检查大多数的长度超过 n/2 就可以给出答案。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="ab63" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">问题 3:改进快速排序</strong></h1><p id="ead8" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这个问题的目标是重新设计随机快速排序算法的一个给定实现，使它即使在包含许多相等元素的序列上也能快速工作。</p><p id="a691" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题描述</strong></p><p id="8543" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">任务。</strong>为了强制快速排序算法的给定实现有效地处理具有很少唯一元素的序列，您的目标是用 3 路分区替换 2 路分区。也就是说，您的新分区过程应该将数组分成三部分:&lt; x 部分、= x 部分和&gt; x 部分。</p><p id="2f25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入格式。</strong>输入的第一行包含一个整数 n。下一行包含 n 个整数 a0，a1，.。。，a(n-1)。</p><p id="f28d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出格式。</strong>输出这个按非降序排序的序列。</p><p id="4f30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">样品 1。</strong></p><p id="b572" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输入:5</p><p id="2a69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">2 3 9 2 2</p><p id="61f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出:</p><p id="da84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">2 2 2 3 9</p><h2 id="d5d0" class="nb lc iq bd ld nc nd dn lh ne nf dp ll jy ng nh lp kc ni nj lt kg nk nl lx nm bi translated">解决方案:</h2><p id="2857" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">正如我们上面所说的，我们需要为具有许多相等元素的数据优化 QuickSort。因此，我们将阵列划分为 3 个阵列:</p><p id="8ff9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">A[left]≤A[m1…m2]≤A[right]with A[I]= = A[pivot](m1≤I≤m2)。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="30da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的主要工作是实现 partition3 函数来重新排列数组 A 并返回位置 m1，m2。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="a5aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们从 l + 1 到 r 循环遍历所有元素 I。在每一步，我们确保将 a[i]重新排列到正确的位置。</p><p id="90ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，如果<strong class="jp ir"> a[i] ≤ pivot </strong> (a[l])，我们将 a[i]重定位到 a[begin…end](与 pivot 具有相同的值)。我们继续检查是否<strong class="jp ir"> a[i] == pivot </strong>，我们通过什么都不做来保持那个位置，如果<strong class="jp ir"> a[i] &lt; pivot </strong>，我们需要在 a[begin]之前移动 a[i]。</p><p id="09ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们只需交换 a[0](pivot)和 a[begin]就可以得到分区(重新排列)数组 a 的最后一步。</p><p id="b1dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这似乎很难理解，但如果你手动运行它，它会在你的手下非常清晰(我保证)。</p><h1 id="e81f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">高级问题 4:一个数据离被排序有多近？</h1><p id="a304" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">序列 a0，a1，…，a(n-1)的逆是一对指数 0 ≤i &lt; j &lt; n such that ai &gt; aj。在某种意义上，一个序列的反转次数衡量了这个序列接近被排序的程度。例如，一个排序的(非降序)序列根本不包含反转，而在一个降序排序的序列中，任何两个元素构成一个反转(总共 n(n-1)/2 个反转)。</p><p id="c185" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题描述</strong></p><p id="f81e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">任务。</strong>这个问题的目标是统计给定序列的求逆次数。</p><p id="8eb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入格式。</strong>第一行包含一个整数 n，下一行包含一个整数序列 a0，a1，…，a(n-1)。</p><p id="79c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出格式。</strong>输出序列中反转的次数。</p><p id="8385" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">样品 1。</strong></p><p id="5645" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入</strong> : 5</p><p id="2874" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">2 3 9 2 9</p><p id="bfa6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出:2</p><p id="10eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">说明:<br/>这里的两个逆是(1，3)(a1 =3 &gt; 2=a3)和(2，3)(a2 =9 &gt; 2=a3)。</p><p id="4c42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个问题可以通过修改合并排序算法来解决。为此，我们将合并和合并排序过程更改如下:</p><ul class=""><li id="3991" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk ms mk ml mm bi translated">Merge(B，C)返回排序后的数组和对(B，C)的数量，使得 b ∈ B，c ∈ C，b &gt; c</li><li id="013c" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk ms mk ml mm bi translated">MergeSort(A)返回一个已排序的数组 A 和 A 中的求逆次数。</li></ul><h2 id="b7dc" class="nb lc iq bd ld nc nd dn lh ne nf dp ll jy ng nh lp kc ni nj lt kg nk nl lx nm bi translated">解决方案:</h2><p id="0b2d" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我们的目标是打印反转次数 ai &gt; aj ( 0 ≤ i ≤ j ≤ n)。我们将数组 A 分为<strong class="jp ir"> left_array </strong>和<strong class="jp ir"> right_array </strong>，格式:<strong class="jp ir">【count _ inversions，sorted_elements】。</strong></p><p id="d9fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir"> merge </strong>函数中，我们可以实现类似 MergeSort 的功能，我们需要为具有<strong class="jp ir">left _ array[1][I]&gt;right _ array[1][I]</strong>的步骤添加<strong class="jp ir"> count_inversions </strong>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="1872" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">高级问题 5:组织一次抽奖</h1><p id="4b55" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">您正在组织在线抽奖。为了参与，一个人在一个整数上下赌注。然后，随机绘制几个连续整数的范围。然后，参与者的收益与包含该参与者数字的区间数减去不包含该数字的区间数成正比。你需要一个有效的算法来计算所有参与者的收益。一种简单的方法是扫描所有参与者的所有范围列表。然而，你的彩票很受欢迎:你有成千上万的参与者和成千上万的范围。出于这个原因，你不能负担一个缓慢的幼稚算法。</p><p id="7821" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题描述</strong></p><p id="e0e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">任务</strong>。给你一组线上的点和一组线上的线段。目标是为每个点计算包含该点的线段数。</p><p id="e898" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入格式</strong>。第一行包含两个非负整数 s 和 p，分别定义线段数和一行上的点数。接下来的 s 行包含定义第 I 个段[ai，bi]的两个整数 ai，bi。下一行包含定义点 x1、x2、.。。，xp。</p><p id="f163" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出格式。</strong>输出 p 个非负整数 k0，k1，.。。k(p-1)，其中 ki 是包含 xi 的片段的数量。</p><p id="de8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">样品 1。</strong></p><p id="2772" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入:</strong></p><p id="0119" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">2 3</p><p id="2c88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">0 5</p><p id="e932" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">7 10</p><p id="2da5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">1 6 11</p><p id="bd84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出:</strong></p><p id="cd58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">1 0 0</p><p id="d875" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解释:</strong> <br/>这里我们有两段([0，5]，[7，10])和三点([1，6，11])。第一个点仅位于第一个线段中，而其余两个点位于所有给定线段之外。</p><p id="1096" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">样品 2。</strong></p><p id="4dc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入:</strong></p><p id="e418" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">3 2</p><p id="7bec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">0 5</p><p id="111d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">-3 2</p><p id="1f91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">7 10</p><p id="7216" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">1 6</p><p id="028c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出</strong>:</p><p id="48d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">2 0</p><p id="2b89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能已经猜到，您的目标是首先以某种方式对给定的片段进行排序(因此，这是一个排序问题，而不是分治问题)。</p><h2 id="247c" class="nb lc iq bd ld nc nd dn lh ne nf dp ll jy ng nh lp kc ni nj lt kg nk nl lx nm bi translated">解决方案:</h2><p id="bf4b" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这个问题很有挑战性。为了解决这个问题，我们必须通过一些策略对给定的片段进行排序。</p><p id="ad01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将[ai，aj]和 POINT[pk]变成 3 个数组:[ai，LEFT]，[aj，RIGHT]，[PK，POINT]左= 1，点= 2，右= 3。</p><p id="d0ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们尝试排序[ai，LEFT] + [aj，RIGHT] + [pk，POINT]。为了比较两个元素[x，左/右/点]和[y，左/右/点]，我们比较 x 和 y，如果 x == y，我们根据左= 1，点= 2，右= 3 的值比较左/右/点。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0dfb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，我们有段:[0，5]，[-3，2]，[7，10]和点:[1，6]。我们把这些变成:[0，左]，[5，右]，[-3，左]，[2，右]，[1，点]，[6，点]。然后，我们使用问题 3 中的 RandomizedQuickSort 对这些项目进行排序，我们将得到一个排序后的数组:</p><p id="6216" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[-3，左]，[0，左]，[1，点]，[2，右]，[5，右]，[6，点]，[10，右]。</p><p id="2d2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了计算覆盖段，我们只需要计算在“点”项之前出现了多少(“左”-右”)项。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7963" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了通过这个问题，我必须提交 11 次大量的变化策略。所以，不要放弃，你比你想象的要优秀！</p><h1 id="83ba" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">高级问题 6:寻找最近的一对点</h1><p id="6dd4" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">在这个问题中，你的目标是在给定的 n 个点中找到最近的一对点。这是计算几何中的一个基本原语，在例如图形、计算机视觉、交通控制系统中有应用。</p><p id="3b49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题描述</strong></p><p id="1467" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">任务</strong>。给定平面上的 n 个点，求一对两点(不同点)之间的最小距离。</p><p id="9e6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入格式</strong>。第一行包含点数 n。下面 n 条线的每一条定义一个点(，易)。</p><p id="1a45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出格式</strong>。输出最小距离。你的程序的答案和最优值之差的绝对值最多应该是 1/10。为了确保这一点，输出您的答案时小数点后至少要有四位数字(否则，虽然您的答案计算正确，但可能会因为舍入问题而出错)。</p><p id="10f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">样品 1 </strong>。</p><p id="bc44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入</strong>:</p><p id="2c0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">11</p><p id="c2fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">4 4</p><p id="8e2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">-2 -2</p><p id="49eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">-3 -4</p><p id="1cbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">-1 3</p><p id="7b1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">2 3</p><p id="4dfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">-4 0</p><p id="1ce7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">1 1</p><p id="1fff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">-1 -1</p><p id="9250" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">3 –1</p><p id="cc99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">-4 2</p><p id="bd93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">-2 4</p><p id="6c2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出</strong>:</p><p id="2148" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">1.414213</p><p id="b519" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">说明:最小距离√2。这个距离上有两对点:(1，1)和(2，2)；(2，4)和(1，3)。</p><p id="40b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解决方案:</strong></p><p id="f8f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在[CLRS]中有一章讨论这个问题，我认为这个问题是这门课中最难的。我经常遇到失败案例#22/23:超过时间限制。所以，一定要先看[CLRS]教材，[33.4 节]关于这个问题。</p><p id="7bd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要通过 x 坐标对点进行预排序，并将点分成两个数组:<strong class="jp ir"> left_points </strong>和<strong class="jp ir"> right_points。</strong>我们的目标是计算最小距离的<strong class="jp ir">左 _ 点</strong>称为<strong class="jp ir">最小 _ 左</strong>，最小距离的<strong class="jp ir">右 _ 点</strong>称为<strong class="jp ir">最小 _ 右</strong>。和<strong class="jp ir">左 _ 点</strong>和<strong class="jp ir">右 _ 点</strong>之间的最小距离称为<strong class="jp ir">混合 _ 最小。</strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8b2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于小尺寸的数组(首先是尺寸&lt; 3), we use compute min distance by brute-force. We try to compute <strong class="jp ir">左 _ 最小</strong>和<strong class="jp ir">右 _ 最小</strong>。我们称<strong class="jp ir">左 _min </strong>和<strong class="jp ir">右 _min </strong>的最小距离为<strong class="jp ir">分隔 _min </strong>。因为 left_points 和 right_points 是按 x 排序的，并且我们确实计算了<strong class="jp ir"> separated_min </strong>，所以不计算<strong class="jp ir">所有 left_points </strong>的<strong class="jp ir"> hybrid_min </strong>和<strong class="jp ir">所有</strong> <strong class="jp ir"> right_points </strong>的<strong class="jp ir"> separated_min </strong>半径内具有 x 坐标的点，我们只关心从中线<strong class="jp ir">line _ l =(left _ points【last】。x + right_points[first]。x)/2。</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nq"><img src="../Images/e1323c1150244fe666fe7146243c4f46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tcY_hpz5ET2EADnGNtgVCw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Red points are in separated radius.</figcaption></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="6aed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们减少了具有 x 坐标的点在<strong class="jp ir">分隔 _ 最小</strong>半径之间的数量。我们称这些缩减点为<strong class="jp ir">缩减 _ 总计</strong>点。我们可以看到，要计算一个点到 reduced_total 点中所有点的最小距离，我们只需要计算 reduced_total 点中 y 坐标在<strong class="jp ir"> separated_min </strong>内的 7 个点。表示<strong class="jp ir">减总</strong>点 x 点的边界是一个矩形，其<strong class="jp ir">宽= 2 x 分隔最小</strong>，<strong class="jp ir">高=分隔最小</strong>。为此，我们需要按 y 坐标对<strong class="jp ir">约简总数</strong>点进行排序，并遍历所有排序后的约简总数点，计算 7 点边界的最小距离。然后我们可以最终计算混合最小距离。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="144c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很难找到实现这种算法的正确方向。一旦你实施正确，你将通过这个问题。我确实为这个问题提交了 17 次。所以保持冷静，继续提交。:D</p><p id="0531" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">资源:</strong></p><p id="2402" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[1]:<a class="ae mz" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/MIT6_006F11_lec11.pdf" rel="noopener ugc nofollow" target="_blank">https://OCW . MIT . edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/LEC 11 . pdf</a></p><p id="2870" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[2]主定理:[DPV08]的第 2.2 节</p><p id="6bb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[3]快速排序:[CLRS]的第 7 章</p><p id="8261" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">多项式乘法:[DPV08]的第 2.1 节</p><p id="ba6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">合并排序和基于比较排序的下限:[DPV08]的第 2.3 节</p><p id="61d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快速排序:[CLRS]第 7 章</p><p id="376c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">参考文献:</strong></p><p id="0c1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Sanjoy Dasgupta、Christos Papadimitriou 和 Umesh Vazirani。算法(第一版)。麦格劳-希尔高等教育。2008.</p><p id="fcf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">托马斯·h·科尔曼，查尔斯·e·莱瑟森，罗纳德·L·李维斯特，克利福德·斯坦。算法导论(第三版)。麻省理工学院出版社和麦格劳-希尔。2009.</p></div></div>    
</body>
</html>