<html>
<head>
<title>How the good old sorting algorithm helps a great machine learning technique</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">古老的排序算法如何帮助伟大的机器学习技术</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-the-good-old-sorting-algorithm-helps-a-great-machine-learning-technique-9e744020254b?source=collection_archive---------5-----------------------#2018-07-18">https://towardsdatascience.com/how-the-good-old-sorting-algorithm-helps-a-great-machine-learning-technique-9e744020254b?source=collection_archive---------5-----------------------#2018-07-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e22c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在本文中，我们展示了简单排序算法如何成为解决计算几何中一个重要问题的核心，以及它如何与广泛使用的机器学习技术相关联。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/4300dee9f0581fef7cba45352ba7de79.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*opwN0BhtH4zvPF697fPlow.gif"/></div></figure><p id="4568" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">机器学习正迅速成为现代社会中最重要的计算技术之一。作为人工智能(AI)的一个分支，它正被应用于从<a class="ae lm" href="https://www.nytimes.com/2016/12/14/magazine/the-great-ai-awakening.html" rel="noopener ugc nofollow" target="_blank">自然语言翻译和处理</a>(想想 Siri 或 Alexa)到<a class="ae lm" href="https://www.techemergence.com/machine-learning-in-pharma-medicine/" rel="noopener ugc nofollow" target="_blank">医学</a>、<a class="ae lm" href="https://www.nytimes.com/2014/11/20/technology/personaltech/picking-your-cars-computerized-brain.html" rel="noopener ugc nofollow" target="_blank">自动驾驶</a>或商业战略发展的方方面面。一系列令人眼花缭乱的智能算法正在不断开发，以解决 ML 问题，从数据流中学习模式，并建立人工智能基础设施。</p><blockquote class="ln lo lp"><p id="0f51" class="kq kr lq ks b kt ku ju kv kw kx jx ky lr la lb lc ls le lf lg lt li lj lk ll im bi translated">然而，有时后退一步，分析一些基本算法如何在这场革命中发挥作用，并欣赏它们的影响，感觉会很好。在本文中，我将举例说明这样一个重要的案例。</p></blockquote><h2 id="e221" class="lu lv it bd lw lx ly dn lz ma mb dp mc kz md me mf ld mg mh mi lh mj mk ml mm bi translated">支持向量机</h2><p id="5f09" class="pw-post-body-paragraph kq kr it ks b kt mn ju kv kw mo jx ky kz mp lb lc ld mq lf lg lh mr lj lk ll im bi translated"><a class="ae lm" href="https://en.wikipedia.org/wiki/Support_vector_machine" rel="noopener ugc nofollow" target="_blank">支持向量机或 SVM </a>简而言之，是过去几十年发展起来的最重要的机器学习技术之一。给定一组训练样本，每个样本被标记为属于两个类别中的一个或另一个，SVM 训练算法建立一个模型，将新样本分配给一个类别或另一个类别，使其成为非<a class="ae lm" href="https://en.wikipedia.org/wiki/Probabilistic_classification" rel="noopener ugc nofollow" target="_blank">概率</a> <a class="ae lm" href="https://en.wikipedia.org/wiki/Binary_classifier" rel="noopener ugc nofollow" target="_blank">二元</a> <a class="ae lm" href="https://en.wikipedia.org/wiki/Linear_classifier" rel="noopener ugc nofollow" target="_blank">线性分类器</a>。它广泛应用于工业系统、文本分类、模式识别、生物 ML 应用等。</p><p id="d18f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下图说明了这个想法。主要目标是将二维平面中的点分为两类——红色或蓝色。这可以通过在两组点之间创建分类器边界(通过运行<a class="ae lm" href="https://en.wikipedia.org/wiki/Statistical_classification" rel="noopener ugc nofollow" target="_blank">分类算法</a>并从标记数据中学习)来完成。图中显示了一些可能的分类器。它们都将正确地对数据点进行分类，但是并非所有的数据点都与最接近边界的数据点集具有相同的“<em class="lq">余量</em>”(即距离)。可以看出，它们中只有一个最大化了蓝点和红点集合之间的这个“T4”裕度。该唯一分类器用实线表示，而其他分类器用虚线表示。这种间隔最大化的效用在于<strong class="ks iu"> <em class="lq">两个类之间的距离越大，对于一个新点的分类的泛化误差就越低。</em>T9】</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/1463ad18aad1fdbcda7f5dadfdce07e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tZmAOZWgnAzYxWGUodbVgA.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk"><strong class="bd nb">FIG 1</strong>: SVM and Maximum-margin classifier</figcaption></figure><p id="584f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">SVM 算法的主要区别特征是<strong class="ks iu"> <em class="lq">分类器不依赖于所有的数据点</em> </strong>(不像逻辑回归，其中每个数据点的特征将用于分类器边界函数的构建)。事实上，<strong class="ks iu"> <em class="lq"> SVM 分类器依赖于数据点的一个非常小的子集，那些最靠近边界</em> </strong>的数据点以及它们在超平面中的位置会影响分类器边界线。由这些点形成的向量唯一地定义了分类器函数，并且它们'<em class="lq">支持</em>分类器，因此被命名为'支持向量机'。这个概念如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nc"><img src="../Images/7b53a04c068f724790b6cef33321e254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cxO8_UNsAdOQpanLFJLoRw.png"/></div></div></figure><p id="a0ee" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">阅读更多关于支持向量机的<a class="ae lm" href="http://web.mit.edu/6.034/wwwbob/svm.pdf" rel="noopener ugc nofollow" target="_blank">白痴指南。一个关于 SVM 的视频教程可以在这里找到。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="52a7" class="lu lv it bd lw lx ly dn lz ma mb dp mc kz md me mf ld mg mh mi lh mj mk ml mm bi translated">SVM 工作原理的几何解释:<em class="nf">凸包</em></h2><p id="e1c5" class="pw-post-body-paragraph kq kr it ks b kt mn ju kv kw mo jx ky kz mp lb lc ld mq lf lg lh mr lj lk ll im bi translated">SVM 算法背后的形式数学相当复杂，但通过考虑一种叫做<a class="ae lm" href="https://en.wikipedia.org/wiki/Convex_hull" rel="noopener ugc nofollow" target="_blank">凸包</a>的特殊几何构造，可以直观地理解它。</p><p id="16ab" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu"> <em class="lq">什么是凸包</em> </strong>？形式上，<a class="ae lm" href="https://en.wikipedia.org/wiki/Euclidean_plane" rel="noopener ugc nofollow" target="_blank">欧氏平面</a>或<a class="ae lm" href="https://en.wikipedia.org/wiki/Euclidean_space" rel="noopener ugc nofollow" target="_blank">欧氏空间</a>中的点集<em class="lq"> X </em>的<strong class="ks iu">凸包</strong>或<strong class="ks iu">凸包络</strong>或<strong class="ks iu">凸闭包</strong>是包含<strong class="ks iu"> <em class="lq"> X </em> </strong>的最小<a class="ae lm" href="https://en.wikipedia.org/wiki/Convex_set" rel="noopener ugc nofollow" target="_blank">凸集。然而，使用<em class="lq">橡皮筋类比</em>最容易形象化。想象一根橡皮筋绕着一组钉子(我们的兴趣点)的圆周伸展。如果橡皮筋被释放，它会缠绕在挂钩上，形成一个紧密的边界来定义原来的设置。最终的形状是<em class="lq">凸包</em>，并且可以通过接触橡皮筋创建的边界的钉的子集来描述。这个想法如下所示。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/b5fb09be23c8f2b495a6ee935d46bcf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ApY7IFePSaUbQnzayQ-dQA.png"/></div></div></figure><p id="df83" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，很容易想象 SVM 分类器只不过是一个线性分隔符，它将连接这些凸包的线正好在中点处一分为二。</p><blockquote class="ln lo lp"><p id="f53d" class="kq kr lq ks b kt ku ju kv kw kx jx ky lr la lb lc ls le lf lg lt li lj lk ll im bi translated">因此，确定 SVM 分类器简化为寻找一组点的凸包的问题。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ng"><img src="../Images/8ff8a8d2d07d8c7f1e91abd0fff0392f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m7QAwwbKK9lIF6FHOrpyEQ.png"/></div></div></figure><h2 id="4af3" class="lu lv it bd lw lx ly dn lz ma mb dp mc kz md me mf ld mg mh mi lh mj mk ml mm bi translated">如何确定凸包？</h2><p id="1f3b" class="pw-post-body-paragraph kq kr it ks b kt mn ju kv kw mo jx ky kz mp lb lc ld mq lf lg lh mr lj lk ll im bi translated">图片(动画的)说一千个字！因此，让我展示用于确定一组点的凸包的算法。它叫做<a class="ae lm" href="https://en.wikipedia.org/wiki/Graham_scan" rel="noopener ugc nofollow" target="_blank">格雷厄姆扫描</a>。该算法找到沿着其边界排序的凸包的所有顶点。它使用一个<a class="ae lm" href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank">堆栈</a>来有效地检测和移除边界中的凹陷。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/6c1a27c8eaf9414abdac57da44a7bc4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/1*ov0GlArRF4gTrOavfjC1UA.gif"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk"><strong class="bd nb">FIG</strong>: Graham’s scan to find convex hull.</figcaption></figure><blockquote class="ln lo lp"><p id="8e67" class="kq kr lq ks b kt ku ju kv kw kx jx ky lr la lb lc ls le lf lg lt li lj lk ll im bi translated">现在，问题是这种算法的效率如何，也就是说，格雷厄姆的扫描方法的时间复杂度是多少？</p></blockquote><p id="4e3c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">事实证明，Graham 的扫描<strong class="ks iu"> <em class="lq">的时间复杂度取决于底层排序算法</em> </strong>，它需要使用该算法来找到构成凸包的正确点集。但是排序是从什么开始的呢？ </p><p id="163b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这种扫描技术的基本思想来自凸包的两个特性，</p><ul class=""><li id="5757" class="ni nj it ks b kt ku kw kx kz nk ld nl lh nm ll nn no np nq bi translated">可以通过逆时针旋转穿过凸包</li><li id="5638" class="ni nj it ks b kt nr kw ns kz nt ld nu lh nv ll nn no np nq bi translated">凸包的顶点相对于 y 坐标最低的点 p 以极角 <br/>递增的顺序出现在<strong class="ks iu">中。</strong></li></ul><p id="6a1f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，这些点存储在一个数组<code class="fe nw nx ny nz b">points</code>中。因此，算法从定位参考点开始。这是具有最低<em class="lq"> y </em>坐标的点(如果出现平局，我们通过选择具有最低<em class="lq"> y </em>坐标和最低<em class="lq"> x </em>坐标的点来打破平局)。一旦我们定位了参考点，我们通过使它与数组中的第一个点交换位置，将该点移动到<code class="fe nw nx ny nz b">points</code>的开头。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/400d7d305c7ea0bac0a16f1e22c8ae1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*k1lPem8ubXVyCdEERAvDsw.jpeg"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk"><strong class="bd nb">FIG</strong>: A stack data structure</figcaption></figure><p id="10dc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">接下来，<strong class="ks iu"> <em class="lq">我们根据剩余点相对于参考点</em> </strong>的极角对其进行排序。排序后，相对于参考点极角最小的点将位于数组的开头，极角最大的点将位于末尾。</p><p id="445d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">正确排序这些点后，我们现在可以运行算法中的主循环。这个循环使用了第二个列表，当我们处理主数组中的点时，这个列表会增长和收缩。基本上，<strong class="ks iu">我们将逆时针旋转出现的点推到堆栈上，如果旋转变为顺时针</strong>则拒绝点(从堆栈中弹出)。第二个列表开始时是空的。在算法结束时，构成凸边界的点将出现在列表中。一个<a class="ae lm" href="https://www.tutorialspoint.com/data_structures_algorithms/stack_algorithm.htm" rel="noopener ugc nofollow" target="_blank">堆栈数据结构</a>用于此目的。</p><h2 id="1eea" class="lu lv it bd lw lx ly dn lz ma mb dp mc kz md me mf ld mg mh mi lh mj mk ml mm bi translated">伪代码</h2><pre class="kj kk kl km gt ob nz oc od aw oe bi"><span id="b6d8" class="lu lv it nz b gy of og l oh oi"># <em class="lq">Three points are a counter-clockwise turn if ccw &gt; 0, clockwise if</em><br/># <em class="lq">ccw &lt; 0, and colinear if ccw = 0 because ccw is a determinant that #gives twice the signed  area of the triangle formed by p1, p2, and #p3.</em></span><span id="0d72" class="lu lv it nz b gy oj og l oh oi"><strong class="nz iu">function</strong> ccw(p1, p2, p3):<br/>    <strong class="nz iu">return</strong> (p2.x - p1.x)*(p3.y - p1.y) - (p2.y - p1.y)*(p3.x - p1.x)</span><span id="a760" class="lu lv it nz b gy oj og l oh oi"><strong class="nz iu">let</strong> N <strong class="nz iu">be</strong> number of points<br/><strong class="nz iu">let</strong> points[N] <strong class="nz iu">be</strong> the array of points<br/><strong class="nz iu">swap</strong> points[0] with the point with the lowest y-coordinate</span><span id="c261" class="lu lv it nz b gy oj og l oh oi"><strong class="nz iu"><em class="lq"># This is the most time-consuming step</em><br/>sort</strong> points by polar angle with points[0]</span><span id="9ec5" class="lu lv it nz b gy oj og l oh oi"><strong class="nz iu">let</strong> stack = NULL<br/><strong class="nz iu">push</strong> points[0] <strong class="nz iu">to</strong> stack<br/><strong class="nz iu">push</strong> points[1] <strong class="nz iu">to</strong> stack<br/><strong class="nz iu">push</strong> points[2] <strong class="nz iu">to</strong> stack<br/><strong class="nz iu">for</strong> i = 3 <strong class="nz iu">to</strong> N:<br/>    <strong class="nz iu">while</strong> <strong class="nz iu">ccw</strong>(next_to_top(stack), top(stack), points[i]) &lt;= 0:<br/>        <strong class="nz iu">pop</strong> stack<br/>    <strong class="nz iu">push</strong> points[i] <strong class="nz iu">to</strong> stack<br/><strong class="nz iu">end</strong></span></pre><p id="2ad1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">所以，格雷厄姆扫描的时间复杂度取决于排序算法的效率。可以使用任何通用排序技术，但是使用<strong class="ks iu"><em class="lq">【o(n^2】</em></strong>和<strong class="ks iu"> <em class="lq"> O(n.log(n)) </em> </strong>算法之间有很大的区别(如下图所示)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ok"><img src="../Images/b83f45a606f193d4a42fc8c4d440c43f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6UxDYdMlnevixdo76xL8vA.gif"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk"><strong class="bd nb">FIG:</strong> Animations of various sort algorithms</figcaption></figure><h2 id="5d8f" class="lu lv it bd lw lx ly dn lz ma mb dp mc kz md me mf ld mg mh mi lh mj mk ml mm bi translated">摘要</h2><p id="39a1" class="pw-post-body-paragraph kq kr it ks b kt mn ju kv kw mo jx ky kz mp lb lc ld mq lf lg lh mr lj lk ll im bi translated">在本文中，我们展示了简单排序算法如何成为解决计算几何中一个重要问题的核心，以及它如何与广泛使用的机器学习技术相关联。尽管有许多基于离散优化的算法来解决 SVM 问题，但这种方法展示了在核心处使用基本有效的算法来构建人工智能复杂学习模型的重要性<strong class="ks iu">。</strong></p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><p id="1fc9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi os translated"><span class="l ot ou ov bm ow ox oy oz pa di">如果</span>您有任何问题或想法要分享，请联系作者在<a class="ae lm" href="mailto:tirthajyoti@gmail.com" rel="noopener ugc nofollow" target="_blank"><strong class="ks iu">tirthajyoti【AT】Gmail . com</strong></a>。此外，您可以查看作者的<a class="ae lm" href="https://github.com/tirthajyoti?tab=repositories" rel="noopener ugc nofollow" target="_blank"> <strong class="ks iu"> GitHub 资源库</strong> </a>中其他有趣的 Python、R 或 MATLAB 代码片段和机器学习资源。如果你像我一样对机器学习/数据科学充满热情，请随时<a class="ae lm" href="https://www.linkedin.com/in/tirthajyoti-sarkar-2127aa7/" rel="noopener ugc nofollow" target="_blank">在 LinkedIn 上添加我</a>或<a class="ae lm" href="https://twitter.com/tirthajyotiS" rel="noopener ugc nofollow" target="_blank">在 Twitter 上关注我。</a></p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><p id="be7b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu"> <em class="lq">关键词</em></strong>:#机器学习，#支持向量机，#算法，#人工智能，#计算几何</p></div></div>    
</body>
</html>