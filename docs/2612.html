<html>
<head>
<title>Machine Learning Tip : Using Rotational Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习提示:使用旋转数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-tip-using-rotational-data-b67ded0a33ad?source=collection_archive---------6-----------------------#2018-02-12">https://towardsdatascience.com/machine-learning-tip-using-rotational-data-b67ded0a33ad?source=collection_archive---------6-----------------------#2018-02-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/cbc65a9fc19c82db7f0f32112f333d07.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/1*RJX-vPQWRHbS-K41dAp1lw.gif"/></div></figure><p id="c330" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">可能会出现需要使用旋转数据进行预测的情况，无论是作为特征还是作为目标。将学位直接插入到你的模型中似乎可行，但是要小心，这不是你想要的。</p><h1 id="a340" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">为什么机器学习算法讨厌学位</h1><p id="b350" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated"><strong class="jw ir">简单来说，他们不顺利！</strong>我的意思是度数刻度随着它的进行从359度瞬移到0度。看:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lv"><img src="../Images/1f3e9a67ac9ace9d1637fa94ecf379cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sf3zCHh3GGKAU0XkYXE85w.png"/></div></div></figure><p id="d473" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这种格式中，梯度下降算法不知道350度与0度相距10度，因此永远不会产生鲁棒的模型。</p><h1 id="23ab" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">拯救罪恶与罪恶！</h1><p id="9045" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">为了克服这些问题，我们只需将度数转换成<strong class="jw ir"> SIN </strong>和<strong class="jw ir"> COS </strong>并使用它们作为我们的特征。现在没有传送，距离被适当地测量:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi me"><img src="../Images/3000026649df147b78ff24678601d252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P8sIZ9wo-dPAXyTXCjolyw.png"/></div></div></figure><p id="5fc3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">重要的是要记住，我们<strong class="jw ir">可以</strong>返回到我们的度数值，因为对于每组SIN和COS值，只有一个等价的度数值。在下一节中，我将向您展示神奇的<a class="ae mf" href="https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.arctan2.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> atan2 </strong> </a>函数，它将为您完成这种转换。</p><h1 id="ee20" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">抓到一个。</h1><p id="ea20" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">一个缺点是，现在如果你想预测一个方向(即方向是你的目标特征)，你必须创建两个预测器:一个预测SIN，一个预测COS，然后使用<strong class="jw ir"/><a class="ae mf" href="https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.arctan2.html" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir">atan2</strong></a>函数将它们组合起来。</p><pre class="lw lx ly lz gt mg mh mi mj aw mk bi"><span id="472a" class="ml kt iq mh b gy mm mn l mo mp">import numpy as np</span><span id="1855" class="ml kt iq mh b gy mq mn l mo mp">degrees_array = np.arctan2(sin_array, cos_array) * 180 / np.pi</span><span id="313c" class="ml kt iq mh b gy mq mn l mo mp"># will be in the range -180 : 180, <br/># use modulo to wrap it to the range 0 : 360</span><span id="6059" class="ml kt iq mh b gy mq mn l mo mp">degrees_array_fixed_range = np.mod(degrees_array, 360)</span></pre><p id="efde" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">查看使用两个预测器预测旋转值的完整示例:</p><p id="396d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae mf" href="https://github.com/ZackAkil/optimising-training-data-meetup/blob/master/CL-DS-PN%20Optimising%20data%20-%20My%20Solution.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/ZackAkil/optimizing-training-data-meetup/blob/master/CL-DS-PN % 20 optimizing % 20 data % 20-% 20 my % 20 solution . ipynb</a></p></div></div>    
</body>
</html>