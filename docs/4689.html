<html>
<head>
<title>Deploying a Machine Learning Model as a REST API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将机器学习模型部署为 REST API</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploying-a-machine-learning-model-as-a-rest-api-4a03b865c166?source=collection_archive---------0-----------------------#2018-08-31">https://towardsdatascience.com/deploying-a-machine-learning-model-as-a-rest-api-4a03b865c166?source=collection_archive---------0-----------------------#2018-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7ca4dd48eef67aadf6376c756977dbe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uezAyMqN2ZynYoWs9uDXvQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Artwork by <a class="ae kc" href="https://dribbble.com/igorkozak" rel="noopener ugc nofollow" target="_blank">Igor Kozak</a></figcaption></figure><p id="fd26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一名 Python 开发人员和数据科学家，我渴望构建 web 应用程序来展示我的工作。尽管我喜欢设计前端，但同时学习机器学习和应用程序开发变得非常困难。因此，我必须找到一种解决方案，能够轻松地将我的机器学习模型与其他开发人员集成，这些开发人员能够比我更好地构建一个健壮的 web 应用程序。</p><p id="539f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过为我的模型构建 REST API，我可以将我的代码与其他开发人员分开。这里有明确的分工，这有利于定义责任，并防止我直接阻止不参与项目机器学习方面的队友。另一个优点是，我的模型可以被在不同平台上工作的多个开发人员使用，比如 web 或 mobile。</p><p id="0e99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我将构建一个简单的 Scikit-Learn 模型，并使用<a class="ae kc" href="https://flask-restful.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Flask RESTful </a>将其部署为 REST API。本文特别面向没有广泛计算机科学背景的数据科学家。</p><h1 id="43a3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">关于模型</h1><p id="c520" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对于这个例子，我组装了一个简单的<a class="ae kc" href="http://scikit-learn.org/stable/modules/generated/sklearn.naive_bayes.MultinomialNB.html" rel="noopener ugc nofollow" target="_blank">朴素贝叶斯分类器</a>来预测电影评论中短语的情感。</p><p id="dd00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据来自 Kaggle 竞赛，<a class="ae kc" href="https://www.kaggle.com/c/sentiment-analysis-on-movie-reviews/data" rel="noopener ugc nofollow" target="_blank">影评情感分析</a>。评论被分成单独的句子，句子被进一步分成单独的短语。所有的短语都有一个情感分数，这样就可以训练一个模型，根据这个模型，哪些词可以给一个句子带来积极的、中性的或消极的情感。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/e8a2889a9cc869c8d10403047f9cc6f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B8cNQmkEfK7Z673yEaQCGw.png"/></div></div></figure><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/9dc05b49ad89611007269731f1381c3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YEpENxFu6kzElHTYNr8QqA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Distribution of ratings from the Kaggle dataset</figcaption></figure><p id="9041" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数短语的评级都是中性的。首先，我尝试使用多项式朴素贝叶斯分类器来预测 5 个可能类别中的一个。但是，因为大多数数据的等级为 2，所以该模型的表现不是很好。我决定保持简单，因为这个练习的要点主要是关于作为 REST API 进行部署。因此，我将数据限制在极端类别，并训练模型仅预测消极或积极的情绪。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/88dfede9e34dc625d632cfea93dec79c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*fVJHg1UBeiCSmibp9TTNkw.png"/></div></figure><p id="2044" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果证明，多项式朴素贝叶斯模型在预测积极和消极情绪方面非常有效。你可以在这个<a class="ae kc" href="https://nbviewer.jupyter.org/github/mnguyenngo/flask-rest-setup/blob/master/notebooks/sentiment_clf.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter 笔记本演练</a>中找到模型训练过程的快速概述。在 Jupyter 笔记本中训练完模型后，我将代码转移到 Python 脚本中，并为 NLP 模型创建了一个类对象。你可以在这个<a class="ae kc" href="https://github.com/mnguyenngo/flask-rest-setup/tree/master/sentiment-clf" rel="noopener ugc nofollow" target="_blank">链接</a>找到我的 Github repo 中的代码。您还需要<a class="ae kc" href="https://docs.python.org/3/library/pickle.html" rel="noopener ugc nofollow" target="_blank"> pickle </a>或保存您的模型，以便您可以快速地将训练好的模型加载到您的 API 脚本中。</p><p id="b52a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了模型，让我们将它部署为一个 REST API。</p><h1 id="9b21" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">REST API 指南</h1><p id="89ed" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为 API 的 Flask 应用程序启动一个新的 Python 脚本。</p><h2 id="660e" class="ml lc iq bd ld mm mn dn lh mo mp dp ll ko mq mr lp ks ms mt lt kw mu mv lx mw bi translated">导入库并加载 Pickles</h2><p id="03f6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">下面的代码块包含许多 Flask 样板文件和加载分类器和矢量器 pickles 的代码。</p><pre class="mf mg mh mi gt mx my mz na aw nb bi"><span id="b0bb" class="ml lc iq my b gy nc nd l ne nf">from flask import Flask<br/>from flask_restful import reqparse, abort, Api, Resource<br/>import pickle<br/>import numpy as np<br/>from model import NLPModel</span><span id="02c5" class="ml lc iq my b gy ng nd l ne nf">app = Flask(__name__)<br/>api = Api(app)</span><span id="d6c2" class="ml lc iq my b gy ng nd l ne nf"># create new model object<br/>model = NLPModel()</span><span id="5f28" class="ml lc iq my b gy ng nd l ne nf"># load trained classifier<br/>clf_path = 'lib/models/SentimentClassifier.pkl'<br/>with open(clf_path, 'rb') as f:<br/>    model.clf = pickle.load(f)</span><span id="f45a" class="ml lc iq my b gy ng nd l ne nf"># load trained vectorizer<br/>vec_path = 'lib/models/TFIDFVectorizer.pkl'<br/>with open(vec_path, 'rb') as f:<br/>    model.vectorizer = pickle.load(f)</span></pre><h2 id="8cde" class="ml lc iq bd ld mm mn dn lh mo mp dp ll ko mq mr lp ks ms mt lt kw mu mv lx mw bi translated">创建参数解析器</h2><p id="c5bd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">解析器将检查用户发送给 API 的参数。参数将位于 Python 字典或 JSON 对象中。对于这个例子，我们将特别寻找一个名为<code class="fe nh ni nj my b">query</code>的键。查询将是一个短语，用户将希望我们的模型预测该短语是积极的还是消极的。</p><pre class="mf mg mh mi gt mx my mz na aw nb bi"><span id="967c" class="ml lc iq my b gy nc nd l ne nf"># argument parsing<br/>parser = reqparse.RequestParser()<br/>parser.add_argument('query')</span></pre><h2 id="900b" class="ml lc iq bd ld mm mn dn lh mo mp dp ll ko mq mr lp ks ms mt lt kw mu mv lx mw bi translated">资源类对象</h2><p id="3ae1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">资源是 Flask RESTful APIs 的主要构件。每个类都可以有对应于 HTTP 方法的方法，比如:<code class="fe nh ni nj my b">GET</code>、<code class="fe nh ni nj my b">PUT</code>、<code class="fe nh ni nj my b">POST</code>和<code class="fe nh ni nj my b">DELETE</code>。<code class="fe nh ni nj my b">GET</code>将是主要方法，因为我们的目标是服务于预测。在下面的<code class="fe nh ni nj my b">get</code>方法中，我们提供了如何处理用户查询以及如何打包将返回给用户的 JSON 对象的指导。</p><pre class="mf mg mh mi gt mx my mz na aw nb bi"><span id="d86e" class="ml lc iq my b gy nc nd l ne nf">class PredictSentiment(Resource):<br/>    def get(self):<br/>        # use parser and find the user's query<br/>        args = parser.parse_args()<br/>        user_query = args['query']</span><span id="3518" class="ml lc iq my b gy ng nd l ne nf">        # vectorize the user's query and make a prediction<br/>        uq_vectorized = model.vectorizer_transform(<br/>            np.array([user_query]))<br/>        prediction = model.predict(uq_vectorized)<br/>        pred_proba = model.predict_proba(uq_vectorized)</span><span id="30ef" class="ml lc iq my b gy ng nd l ne nf">        # Output 'Negative' or 'Positive' along with the score<br/>        if prediction == 0:<br/>            pred_text = 'Negative'<br/>        else:<br/>            pred_text = 'Positive'<br/>            <br/>        # round the predict proba value and set to new variable<br/>        confidence = round(pred_proba[0], 3)</span><span id="3282" class="ml lc iq my b gy ng nd l ne nf">        # create JSON object<br/>        output = {'prediction': pred_text, 'confidence': confidence}<br/>        <br/>        return output</span></pre><p id="dce9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一个很棒的教程是由<a class="ae kc" href="https://flask-restful.readthedocs.io/en/latest/quickstart.html#resourceful-routing" rel="noopener ugc nofollow" target="_blank"> Flask-RESTful </a>提供的，他们在其中构建了一个待办事项应用程序，并演示了如何使用<code class="fe nh ni nj my b">PUT</code>、<code class="fe nh ni nj my b">POST</code>和<code class="fe nh ni nj my b">DELETE</code>方法。</p><h2 id="9f78" class="ml lc iq bd ld mm mn dn lh mo mp dp ll ko mq mr lp ks ms mt lt kw mu mv lx mw bi translated">端点</h2><p id="ccc4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">以下代码将设置情绪预测器资源的基本 url。您可以想象您可能有多个端点，每个端点都指向一个不同的模型，该模型将做出不同的预测。一个例子可以是端点<code class="fe nh ni nj my b">'/ratings'</code>，它将用户引导到另一个模型，该模型可以预测给定类型、预算和制作成员的电影评级。您需要为第二个模型创建另一个资源对象。这些可以一个接一个地添加，如下所示。</p><pre class="mf mg mh mi gt mx my mz na aw nb bi"><span id="7e05" class="ml lc iq my b gy nc nd l ne nf">api.add_resource(PredictSentiment, '/')<br/>  <br/># example of another endpoint<br/>api.add_resource(PredictRatings, '/ratings')</span></pre><h2 id="6894" class="ml lc iq bd ld mm mn dn lh mo mp dp ll ko mq mr lp ks ms mt lt kw mu mv lx mw bi translated">Name ==主块</h2><p id="81e3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这里不多说了。如果要将此 API 部署到生产环境中，请将 debug 设置为 False。</p><pre class="mf mg mh mi gt mx my mz na aw nb bi"><span id="e305" class="ml lc iq my b gy nc nd l ne nf">if __name__ == '__main__':<br/>    app.run(debug=True)</span></pre><h2 id="3c42" class="ml lc iq bd ld mm mn dn lh mo mp dp ll ko mq mr lp ks ms mt lt kw mu mv lx mw bi translated">用户请求</h2><p id="3976" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">下面是一些用户如何访问你的 API 的例子，这样他们就可以得到预测。</p><p id="2ead" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Jupyter 笔记本中的请求模块:</p><pre class="mf mg mh mi gt mx my mz na aw nb bi"><span id="2e0c" class="ml lc iq my b gy nc nd l ne nf">url = '<a class="ae kc" href="http://127.0.0.1:5000/'" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:5000/'</a><br/>params ={'query': 'that movie was boring'}<br/>response = requests.get(url, params)<br/>response.json()</span><span id="ba37" class="ml lc iq my b gy ng nd l ne nf">Output: {'confidence': 0.128, 'prediction': 'Negative'}</span></pre><p id="09a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在终端中使用 curl:</p><pre class="mf mg mh mi gt mx my mz na aw nb bi"><span id="930b" class="ml lc iq my b gy nc nd l ne nf">$ curl -X GET <a class="ae kc" href="http://127.0.0.1:5000/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:5000/</a> -d query='that movie was boring'<br/>{<br/>    "prediction": "Negative",<br/>    "confidence": 0.128<br/>}</span></pre><p id="2052" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在终端中使用 HTTPie:</p><pre class="mf mg mh mi gt mx my mz na aw nb bi"><span id="39e6" class="ml lc iq my b gy nc nd l ne nf">$ http <a class="ae kc" href="http://127.0.0.1:5000/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:5000/</a> query=='that movie was boring'</span><span id="6e55" class="ml lc iq my b gy ng nd l ne nf">HTTP/1.0 200 OK<br/>Content-Length: 58<br/>Content-Type: application/json<br/>Date: Fri, 31 Aug 2018 18:49:25 GMT<br/>Server: Werkzeug/0.14.1 Python/3.6.3</span><span id="cc43" class="ml lc iq my b gy ng nd l ne nf">{<br/>    "confidence": 0.128,<br/>    "prediction": "Negative"<br/>}</span></pre><p id="dd30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我的队友只需向这个 API 发出请求，就可以将情绪预测添加到他们的应用程序中，而无需将 Python 和 JavaScript 混合在一起。</p><h2 id="38de" class="ml lc iq bd ld mm mn dn lh mo mp dp ll ko mq mr lp ks ms mt lt kw mu mv lx mw bi translated">完整的<code class="fe nh ni nj my b">app.py</code>代码</h2><p id="c4dd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有时在一个地方看到所有代码会很有帮助。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="8bfa" class="ml lc iq bd ld mm mn dn lh mo mp dp ll ko mq mr lp ks ms mt lt kw mu mv lx mw bi translated">文件结构</h2><p id="aa65" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我想包括的最后一件事是这个简单 API 的文件结构的概述。</p><pre class="mf mg mh mi gt mx my mz na aw nb bi"><span id="12c0" class="ml lc iq my b gy nc nd l ne nf">sentiment-clf/<br/>├── README.md<br/>├── app.py  <strong class="my ir"># Flask REST API script</strong><br/>├── build_model.py  <strong class="my ir"># script to build and pickle the classifier</strong><br/>├── model.py  <strong class="my ir"># script for the classifier class object</strong><br/>├── util.py  <strong class="my ir"># helper functions</strong><br/>├── requirements.txt<br/>└── lib/<br/>    ├── data/  <strong class="my ir"># data from Kaggle</strong><br/>    │   ├── sampleSubmission.csv<br/>    │   ├── test.tsv<br/>    │   └── train.tsv<br/>    └── models/  <strong class="my ir"># pickled models for import into API script</strong><br/>        ├── SentimentClassifier.pkl<br/>        └── TFIDFVectorizer.pkl</span></pre><h2 id="26a3" class="ml lc iq bd ld mm mn dn lh mo mp dp ll ko mq mr lp ks ms mt lt kw mu mv lx mw bi translated">部署</h2><p id="9b93" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">一旦你建立了你的模型和 REST API，并完成了本地测试，你就可以像部署 Flask 应用程序一样部署你的 API 到网络上的许多主机服务上。通过部署在 web 上，任何地方的用户都可以向您的 URL 发出请求以获得预测。<a class="ae kc" href="http://flask.pocoo.org/docs/1.0/deploying/" rel="noopener ugc nofollow" target="_blank">部署指南</a>包含在烧瓶文档中。</p><h1 id="fc8b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">关闭</h1><p id="81f8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这只是为情感分类器构建 Flask REST API 的一个非常简单的例子。同样的过程可以应用于其他机器学习或深度学习模型，只要你训练并保存了它们。</p><p id="d58b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了将模型部署为 REST API 之外，我还使用 REST API 来管理我从 web 上收集的数据的数据库查询。这让我可以与全栈开发人员合作，而不必管理他们的 React 应用程序的代码。如果一个移动开发者想要开发一个应用，那么他们只需要熟悉 API 端点。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="2336" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你有任何反馈或批评，请随时与我分享。如果本演练对您有所帮助，请喜欢👏文章。干杯！🍻</p></div></div>    
</body>
</html>