<html>
<head>
<title>Introduction to PyTorch Model Compression Through Teacher-Student Knowledge Distillation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过师生知识蒸馏介绍 PyTorch 模型压缩</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/model-distillation-and-compression-for-recommender-systems-in-pytorch-5d81c0f2c0ec?source=collection_archive---------11-----------------------#2018-11-09">https://towardsdatascience.com/model-distillation-and-compression-for-recommender-systems-in-pytorch-5d81c0f2c0ec?source=collection_archive---------11-----------------------#2018-11-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7f51" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过知识蒸馏的模型压缩可以节省推理时间、功率效率和模型大小。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/870977212717ead97059a0b5ce43dca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Okajwbc32B7LatxrZIggpg.jpeg"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Knowledge River Delta</figcaption></figure><p id="c41f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在资源受限的移动和实时系统中服务 ML 模型可能是一个真正的问题。ML 社区一直在开发解决方案来压缩由较大的服务器集群生成的模型的大小。模型压缩承诺节省推理时间、功率效率和模型大小。所有这些都可以让飞行救援无人机在一次充电后覆盖更多的土地表面，同时不会耗尽移动应用用户的电池。</p><blockquote class="ln"><p id="595b" class="lo lp iq bd lq lr ls lt lu lv lw lm dk translated"><strong class="ak">模型知识提炼是一种在不损失太多预测能力的情况下减少模型规模的方法</strong>。</p></blockquote><p id="cec5" class="pw-post-body-paragraph kr ks iq kt b ku lx jr kw kx ly ju kz la lz lc ld le ma lg lh li mb lk ll lm ij bi translated">Geoffrey Hinton 在 2018 年<a class="ae mc" href="https://www.re-work.co/events/deep-learning-summit-toronto-canada-2018/schedule#" rel="noopener ugc nofollow" target="_blank">深度学习峰会</a>上关于使用<a class="ae mc" href="https://arxiv.org/abs/1503.02531" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">【知识蒸馏】</strong> </a> <strong class="kt ir"> </strong> (KD)的演讲让我去寻找另一类问题的当前技术状态:推荐系统(RecSys)。</p><p id="02b6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这让我想到了唐嘉熙在 2018 年 KDD 发表的关于<a class="ae mc" href="https://arxiv.org/abs/1809.07428" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">排名蒸馏</strong> </a> <strong class="kt ir"> </strong> (RD)的优秀作品，他在其中讨论了他将知识蒸馏应用于排名任务的相关方法。</p><p id="a621" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这篇博客中，我在<a class="ae mc" href="https://grouplens.org/datasets/movielens/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> Movielens 100K 数据集</strong> </a>上复制了这个排名提炼工作的一小部分。在这方面工作是一种领悟。即使 KD 是一个从一个模型到一个小模型提取知识的坚实的概念框架，将它应用于推荐系统的排序任务也不是一个简单的任务。</p><p id="3946" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">第一个挑战</strong>是我们在一个比常见的 fit/predict API 更低的抽象层次上工作，这些 API 存在于 Scikit-learn 和 Keras 等更高层次的库中。这是因为实现这个 KD 所需的改变是在<strong class="kt ir">损失函数公式</strong>本身。为了解决这个问题，我跟随第三篇论文的脚步，使用优雅的 PyTorch API 在 RecSys 中构建这个 KD。</p><p id="8574" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二个挑战是，即使 PyTorch 是一个优雅的库，我们也需要一个更高层次的框架，专门研究带有 PyTorch 的 RecSys。这些天的选择框架似乎是来自库拉的<a class="ae mc" href="https://github.com/maciejkula/spotlight" rel="noopener ugc nofollow" target="_blank">聚焦。我强烈推荐它，API 设计易于使用，它让用户自定义我们这个实验需要的大多数方面。</a></p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="4b93" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们走吧！</p><h1 id="dcf0" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">定制分级蒸馏反向传播流</h1><p id="8eb4" class="pw-post-body-paragraph kr ks iq kt b ku nc jr kw kx nd ju kz la ne lc ld le nf lg lh li ng lk ll lm ij bi translated">目标是从 Movielens 100K 数据集生成 3 个模型:学生模型、带蒸馏的学生模型和教师模型，并比较它们的 MAP@K 指标以及物理磁盘大小。</p><p id="f41e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要解释我们将要使用的策略，从教师模型到学生模型，用蒸馏来教授一些<strong class="kt ir">黑暗知识</strong>。以下是对培训过程中将要发生的事情的解释:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nh"><img src="../Images/c5352691f9bd596c96e98f7ff2635263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OwC6-X86paX80dleQxQvTQ.jpeg"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Flow of data and forward/backward propagation during the knowledge distillation method</figcaption></figure><p id="8dea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上图中，我们展示了培训流程:</p><ul class=""><li id="ed06" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated">对于学生模型，我们使用传统的方法，使用带有数据标签和单个排名损失的训练数据。</li><li id="344f" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">对于教师模型，我们与学生模型类似地对其进行预训练，但我们使用更大的网络规模来实现更高的 K (MAP@K)平均精度。在完成较大模型的训练之后，我们存储预先训练的教师模型。</li><li id="937d" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">对于带有蒸馏的学生模型，我们使用带有标签和排名损失的训练数据。然而，在这个例子中，我们使用了教师模型对我们提供给学生模型的数据的预测。更准确地说，除了学生的损失之外，我们还使用教师的损失来计算和反向传播学生模型网络中的梯度。这些额外的信息应该可以提高学生模型的预测能力，同时保持模型大小与没有经过提取的学生模型相同。</li></ul></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="0d78" class="mk ml iq bd mm mn oa mp mq mr ob mt mu jw oc jx mw jz od ka my kc oe kd na nb bi translated">结果比较</h1><p id="0c8f" class="pw-post-body-paragraph kr ks iq kt b ku nc jr kw kx nd ju kz la ne lc ld le nf lg lh li ng lk ll lm ij bi translated">首先，我们需要一些培训数据，我们用这些数据来建立一个预培训教师模型。我们使用 movielens 100K 数据集，并且只使用电影/用户交互。我们将尝试预测用户最有可能评价的前 5 部电影。</p><p id="124f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为此，我们将使用 Spotlight 库提供的<strong class="kt ir">implicit factorization model</strong>。该模型使用基于<strong class="kt ir">嵌入的</strong>模型结构:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/687870e0e83327fe5c7c84bc579e65ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*0TOjCieI6WbOwcpt9r1VRw.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Implicit Factorization Model with a Bi-Linear model structure</figcaption></figure><p id="7891" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于损失，我们使用类似于下面负对数似然函数的方法。我们对正对和负对进行采样，并要求优化器提高正对中的排序项目(d+)并减少负对中的项目(d-):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi og"><img src="../Images/c41e8af2081029b881db729e64e2c4cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a0jbWvZSHmxslCDOS_lYHA.png"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Loss function related to the negative logarithmic of the likelihood function.</figcaption></figure><p id="a81f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<strong class="kt ir"> 200 </strong>作为 movielens 数据集上每个嵌入层的大小来训练“大型”教学模型，这为我们提供了以下指标:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="ab90" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们用一个小得多的模型做同样的尝试，用<strong class="kt ir"> 2 </strong>作为每个嵌入层的大小:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="611e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 2 次观察:</strong></p><ul class=""><li id="04d2" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated">第一，学生模型本身序列化后的大小更小(0.10 mb vs 6.34)。这与网络的大小一致，因为嵌入的大小要小 100 倍。</li><li id="0d4d" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">第三，学生模型的 MAP@5 低于教师模型(0.050 vs 0.073)。较小的网络可以远离较大的网络。挑战是:<strong class="kt ir">我们能在保持模型尺寸不变的情况下做得更好吗？</strong></li></ul><p id="94c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我们接下来要尝试的。我们培训第三个模型，这是一个学生模型，由预先培训的教师模型推动。</p><p id="92aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为此，我们需要在损失函数中混合从两个模型中获得的两个损失。这就是 PyTorch 闪耀的地方。我们所要做的就是定义一个修正的损失函数，它总结了学生和老师的损失，让梯度下降发挥它的魔力。其核心是，如果您对使用对数 sigmoid 损失的正负损失有所了解，我们通过教师网络传递当前一批数据，获得候选预测，并使用它们来生成教师损失值。我们用于优化的最终损失是 pos/neg/teacher 这三个损失的总和。下面是组合损失函数的一个片段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="3856" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们表现如何？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="80f0" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated">首先，提取模型的 MAP@5 值更接近教师模型的值，仅使用 2 作为嵌入层的大小(0.070 比 0.073)</li><li id="e6bf" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">第二，大小仍然是 0.10mb，类似于非蒸馏的学生模型。</li></ul><p id="7c7c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里有一个表格，列出了所有这些值以供比较</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h2 id="c191" class="oj ml iq bd mm ok ol dn mq om on dp mu la oo op mw le oq or my li os ot na ou bi translated">我们从这次冒险中学到了什么？</h2><ul class=""><li id="5cc5" class="nm nn iq kt b ku nc kx nd la ov le ow li ox lm nr ns nt nu bi translated">我很高兴看到 PyTorch 能够灵活地复制 KDD2018 论文的一小部分。</li><li id="026d" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">知识蒸馏真的很酷，也为推荐系统工作。</li><li id="4137" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">总的来说，每当两个或更多的人工智能模型之间有互动时，我对它们的结果非常感兴趣。</li></ul><p id="5307" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您对这种类型的跨模型交互感兴趣，我邀请您深入研究 KDD2018 论文。我们没有讨论如何通过加权教师的模型损失或仅考虑教师模型的 top-k 建议来改进这种设置。大概是以后的帖子吧。</p><p id="e817" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">直到那时！</p><p id="6d27" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">谢了。</p><h1 id="b078" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">参考资料:</h1><p id="b669" class="pw-post-body-paragraph kr ks iq kt b ku nc jr kw kx nd ju kz la ne lc ld le nf lg lh li ng lk ll lm ij bi translated">唐佳夕，还有王柯。排名提取:为推荐系统学习高性能的紧凑排名模型。<em class="oy">第 24 届 ACM SIGKDD 知识发现国际会议论文集&amp;数据挖掘</em>。ACM，2018。</p><p id="a53f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">辛顿·杰弗里、奥里奥尔·维尼亚尔斯和杰夫·迪恩。<strong class="kt ir">在神经网络中提取知识。</strong><em class="oy">arXiv 预印本 arXiv:1503.02531 </em> (2015)。</p><p id="27e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2017 年【https://github.com/maciejkula/spotlight】库拉<strong class="kt ir">聚光灯</strong>T2</p><p id="d3a5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2018 年<strong class="kt ir"> PyTorch </strong>，<a class="ae mc" href="https://pytorch.org/" rel="noopener ugc nofollow" target="_blank">https://pytorch.org/</a></p></div></div>    
</body>
</html>