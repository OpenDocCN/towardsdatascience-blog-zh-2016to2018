<html>
<head>
<title>Deploy a machine learning model using flask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 flask 部署机器学习模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploy-a-machine-learning-model-using-flask-da580f84e60c?source=collection_archive---------1-----------------------#2018-11-30">https://towardsdatascience.com/deploy-a-machine-learning-model-using-flask-da580f84e60c?source=collection_archive---------1-----------------------#2018-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6fa0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为机器学习的初学者，对于任何人来说，获得关于机器学习和深度学习的所有算法的足够资源可能都很容易，但是当我开始寻找将 ML 模型部署到生产的参考资料时，我没有找到任何可以帮助我部署我的模型的好资源，因为我对这个领域非常陌生。因此，当我成功地使用 Flask 作为 API 部署我的模型时，我决定写一篇文章来帮助其他人简单地部署他们的模型。希望有帮助:)</p><p id="31ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将使用简单的线性回归算法和 scikit-learn。为了简单起见，我们将使用 Flask，因为它是一个非常轻量级的 web 框架。我们将创建三个文件，</p><ol class=""><li id="70a9" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><em class="ku"> model.py </em></li><li id="89a5" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><em class="ku"> server.py </em></li><li id="5c0f" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><em class="ku"> request.py </em></li></ol><p id="c016" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在一个<em class="ku"> model.py </em>文件中，我们将开发并训练我们的模型，在一个<em class="ku"> server.py 中，</em>我们将编码处理 POST 请求并返回结果，最后在<em class="ku"> request.py </em>中，我们将向服务器发送带有特性的请求并接收结果。</p><h1 id="20ed" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">让我们开始编码部分</h1><ol class=""><li id="a70b" class="kl km iq jp b jq ly ju lz jy ma kc mb kg mc kk kq kr ks kt bi translated"><strong class="jp ir"> model.py </strong></li></ol><p id="7541" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我上面提到的，在这个文件中我们将开发我们的 ML 模型并训练它。我们将根据员工在该领域的经验来预测他/她的工资。你可以在这里找到数据集<a class="ae md" href="https://github.com/vyashemang/flask-salary-predictor/blob/master/Salary_Data.csv" rel="noopener ugc nofollow" target="_blank"/>。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="70fd" class="mn lb iq mj b gy mo mp l mq mr">import numpy as np<br/>import pandas as pd<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.linear_model import LinearRegression<br/>import pickle<br/>import requests<br/>import json</span></pre><p id="657b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导入我们将用来开发模型的库。<em class="ku"> numpy </em>和<em class="ku"> pandas </em>分别操作矩阵和数据，<em class="ku">sk learn . model _ selection</em>将数据拆分为训练集和测试集，<em class="ku"> sklearn.linear_model </em>使用<em class="ku"> LinearRegression </em>训练我们的模型。<em class="ku"> pickle </em>将我们训练好的模型保存到磁盘，<em class="ku">请求</em>向服务器发送请求，<em class="ku"> json </em>在我们的终端打印结果。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="64f7" class="mn lb iq mj b gy mo mp l mq mr">dataset = pd.read_csv('Salary_Data.csv')<br/>X = dataset.iloc[:, :-1].values<br/>y = dataset.iloc[:, 1].values</span></pre><p id="4e18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经使用 pandas 导入了数据集，并将要素和标注从数据集中分离出来。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b8b4" class="mn lb iq mj b gy mo mp l mq mr">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.33, random_state = 0)</span></pre><p id="5796" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本节中，我们使用来自<em class="ku"> sklearn 的<em class="ku"> train_test_split </em>将我们的数据分为训练和测试大小分别为 0.67 和 0.33。</em></p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ebfe" class="mn lb iq mj b gy mo mp l mq mr">regressor = LinearRegression()<br/>regressor.fit(X_train, y_train)</span><span id="6a9f" class="mn lb iq mj b gy ms mp l mq mr">y_pred = regressor.predict(X_test)</span></pre><p id="9402" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该对象被实例化为类<em class="ku"> LinearRegression() </em>的<em class="ku">回归变量</em>，并使用<em class="ku"> X_train </em>和<em class="ku"> y_train 进行训练。</em>后者预测结果存储在<em class="ku"> y_pred 中。</em></p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="61c7" class="mn lb iq mj b gy mo mp l mq mr">pickle.dump(regressor, open('model.pkl','wb'))</span></pre><p id="2a6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用<em class="ku"> pickle </em>库将训练好的模型保存到磁盘上。<em class="ku"> Pickle </em>用于序列化和反序列化 Python 对象结构。其中 python 对象被转换成字节流。<em class="ku"> dump() </em>方法将对象转储到参数中指定的文件中。</p><p id="22f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，我们希望保存我们的模型，以便服务器可以使用它。因此，我们将把我们的对象<em class="ku">回归器</em>保存到名为<em class="ku"> model.pkl. </em>的文件中</p><p id="8009" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过下面的方法再次加载模型，</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b2aa" class="mn lb iq mj b gy mo mp l mq mr">model = pickle.load(open('model.pkl','rb'))<br/>print(model.predict([[1.8]]))</span></pre><p id="0f78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ku"> pickle.load() </em>方法加载方法并将反序列化后的字节保存到<em class="ku">模型。</em>可以使用<em class="ku"> model.predict()进行预测。</em></p><p id="d100" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，我们可以预测有 1.8 年工作经验的雇员的工资。</p><p id="148f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们的<em class="ku"> model.py </em>准备训练并保存模型。<em class="ku"> model.py </em>的完整代码如下。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e3d8" class="mn lb iq mj b gy mo mp l mq mr"># Importing the libraries<br/>import numpy as np<br/>import pandas as pd<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.linear_model import LinearRegression<br/>import pickle<br/>import requests<br/>import json</span><span id="b04b" class="mn lb iq mj b gy ms mp l mq mr"># Importing the dataset<br/>dataset = pd.read_csv('Salary_Data.csv')<br/>X = dataset.iloc[:, :-1].values<br/>y = dataset.iloc[:, 1].values</span><span id="ce39" class="mn lb iq mj b gy ms mp l mq mr"># Splitting the dataset into the Training set and Test set<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 1/3, random_state = 0)</span><span id="4095" class="mn lb iq mj b gy ms mp l mq mr"># Fitting Simple Linear Regression to the Training set<br/>regressor = LinearRegression()<br/>regressor.fit(X_train, y_train)</span><span id="3d6d" class="mn lb iq mj b gy ms mp l mq mr"># Predicting the Test set results<br/>y_pred = regressor.predict(X_test)</span><span id="adf6" class="mn lb iq mj b gy ms mp l mq mr"># Saving model to disk<br/>pickle.dump(regressor, open('model.pkl','wb'))</span><span id="37ad" class="mn lb iq mj b gy ms mp l mq mr"># Loading model to compare the results<br/>model = pickle.load(open('model.pkl','rb'))<br/>print(model.predict([[1.8]]))</span></pre><p id="1b63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2。server.py </strong></p><p id="83d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个文件中，我们将使用 flask web 框架来处理从<em class="ku"> request.py </em>获得的 POST 请求。</p><p id="e11d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导入我们将在代码中使用的方法和库。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="47d8" class="mn lb iq mj b gy mo mp l mq mr">import numpy as np<br/>from flask import Flask, request, jsonify<br/>import pickle</span></pre><p id="4edd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们导入了<em class="ku"> numpy </em>来创建请求数据的数组，<em class="ku"> pickle </em>来加载我们训练好的模型进行预测。</p><p id="e25c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的代码中，我们创建了<em class="ku"> Flask() </em>的实例，并将模型加载到<em class="ku">模型中。</em></p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4910" class="mn lb iq mj b gy mo mp l mq mr">app = Flask(__name__)</span><span id="af49" class="mn lb iq mj b gy ms mp l mq mr">model = pickle.load(open('model.pkl','rb'))</span></pre><p id="32c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，我们用方法<em class="ku"> predict()绑定了<em class="ku"> /api </em>。</em>其中 predict 方法从请求者传递的 json 中获取数据。<em class="ku"> model.predict() </em>方法从 json 获取输入，并将其转换为 2D <em class="ku"> numpy 数组</em>结果存储在名为<em class="ku">的变量中，输出</em>和<em class="ku"> </em>我们在使用 flaks<em class="ku">json ify()</em>方法将其转换为 JSON 对象后返回此变量。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d9b2" class="mn lb iq mj b gy mo mp l mq mr"><a class="ae md" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/api',methods=['POST'])<br/>def predict():<br/>    data = request.get_json(force=True)<br/>    prediction = model.predict([[np.array(data['exp'])]])<br/>    output = prediction[0]<br/>    return jsonify(output)</span></pre><p id="7011" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们将通过下面的代码运行我们的服务器。这里我使用了端口 5000，并设置了<em class="ku"> debug=True </em>，因为如果我们遇到任何错误，我们可以调试并解决它。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="65ab" class="mn lb iq mj b gy mo mp l mq mr">if __name__ == '__main__':<br/>    app.run(port=5000, debug=True)</span></pre><p id="ecef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们的服务器已经准备好为请求提供服务。下面是<em class="ku"> server.py. </em>的完整代码</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0442" class="mn lb iq mj b gy mo mp l mq mr"># Import libraries<br/>import numpy as np<br/>from flask import Flask, request, jsonify<br/>import pickle</span><span id="201e" class="mn lb iq mj b gy ms mp l mq mr">app = Flask(__name__)</span><span id="07bb" class="mn lb iq mj b gy ms mp l mq mr"># Load the model<br/>model = pickle.load(open('model.pkl','rb'))</span><span id="3ef8" class="mn lb iq mj b gy ms mp l mq mr">@app.route('/api',methods=['POST'])<br/>def predict():<br/>    # Get the data from the POST request.<br/>    data = request.get_json(force=True)</span><span id="e0e8" class="mn lb iq mj b gy ms mp l mq mr">    # Make prediction using model loaded from disk as per the data.<br/>    prediction = model.predict([[np.array(data['exp'])]])</span><span id="0ba9" class="mn lb iq mj b gy ms mp l mq mr">    # Take the first value of prediction<br/>    output = prediction[0]</span><span id="b65f" class="mn lb iq mj b gy ms mp l mq mr">    return jsonify(output)</span><span id="58c3" class="mn lb iq mj b gy ms mp l mq mr">if __name__ == '__main__':<br/>    app.run(port=5000, debug=True)</span></pre><p id="8ead" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.<em class="ku"> request.py </em></p><p id="2696" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我前面提到的,<em class="ku"> request.py </em>将向服务器请求预测。</p><p id="3c72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是向服务器发出请求的完整代码。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f2f3" class="mn lb iq mj b gy mo mp l mq mr">import requests</span><span id="644c" class="mn lb iq mj b gy ms mp l mq mr">url = '<a class="ae md" href="http://localhost:5000/api'" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/api'</a></span><span id="7c35" class="mn lb iq mj b gy ms mp l mq mr">r = requests.post(url,json={'exp':1.8,})<br/>print(r.json())</span></pre><p id="5e4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经使用<em class="ku">请求</em>库来发出 post 请求。<em class="ku"> requests.post() </em>获取 URL 和 post 请求中要传递的数据，从服务器返回的结果存储到变量<em class="ku"> r </em>中，并由<em class="ku"> r.json()打印。</em></p><h2 id="ea97" class="mn lb iq bd lc mt mu dn lg mv mw dp lk jy mx my lo kc mz na ls kg nb nc lw nd bi translated"><strong class="ak">结论</strong></h2><p id="10d0" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">我们创建了三个文件<em class="ku"> model.py、server.py 和 request.py </em>来训练和保存模型，处理请求，分别向服务器发出请求。</p><p id="a9a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在对所有这些文件进行编码之后，执行文件的顺序应该是<em class="ku"> model.py </em>、<em class="ku"> server.py </em>(在单独的终端中)以及最后<em class="ku"> request.py </em>。</p><p id="926c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以将预测的结果与一个<em class="ku"> model.py </em>进行比较，因为我们将结果打印在文件的末尾。</p><p id="2a63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在我的 Github 库<a class="ae md" href="https://github.com/vyashemang/flask-salary-predictor/" rel="noopener ugc nofollow" target="_blank"> flask-salary-predictor </a>中找到所有的代码。</p><p id="7107" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要犹豫，在下面的评论区说出你的想法。</p><p id="db60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谢谢:)</p></div></div>    
</body>
</html>