<html>
<head>
<title>Prototyping a Recommendation System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">推荐系统原型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/prototyping-a-recommendation-system-8e4dd4a50675?source=collection_archive---------2-----------------------#2017-06-17">https://towardsdatascience.com/prototyping-a-recommendation-system-8e4dd4a50675?source=collection_archive---------2-----------------------#2017-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8887" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">R、Java、Scala和SQL的Hello World</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/6dd75d6d379e393db29546b8ca55cc25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*h6K2R6IIuh6IkjNx_Cb1jw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Amazon.com recommendations for “Mahout in Action”</figcaption></figure><p id="dd62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Twitch有许多由推荐系统驱动的产品，包括VOD推荐、剪辑推荐和类似的频道。在<a class="ae ky" href="https://blog.twitch.tv/productizing-data-science-at-twitch-67a643fd8c44" rel="noopener ugc nofollow" target="_blank">将Twitch的一个推荐系统产品化</a>之前，科学团队首先制作了一个推荐系统的原型，看看输出结果对我们的一个产品是否有用。建立推荐原型的成本可能很低，这篇文章提供了用四种不同的编程语言构建推荐系统的例子。</p><p id="58af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个例子都使用不同的库来构建一个使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Collaborative_filtering" rel="noopener ugc nofollow" target="_blank">协同过滤</a>的推荐系统原型。本文介绍了Amazon.com使用的协作过滤方法，而<a class="ae ky" href="https://www.amazon.com/Mahout-Action-Sean-Owen/dp/1935182684" rel="noopener ugc nofollow" target="_blank"> Mahout in Action </a>则很好地概述了推荐系统中使用的不同算法和相似性度量。我还在EverQuest Landmark的市场上的GDC演讲中提供了推荐系统的概述。除了使用交替最小二乘法(ALS)的Scala示例之外，以下所有示例都使用了基于用户的协同过滤。</p><p id="7186" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些示例加载一个数据集，然后为ID为101的用户推荐五个商品。在这些例子中使用的合成数据集是用户购买游戏的集合，其中每一行包括用户ID和游戏ID。所有示例的示例数据集和源代码可在<a class="ae ky" href="https://github.com/bgweber/Twitch/tree/master/Recommendations" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><p id="db13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果R是你选择的编程语言，那么<a class="ae ky" href="https://cran.r-project.org/web/packages/recommenderlab/vignettes/recommenderlab.pdf" rel="noopener ugc nofollow" target="_blank"> recommenderlab </a>软件包可以让你很容易地构建不同的推荐系统。该软件包在CRAN存储库中可用，可以使用标准的<em class="kl"> install.packages </em>函数进行安装。加载后，该包提供了一个<em class="kl">推荐器</em>函数，它将数据矩阵和推荐方法作为输入。在这个脚本中，数据矩阵是从一个CSV文件中加载的，使用的方法是基于用户的协同过滤。然后使用<em class="kl">预测</em>函数为用户101检索五个项目。</p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="73a4" class="le lf iq la b gy lg lh l li lj">install.packages("recommenderlab")<br/>library(recommenderlab)</span><span id="5dcb" class="le lf iq la b gy lk lh l li lj">matrix &lt;- as(read.csv("Games.csv"),"realRatingMatrix")<br/>model &lt;-Recommender(matrix, method = "UBCF")<br/>games &lt;- predict(model, matrix["101",], n=5)<br/>as(games, "list")</span></pre><p id="c3c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">Java:Apache Mahout<br/></strong>Mahout是一个用Java实现的机器学习库，提供了多种协同过滤算法。Mahout用一个<em class="kl"> UserNeighborhood </em>类实现了基于用户的协作过滤，这个类指定了用户需要有多相似才能提供商品推荐的反馈。此示例使用Tanimoto相似性度量来查找用户之间的相似性，该度量计算共享游戏的数量(交集)与玩家拥有的游戏总数(联合)的比率。这个CSV文件被用作数据模型的输入，该数据模型然后被传递给推荐器对象。一旦推荐对象被实例化，就可以使用<em class="kl">推荐</em>方法为特定用户创建游戏推荐列表。</p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="7305" class="le lf iq la b gy lg lh l li lj">import org.apache.mahout.cf.taste.*;</span><span id="c737" class="le lf iq la b gy lk lh l li lj">DataModel model = new FileDataModel(new File("Games.csv"));</span><span id="14f3" class="le lf iq la b gy lk lh l li lj">UserSimilarity similarity = new<br/>  TanimotoCoefficientSimilarity(model);<br/>UserNeighborhood neighborhood = <br/>  new ThresholdUserNeighborhood(0.1, similarity, model);<br/>UserBasedRecommender recommender = <br/>  new GenericUserBasedRecommender(model, neighborhood, similarity);</span><span id="8793" class="le lf iq la b gy lk lh l li lj">List recommendations = recommender.recommend(101, 5);<br/>System.out.println(recommendations);</span></pre><p id="f49f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Apache Spark是构建推荐系统越来越流行的工具之一，它提供了一个名为MLlib的内置库，其中包括一组机器学习算法。该示例首先运行一个查询来检索UserID、GameID元组格式的游戏购买，然后将数据框转换为ALS模型可以使用的评级集合。本例中使用了隐式数据反馈，这就是为什么使用了<em class="kl"> trainImplicit </em>方法而不是<em class="kl"> train </em>方法。训练方法的输入参数是游戏评级、要使用的潜在特征的数量、为矩阵分解执行的迭代次数、用于正则化的λ参数以及指定如何测量隐式评级的alpha参数。一旦模型被训练好，就可以使用<em class="kl">推荐产品</em>方法为用户检索推荐的游戏列表。</p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="6c9a" class="le lf iq la b gy lg lh l li lj">import org.apache.spark.mllib.recommendation._</span><span id="db35" class="le lf iq la b gy lk lh l li lj">val games = sqlContext.read<br/>    .format("com.databricks.spark.csv")<br/>    .option("header", "false")  <br/>    .option("inferSchema", "true")  <br/>    .load("/Users/bgweber/spark/Games.csv")</span><span id="7fb5" class="le lf iq la b gy lk lh l li lj">val ratings = games.rdd.map(row =&gt;<br/>  Rating(row.getInt(0), row.getInt(1), 1)<br/>)</span><span id="c42e" class="le lf iq la b gy lk lh l li lj">val rank = 10<br/>val model = ALS.trainImplicit(ratings, rank, 5, 0.01, 1)<br/>val recommendations = model.recommendProducts(101, 5)<br/>recommendations.foreach(println)</span></pre><p id="191f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在将数据提取到运行Spark或R的机器上太慢或太贵的情况下，您可以使用SQL来构建一个推荐系统的原型。这种方法使用起来可能计算量很大，但是对于抽查一些结果是有用的。下面的例子使用Spark SQL，因为我想让这个例子对于所提供的数据集是可重复的。代码的第一部分从CSV文件加载表，并将加载的数据框注册为临时表。示例的第二部分包括SQL CTAs，它准备数据，然后为单个用户的游戏评分。内部查询通过查找重叠游戏的比率除以购买的游戏总数来计算用户之间的Tanimoto系数，外部查询返回每个检索到的游戏的总分数。</p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="fbdc" class="le lf iq la b gy lg lh l li lj">val games = sqlContext.read<br/>    .format("com.databricks.spark.csv")<br/>    .option("header", "false")  <br/>    .option("inferSchema", "true")  <br/>    .load("/Users/bgweber/spark/Games.csv")<br/>    <br/>games.registerTempTable("games")</span><span id="e54a" class="le lf iq la b gy lk lh l li lj">val result = sqlContext.sql("""<br/>with users as (<br/>    select _c0 as User_ID, sum(1) as NumGames <br/>    from games <br/>    group by 1 <br/>)<br/>, purchases as (<br/>    select _c0 as User_ID, _c1 as Game_ID, NumGames <br/>    from games g<br/>    join users u<br/>      on g._c0 = u.User_ID<br/>)<br/>select u.User_ID, v.Game_ID, sum(Tanimoto) as GameWeight<br/>from ( <br/>    select u.User_ID, v.User_ID as Other_User_ID,<br/>        count(u.Game_ID)/(u.NumGames + v.NumGames - count(u.Game_ID)) as Tanimoto<br/>    from purchases u<br/>    Join purchases v<br/>        on u.Game_ID = v.Game_ID <br/>    where u.User_ID = 101<br/>    group by u.User_ID, v.User_ID, u.NumGames, v.NumGames<br/>) u<br/>Join purchases v<br/>    on Other_User_ID = v.User_ID<br/>group by u.User_ID, v.Game_ID<br/>order by GameWeight desc<br/>""")</span><span id="f355" class="le lf iq la b gy lk lh l li lj">result.show(5)</span></pre><p id="650f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">评估<br/> </strong>这些脚本提供了如何为特定用户检索游戏建议的示例。评估推荐器质量的一种方法是使用定性方法，其中为一小组用户手动检查推荐器的输出。另一种方法是使用不同库中包含的内置评估指标。例如，recommenderlab和MLlib提供了用于计算ROC曲线的函数，这些曲线可用于评估不同的系统配置。在评估推荐者时，将推荐系统的性能与其他手工制作的方法进行比较也是一种很好的做法，例如畅销书排行榜。</p></div></div>    
</body>
</html>