<html>
<head>
<title>Collaborative Filtering based Recommendation Systems exemplified..</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于协同过滤的推荐系统举例..</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/collaborative-filtering-based-recommendation-systems-exemplified-ecbffe1c20b1?source=collection_archive---------1-----------------------#2018-03-06">https://towardsdatascience.com/collaborative-filtering-based-recommendation-systems-exemplified-ecbffe1c20b1?source=collection_archive---------1-----------------------#2018-03-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/564e3613ed29e1d9f2a1a275f0ef410b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wFbMH-4-Kn9I03IcKNTs8A.jpeg"/></div></div></figure><div class=""/><p id="4f2d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的上一篇文章中，我对推荐系统做了简单的解释，举例说明了各种类型的推荐系统。在这篇文章中，我将使用<strong class="ka jc"> Python </strong>实现一些这类推荐系统的简单例子。</p><p id="401b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">给定下面的用户项目评级矩阵M，其中6个用户(行)对6个项目(列)进行了评级。评级可以取1-10之间的整数值，0表示没有评级。(注意，我们对行和列使用Python中使用的从零开始的索引。但是，对于用户输入，user_id将占用1–6之间的数字，item_id将占用1–6之间的数字。假设，我们必须发现用户3是否会喜欢项目4。因此，用户3成为我们的目标用户或活动用户，项目4是目标项目。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div class="gh gi kw"><img src="../Images/a2aecc9326e0e5e267744fe53e7ec689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*lhYsKfOtkGTV_GSuknIg7Q.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">sample user-ratings matrix</figcaption></figure><h1 id="62b4" class="lf lg jb bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">基于用户的协同过滤</h1><p id="2d69" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">首先，我们必须预测用户3对项目4的评分。在基于用户的CF中，我们会找到与用户3最相似的k=3个用户。常用的相似性度量有余弦、皮尔逊、欧几里德等。这里我们将使用<a class="ae mi" href="https://en.wikipedia.org/wiki/Cosine_similarity" rel="noopener ugc nofollow" target="_blank">余弦相似度</a>，其定义如下:</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/1c1743a7cdbf0557d02b786dd15e623d.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*FjjcEChVVgb8fvUCVUL2mQ.png"/></div></figure><p id="82fa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和，<a class="ae mi" href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient" rel="noopener ugc nofollow" target="_blank">皮尔逊相关</a>，定义为:</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/78a59d4908a87d0f47309f4926b7e879.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*qCdw27XS0Q9shX4-0pJ96w.png"/></div></figure><p id="9e24" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在sklearn中，<a class="ae mi" href="http://scikit-learn.org/stable/modules/generated/sklearn.neighbors.NearestNeighbors.html#sklearn.neighbors.NearestNeighbors" rel="noopener ugc nofollow" target="_blank"> NearestNeighbors </a>方法可以用来基于各种相似性度量来搜索k个最近邻居。</p><p id="4c45" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">查看我的<strong class="ka jc"> Jupyter笔记本下面嵌入的</strong>，</p><div class="ip iq gp gr ir ml"><a href="https://github.com/csaluja/JupyterNotebooks-Medium/blob/master/CF%20Recommendation%20System-Examples.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd jc gy z fp mq fr fs mr fu fw ja bi translated">csaluja/JupyterNotebooks-中号</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">在GitHub上创建一个帐户，为JupyterNotebooks-Medium开发做出贡献。</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">github.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz ix ml"/></div></div></a></div><p id="8f3d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"><em class="na">findksimilarrusers</em></strong><em class="na"/>函数使用此方法返回活动用户的k近邻的相似度和索引。函数<strong class="ka jc"><em class="na">predict _ user based</em></strong><em class="na"/>使用基于用户的CF方法进一步预测用户3将给予项目4的评级。预测计算为邻居平均值偏差的加权平均值，并将其添加到活跃用户的平均评级中。偏差用于调整与用户相关的偏差。由于某些用户可能总是倾向于给所有项目高或低的评级，所以会出现用户偏差。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nb"><img src="../Images/a79a216ff437a477ef2cd1d73d864ba1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*MdEImGMBgGY_5xltOJJAQA.png"/></div></div></figure><p id="39b8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中p(a，I)是项目I的目标或活动用户a的预测，w(a，u)是用户a和u之间的相似性，K是最相似用户的邻域。</p><h1 id="c3be" class="lf lg jb bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">基于项目的协同过滤</h1><p id="1e13" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">在这种方法中，使用余弦相似性度量来计算项目对之间的相似性。活跃用户<em class="na"> a </em>的目标项目<em class="na"> i </em>的评分可以通过使用简单加权平均来预测，如下所示:</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/aea0cd0dae8bd663b0b1dc8862e61c17.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*4LhLv-MRP29aHESuaWwMAA.png"/></div></figure><p id="8f00" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中K是活动用户a评价的最相似项目的邻域，w(i，j)是项目<em class="na"> i </em>和<em class="na">j</em>之间的相似度</p><p id="a1f7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Jupyter Notebook embed中检查，函数<strong class="ka jc"><em class="na">findksimilaritems</em></strong><em class="na"/>使用利用余弦相似度的<a class="ae mi" href="http://scikit-learn.org/stable/modules/generated/sklearn.neighbors.NearestNeighbors.html#sklearn.neighbors.NearestNeighbors" rel="noopener ugc nofollow" target="_blank">最近邻居</a>方法来查找与项目<em class="na"> i. </em>相似的k个项目，函数<strong class="ka jc"><em class="na">predict _ item based</em></strong><em class="na"/>使用基于项目的CF方法(上面的公式)进一步预测用户3将给予项目4的评分。</p><h1 id="60cc" class="lf lg jb bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><a class="ae mi" href="http://www10.org/cdrom/papers/519/node14.html" rel="noopener ugc nofollow" target="_blank">调整后的余弦相似度</a></h1><p id="fe2f" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">将余弦相似性度量用于基于项目的CF方法不考虑用户评级的差异。调整后的余弦相似性通过从每个共同评级对中减去相应用户的平均评级来弥补这一缺陷，并且定义如下</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/d65e746970567c771603203a32858217.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*P-JTYdDjXGwpgnUMCu2YKw.png"/></div></figure><p id="55b5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了在Python中实现调整后的余弦相似度，我定义了一个名为<em class="na"> computeAdjCosSim，</em>的简单函数，该函数返回调整后的余弦相似度矩阵，给定评级矩阵。函数<strong class="ka jc"><em class="na">findksimilaritems _ adj cos</em></strong>和<strong class="ka jc"><em class="na">predict _ item based _ adj cos</em></strong>利用调整后的余弦相似度来寻找k个相似项目并计算预测评分。</p><p id="2716" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">功能<strong class="ka jc"><em class="na">re commenditem</em></strong>提示用户选择推荐方式(基于用户(余弦)、基于用户(相关)、基于项目(余弦)、基于项目(调整余弦)。基于所选择的方法和相似性度量，该功能预测指定用户和项目的评级，并且还建议是否可以向用户推荐该项目。如果用户尚未对该项目进行评级，并且如果预测评级大于6，则向用户推荐该项目。如果评级小于6，则不向用户推荐该项目。</p><h1 id="c708" class="lf lg jb bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">相似性度量的选择</h1><p id="e17a" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">在选择相似性度量时，一些有用的线索是</p><p id="547c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您的数据受到用户偏差/不同用户评级尺度的影响时，请使用Pearson</p><p id="a570" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果数据稀疏(许多评级未定义)，请使用余弦</p><p id="807e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您的数据不稀疏并且属性值的数量很大，请使用欧几里得</p><p id="c8df" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对基于项目的方法使用调整余弦来调整用户偏差</p><h1 id="9910" class="lf lg jb bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">推荐系统的评价</h1><p id="2937" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">评价推荐系统的评价指标有很多。然而，最流行和最常用的是RMSE(均方根误差)。函数<strong class="ka jc"> <em class="na">评估者</em> </strong>使用sklearn的<a class="ae mi" href="http://scikit-learn.org/stable/modules/generated/sklearn.metrics.mean_squared_error.html" rel="noopener ugc nofollow" target="_blank">均方误差</a>函数计算预测额定值和实际额定值之间的RMSE，并显示所选进近的RMSE值。(为了解释简单，使用了小数据集，因此没有将其分成训练集和测试集；本帖也不考虑交叉验证)。</p><p id="17bd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在用户基数很大的应用程序中，基于用户的方法面临可伸缩性问题，因为它们的复杂性随着用户数量的增加而线性增长。基于项目的方法解决了这些可伸缩性问题，根据项目相似性推荐项目。混合技术利用了各种此类方法的优势，并以多种方式将它们结合起来以实现更好的性能。</p><p id="3ad8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="na">感谢阅读。这篇文章是为了分享我对推荐系统的理解，欢迎任何关于改进这个实现的反馈。</em></p></div></div>    
</body>
</html>