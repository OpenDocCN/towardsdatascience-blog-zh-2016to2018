<html>
<head>
<title>Python for Finance: Stock Portfolio Analyses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">金融Python:股票投资组合分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-for-finance-stock-portfolio-analyses-6da4c3e61054?source=collection_archive---------0-----------------------#2018-04-16">https://towardsdatascience.com/python-for-finance-stock-portfolio-analyses-6da4c3e61054?source=collection_archive---------0-----------------------#2018-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f761b7b5da4d8a9e999cd8dec0162b8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IJTyPDhuCfNRAl_J.jpg"/></div></div></figure><p id="f481" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我最近的两篇博文是关于用Python扩展分析洞察力的；第一部分可以在这里找到<a class="ae kw" href="https://kdboller.github.io/2017/07/09/scaling-analytical-insights-with-python.html" rel="noopener ugc nofollow" target="_blank">，第二部分可以在</a><a class="ae kw" href="https://kdboller.github.io/2017/10/11/scaling-analytical-insights-with-python_part2.html" rel="noopener ugc nofollow" target="_blank">这里找到</a>。我写这些已经有几个月了，主要是因为去年11月我把家搬到了西雅图，加入了亚马逊；我花了大部分时间在我的主要项目上，确定我们的全球推广计划和相关的商业智能路线图。</p><p id="7d0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我离开我以前的公司FloSports之前，我们正在对整个组织的分析报告进行彻底检查(数据、营销、产品等)，这次彻底检查的一部分包括我们的财务报告。虽然我很早就离开了这个实现，但在过去的几个月里，我继续广泛使用Python进行财务分析，尤其是<code class="fe kx ky kz la b">pandas</code>。在这篇文章中，我将分享我如何利用一些非常有用的在线资源，<code class="fe kx ky kz la b">Yahoo Finance API</code>(需要一个解决方案，可能需要未来的数据源替换)，以及<code class="fe kx ky kz la b">Jupyter notebook</code>来在很大程度上自动跟踪和衡量股票投资组合的表现。</p><h1 id="2bd1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">PME和基准个股表现概述</h1><p id="cac3" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">作为一个快速的背景，我从2002年开始投资我自己的股票投资组合，并在几年前为我的投资组合开发了一个金融模型。多年来，我会下载历史价格并将数据加载到金融模型中——虽然在线经纪人计算已实现和未实现的回报，以及收入和股息，但我喜欢在模型中拥有历史数据，因为我自己进行分析来评估头寸。我从未在在线经纪人和服务中发现的一个观点/报告是类似于<a class="ae kw" href="https://en.wikipedia.org/wiki/Public_Market_Equivalent" rel="noopener ugc nofollow" target="_blank">“公共市场等价物”</a>的分析。简而言之，公开市场等价物(PME)是私募股权行业中使用的一组分析，用于比较私募股权基金相对于行业基准的表现。更多细节<a class="ae kw" href="http://docs.preqin.com/reports/Preqin-Special-Report-PME-July-2015.pdf" rel="noopener ugc nofollow" target="_blank">在这里。</a></p><p id="5af0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与此相关，绝大多数股票投资组合经理无法选择长期表现优于大盘(如标准普尔500)的股票投资组合(20只积极管理的国内基金中有1只跑赢指数基金)。即使一些个股表现出色，其他股票的表现不佳也往往超过表现更好的股票，这意味着总体而言，投资者的情况比单纯投资指数基金更糟。在商学院期间，我了解了PME，并把一个概念上类似的分析纳入了对我目前持有的公共股票的评估。为了正确地做到这一点，你应该衡量每个投资组合头寸(持有期)相对于相同持有期内标准普尔500等值美元投资的投资流入时间。举例来说，如果你在2016年6月1日购买了一只股票，并且你仍然持有它，你会想要比较这只股票在这一时期的回报率与2016年6月1日同等美元投资在标准普尔500指数中的回报率(我们的基准例子)。除此之外，你可能会发现，即使一只股票表现相对较好，它仍可能落后于同期标准普尔500指数的回报。</p><p id="9b89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">过去，我从雅虎财经(Yahoo Finance)下载历史价格数据，并在excel中使用指数和匹配功能来计算每个头寸相对于标准普尔500的相对持有期表现。虽然这是实现这一目标的好方法，但在Jupyter notebook中使用<code class="fe kx ky kz la b">pandas</code>进行同样的操作更具可伸缩性和可扩展性。每当您下载新数据并加载到excel中时，您不可避免地需要修改一些公式并验证错误。使用<code class="fe kx ky kz la b">pandas</code>，添加新的计算，比如累积ROI倍数(我将介绍)，几乎不需要时间就可以实现。我使用<code class="fe kx ky kz la b">Plotly</code>的视觉化效果是高度可重复的，在产生洞察力方面更有用。</p><p id="6d58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">披露:</strong> <em class="me">本帖无任何内容应视为投资建议。过去的表现不一定代表未来的回报。这些是关于如何使用pandas导入不同时间间隔的小样本股票数据，并根据某个指数衡量其个别表现的一般示例。你应该向你的财务顾问提出所有与投资相关的问题。</em></p><p id="5a2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了贡献本教程之外，我还将继续修改和构建这种方法，并在本文的最后概述了进一步开发的一些考虑因素。我相信这篇文章会对初级到中级的面向数据科学的金融专业人士有所帮助，特别是因为这应该扩展到许多其他类型的金融分析。这种方法是“类似PME”的，因为它在相等的持有期内测量投资流入。由于公开市场投资比私募股权投资更具流动性，并且假设你遵循跟踪止损方法，在我看来，更重要的是专注于积极持股——通常可取的做法是减持表现低于基准的股票，或者出于各种原因你不再想持有的股票，而我采取长期观点，只要他们拥有我，我就很高兴持有表现出色的股票。</p><p id="bc16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">资源:</p><ul class=""><li id="58c3" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">我目前是DataCamp的订户(未来的帖子将在DataCamp上发布)，这个关于Python金融的社区教程非常棒<a class="ae kw" href="https://www.datacamp.com/community/tutorials/finance-python-trading" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="6aad" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">我为这篇文章创建了<a class="ae kw" href="https://github.com/kdboller/pythonsp500" rel="noopener ugc nofollow" target="_blank">回购，包括Python笔记本</a><a class="ae kw" href="https://github.com/kdboller/pythonsp500/blob/master/Investment%20Portfolio%20Python%20Notebook_03_2018_blog%20example.ipynb" rel="noopener ugc nofollow" target="_blank">和excel文件</a>。</li><li id="905c" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">如果你想看完整的互动版(因为Jupyter  &gt; GitHub集成太牛逼了)，可以在这里用nbviewer <a class="ae kw" href="http://nbviewer.jupyter.org/github/kdboller/pythonsp500/blob/b45eb79daf15d3c3032a8f398c207c9d2721ac19/Investment%20Portfolio%20Python%20Notebook_03_2018_blog%20example.ipynb" rel="noopener ugc nofollow" target="_blank">查看。</a></li></ul><p id="335c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们想要实现的目标概述:</p><ul class=""><li id="4286" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">使用Yahoo Finance API导入标准普尔500和样本股票数据</li><li id="33c6" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">创建一个合并的投资组合“主”文件，该文件将样本投资组合数据框架与历史股票行情和历史标准普尔500数据相结合</li><li id="33a4" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">确定每笔投资收购日的标准普尔500收盘价，这样我们就可以用同样的投资金额计算标准普尔500的等价股票头寸</li><li id="fe05" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">计算这段时间内投资组合头寸相对于标准普尔500回报的相对百分比和美元价值回报</li><li id="b843" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">计算累积投资组合回报和投资回报率倍数，以评估该示例投资组合与市场指数相比的表现</li><li id="8ec1" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">更重要的一点是:动态计算每个头寸相对于跟踪止损的表现，例如，如果一个头寸收盘时比收盘高点低25%，考虑在下一个交易日卖出该头寸。</li><li id="e637" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">形象化</li><li id="cbe4" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">总回报比较——每个头寸相对于指数基准的回报百分比</li><li id="7094" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">一段时间内的累积回报——每个头寸相对于基准的收益/(损失)</li><li id="ab8f" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">一段时间内的累计投资——鉴于上述情况，与同等权重和时间周期的标准普尔500投资相比，总体投资回报如何？</li><li id="d31f" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">最高价比较的调整收盘百分比——自买入以来，每个头寸相对于其调整收盘最高价的最近收盘百分比是多少？</li></ul><h1 id="5635" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">投资组合Python笔记本</h1><h1 id="9da3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数据导入和数据框操作</h1><p id="4a99" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">您将从导入必要的Python库开始，导入<code class="fe kx ky kz la b">Plotly</code>离线模块，并读入我们的样例组合数据框架。</p><pre class="mt mu mv mw gt mx la my mz aw na bi"><span id="9b3c" class="nb lc iq la b gy nc nd l ne nf"><em class="me"># Import initial libraries</em></span><span id="8f6c" class="nb lc iq la b gy ng nd l ne nf">import pandas <strong class="la ir">as</strong> pd<br/>import numpy <strong class="la ir">as</strong> np<br/>import datetime<br/>import matplotlib.pyplot <strong class="la ir">as</strong> plt<br/>import plotly.graph_objs <strong class="la ir">as</strong> go<br/><strong class="la ir">%</strong>matplotlib inline</span><span id="7b0b" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># Imports in order to be able to use Plotly offline.</em><br/>from plotly import __version__<br/>from plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot</span><span id="d9fe" class="nb lc iq la b gy ng nd l ne nf"><strong class="la ir">print</strong>(__version__) <em class="me"># requires version &gt;= 1.9.0</em></span><span id="f6a2" class="nb lc iq la b gy ng nd l ne nf">init_notebook_mode(connected<strong class="la ir">=</strong>True)</span><span id="a152" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># Import the Sample worksheet with acquisition dates and initial cost basis:</em></span><span id="f34c" class="nb lc iq la b gy ng nd l ne nf">portfolio_df <strong class="la ir">=</strong> pd<strong class="la ir">.</strong>read_excel('Sample stocks acquisition dates_costs.xlsx', sheetname<strong class="la ir">=</strong>'Sample')</span><span id="6056" class="nb lc iq la b gy ng nd l ne nf">portfolio_df<strong class="la ir">.</strong>head(10)</span></pre><p id="fe2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您已经阅读了样本投资组合文件，您将创建几个变量来捕获标准普尔500和所有投资组合报价机的日期范围。请注意，这是该笔记本要求每周更新的少数几个方面之一(调整日期范围，以包括最近的交易周，在这里，我们正在运行截至2018年3月9日的价格)。</p><pre class="mt mu mv mw gt mx la my mz aw na bi"><span id="0893" class="nb lc iq la b gy nc nd l ne nf"><em class="me"># Date Ranges for SP 500 and for all tickers</em><br/><em class="me"># Modify these date ranges each week.</em></span><span id="df75" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># The below will pull back stock prices from the start date until end date specified.</em><br/>start_sp <strong class="la ir">=</strong> datetime<strong class="la ir">.</strong>datetime(2013, 1, 1)<br/>end_sp <strong class="la ir">=</strong> datetime<strong class="la ir">.</strong>datetime(2018, 3, 9)</span><span id="af2b" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># This variable is used for YTD performance.</em><br/>end_of_last_year <strong class="la ir">=</strong> datetime<strong class="la ir">.</strong>datetime(2017, 12, 29)</span><span id="279a" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># These are separate if for some reason want different date range than SP.</em><br/>stocks_start <strong class="la ir">=</strong> datetime<strong class="la ir">.</strong>datetime(2013, 1, 1)<br/>stocks_end <strong class="la ir">=</strong> datetime<strong class="la ir">.</strong>datetime(2018, 3, 9)</span></pre><p id="af80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如Python金融培训帖子中提到的,<code class="fe kx ky kz la b">pandas-datareader</code>包使我们能够从像Google、Yahoo！金融与世界银行。这里我将重点介绍雅虎！金融，尽管我已经和Quantopian初步合作过，并且也已经开始把<code class="fe kx ky kz la b">quandl</code>作为一个数据源。正如DataCamp帖子中提到的，Yahoo API端点最近发生了变化，这需要安装一个临时修复程序，以便Yahoo！金融到工作。我在下面的代码中做了一些必要的小调整。我注意到一些小的数据问题，数据并不总是如预期的那样读入，或者最后一个交易日有时会丢失。虽然这些问题相对较少，但我会继续关注雅虎！金融将是未来最好、最可靠的数据来源。</p><pre class="mt mu mv mw gt mx la my mz aw na bi"><span id="369e" class="nb lc iq la b gy nc nd l ne nf"><em class="me"># Leveraged from the helpful Datacamp Python Finance trading blog post.</em></span><span id="fab8" class="nb lc iq la b gy ng nd l ne nf">from pandas_datareader import data <strong class="la ir">as</strong> pdr<br/>import fix_yahoo_finance <strong class="la ir">as</strong> yf<br/>yf<strong class="la ir">.</strong>pdr_override() <em class="me"># &lt;== that's all it takes :-)</em></span><span id="b6a2" class="nb lc iq la b gy ng nd l ne nf">sp500 <strong class="la ir">=</strong> pdr<strong class="la ir">.</strong>get_data_yahoo('^GSPC', <br/>                           start_sp,<br/>                             end_sp)<br/>    <br/>sp500<strong class="la ir">.</strong>head()</span></pre><p id="caa3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你用你自己的笔记本在跟踪，一旦你成功地从雅虎的API中读取数据，你应该会看到类似下面的内容:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/987a38fdbb96e5744a1643abd3cfa712.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sqivw2J_oYn1jArV.png"/></div></div></figure><p id="0da7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在加载标准普尔500数据后，您将看到我检查了数据帧的头部和尾部，并压缩数据帧，使其只包含<code class="fe kx ky kz la b">Adj Close</code>列。<code class="fe kx ky kz la b">Adjusted Close</code>栏和<code class="fe kx ky kz la b">Close</code>栏的不同之处在于，调整后的收盘反映了股息(参见下面的未来发展领域)。当一家公司派发股息时，股价会因每股股息的大小而下跌，因为该公司正在分配公司收益的一部分。为了这个分析的目的，您只需要分析这个列。我还创建了一个数据框架，其中只包括标准普尔在2017年最后一天(2018年初)调整后的收盘价；这是为了对单个股票相对于标准普尔500指数的表现进行年初至今的比较。</p><p id="1e96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下面的代码中，您在我们的投资组合样本数据框架中创建了一个所有报价机的数组。然后，您编写一个函数，将所有报价机及其相关数据读入一个新的数据框架，这与您对S&amp;P500采取的方法基本相同，但适用于投资组合的所有报价机。</p><pre class="mt mu mv mw gt mx la my mz aw na bi"><span id="c2d9" class="nb lc iq la b gy nc nd l ne nf"><em class="me"># Generate a dynamic list of tickers to pull from Yahoo Finance API based on the imported file with tickers.</em><br/>tickers <strong class="la ir">=</strong> portfolio_df['Ticker']<strong class="la ir">.</strong>unique()<br/>tickers</span><span id="1c68" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># Stock comparison code</em></span><span id="b19d" class="nb lc iq la b gy ng nd l ne nf"><strong class="la ir">def</strong> <strong class="la ir">get</strong>(tickers, startdate, enddate):<br/>    <strong class="la ir">def</strong> <strong class="la ir">data</strong>(ticker):<br/>        <strong class="la ir">return</strong> (pdr<strong class="la ir">.</strong>get_data_yahoo(ticker, start<strong class="la ir">=</strong>startdate, end<strong class="la ir">=</strong>enddate))<br/>    datas <strong class="la ir">=</strong> map(data, tickers)<br/>    <strong class="la ir">return</strong>(pd<strong class="la ir">.</strong>concat(datas, keys<strong class="la ir">=</strong>tickers, names<strong class="la ir">=</strong>['Ticker', 'Date']))<br/>               <br/>all_data <strong class="la ir">=</strong> get(tickers, stocks_start, stocks_end)</span></pre><p id="854f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与标准普尔500数据框架一样，您将创建一个<code class="fe kx ky kz la b">adj_close</code>数据框架，其中只有用于您所有股票报价机的<code class="fe kx ky kz la b">Adj Close</code>列。如果你看看我上面链接的repo中的笔记本，这段代码被分成了比下面更多的代码块。为了在这里进行描述，我在下面列出了导致我们最初的<code class="fe kx ky kz la b">merged_portfolio</code>数据帧的所有代码。</p><pre class="mt mu mv mw gt mx la my mz aw na bi"><span id="5a8f" class="nb lc iq la b gy nc nd l ne nf"><em class="me"># Also only pulling the ticker, date and adj. close columns for our tickers.</em></span><span id="6360" class="nb lc iq la b gy ng nd l ne nf">adj_close <strong class="la ir">=</strong> all_data[['Adj Close']]<strong class="la ir">.</strong>reset_index()<br/>adj_close<strong class="la ir">.</strong>head()</span><span id="c793" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># Grabbing the ticker close from the end of last year</em><br/>adj_close_start <strong class="la ir">=</strong> adj_close[adj_close['Date']<strong class="la ir">==</strong>end_of_last_year]<br/>adj_close_start<strong class="la ir">.</strong>head()</span><span id="92bd" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># Grab the latest stock close price</em></span><span id="9442" class="nb lc iq la b gy ng nd l ne nf">adj_close_latest <strong class="la ir">=</strong> adj_close[adj_close['Date']<strong class="la ir">==</strong>stocks_end]<br/>adj_close_latest</span><span id="c73b" class="nb lc iq la b gy ng nd l ne nf">adj_close_latest<strong class="la ir">.</strong>set_index('Ticker', inplace<strong class="la ir">=</strong>True)<br/>adj_close_latest<strong class="la ir">.</strong>head()</span><span id="b700" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># Set portfolio index prior to merging with the adj close latest.</em><br/>portfolio_df<strong class="la ir">.</strong>set_index(['Ticker'], inplace<strong class="la ir">=</strong>True)</span><span id="bbc0" class="nb lc iq la b gy ng nd l ne nf">portfolio_df<strong class="la ir">.</strong>head()</span><span id="8066" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># Merge the portfolio dataframe with the adj close dataframe; they are being joined by their indexes.</em></span><span id="2b4d" class="nb lc iq la b gy ng nd l ne nf">merged_portfolio <strong class="la ir">=</strong> pd<strong class="la ir">.</strong>merge(portfolio_df, adj_close_latest, left_index<strong class="la ir">=</strong>True, right_index<strong class="la ir">=</strong>True)<br/>merged_portfolio<strong class="la ir">.</strong>head()</span><span id="1da9" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># The below creates a new column which is the ticker return; takes the latest adjusted close for each position</em><br/><em class="me"># and divides that by the initial share cost.</em></span><span id="38bc" class="nb lc iq la b gy ng nd l ne nf">merged_portfolio['ticker return'] <strong class="la ir">=</strong> merged_portfolio['Adj Close'] <strong class="la ir">/</strong> merged_portfolio['Unit Cost'] <strong class="la ir">-</strong> 1</span><span id="2a6a" class="nb lc iq la b gy ng nd l ne nf">merged_portfolio</span></pre><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/0955f08d7da9eb14f935f562cceea910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6hN6vy6ShMISGiNf.png"/></div></div></figure><p id="70df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据你对<code class="fe kx ky kz la b">pandas</code>的熟悉程度，这将会非常简单，甚至有点让人不知所措。下面，我将解开这些行是做什么的:</p><ul class=""><li id="937b" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">你所采取的整体方法是一个<a class="ae kw" href="http://www.jstatsoft.org/v40/i01/paper" rel="noopener ugc nofollow" target="_blank">分割-应用-组合</a>的例子(注意这下载了一个PDF)。</li><li id="5bfa" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated"><code class="fe kx ky kz la b">all_data[['Adj Close']]</code>行创建一个新的dataframe，只包含列表中提供的列；这里<code class="fe kx ky kz la b">Adj Close</code>是列表中唯一提供的项目。</li><li id="5b59" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">使用这一行代码<code class="fe kx ky kz la b">adj_close[adj_close['Date']==end_of_last_year]</code>，您将过滤<code class="fe kx ky kz la b">adj_close</code>数据帧，只过滤数据的<code class="fe kx ky kz la b">Date</code>列等于您之前在<code class="fe kx ky kz la b">end_of_last_year</code>变量(2017，12，29)中指定的日期的行。</li><li id="1e74" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">您还可以设置<code class="fe kx ky kz la b">adj_close_latest</code>和<code class="fe kx ky kz la b">portfolio_df</code>数据帧的索引。我这样做是因为这是合并两个数据帧的方法。<code class="fe kx ky kz la b">merge</code>函数非常类似于SQL连接，是我经常使用的一个非常有用的函数。</li><li id="adb7" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">在<code class="fe kx ky kz la b">merge</code>函数中，指定左侧数据帧(<code class="fe kx ky kz la b">portfolio_df</code>)和右侧数据帧(<code class="fe kx ky kz la b">adj_close_latest</code>)。通过指定<code class="fe kx ky kz la b">left_index</code>和<code class="fe kx ky kz la b">right_index</code>等于True，您声明这两个数据帧共享一个公共索引，并且您将在这个索引上连接这两个数据帧。</li><li id="d1ea" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">最后，创建一个名为<code class="fe kx ky kz la b">'ticker return'</code>的新列。这通过将<code class="fe kx ky kz la b">Adj Close</code>除以<code class="fe kx ky kz la b">Unit Cost</code>(股票的初始购买价格)并减去1来计算每个股票头寸的百分比回报。这类似于在excel中计算一个公式并将其携带下来，但在<code class="fe kx ky kz la b">pandas</code>中，这是用一行代码完成的。</li></ul><p id="6405" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你已经获得了标准普尔500和个股的单个数据框架，你开始开发一个“主”数据框架，我们将使用它进行计算、可视化和任何进一步的分析。接下来，您将进一步使用pandas <code class="fe kx ky kz la b">merge</code>函数，继续构建这个“主”数据框架。下面，您重置当前数据帧的索引，并开始将较小的数据帧与主数据帧连接起来。同样，下面的代码块在<code class="fe kx ky kz la b">Jupyter</code>笔记本中被进一步分解；在这里，我采取了与之前类似的方法，我将分享下面的代码，然后分解代码块下面的关键标注。</p><pre class="mt mu mv mw gt mx la my mz aw na bi"><span id="295b" class="nb lc iq la b gy nc nd l ne nf">merged_portfolio<strong class="la ir">.</strong>reset_index(inplace<strong class="la ir">=</strong>True)</span><span id="6a2e" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># Here we are merging the new dataframe with the sp500 adjusted closes since the sp start price based on </em><br/><em class="me"># each ticker's acquisition date and sp500 close date.</em></span><span id="1aca" class="nb lc iq la b gy ng nd l ne nf">merged_portfolio_sp <strong class="la ir">=</strong> pd<strong class="la ir">.</strong>merge(merged_portfolio, sp_500_adj_close, left_on<strong class="la ir">=</strong>'Acquisition Date', right_on<strong class="la ir">=</strong>'Date')<br/><em class="me"># .set_index('Ticker')</em></span><span id="1ca5" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># We will delete the additional date column which is created from this merge.</em><br/><em class="me"># We then rename columns to Latest Date and then reflect Ticker Adj Close and SP 500 Initial Close.</em></span><span id="03e1" class="nb lc iq la b gy ng nd l ne nf"><strong class="la ir">del</strong> merged_portfolio_sp['Date_y']</span><span id="ea58" class="nb lc iq la b gy ng nd l ne nf">merged_portfolio_sp<strong class="la ir">.</strong>rename(columns<strong class="la ir">=</strong>{'Date_x': 'Latest Date', 'Adj Close_x': 'Ticker Adj Close'<br/>                                    , 'Adj Close_y': 'SP 500 Initial Close'}, inplace<strong class="la ir">=</strong>True)</span><span id="d100" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># This new column determines what SP 500 equivalent purchase would have been at purchase date of stock.</em><br/>merged_portfolio_sp['Equiv SP Shares'] <strong class="la ir">=</strong> merged_portfolio_sp['Cost Basis'] <strong class="la ir">/</strong> merged_portfolio_sp['SP 500 Initial Close']<br/>merged_portfolio_sp<strong class="la ir">.</strong>head()</span><span id="ff04" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># We are joining the developing dataframe with the sp500 closes again, this time with the latest close for SP.</em><br/>merged_portfolio_sp_latest <strong class="la ir">=</strong> pd<strong class="la ir">.</strong>merge(merged_portfolio_sp, sp_500_adj_close, left_on<strong class="la ir">=</strong>'Latest Date', right_on<strong class="la ir">=</strong>'Date')</span><span id="3a8b" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># Once again need to delete the new Date column added as it's redundant to Latest Date.  </em><br/><em class="me"># Modify Adj Close from the sp dataframe to distinguish it by calling it the SP 500 Latest Close.</em></span><span id="6beb" class="nb lc iq la b gy ng nd l ne nf"><strong class="la ir">del</strong> merged_portfolio_sp_latest['Date']</span><span id="0873" class="nb lc iq la b gy ng nd l ne nf">merged_portfolio_sp_latest<strong class="la ir">.</strong>rename(columns<strong class="la ir">=</strong>{'Adj Close': 'SP 500 Latest Close'}, inplace<strong class="la ir">=</strong>True)</span><span id="b4c9" class="nb lc iq la b gy ng nd l ne nf">merged_portfolio_sp_latest<strong class="la ir">.</strong>head()</span></pre><ul class=""><li id="019b" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">使用<code class="fe kx ky kz la b">merged_portfolio</code>上的<code class="fe kx ky kz la b">reset_index</code>来展平主数据框，并连接较小数据框的相关列。</li><li id="5d1c" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">在<code class="fe kx ky kz la b">merged_portfolio_sp</code>行，将当前主数据帧(merged_portfolio)与<code class="fe kx ky kz la b">sp_500_adj_close</code>合并；你这样做是为了得到标准普尔在每个头寸购买日的收盘价——这允许你跟踪标准普尔在持有每个头寸的同一时间段(从购买日到最近的市场收盘日)的表现。</li><li id="d225" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">这里的合并与之前略有不同，我们在左侧数据帧的<code class="fe kx ky kz la b">Acquisition Date</code>列和右侧数据帧的<code class="fe kx ky kz la b">Date</code>列进行了连接。</li><li id="7ef9" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">完成合并后，您将拥有不需要的额外列——因为我们的主数据框架最终将拥有大量用于分析的列，所以在此过程中删除重复和不必要的列非常重要。</li><li id="ba74" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">有几种方法可以删除不必要的列并执行各种列名清理；为了简单起见，我使用<code class="fe kx ky kz la b">python</code> <code class="fe kx ky kz la b">del</code>，然后用熊猫<code class="fe kx ky kz la b">rename</code>的方法重命名几列，通过重命名为<code class="fe kx ky kz la b">Ticker Adj Close</code>来澄清股票代码的<code class="fe kx ky kz la b">Adj Close</code>列；你可以用<code class="fe kx ky kz la b">SP 500 Initial Close</code>来区分S &amp; P的初始调整关闭。</li><li id="9f1b" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">当您计算<code class="fe kx ky kz la b">merged_portfolio_sp['Equiv SP Shares']</code>时，您这样做是为了能够计算出在您获得每个股票头寸的日期收盘时标准普尔500的等值:如果您在一个新的股票头寸上花费了5000美元，您可能已经在标准普尔500上花费了5000美元；继续这个例子，如果标准普尔500指数在购买时的交易价格是每股2500美元，你就可以购买2股。之后，如果标准普尔500指数的交易价格为每股3000美元，你的股份将价值6000美元(相当于2股*每股3000美元)，在可比的时间段内，你将有1000美元的账面利润。</li><li id="a03b" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">在代码块的其余部分，您接下来执行类似的合并，这一次加入标准普尔500的最新收盘数据—这提供了计算S&amp;P相对于每个头寸持有期的可比回报所需的第二部分:每个股票收购日的标准普尔500价格和标准普尔500的最新收盘数据。</li></ul><p id="fcd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您已经用以下内容进一步开发了您的“主”数据框架:</p><ul class=""><li id="a74f" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">每个投资组合头寸在头寸收购日的价格、份额和价值，以及最新的市场收盘价。</li><li id="770f" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">每只股票在等价头寸收购日的等价标准普尔500价格、股份和价值，以及最新的标准普尔500收盘价。</li></ul><p id="6bfd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">鉴于上述情况，您接下来将执行必要的计算，以比较每个头寸的表现，以及该策略/一篮子股票相对于可比美元投资和标准普尔500持有时间的整体表现。</p><p id="c4b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是您添加到“主”数据框架的新列的摘要。</p><ul class=""><li id="997e" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">在第一列<code class="fe kx ky kz la b">['SP Return']</code>中，您创建了一个列来计算标准普尔500指数在每个头寸的持有期内的绝对百分比回报(注意，这是绝对回报，而不是年化回报)。在第二列(<code class="fe kx ky kz la b">['Abs. Return Compare']</code>)中，您比较了同一时间段内<code class="fe kx ky kz la b">['ticker return']</code>(每个仓位的回报)与<code class="fe kx ky kz la b">['SP Return']</code>。</li><li id="36a8" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">在接下来的三列<code class="fe kx ky kz la b">['Ticker Share Value']</code>、<code class="fe kx ky kz la b">['SP 500 Value']</code>和<code class="fe kx ky kz la b">['Abs Value Compare']</code>中，我们根据我们持有的股票乘以最新调整后的收盘价来计算美元价值(市值)(并从股票行情自动收录器中减去S &amp; P回报，以计算超额/(低于)业绩)。</li><li id="ef8d" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">最后，<code class="fe kx ky kz la b">['Stock Gain / (Loss)']</code>和<code class="fe kx ky kz la b">['SP 500 Gain / (Loss)']</code>栏计算我们每个头寸的未实现美元损益和可比标准普尔500的损益；这让我们能够比较每个头寸与简单地将这些美元投资于标准普尔500指数的价值影响。</li></ul><pre class="mt mu mv mw gt mx la my mz aw na bi"><span id="4539" class="nb lc iq la b gy nc nd l ne nf"><em class="me"># Percent return of SP from acquisition date of position through latest trading day.</em><br/>merged_portfolio_sp_latest['SP Return'] <strong class="la ir">=</strong> merged_portfolio_sp_latest['SP 500 Latest Close'] <strong class="la ir">/</strong> merged_portfolio_sp_latest['SP 500 Initial Close'] <strong class="la ir">-</strong> 1</span><span id="a15e" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># This is a new column which takes the tickers return and subtracts the sp 500 equivalent range return.</em><br/>merged_portfolio_sp_latest['Abs. Return Compare'] <strong class="la ir">=</strong> merged_portfolio_sp_latest['ticker return'] <strong class="la ir">-</strong> merged_portfolio_sp_latest['SP Return']</span><span id="2028" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># This is a new column where we calculate the ticker's share value by multiplying the original quantity by the latest close.</em><br/>merged_portfolio_sp_latest['Ticker Share Value'] <strong class="la ir">=</strong> merged_portfolio_sp_latest['Quantity'] <strong class="la ir">*</strong> merged_portfolio_sp_latest['Ticker Adj Close']</span><span id="301e" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># We calculate the equivalent SP 500 Value if we take the original SP shares * the latest SP 500 share price.</em><br/>merged_portfolio_sp_latest['SP 500 Value'] <strong class="la ir">=</strong> merged_portfolio_sp_latest['Equiv SP Shares'] <strong class="la ir">*</strong> merged_portfolio_sp_latest['SP 500 Latest Close']</span><span id="a1c3" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># This is a new column where we take the current market value for the shares and subtract the SP 500 value.</em><br/>merged_portfolio_sp_latest['Abs Value Compare'] <strong class="la ir">=</strong> merged_portfolio_sp_latest['Ticker Share Value'] <strong class="la ir">-</strong> merged_portfolio_sp_latest['SP 500 Value']</span><span id="01cb" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># This column calculates profit / loss for stock position.</em><br/>merged_portfolio_sp_latest['Stock Gain / (Loss)'] <strong class="la ir">=</strong> merged_portfolio_sp_latest['Ticker Share Value'] <strong class="la ir">-</strong> merged_portfolio_sp_latest['Cost Basis']</span><span id="b0af" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># This column calculates profit / loss for SP 500.</em><br/>merged_portfolio_sp_latest['SP 500 Gain / (Loss)'] <strong class="la ir">=</strong> merged_portfolio_sp_latest['SP 500 Value'] <strong class="la ir">-</strong> merged_portfolio_sp_latest['Cost Basis']</span><span id="05b8" class="nb lc iq la b gy ng nd l ne nf">merged_portfolio_sp_latest<strong class="la ir">.</strong>head()</span></pre><p id="720a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您已经了解了将您的投资组合的表现与同等投资于标准普尔500的投资组合进行比较所需的内容。接下来的两个代码块部分允许您I)比较每个头寸相对于标准普尔500的YTD表现(衡量动量和您的头寸如何调整),以及ii)比较每个投资组合头寸相对于其最近收盘高点的最近收盘价(这允许您评估头寸是否触发了跟踪止损，例如，收盘时比收盘高点低25%。</p><p id="2020" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面，我将从YTD性能代码块开始，并在下面进一步提供有关代码的细节。</p><pre class="mt mu mv mw gt mx la my mz aw na bi"><span id="0c02" class="nb lc iq la b gy nc nd l ne nf"><em class="me"># Merge the overall dataframe with the adj close start of year dataframe for YTD tracking of tickers.</em></span><span id="7f8d" class="nb lc iq la b gy ng nd l ne nf">merged_portfolio_sp_latest_YTD <strong class="la ir">=</strong> pd<strong class="la ir">.</strong>merge(merged_portfolio_sp_latest, adj_close_start, on<strong class="la ir">=</strong>'Ticker')<br/><em class="me"># , how='outer'</em></span><span id="312e" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># Deleting date again as it's an unnecessary column.  Explaining that new column is the Ticker Start of Year Close.</em></span><span id="cec9" class="nb lc iq la b gy ng nd l ne nf"><strong class="la ir">del</strong> merged_portfolio_sp_latest_YTD['Date']</span><span id="aae5" class="nb lc iq la b gy ng nd l ne nf">merged_portfolio_sp_latest_YTD<strong class="la ir">.</strong>rename(columns<strong class="la ir">=</strong>{'Adj Close': 'Ticker Start Year Close'}, inplace<strong class="la ir">=</strong>True)</span><span id="f0d9" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># Join the SP 500 start of year with current dataframe for SP 500 ytd comparisons to tickers.</em></span><span id="626f" class="nb lc iq la b gy ng nd l ne nf">merged_portfolio_sp_latest_YTD_sp <strong class="la ir">=</strong> pd<strong class="la ir">.</strong>merge(merged_portfolio_sp_latest_YTD, sp_500_adj_close_start<br/>                                             , left_on<strong class="la ir">=</strong>'Start of Year', right_on<strong class="la ir">=</strong>'Date')</span><span id="4332" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># Deleting another unneeded Date column.</em></span><span id="c61b" class="nb lc iq la b gy ng nd l ne nf"><strong class="la ir">del</strong> merged_portfolio_sp_latest_YTD_sp['Date']</span><span id="ff09" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># Renaming so that it's clear this column is SP 500 start of year close.</em><br/>merged_portfolio_sp_latest_YTD_sp<strong class="la ir">.</strong>rename(columns<strong class="la ir">=</strong>{'Adj Close': 'SP Start Year Close'}, inplace<strong class="la ir">=</strong>True)</span><span id="e572" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># YTD return for portfolio position.</em><br/>merged_portfolio_sp_latest_YTD_sp['Share YTD'] <strong class="la ir">=</strong> merged_portfolio_sp_latest_YTD_sp['Ticker Adj Close'] <strong class="la ir">/</strong> merged_portfolio_sp_latest_YTD_sp['Ticker Start Year Close'] <strong class="la ir">-</strong> 1</span><span id="a146" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># YTD return for SP to run compares.</em><br/>merged_portfolio_sp_latest_YTD_sp['SP 500 YTD'] <strong class="la ir">=</strong> merged_portfolio_sp_latest_YTD_sp['SP 500 Latest Close'] <strong class="la ir">/</strong> merged_portfolio_sp_latest_YTD_sp['SP Start Year Close'] <strong class="la ir">-</strong> 1</span></pre><ul class=""><li id="485d" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">创建<code class="fe kx ky kz la b">merged_portfolio_sp_latest_YTD</code>数据帧时，您现在将“主”数据帧与<code class="fe kx ky kz la b">adj_close_start</code>数据帧合并；作为一个快速提醒，您是通过过滤<code class="fe kx ky kz la b">adj_close</code>数据帧来创建这个数据帧的，其中<code class="fe kx ky kz la b">'Date'</code>列等于变量<code class="fe kx ky kz la b">end_of_last_year</code>；你这样做是因为这是衡量YTD(年初至今)股票和指数表现的方法；去年的收盘价格是下一年的起始价格。</li><li id="2813" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">从这里开始，我们再次使用<code class="fe kx ky kz la b">del</code>删除不必要的列，并使用<code class="fe kx ky kz la b">rename</code>方法阐明“主”数据帧新添加的列。</li><li id="bd22" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">最后，我们获取每个股票(在<code class="fe kx ky kz la b">['Ticker Adj Close']</code>列中)并计算每个股票的YTD回报(对于<code class="fe kx ky kz la b">'SP 500 Latest Close'</code>列中的每个值，我们还有一个S &amp; P 500等值)。</li></ul><p id="1db9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下面的代码块中，您使用<code class="fe kx ky kz la b">sort_values</code>方法对我们的“主”数据框架进行重新排序，然后计算累积投资组合投资(您的持仓获取成本的总和)，以及投资组合持仓的累积价值和理论标准普尔500指数投资的累积价值。这使你能够看到你的总投资组合，包括在整个期间不同时间的投资，与你只投资于一个指数的策略相比是如何的。稍后，您将使用<code class="fe kx ky kz la b">['Cum Ticker ROI Mult']</code>来帮助您形象化每项投资对您的总体投资回报(ROI)的贡献或减少。</p><pre class="mt mu mv mw gt mx la my mz aw na bi"><span id="cf81" class="nb lc iq la b gy nc nd l ne nf">merged_portfolio_sp_latest_YTD_sp <strong class="la ir">=</strong> merged_portfolio_sp_latest_YTD_sp<strong class="la ir">.</strong>sort_values(by<strong class="la ir">=</strong>'Ticker', ascending<strong class="la ir">=</strong>True)</span><span id="ae08" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># Cumulative sum of original investment</em><br/>merged_portfolio_sp_latest_YTD_sp['Cum Invst'] <strong class="la ir">=</strong> merged_portfolio_sp_latest_YTD_sp['Cost Basis']<strong class="la ir">.</strong>cumsum()</span><span id="63b2" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># Cumulative sum of Ticker Share Value (latest FMV based on initial quantity purchased).</em><br/>merged_portfolio_sp_latest_YTD_sp['Cum Ticker Returns'] <strong class="la ir">=</strong> merged_portfolio_sp_latest_YTD_sp['Ticker Share Value']<strong class="la ir">.</strong>cumsum()</span><span id="4661" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># Cumulative sum of SP Share Value (latest FMV driven off of initial SP equiv purchase).</em><br/>merged_portfolio_sp_latest_YTD_sp['Cum SP Returns'] <strong class="la ir">=</strong> merged_portfolio_sp_latest_YTD_sp['SP 500 Value']<strong class="la ir">.</strong>cumsum()</span><span id="516a" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># Cumulative CoC multiple return for stock investments</em><br/>merged_portfolio_sp_latest_YTD_sp['Cum Ticker ROI Mult'] <strong class="la ir">=</strong> merged_portfolio_sp_latest_YTD_sp['Cum Ticker Returns'] <strong class="la ir">/</strong> merged_portfolio_sp_latest_YTD_sp['Cum Invst']</span><span id="d6a7" class="nb lc iq la b gy ng nd l ne nf">merged_portfolio_sp_latest_YTD_sp<strong class="la ir">.</strong>head()</span></pre><p id="87b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您已经接近尾声，几乎准备好开始可视化您的数据，并评估您的投资组合的单个股票和整体策略表现的优势和劣势。</p><p id="d037" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和以前一样，我包含了主要的代码块，用于确定头寸相对于最近收盘价的交易位置；然后，我将在下面进一步解包代码。</p><pre class="mt mu mv mw gt mx la my mz aw na bi"><span id="79d0" class="nb lc iq la b gy nc nd l ne nf"><em class="me"># Need to factor in that some positions were purchased much more recently than others.</em><br/><em class="me"># Join adj_close dataframe with portfolio in order to have acquisition date.</em></span><span id="0d7f" class="nb lc iq la b gy ng nd l ne nf">portfolio_df<strong class="la ir">.</strong>reset_index(inplace<strong class="la ir">=</strong>True)</span><span id="5dcd" class="nb lc iq la b gy ng nd l ne nf">adj_close_acq_date <strong class="la ir">=</strong> pd<strong class="la ir">.</strong>merge(adj_close, portfolio_df, on<strong class="la ir">=</strong>'Ticker')</span><span id="8416" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># delete_columns = ['Quantity', 'Unit Cost', 'Cost Basis', 'Start of Year']</em></span><span id="297e" class="nb lc iq la b gy ng nd l ne nf"><strong class="la ir">del</strong> adj_close_acq_date['Quantity']<br/><strong class="la ir">del</strong> adj_close_acq_date['Unit Cost']<br/><strong class="la ir">del</strong> adj_close_acq_date['Cost Basis']<br/><strong class="la ir">del</strong> adj_close_acq_date['Start of Year']</span><span id="e58b" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># Sort by these columns in this order in order to make it clearer where compare for each position should begin.</em><br/>adj_close_acq_date<strong class="la ir">.</strong>sort_values(by<strong class="la ir">=</strong>['Ticker', 'Acquisition Date', 'Date'], ascending<strong class="la ir">=</strong>[True, True, True], inplace<strong class="la ir">=</strong>True)</span><span id="353f" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># Anything less than 0 means that the stock close was prior to acquisition.</em><br/>adj_close_acq_date['Date Delta'] <strong class="la ir">=</strong> adj_close_acq_date['Date'] <strong class="la ir">-</strong> adj_close_acq_date['Acquisition Date']</span><span id="25d8" class="nb lc iq la b gy ng nd l ne nf">adj_close_acq_date['Date Delta'] <strong class="la ir">=</strong> adj_close_acq_date[['Date Delta']]<strong class="la ir">.</strong>apply(pd<strong class="la ir">.</strong>to_numeric)</span><span id="5751" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># Modified the dataframe being evaluated to look at highest close which occurred after Acquisition Date (aka, not prior to purchase).</em></span><span id="4235" class="nb lc iq la b gy ng nd l ne nf">adj_close_acq_date_modified <strong class="la ir">=</strong> adj_close_acq_date[adj_close_acq_date['Date Delta']<strong class="la ir">&gt;=</strong>0]</span><span id="db62" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># This pivot table will index on the Ticker and Acquisition Date, and find the max adjusted close.</em></span><span id="9c04" class="nb lc iq la b gy ng nd l ne nf">adj_close_pivot <strong class="la ir">=</strong> adj_close_acq_date_modified<strong class="la ir">.</strong>pivot_table(index<strong class="la ir">=</strong>['Ticker', 'Acquisition Date'], values<strong class="la ir">=</strong>'Adj Close', aggfunc<strong class="la ir">=</strong>np<strong class="la ir">.</strong>max)</span><span id="e730" class="nb lc iq la b gy ng nd l ne nf">adj_close_pivot<strong class="la ir">.</strong>reset_index(inplace<strong class="la ir">=</strong>True)</span><span id="bf80" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># Merge the adj close pivot table with the adj_close table in order to grab the date of the Adj Close High (good to know).</em></span><span id="36e9" class="nb lc iq la b gy ng nd l ne nf">adj_close_pivot_merged <strong class="la ir">=</strong> pd<strong class="la ir">.</strong>merge(adj_close_pivot, adj_close<br/>                                             , on<strong class="la ir">=</strong>['Ticker', 'Adj Close'])</span><span id="5ad1" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># Merge the Adj Close pivot table with the master dataframe to have the closing high since you have owned the stock.</em></span><span id="0074" class="nb lc iq la b gy ng nd l ne nf">merged_portfolio_sp_latest_YTD_sp_closing_high <strong class="la ir">=</strong> pd<strong class="la ir">.</strong>merge(merged_portfolio_sp_latest_YTD_sp, adj_close_pivot_merged<br/>                                             , on<strong class="la ir">=</strong>['Ticker', 'Acquisition Date'])</span><span id="9e6e" class="nb lc iq la b gy ng nd l ne nf"><em class="me"># Renaming so that it's clear that the new columns are closing high and closing high date.</em><br/>merged_portfolio_sp_latest_YTD_sp_closing_high<strong class="la ir">.</strong>rename(columns<strong class="la ir">=</strong>{'Adj Close': 'Closing High Adj Close', 'Date': 'Closing High Adj Close Date'}, inplace<strong class="la ir">=</strong>True)</span><span id="d68c" class="nb lc iq la b gy ng nd l ne nf">merged_portfolio_sp_latest_YTD_sp_closing_high['Pct off High'] <strong class="la ir">=</strong> merged_portfolio_sp_latest_YTD_sp_closing_high['Ticker Adj Close'] <strong class="la ir">/</strong> merged_portfolio_sp_latest_YTD_sp_closing_high['Closing High Adj Close'] <strong class="la ir">-</strong> 1 </span><span id="32a6" class="nb lc iq la b gy ng nd l ne nf">merged_portfolio_sp_latest_YTD_sp_closing_high</span></pre><ul class=""><li id="fc40" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">首先，将<code class="fe kx ky kz la b">adj_close</code>数据帧与<code class="fe kx ky kz la b">portfolio_df</code>数据帧合并；这是你第三次利用这个<code class="fe kx ky kz la b">adj_close</code>数据框架来进行单独的分析，然后将它与整个“主”数据框架相结合。</li><li id="b4fb" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">这种初始合并不是特别有用，因为你有日期和调整后的收盘价，这些日期和价格都在你收购每个头寸的日期之前；因此，我们将对收购日期后的数据进行子集化，然后找到从那时起的<code class="fe kx ky kz la b">max</code>收盘价。</li><li id="3067" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">我再次使用<code class="fe kx ky kz la b">del</code>删除合并后的dataframe中不需要的列；这是我应该重构的代码，因为创建一个列表，例如<code class="fe kx ky kz la b">cols_to_keep</code>，然后用它过滤数据帧将是一个更好的方法——作为参考，多次运行<code class="fe kx ky kz la b">del</code>代码块将会抛出一个错误，您需要重新初始化您的数据帧，然后再次运行<code class="fe kx ky kz la b">del</code>代码块。</li><li id="cc70" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">在删除不必要的列之后，使用<code class="fe kx ky kz la b">sort_values</code>方法，按照<code class="fe kx ky kz la b">'Ticker'</code>、<code class="fe kx ky kz la b">'Acquisition Date'</code>和<code class="fe kx ky kz la b">'Date'</code>列对值进行排序(都是升序)；您这样做是为了确保所有的股票行都排序在一起，我们按收购日期(以防我们不止一次购买同一只股票)和日期升序排序，以便过滤出您的头寸收购日期之前的日期。换句话说，你只关心收盘高点，因为你已经建仓了。</li><li id="44e4" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">为了过滤我们的数据框架，您创建了一个新列<code class="fe kx ky kz la b">['Date Delta']</code>,它是通过日期和采集日期列之间的差异计算的。</li><li id="8b20" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">然后将该列转换成数字列，并创建一个名为<code class="fe kx ky kz la b">adj_close_acq_date_modified</code>的新数据帧，其中<code class="fe kx ky kz la b">['Date Delta']</code>为&gt; = 0。这确保了你只评估自你买入每个头寸之日起的收盘高点。</li><li id="acc3" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">现在您已经有了<code class="fe kx ky kz la b">adj_close_acq_date_modified</code>数据框架，我们将使用一个非常强大的名为<code class="fe kx ky kz la b">pivot_table</code>的pandas函数。如果您熟悉Excel中的数据透视表，该函数与此类似，您可以基于单个或多个索引透视数据，指定要计算的值和要透视的列，还可以使用<code class="fe kx ky kz la b">agg functions</code>(利用<code class="fe kx ky kz la b">numpy</code>)。</li><li id="3b0e" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">使用<code class="fe kx ky kz la b">pivot_table</code>函数，我们以报价机和采集日期为中心，并指定我们希望找到每个位置的最大值(<code class="fe kx ky kz la b">np.max</code>)<code class="fe kx ky kz la b">Adj Close</code>；这允许您将每个头寸的最近调整收盘价与此最高调整收盘价进行比较。</li><li id="25b4" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">现在您有了一个<code class="fe kx ky kz la b">adj_close_pivot</code>数据帧，您重置了索引并在<code class="fe kx ky kz la b">adj_close</code>数据帧上再次连接它。这就创建了<code class="fe kx ky kz la b">adj_close_pivot_merged</code>数据框架，它告诉你何时买入了每个头寸，以及自买入以来触及收盘高点的日期。</li><li id="406b" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">最后，我们将“主”数据帧与最后一个较小的数据帧<code class="fe kx ky kz la b">adj_close_pivot_merged</code>合并。</li><li id="c606" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">这样做之后，您现在能够计算所需的最后一列<code class="fe kx ky kz la b">['Pct off High']</code>。你用<code class="fe kx ky kz la b">['Ticker Adj Close']</code>除以<code class="fe kx ky kz la b">['Closing High Adj Close']</code>，然后减去1。请注意，该百分比将始终为负，除非该股票碰巧在最近评估的交易日有最高收盘价(在这种情况下为零)(如果是这样，这通常是一个非常好的迹象)。</li></ul><p id="5266" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个非常重要的提升，现在是我们期待已久的可视化的时候了。如果你继续在你自己的笔记本上跟随，你现在有一个非常丰富的数据框架，有许多计算的投资组合指标，如下所示:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/e2fb0bf12c85b223b6dd2870d216ed56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*I7hOFxB5hBUP2C4s.png"/></div></div></figure><h1 id="7c77" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">总回报和累计回报可视化</h1><p id="1d07" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">对于所有这些可视化，您将使用<code class="fe kx ky kz la b">Plotly</code>，它允许您完全不用代码就可以制作D3图表。虽然我也用<code class="fe kx ky kz la b">Matplotlib</code>和<code class="fe kx ky kz la b">Seaborn</code>，但是我真的很看重<code class="fe kx ky kz la b">Plotly</code>的互动性；一旦你习惯了，语法变得相当简单，动态图表也很容易获得。</p><p id="ea64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的第一个图表比较了每个头寸相对于标准普尔500的总回报(头寸和标准普尔500假设投资的持有期相同)。在下面，你会看到在他们不同的持有期，8个位置中的6个跑赢了标准普尔。最后两个，Twitter(实际上有负回报)和沃尔玛跑输了同等时间的标准普尔500投资。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/de5953c9593a28634f4df05f8ba7fb94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5ekwOuewgCgfM6oJ.png"/></div></div></figure><p id="6b7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于这些可视化相对相似，我将解释生成上述Plotly可视化所需的代码，对于其余的，我将只总结每个可视化的观察结果。</p><pre class="mt mu mv mw gt mx la my mz aw na bi"><span id="d3a4" class="nb lc iq la b gy nc nd l ne nf">trace1 <strong class="la ir">=</strong> go<strong class="la ir">.</strong>Bar(<br/>    x <strong class="la ir">=</strong> merged_portfolio_sp_latest_YTD_sp_closing_high['Ticker'][0:10],<br/>    y <strong class="la ir">=</strong> merged_portfolio_sp_latest_YTD_sp_closing_high['ticker return'][0:10],<br/>    name <strong class="la ir">=</strong> 'Ticker Total Return')</span><span id="138d" class="nb lc iq la b gy ng nd l ne nf">trace2 <strong class="la ir">=</strong> go<strong class="la ir">.</strong>Scatter(<br/>    x <strong class="la ir">=</strong> merged_portfolio_sp_latest_YTD_sp_closing_high['Ticker'][0:10],<br/>    y <strong class="la ir">=</strong> merged_portfolio_sp_latest_YTD_sp_closing_high['SP Return'][0:10],<br/>    name <strong class="la ir">=</strong> 'SP500 Total Return')<br/>    <br/>data <strong class="la ir">=</strong> [trace1, trace2]</span><span id="4f5f" class="nb lc iq la b gy ng nd l ne nf">layout <strong class="la ir">=</strong> go<strong class="la ir">.</strong>Layout(title <strong class="la ir">=</strong> 'Total Return vs S&amp;P 500'<br/>    , barmode <strong class="la ir">=</strong> 'group'<br/>    , yaxis<strong class="la ir">=</strong>dict(title<strong class="la ir">=</strong>'Returns', tickformat<strong class="la ir">=</strong>".2%")<br/>    , xaxis<strong class="la ir">=</strong>dict(title<strong class="la ir">=</strong>'Ticker')<br/>    , legend<strong class="la ir">=</strong>dict(x<strong class="la ir">=.</strong>8,y<strong class="la ir">=</strong>1)<br/>    )</span><span id="1101" class="nb lc iq la b gy ng nd l ne nf">fig <strong class="la ir">=</strong> go<strong class="la ir">.</strong>Figure(data<strong class="la ir">=</strong>data, layout<strong class="la ir">=</strong>layout)<br/>iplot(fig)</span></pre><ul class=""><li id="c8d9" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">当使用<code class="fe kx ky kz la b">Plotly</code>时，您创建<code class="fe kx ky kz la b">traces</code>，它将绘制您指定的x和y数据。在这里，您在trace1中指定要绘制一个条形图，每个报价器在x轴上，每个报价器的回报率在y轴上。</li><li id="c7b0" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">在trace2中，为了稍微分解一下数据，我们将使用一个散点图，在x轴上显示股票，在y轴上显示S&amp;P回报率。</li><li id="9acf" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">当棒线在线上时，单个股票(8次中的6次)的表现超过了标准普尔500。</li><li id="897e" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">然后用这些跟踪创建一个数据对象，然后为图表提供一个布局；在这种情况下，您需要指定标题、barmode和图例的位置。您还可以为y轴系列传入标题和刻度格式(小数点后两位的百分比格式)。</li><li id="902f" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">然后您使用<code class="fe kx ky kz la b">go.Figure</code>创建一个图形对象，指定数据和布局对象，您之前将它们命名为<code class="fe kx ky kz la b">data</code>和<code class="fe kx ky kz la b">layout</code>。</li></ul><p id="186d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的图表显示了每个仓位相对于标准普尔500的盈利/(亏损)金额，以及股票总回报率%。虽然通常建议您为您的头寸分配相等的头寸规模(或可能根据隐含波动率确定头寸规模)，但情况可能并非总是如此。对于波动性较小的投资，您可能会比风险较高的头寸投资更多(或者您可能有其他头寸规模调整规则)。有鉴于此，这种可视化显示了每个位置的回报和美元价值的贡献，你的整体投资组合的回报。</p><p id="3c85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，你可以看到，虽然你在脸书的投资比其他头寸略少，但这只股票在这个模拟投资组合中获得了约2万美元的回报，比同期同等标准普尔500投资的4倍回报率还要高。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/4390a9d716f3ea83406036c569644fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*h148S6oBDMijzkbQ.png"/></div></div></figure><p id="3065" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的图表利用了您创建的累积列:<code class="fe kx ky kz la b">'Cum Invst'</code>、<code class="fe kx ky kz la b">'Cum SP Returns'</code>、<code class="fe kx ky kz la b">'Cum Ticker Returns'</code>和<code class="fe kx ky kz la b">'Cum Ticker ROI Mult'</code>。</p><ul class=""><li id="a802" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">在x轴上，你按字母顺序对投资组合进行了排序。每个头寸显示该头寸的初始投资和总价值(投资加上收益或减去损失)，以及之前的头寸。</li><li id="f126" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">为了进一步解释，根据在AAPL的约8k美元投资，这增长到约22.5k美元(收益为14k美元)，而标准普尔的总价值为15k美元。这是对AAPL初始投资的2.75倍回报(8k美元投资的22.5k价值是约2.75倍ROI)。</li><li id="c509" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">继续说FB，你总共投资了约1.6万美元(两个头寸都是8万美元)，现在已经超过5万美元，总回报超过3倍，这意味着FB扩大了你的整体投资组合投资回报率。</li><li id="7eca" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">沿着x轴往下，您会看到TWTR和WMT都降低了整体投资组合的投资回报率，这是显而易见的，因为两者的表现都不如S&amp;P，但我相信通过这种可视化，贡献的幅度会更明显。</li><li id="fecf" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">需要注意的是，考虑到不同的持有期，这种累积方法对于一些基于买入时间的头寸来说有点像苹果和橘子的组合。但是，您可以通过细分成更小的数据框架来隔离这种分析，并单独比较持有期更一致的头寸。例如，你可以分别比较你在2H 2016年和1H 2017年的购买情况。</li></ul><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/cc7818d5c7c97fcda505ae45567bee64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HBp6JtzbgpaJtyKR.png"/></div></div></figure><h1 id="6422" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">高比较的调整收盘百分比</h1><p id="5b8a" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">您的最终图表比较了每个头寸的最新收盘价与买入后调整后的收盘价的差距。这通常是要考虑的一个重要的可视化:</p><ul class=""><li id="fc2c" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">当一只股票以更高的价格收盘时，通常建议你也调整跟踪止损。举例来说，这里有一个例子:</li><li id="4975" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">一个头寸以10美元买入，翻倍至20美元——使用25%的跟踪止损，如果第二天该头寸收于15美元($ 15/$ 20–1 =(25%))，你会想考虑卖出该头寸。</li><li id="ab39" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">如果仓位增加到25美元，你可以考虑将你的跟踪止损移动到18.75美元($ 18.75/$ 25–1 =(25%))。</li><li id="b61d" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">如前所述，<em class="me">本文无意成为财务建议</em>；不同的交易系统有不同的跟踪止损规则，这是一个说明性的例子。</li><li id="a309" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">跟踪止损意在帮助保持收益，通常对减轻投资情绪很重要；虽然很容易看到你的头寸的当前回报，但往往需要手动(或者如果你使用跟踪止损服务，有点昂贵)计算你的头寸离跟踪止损有多近。</li><li id="69e2" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">这种最终的可视化使您可以很容易地评估您正在查看的任何日期；在图表中，我们看到AAPL、MTCH和NFLX都在2018年3月9日收盘于收盘高点(通常是一个非常好的迹象)。</li><li id="48fb" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">然而，TWTR比最高收盘价低25%以上(截至2018年3月9日，比最高收盘价低33%)，WMT比最高收盘价低约20%。</li><li id="8eef" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">在这种情况下，你可能想卖掉TWTR，继续密切关注WMT的表现。</li></ul><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/ab61b95473ffe57203101de9c3b099e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EvMdoJ2MTDnF8aAv.png"/></div></div></figure><h1 id="d575" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">方法的限制和总结</h1><p id="ac83" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">现在，您有了一个相对可扩展的Jupyter笔记本和投资组合数据集，您可以使用它来评估您的股票投资组合，并在您认为合适的时候添加新的指标和可视化。</p><p id="7471" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，虽然本笔记本对投资组合进行了相当全面的审查，但以下内容尚未纳入考虑范围，会对整体比较产生影响，并可能为未来发展提供很大的空间:</p><ul class=""><li id="f9cf" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">如前所述，本笔记本侧重于积极持仓——理想情况下，我们将评估所有头寸，包括已平仓和积极持仓，以便对个人相对于替代方案的投资策略有一个真正全面的了解，如指数比较。</li><li id="6d64" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">这里的方法不考虑分红。当我们评估调整后的收盘价(反映股息)时，总股东回报结合股价升值和股息来显示股票的总回报；虽然这更难做到，但我正在评估将来是否会包括这一点。</li><li id="6671" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">与此相关的是，投资者也可以将股息再投资于某个头寸，而不是进行现金分配；可以说，这甚至比股息会计更复杂，因为收购成本低且分散，在持有一个头寸的几年时间里，你可能每年有四个(或更多)收购日期用于股息再投资股票。</li></ul><p id="0b37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑到这些未来的领域，我们在这里取得了很多成就；这包括使用雅虎导入标准普尔500和股票数据。金融的API，并创建一个主数据框架，将您的投资组合与历史股票和比较标准普尔500价格相结合。这样，你就可以计算每个头寸的绝对百分比和美元价值回报(并与同期标准普尔500投资进行比较)，以及每个头寸对你的整体投资组合表现的累积影响。你也可以根据自己的交易规则动态监控你的跟踪止损。你还创造了可视化效果，让你更好地洞察你的主数据框架，关注不同的指标和每个位置对每个指标的贡献。</p><p id="899b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望你觉得这个教程有用，我欢迎评论中的任何反馈。你也可以在推特上联系我，<a class="ae kw" href="https://twitter.com/kevinboller" rel="noopener ugc nofollow" target="_blank"> @kevinboller </a>，我的个人博客可以在这里找到<a class="ae kw" href="https://kdboller.github.io/" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>