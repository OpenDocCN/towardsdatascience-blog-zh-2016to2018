<html>
<head>
<title>Beginning to Walk the Data Science Road (Part 2) : Pandas DataFrame</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开始走数据科学之路(下) :熊猫数据框架</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/beginning-to-walk-the-data-science-road-part-2-pandas-dataframe-c3e898499d90?source=collection_archive---------6-----------------------#2018-08-16">https://towardsdatascience.com/beginning-to-walk-the-data-science-road-part-2-pandas-dataframe-c3e898499d90?source=collection_archive---------6-----------------------#2018-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/833d06f084a07498d08d39dec0125573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ym_NwLRK2zrsgyNf"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@ninjason?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jason Leung</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4247" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第 1 部分中，我们开始走这条路，一路上，我们遇到了系列。</p><div class="lb lc gp gr ld le"><a rel="noopener follow" target="_blank" href="/beginning-to-walk-the-data-science-road-part-1-pandas-series-920e2237c336"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">开始走数据科学之路(上) :熊猫系列</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">既然我们已经迈出了数据科学的第一步，</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">towardsdatascience.com</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls jw le"/></div></div></a></div><p id="28f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们的探索还没有结束。在这一部分，我们将看看另一个熊猫对象——data frame。我们将首先解决我们在系列中看到的相同的体重指数问题，然后进入一个稍微复杂一点的问题。</p><p id="9a63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">DataFrame 可能是熊猫中最重要也是最常用的对象。数据帧基本上是共享公共索引的一系列数据的集合，这就是我们首先看到系列的原因。数据帧在表格结构中以行和列的形式排列数据。</p><p id="ca34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">万一你忘了，让我们重新定义身体质量指数的问题。如果你确实记得，向前跳到解决方案。</p><h1 id="2a24" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">问题 1</h1><p id="ef04" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">给你 5 个人的身高(英寸)和体重(磅)，如下表所示:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="6be5" class="nf lu iq nb b gy ng nh l ni nj">+--------+--------------+-------------+<br/>| Person | Height(inch) | Weight(lbs) |<br/>+--------+--------------+-------------+<br/>| A      |           72 |         186 |<br/>| B      |           69 |         205 |<br/>| C      |           70 |         201 |<br/>| D      |           62 |         125 |<br/>| E      |           57 |          89 |<br/>+--------+--------------+-------------+</span></pre><p id="c1e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">后来发现，该表实际上遗漏了人 F 和 G 的条目，他们的身高分别是 65 英寸和 60 英寸，F 的体重是 121 磅，但是遗漏了 G 的体重数据。此外，发现所有高度的值都比它应有的值小 5 英寸，而所有重量的值都比它应有的值大 5 磅。如果可能的话，为每个人找到正确的体重指数(身体质量指数)。</p><h1 id="2911" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">解决方案 1</h1><p id="5c48" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">我们已经看到了使用级数的解决方案。现在，让我们尝试使用 DataFrame 解决相同的问题。同样，您可以在下面的链接中找到完整的代码。</p><div class="lb lc gp gr ld le"><a href="https://github.com/bajracharya-kshitij/pandas" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">bajracharya-kshi tij/熊猫</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">GitHub 是人们构建软件的地方。超过 2800 万人使用 GitHub 来发现、分享和贡献超过…</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">github.com</p></div></div><div class="ln l"><div class="nk l lp lq lr ln ls jw le"/></div></div></a></div><p id="1f18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们将使用 DataFrames 来表示给定的表。条目(也称为数据点)作为列表传递给数据参数，列名作为字符串列表传递给列参数。我们创建了两个数据框——一个是身高数据框，另一个是体重数据框。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="24d8" class="nf lu iq nb b gy ng nh l ni nj">height_df = pd.DataFrame(data=[['A',72],['B',69],['C',70],['D',62],['E',57]], columns=['Person','Height'])<br/>weight_df = pd.DataFrame(data=[['A',186],['B',205],['C',201],['D',125],['E',89]], columns=['Person','Weight'])</span></pre><p id="4e16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们检查数据帧的<code class="fe nl nm nn nb b">head</code>。Head 通过返回参数中定义的第一个<code class="fe nl nm nn nb b">n</code>行数，为我们提供了一个表格示例。在这种情况下，我们将定义<code class="fe nl nm nn nb b">n = 3</code>。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="4ebe" class="nf lu iq nb b gy ng nh l ni nj">height_df.head(n=3)</span></pre><p id="29d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它返回</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/5f4cdb8e0752254988172bed02e5e26e.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*xB223rj1Qyxm15MC81-RKg.png"/></div></figure><p id="bc76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有将<code class="fe nl nm nn nb b">n</code>指定为 head 方法的参数，则返回前 5 行。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="0163" class="nf lu iq nb b gy ng nh l ni nj">weight_df.head()</span></pre><p id="19b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/b4467d23629631d8288203c8321312a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*lOzuLS1X1DG20JGzwJ3q0A.png"/></div></figure><p id="c2a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们有两个数据帧，但实际上我们只是想要一个来表示给定的表。因此，我们将使用<code class="fe nl nm nn nb b">merge</code>方法连接两个数据帧。由于两个数据帧都有公共列<strong class="kf ir"> Person </strong>，我们将使用它将它们合并成一个数据帧。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="9b41" class="nf lu iq nb b gy ng nh l ni nj">height_weight_df = pd.merge(height_df,weight_df,on='Person')</span></pre><p id="ed33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以现在我们有<code class="fe nl nm nn nb b">height_weight_df</code>作为:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/94dbdb683a46701f8b65ec12d019085a.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*Hf1pTWk2jPLuZs5Uxn3ANQ.png"/></div></figure><p id="c48b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在这个数据框架上使用<code class="fe nl nm nn nb b">describe</code>方法来获得关于平均值、标准差、四分位数和其他的统计信息。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="06ba" class="nf lu iq nb b gy ng nh l ni nj">height_weight_df.describe()</span></pre><p id="1199" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/b1ea69ff61bce7704313536ab2fb330b.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*uYQsm_98aGQPVDiqNBmQqw.png"/></div></figure><p id="cb07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以使用<code class="fe nl nm nn nb b">info</code>方法来获得每一列中条目数量及其数据类型的更多细节。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="f0b0" class="nf lu iq nb b gy ng nh l ni nj">height_weight_df.info()</span></pre><p id="8683" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nl nm nn nb b">info</code>方法的结果看起来是这样的:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="f7dc" class="nf lu iq nb b gy ng nh l ni nj">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>Int64Index: 5 entries, 0 to 4<br/>Data columns (total 3 columns):<br/>Person    5 non-null object<br/>Height    5 non-null int64<br/>Weight    5 non-null int64<br/>dtypes: int64(2), object(1)<br/>memory usage: 160.0+ bytes</span></pre><p id="1306" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nl nm nn nb b">describe</code>方法只显示身高和体重列的细节，而不显示人员列的细节。这是因为 Person 列中的条目属于<code class="fe nl nm nn nb b">object</code>类型；它们只是名字，不可能对名字进行统计操作，如均值、标准差和四分位数。这也可以通过<code class="fe nl nm nn nb b">info</code>方法来说明，该方法显示身高和体重属于<code class="fe nl nm nn nb b">int64</code>类型，而人属于<code class="fe nl nm nn nb b">object</code>类型。</p><p id="81ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实际的计算只针对身高和体重。person 列只使用一个公共索引将一对值绑定在一起。因此，让我们使用<code class="fe nl nm nn nb b">set_index</code>方法将 Person 列设置为这个数据帧的索引。<code class="fe nl nm nn nb b">set_index</code>接受一个列数组作为参数。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="e74f" class="nf lu iq nb b gy ng nh l ni nj">height_weight_df.set_index(['Person'])</span></pre><p id="ea3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但这不会改变原始数据帧中的任何内容。回想一下系列，熊猫不希望你不小心丢失信息。当我们在数据帧上设置新的索引时，我们会丢失现有的索引。当然，此刻索引只是默认的整数。尽管如此，为了使索引永久化，您必须声明您希望这个改变发生在<code class="fe nl nm nn nb b">inplace</code>。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="9a39" class="nf lu iq nb b gy ng nh l ni nj">height_weight_df.set_index(['Person'],inplace=True)</span></pre><p id="7e8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果我们检查<code class="fe nl nm nn nb b">height_weight_df</code>，我们会看到</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/8f336b9560eb1ae157800a2d4d139d31.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*0B5F3WxYkpCT9sm-frEmKw.png"/></div></figure><p id="4b34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nl nm nn nb b">info</code>方法现在只显示身高和体重列。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="9289" class="nf lu iq nb b gy ng nh l ni nj">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>Index: 5 entries, A to E<br/>Data columns (total 2 columns):<br/>Height    5 non-null int64<br/>Weight    5 non-null int64<br/>dtypes: int64(2)<br/>memory usage: 120.0+ bytes</span></pre><h2 id="d5e8" class="nf lu iq bd lv nt nu dn lz nv nw dp md ko nx ny mh ks nz oa ml kw ob oc mp od bi translated">我们已经用级数解决了。再解决这个问题有什么意义？</h2><p id="5474" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">这里的要点是证明 DataFrame 只不过是由公共索引绑定在一起的一组序列。如果你打印出<code class="fe nl nm nn nb b">height_weight_df[‘Height’]</code>，它返回</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="ba6e" class="nf lu iq nb b gy ng nh l ni nj">Person<br/>A    72<br/>B    69<br/>C    70<br/>D    62<br/>E    57<br/>Name: Height, dtype: int64</span></pre><p id="5130" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这显然是一个系列。如果你打印出<code class="fe nl nm nn nb b">height_weight_df[‘Weight’]</code>，同样的事情也会发生。这表明身高和体重都是具有共同索引 A 到 e 的序列，这是列所关心的。现在，让我们看看行。如果使用<code class="fe nl nm nn nb b">height_weight_df.loc['A']</code>打印出 A 的行，我们得到</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="73c8" class="nf lu iq nb b gy ng nh l ni nj">Height     72<br/>Weight    186<br/>Name: A, dtype: int64</span></pre><p id="bee5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也是一个系列。所以，A 到 E 也是拥有共同指数身高和体重的系列。我们可以使用<code class="fe nl nm nn nb b">type(height_weight_df[‘Height’])</code>和<code class="fe nl nm nn nb b">type(height_weight_df.loc[‘A’])</code>来查看这两者的类型。这两个人都回到了<code class="fe nl nm nn nb b">pandas.core.series.Series</code>。</p><p id="a0bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们清楚了数据帧是由系列组成的，让我们回到我们的问题。我们现在意识到 F 和 G 的身高和体重从表格中消失了。因此，我们为丢失的值创建另一个数据帧。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="abb7" class="nf lu iq nb b gy ng nh l ni nj">missing_df = pd.DataFrame(data=[[65,121],[60]],index=['F','G'],columns=['Height','Weight'])</span></pre><p id="14ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nl nm nn nb b">missing_df</code>现在看起来是这样的</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/ce61446dc451c7d7d0b58632b9299a99.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*LAOIrE5xDJxPdOyTJkp-JQ.png"/></div></figure><p id="134d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们看到 G 的权重丢失了，所以取而代之的是一个<code class="fe nl nm nn nb b">NaN</code>值。接下来，为了获得单个数据帧，我们将这个<code class="fe nl nm nn nb b">missing_df</code>附加到原始的<code class="fe nl nm nn nb b">height_weight_df</code>中，</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="c047" class="nf lu iq nb b gy ng nh l ni nj">updated_df = height_weight_df.append(missing_df)</span></pre><p id="9538" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样<code class="fe nl nm nn nb b">updated_df</code>就变成了</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/ebf374ecfa5aeaefd1b021ba9399e8e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*syBcAhRobz_EruEerKWfaw.png"/></div></figure><p id="577d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们发现每个人的身高减少了 5，体重增加了 5。所以，让我们修改一下。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="8349" class="nf lu iq nb b gy ng nh l ni nj">updated_df['Height'] += 5<br/>updated_df['Weight'] -= 5</span></pre><p id="10ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就把我们的<code class="fe nl nm nn nb b">updated_df</code>改成了</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/62efb32f8d6951261e7741dacf0c99f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*5ettuEiUnKUo7gKECvmYyg.png"/></div></figure><p id="fe59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有人的身高和体重已被正确更新，并可进一步用于计算身体质量指数。但是由于 G 的重量丢失，不可能计算出 G 的身体质量指数，所以我们把 G 的条目一起去掉。同样，我们需要指定<code class="fe nl nm nn nb b">inplace=True</code>来使其永久化。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="50b8" class="nf lu iq nb b gy ng nh l ni nj">updated_df.dropna(inplace=True)</span></pre><p id="dd63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后移除 G 的条目。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi of"><img src="../Images/2b0aa27731d3b5037ed29a46fa94c7c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*gU1KJa2hj1jKCXDD2_ewqg.png"/></div></figure><p id="1171" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们已经正确地得到了所有的值，那么是时候找到身体质量指数了。我们已经知道，计算身体质量指数的公式如下:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/3cbfc241c7e7dd5922f903ef4b80b9c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*7Pk-4kFp72O6d371-0l4hg.png"/></div></figure><p id="df10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要应用上述公式，首先必须将体重从磅转换为千克，将身高从英寸转换为米。我们知道，1 磅= 0.453592 千克，1 英寸= 0.0254 米，我们用变量来定义这些。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="5521" class="nf lu iq nb b gy ng nh l ni nj">lbs_to_kg_ratio = 0.453592<br/>inch_to_meter_ratio = 0.0254</span></pre><p id="152f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用上述比率，我们将数据框更新为所需的单位。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="b52a" class="nf lu iq nb b gy ng nh l ni nj">updated_df['Height'] *= inch_to_meter_ratio<br/>updated_df['Weight'] *= lbs_to_kg_ratio</span></pre><p id="ae5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在有<code class="fe nl nm nn nb b">updated_df</code>作为</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/82a79e1455deae1f52023b866d1c1654.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*l1pMIpnZpeePLeB6pbjbWg.png"/></div></figure><p id="c0ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经有了正确单位的所有数据，我们可以使用上面的公式来计算身体质量指数。我们将一个新列<code class="fe nl nm nn nb b">BMI</code>添加到现有的数据帧中</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="a140" class="nf lu iq nb b gy ng nh l ni nj">updated_df['BMI'] = updated_df['Weight']/(updated_df['Height']**2)</span></pre><p id="3370" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以<code class="fe nl nm nn nb b">updated_df</code>现在看起来像</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/6c7fa0d149b19f78c0580dd318a6973e.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*L19F6OM7bET6r3p5nb-1xg.png"/></div></figure><p id="71ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，通过将索引标签设置为<code class="fe nl nm nn nb b">Person</code>，我们将这个数据帧导出到一个名为<code class="fe nl nm nn nb b">BMI.csv</code>的 csv 文件中。csv 文件保存在保存程序源代码的同一目录中。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="a098" class="nf lu iq nb b gy ng nh l ni nj">updated_df.to_csv('BMI.csv',index_label='Person')</span></pre><p id="2b5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们比较这两种方法，使用 DataFrame 方法会产生一个更简洁的问题解决方案；部分原因是我们可以用一个数据框架同时处理两个系列。</p><h2 id="7498" class="nf lu iq bd lv nt nu dn lz nv nw dp md ko nx ny mh ks nz oa ml kw ob oc mp od bi translated">熊猫能做的就这些吗？</h2><p id="be09" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">目前我们看到的只是对熊猫的简单利用。然而，当我们处理复杂的问题时，熊猫的真正力量变得显而易见。所以，现在让我们来看一个稍微复杂一点的问题，看看熊猫到底能做什么。这次我们将使用一个真实的数据集。</p><h2 id="1515" class="nf lu iq bd lv nt nu dn lz nv nw dp md ko nx ny mh ks nz oa ml kw ob oc mp od bi translated">什么是数据集？</h2><p id="c26e" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">数据集只是在感兴趣的特定领域中收集的数据的集合。例如，可以有一个世界各国的数据集。该数据集可以包含特定年份世界各国的人口、按性别、年龄组划分的人口、各国的 GDP、预期寿命、识字率、婴儿死亡率以及各种其他数据。这些只是一堆毫无意义的数字。但是有了像熊猫这样的分析工具，我们可以从这个数据集产生有价值的见解，比如，一个国家的 GDP 和它的识字率之间有关系吗？或者婴儿死亡率和女性预期寿命的关系？这些是熊猫帮助我们解决的问题类型。<a class="ae kc" href="https://archive.ics.uci.edu/ml/datasets.html" rel="noopener ugc nofollow" target="_blank"> UCI 机器学习库</a>包含许多有趣的数据集。一旦您熟悉了 DataFrame，您就可以尝试使用其中的一些数据集。在这篇文章中，我将使用一个相对简单的数据集，我们将在下一个问题中讨论。</p><h1 id="aeca" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">问题 2</h1><p id="0921" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">我们有一个数据集，其中包含司机在一段时间内的出行数据。数据集的描述如下:</p><p id="94a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="oj">一名司机每天开车上下班时使用一款应用程序追踪 GPS 坐标。该应用程序收集位置和海拔数据。该数据集中总结了大约 200 次旅行的数据。</em></p><p id="e509" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用数据集，查找<br/> a)第一个、最后一个和第十个条目的详细信息，<br/> b)每天的详细信息，<br/> c)当一天的总行驶距离大于 90 但小于 100 时的条目，<br/>d)c)单行的距离和燃油经济性，<br/> e)当平均移动速度大于 90 时的星期五的条目，<br/> f)当最大速度大于 135 或燃油经济性小于 8 时的条目，以及<br/> g)</p><h1 id="5831" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">解决方案 2</h1><p id="5c25" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">我们从这个<a class="ae kc" href="https://openmv.net/info/travel-times" rel="noopener ugc nofollow" target="_blank">链接</a>下载数据集，并将其保存在一个名为<code class="fe nl nm nn nb b">travel-times.csv</code>的文件中。现在，我们需要从 csv 文件中获取数据。<code class="fe nl nm nn nb b">read_csv</code>方法接受文件名作为参数，并返回一个 DataFrame。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="56eb" class="nf lu iq nb b gy ng nh l ni nj">travel_df = pd.read_csv('travel-times.csv')</span></pre><p id="c24a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时此刻，我们并不真正知道数据集中有什么样的数据。在我们开始解决问题之前熟悉数据通常是一个好习惯。为了查看数据集中可用的数据类型，我们使用了返回 DataFrame 的前 5 行的<code class="fe nl nm nn nb b">head</code>方法。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="6148" class="nf lu iq nb b gy ng nh l ni nj">travel_df.head()</span></pre><p id="6de0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回以下内容</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/c94a7f0ccf8a5368a662df6a230e0307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lgVsGVctJjjZiuaq9EFy0g.png"/></div></div></figure><p id="f0a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nl nm nn nb b">head</code>方法让我们熟悉了数据集中可用的列，并提供了一个数据样本。让我们通过使用<code class="fe nl nm nn nb b">describe</code>方法来了解更多的数据。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="639a" class="nf lu iq nb b gy ng nh l ni nj">travel_df.describe()</span></pre><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/a156f3bebe85fd71a369a2b68876aed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mDujlH2ur3SoIhpNNNYVWQ.png"/></div></div></figure><p id="38f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nl nm nn nb b">describe</code>方法只列出原始数据帧中的 6 列。这是因为只有这 6 个是数字类型，因此它们的平均值、标准差、四分位数等也是数字类型。可以被计算出来。让我们用<code class="fe nl nm nn nb b">info</code>方法进一步验证这一点。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="2205" class="nf lu iq nb b gy ng nh l ni nj">travel_df.info()</span></pre><p id="d293" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="95b6" class="nf lu iq nb b gy ng nh l ni nj">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 205 entries, 0 to 204<br/>Data columns (total 13 columns):<br/>Date              205 non-null object<br/>StartTime         205 non-null object<br/>DayOfWeek         205 non-null object<br/>GoingTo           205 non-null object<br/>Distance          205 non-null float64<br/>MaxSpeed          205 non-null float64<br/>AvgSpeed          205 non-null float64<br/>AvgMovingSpeed    205 non-null float64<br/>FuelEconomy       188 non-null object<br/>TotalTime         205 non-null float64<br/>MovingTime        205 non-null float64<br/>Take407All        205 non-null object<br/>Comments          24 non-null object<br/>dtypes: float64(6), object(7)<br/>memory usage: 20.9+ KB</span></pre><p id="7532" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实际上只有 6 列是类型<code class="fe nl nm nn nb b">float64</code>。然而，我们从<code class="fe nl nm nn nb b">info</code>方法中发现了一些有趣的信息。总共有 13 列，其中 11 列有 205 个条目，但是<code class="fe nl nm nn nb b">FuelEconomy</code>只有 188 个，而<code class="fe nl nm nn nb b">Comments</code>字段只有 24 个。相对而言，这是非常少的数据，不能为我们提供太多信息。此外，我们的问题没有定义任何关于评论的东西。因为我们对评论不感兴趣，所以我们将放弃这个专栏。记住，我们需要声明<code class="fe nl nm nn nb b">inplace=True</code>来永久删除该列。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="e6c8" class="nf lu iq nb b gy ng nh l ni nj">travel_df.drop(labels=['Comments'],axis=1,inplace=True)</span></pre><p id="5457" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有定义 axis，它将被设置为 0，这意味着删除索引。为了删除一列，我们显式定义了<code class="fe nl nm nn nb b">axis=1</code>。同样，我们检查 head 和 info 方法。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="ffd0" class="nf lu iq nb b gy ng nh l ni nj">travel_df.head()</span></pre><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/bd47ed761ee1d8cdc4818b24ec085da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KTTkTyQOB_AMDaqhplKf2Q.png"/></div></div></figure><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="68df" class="nf lu iq nb b gy ng nh l ni nj">travel_df.info()</span></pre><p id="9e77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它返回</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="ce0b" class="nf lu iq nb b gy ng nh l ni nj">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 205 entries, 0 to 204<br/>Data columns (total 12 columns):<br/>Date              205 non-null object<br/>StartTime         205 non-null object<br/>DayOfWeek         205 non-null object<br/>GoingTo           205 non-null object<br/>Distance          205 non-null float64<br/>MaxSpeed          205 non-null float64<br/>AvgSpeed          205 non-null float64<br/>AvgMovingSpeed    205 non-null float64<br/>FuelEconomy       188 non-null object<br/>TotalTime         205 non-null float64<br/>MovingTime        205 non-null float64<br/>Take407All        205 non-null object<br/>dtypes: float64(6), object(6)<br/>memory usage: 19.3+ KB</span></pre><p id="4559" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们只剩下 12 列了。我们仍然在<code class="fe nl nm nn nb b">FuelEconomy</code>列中缺少我们感兴趣的数据。让我们看一个更大的样本，这样我们就可以看到 FuelEconomy 不是 NaN 的行。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="aebe" class="nf lu iq nb b gy ng nh l ni nj">travel_df.head(n=10)</span></pre><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi on"><img src="../Images/c1450f2a593574ed00db5e71dc18e70f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FrbVCqsqejbz2xu7bN_fdQ.png"/></div></div></figure><p id="2372" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到<code class="fe nl nm nn nb b">FuelEconomy</code>列包含数字，但是<code class="fe nl nm nn nb b">info</code>方法将<code class="fe nl nm nn nb b">FuelEconomy</code>列的数据类型显示为<code class="fe nl nm nn nb b">object</code>。让我们用<code class="fe nl nm nn nb b">dtype</code>属性进一步验证这一点。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="718c" class="nf lu iq nb b gy ng nh l ni nj">travel_df['FuelEconomy'].dtype</span></pre><p id="a190" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它返回<code class="fe nl nm nn nb b">dtype(‘O’)</code>。“O”表示它属于类型<code class="fe nl nm nn nb b">object</code>。通过查看上面的头部，我们可以看到它不仅包含<code class="fe nl nm nn nb b">NaN</code> s，还包含虚线(-)条目，类型为<code class="fe nl nm nn nb b">object</code>。在执行任何操作之前，我们需要将<code class="fe nl nm nn nb b">FuelEconomy</code>列转换为数字类型。为此，我们使用<code class="fe nl nm nn nb b">to_numeric</code>方法。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="4f0d" class="nf lu iq nb b gy ng nh l ni nj">travel_df['FuelEconomy'] = pd.to_numeric(travel_df['FuelEconomy'],errors='coerce')</span></pre><p id="7276" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">方法试图将一个字符串解析成一个数字。<code class="fe nl nm nn nb b">errors=’coerce’</code>将无法解析为数字的条目设置为<code class="fe nl nm nn nb b">NaN</code>。如果没有显式定义 errors，默认结果将是抛出一个异常，因为虚线(-)条目无法解析为数字。</p><p id="4b1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们再次看看 info 和 head 方法。<code class="fe nl nm nn nb b">travel_df.info()</code>现在退货</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="937d" class="nf lu iq nb b gy ng nh l ni nj">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 205 entries, 0 to 204<br/>Data columns (total 12 columns):<br/>Date              205 non-null object<br/>StartTime         205 non-null object<br/>DayOfWeek         205 non-null object<br/>GoingTo           205 non-null object<br/>Distance          205 non-null float64<br/>MaxSpeed          205 non-null float64<br/>AvgSpeed          205 non-null float64<br/>AvgMovingSpeed    205 non-null float64<br/>FuelEconomy       186 non-null float64<br/>TotalTime         205 non-null float64<br/>MovingTime        205 non-null float64<br/>Take407All        205 non-null object<br/>dtypes: float64(7), object(5)<br/>memory usage: 19.3+ KB</span></pre><p id="5454" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe nl nm nn nb b">travel_df.head(n=10)</code>现在显示</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oo"><img src="../Images/0a8a4b704dbb1e7553e467d71c927afb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jYrVSTKu63rlqhg5RbOpMQ.png"/></div></div></figure><p id="edb0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nl nm nn nb b">FuelEconomy</code>的数据类型现在已经更改为<code class="fe nl nm nn nb b">float64</code>，现在有 186 个非空条目，因为虚线条目已经设置为<code class="fe nl nm nn nb b">NaN</code>。</p><p id="0a16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了执行进一步的计算，最好将所有数值都填满。移除<code class="fe nl nm nn nb b">NaN</code>值的一个常用方法是用列中可用值的平均值填充这些条目。为此，我们将<code class="fe nl nm nn nb b">fillna</code>方法与<code class="fe nl nm nn nb b">inplace=True</code>结合使用。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="19ef" class="nf lu iq nb b gy ng nh l ni nj">travel_df['FuelEconomy'].fillna(travel_df['FuelEconomy'].mean(),inplace=True)</span></pre><p id="2101" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nl nm nn nb b">head</code>现在显示</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi op"><img src="../Images/171854d8ff32b24d7dbd665381adde76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ec1NciTikwYRZsyh9pdK-A.png"/></div></div></figure><p id="0c18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且<code class="fe nl nm nn nb b">info</code>给出</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="45c0" class="nf lu iq nb b gy ng nh l ni nj">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 205 entries, 0 to 204<br/>Data columns (total 12 columns):<br/>Date              205 non-null object<br/>StartTime         205 non-null object<br/>DayOfWeek         205 non-null object<br/>GoingTo           205 non-null object<br/>Distance          205 non-null float64<br/>MaxSpeed          205 non-null float64<br/>AvgSpeed          205 non-null float64<br/>AvgMovingSpeed    205 non-null float64<br/>FuelEconomy       205 non-null float64<br/>TotalTime         205 non-null float64<br/>MovingTime        205 non-null float64<br/>Take407All        205 non-null object<br/>dtypes: float64(7), object(5)<br/>memory usage: 19.3+ KB</span></pre><p id="2af9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们在<code class="fe nl nm nn nb b">FuelEconomy</code>列中的所有 205 个值都用平均值填充了数据缺失的地方。</p><p id="9f17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们准备开始解决上面给出的问题。对于第一个问题，我们使用<code class="fe nl nm nn nb b">iloc</code>属性来查找数据帧中的第一个、最后一个和第 10 个条目。</p><p id="0b75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nl nm nn nb b">travel_df.iloc[0]</code>给了我们第一排</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="59db" class="nf lu iq nb b gy ng nh l ni nj">Date              1/6/2012<br/>StartTime            16:37<br/>DayOfWeek           Friday<br/>GoingTo               Home<br/>Distance             51.29<br/>MaxSpeed             127.4<br/>AvgSpeed              78.3<br/>AvgMovingSpeed        84.8<br/>FuelEconomy        8.69059<br/>TotalTime             39.3<br/>MovingTime            36.3<br/>Take407All              No<br/>Name: 0, dtype: object</span></pre><p id="dc2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到这是一个系列。</p><p id="2b73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类似地，我们可以使用<code class="fe nl nm nn nb b">travel_df.iloc[-1]</code>查找最后一行，使用<code class="fe nl nm nn nb b">travel_df.iloc[9]</code>查找第 10 个元素。</p><p id="e9b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们看到一个日期有多个条目。因此，让我们将数据分组，以便每个日期只有一个条目。我们尝试按照<code class="fe nl nm nn nb b">Date</code>列对数据帧进行分组。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="2c5b" class="nf lu iq nb b gy ng nh l ni nj">travel_df_by_date = travel_df.groupby(['Date'])</span></pre><p id="33f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们通过使用<code class="fe nl nm nn nb b">type(travel_df_by_date)</code>来查看<code class="fe nl nm nn nb b">travel_df_by_date</code>的类型，我们将看到它返回<code class="fe nl nm nn nb b">pandas.core.groupby.DataFrameGroupBy</code>。所以<code class="fe nl nm nn nb b">travel_df_by_date</code>是一个<code class="fe nl nm nn nb b">DataFrameGroupBy</code>实例。为了组合具有相同日期的多行，我们在<code class="fe nl nm nn nb b">DataFrameGroupBy</code>实例上使用了<code class="fe nl nm nn nb b">sum</code>方法。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="c870" class="nf lu iq nb b gy ng nh l ni nj">travel_df_by_date_combined = travel_df_by_date.sum()</span></pre><p id="f7a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该数据帧的<code class="fe nl nm nn nb b">head</code>返回</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oq"><img src="../Images/8d19c0d6bb5e80650c1c40599e0e1380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hji8npKM4pJ4lMdYNBr6ZQ.png"/></div></div></figure><p id="6f26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看我们的问题，也需要<code class="fe nl nm nn nb b">DayOfWeek</code>栏。但是使用<code class="fe nl nm nn nb b">sum</code>方法只能保留数字字段。因此，为了获得<code class="fe nl nm nn nb b">DayOfWeek</code>列，我们通过<code class="fe nl nm nn nb b">Date</code>和<code class="fe nl nm nn nb b">DayOfWeek</code>列以及结果<code class="fe nl nm nn nb b">DataFrameGroupBy</code>实例上的<code class="fe nl nm nn nb b">sum</code>进行分组。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="d937" class="nf lu iq nb b gy ng nh l ni nj">travel_df_by_date = travel_df.groupby(['Date','DayOfWeek'])<br/>travel_df_by_date_combined = travel_df_by_date.sum()</span></pre><p id="1058" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nl nm nn nb b">travel_df_by_date_combined</code>的<code class="fe nl nm nn nb b">head</code>显示</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi or"><img src="../Images/9f8e61ec7b43d2ccb2de77584908079a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5zT-3UBGAUX6G1I4XCNJAg.png"/></div></div></figure><p id="4c0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们现在可以看到 DataFrame 现在有一些不正确的数据。按日期分组时，<code class="fe nl nm nn nb b">Distance</code>、<code class="fe nl nm nn nb b">TotalTime</code>和<code class="fe nl nm nn nb b">MovingTime</code>列的总和是正确的。但是通过使用<code class="fe nl nm nn nb b">sum</code>方法，我们还添加了<code class="fe nl nm nn nb b">MaxSpeed</code>、<code class="fe nl nm nn nb b">AvgSpeed</code>、<code class="fe nl nm nn nb b">AvgMovingSpeed</code>和<code class="fe nl nm nn nb b">FuelEconomy</code>列，这是不正确的。<code class="fe nl nm nn nb b">MaxSpeed</code>应包含特定日期各行的最大值，其他列应包含各行的平均值。所以，让我们修改一下。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="da06" class="nf lu iq nb b gy ng nh l ni nj">travel_df_by_date_combined['MaxSpeed'] = travel_df_by_date['MaxSpeed'].max() travel_df_by_date_combined['AvgSpeed'] = travel_df_by_date['AvgSpeed'].mean() travel_df_by_date_combined['AvgMovingSpeed'] = travel_df_by_date['AvgMovingSpeed'].mean() travel_df_by_date_combined['FuelEconomy'] = travel_df_by_date['FuelEconomy'].mean()</span></pre><p id="7754" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果我们检查一下<code class="fe nl nm nn nb b">travel_df_by_date_combined</code>的<code class="fe nl nm nn nb b">head</code>，我们会看到</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi os"><img src="../Images/b60e90d2132287a3f216ff7d92185b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KtpwrrpameZUtZdX8jQuEA.png"/></div></div></figure><p id="121b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了。我们现在有了所有所需列的正确数据。现在让我们检查数据框<code class="fe nl nm nn nb b">travel_df_by_date_combined</code>上的<code class="fe nl nm nn nb b">info</code>。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="8f04" class="nf lu iq nb b gy ng nh l ni nj">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>MultiIndex: 111 entries, (1/2/2012, Monday) to (9/8/2011, Thursday)<br/>Data columns (total 7 columns):<br/>Distance          111 non-null float64<br/>MaxSpeed          111 non-null float64<br/>AvgSpeed          111 non-null float64<br/>AvgMovingSpeed    111 non-null float64<br/>FuelEconomy       111 non-null float64<br/>TotalTime         111 non-null float64<br/>MovingTime        111 non-null float64<br/>dtypes: float64(7)<br/>memory usage: 7.4+ KB</span></pre><p id="2125" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过<code class="fe nl nm nn nb b">Date</code>和<code class="fe nl nm nn nb b">DayOfWeek</code>列进行分组产生了一个多索引数据帧，如 head 和 info 方法所示。但是我们希望<code class="fe nl nm nn nb b">DayOfWeek</code>是一个常规列，而不是索引。因此，我们首先重置索引，使数据帧的索引变成普通整数。在下一步中，我们将<code class="fe nl nm nn nb b">Date</code>列设置回索引。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="f4a1" class="nf lu iq nb b gy ng nh l ni nj">travel_df_by_date_combined.reset_index(inplace=True)</span></pre><p id="3ea3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一次我们使用<code class="fe nl nm nn nb b">tail</code>方法查看最后 5 行，并且看到<code class="fe nl nm nn nb b">Date</code>和<code class="fe nl nm nn nb b">DayOfWeek</code>都被设置为常规列。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="f4eb" class="nf lu iq nb b gy ng nh l ni nj">travel_df_by_date_combined.tail()</span></pre><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ot"><img src="../Images/8a651e38357a48880261dddff408a3c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1_wcVH9qm5Z7ZRZvg7Fh2A.png"/></div></div></figure><p id="2864" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将<code class="fe nl nm nn nb b">Date</code>列设置为索引。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="ba78" class="nf lu iq nb b gy ng nh l ni nj">travel_df_by_date_combined.set_index(['Date'],inplace=True)</span></pre><p id="90d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nl nm nn nb b">travel_df_by_date_combined</code>中的<code class="fe nl nm nn nb b">head</code>现在显示</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ou"><img src="../Images/ba9cc7e5e14e08a00583e7245e4b38b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q_gPPtZdM5-NUGFnc830rw.png"/></div></div></figure><p id="a508" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完美。我们将<code class="fe nl nm nn nb b">Date</code>作为索引，我们还保留了<code class="fe nl nm nn nb b">DayOfWeek</code>列和所有其他数字列。每个日期都有一个条目。这是上面问题 b 的答案。</p><h2 id="5005" class="nf lu iq bd lv nt nu dn lz nv nw dp md ko nx ny mh ks nz oa ml kw ob oc mp od bi translated">这么多工作只为了一个简单的答案。</h2><p id="25a8" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">是的。那是一个相当大的过程。但是不用担心。到目前为止，我们一直在准备数据，以便能够回答上述所有问题。从这里开始，事情就非常简单了。我们已经做了所有的艰苦工作。现在是收获我们所播种的东西的时候了。</p><p id="d964" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们找出距离大于 90 但小于 100 的条目。为此，我们使用条件选择。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="46aa" class="nf lu iq nb b gy ng nh l ni nj">distance_above_ninety = travel_df_by_date_combined['Distance']&gt;90</span></pre><p id="03c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将导致<code class="fe nl nm nn nb b">distance_above_ninety</code>包含一系列布尔值。它的作用是，获取<code class="fe nl nm nn nb b">travel_df_by_date_combined[‘Distance’]</code>数据帧的每个条目，并检查它是否大于 90。如果是，它为结果序列中的相应条目设置<code class="fe nl nm nn nb b">True</code>；否则设置<code class="fe nl nm nn nb b">False</code>。请注意，该系列的索引将是<code class="fe nl nm nn nb b">Date</code>列。</p><p id="ae96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以发现</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="6198" class="nf lu iq nb b gy ng nh l ni nj">distance_below_hundred = travel_df_by_date_combined['Distance']&lt;100</span></pre><p id="7c55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以把这两个数列结合起来，找出距离大于 90 小于 100 的<code class="fe nl nm nn nb b">Distance</code>。但是我们不能像在 Python 中那样使用<code class="fe nl nm nn nb b"><em class="oj">and</em></code>操作符来组合<code class="fe nl nm nn nb b">distance_above_ninety</code>和<code class="fe nl nm nn nb b">distance_below_hundred</code>。这是因为<code class="fe nl nm nn nb b"><em class="oj">and</em></code>操作符只作用于两个布尔值，但是这里我们处理的是两个布尔值序列。使用<code class="fe nl nm nn nb b"><em class="oj">and</em></code>操作符会导致<strong class="kf ir">值错误:一个序列的真值是不明确的</strong>。为了找到一系列组合的真值，我们需要使用<code class="fe nl nm nn nb b"><em class="oj">&amp;</em></code>操作符。也就是我们用<code class="fe nl nm nn nb b">distance_above_ninety &amp; distance_below_hundred</code>。</p><p id="699b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结合条件选择，</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="e610" class="nf lu iq nb b gy ng nh l ni nj">ninety_to_hundred_df = travel_df_by_date_combined[distance_above_ninety &amp; distance_below_hundred]</span></pre><p id="340a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到一个数据帧，其中只有满足这两个条件的条目</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ov"><img src="../Images/8cfde72e401320e287e593df305a1ff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UUZuOCRoQrveLy-umJh-ew.png"/></div></div></figure><p id="3c77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到所有的距离都在 90 到 100 之间。这解决了我们的问题 c。我们可以使用这个数据帧来解决问题 d。在问题 d 中，我们需要做的就是从上面的数据帧中提取任意行的详细信息。让我们用<code class="fe nl nm nn nb b">loc</code>得到最后一个日期的<code class="fe nl nm nn nb b">Distance</code>和<code class="fe nl nm nn nb b">FuelEconomy</code>。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="cc7c" class="nf lu iq nb b gy ng nh l ni nj">ninety_to_hundred_df.loc[['8/26/2011'],['Distance','FuelEconomy']]</span></pre><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/fb68da2346a0b55359b3afe1a84d4144.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*yrc0qYiJnL3MIJhH4P0riw.png"/></div></figure><p id="e44a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于问题 e，我们再次使用组合条件选择来查找星期五平均移动速度高于 90 的条目。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="3986" class="nf lu iq nb b gy ng nh l ni nj">over_ninety_on_friday = travel_df_by_date_combined[(travel_df_by_date_combined['AvgMovingSpeed']&gt;90) &amp; (travel_df_by_date_combined['DayOfWeek']=='Friday')]</span></pre><p id="564c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和上面的条件选择一样。我们现在已经简单地在一行中写了所有的内容。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ox"><img src="../Images/c999f067bbdeaf0132931082ba3e1776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gD14BttipmhMmM-noRESiQ.png"/></div></div></figure><p id="cf07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有条目都是星期五的，每行的平均移动速度超过 90。</p><p id="d064" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用同样的方法来解决问题 f。这里，我们需要最大速度大于 135 或者燃油经济性小于 8 的条目。就像在<code class="fe nl nm nn nb b"><em class="oj">and</em></code>操作符的情况下，出于同样的原因，我们不能使用<code class="fe nl nm nn nb b"><em class="oj">or</em></code>操作符。相反，我们使用管道(|)运算符。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="7ec3" class="nf lu iq nb b gy ng nh l ni nj">max_speed_over_one_thirty_five_or_fuel_economy_below_eight = travel_df_by_date_combined[(travel_df_by_date_combined['MaxSpeed']&gt;135) | (travel_df_by_date_combined['FuelEconomy']&lt;8)]</span></pre><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ou"><img src="../Images/e77a62a1c53e45373726bd404df5551f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4cBgb69zVOPjicvKT0fJfw.png"/></div></div></figure><p id="0b54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这次我们有更多的行，因为只需要满足两个条件中的一个。有些条目的<code class="fe nl nm nn nb b">MaxSpeed</code>高于 135，有些条目的<code class="fe nl nm nn nb b">FuelEconomy</code>低于 8，有些条目两者都有。这就解决了问题 f。</p><p id="98f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们来看看一周中每一天的一些统计信息。DataFrameGroupBy 实例上应用的<code class="fe nl nm nn nb b">sum</code>方法提供了每一天中每一列的总和。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="455d" class="nf lu iq nb b gy ng nh l ni nj">travel_df.groupby(['DayOfWeek']).sum()</span></pre><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oy"><img src="../Images/a1b281f071ede8bf9b8abbeec660f18b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oLog_xz9_wvoCAzcc7etMw.png"/></div></div></figure><p id="7aa6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，这些列再次包含不正确的<code class="fe nl nm nn nb b">MaxSpeed</code>、<code class="fe nl nm nn nb b">AvgSpeed</code>、<code class="fe nl nm nn nb b">AvgMovingSpeed</code>和<code class="fe nl nm nn nb b">FuelEconomy</code>值。但是这里我们只是在演示<code class="fe nl nm nn nb b">sum</code>方法的作用。</p><p id="2452" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以沿着各个日行找到每一列的<code class="fe nl nm nn nb b">max</code>值。<code class="fe nl nm nn nb b">max</code>方法也适用于非数字列。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="0ed0" class="nf lu iq nb b gy ng nh l ni nj">travel_df.groupby(['DayOfWeek']).max()</span></pre><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oz"><img src="../Images/7dbb562d4ce23466364781f9614124b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tAxulSA3T1L0cQiSni_NrA.png"/></div></div></figure><p id="fed5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也可以使用 describe 方法获得所有细节，如平均值、标准差、四分位数等。立刻。下面我们对其中一列<code class="fe nl nm nn nb b">AvgMovingSpeed</code>使用 describe 方法。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="3655" class="nf lu iq nb b gy ng nh l ni nj">travel_df.groupby(['DayOfWeek'])['AvgMovingSpeed'].describe()</span></pre><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pa"><img src="../Images/6ecaf0ec1ee288eb4f45ec794c948c80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vhDAWF-NmMpPmMhOGm_ejQ.png"/></div></div></figure><p id="a08e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这解决了我们的最后一个问题。</p><h2 id="e07b" class="nf lu iq bd lv nt nu dn lz nv nw dp md ko nx ny mh ks nz oa ml kw ob oc mp od bi translated">我头疼。</h2><p id="eba4" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">我知道这很难接受。但是 DataFrame 是一个非常重要的主题，一旦你熟悉了它，你就可以选择你感兴趣的任何数据集，然后找到对数据的所需见解。同样，这篇文章没有涵盖 DataFrame 的所有方法和属性。这篇文章中所采取的一系列步骤可能不是解决问题的唯一途径。也许你可以找到另一种方法。更有效的方法。你需要的只是练习。只要像阿宝一样坚持下去，你也能成为功夫熊猫。</p><p id="f054" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下一篇文章中，我们将利用我们目前所学的知识，以一种更紧凑、更具视觉吸引力的方式将结果可视化。我们将使用 Matplotlib 包，特别是 pyplot 模块，最终用图形和图表来表示文本、数字和表格。</p><div class="lb lc gp gr ld le"><a rel="noopener follow" target="_blank" href="/sprinting-into-the-visualization-track-part-1-matplotlib-6c069ac91e40"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">冲刺可视化轨道(第 1 部分):Matplotlib</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">我们已经用 DataFrame 走了很久，</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">towardsdatascience.com</p></div></div><div class="ln l"><div class="pb l lp lq lr ln ls jw le"/></div></div></a></div></div></div>    
</body>
</html>