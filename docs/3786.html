<html>
<head>
<title>Jupyter tools to increase productivity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高生产力的 Jupyter 工具</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/jupyter-tools-to-increase-productivity-7b3c6b90be09?source=collection_archive---------1-----------------------#2018-06-18">https://towardsdatascience.com/jupyter-tools-to-increase-productivity-7b3c6b90be09?source=collection_archive---------1-----------------------#2018-06-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/50437270aa7125e49e4f62b9841530be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g3L9F6AO-jUW-QuQRFI3JA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/photos/vS7LVkPyXJU?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Philip Swinburn</a> on <a class="ae kc" href="https://unsplash.com/search/photos/tools?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="kd ke kf"><p id="dd77" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><em class="iq">“如果你唯一的工具是一把锤子，你会把所有的问题都看成钉子。”</em></p><p id="67e5" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><em class="iq">亚伯拉罕·马斯洛</em></p></blockquote><p id="76a5" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">像许多其他数据科学家一样，Jupyter notebook 是我的数据科学工具包中不可或缺的一部分。它易于使用，功能强大得令人难以置信。在这篇文章中，我将记录一些可用的扩展和特性，我认为每个使用 Jupyter 的人都应该熟悉它们。</p><p id="e576" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">但是等等，这难道不是旧东西吗？既然 JupyterLab 刚刚出现，我们现在应该对它感到满意吗？</p><p id="7fbc" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">JupyterLab 是 Jupyter 笔记本电脑的发展，引入了一些期待已久的功能，然而它目前处于测试阶段，当我试用它时，发现许多为 JupyterLab 开发的很酷的扩展由于版本兼容性问题不能很好地工作。所以我想，即使 JupyterLab 是未来，至少在不久的将来，我还是会坚持使用经典笔记本几个月。</p><h1 id="2e01" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">Jupyter contrib nbextensions</h1><p id="3f96" class="pw-post-body-paragraph kg kh iq kj b kk mg km kn ko mh kq kr lf mi ku kv lg mj ky kz lh mk lc ld le ij bi translated">你知道 Jupyter 笔记本有扩展吗！确实有，而且非常有用！</p><p id="dc53" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">安装</em></p><p id="cb6b" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><a class="ae kc" href="https://github.com/ipython-contrib/jupyter_contrib_nbextensions" rel="noopener ugc nofollow" target="_blank">官方 github repo </a>有安装的所有细节，所以我不会重复这些。但是，如果你懒得去过，这里是 TLDR 版本的基本步骤:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="f52f" class="mu lj iq mq b gy mv mw l mx my">pip install jupyter_contrib_nbextensions</span><span id="2c28" class="mu lj iq mq b gy mz mw l mx my">pip install https://github.com/ipython-contrib/jupyter_contrib_nbextensions/tarball/master</span><span id="a38b" class="mu lj iq mq b gy mz mw l mx my">jupyter contrib nbextension install --user</span></pre><p id="91d9" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">还要安装扩展配置器，以便轻松切换扩展:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="a3c2" class="mu lj iq mq b gy mv mw l mx my">pip install jupyter_nbextensions_configurator</span><span id="a4bf" class="mu lj iq mq b gy mz mw l mx my">jupyter nbextensions_configurator enable --user</span></pre><p id="b62e" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">你完了！</p><p id="1200" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">刷新 Jupyter 主页，您应该能够看到类似这样的内容:</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/3d8a2ea50f88b22f91c3ed72631d2c07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0yy5_nplpfMXuqexaL6Slw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">nbextensions tab</figcaption></figure><p id="0dbc" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">以下是一些我认为有用的 nbextensions，并简要描述了它们的功能:</p><ol class=""><li id="1c4e" class="nb nc iq kj b kk kl ko kp lf nd lg ne lh nf le ng nh ni nj bi translated"><em class="ki">目录(2) </em>:根据笔记本的表头单元格自动创建一个目录。<code class="fe nk nl nm mq b">Display Table of Contents as a sidebar</code>选项创建了一个 TOC 作为侧边栏，有助于保持上下文和浏览笔记本。</li></ol><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/4c34b209ea428860f373b8b6c8d4be9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ijytWCYz2jhUsZlmFLNEfA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Table of contents</figcaption></figure><p id="2d1c" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki"> 2。可折叠的标题</em>:这个和 toc2 一起可以很好的卷起笔记本中你不想在特定时间关注的部分。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/a9cc3629c501a68d0917341cfcc6a5be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PJSgnV-R4sloJAYY5LN7-g.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Collapsible heading</figcaption></figure><p id="5481" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki"> 3。代码折叠</em>:您可以通过折叠函数定义和长代码块来减小单元格的大小。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/48ef6c4c06dea78baeb5ed17b70db714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Ui23HiD2D1TdmYtVPA_3lw.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">codefolding</figcaption></figure><p id="c25f" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki"> 4。execute time</em>:<code class="fe nk nl nm mq b">%%time</code>单元格魔术函数对于检查运行时非常有用。但是有了 ExecuteTime，所有代码单元格的运行时都显示在左下角，所以你不需要记得使用单元格魔术。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/ffd0e4128c7c15c7593827828e36180b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*ol-ZB7CXzuai4TfwQkW-cA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">execute time</figcaption></figure><p id="f624" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki"> 5。Gist-it </em>:非常适合在 Github 上创建 Gist。为什么是 gist？实验时可以在不同状态下保存同一个笔记本的不同版本。此外，gists 更容易共享和引用。</p><p id="ae68" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki"> 6。隐藏所有输入</em>:当你需要编码来生成和输出，但是不需要显示代码的时候(为了简洁)，这对于整理一个笔记本来演示是很棒的。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="7344" class="li lj iq bd lk ll ny ln lo lp nz lr ls lt oa lv lw lx ob lz ma mb oc md me mf bi translated">Jupyter 魔法函数</h1><p id="6e3e" class="pw-post-body-paragraph kg kh iq kj b kk mg km kn ko mh kq kr lf mi ku kv lg mj ky kz lh mk lc ld le ij bi translated">Jupyter 中有很多神奇的功能。对于 Ipython 内核，这里是到文档的<a class="ae kc" href="http://ipython.readthedocs.io/en/stable/interactive/magics.html" rel="noopener ugc nofollow" target="_blank">链接。</a></p><p id="1d40" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">以下是一些我认为特别有用的线条魔术功能:</p><ol class=""><li id="9a8b" class="nb nc iq kj b kk kl ko kp lf nd lg ne lh nf le ng nh ni nj bi translated"><code class="fe nk nl nm mq b">%cd &lt;path&gt;</code>:在笔记本中切换工作目录的快捷方式。</li><li id="0fa1" class="nb nc iq kj b kk od ko oe lf of lg og lh oh le ng nh ni nj bi translated"><code class="fe nk nl nm mq b">%autoreload</code>:在每个使用脚本/项目的笔记本上使用。您对它们所做的更改将自动重新加载到 jupyter 上下文中。</li></ol><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="636d" class="mu lj iq mq b gy mv mw l mx my">%reload_ext autoreload<br/>%autoreload 2</span></pre><ol class=""><li id="1253" class="nb nc iq kj b kk kl ko kp lf nd lg ne lh nf le ng nh ni nj bi translated"><code class="fe nk nl nm mq b">%timeit</code>:多次运行代码行，并打印代码运行时的度量。</li><li id="8f30" class="nb nc iq kj b kk od ko oe lf of lg og lh oh le ng nh ni nj bi translated"><code class="fe nk nl nm mq b">%lprun and %mprun</code>:python 的行分析器和内存分析器。非常适合优化代码:</li></ol><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/50fac90d8d1f50f47beb79e8d807f4d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*UvtoHHO9vO3jMzUMN1I73w.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">line profiler in action</figcaption></figure><p id="19d6" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">要使用 line_profiler，请使用 pip 安装它:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="193e" class="mu lj iq mq b gy mv mw l mx my">pip install line-profiler<br/>pip install memory_profiler</span></pre><p id="696b" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">然后加载扩展:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="339d" class="mu lj iq mq b gy mv mw l mx my">%load_ext line_profiler<br/>%load_ext memory_profiler</span></pre><ol class=""><li id="0b9b" class="nb nc iq kj b kk kl ko kp lf nd lg ne lh nf le ng nh ni nj bi translated"><code class="fe nk nl nm mq b">!</code>或<code class="fe nk nl nm mq b">%%bash</code> : Bash 命令在终端上很容易使用，但是如果你有一系列需要重复运行的命令，那么把它们放在笔记本上就更好了！一行之前的<code class="fe nk nl nm mq b">!</code>将在 bash 中执行该行。例如:</li></ol><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="986d" class="mu lj iq mq b gy mv mw l mx my">!ls -lht</span></pre><p id="421b" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">如果您使用 AWS 之类的云服务，并且您有多个 cli 命令，将它们放在一个笔记本中会使事情变得容易得多，因为您有可搜索的命令历史和结果。</p><p id="9fa2" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">注意:由于某种原因，我发现使用单元格魔术<code class="fe nk nl nm mq b">%%bash</code>会在执行完成后打印输出<em class="ki">。这对于大多数用例来说是好的，但是假设您正在检查 docker 日志，您可能很想检查进度。</em></p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="7647" class="li lj iq bd lk ll ny ln lo lp nz lr ls lt oa lv lw lx ob lz ma mb oc md me mf bi translated">临时演员</h1><p id="a5f5" class="pw-post-body-paragraph kg kh iq kj b kk mg km kn ko mh kq kr lf mi ku kv lg mj ky kz lh mk lc ld le ij bi translated">Jupyter 还可以做很多其他很酷的事情，但我无法一一列举，只能列出一个简短的列表:</p><ol class=""><li id="b00c" class="nb nc iq kj b kk kl ko kp lf nd lg ne lh nf le ng nh ni nj bi translated"><em class="ki"> Jupyter 小部件:</em> Jupyter 支持小部件，也支持有用的<a class="ae kc" href="https://ipywidgets.readthedocs.io/en/latest/examples/Widget%20List.html" rel="noopener ugc nofollow" target="_blank">交互</a>甚至很酷的<a class="ae kc" href="http://jupyter.org/widgets" rel="noopener ugc nofollow" target="_blank">可视化</a>。交互小部件对于创建交互式笔记本来说是很棒的，我想如果你安装了 JupyterHub，它们会更棒，这样你就可以在笔记本上协作了。</li><li id="4f4d" class="nb nc iq kj b kk od ko oe lf of lg og lh oh le ng nh ni nj bi translated"><em class="ki">跨语言支持:</em>事实证明，Jupyter 实际上是一个缩写——Julia Python R，并且有许多不同语言的内核。。</li><li id="12aa" class="nb nc iq kj b kk od ko oe lf of lg og lh oh le ng nh ni nj bi translated"><em class="ki">调试:【Jupyter 笔记本有很多调试选项，哪一个最有效很大程度上取决于你如何编写代码。对我来说，由于我将大部分代码放在了<code class="fe nk nl nm mq b">.py</code>文件中，所以我使用 ipython 调试器来调试代码:</em></li></ol><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="1366" class="mu lj iq mq b gy mv mw l mx my">from IPython.core.debugger import set_trace</span><span id="709b" class="mu lj iq mq b gy mz mw l mx my">def func(x):<br/>	x = x+2<br/>	set_trace()<br/>	x = x-2<br/>	return x</span><span id="9440" class="mu lj iq mq b gy mz mw l mx my">func(2)</span></pre><p id="c8fd" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">这将弹出一个交互框来检查笔记本中的变量。</p><p id="4700" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">还有更容易使用的选项:</p><p id="3138" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">出现异常时打开调试器界面的<code class="fe nk nl nm mq b">%%pdb</code>单元魔术。</p><p id="a5d0" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">或者你可以在出现异常后立即运行<code class="fe nk nl nm mq b">%debug</code>行来检查堆栈。</p><p id="b36e" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">4.Jupyter 笔记本预览与 Vistual 工作室代码</p><p id="85e1" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">所以笔记本很棒，当你更有条理的时候，你可以用它做更多的事情。但是，笔记本的版本化仍然是个问题。这意味着你可能会为一个项目制作几十个笔记本，如果你想找到一些你在项目早期写的代码，你必须一个接一个地打开它们，或者试着记住 grep 的相关关键词。除了使用命名约定和利用文件夹结构之外，我没有解决版本控制问题的干净的解决方案，但是，对我来说，如果我可以预览笔记本而不必启动内核并等待它加载(特别是如果笔记本很大的话)，这是有帮助的。拯救的 Visual Studio 代码！这个方便的文本编辑器与 Sublime Text 非常相似，并且有一个方便的插件<code class="fe nk nl nm mq b">vscode-nbpreviewer</code>，它允许你在不启动内核的情况下打开笔记本，加载速度非常快。</p><p id="8bf5" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">使用 Visual Studio 代码的另一个好处是:spyder 喜欢脚本中的代码单元，因此您可以将代码从脚本发送到编辑器</p><p id="2359" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">此外，它是 Anaconda 的可选安装！</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="ee33" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">这是我目前所有的。随着我发现更多有用的东西，我会继续更新。感谢阅读！</p></div></div>    
</body>
</html>