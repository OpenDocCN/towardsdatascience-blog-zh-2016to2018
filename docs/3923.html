<html>
<head>
<title>Python Code for Identifying Seasonal Customers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于识别季节性客户的 Python 代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-code-for-identifying-seasonal-customers-4bd36dc7fcda?source=collection_archive---------5-----------------------#2018-07-01">https://towardsdatascience.com/python-code-for-identifying-seasonal-customers-4bd36dc7fcda?source=collection_archive---------5-----------------------#2018-07-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/528a43db452b9b3b4f614757f143ba28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SGnF7UCzkgH3hXf5O1HyqQ@2x.jpeg"/></div></div></figure><div class=""/><p id="dc6d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我以前写过如何使用时间序列来识别数据库中具有季节性使用模式的客户。如果你想详细了解，你可以在这里找到文章<a class="ae kz" href="http://www.kristenkehrer.com/seasonal-customer-time-series-analysis" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="3757" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您想长话短说:为了识别具有季节性使用模式的客户，我采用了按月汇总的 customer_id、月、年和使用数据，并按 id、年和月排序。我们只能评估与我们在一起至少 2 年的客户的季节性，以允许算法识别模式。所以数据(完全虚构，只是为了说明)看起来像这样:</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi la"><img src="../Images/6c5cf8d2e769acf98d0b22b0059f506f.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/0*eU6JyWFP2ns8tV7j"/></div></figure><p id="f060" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您会注意到数据中缺少了五月、八月、九月和十月。这意味着该客户在那几个月没有任何使用。因此，第一项任务是填补数据集中缺失的零。我把数据库里的数据拉进来，命名为“原创”。这里我没有提供连接数据库的代码，因为我们使用 Netezza SQL。</p><p id="c2de" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">代码如下(有些缩进对于较长的行是不正确的，抱歉！)🙂</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="1d39" class="lk ll je lg b gy lm ln l lo lp">import pandas as pa <br/>import numpy as np </span><span id="9352" class="lk ll je lg b gy lq ln l lo lp">## Outfile is just because we're going to export our results as a .csv to save them. </span><span id="83c8" class="lk ll je lg b gy lq ln l lo lp">outfile = '[put your file path here].csv' </span><span id="4e54" class="lk ll je lg b gy lq ln l lo lp">## Headings in the .csv that I'm going to output </span><span id="96f6" class="lk ll je lg b gy lq ln l lo lp">filledIn = pa.DataFrame(columns=['customer_id','yr','mnth','usage']) </span><span id="b894" class="lk ll je lg b gy lq ln l lo lp">##original was just the name of my dataframe with data </span><span id="a049" class="lk ll je lg b gy lq ln l lo lp">grouped = original.groupby(by='customer_id') <br/>def yearmonth_to_justmonth(year, month): <br/>     return year * 12 + month - 1 </span><span id="af3a" class="lk ll je lg b gy lq ln l lo lp">##Defining a function to fill in the zeros. </span><span id="82a9" class="lk ll je lg b gy lq ln l lo lp">def fillInForOwner(group): <br/>     min = group.head(1).iloc[0] <br/>     max = group.tail(1).iloc[0]       <br/>     minMonths = yearmonth_to_justmonth(min.yr, min.mnth) <br/>     maxMonths = yearmonth_to_justmonth(max.yr, max.mnth)<br/>     filled_index = pa.Index(np.arange(minMonths, maxMonths, 1),<br/>       name="filled_months") <br/>     group['months'] = group.yr * 12 + group.mnth - 1 <br/>     group = group.set_index('months') <br/>     group = group.reindex(filled_index) <br/>     group.customer_id = min.customer_id <br/>     group.yr = group.index // 12 group.mnth = group.index % 12 + 1<br/>     group.usage = np.where(group.usage.isnull(), 0,<br/>       group.usage).astype(int) <br/>     return group </span><span id="f59a" class="lk ll je lg b gy lq ln l lo lp">filledIn = grouped.apply(fillInForOwner) <br/>newIndex = pa.Index(np.arange(filledIn.customer_id.count())) </span><span id="b01f" class="lk ll je lg b gy lq ln l lo lp">## Printing out the results to a .csv <br/>filledIn = filledIn.set_index(newIndex) <br/>filledIn.to_csv(outfile)  </span><span id="aba9" class="lk ll je lg b gy lq ln l lo lp">## I also print results on the screen <br/>print(filledIn)</span></pre><p id="3e8e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我选择在 Python 中为时间序列部分运行 R。实际上，我遇到了一个值得一提的小问题。我在我的计算机上安装了 64 位和 32 位版本的 R，并指向还没有安装我的所有包的 R 版本(来自 Python)。尴尬的真相:我手动将文件从一个文件夹复制粘贴到另一个文件夹。我确信有一种更“正确”的方法，但是将它们复制并粘贴到目录中正确的文件夹是可行的。</p><p id="6ce7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有一个小问题，值得一提的是，用 Python 运行 R 代码并不是我尝试的第一种方法。您实际上可以使用 Python 语言来运行 R 代码，但是我很难做到这一点，所以我选择了 rpy2 路线。</p><p id="caff" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我导入 rpy2 来利用 Python 中的 R 代码。这些也是我需要的所有库。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6135" class="lk ll je lg b gy lm ln l lo lp">import rpy2 as r <br/>     from rpy2.robjects.packages import importr <br/>     from rpy2.robjects import r, pandas2ri, globalenv<br/>     pandas2ri.activate() </span><span id="0d88" class="lk ll je lg b gy lq ln l lo lp">base = importr('base') <br/>colorspace = importr('colorspace') <br/>forecast = importr('forecast') <br/>times = importr('timeSeries') <br/>stats = importr('stats')</span></pre><p id="b2e1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我逐一查看了每位顾客。我会找到他们的开始月份/年份和结束月份/年份，并为每个客户创建一个时间序列对象。我包含了一个 try/except 语句，因为我最初尝试在没有 try/except 语句的情况下运行它，在它已经运行了几个小时之后，它被一个客户卡住了，不太理想。</p><p id="8f9e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在创建了时间序列对象之后，我简单地询问 R 模型中是否有季节性成分，并打印出客户 id 以及它们是否是季节性的。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="f589" class="lk ll je lg b gy lm ln l lo lp"><br/>##Again, this is just for saving your results to a .csv <br/>outfile = '[put your file path here].csv' <br/>seasonal_output = pa.DataFrame(columns=['customer_id', 'seasonal']) </span><span id="577f" class="lk ll je lg b gy lq ln l lo lp">### Now we're going to loop through our customers <br/>for customerid, dataForCustomer in filledIn.groupby(by=['customer_id']): <br/>     startYear = dataForCustomer.head(1).iloc[0].yr <br/>     startMonth = dataForCustomer.head(1).iloc[0].mnth <br/>     endYear = dataForCustomer.tail(1).iloc[0].yr <br/>     endMonth = dataForCustomer.tail(1).iloc[0].mnth </span><span id="44e1" class="lk ll je lg b gy lq ln l lo lp">#Creating a time series object <br/>     customerTS = stats.ts(dataForOwner.SENDS.astype(int),<br/>          start=base.c(startYear,startMonth), <br/>          end=base.c(endYear, endMonth), frequency=12)<br/>     r.assign('customerTS', customerTS) </span><span id="b094" class="lk ll je lg b gy lq ln l lo lp">##Here comes the R code piece <br/>     try:  <br/>          seasonal = r(''' <br/>          fit&lt;-tbats(customerTS, seasonal.periods = 12, use.parallel<br/>          = TRUE) <br/>          fit$seasonal <br/>          ''') <br/>     except: <br/>          seasonal = 1 <br/>     seasonal_output = seasonal_output.append({'customer_id':<br/>          customerid, 'seasonal': seasonal}, ignore_index=True) <br/>     print(f' {customerid} | {seasonal} ') </span><span id="d95f" class="lk ll je lg b gy lq ln l lo lp">print(seasonal_output) <br/>seasonal_output.to_csv(outfile)</span></pre><p id="fbd8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个输出将成为我正在进行的聚类分析的一个特征。我还将做一些工作来确定每个客户的最小和最大使用月数，并将其存储在数据库中。很快，市场营销将能够利用这一点来开展更加个性化的活动。</p><p id="dbb9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想订阅我未来的文章，你可以在这里订阅。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="061b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ly">原载于 2018 年 7 月 1 日</em><a class="ae kz" href="https://datamovesme.com/2018/07/01/seasonality-python-code/" rel="noopener ugc nofollow" target="_blank"><em class="ly">【datamovesme.com】</em></a><em class="ly">。</em></p></div></div>    
</body>
</html>