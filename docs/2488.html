<html>
<head>
<title>Python Basics for Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学的Python基础</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-basics-for-data-science-6a6c987f2755?source=collection_archive---------1-----------------------#2018-02-01">https://towardsdatascience.com/python-basics-for-data-science-6a6c987f2755?source=collection_archive---------1-----------------------#2018-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/66c20f1d0a5a92f4b4ad2daadb30b490.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7EUX9QIjq2x1JyFKcjhXsA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Source: <a class="ae kc" href="https://www.quora.com/Can-you-suggest-some-good-books-websites-for-learning-Python-for-a-layman" rel="noopener ugc nofollow" target="_blank">https://www.quora.com/Can-you-suggest-some-good-books-websites-for-learning-Python-for-a-layman</a></figcaption></figure><h1 id="7464" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Python数据类型</h1><p id="1c30" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在Python中，我们有许多数据类型。最常见的有float(浮点)、int(整数)、str(字符串)、bool(布尔)、list、dict(字典)。</p><ul class=""><li id="2c2e" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly mg mh mi mj bi translated">浮点数-用于实数。</li><li id="a366" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">int——用于整数。</li><li id="1a7f" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">str -用于文本。我们可以用单引号<code class="fe mp mq mr ms b">'value'</code>，双引号<code class="fe mp mq mr ms b">"value"</code>，或者三引号<code class="fe mp mq mr ms b">"""value"""</code>来定义字符串。用三重引号括起来的字符串可以在多行上，新行将包含在变量值中。它们也用于编写函数文档。</li><li id="9187" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">bool -用于真值。用于对数据执行过滤操作。</li><li id="56a0" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">list -用于存储值的集合。</li><li id="0107" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">dict -用来存储一个键值对。</li></ul><p id="57ee" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">我们可以使用<code class="fe mp mq mr ms b">type(variable_name)</code>函数来检查特定变量的类型。Python中的运算符根据变量的类型有不同的行为，并且每种类型都有不同的内置方法。</p><p id="d207" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">这里我们可以看一些用Python创建浮点、整数、字符串和布尔值的例子。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="a308" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Python列表</h1><p id="2182" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Python列表是一种基本的序列类型。我们可以使用这种类型来存储值的集合。一个列表可以包含任何类型的值。一个列表可能包含另一个值的嵌套列表。这并不常用，但是您可以拥有一个混合了Python类型的列表。您可以使用方括号创建一个新的，如下所示:</p><p id="da02" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated"><code class="fe mp mq mr ms b">fruits = ["pineapple", "apple", "lemon", "strawberry", "orange", "kiwi"]</code></p><h2 id="e372" class="nc ke iq bd kf nd ne dn kj nf ng dp kn lm nh ni kr lq nj nk kv lu nl nm kz nn bi translated">子集列表</h2><p id="abda" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">您可以使用索引从列表中获取一个或多个元素。在Python中，索引从<code class="fe mp mq mr ms b">0.</code>开始，因此列表中的第一个元素将有一个索引<code class="fe mp mq mr ms b">0</code>。我们也可以使用负索引来访问元素。列表中的最后一个元素将有一个索引<code class="fe mp mq mr ms b">-1</code>，最后一个元素之前的元素将有一个索引<code class="fe mp mq mr ms b">-2</code>，依此类推。Python中还有一个叫做<strong class="ld ir">列表切片</strong>的东西，可以用来从一个列表中获取多个元素。我们可以这样用:<code class="fe mp mq mr ms b">sliceable[start_index:end_index:step].</code></p><ul class=""><li id="b202" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly mg mh mi mj bi translated"><code class="fe mp mq mr ms b">start_index</code>是切片的起始索引，该索引处的元素将包含在结果中，默认值为<code class="fe mp mq mr ms b">0</code>。</li><li id="e1d3" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated"><code class="fe mp mq mr ms b">end_index</code>是切片的结束索引，该索引处的元素将<strong class="ld ir">不包含在结果中</strong>，默认值为<code class="fe mp mq mr ms b">length of the list</code>。此外，如果步长为负，默认值可以是<code class="fe mp mq mr ms b">- length of the list -1</code>。如果跳过这一步，您将获得从开始索引到结尾的所有元素。</li><li id="2875" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated"><code class="fe mp mq mr ms b">step</code>是指数增加的量，<br/>默认值为<code class="fe mp mq mr ms b">1</code>。如果我们为步长设置一个负值，我们将向后移动。</li></ul><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="3916" class="nc ke iq bd kf nd ne dn kj nf ng dp kn lm nh ni kr lq nj nk kv lu nl nm kz nn bi translated">列表操作</h2><ul class=""><li id="b899" class="lz ma iq ld b le lf li lj lm no lq np lu nq ly mg mh mi mj bi translated">我们可以使用<code class="fe mp mq mr ms b">append</code>方法或<code class="fe mp mq mr ms b">plus operator</code>向列表中添加一个或多个元素。如果在两个列表上使用加号运算符，Python将给出两个列表内容的新列表。</li><li id="24ae" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">我们可以使用已经用于索引和列表切片的方括号将一个或多个元素更改为list。</li><li id="40ba" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">我们可以用<code class="fe mp mq mr ms b">remove(value)</code>方法从列表中删除一个元素。此方法将删除带有传递值的列表的第一个元素。</li></ul><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="6b4e" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">理解Python中列表的幕后工作方式很重要。当你创建一个新的列表<code class="fe mp mq mr ms b">my_list</code>时，你将列表存储在你的计算机内存中，列表的地址存储在<code class="fe mp mq mr ms b">my_list</code>变量中。变量<code class="fe mp mq mr ms b">my_list</code>不包含列表中的元素。它包含对列表的引用。如果我们像这样复制一个只有等号的列表<code class="fe mp mq mr ms b">my_list_copy = my_list</code>，你将在<code class="fe mp mq mr ms b">my_list_copy</code>变量中复制引用，而不是列表值。所以，如果你想复制实际值，你可以使用<code class="fe mp mq mr ms b">list(my_list)</code>函数或切片<code class="fe mp mq mr ms b">[:]</code>。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="5c62" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Python词典</h1><p id="ea53" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">字典用于存储<strong class="ld ir">键值对</strong>。当你想用<strong class="ld ir">唯一键</strong>索引你的值时，它们会很有帮助。在Python中，你可以使用<strong class="ld ir">花括号</strong>创建一个字典。此外，键和值由冒号<strong class="ld ir">分隔。如果我们想得到给定键的值，我们可以这样做:<code class="fe mp mq mr ms b">our_dict[key]</code>。</strong></p><h2 id="d159" class="nc ke iq bd kf nd ne dn kj nf ng dp kn lm nh ni kr lq nj nk kv lu nl nm kz nn bi translated">字典与列表</h2><p id="a0f6" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们看一个例子，将列表和字典进行比较。假设我们有一些电影，你想为它们存储收视率。此外，我们希望通过电影名称快速访问电影的分级。我们可以通过使用两个列表或一本字典来做到这一点。在示例中,<code class="fe mp mq mr ms b">movies.index(“Ex Machina”)</code>代码返回“ex玛奇纳”电影的索引。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Movie rating using lists.</figcaption></figure><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Movie ratings using a dictionary.</figcaption></figure><p id="b36f" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">在这种情况下，使用字典是一种更直观和方便的方式来表示评级。</p><h2 id="12e9" class="nc ke iq bd kf nd ne dn kj nf ng dp kn lm nh ni kr lq nj nk kv lu nl nm kz nn bi translated">字典操作</h2><p id="4ad9" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们可以<strong class="ld ir">添加</strong>、<strong class="ld ir">更新</strong>、<strong class="ld ir">从我们的字典中删除</strong>数据。当我们想要添加或更新数据时，我们可以简单地使用这个代码<code class="fe mp mq mr ms b">our_dict[key] = value</code>。当我们想要删除一个键-值对时，我们这样做<code class="fe mp mq mr ms b">del(our_dict[key])</code>。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="0054" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">我们还可以像这样检查给定的键是否在我们的字典中:<code class="fe mp mq mr ms b">key in our_dict</code>。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="70ce" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">功能</h1><p id="df8c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">函数是解决特定任务的一段可重用代码。我们可以像这样使用<code class="fe mp mq mr ms b">def</code>关键字来编写函数:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b707" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">但是Python中有很多内置函数，比如<code class="fe mp mq mr ms b">max(iterable [, key]), </code>、<code class="fe mp mq mr ms b">min(iterable [, key])</code>、<code class="fe mp mq mr ms b">type(object)</code>、<code class="fe mp mq mr ms b">round(number [, ndigits])</code>等。因此，在许多情况下，当我们需要一个函数来解决一个给定的任务时，我们可以研究一个内置的函数来解决这个任务或者一个Python包来解决这个问题。我们不必“<a class="ae kc" href="https://en.wikipedia.org/wiki/Reinventing_the_wheel" rel="noopener ugc nofollow" target="_blank">多此一举</a>”。</p><p id="8d75" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">大多数函数接受一些输入并返回一些输出。这些函数有参数，Python将函数调用中传递的输入与参数匹配。如果一个参数用方括号括起来，那么它就是可选的。</p><p id="8160" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">我们可以使用函数<code class="fe mp mq mr ms b">help([object])</code>或<code class="fe mp mq mr ms b">?function_name</code>来查看任何函数的文档。如果我们使用Jupyter Notebook，<code class="fe mp mq mr ms b">help</code>函数将显示当前单元格中的文档，而第二个选项将显示页面中的文档。</p><h1 id="ac88" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">方法</h1><p id="4533" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们已经看到，我们有字符串，浮点，整数，布尔，等等。在Python中。这些数据结构的每一个都是一个对象。方法是根据对象类型对给定对象可用的函数。因此，每个对象都有一个特定的类型和一组依赖于该类型的方法。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="3b91" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">不同类型的对象可以有相同名称的方法。根据对象的类型，方法有不同的行为。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="cef1" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">小心！一些方法可以改变它们被调用的对象。例如，在列表类型上调用的<code class="fe mp mq mr ms b">append()</code>方法。</p><h1 id="2ab5" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">包装</h1><p id="2275" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">模块是包含Python定义和语句的文件。模块指定了解决特定问题的函数、方法和新的Python类型。</p><p id="7a4f" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">包是目录中模块的集合。Python有许多可用的包，涵盖了不同的问题。比如“NumPy”、“matplotlib”、“seaborn”、“scikit-learn”都是非常著名的数据科学包。</p><ul class=""><li id="de87" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly mg mh mi mj bi translated">“NumPy”用于高效地处理数组</li><li id="1957" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">“matplotlib”和“seaborn”是用于数据可视化的流行库</li><li id="2090" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">“scikit-learn”是一个强大的机器学习库</li></ul><p id="6a4b" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">默认情况下，Python中有一些可用的包，但也有很多我们需要但默认情况下没有的包。如果我们想使用某个包，我们必须已经安装了它，或者只是使用pip(Python的包维护系统)来安装它。</p><p id="6128" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">然而，还有一种东西叫做“蟒蛇”。</p><blockquote class="nr ns nt"><p id="3967" class="lb lc nu ld b le mb lg lh li mc lk ll nv mt lo lp nw mu ls lt nx mv lw lx ly ij bi translated">Anaconda发行版是一个免费的、易于安装的包管理器、环境管理器和Python发行版，包含1，000多个开源包，并有免费的社区支持。</p></blockquote><p id="4feb" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">所以，如果你不想安装很多包，我会推荐你使用“Anaconda”。这个发行版中有这么多有用的包。</p><h2 id="38a8" class="nc ke iq bd kf nd ne dn kj nf ng dp kn lm nh ni kr lq nj nk kv lu nl nm kz nn bi translated">导入报表</h2><p id="cbf2" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">一旦安装了所需的包，就可以将它们导入到Python文件中。我们可以从中导入整个包、子模块或特定功能。此外，我们可以为包添加别名。从下面的例子中，我们可以看到导入语句的不同方式。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Simple Import Statement</figcaption></figure><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Import statement With an Alias</figcaption></figure><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Import Submodule From a Package With an Alias</figcaption></figure><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Import Only One Function From a Package</figcaption></figure><p id="ead5" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">我们也可以做这样的事情<code class="fe mp mq mr ms b">from numpy import *</code>。这里的星号表示从该模块导入所有内容。这个import语句在当前名称空间中创建对由<code class="fe mp mq mr ms b">numpy</code>模块定义的所有公共对象的引用。换句话说，我们可以使用<code class="fe mp mq mr ms b">numpy</code>中所有可用的函数，只使用不带前缀的名字。例如，现在我们可以使用NumPy的绝对函数，如<code class="fe mp mq mr ms b">absolute()</code>而不是<code class="fe mp mq mr ms b">numpy.absolute()</code>。<br/>但是，我不建议您使用它，因为:</p><ul class=""><li id="3e30" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly mg mh mi mj bi translated">如果我们像那样从一些模块中导入所有的函数，那么当前的名称空间将会充满如此多的函数，如果有人查看我们的代码，他或她可能会搞不清哪个包是特定的函数。</li><li id="0186" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">如果两个模块有一个同名的函数，第二个导入将覆盖第一个的函数。</li></ul><h1 id="e885" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">NumPy</h1><p id="6765" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">NumPy是使用Python进行科学计算的基础包。它非常快而且容易使用。这个软件包帮助我们逐元素地进行计算。</p><p id="e9c5" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">常规的Python列表不知道如何对元素进行操作。当然，我们可以使用Python列表，但是它们很慢，并且我们需要更多的代码来实现想要的结果。在大多数情况下，更好的决定是使用<code class="fe mp mq mr ms b">NumPy</code>。</p><p id="f686" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">与常规Python列表不同，NumPy数组总是只有一种类型。如果我们将不同类型的数组传递给<code class="fe mp mq mr ms b">np.array()</code>，我们可以使用参数<code class="fe mp mq mr ms b">dtype</code>选择想要的类型。如果未给定此参数，则类型将被确定为保存对象所需的最小类型。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">NumPy Array — Type Converting</figcaption></figure><p id="3980" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">NumPy数组自带属性和方法。还记得Python中的操作符对不同的数据类型有不同的行为吗？在NumPy中，操作符的行为是基于元素的。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Operators on NumPy Array</figcaption></figure><p id="d692" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">如果我们检查NumPy数组的类型，结果将是<code class="fe mp mq mr ms b">numpy.ndarray</code>。Ndarray表示n维数组。在上面的例子中，我们使用了一维数组，但是没有什么可以阻止我们制作2维、3维、4维或更多维的数组。我们可以在一个数组上做子集化，与这个数组的维数无关。我将给你们展示一些二维数组的例子。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Subsetting 2-dimensional arrays</figcaption></figure><p id="c00a" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">如果我们想知道数组有多少个维度，每个维度有多少个元素，我们可以使用<code class="fe mp mq mr ms b">shape</code>属性。对于二维数组，元组的第一个元素是行数，第二个元素是列数。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">NumPy Shape Attribute</figcaption></figure><h2 id="bfb9" class="nc ke iq bd kf nd ne dn kj nf ng dp kn lm nh ni kr lq nj nk kv lu nl nm kz nn bi translated">基本统计</h2><p id="3628" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">分析数据的第一步是熟悉数据。NumPy有很多方法可以帮助我们做到这一点。我们将看到一些对数据进行统计的基本方法。</p><ul class=""><li id="7c8f" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly mg mh mi mj bi translated"><code class="fe mp mq mr ms b">np.mean()</code> -返回算术平均值(元素之和除以元素长度)。</li><li id="ac08" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated"><code class="fe mp mq mr ms b">np.median()</code> -返回中间值(传递的数组的排序副本的中间值，如果数组的长度是偶数-将计算两个中间值的平均值)</li><li id="3e99" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated"><code class="fe mp mq mr ms b">np.corrcoef()</code> -返回一个相关矩阵。当我们想知道数据集中的两个变量之间，或者换句话说，两个长度相同的数组之间，是否存在相关性时，这个函数非常有用。</li><li id="fefa" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated"><code class="fe mp mq mr ms b">np.std()</code> -返回标准偏差</li></ul><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Generating Basic Statistics using NumPy</figcaption></figure><p id="dbfc" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">从上面的例子中，我们可以看到学习时间和成绩之间有很高的相关性。<br/>同样，我们可以看到:</p><ul class=""><li id="9442" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly mg mh mi mj bi translated">学习时间的平均值为4.6小时</li><li id="d496" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">学习时间的中位数是4.0</li><li id="4c52" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">学习时间的标准偏差是3.2</li></ul><p id="bd51" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">NumPy也有一些基本的函数，如<code class="fe mp mq mr ms b">np.sort()</code>和<code class="fe mp mq mr ms b">np.sum()</code>，它们也存在于基本的Python列表中。这里需要注意的一点是，NumPy在数组中强制使用单一类型，这样可以加快计算速度。</p><h1 id="78b2" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">练习</h1><p id="35ed" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我已经准备了一些练习，包括子集，元素操作和基本统计。如果你愿意，你可以试着解决它们。</p><ul class=""><li id="ca17" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly mg mh mi mj bi translated"><a class="ae kc" href="https://gist.github.com/Ventsislav-Yordanov/fb14e1c52a2b4d18422dc7075d5a09cb" rel="noopener ugc nofollow" target="_blank">子集化Python列表</a></li><li id="9d69" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated"><a class="ae kc" href="https://gist.github.com/Ventsislav-Yordanov/3ef4587b274643a161e4bea0952950ab" rel="noopener ugc nofollow" target="_blank">子集化二维数组</a></li><li id="19e1" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated"><a class="ae kc" href="https://gist.github.com/Ventsislav-Yordanov/48a5e73ae43c668e2f2f725a503ca96c" rel="noopener ugc nofollow" target="_blank"> NumPy元素式运算</a></li><li id="9267" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated"><a class="ae kc" href="https://gist.github.com/Ventsislav-Yordanov/8b7e47cda7b63bf97cfa5c80f05f50b3" rel="noopener ugc nofollow" target="_blank"> NumPy基本统计</a></li></ul><h1 id="e538" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">互动版</h1><p id="1181" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><a class="ae kc" href="https://beta.deepnote.com/launch?template=deepnote&amp;url=https%3A%2F%2Fstorage.googleapis.com%2Fdeepnote-public-templates%2Fvyordanov%2Fbasics.tar.gz" rel="noopener ugc nofollow" target="_blank">这里的</a>是在<a class="ae kc" href="https://deepnote.com" rel="noopener ugc nofollow" target="_blank"> Deepnote </a>(云托管Jupyter笔记本平台)上传的这篇文章的<strong class="ld ir">交互版本</strong>。请随意查看并使用示例。</p><h1 id="1164" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">我的其他博客文章</h1><ul class=""><li id="ef19" class="lz ma iq ld b le lf li lj lm no lq np lu nq ly mg mh mi mj bi translated"><a class="ae kc" href="https://medium.com/@ventsislav94/jypyter-notebook-shortcuts-bf0101a98330" rel="noopener"> Jupyter笔记本快捷键</a>。</li><li id="a267" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated"><a class="ae kc" rel="noopener" target="_blank" href="/python-basics-iteration-and-looping-6ca63b30835c"> Python基础:迭代和循环</a></li><li id="ad18" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated"><a class="ae kc" rel="noopener" target="_blank" href="/python-basics-list-comprehensions-631278f22c40"> Python基础:列表理解</a></li><li id="a2a1" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated"><a class="ae kc" rel="noopener" target="_blank" href="/data-science-with-python-intro-to-data-visualization-and-matplotlib-5f799b7c6d82">Python数据科学:Matplotlib数据可视化简介</a></li><li id="84db" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated"><a class="ae kc" rel="noopener" target="_blank" href="/data-science-with-python-intro-to-loading-and-subsetting-data-with-pandas-9f26895ddd7f">使用Python的数据科学:使用pandas加载、子集化和过滤数据简介</a></li><li id="25c7" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated"><a class="ae kc" rel="noopener" target="_blank" href="/introduction-to-natural-language-processing-for-text-df845750fb63">文本自然语言处理简介</a></li></ul><h1 id="79d5" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">商务化人际关系网</h1><p id="517f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这是我在LinkedIn上的简介，如果你想和我联系的话。我将很高兴与你联系在一起。</p><h1 id="14a3" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">最后的话</h1><p id="3d6a" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">谢谢你的阅读。如果你喜欢这个帖子，请按住拍手键分享给你的朋友。另外，我很高兴听到你的反馈。如果你想在我写新博客时得到通知，你可以订阅<a class="ae kc" href="https://buttondown.email/Ventsislav" rel="noopener ugc nofollow" target="_blank">我的简讯</a>。</p></div></div>    
</body>
</html>