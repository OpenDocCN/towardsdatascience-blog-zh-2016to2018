<html>
<head>
<title>Why You Should Still Consider Good Old Fashioned For-Loops in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么您仍然应该考虑R中的老式For循环</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-you-should-still-consider-good-old-fashioned-for-loops-in-r-6f2f9d0db14a?source=collection_archive---------5-----------------------#2017-12-11">https://towardsdatascience.com/why-you-should-still-consider-good-old-fashioned-for-loops-in-r-6f2f9d0db14a?source=collection_archive---------5-----------------------#2017-12-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/30971ba7e8b9a588f347bdca202a435d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hSFdI_B3QS-gps3Ro456TA.jpeg"/></div></div></figure><div class=""/><p id="1027" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我第一次开始使用R时，我对这种语言的计算效率(速度)有点失望。这并不会妨碍大多数数据科学家，但对于生产代码或大型数据集来说就不那么好了。然而，就像生活中的许多事情一样，为了让R做你想做的事情，你需要更加努力地工作，走出普通的道路。</p><p id="295b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在之前的一篇文章中，我比较了四种不同编程语言中拆分-应用-合并原理的时间，在几次尝试之后，R实际上在我的用例中名列前茅。最好的结果是使用了data.table包，它主要是在Rcpp(R的c++接口)中构建的。</p><p id="b380" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有趣的是，我现在正与另一位工程师合作，在我们的一个商业包中实现一种分割-应用-组合的方法，使用R中的预开发代码来快速地在客户那里得到东西(持续开发等等)。不幸的是，我们被告知不能使用GNU GPL开源许可。</p><p id="3f8b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着:</p><ul class=""><li id="1e35" class="kx ky jb ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">没有数据。表:(</li><li id="5bc2" class="kx ky jb ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">没有dplyr:(</li><li id="81c7" class="kx ky jb ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">没有使用有效的Rcpp代码…</li></ul><h1 id="53a8" class="ll lm jb bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">现在怎么办？</h1><p id="8015" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">没有这些精美的软件包，数据科学家应该做些什么呢？什么都要自己写？以R为基数？哦不！这是一场噩梦，对吗？但是，事实证明，你学到了r基的一些有趣的方面。</p><p id="dca4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我还是要速度。我的应用程序肯定不会成为瓶颈。绝对不会。我代表质量。代替这种用户体验的是:</p><p id="fe7a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mo">点击开始按钮。预计计算时间:15分钟。“唉，我再去喝一杯咖啡。”</em></p><p id="12be" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我更喜欢这种用户体验:</p><p id="3e2c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mo">点击。嗖嗖。完成了。“嘿，这个漂亮的图表在这里做什么？”</em></p><p id="7712" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我的一般规则是:“当我的算法运行时，顾客不能喝咖啡。”幸运的是，我的同事也有同样的想法，显然他甚至牺牲了对经理的好感，在代码优化上花时间。所以我觉得这将是一次有趣的合作。</p><p id="87ad" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么我们如何获得速度呢？一般你用众所周知的互联网智慧。这是R中宣扬的主要范式:</p><p id="0473" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你不应该使用for循环！您应该使用应用功能！</p><p id="48dc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并不总是对的…</p><p id="7a49" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我喜欢函数式编程，但有时你必须尝试什么最有效。在base R中，对数据帧中的每个组应用操作的默认方法是函数<code class="fe mp mq mr ms b">by</code>。最重要的是，R中典型的线性建模接口是<code class="fe mp mq mr ms b">lm</code>。将这两个功能结合起来，在一个简单的用例上的计时超过9秒(在更现实的情况下，打哈欠、喝咖啡会很快达到几分钟)。我可以用基R函数把它降低到0.4秒。这是超过25倍的改进！</p><h1 id="fc67" class="ll lm jb bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">我们是如何加快速度的？</h1><p id="6a6b" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">函数<code class="fe mp mq mr ms b">lm</code>很慢，因为它进行字符串解释和许多其他计算，使用户的生活更容易。假设您有一个包含A、B和Z列的数据框架，那么通常情况下，您会对多项式回归进行如下操作:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="2b5b" class="nb lm jb ms b gy nc nd l ne nf"><strong class="ms jc"># The easy way of modeling</strong><br/>model &lt;- lm(Z ~ poly(A, B, degree=3, raw=TRUE), data = df)</span></pre><p id="771a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">比<code class="fe mp mq mr ms b">lm</code>更快的方法是手动处理线性代数。在我之前的文章中，我使用了一个QR分解器，但是我的同事发现内部的<code class="fe mp mq mr ms b">.lm.fit</code>功能甚至比它快两倍(我们有一点竞争)。对于那些不熟悉线性代数的人来说，这里最难的部分是为你的问题定义模型矩阵。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="629c" class="nb lm jb ms b gy nc nd l ne nf"><strong class="ms jc"># The harder way, first construct a model matrix</strong><br/>M &lt;- cbind(A*0+1, A, B, A*B, A², A²*B, B², A*B², A³, B³)<br/> <br/><strong class="ms jc"># Then do the fit</strong><br/>model &lt;- .lm.fit( M, Z )</span></pre><p id="400c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着建模速度的提高，我们现在可以看看如何处理<code class="fe mp mq mr ms b">by</code>功能。这个函数很慢，因为它在内部进行了大量的数据转换，一直在分配新的内存，这是完全没有必要的。最后，您会得到每个组的结果列表，您需要再次取消列表，这又是一次内存分配。这很容易改进。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ng"><img src="../Images/03c02a06101e310028972ea8b007d465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8dzaKhwClQRhmZs9b6gStg.jpeg"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">A comparison of some of the results. I’m not even showing <code class="fe mp mq mr ms b">by + lm</code>, that’s off the chart at 9 seconds.</figcaption></figure><p id="e5ab" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mp mq mr ms b">by</code>的另一种选择是data.table，但不幸的是我们不能使用它。所以下一个最好的方法是一个简单的for循环！我们发现矩阵是循环中最快的索引数据类型，这是线性代数所需要的。为了让事情进展得更快，只要确保不要创建太多不必要的变量，尤其是避免将事情转换成列表。</p><p id="49a0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于那些喜欢钻研代码的人，我已经在我的github库中添加了一个关于这个主题的<a class="ae kw" href="https://github.com/matthijscox/many-models/blob/master/many_models_forloop.R" rel="noopener ugc nofollow" target="_blank">单R脚本</a>。</p><h1 id="d79d" class="ll lm jb bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="e32e" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">结合所有这些改进和其他代码优化，我的同事成功地将一个典型用例的5分钟计算时间减少到了2秒钟！这是一个伟大的结果！现在的瓶颈在于数据加载，这仍然需要大约一分钟的时间，我们目前没有能力解决这个问题。但是总的来说没有时间再喝咖啡了！</p><p id="f0ea" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，如果您正面临一些数据科学或编码问题，不要忘记尝试违背常规实践的方法！</p></div></div>    
</body>
</html>