<html>
<head>
<title>Recurrent Neural Networks for Language Understanding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于语言理解的递归神经网络</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/recurrent-neural-networks-for-language-understanding-10c649f8ac15?source=collection_archive---------12-----------------------#2018-11-20">https://towardsdatascience.com/recurrent-neural-networks-for-language-understanding-10c649f8ac15?source=collection_archive---------12-----------------------#2018-11-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="00d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">递归神经网络(RNNs)已经被认为在机器翻译、情感分析、语音识别和许多其他机器学习任务中实现了最先进的性能。它们的优势在于处理顺序数据和各种长度的输入输出的能力。</p><p id="2f44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些神奇的网络并不新鲜。事实上，它们是在 20 世纪 80 年代开发的——但是比非递归神经网络的计算成本更高，直到(相对)最近计算资源的改进，RNNs 才开始流行。</p><p id="5359" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文将在 NLP 的背景下介绍递归神经网络。</p><h2 id="5ce5" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">从序列数据中学习</h2><p id="02dc" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">前馈神经网络假设所有输入都是相互独立的。虽然对于许多分类任务来说，这是一个合理的假设，但它无法捕捉到在顺序数据中发现的关系。</p><p id="fe80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在顺序数据中，顺序很重要。以文字为例。我们通过每一个单词来发展对文本的理解。我们必须按顺序处理课文，并结合之前所学的知识处理每个单词，以形成正确的理解。</p><p id="593e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">递归神经网络通过使用先前学习的信息来预测下一个输出，从而缓解了这个问题。在语言环境中，RNNs 将从前面的单词中学到的信息存储在“记忆”中，并使用这些知识来更好地理解下一个单词。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/044fa336a90e5e5883949b8cc4363121.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DWWFSETJIWKXL7tjicQcfw.jpeg"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Language is a puzzle! Words needs to be pieced together for us to see the big picture.</figcaption></figure><p id="c755" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">内存的使用也允许 rnn 处理不同长度的序列。这在诸如机器翻译等我们不知道输入和输出有多长的任务中特别有用。</p><p id="4c5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是 RNNs 可以使用的几种输入/输出配置:</p><ul class=""><li id="3484" class="mc md it js b jt ju jx jy kb me kf mf kj mg kn mh mi mj mk bi translated"><strong class="js iu">一对一网络:</strong>香草神经网络接受一个向量作为输入，返回一个向量作为输出。rnn 也可以这样配置。</li><li id="275d" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated"><strong class="js iu">多对一网络:</strong>RNN 也可以接受几个向量作为输入来模拟顺序关系，但返回一个向量作为输出。</li><li id="b804" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated"><strong class="js iu">多对多网络:</strong>一个 RNN 也可以接受多个向量作为输入，返回多个向量作为输出。</li></ul><h2 id="d7c6" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">不同输入/输出配置的示例</h2><p id="a68c" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated"><strong class="js iu">一对一:</strong>我们对基于毒性的聊天室消息分类感兴趣。我们决定最好的嵌入技术将基于频率，并选择使用 TF-IDF 将每个消息嵌入到一个向量中。输出也是一个向量，每个坐标对应于每个类。</p><p id="fa17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">多对一:</strong>我们认为基于频率嵌入聊天室消息是个坏主意，而且单词的顺序很重要。因此，我们通过使用预先训练的 word2vec 模型，将消息中的每个单词嵌入到它自己的向量中。模型输出不会改变。</p><p id="139d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">多对多:</strong>我们已经超越了简单的文本分类器，开始训练一个 RNN 来翻译英语和法语之间的信息。在这种情况下，单词的顺序当然很重要。我们将英语输入编码成几个向量(每个词一个向量)，并使用输出向量来确定法语翻译的顺序。</p><h2 id="8090" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">训练递归神经网络</h2><p id="8a53" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">从传统的神经网络训练 RNN 的区别在于更新权重的方式。在 RNN 中更新权重最常用的方法是<strong class="js iu">通过时间反向传播(BPTT)。</strong></p><p id="87dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回想一下用于训练普通神经网络的梯度下降算法:</p><ol class=""><li id="616d" class="mc md it js b jt ju jx jy kb me kf mf kj mg kn mq mi mj mk bi translated"><strong class="js iu">初始化重量</strong></li><li id="55c5" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mq mi mj mk bi translated">使用权重从输入生成输出(输出计算为输入的加权和)</li><li id="10d8" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mq mi mj mk bi translated"><strong class="js iu">使用激活功能转换输出</strong></li><li id="30aa" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mq mi mj mk bi translated">计算<strong class="js iu">输出误差</strong>(转换输出和目标之间的差值)</li><li id="6ca1" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mq mi mj mk bi translated"><strong class="js iu">反向传播误差</strong>使用偏导数寻找梯度</li><li id="02c7" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mq mi mj mk bi translated">通过<strong class="js iu">梯度下降</strong>更新权重</li><li id="3ebb" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mq mi mj mk bi translated">重复步骤 2-6，直到满足某个停止标准</li></ol><p id="0c4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当执行 BPTT 时，我们需要将我们的网络“展开”成按时间步长分解的层。</p><p id="1de3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注:</strong>我们经常把顺序数据分解成“时间步长”。第一个数据点将是时间 1 的输入，依此类推。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mr"><img src="../Images/63500d02f2284f5eabbe91a255975dfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fDV9INjZlKJeFkU5OUsRSw.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Wikipedia illustration of BPTT</figcaption></figure><p id="13a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在展开我们的循环层之后，我们剩下看起来像几个非循环层的东西。与上述算法的唯一不同之处在于:</p><ol class=""><li id="7381" class="mc md it js b jt ju jx jy kb me kf mf kj mg kn mq mi mj mk bi translated">渐变是通过跨所有展开的层而不是一个层反向传播而生成的。总损失计算为所有时间步长的平均损失。</li><li id="132f" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mq mi mj mk bi translated">权重由所有展开的层共享。它们在最后使用累积的梯度进行更新。</li></ol><h2 id="a147" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">使用递归神经网络</h2><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi ms"><img src="../Images/d7ec3ecad0a108f6f94e3668afc543ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z-csFf-oueqLIShocmL_CQ.png"/></div></div></figure><p id="63ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们正在处理文本数据，其中每个单词都映射到它自己的向量，那么每个单词都将是一个单独的数据点。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mt"><img src="../Images/6ca69355caf2c72cc81d21abd7845e8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mHouQRuuVsLUeT5asUPW5Q.png"/></div></div></figure><p id="c20e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用关于网络权重 w 的函数来计算隐藏状态。该函数的参数是先前的隐藏状态和当前时间步长的输入向量。<a class="ae mu" href="https://en.wikipedia.org/wiki/Hyperbolic_function" rel="noopener ugc nofollow" target="_blank"> Tanh </a>和<a class="ae mu" href="https://en.wikipedia.org/wiki/Rectifier_(neural_networks)" rel="noopener ugc nofollow" target="_blank"> ReLU </a>是一些常用的计算隐藏状态的函数。</p><p id="214d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们通过使用权重来计算输出，以获得最后隐藏状态的加权和。这些输出可以用来进行预测或生成新的序列。</p><h2 id="dbaa" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">对消失/爆炸梯度的关注</h2><p id="ff52" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">类似于非常深的前馈神经网络，rnn 容易受到通过反向传播的消失/爆炸梯度的影响(回想一下，一个递归层被展开成许多非递归层)。</p><p id="d729" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">幸运的是，有几种方法可以解决这些问题。</p><p id="ae86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">消失渐变:</strong></p><ul class=""><li id="93f2" class="mc md it js b jt ju jx jy kb me kf mf kj mg kn mh mi mj mk bi translated">使用门控机制，以便不是所有的隐藏状态都被存储。这是通过替代 RNN 单位完成的，如<a class="ae mu" href="https://en.wikipedia.org/wiki/Long_short-term_memory" rel="noopener ugc nofollow" target="_blank"> LSTM </a>和<a class="ae mu" href="https://en.wikipedia.org/wiki/Gated_recurrent_unit" rel="noopener ugc nofollow" target="_blank"> GRU </a>。</li><li id="9dc1" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">使用 ReLU 作为激活功能</li></ul><p id="f859" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">爆炸渐变:</strong></p><ul class=""><li id="da30" class="mc md it js b jt ju jx jy kb me kf mf kj mg kn mh mi mj mk bi translated"><a class="ae mu" href="http://theai.wiki/Gradient%20Clipping" rel="noopener ugc nofollow" target="_blank">渐变裁剪</a>:设置渐变值的最大阈值；剪裁阈值以上所有渐变</li></ul><h2 id="65c1" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">结论</h2><p id="696b" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">尽管有额外的训练复杂性，RNNs 在机器学习中已经变得非常流行。在 NLP 之外，递归神经网络也被用于视频分类、语音识别和时间序列数据中的异常检测。</p><h1 id="caf5" class="mv kp it bd kq mw mx my kt mz na nb kw nc nd ne kz nf ng nh lc ni nj nk lf nl bi translated">感谢您的阅读！</h1><p id="3246" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">如果你喜欢这篇文章，可以看看我关于数据科学、数学和编程的其他文章。<a class="ae mu" href="https://medium.com/@mandygu" rel="noopener">通过 Medium </a>关注我的最新更新。😃</p><p id="c4c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为一个业余爱好项目，我还在<a class="ae mu" href="http://www.dscrashcourse.com/" rel="noopener ugc nofollow" target="_blank">www.dscrashcourse.com</a>建立了一套全面的<strong class="js iu">免费</strong>数据科学课程和练习题。</p><p id="fb9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想支持我的写作，下次你报名参加 Coursera 课程时，可以考虑使用我的会员链接。完全公开—我从每一次注册中获得佣金，但不会对您产生额外费用。</p><p id="99bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">再次感谢您的阅读！📕</p></div></div>    
</body>
</html>