<html>
<head>
<title>ConvolutionNeuralNetwork(CNN) in Android — tictactoe.ai (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android 中的 ConvolutionNeuralNetwork(CNN)——TIC tactoe . ai(第 1 部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/android-with-tensorflow-part-1-6897ba617b1e?source=collection_archive---------3-----------------------#2018-06-20">https://towardsdatascience.com/android-with-tensorflow-part-1-6897ba617b1e?source=collection_archive---------3-----------------------#2018-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/bb1ebe4c3b841d61aeedb836e945f423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*InKCb9BfLS7G5w5YTdm_3A.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Image source from- <a class="ae jd" href="https://techcrunch.com/2017/05/17/googles-tensorflow-lite-brings-machine-learning-to-android-devices/" rel="noopener ugc nofollow" target="_blank">https://techcrunch.com/2017/05/17/googles-tensorflow-lite-brings-machine-learning-to-android-devices/</a></figcaption></figure><div class=""/><p id="5a81" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Google Tensorflow 现在已经在 Android 中用于集成机器学习模型。</p><p id="8570" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我想用 Tensorflow 创建一个 Android 应用程序，因为其他人只是使用 Tensorflow 的预训练模型，并将其集成到应用程序中。但我想尝试一些新的东西，所以我训练了自己的模型，并了解了 Tensorflow 如何与 Android 交互。了解如何保存模型以供移动使用。</p><h1 id="e49a" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">张量流</h1><p id="fda5" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我已经实现了卷积神经网络的代码来分类 TicTacToe 游戏的 X 和 O。</p><figure class="mf mg mh mi gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi me"><img src="../Images/204e2d28920af8d59a99e1fb14db48d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cPAmSB9nziZPI73VC5HAHg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Image sources from :- <a class="ae jd" href="https://www.analyticsvidhya.com/blog/2017/06/architecture-of-convolutional-neural-networks-simplified-demystified/" rel="noopener ugc nofollow" target="_blank">https://www.analyticsvidhya.com/blog/2017/06/architecture-of-convolutional-neural-networks-simplified-demystified/</a></figcaption></figure><p id="d1d2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输入图像大小为 28x28，输出图层大小为 2。因为我们必须将图像分类为 X 和 o。</p><p id="0e74" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在建立模型的时候，你必须定义哪个是你的<strong class="kf jh">输出节点</strong>，哪个是你的<strong class="kf jh">输入节点</strong>，给那些节点一些特定的名字。</p><p id="633e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后是模型的训练，我已经在 6000 张不同的 X 和 O 的图像上训练了我的模型，运行了 3 个时期</p><figure class="mf mg mh mi gt is gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/1e7db44951bdddd05b4a072c4a2cdd3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*gN-_uQmgXhwxNfyKQcCJvg.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Training result of CNN</figcaption></figure><p id="0ac1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于训练模型已经训练了权重，这给出了 X 和 o 的完美分类。现在，我们必须保存具有权重的张量流的图形。</p><p id="3d49" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">冻结图形时，我们需要输入和输出节点名称的列表，这就是为什么我们给输入和输出节点命名，这在冻结图形时很有帮助。</p><p id="7068" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">冻结图由获得输出必须执行的操作序列组成。操作包括矩阵乘法、加法和用训练模型的冻结权重对矩阵进行整形。</p><p id="a0e8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是冻结保存模型的代码。</p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="6505" class="mp lc jg ml b gy mq mr l ms mt">freeze_graph.freeze_graph('out/' + MODEL_NAME + '.pbtxt', <strong class="ml jh">None</strong>, <strong class="ml jh">False</strong>,'out/' + MODEL_NAME + '.chkp', output_node_name, "save/restore_all","save/Const:0", 'out/frozen_' + MODEL_NAME + '.pb', <strong class="ml jh">True</strong>, "")<br/><br/>input_graph_def = tf.GraphDef()<br/><strong class="ml jh">with</strong> tf.gfile.Open('out/frozen_' + MODEL_NAME + '.pb', "rb") <strong class="ml jh">as</strong> f:<br/>    input_graph_def.ParseFromString(f.read())<br/><br/>input_node_names = ['input']<br/>    <br/>output_graph_def = optimize_for_inference_lib.optimize_for_inference(<br/>        input_graph_def, input_node_names, [output_node_name],<br/>        tf.float32.as_datatype_enum)<br/><br/><strong class="ml jh">with</strong> tf.gfile.FastGFile('out/opt_' + MODEL_NAME + '.pb', "wb") <strong class="ml jh">as</strong> f:<br/>    f.write(output_graph_def.SerializeToString())</span></pre><p id="dd6f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查看我的项目<a class="ae jd" href="https://raw.githubusercontent.com/harsh2011/XO-Models/master/out/opt_xo_differ.pb" rel="noopener ugc nofollow" target="_blank">的冻结图</a></p><h1 id="a866" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">带 Tensorflow 的 Android</h1><p id="163f" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">从 Android 开始，首先，我们已经集成了 Tensorflow 库，只需将它添加到依赖项中。</p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="f13f" class="mp lc jg ml b gy mq mr l ms mt">dependencies {<br/>.....<br/>implementation ‘org.tensorflow:tensorflow-android:+’<br/>}</span></pre><p id="6a4b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于 Tensorflow 是用 C++编写的，所以你必须将 NDK 集成到我们的 Android 项目中。然后将模型复制到 android 目录的 asset 文件夹中。</p><p id="69f4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如何使用 Java 在 Android 中运行图形？</p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="6c32" class="mp lc jg ml b gy mq mr l ms mt">// added the path of model<br/>private static final String MODEL_FILE_CNN = "file:///android_asset/opt_xo_differ_v2.pb";<br/>//declare the input and output<br/>private static final String INPUT_NODE = "input";<br/>private static final String OUTPUT_NODE = "output"private TensorFlowInferenceInterface inferenceInterface;</span><span id="ea05" class="mp lc jg ml b gy mu mr l ms mt">//load graph<br/>inferenceInterface = new TensorFlowInferenceInterface(getAssets(),MODEL_FILE_CNN);</span></pre><p id="4c65" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正在加载模型。pd 文件，并创建一个<strong class="kf jh">tensorflowenceinterface</strong>对象</p><p id="92e4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了检测，我创建了一个方法来读取浮动中的图像像素。因为 DrawView 是一个画布，它为我们提供画布绘制图像的像素值，然后将它们转换为 float，并将其传递给<strong class="kf jh">tensorflowenceinterface</strong>对象。</p><p id="fc81" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，首先您必须将数据输入到<strong class="kf jh">输入节点(input_node 和 keep_prob)，</strong>中，然后使用<strong class="kf jh">输出节点</strong>运行推理接口</p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="5a57" class="mp lc jg ml b gy mq mr l ms mt">public float[] getDetectofDV(DrawView d){</span><span id="fa52" class="mp lc jg ml b gy mu mr l ms mt">float pixels[] = d.getPixelData();</span><span id="8cc4" class="mp lc jg ml b gy mu mr l ms mt">inferenceInterface.feed(INPUT_NODE, pixels,1,28,28,1);<br/>inferenceInterface.feed("keep_prob", new float[] { 1 });</span><span id="939a" class="mp lc jg ml b gy mu mr l ms mt">final Operation operation = inferenceInterface.graphOperation(OUTPUT_NODE);</span><span id="e6c4" class="mp lc jg ml b gy mu mr l ms mt">final int numClasses = (int) operation.output(0).shape().size(1);</span><span id="0e91" class="mp lc jg ml b gy mu mr l ms mt">// this run the operation of the graph<br/>inferenceInterface.run(new String[]{OUTPUT_NODE},false);</span><span id="d7ac" class="mp lc jg ml b gy mu mr l ms mt">float [] outputarray = new float[numClasses];<br/>//get the output<br/>inferenceInterface.fetch(OUTPUT_NODE,outputarray);</span><span id="4aa2" class="mp lc jg ml b gy mu mr l ms mt">return outputarray;<br/>}</span></pre><p id="419e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh"> outputarray </strong>如果一个索引 0 值大于索引 1，则返回具有 2 个值的检测结果。则图像被检测为‘0’，否则为‘X’。</p><figure class="mf mg mh mi gt is gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/c44e8c779090e142f60b199bcb789292.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*JH1QqrGT7FRQQnjxBJhh5Q.gif"/></div></figure><p id="caaf" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是将模型与 Android 整合后的结果。就像在触摸监听器上工作一样，当你从画布上拿起手指时，它会传递图像进行分类，你会在下面的矩阵中得到输出。</p><p id="65c5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查看 playstore 上的应用程序。<a class="ae jd" href="https://play.google.com/store/apps/details?id=com.harsh.xo" rel="noopener ugc nofollow" target="_blank">https://play.google.com/store/apps/details?id=com.harsh.xo</a></p><h1 id="020c" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">未来的工作</h1><p id="4f28" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">首先，我会尽量缩小模型的尺寸。CNN 的模型大小是 17MB，因为它在应用程序中占用了大量空间。应用程序的最终大小为 55 MB。</p><p id="83d3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">致力于在同一应用程序中集成新模型。一个人可以玩电脑。</p><p id="6512" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">https://play.google.com/store/apps/details?id=com.harsh.xo<a class="ae jd" href="https://play.google.com/store/apps/details?id=com.harsh.xo" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>