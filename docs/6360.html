<html>
<head>
<title>TensorFlow Filesystem — Access Tensors Differently</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">张量流文件系统—以不同方式访问张量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tensorflow-filesystem-access-tensors-differently-888bce1d68e7?source=collection_archive---------16-----------------------#2018-12-09">https://towardsdatascience.com/tensorflow-filesystem-access-tensors-differently-888bce1d68e7?source=collection_archive---------16-----------------------#2018-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c14fe8f80acadd34724c6a3a8a30a2e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0f9B1Tu1XcMsgSZVatwO6w.png"/></div></div></figure><p id="c1ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Tensorflow 很棒。真的，我是认真的。问题是它在某种程度上是伟大的。有时候你想做非常简单的事情，但是 tensorflow 却在为难你。我写<a class="ae kz" href="https://github.com/yoel-zeldes/tffs" rel="noopener ugc nofollow" target="_blank"> TFFS </a> (TensorFlow 文件系统)背后的动机可以被任何使用过 TensorFlow 的人分享，包括你。</p><p id="7b73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我只想知道一个特定张量的名字是什么；或者它的输入张量是什么(忽略运算)。</p><p id="85c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用 tensorboard 可以轻松回答所有这些问题。<br/> 当然，你只需打开图形选项卡，并目视检查图形。真的很方便吧？如果你想对图表有一个总体的了解。但是如果你很专注，并且有一个特定的问题想要回答，使用键盘是一个不错的选择。</p><p id="f19d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">那么为什么不在 python shell 中加载图形并检查它呢？<br/> </strong>这是可行的，但是每次我想做那个任务的时候都要写这几行代码？必须记住如何加载图形，如何寻找张量，如何获得它的输入…当然，这只是几行代码，但一旦你一次又一次地重复同样的任务，就该写脚本了！</p><p id="d230" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么为什么不写一个交互式脚本呢？你是指一个脚本，它给出了模型的路径，为你加载它，并提供实用函数来减轻你写张量流代码的痛苦？好吧，我们可以这么做，但那不会比我要给你看的更棒！</p><p id="69d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">声明:如果你想要一个有意义的解决方案，停止阅读这里，只使用交互式脚本方法。只有当你想学习一些不同的东西时，才继续阅读；)</p><h1 id="c80f" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">文件系统拯救世界！</h1><p id="d921" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">张量的名称有斜杠——与 UNIX 文件系统非常相似。想象一个有张量流文件系统的世界，其中目录类似于张量流范围，文件类似于张量。给定这样一个文件系统，我们可以使用传统的 bash 来做我们想做的事情。例如，我们可以通过运行<code class="fe md me mf mg b">find ~/tf</code>列出所有可用的作用域和张量——假设<code class="fe md me mf mg b">~/tf</code>是 tensorflow 文件系统的挂载位置。想只列出张量？没问题，用<code class="fe md me mf mg b">find ~/tf -type f</code>就行了。</p><p id="f9d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">嘿，我们有文件，对吧？它们的内容应该是什么？让我们运行<code class="fe md me mf mg b">cat ~/tf/.../tensor_name</code>。哇！我们得到了张量的值——很好……这只有在张量不依赖占位符的情况下才有效，原因很明显。</p><p id="d440" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如何得到张量的输入呢？嗯，你可以跑<code class="fe md me mf mg b">~/tf/bin/inputs -d 3 ~/tf/.../tensor_name</code>。这个特殊的脚本将打印递归深度为 3 的输入的树形视图。不错…</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/58a18b185827e6e303f575bfaeb6a0d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V17aGf-6No3ROrRz8SKu_Q.jpeg"/></div></div></figure><p id="6ccf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好吧，我加入。我们如何实现它？这个问题问得好。我们可以在用户空间(FUSE)中使用文件系统。这是一种允许我们在用户空间实现文件系统的技术。它为我们省去了进入低层次领域的麻烦，如果你以前没有做过，这真的很难做到(并且实现起来很慢)。包括用 C 写代码——恐怖！我们将使用名为<a class="ae kz" href="https://github.com/fusepy/fusepy" rel="noopener ugc nofollow" target="_blank"> fusepy </a>的 python 绑定。</p><p id="8741" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我将只解释实现中有趣的部分。完整的代码可以在这里找到。包括文档在内，只有 345 行代码。</p><p id="f842" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先我们需要加载一个张量流模型:</p><ol class=""><li id="23bb" class="mn mo it kd b ke kf ki kj km mp kq mq ku mr ky ms mt mu mv bi translated">使用<code class="fe md me mf mg b">tf.train.import_meta_graph</code>导入图形结构。</li><li id="d349" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky ms mt mu mv bi translated">如果模型经过训练，使用<code class="fe md me mf mg b">saver.restore</code>加载重量。</li></ol><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="4194" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">将张量映射到文件</h1><p id="f5ab" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">接下来，我将描述主类。构造函数中有几件有趣的事情。首先，我们称之为<code class="fe md me mf mg b">_load_model</code>。然后，我们将图中的每个张量映射到文件系统中的一个路径。假设一个张量的名字是<code class="fe md me mf mg b">a/b/c:0</code>——它将被映射到路径<code class="fe md me mf mg b">~/tf/a/b/c:0</code>，假设挂载点是<code class="fe md me mf mg b">~/tf</code>。</p><p id="845a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个目录和文件都是使用<code class="fe md me mf mg b">_create_dir</code>和<code class="fe md me mf mg b">_create_tensor_file</code>函数创建的。这些函数返回一个简单的 python 字典，其中包含关于目录或文件的元数据。</p><p id="293a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们也叫<code class="fe md me mf mg b">_populate_bin</code>，后面我会讲到。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="e895" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用 fusepy</h1><p id="1715" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">fusepy 要求你实现一个扩展<code class="fe md me mf mg b">fuse.Operations</code>的类。这个类实现文件系统支持的操作。在我们的例子中，我们想要支持读取文件，所以我们将实现<code class="fe md me mf mg b">read</code>函数。当被调用时，这个函数将计算与给定路径相关的张量。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="83aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">担心<code class="fe md me mf mg b">printoptions</code>部分？当实现文件系统时，你需要知道文件的大小。为了知道大小，我们可以评估所有的张量，但是这需要时间和内存。相反，我们可以检查每个张量的形状。给定它的形状，并且给定我们使用一个格式化程序在结果中输出每个条目的固定数量的字符(这就是<code class="fe md me mf mg b">_fixed_val_length</code>出现的地方)，我们可以计算大小。</p><h1 id="bc19" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">获取输入和输出</h1><p id="9ef1" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">虽然张量流观测仪的结构类似于文件系统，但张量输入和输出却不同。因此，我们可以不使用文件系统来获取输入和输出，而是编写一个可以如下执行的脚本:</p><p id="f813" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe md me mf mg b">~/tf/bin/outputs — depth 3 ~/tf/a:0</code></p><p id="655d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">结果将如下所示:</p><pre class="mi mj mk ml gt nd mg ne nf aw ng bi"><span id="14d4" class="nh lb it mg b gy ni nj l nk nl">~/tf/a:0<br/>├── ~/tf/b:0<br/>└── ~/tf/c:0<br/>    └── ~/tf/d:0<br/>    |   └── ~/tf/e:0<br/>    └── ~/tf/f:0</span></pre><p id="b397" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不错！我们有输出树！要实现它，我们要做的就是:</p><ol class=""><li id="3ba4" class="mn mo it kd b ke kf ki kj km mp kq mq ku mr ky ms mt mu mv bi translated">获取数据，这是从每个张量到其输出的映射。</li><li id="46d1" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky ms mt mu mv bi translated">实现一个输出树的递归函数。这并不复杂(它花了我 6 行代码)，并且是一个很好的练习。</li></ol><p id="9939" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不过有一个挑战……<code class="fe md me mf mg b">outputs</code>脚本将在一个新进程中执行——这是 UNIX 的工作方式。这意味着它不能访问 tensorflow 图，它是在主进程中加载的。</p><p id="90d1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么如何访问张量的所有输入/输出呢？我可以在两个进程之间实现进程间通信，这是一个很大的工作量。但是我选择了不同的方法。我创建了一个包含以下行的模板 python 文件:</p><p id="1be5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe md me mf mg b">_TENSOR_TO_DEPENDENCIES = {{TENSOR_TO_TENSORS_PLACEHOLDER}}</code></p><p id="4d4e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是非法的 python 代码。我们之前看到的<code class="fe md me mf mg b">_populate_bin</code>函数读取这个 python 文件，并用输出(或输入)的张量字典替换<code class="fe md me mf mg b">{{TENSOR_TO_TENSORS_PLACEHOLDER}}</code>。然后，结果文件被映射到我们的文件系统中的一个路径— <code class="fe md me mf mg b">~/tf/bin/outputs</code>(或<code class="fe md me mf mg b">~/tf/bin/inputs</code>)。这意味着如果您运行<code class="fe md me mf mg b">cat ~/tf/bin/outputs</code>，您将能够看到文件内部(潜在的)巨大的映射。</p><h1 id="415e" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">猫。/最终想法</h1><p id="a1a1" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我们做到了！我们将张量流模型映射到文件系统。TFFS 是一个有趣的小项目，我在这个过程中了解了 FUSE，这很棒。</p><p id="abca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">TFFS 是一个可爱的工具，但它不能代替旧的 python shell。使用 python，您可以轻松地导入张量流模型并手动检查张量。我只是希望我能记得如何这样做，即使在做了数百次之后…</p></div></div>    
</body>
</html>