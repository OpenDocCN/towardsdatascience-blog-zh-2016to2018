<html>
<head>
<title>Predicting the task duration based on a range</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于范围预测任务持续时间</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/predicting-the-task-duration-based-on-a-range-a345b83fab58?source=collection_archive---------16-----------------------#2018-12-03">https://towardsdatascience.com/predicting-the-task-duration-based-on-a-range-a345b83fab58?source=collection_archive---------16-----------------------#2018-12-03</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="7e22" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">使用机器学习进行项目评估。</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/4c9589a39efcb10aea70e57ee234b535.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qXu_UytNCNzYPndM.jpg"/></div></div></figure><p id="9445" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在<a class="ae lo" href="https://medium.com/@michaellarionov/using-statistics-in-agile-estimation-ead56236de64" rel="noopener">之前的条目之一</a>中，我们已经建立了一个统计模型，用于根据估计预测实际项目时间和成本。我们讨论过，我们可以将评估(敏捷项目和瀑布项目)拟合到对数正态分布，这保证了积极的支持。正如我们在另一篇文章的<a class="ae lo" rel="noopener" target="_blank" href="/agile-estimation-part-ii-80bba09b9fc1">中所讨论的那样，使用统计方法进行估算使我们能够给出具有所需置信水平的预测，并预测货币收益、成本和风险。</a></p><p id="9d22" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我被问到的一件事是，当一个估计值被作为一个范围给出时，这个模型如何推广。事实上，这是每个人都教导我们的:不要给出一个单一的数字，而是范围。一种方法是继续使用我们的统计模型，并在中间输入一个数字，即两个值的平均值。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj lp"><img src="../Images/6c9d51d7e9304ebcf05612bf6037761d.png" data-original-src="https://miro.medium.com/v2/resize:fit:408/format:webp/1*d81y1C9hC3Y4P9PZkw097A.png"/></div></figure><p id="7dd2" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这样，该模型无需修改即可使用。</p><p id="dc45" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这种方法有两个问题:</p><ol class=""><li id="62de" class="lq lr ir ku b kv kw ky kz lb ls lf lt lj lu ln lv lw lx ly bi translated">取一个高低的平均值是任意的。它将给出的信息减少了一半。最好有一个算法来学习我们需要在低边界和高边界之间的区间内的什么地方设置变量 x</li><li id="51be" class="lq lr ir ku b kv lz ky ma lb mb lf mc lj md ln lv lw lx ly bi translated">通过给我们一系列的数据，开发者试图向我们传达一个非常重要的信息:评估的不确定性程度。正确的模型应该使用这些信息。</li></ol><p id="0505" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">为了简化过程，我们将对所有的估计值和实际值取自然对数。由于我们使用对数正态分布对估计值建模，我们的新变量<code class="fe me mf mg mh b">y</code>、<code class="fe me mf mg mh b">l</code>、<code class="fe me mf mg mh b">h</code>将分别是实际天数、低估计值和高估计值的对数。在这种情况下我们可以使用正态分布！我们将使用线性回归对<code class="fe me mf mg mh b">y</code>建模:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj mi"><img src="../Images/f4a8f553eb16b48f3de623a407fbe594.png" data-original-src="https://miro.medium.com/v2/resize:fit:366/format:webp/1*ZQqCsCjN9Tmprf_LdcXzlA.png"/></div></figure><p id="28fd" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在<em class="mj"> θh </em>和<em class="mj"> θl </em>相等的情况下，我们会遇到与之前讨论的<a class="ae lo" href="https://medium.com/@michaellarionov/using-statistics-in-agile-estimation-ead56236de64" rel="noopener">完全相同的问题</a>。</p><p id="a38f" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在这种情况下，单个数据的似然函数可以写成如下形式(在<a class="ae lo" href="https://en.wikipedia.org/wiki/Bayesian_linear_regression" rel="noopener ugc nofollow" target="_blank">和</a>之后)。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj mk"><img src="../Images/080bb5abde8df75461cd9b4f2dd2f043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*_uxiktS2ATC0ByJOXvfkdg.png"/></div></figure><p id="4fea" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如前所述，通过给出一个范围，开发人员希望向我们传达评估的不确定性。我们应该将这种不确定性包括在我们对<em class="mj"> σ </em>的估计中。直观上，范围与标准偏差成比例，我们可以通过将<em class="mj"> σ </em>建模为:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj ml"><img src="../Images/33f442a43f18f1ce99a23928876500d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*f7ug5a2972__Vks83wpBPg.png"/></div></figure><p id="6820" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如果我们也使用精度参数<em class="mj"> τ </em>代替<em class="mj"> σ </em> 0:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj mm"><img src="../Images/60b357c6579f28f9ac0dad2a70fdcef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:212/format:webp/1*vAb9Rp0XILCV84rGV6k5zA.png"/></div></figure><p id="79f9" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">那么我们的可能性函数将是:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj mn"><img src="../Images/13be8a6d7641736c736fcc803b590481.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jc_Txvd0ghPlIBHxJeN8_Q.png"/></div></div></figure><p id="756b" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><em class="mj"> τ </em>和<em class="mj"> θ </em>的先验传统上分别为伽玛分布和正态分布；</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj mo"><img src="../Images/2354c8716b566de63cf9b80fcb570a3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*zJCQaSb_5RAo8WYqORnN7g.png"/></div></figure><p id="de6d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这里<em class="mj"> α </em>，<em class="mj"> β </em>，<em class="mj"> λ </em>为超参数。</p><p id="57ac" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">为<em class="mj"> ζ </em>选择先验比较困难。对于我们选择的这种似然函数，没有共轭先验存在。现在我们可以选择正态分布。这种分布的零均值意味着我们先验地不信任范围(我们知道许多顾问的范围总是 20%并且不传达任何信息)。先验分布的高均值意味着我们更加关注估计的不确定性程度。</p><p id="937a" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">为简单起见，我们将平均值设为零。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj mp"><img src="../Images/d25625e4458a286efe63f2fec1785274.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*Km50dly-mb4OgUmc-PvlpQ.png"/></div></figure><p id="97bb" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">负对数后验函数为:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj mq"><img src="../Images/2fc71ef473736aeb1239af3c6258f1df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*txrsM5BGQbPJNWNeOQwnLw.png"/></div></div></figure><p id="e3cd" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在这个博客里我会找到参数，对应最大后验概率。为了避免在微分中出错，我们将使用张量流。我们将按照这个例子来构建我们的代码</p><pre class="kh ki kj kk gu mr mh ms mt aw mu bi"><span id="3f6f" class="mv mw ir mh b gz mx my l mz na">import numpy as np<br/>import pandas as pd<br/>import tensorflow as tf</span></pre><p id="1599" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">此处的数据代表预计和实际天数。我们看到开发人员喜欢在他的预算中增加 25%作为缓冲。然而，对于一些故事，他增加了更多的缓冲，也许是为了表明更多的不确定性。</p><pre class="kh ki kj kk gu mr mh ms mt aw mu bi"><span id="23e2" class="mv mw ir mh b gz mx my l mz na">seed=1389<br/>tf.reset_default_graph()<br/>task_data = pd.DataFrame({'low':[4,14,4,3,4,3,4,9,6,27,20,23,11],<br/>                          'high':[5,18,5,4,5,7,5,10,8,30,25,29,14],<br/>                          'actual':[17,8,5,3,5,4,9,9,4,27,16,15,7,]})</span><span id="a28f" class="mv mw ir mh b gz nb my l mz na">%matplotlib inline<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>fig, ax = plt.subplots(figsize=(11.7, 8.27))<br/>task_data['story_id'] = task_data.index<br/>data_for_plot = pd.melt(task_data, id_vars="story_id", var_name="type", value_name="days")<br/>task_data.drop(columns=['story_id'], inplace=True)<br/>sns.barplot(x='story_id', y='days', hue='type', data=data_for_plot,ax=ax);</span></pre><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nc"><img src="../Images/907ed6ee133b88914c867b2e121e3ab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KjsAY6FWdMwV62LphUr7tw.png"/></div></div></figure><p id="cd0d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">定义变量时，我们用<em class="mj"> τ </em>代替另一个变量<em class="mj"> ρ </em>:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj nd"><img src="../Images/cffe5d00d366378105d973a41e781e42.png" data-original-src="https://miro.medium.com/v2/resize:fit:174/format:webp/1*04l0Kwqp4_RLvQYpslhYHA.png"/></div></figure><p id="af4c" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这是为了避免优化器选择负的<em class="mj"> τ </em></p><pre class="kh ki kj kk gu mr mh ms mt aw mu bi"><span id="ae2a" class="mv mw ir mh b gz mx my l mz na">#Taking the log of data<br/>log_data = np.log(task_data.values)<br/>N = log_data.shape[0]</span><span id="124e" class="mv mw ir mh b gz nb my l mz na">#Defining variables<br/>theta_h = tf.Variable(name='theta_h', initial_value=0.5)<br/>theta_l = tf.Variable(name='theta_l', initial_value=0.5)<br/>zeta = tf.Variable(name='zeta', initial_value=0.01)<br/>rho = tf.Variable(name='rho', initial_value=0.01)</span></pre><p id="3e26" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">由于不想调太多超参数，我们就把<em class="mj"> α </em>和<em class="mj"> β </em>设为一。两个<em class="mj"> λ </em>参数都作为正则化参数，所以我们必须调整它们</p><pre class="kh ki kj kk gu mr mh ms mt aw mu bi"><span id="d8b7" class="mv mw ir mh b gz mx my l mz na">#Set the hyperparameters<br/>alpha = tf.constant(name='alpha', value=1.0)<br/>beta = tf.constant(name='beta', value=1.0)<br/>lambda1 = tf.constant(name='lambda1', value=1e-4)<br/>lambda2 = tf.constant(name='lambda2', value=1e-4)</span><span id="60db" class="mv mw ir mh b gz nb my l mz na">def loss(l, h, y):<br/>    return tf.log(1+zeta**2*(h-l)) + \<br/>        rho**2/2/(1+zeta**2*(h-l))**2 * (y - theta_l*l - theta_h*h)**2</span><span id="f428" class="mv mw ir mh b gz nb my l mz na">cummulative_loss = tf.reduce_sum(list(np.apply_along_axis(lambda x: loss(*x), axis=1, arr=log_data )))<br/>cost = cummulative_loss - (N+1-2*alpha)/2*tf.log(rho**2) + beta*rho**2 + \<br/>rho**2*lambda1/2*(theta_h**2+theta_l**2) + rho**2*lambda2/2*zeta**2</span><span id="c284" class="mv mw ir mh b gz nb my l mz na">learning_rate = 1e-4<br/>optimizer = tf.train.AdamOptimizer(learning_rate)<br/>train_op = optimizer.minimize(cost)</span><span id="4808" class="mv mw ir mh b gz nb my l mz na">import math<br/>init = tf.global_variables_initializer()<br/>n_epochs = int(1e5)<br/></span><span id="d3f8" class="mv mw ir mh b gz nb my l mz na">with tf.Session() as sess:<br/>    sess.run(init)</span><span id="b093" class="mv mw ir mh b gz nb my l mz na">    for epoch in range(n_epochs):<br/>        if epoch % 1e4 == 0:<br/>            print("Epoch", epoch, "Cost =", cost.eval())<br/>            print(f'Parameters: {theta_l.eval()}, {theta_h.eval()}, {rho.eval()}, {zeta.eval()}')<br/>        sess.run(train_op)<br/>    best_theta_l = theta_l.eval()<br/>    best_theta_h = theta_h.eval()<br/>    best_sigma = 1/math.sqrt(rho.eval())</span><span id="530c" class="mv mw ir mh b gz nb my l mz na">Epoch 0 Cost = 55.26268<br/>Parameters: 0.5, 0.5, 0.009999999776482582, 0.009999999776482582<br/>Epoch 10000 Cost = 6.5892615<br/>Parameters: 0.24855799973011017, 0.6630115509033203, 0.6332486271858215, 1.1534561276317736e-35<br/>Epoch 20000 Cost = 1.39517<br/>Parameters: 0.2485545128583908, 0.6630078554153442, 1.3754394054412842, 1.1534561276317736e-35<br/>Epoch 30000 Cost = 1.3396643<br/>Parameters: 0.24855604767799377, 0.6630094647407532, 1.4745615720748901, 1.1534561276317736e-35<br/>Epoch 40000 Cost = 1.3396641<br/>Parameters: 0.24855272471904755, 0.6630063056945801, 1.4745622873306274, 1.1534561276317736e-35<br/>Epoch 50000 Cost = 1.3396646<br/>Parameters: 0.2485586702823639, 0.6630119681358337, 1.4745632410049438, 1.1534561276317736e-35<br/>Epoch 60000 Cost = 1.3396648<br/>Parameters: 0.2485581487417221, 0.6630115509033203, 1.4745649099349976, 1.1534561276317736e-35<br/>Epoch 70000 Cost = 1.3396643<br/>Parameters: 0.2485586702823639, 0.6630122065544128, 1.4745644330978394, 1.1534561276317736e-35<br/>Epoch 80000 Cost = 1.3396643<br/>Parameters: 0.24855820834636688, 0.6630116701126099, 1.4745631217956543, 1.1534561276317736e-35<br/>Epoch 90000 Cost = 1.3396646<br/>Parameters: 0.248562291264534, 0.663015604019165, 1.474563717842102, 1.1534561276317736e-35</span></pre><p id="45fa" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这里有意思的是<em class="mj"> ζ </em>为零。这意味着我们不能相信开发者给我们的不确定性估计。这也意味着我们可以只使用由学习参数<em class="mj"> θl </em>和<em class="mj"> θh </em>指定的平均值周围的对数正态分布。比方说，同一个开发人员估计一项新任务需要 10-15 天。代入我们看到的公式:</p><pre class="kh ki kj kk gu mr mh ms mt aw mu bi"><span id="9ba4" class="mv mw ir mh b gz mx my l mz na">mu = best_theta_l*math.log(10)+best_theta_h*math.log(15)<br/>most_likely_prediction = math.exp(mu)    <br/>most_likely_prediction</span><span id="1024" class="mv mw ir mh b gz nb my l mz na">10.67385532327305</span></pre><p id="daf3" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们还可以通过将这些值直接代入对数正态分布来获得 95%的置信度:</p><pre class="kh ki kj kk gu mr mh ms mt aw mu bi"><span id="db57" class="mv mw ir mh b gz mx my l mz na">from scipy.stats import lognorm<br/>distribution = lognorm(s=best_sigma, scale=most_likely_prediction, loc=0)<br/>print(f'95% confidence: {distribution.ppf(0.95)}')</span><span id="de5c" class="mv mw ir mh b gz nb my l mz na">95% confidence: 41.3614192940211</span></pre><p id="f5e5" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如我们所见，如果我们想要 95%的置信度，我们必须给出 41 天的估计，而不是 50%置信度的 11 天。如果你看到开发人员在过去没有很好地完成任务评估，这就很容易解释了。</p><p id="f2f3" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">您可以从<a class="ae lo" href="https://github.com/mlarionov/machine_learning_POC/blob/master/agile_estimation/range_estimates.ipynb" rel="noopener ugc nofollow" target="_blank"> github </a>访问笔记本。</p></div></div>    
</body>
</html>