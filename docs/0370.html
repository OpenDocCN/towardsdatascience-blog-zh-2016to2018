<html>
<head>
<title>How to build a simple song recommender system</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何建立一个简单的歌曲推荐系统</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-a-simple-song-recommender-296fcbc8c85?source=collection_archive---------0-----------------------#2017-04-24">https://towardsdatascience.com/how-to-build-a-simple-song-recommender-296fcbc8c85?source=collection_archive---------0-----------------------#2017-04-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/37214e67a06d78513aa4ec8502630b9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fd8wNWDC5Wmh2R58PzZSNw.jpeg"/></div></div></figure><p id="4c2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇博客的灵感来自 Siraj Raval 在 Udacity 的<a class="ae kw" href="https://www.udacity.com/course/deep-learning-nanodegree-foundation--nd101" rel="noopener ugc nofollow" target="_blank">深度学习基金会纳米学位</a>。那么回购这种做法可以在<a class="ae kw" href="https://github.com/llSourcell/recommender_live" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="65a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">建立推荐系统是亚马逊、网飞、Spotify 和谷歌面临的共同任务。推荐系统的基本目标是为我们的观众个性化内容和识别相关数据。这些内容可以是文章、电影、游戏等</p><p id="6af9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有 3 种类型的推荐系统:基于内容的、协作的和流行的。</p><p id="c915" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本练习中，我们将学习如何使用真实数据构建音乐推荐系统。我们的<a class="ae kw" href="http://labrosa.ee.columbia.edu/millionsong" rel="noopener ugc nofollow" target="_blank">百万首歌曲数据集</a>包含两个文件:<a class="ae kw" href="https://static.turi.com/datasets/millionsong/10000.txt" rel="noopener ugc nofollow" target="_blank">三元组 _ 文件</a>和<a class="ae kw" href="https://static.turi.com/datasets/millionsong/song_data.csv" rel="noopener ugc nofollow" target="_blank">元数据 _ 文件</a>。三元组文件包含用户 id、歌曲 id 和收听时间。元数据文件包含歌曲 id、标题、发行人和艺术家姓名。百万歌曲数据集是来自不同网站的歌曲的混合，用户在听完歌曲后给出评级。例如<a class="ae kw" href="http://labrosa.ee.columbia.edu/millionsong/lastfm" rel="noopener ugc nofollow" target="_blank"> Last.fm </a>、<a class="ae kw" href="https://labrosa.ee.columbia.edu/millionsong/thisismyjam" rel="noopener ugc nofollow" target="_blank"> thisismyjam </a>、<a class="ae kw" href="http://labrosa.ee.columbia.edu/millionsong/musixmatch" rel="noopener ugc nofollow" target="_blank"> musixmatch </a>等</p><p id="f328" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的第一项工作是整合我们的数据集，这在每次我们想要构建数据处理管道时都非常重要。为了集成三元组文件和元数据文件，我们将使用一个流行的 Python 库，名为<a class="ae kw" href="http://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> pandas </a></p><p id="23f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们首先定义将要使用的两个文件:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="44ef" class="lg lh iq lc b gy li lj l lk ll">triplets_file = 'https://static.turi.com/datasets/millionsong/10000.txt'</span><span id="e168" class="lg lh iq lc b gy lm lj l lk ll">songs_metadata_file = 'https://static.turi.com/datasets/millionsong/song_data.csv'</span></pre><p id="4aa8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们使用 pandas 读取三元组文件表，并将这 3 列定义为 user_id、song_id 和 listen_count ( <code class="fe ln lo lp lc b">df </code>在这里表示数据帧)</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="2f5f" class="lg lh iq lc b gy li lj l lk ll">song_df_1 = pandas.read_table(triplets_file,header=<strong class="lc ir">None</strong>)<br/>song_df_1.columns = ['user_id', 'song_id', 'listen_count']</span></pre><p id="6874" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还读取了 metadat_file，并打算将 metadat _ file 与 triplets_file 合并。每当组合两个或更多数据集时，都会有重复的列。这里，我们使用 song_id 删除两个数据集之间的重复项</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="e3a7" class="lg lh iq lc b gy li lj l lk ll"><br/>song_df_2 =  pandas.read_csv(songs_metadata_file)<br/><br/>song_df = pandas.merge(song_df_1, song_df_2.drop_duplicates(['song_id']), on="song_id", how="left")</span></pre><p id="25b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用命令<code class="fe ln lo lp lc b">song_df.head()</code>允许我们可视化组合数据集:</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lq"><img src="../Images/ff9f3130d52406cbac6d1e4850a41907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7F-Icfi0o2EL4-eRMXH14g.png"/></div></div></figure><p id="62f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有歌曲索引、用户标识、歌曲标识、收听次数、标题、发行版本和艺术家名称。运行<code class="fe ln lo lp lc b">len(song_df)</code>返回这个数据集按歌曲索引的总长度是 2，000，000。</p><p id="f8e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本练习的第二步是数据转换，我们将选择该数据的一个子集(前 10，000 首歌曲)。然后，我们将歌曲和 artist_name 合并到一个列中，按照特定歌曲被所有用户收听的次数进行汇总。下面代码中的第一行按照 listen_count 的升序对 song_df 进行分组。第二行通过对每首歌曲的 listen_count 求和来计算 group_sum。第三行添加了一个名为<code class="fe ln lo lp lc b">percentage</code>的新列，通过将 listen_count 除以所有歌曲的 listen_count 之和然后乘以 100 来计算这个百分比。最后一行按给定歌曲流行度的升序列出歌曲</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="bde4" class="lg lh iq lc b gy li lj l lk ll">song_grouped = song_df.groupby(['song']).agg({'listen_count': 'count'}).reset_index()<br/>grouped_sum = song_grouped['listen_count'].sum()<br/>song_grouped['percentage']  = song_grouped['listen_count'].div(grouped_sum)*100<br/>song_grouped.sort_values(['listen_count', 'song'], ascending = [0,1])</span></pre><p id="262c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是转换步骤后数据集的示例:</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lr"><img src="../Images/f7fafdc558fc08b02d93dfcd57dffdd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gVEWkr_Fj_hw9CxvYLhGxw.png"/></div></div></figure><p id="f4d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">进行数据转换使我们能够进一步简化数据集，并使其易于理解。</p><p id="4e86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步，在构建推荐系统时，我们将遵循一种简单的方法。我们将统计数据子集中独立用户和歌曲的数量</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="0906" class="lg lh iq lc b gy li lj l lk ll">users = song_df['user_id'].unique()<br/>len(users) ## return 365 unique users</span><span id="62a1" class="lg lh iq lc b gy lm lj l lk ll">songs = song_df['song'].unique()<br/>len(songs) ## return 5151 unique songs</span></pre><p id="6b04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们通过将数据集分成训练和测试数据来创建歌曲推荐器。我们使用<code class="fe ln lo lp lc b">scikit-learn</code>库的<code class="fe ln lo lp lc b">train_test_split</code>功能。值得注意的是，每当我们构建机器学习系统时，在训练我们的模型之前，我们总是希望将我们的数据分成训练和测试数据集</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="49e1" class="lg lh iq lc b gy li lj l lk ll">train_data, test_data = train_test_split(song_df, test_size = 0.20, random_state=0)</span></pre><p id="30dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们任意选择 20%作为我们的测试规模。然后，我们使用基于流行度的<a class="ae kw" href="https://github.com/dvysardana/RecommenderSystems_PyData_2016/blob/master/Recommenders.py" rel="noopener ugc nofollow" target="_blank">推荐器类</a>作为黑盒来训练我们的模型。我们创建了一个基于流行度的推荐类的实例，并用我们的训练数据来填充它。下面的代码实现了以下目标:基于每首歌曲的流行度，创建一个推荐器，它接受一个<code class="fe ln lo lp lc b">user_id</code>作为输入，并输出该用户的推荐歌曲列表</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="30ea" class="lg lh iq lc b gy li lj l lk ll">pm = Recommenders.popularity_recommender_py()<br/>pm.create(train_data, 'user_id', 'song')</span><span id="ae13" class="lg lh iq lc b gy lm lj l lk ll">#user the popularity model to make some prediction<br/>user_id = users[5]<br/>pm.recommend(user_id)</span></pre><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ls"><img src="../Images/b705c82c30014b8688c40120e4d05bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bTjP-ls6s8NOY8mR0HXoJg.png"/></div></div></figure><p id="36ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">推荐系统模型的代码如下。这个系统是一个幼稚的方法，没有个性化。它首先获得每首歌曲的 user_id 的唯一计数(即该歌曲通常被所有用户收听的次数),并将其标记为推荐分数。然后，<code class="fe ln lo lp lc b">recommend</code>函数接受一个 user_id，并为任何给定用户输出前十首推荐歌曲。因为这是幼稚的方法，所以推荐不是个性化的，对所有用户都是一样的。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="d863" class="lg lh iq lc b gy li lj l lk ll">#Class for Popularity based Recommender System modelclass popularity_recommender_py():    <br/>    def __init__(self):        <br/>    self.train_data = None        <br/>    self.user_id = None        <br/>    self.item_id = None        <br/>    self.popularity_recommendations = None            </span><span id="24a1" class="lg lh iq lc b gy lm lj l lk ll">    #Create the popularity based recommender system model    <br/>    def create(self, train_data, user_id, item_id): <br/>        self.train_data = train_data<br/>        self.user_id = user_id        <br/>        self.item_id = item_id         <br/>        <br/>        #Get a count of user_ids for each unique song as   recommendation score<br/>        train_data_grouped = train_data.groupby([self.item_id]).agg({self.user_id: 'count'}).reset_index()        <br/>        train_data_grouped.rename(columns = {'user_id': 'score'},inplace=True)            </span><span id="81aa" class="lg lh iq lc b gy lm lj l lk ll">        #Sort the songs based upon recommendation score<br/>        train_data_sort = train_data_grouped.sort_values(['score', self.item_id], ascending = [0,1])            </span><span id="f5a1" class="lg lh iq lc b gy lm lj l lk ll">        #Generate a recommendation rank based upon score<br/>        train_data_sort['Rank'] = train_data_sort['score'].rank(ascending=0, method='first')</span><span id="ea64" class="lg lh iq lc b gy lm lj l lk ll">        #Get the top 10 recommendations<br/>        self.popularity_recommendations = train_data_sort.head(10)     </span><span id="d75f" class="lg lh iq lc b gy lm lj l lk ll">        #Use the popularity based recommender system model to    <br/>        #make recommendations    </span><span id="069f" class="lg lh iq lc b gy lm lj l lk ll">    def recommend(self, user_id):            </span><span id="19a8" class="lg lh iq lc b gy lm lj l lk ll">        user_recommendations = self.popularity_recommendations                 </span><span id="638f" class="lg lh iq lc b gy lm lj l lk ll">        #Add user_id column for which the recommendations are being generated        </span><span id="29e2" class="lg lh iq lc b gy lm lj l lk ll">        user_recommendations['user_id'] = user_id            </span><span id="b6ee" class="lg lh iq lc b gy lm lj l lk ll">        #Bring user_id column to the front        <br/>        cols = user_recommendations.columns.tolist()        <br/>        cols = cols[-1:] + cols[:-1]        <br/>        user_recommendations = user_recommendations[cols]<br/>        return user_recommendations</span></pre><p id="e0e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本练习的第二部分是通过利用基于<em class="lt">项</em> <em class="lt">相似性的协同过滤模型来创建一个 ML 个性化歌曲推荐系统。</em>回想一下，推荐系统分为两种类型:<em class="lt">基于内容的</em>和<em class="lt">基于协作的</em>。基于内容的系统根据用户过去喜欢什么来预测用户喜欢什么。基于协作的系统基于其他相似用户的喜好来预测特定用户的喜好。像网飞和 Hulu 这样的大多数公司都使用混合方法，根据用户过去喜欢的内容以及其他类似用户喜欢的内容来提供推荐。</p><p id="f2c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据剑桥编码学院的 Agnes jóhannsdóttir(Twitter:<a class="ae kw" href="https://twitter.com/agnesjohanns" rel="noopener ugc nofollow" target="_blank">@ agnesjohanns</a>)的说法，基于记忆的协同过滤可以分为两种主要方法:用户-项目过滤和项目-项目过滤。</p><p id="ba00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">项目-项目过滤方法包括基于用户喜欢的歌曲定义<a class="ae kw" href="https://blogs.msdn.microsoft.com/carlnol/2012/06/23/co-occurrence-approach-to-an-item-based-recommender/" rel="noopener ugc nofollow" target="_blank">一个共现矩阵</a>。我们试图回答一个问题，对于每首歌曲，已经听过该歌曲的用户还会听另一组其他歌曲多少次。为了进一步简化这一点，根据你过去喜欢什么，根据其他类似用户喜欢什么，你会喜欢什么其他类似的歌曲。让我们将它应用到我们的代码中。首先，我们创建一个基于实例项目相似性的推荐器类，并向它提供我们的训练数据。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="884e" class="lg lh iq lc b gy li lj l lk ll">is_model = Recommenders.item_similarity_recommender_py()<br/>is_model.create(train_data, 'user_id', 'song')</span></pre><p id="fa8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，在推荐系统的<a class="ae kw" href="https://github.com/dvysardana/RecommenderSystems_PyData_2016/blob/master/Recommenders.py" rel="noopener ugc nofollow" target="_blank">源代码</a>中，<code class="fe ln lo lp lc b">generate_top_recommendations</code> <a class="ae kw" href="https://github.com/dvysardana/RecommenderSystems_PyData_2016/blob/master/Recommenders.py#L125" rel="noopener ugc nofollow" target="_blank">函数</a>计算了所有用户歌曲在同现矩阵中得分的加权平均值。这个共现矩阵将趋向于稀疏矩阵，因为不可能预测用户是否喜欢特定歌曲，他/她是否会喜欢一百万首其他歌曲。可能性是如此之大。使用我们的模型，我们将能够预测用户喜欢的歌曲列表</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="ec92" class="lg lh iq lc b gy li lj l lk ll"><em class="lt">#Print the songs for the user in training data</em><br/>user_id = users[5]<br/>user_items = is_model.get_user_items(user_id)<br/><em class="lt">#</em><br/>print("------------------------------------------------------------------------------------")<br/>print("Training data songs for the user userid: <strong class="lc ir">%s</strong>:" % user_id)<br/>print("------------------------------------------------------------------------------------")<br/><br/><strong class="lc ir">for</strong> user_item <strong class="lc ir">in</strong> user_items:<br/>    print(user_item)<br/><br/>print("----------------------------------------------------------------------")<br/>print("Recommendation process going on:")<br/>print("----------------------------------------------------------------------")<br/><br/><em class="lt">#Recommend songs for the user using personalized model</em><br/>is_model.recommend(user_id)</span></pre><p id="86c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="f737" class="lg lh iq lc b gy li lj l lk ll">------------------------------------------------------------------------------------<br/>Training data songs for the user userid: 4bd88bfb25263a75bbdd467e74018f4ae570e5df:<br/>------------------------------------------------------------------------------------<br/>Just Lose It - Eminem<br/>Without Me - Eminem<br/>16 Candles - The Crests<br/>Speechless - Lady GaGa<br/>Push It - Salt-N-Pepa<br/>Ghosts 'n' Stuff (Original Instrumental Mix) - Deadmau5<br/>Say My Name - Destiny's Child<br/>My Dad's Gone Crazy - Eminem / Hailie Jade<br/>The Real Slim Shady - Eminem<br/>Somebody To Love - Justin Bieber<br/>Forgive Me - Leona Lewis<br/>Missing You - John Waite<br/>Ya Nada Queda - Kudai<br/>----------------------------------------------------------------------<br/>Recommendation process going on:<br/>----------------------------------------------------------------------<br/>No. of unique songs for the user: 13<br/>no. of unique songs in the training set: 4483<br/>Non zero values in cooccurence_matrix :2097</span></pre><p id="3b8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还可以使用我们的<em class="lt">基于项目相似性的协作过滤模型</em>来查找与我们数据集中的任何歌曲相似的歌曲:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="b6b0" class="lg lh iq lc b gy li lj l lk ll">is_model.get_similar_items(['U Smile - Justin Bieber'])</span></pre><p id="a48d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个输出</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="2ac0" class="lg lh iq lc b gy li lj l lk ll">no. of unique songs in the training set: 4483<br/>Non zero values in cooccurence_matrix :271</span></pre><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/f3dc1380a57fcffad8d25ee16d769514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XtYH4816dIhqDXtWzGdFVA.png"/></div></div></figure><p id="deea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">值得注意的是，这种方法不是深度学习，而是纯粹基于线性代数。</p><p id="3989" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">概括地说，在本练习中，我们讨论了两种模型。第一种模型是基于流行度的推荐器，这意味着它不会针对任何用户进行个性化，并且会输出相同的推荐歌曲列表。第二个模型是个性化推荐器，利用基于<em class="lt">项</em> <em class="lt">相似性的协同过滤模型(</em>即共现矩阵)来基于其他相似用户已经喜欢的歌曲找到用户可能喜欢的歌曲的个性化列表。</p><p id="68ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来我们将讨论如何使用<em class="lt">精确召回曲线</em>来量化比较基于流行度的模型和个性化协同过滤模型，从而衡量这两个模型的性能。</p><p id="afaf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了定量地衡量推荐系统的性能，我们使用了三种不同的指标:精确度、召回率和 F-1 分数</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/502b066e90dc198282a685bcdc860965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xOy6s_J9a7CGZIrv_cWr5A.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk">Source: <a class="ae kw" href="http://aimotion.blogspot.com/2011/05/evaluating-recommender-systems.html" rel="noopener ugc nofollow" target="_blank">http://aimotion.blogspot.com/2011/05/evaluating-recommender-systems.html</a></figcaption></figure><p id="feaa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据<a class="ae kw" href="http://aimotion.blogspot.com/2011/05/evaluating-recommender-systems.html" rel="noopener ugc nofollow" target="_blank"> Marcel Caraciolo </a>的说法，<em class="lt"> Precision </em>是“相关的顶级结果的比例，考虑到与您的问题领域相关的一些定义”。在我们的案例中，对于我们问题领域相关的定义是一首歌被听的时长，若干用户都喜欢过这首歌。<em class="lt">回忆</em>将“测量所有相关结果在顶部结果中所占的比例”。在我们的例子中，这意味着<em class="lt"> precision </em>试图衡量歌曲与推荐歌曲前十名结果的相关性，而<em class="lt"> recall </em>试图衡量歌曲与所有歌曲的相关性</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/ba000bcc8ab80663218929d8d2b517f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IeXtERBoZtbkxQJscZNX2w.png"/></div></div></figure><p id="77c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">观察我们的基于流行度的模型和个性化项目相似性模型的精确召回曲线，项目相似性模型在精确召回曲线的某个点上表现更好(即具有更高的召回数和精确度)。</p><p id="674c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一类推荐系统是<em class="lt">基于矩阵分解的推荐系统。</em>这种类型的推荐系统使用原始相似矩阵的所谓奇异值分解(SVD)分解矩阵来构建推荐系统。</p><p id="f32e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了计算 SVD 和建议，我们使用以下代码:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="ffed" class="lg lh iq lc b gy li lj l lk ll"><em class="lt">#constants defining the dimensions of our User Rating Matrix (URM)</em> MAX_PID = 4 <br/>MAX_UID = 5  </span><span id="c63e" class="lg lh iq lc b gy lm lj l lk ll"><em class="lt">#Compute SVD of the user ratings matrix</em> </span><span id="fc37" class="lg lh iq lc b gy lm lj l lk ll"><strong class="lc ir">def</strong> computeSVD(urm, K):     <br/>    U, s, Vt = sparsesvd(urm, K)      <br/>    dim = (len(s), len(s))     <br/>    S = np.zeros(dim, dtype=np.float32)     <br/>    <strong class="lc ir">for</strong> i <strong class="lc ir">in</strong> range(0, len(s)):         <br/>        S[i,i] = mt.sqrt(s[i])      <br/>        U = csc_matrix(np.transpose(U), dtype=np.float32)     <br/>        S = csc_matrix(S, dtype=np.float32)     <br/>        Vt = csc_matrix(Vt, dtype=np.float32)          <br/>        <strong class="lc ir">return</strong> U, S, Vt</span></pre><p id="fde7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这段代码中，U 代表用户向量，S 代表项目向量。Vt 将这两个向量的结合点表示为 2 维空间中的点的集合(即向量)。我们将使用这些向量来衡量一个用户的偏好与另一个用户的偏好之间的距离。</p><p id="cf77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">换句话说，我们对矩阵进行矢量化，以计算矩阵之间的距离。为了进一步阐明这一点，我们将通过一个例子来说明。假设我们有一个用户歌曲矩阵如下:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="c46e" class="lg lh iq lc b gy li lj l lk ll">        Song0   Song1   Song2   Song3 <br/>User0   3       1       2       3<br/>User1   4       3       4       3<br/>User2   3       2       1       5<br/>User3   1       6       5       2<br/>User4   0       0       5       0</span></pre><p id="ff76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们执行 SVD，输出将是向量，测量向量之间的距离给我们建议</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="1407" class="lg lh iq lc b gy li lj l lk ll">#Compute estimated rating for the test user<br/>def computeEstimatedRatings(urm, U, S, Vt, uTest, K, test):<br/>    rightTerm = S*Vt</span><span id="f4e5" class="lg lh iq lc b gy lm lj l lk ll">    estimatedRatings = np.zeros(shape=(MAX_UID, MAX_PID), dtype=np.float16)<br/>    for userTest in uTest:<br/>        prod = U[userTest, :]*rightTerm<br/>        #we convert the vector to dense format in order to get the     #indices<br/>        #of the movies with the best estimated ratings <br/>        estimatedRatings[userTest, :] = prod.todense()<br/>        recom = (-estimatedRatings[userTest, :]).argsort()[:250]<br/>    return recom</span><span id="9440" class="lg lh iq lc b gy lm lj l lk ll"><br/>#Used in SVD calculation (number of latent factors)<br/>K=2</span><span id="87cc" class="lg lh iq lc b gy lm lj l lk ll">#Initialize a sample user rating matrix<br/>urm = np.array([[3, 1, 2, 3],[4, 3, 4, 3],[3, 2, 1, 5], [1, 6, 5, 2], [5, 0,0 , 0]])<br/>urm = csc_matrix(urm, dtype=np.float32)</span><span id="d0a5" class="lg lh iq lc b gy lm lj l lk ll">#Compute SVD of the input user ratings matrix<br/>U, S, Vt = computeSVD(urm, K)</span><span id="5bae" class="lg lh iq lc b gy lm lj l lk ll">#Test user set as user_id 4 with ratings [0, 0, 5, 0]<br/>uTest = [4]<br/>print("User id for whom recommendations are needed: %d" % uTest[0])</span><span id="cc2e" class="lg lh iq lc b gy lm lj l lk ll">#Get estimated rating for test user<br/>print("Predictied ratings:")<br/>uTest_recommended_items = computeEstimatedRatings(urm, U, S, Vt, uTest, K, True)<br/>print(uTest_recommended_items)</span></pre><p id="c630" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将输出:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="c00a" class="lg lh iq lc b gy li lj l lk ll">User id for whom recommendations are needed: 4<br/>Predictied ratings:<br/>[0 3 2 1]</span></pre><p id="bd19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们讨论真实世界的例子，Hulu 如何将深度学习应用于协同过滤，以建立其行业领先的推荐系统。在 Hulu，像个性化报头、观察列表和最佳选择等功能都是由协同过滤提供支持的。</p><p id="f7aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Hulu 使用的方法是 CF-NADE。我们举个例子。假设我们有 4 部电影:《变形金刚》、《海绵宝宝》、《忍者神龟》、《星际穿越》，评分分别为 4、2、3、5。在 CF-NADE 中，向量(4，2，3，5)的联合概率通过链规则分解为条件的乘积，条件如下:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="82f5" class="lg lh iq lc b gy li lj l lk ll">1/ The probability that the user gives “Transformers” 4-star conditioned on nothing;</span><span id="cb3c" class="lg lh iq lc b gy lm lj l lk ll">2/ The probability that the user gives “SpongeBob” 2-star conditioned on giving “Transformers” 4-star;</span><span id="e87e" class="lg lh iq lc b gy lm lj l lk ll">3/ The probability that the user gives “Teenage Mutant Ninja Turtles” a 3-star conditioned on giving 4-star and 2-star to “Transformers” and “SpongeBob”, respectively;</span><span id="11b9" class="lg lh iq lc b gy lm lj l lk ll">4/ The probability that the user gives “Interstellar” a 5-star conditioned on giving 4-star, 2-star and 3-star to “Transformers”, “SpongeBob” and “Teenage Mutant Ninja Turtles”, respectively;</span></pre><p id="15e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总而言之，这是基于先前发生的事情的概率链。每个条件由其自己的神经网络建模，并且所有这些神经网络的参数在所有模型之间共享。</p><p id="242e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来源:</p><p id="228e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1/Siraj Raval 的深度学习基金会 nano degree(<a class="ae kw" href="https://www.udacity.com/course/deep-learning-nanodegree-foundation--nd101" rel="noopener ugc nofollow" target="_blank">https://www . uda city . com/course/Deep-Learning-nano degree-Foundation-nd 101</a>)</p><p id="f6de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2/【https://www.youtube.com/watch?v=18adykNGhHU T4】</p><p id="c49f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3/<a class="ae kw" href="https://github.com/llSourcell/recommender_live" rel="noopener ugc nofollow" target="_blank">https://github.com/llSourcell/recommender_live</a></p><p id="27ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4/将深度学习应用于协同过滤:Hulu 如何建立其行业领先地位(<a class="ae kw" href="http://tech.hulu.com/blog/2016/08/01/cfnade.html" rel="noopener ugc nofollow" target="_blank">http://tech.hulu.com/blog/2016/08/01/cfnade.html</a>)</p><p id="c13a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">5/用 Python 实现自己的推荐系统(<a class="ae kw" href="http://online-dev.cambridgecoding.com/notebooks/eWReNYcAfB/implementing-your-own-recommender-systems-in-python-2" rel="noopener ugc nofollow" target="_blank">http://online-dev . Cambridge coding . com/notebooks/eWReNYcAfB/Implementing-your-own-recommender-systems-in-Python-2</a>)</p></div></div>    
</body>
</html>