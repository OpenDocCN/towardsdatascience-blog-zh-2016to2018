<html>
<head>
<title>Machine Learning with PySpark and MLlib — Solving a Binary Classification Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于 PySpark 和 MLlib 的机器学习——解决二元分类问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-with-pyspark-and-mllib-solving-a-binary-classification-problem-96396065d2aa?source=collection_archive---------0-----------------------#2018-05-06">https://towardsdatascience.com/machine-learning-with-pyspark-and-mllib-solving-a-binary-classification-problem-96396065d2aa?source=collection_archive---------0-----------------------#2018-05-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9020c36dd297b8ed7f859d99697ebfb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J_4joYwf_HHMbBt8s1Kuqw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo Credit: Pixabay</figcaption></figure><p id="7101" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://spark.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Spark </a>，曾经是<a class="ae la" href="http://hadoop.apache.org/" rel="noopener ugc nofollow" target="_blank"> Hadoop </a>生态系统的一个组成部分，现在正成为企业首选的大数据平台。它是一个强大的开源引擎，提供实时流处理、交互式处理、图形处理、内存处理以及批处理，速度非常快，易于使用，接口标准。</p><p id="4719" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这个行业中，有一个强大的引擎，可以做到以上所有的需求很大。你的公司或客户迟早会使用 Spark 开发复杂的模型，让你发现新的机会或规避风险。Spark 并不难学，如果你已经了解 Python 和 SQL，入门非常容易。今天就来试试吧！</p><h1 id="314b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">探索数据</h1><p id="34b8" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">当我们<a class="ae la" rel="noopener" target="_blank" href="/building-a-logistic-regression-in-python-step-by-step-becd4d56c9c8">用 Python </a>构建逻辑回归时，我们将使用相同的数据集，它与一家葡萄牙银行机构的直接营销活动(电话)相关。分类的目标是预测客户是否会认购(是/否)定期存款。数据集可以从<a class="ae la" href="https://www.kaggle.com/rouseguy/bankbalanced/data" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>下载。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1f59" class="mn lc iq mj b gy mo mp l mq mr">from pyspark.sql import SparkSession<br/>spark = SparkSession.builder.appName('ml-bank').getOrCreate()<br/>df = spark.read.csv('bank.csv', header = True, inferSchema = True)<br/>df.printSchema()</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/506559cc051fab50e87c1dcb85cc34e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*TULzFyy4X2Y4ijn1_Evy1A.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 1</figcaption></figure><p id="bdb0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">输入变量:年龄、工作、婚姻、教育、违约、余额、住房、贷款、联系人、日、月、持续时间、活动、pdays、先前、poutcome。</p><p id="2559" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">产出变量:存款</p><p id="35a4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">先看一下前五个观察结果。熊猫数据框比 Spark DataFrame.show()好看。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2796" class="mn lc iq mj b gy mo mp l mq mr">import pandas as pd<br/>pd.DataFrame(df.take(5), columns=df.columns).transpose()</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/417fc4d1783942314979856c0a57390e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*xhryNF7_oYQr8p8kFKcztQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 2</figcaption></figure><p id="0835" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的班级非常平衡。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8469" class="mn lc iq mj b gy mo mp l mq mr">import pandas as pd<br/>pd.DataFrame(df.take(5), columns=df.columns).transpose()</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/0b6bc4573dacb5b6944cffae46245858.png" data-original-src="https://miro.medium.com/v2/resize:fit:332/format:webp/1*3tToVqZhiZEQYJnn-nVgeQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 3</figcaption></figure><p id="d9ce" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">数字变量的汇总统计</strong></p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="689b" class="mn lc iq mj b gy mo mp l mq mr">numeric_features = [t[0] for t in df.dtypes if t[1] == 'int']<br/>df.select(numeric_features).describe().toPandas().transpose()</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/eaada548b0e2c9541a8ddb387a873a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*isbhHT-K4BXHGkRIMvuVOQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 4</figcaption></figure><p id="fedf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">自变量之间的相关性</strong>。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f75b" class="mn lc iq mj b gy mo mp l mq mr">numeric_data = df.select(numeric_features).toPandas()</span><span id="eb8f" class="mn lc iq mj b gy mw mp l mq mr">axs = pd.scatter_matrix(numeric_data, figsize=(8, 8));</span><span id="0ead" class="mn lc iq mj b gy mw mp l mq mr">n = len(numeric_data.columns)<br/>for i in range(n):<br/>    v = axs[i, 0]<br/>    v.yaxis.label.set_rotation(0)<br/>    v.yaxis.label.set_ha('right')<br/>    v.set_yticks(())<br/>    h = axs[n-1, i]<br/>    h.xaxis.label.set_rotation(90)<br/>    h.set_xticks(())</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/b26c641210f3ad0da5b1f09a37c4fb5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*zdOEcTGPGEYPWR0Nte4nvQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 5</figcaption></figure><p id="d32c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">很明显，没有高度相关的数值变量。因此，我们将为模型保留它们。然而，日和月列并不真正有用，我们将删除这两列。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9faf" class="mn lc iq mj b gy mo mp l mq mr">df = df.select('age', 'job', 'marital', 'education', 'default', 'balance', 'housing', 'loan', 'contact', 'duration', 'campaign', 'pdays', 'previous', 'poutcome', 'deposit')<br/>cols = df.columns<br/>df.printSchema()</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/7c880624a1a60bdcd3df02cce31b8f07.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*lNOW_Pgz36NDeHvteQeBEQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 6</figcaption></figure><h1 id="a1ef" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为机器学习准备数据</h1><p id="c0b6" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">该过程包括类别索引、一键编码和 vector assembler——一种将多个列合并为一个向量列的特征转换器。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e5b8" class="mn lc iq mj b gy mo mp l mq mr">from pyspark.ml.feature import OneHotEncoderEstimator, StringIndexer, VectorAssembler</span><span id="28ee" class="mn lc iq mj b gy mw mp l mq mr">categoricalColumns = ['job', 'marital', 'education', 'default', 'housing', 'loan', 'contact', 'poutcome']<br/>stages = []</span><span id="8a5c" class="mn lc iq mj b gy mw mp l mq mr">for categoricalCol in categoricalColumns:<br/>    stringIndexer = StringIndexer(inputCol = categoricalCol, outputCol = categoricalCol + 'Index')<br/>    encoder = OneHotEncoderEstimator(inputCols=[stringIndexer.getOutputCol()], outputCols=[categoricalCol + "classVec"])<br/>    stages += [stringIndexer, encoder]</span><span id="f991" class="mn lc iq mj b gy mw mp l mq mr">label_stringIdx = StringIndexer(inputCol = 'deposit', outputCol = 'label')<br/>stages += [label_stringIdx]</span><span id="2d85" class="mn lc iq mj b gy mw mp l mq mr">numericCols = ['age', 'balance', 'duration', 'campaign', 'pdays', 'previous']<br/>assemblerInputs = [c + "classVec" for c in categoricalColumns] + numericCols<br/>assembler = VectorAssembler(inputCols=assemblerInputs, outputCol="features")<br/>stages += [assembler]</span></pre><p id="2b3e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">上面的代码取自<a class="ae la" href="https://docs.databricks.com/spark/latest/mllib/binary-classification-mllib-pipelines.html" rel="noopener ugc nofollow" target="_blank"> databricks 的官方网站</a>，它使用 StringIndexer 对每个分类列进行索引，然后将索引的类别转换为 one-hot 编码变量。结果输出将二进制向量附加到每一行的末尾。我们再次使用 StringIndexer 将标签编码为标签索引。接下来，我们使用 VectorAssembler 将所有的特性列合并成一个向量列。</p><p id="8fae" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">管道</strong></p><p id="a6ba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们使用管道将多个转换器和估计器链接在一起，以指定我们的机器学习工作流程。管道的阶段被指定为有序数组。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="39fa" class="mn lc iq mj b gy mo mp l mq mr">from pyspark.ml import Pipeline<br/>pipeline = Pipeline(stages = stages)<br/>pipelineModel = pipeline.fit(df)<br/>df = pipelineModel.transform(df)<br/>selectedCols = ['label', 'features'] + cols<br/>df = df.select(selectedCols)<br/>df.printSchema()</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/a259fa2f05801c71d9bdbe65f0477beb.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*DxErv3vt9xYXBKNybxhTLw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 7</figcaption></figure><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="09d8" class="mn lc iq mj b gy mo mp l mq mr">pd.DataFrame(df.take(5), columns=df.columns).transpose()</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/c02b84df1af1158e793849e9b712ca46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FKhz3gm81yaZM6ivhrAfWg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 8</figcaption></figure><p id="d4d4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如您所见，我们现在有“功能”列和“标签”列。</p><p id="83ed" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将数据随机分为训练集和测试集，并为可重复性设置种子。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c561" class="mn lc iq mj b gy mo mp l mq mr">train, test = df.randomSplit([0.7, 0.3], seed = 2018)<br/>print("Training Dataset Count: " + str(train.count()))<br/>print("Test Dataset Count: " + str(test.count()))</span></pre><p id="8bb3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="nb">训练数据集计数:7764 <br/>测试数据集计数:3398 </em> </strong></p><h1 id="0aca" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">逻辑回归模型</h1><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3ccc" class="mn lc iq mj b gy mo mp l mq mr">from pyspark.ml.classification import LogisticRegression</span><span id="f88c" class="mn lc iq mj b gy mw mp l mq mr">lr = LogisticRegression(featuresCol = 'features', labelCol = 'label', maxIter=10)<br/>lrModel = lr.fit(train)</span></pre><p id="9515" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以通过使用 LogisticRegressionModel 的属性获得<strong class="ke ir">系数</strong>。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2a9b" class="mn lc iq mj b gy mo mp l mq mr">import matplotlib.pyplot as plt<br/>import numpy as np</span><span id="0fa7" class="mn lc iq mj b gy mw mp l mq mr">beta = np.sort(lrModel.coefficients)</span><span id="43f2" class="mn lc iq mj b gy mw mp l mq mr">plt.plot(beta)<br/>plt.ylabel('Beta Coefficients')<br/>plt.show()</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/b8873e796e7c7e9afa2fe0a988726276.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*Z3ihFTH7jIE-9WyL6sVuIg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 9</figcaption></figure><p id="2e7a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在训练集上总结模型，我们还可以得到<strong class="ke ir">接收机操作特性和 areaUnderROC </strong>。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d6e9" class="mn lc iq mj b gy mo mp l mq mr">trainingSummary = lrModel.summary</span><span id="c022" class="mn lc iq mj b gy mw mp l mq mr">roc = trainingSummary.roc.toPandas()<br/>plt.plot(roc['FPR'],roc['TPR'])<br/>plt.ylabel('False Positive Rate')<br/>plt.xlabel('True Positive Rate')<br/>plt.title('ROC Curve')<br/>plt.show()</span><span id="ae45" class="mn lc iq mj b gy mw mp l mq mr">print('Training set areaUnderROC: ' + str(trainingSummary.areaUnderROC))</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/bfda1eeb32f3738d0d44ec2fab42062f.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*PcKw72q-RncZWOwhPItUYA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 10</figcaption></figure><p id="e63f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">精度和召回</strong>。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9718" class="mn lc iq mj b gy mo mp l mq mr">pr = trainingSummary.pr.toPandas()<br/>plt.plot(pr['recall'],pr['precision'])<br/>plt.ylabel('Precision')<br/>plt.xlabel('Recall')<br/>plt.show()</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/c8e3f2a9770f4295cb141e452c9f4644.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*6phlTrWSfaT53zh8_3LWRQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 11</figcaption></figure><p id="d223" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">对测试集</strong>进行预测。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7f66" class="mn lc iq mj b gy mo mp l mq mr">predictions = lrModel.transform(test)<br/>predictions.select('age', 'job', 'label', 'rawPrediction', 'prediction', 'probability').show(10)</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/b72d464dda8cae300fe6aac3e7380910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*23XUWWuvbjp5ADgIoaZApw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 12</figcaption></figure><p id="3962" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">评估我们的逻辑回归模型</strong>。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1eb4" class="mn lc iq mj b gy mo mp l mq mr">from pyspark.ml.evaluation import BinaryClassificationEvaluator</span><span id="c685" class="mn lc iq mj b gy mw mp l mq mr">evaluator = BinaryClassificationEvaluator()<br/>print('Test Area Under ROC', evaluator.evaluate(predictions))</span></pre><p id="3868" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"><em class="nb">ROC 0.88324614449619</em></strong>下的测试区域</p><h1 id="a190" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">决策树分类器</h1><p id="9fc6" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">决策树被广泛使用，因为它们易于解释、处理分类特征、扩展到多类分类、不需要特征缩放，并且能够捕捉非线性和特征交互。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8786" class="mn lc iq mj b gy mo mp l mq mr">from pyspark.ml.classification import DecisionTreeClassifier</span><span id="bbf4" class="mn lc iq mj b gy mw mp l mq mr">dt = DecisionTreeClassifier(featuresCol = 'features', labelCol = 'label', maxDepth = 3)<br/>dtModel = dt.fit(train)<br/>predictions = dtModel.transform(test)<br/>predictions.select('age', 'job', 'label', 'rawPrediction', 'prediction', 'probability').show(10)</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/30921d65d75916aad25abca5120b9d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*9v_WdJYGdwNwvikEBPAfaw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 13</figcaption></figure><p id="a0db" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">评估我们的决策树模型</strong>。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f71d" class="mn lc iq mj b gy mo mp l mq mr">evaluator = BinaryClassificationEvaluator()<br/>print("Test Area Under ROC: " + str(evaluator.evaluate(predictions, {evaluator.metricName: "areaUnderROC"})))</span></pre><p id="fe86" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"><em class="nb">ROC 下的测试区域:0.7807240050065357 </em> </strong></p><p id="4f6a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一个简单的决策树表现不佳，因为它在不同特征的范围内太弱。集成方法可以提高决策树的预测精度，如随机森林和梯度提升树。</p><h1 id="67ec" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">随机森林分类器</h1><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5995" class="mn lc iq mj b gy mo mp l mq mr">from pyspark.ml.classification import RandomForestClassifier</span><span id="70d0" class="mn lc iq mj b gy mw mp l mq mr">rf = RandomForestClassifier(featuresCol = 'features', labelCol = 'label')<br/>rfModel = rf.fit(train)<br/>predictions = rfModel.transform(test)<br/>predictions.select('age', 'job', 'label', 'rawPrediction', 'prediction', 'probability').show(10)</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/8b82709396c1876a4481ca3b9dab6f7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*rmkfZ6sW2DqNVEENdqQZrw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 14</figcaption></figure><p id="8d53" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">评估我们的随机森林分类器。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a9a3" class="mn lc iq mj b gy mo mp l mq mr">evaluator = BinaryClassificationEvaluator()<br/>print("Test Area Under ROC: " + str(evaluator.evaluate(predictions, {evaluator.metricName: "areaUnderROC"})))</span></pre><p id="8c99" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"><em class="nb">ROC 下的测试区域:0.8846453518867426 </em> </strong></p><h1 id="ee12" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">梯度增强树分类器</h1><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fb42" class="mn lc iq mj b gy mo mp l mq mr">from pyspark.ml.classification import GBTClassifier</span><span id="9b60" class="mn lc iq mj b gy mw mp l mq mr">gbt = GBTClassifier(maxIter=10)<br/>gbtModel = gbt.fit(train)<br/>predictions = gbtModel.transform(test)<br/>predictions.select('age', 'job', 'label', 'rawPrediction', 'prediction', 'probability').show(10)</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/130bba968e0571c6d36c2ebab73cd5ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*g2uohpSKLFm4cO8qnso9SA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 15</figcaption></figure><p id="4935" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">评估我们的梯度增强树分类器。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c2a7" class="mn lc iq mj b gy mo mp l mq mr">evaluator = BinaryClassificationEvaluator()<br/>print("Test Area Under ROC: " + str(evaluator.evaluate(predictions, {evaluator.metricName: "areaUnderROC"})))</span></pre><p id="baf1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"><em class="nb">ROC 下的测试区域:0.8940728473145346 </em> </strong></p><p id="0596" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">梯度提升树取得了最好的结果，我们将尝试用 ParamGridBuilder 和 CrossValidator 调整这个模型。在此之前，我们可以使用 explainParams()打印所有参数及其定义的列表，以了解哪些参数可用于调优。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7188" class="mn lc iq mj b gy mo mp l mq mr">print(gbt.explainParams())</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/5139fb1762a55851e77db6cfc4170c8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*voLTp-IKD8u5cQkdwYc2Ag.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Figure 16</figcaption></figure><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1f22" class="mn lc iq mj b gy mo mp l mq mr">from pyspark.ml.tuning import ParamGridBuilder, CrossValidator</span><span id="c8b6" class="mn lc iq mj b gy mw mp l mq mr">paramGrid = (ParamGridBuilder()<br/>             .addGrid(gbt.maxDepth, [2, 4, 6])<br/>             .addGrid(gbt.maxBins, [20, 60])<br/>             .addGrid(gbt.maxIter, [10, 20])<br/>             .build())</span><span id="5151" class="mn lc iq mj b gy mw mp l mq mr">cv = CrossValidator(estimator=gbt, estimatorParamMaps=paramGrid, evaluator=evaluator, numFolds=5)</span><span id="1502" class="mn lc iq mj b gy mw mp l mq mr"># Run cross validations.  This can take about 6 minutes since it is training over 20 trees!<br/>cvModel = cv.fit(train)<br/>predictions = cvModel.transform(test)<br/>evaluator.evaluate(predictions)</span></pre><p id="c81e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"><em class="nb">0.8981050997838095</em></strong></p><p id="ffc0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">综上所述，我们已经学习了如何使用 PySpark 和 MLlib Pipelines API 构建二进制分类应用程序。我们尝试了四种算法，梯度提升在我们的数据集上表现最好。</p><p id="7434" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">源代码可以在<a class="ae la" href="https://github.com/susanli2016/PySpark-and-MLlib/blob/master/Machine%20Learning%20PySpark%20and%20MLlib.ipynb" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。我期待听到反馈或问题。</p><p id="64d8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://spark.apache.org/docs/2.1.0/ml-classification-regression.html#linear-regression" rel="noopener ugc nofollow" target="_blank">参考:阿帕奇 Spark 2.1.0 </a></p></div></div>    
</body>
</html>