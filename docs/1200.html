<html>
<head>
<title>Using Recurrent Neural Networks for Track Detection In Noise</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用递归神经网络进行噪声中的轨迹检测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-recurrent-neural-networks-for-track-detection-in-noise-5e6395c8afae?source=collection_archive---------9-----------------------#2017-08-09">https://towardsdatascience.com/using-recurrent-neural-networks-for-track-detection-in-noise-5e6395c8afae?source=collection_archive---------9-----------------------#2017-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="1c0a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak"> <em class="kl">动机</em> </strong></h1><p id="2906" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">通过观察<a class="ae lk" href="https://en.wikipedia.org/wiki/Sonar" rel="noopener ugc nofollow" target="_blank">声纳</a>或<a class="ae lk" href="https://en.wikipedia.org/wiki/Radar" rel="noopener ugc nofollow" target="_blank">雷达</a>屏幕，人类可以很容易地探测到轨迹，这些轨迹是由通常距离很远且只能作为点来观察的物体形成的。即使在有噪声的图像中，也可以在视觉上检测到相应的点图案。此外，当轨迹在噪音中不断出现和消失时，训练有素的操作员可以快速判断不相关的轨迹本身是否形成了可能与同一物体相关的轨迹模式。</p><p id="5677" class="pw-post-body-paragraph km kn iq ko b kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf lp lh li lj ij bi translated">需要上述观察来做出关于物体存在或不存在的决定。例如，如果物体与噪声相比非常亮，那么可以通过观察(或检测)单个亮点来做出这样的决定。然而，如果与噪声相关的点表现出与感兴趣的对象相当的亮度，我们最终会得到许多错误的检测。作为对象检测的下一步，我们假设噪声是均匀的，因此与噪声相关的点不会形成轨迹。然而，如果噪声分布不均匀，与噪声相关的点也会形成短轨迹。因此，我们以错误的轨迹检测结束。当由于噪声，感兴趣对象的轨迹很短，使得它们出现和消失，表现出噪声轨迹间歇性时，就会出现这种情况。在这种情况下，人类观察者会寻找与单个物体相关的轨迹模式。一旦发现这种轨迹模式，就可以宣布感兴趣的物体的存在。</p><p id="1042" class="pw-post-body-paragraph km kn iq ko b kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf lp lh li lj ij bi translated">另一方面，随着噪声水平的增加和要跟踪的对象数量的增加，现有的基于对象运动建模的<a class="ae lk" href="https://en.wikipedia.org/wiki/Track_algorithm" rel="noopener ugc nofollow" target="_blank">跟踪算法</a>必须处理指数级增加的计算复杂度。还应该注意，执行各自的计算增加了数据处理功耗，同时需要强大的处理器和增加的存储器。</p><p id="9602" class="pw-post-body-paragraph km kn iq ko b kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf lp lh li lj ij bi translated">最近在机器学习(例如深度学习，<a class="ae lk" href="https://en.wikipedia.org/wiki/Deep_learning" rel="noopener ugc nofollow" target="_blank"> DL </a>)的各种应用中取得的重大进展已经证明了匹配甚至超过人类能力的结果(例如在下棋或下围棋方面)。在Raspberry Pi等小型单板计算机上成功实现训练好的DL表明，使用廉价的自主、低功耗机器人解决目标检测、跟踪和定位问题可能是DL应用的新方向。</p><h1 id="b1bd" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">方法</h1><p id="8df8" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在这项工作中，我将研究二进制(即黑白)图像中轨迹检测的玩具问题。各自的Python代码，写为Jupyter notebook，使用<a class="ae lk" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank"> Keras </a>框架，可在<a class="ae lk" href="https://github.com/GeorgeMadlis/Track-detection-in-noise" rel="noopener ugc nofollow" target="_blank">这里获得。下面，我展示了这段代码的主要模块和计算的输出。</a></p><p id="68c1" class="pw-post-body-paragraph km kn iq ko b kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf lp lh li lj ij bi translated">下面显示的问题不是一个小问题，它的成功保证了在这个领域的进一步研究。下面我实现了一种循环神经网络(<a class="ae lk" href="https://en.wikipedia.org/wiki/Recurrent_neural_network" rel="noopener ugc nofollow" target="_blank"> RNN </a>)，叫做长短期记忆(<a class="ae lk" href="https://en.wikipedia.org/wiki/Long_short-term_memory" rel="noopener ugc nofollow" target="_blank"> LSTM </a>)网络。想法是应用可以同时使用空间和时间信息的算法，以便能够捕获在噪声中呈现间歇出现和消失的对象的模式。</p><p id="62af" class="pw-post-body-paragraph km kn iq ko b kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf lp lh li lj ij bi translated">在开始具体示例之前，我导入了这项工作所需的所有Python模块。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="6108" class="pw-post-body-paragraph km kn iq ko b kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf lp lh li lj ij bi translated">现在我加载<strong class="ko ir"> LSTM </strong>训练和测试所需的预先生成的人工数据。注意，我分别使用了3000和300幅图像进行训练和测试。这些图像被堆叠成3D矩阵，每个图像具有10×30像素的尺寸。每个图像被标记为噪声(<em class="lx"> y[i] = 0 </em>)或包含轨迹(<em class="lx"> y[i]=1 </em>)。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="2d18" class="pw-post-body-paragraph km kn iq ko b kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf lp lh li lj ij bi translated">接下来，为了展示数据的结构，我们看几个示例图像。</p><h1 id="6591" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">例子</h1><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ly"><img src="../Images/f747a33eaa4d92292177126334efb395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NwXj8mrVPgdn8AGCmvYNew.png"/></div></div></figure><p id="e7be" class="pw-post-body-paragraph km kn iq ko b kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf lp lh li lj ij bi translated">上图中，左图显示了由黑色矩形标记的典型噪波分布。在右边，三个图像被连接在一起。从左到右，第一个图像对应于左侧显示的噪声，接下来的两个图像显示了一个线性轨迹，看起来像一个由黑色小矩形框组成的楼梯，向下穿过中间和最右侧的图像。</p><p id="e30a" class="pw-post-body-paragraph km kn iq ko b kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf lp lh li lj ij bi translated">为了LSTM处理的目的，在这项工作中，图像按10的顺序进行处理。下面，我只展示了前三个，以强调数据的3D排列。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/174f3cdd2c8645f5b8087b8d20583d06.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*OJJUoSDGRysRphsr_2761Q.png"/></div></figure><h1 id="2ea6" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">利用长短时记忆模型学习检测轨迹</h1><p id="48bf" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我在带有<a class="ae lk" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> Tensorflow </a>后端的<a class="ae lk" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank"> Keras </a>框架中使用LSTM模型架构。下面，如果“keras_model_load”设置为True，将使用预训练模型。如果“keras_model_load”设置为False，则从头开始训练模型。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="64f2" class="pw-post-body-paragraph km kn iq ko b kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf lp lh li lj ij bi translated">现在，我们使用经过训练的模型来预测用于训练和测试的输入图像的标签。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="ca99" class="pw-post-body-paragraph km kn iq ko b kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf lp lh li lj ij bi translated">为了估计每个图像的一个标签，我们需要对每个图像的10个时间步长生成的10个标签进行平均。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="3d85" class="pw-post-body-paragraph km kn iq ko b kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf lp lh li lj ij bi translated">由于预测输出是实值，使用阈值0.5，我将输出分为两类:对应于轨道存在的输出(<em class="lx"> y </em> =1)，以及对应于轨道不存在的输出(<em class="lx"> y </em> =0)。下面的<em class="lx"> y </em>对应于<em class="lx"> Y_estim_test </em>或<em class="lx"> Y_estim_train </em>。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h1 id="2553" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结果</h1><p id="aaaa" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">下面显示了训练和测试结果的子集。在每个连接图像的顶部，绘制了平均标签的分布。蓝色和红色分别显示真实和估计的标签。请注意，对于下面显示的训练子集，这两种标签类型完全匹配。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mg"><img src="../Images/fa178af88f37e4e4bc107edf0c8eacdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZjlB18SyEMuxVnbaK7ATRg.png"/></div></div></figure><p id="7230" class="pw-post-body-paragraph km kn iq ko b kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf lp lh li lj ij bi translated">最后，我估计了应用于测试和训练数据的检测概率(Pd)和虚警概率(Pfa)。该指标通常用于<a class="ae lk" href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic" rel="noopener ugc nofollow" target="_blank">接收器操作特性</a>估计。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h1 id="7800" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">讨论</h1><p id="585e" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">查看上面显示的输出，可以看到训练的模型倾向于过度拟合(比较训练的Pd=0.988和测试数据的Pd=0.629)。我对大量测试运行的经验(此处未显示)表明，对于该数据集，过度拟合往往会随着训练数据大小的增加而减少，这是意料之中的。</p><p id="66a4" class="pw-post-body-paragraph km kn iq ko b kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf lp lh li lj ij bi translated">通过寻找更好的RNN结构和微调超参数来提高精度是未来潜在的研究课题之一。</p><p id="aad2" class="pw-post-body-paragraph km kn iq ko b kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf lp lh li lj ij bi translated">尽管所呈现的数据生成算法简单，但是数据生成模型输出非常类似于活动声纳的真实场景。</p><p id="e497" class="pw-post-body-paragraph km kn iq ko b kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf lp lh li lj ij bi translated">在这项工作中分析的情况，在任何给定的时间，仅限于检测一个单一的轨道。轨迹检测是在没有对象运动建模算法的帮助下进行的。后者不需要任何训练(除了一些微调)，但在操作上需要更昂贵的计算。</p><p id="6fa4" class="pw-post-body-paragraph km kn iq ko b kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf lp lh li lj ij bi translated">这项研究是基于LSTM神经网络的第一步，旨在通过发现和检测属于同一物体的轨迹(或轨迹拼接)模式来提高物体检测的可信度，这些轨迹由于噪声而在声纳或雷达屏幕上出现和消失。</p></div></div>    
</body>
</html>