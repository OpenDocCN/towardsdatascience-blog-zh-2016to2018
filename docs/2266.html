<html>
<head>
<title>Robust lane finding using advanced computer vision techniques: Mid project update</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用先进的计算机视觉技术的鲁棒车道发现:中期项目更新</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/robust-lane-finding-using-advanced-computer-vision-techniques-mid-project-update-540387e95ed3?source=collection_archive---------0-----------------------#2016-12-30">https://towardsdatascience.com/robust-lane-finding-using-advanced-computer-vision-techniques-mid-project-update-540387e95ed3?source=collection_archive---------0-----------------------#2016-12-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fe4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">车道发现对于开发自动驾驶机器人或自动驾驶汽车的算法至关重要。车道寻找算法必须对变化的光线条件、天气条件、道路上的其他汽车/车辆、道路的曲率和道路本身的类型具有鲁棒性。在这篇文章中，我们提出了一种基于先进的计算机视觉技术的算法，从仪表板上安装的摄像头视频中识别左右车道。我们在以下步骤中实现了车道寻找算法，</p><ol class=""><li id="bf54" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">不失真的相机图像，并应用透视变换获得街道的鸟瞰图。</li><li id="aadc" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">转换到HSV色彩空间并应用颜色遮罩来识别黄线</li><li id="f329" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">应用Sobel滤波器以获得具有潜在线条/边缘的图像</li><li id="af28" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">组合来自Sobel过滤器和HSV颜色遮罩的二进制遮罩</li><li id="1b9b" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">应用移动平均过滤器来去除任何可能是由于图像中的其他伪像造成的标记或特征。</li><li id="b631" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">应用多项式回归计算左右车道</li><li id="cc92" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">应用帧到帧平滑以丢弃图像之间的噪点，并在图像上画回线条。</li><li id="7a5e" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">计算曲率和车道偏离，并将其写在图像上。</li></ol><p id="2e2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来我们将详细讨论每个步骤。上述过程的最终结果如下所示，</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Advanced lane finding using computer vision</figcaption></figure><p id="97cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的视频展示了制作上面的视频所涉及的所有步骤的诊断视图。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="85b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一步:不失真的相机图像和应用透视变换。</p><p id="2432" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当相机镜头捕捉图像时，它们捕捉的不是真实的图像，而是原始图像的变形。图像中心的点具有较低的失真，而远离中心的点具有较高的失真。这种失真可能是由于与相机中心的距离不同、不同镜头位置的光线弯曲不同或透视失真造成的。一篇关于不同类型失真的好文章可以在<a class="ae lk" href="https://photographylife.com/what-is-distortion" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="99ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，图像处理的第一步是对原始图像进行去失真处理。对用于不失真摄像机图像的算法的详细描述可以在<a class="ae lk" href="https://nl.mathworks.com/products/demos/symbolictlbx/Pixel_location/Camera_Lens_Undistortion.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。对于我们的算法，我们首先使用提供的棋盘图像计算相机失真矩阵和失真参数。然后，我们加载相机矩阵，并使用它来不失真的图像。下图显示了未失真的结果。最后一个面板显示了原始图像和未失真图像之间的差异。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ll"><img src="../Images/229ca55939149efccd1e01a4812e276c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z3WxWEEj9gVK2nefp1qmuA.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Removing image distortion</figcaption></figure><p id="f582" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们应用透视变换来获得道路的鸟瞰图。我们首先在原始相机图像中识别4个点，然后拉伸图像，使4个点之间的区域形成一个矩形截面。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ls"><img src="../Images/2ebea146358a9cc2e193a8bccfa309f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Ra40lYTIuGFIJuVMPUGqQ.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Perspective transform to get bird-eye view</figcaption></figure><p id="f940" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦获得了俯视图，我们就开始确定车道。</p><p id="fd4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤2:转换到HSV色彩空间并应用颜色遮罩</strong></p><p id="a19f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是将鸟瞰图RGB图像转换为HSV颜色方案。HSV指的是色调、饱和度、数值。HSV方案是作为一种更直观的方式来表示颜色而开发的。色调(或H)代表特定的颜色，饱和度(或S)代表颜色的数量，数值(或V)代表相对于类似照明的白色的亮度。因此，通过将图像转换为HSV尺度，可以获得良好的颜色分辨率。我们使用HSV颜色空间来识别黄色和白色。我们应用黄色面具作为</p><pre class="kz la lb lc gt lt lu lv lw aw lx bi"><span id="1e63" class="ly lz iq lu b gy ma mb l mc md">yellow_hsv_low  = np.array([ 0, 80, 200])<br/>yellow_hsv_high = np.array([ 40, 255, 255])<br/>res = apply_color_mask(image_HSV,warped,yellow_hsv_low,yellow_hsv_high)</span></pre><p id="8658" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中，apply_color_mask返回指定强度介于低值和高值之间的像素。应用黄色蒙版的结果是，</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi me"><img src="../Images/9d2fd3aecb3db58d764e9455356f6a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*voyZ0IAGn3hd2gne5WTl5Q.png"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Applying yellow-mask</figcaption></figure><p id="447f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为黄色掩模对于不同的照明条件非常鲁棒，因为黄色的不同照明图像是通过改变亮度通道而产生的，同时保持色调或颜色通道固定。下图显示了不同照明条件下应用黄色遮罩的效果。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/eb57abace80e210f4582b415ffbf8557.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*WjCpcIt7iWpU5_v2Ea5UXw.png"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Yellow mask on shadowed and bright patch of road</figcaption></figure><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/cc2e9e0471bb4881159598612112f141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*Qyg7OVnj6AdAowbzTqYa0A.png"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Yellow mask on bright patch of road</figcaption></figure><p id="4828" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，使用阈值应用白色遮罩，如下所示</p><pre class="kz la lb lc gt lt lu lv lw aw lx bi"><span id="3b0c" class="ly lz iq lu b gy ma mb l mc md">white_hsv_low  = np.array([  20,   0,   200])<br/>white_hsv_high = np.array([ 255,  80, 255])</span></pre><p id="aa51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了识别白线，</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi me"><img src="../Images/61500e9fd862421c6b458fe25dac2ceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*MT07k2J4fTbhmaFpt4Ug-Q.png"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Applying white mask,</figcaption></figure><p id="7188" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦应用黄色和白色蒙版，通过如下组合两个通道蒙版获得来自彩色蒙版的通道。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi me"><img src="../Images/bae410059a16284d4c10fc44d8afb649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*SayvOlvoqNvMA9olVwbkbQ.png"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Combined lane from color masks</figcaption></figure><p id="fd58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第三步:应用索贝尔过滤器得到潜在的线条/边缘</strong></p><p id="1d1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是应用索贝尔过滤器，以获得潜在的线/边缘。如果道路上没有其他黄色或白色标记，上面的颜色遮罩是选择车道标记的好方法。这并不总是可能的，因为道路上可能有白色或黄色的文字。因此，为了避免混淆，我们还使用Sobel滤波器进行边缘检测。Sobel滤波器用于图像处理，通过执行原始图像和Sobel算子(或滤波器)的2-D卷积来获得图像的边缘。这个操作可以表示为，</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/169f8e12bc3ce9f7e55f31ebb7075235.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/1*MU0f9WV941sr7leSjq7xGg.gif"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Sobel filter, circle denotes convolution operation</figcaption></figure><p id="d461" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">沿着x和y方向Sobel滤波器给出了沿着x和y方向的图像强度的梯度或变化。然后，这些强度可以通过大小和方向进行阈值处理，以获得仅在边缘处等于1的二进制图像。我们将应用Sobel滤波器，并对HLS图像的S和L通道的x和y方向的梯度幅度进行阈值处理。我们选择HLS通道是因为在以前的实验中，发现HLS颜色空间对于检测边缘是最鲁棒的。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/da9d754c91e534e14550fc638c711295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*24U36bhBsGhzpvnQxSVbJA.png"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Sobel filter applied on L and S channel of image</figcaption></figure><p id="800b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第四步:组合索贝尔滤镜和彩色蒙版</strong></p><p id="b72f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将来自Sobel过滤器的二进制掩码和颜色掩码相结合，以获得车道的更强指示符。车道应该是深色背景上的白色或黄色标记，因此应该显示较大的坡度。白色和黄色通道的组合Sobel图像和颜色遮罩如下所示。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/545fe1c5e2bd1ba003d7cff6b102f3c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*13RqyhHMCYCvV9cutDO2FQ.png"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Lane masks from Sobel filters and color masks</figcaption></figure><p id="821f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来自颜色掩蔽和Sobel滤波器的最终组合的车道和边缘掩蔽如下所示。很明显，原始图像中预期有车道的区域用粗粗线突出显示。我们能够获得这些粗线是因为我们结合了边缘检测和颜色掩膜。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi me"><img src="../Images/3a51fa1772c75522d4a828fc0def09e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*htuvUColZG9wq7aoFy-olw.png"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Final combined lane mask</figcaption></figure><p id="7b69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第五步:应用窗口来删除任何可能是由于图像中的其他伪像而产生的标记或特征。</p><p id="7992" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在最终的合成蒙版中，我们看到了许多可能是由其他伪像造成的边缘特征，其中一个突出的是由汽车引擎盖造成的水平线。因此，我们计算沿x方向的所有像素的平均值，并使用移动平均滤波器来获得沿x方向的平滑强度分布。然后，我们应用阈值0.05来识别可能包含车道线的区域。这些区域边界用蓝线表示。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/f4f8e8fd0a69b4028a1d9cab638d39e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*2ZedtLWPFVMe_6_CWa9omQ.png"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Plot of intensity along X direction</figcaption></figure><p id="83a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用这些峰的左右边缘作为边界来选择左右车道标志点。通过去除左右车道标志的点，我们得到了表示车道的点，</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/3ca29b23aca4ff162fab0f851bde93b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*ew3EtvFsZVZeWJwDN3iz6Q.png"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Left and right lane markings</figcaption></figure><p id="6daa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤6:应用多项式回归计算左右车道</strong></p><p id="00f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们使用多项式回归获得二次拟合来近似车道线。我们使用numpy的简单多项式拟合函数来计算左右车道的二次拟合。一旦获得了左和右车道的二次拟合，我们将它们画回到图像上，并如下用青绿色标记左和右车道之间的区域。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mi"><img src="../Images/068f1eedb56f11c6872cd1df2070ceca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O17AOi9EB40luQ81BssXhg.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Redrawing lane lines and lane back on the original image</figcaption></figure><p id="e59e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第七步:逐帧平滑去除图像间的噪声，并在图像上画线。</strong></p><p id="5bf9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们通过一阶滤波器对帧进行平滑处理。我们还包括一个干扰抑制例程，该例程丢弃任何系数与前一帧中的系数偏差超过5%的多项式拟合。</p><p id="490d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤8:计算车道曲率和车道偏差</strong></p><p id="b2b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们计算了曲率半径和车道偏离，并实现了一个简单的车道偏离警告系统，如果车道偏离超过30厘米，该系统会将蓝绿色区域变为红色。</p><p id="2b6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">反思</strong></p><p id="eb9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个非常有趣的项目。最有趣的部分是查看在以前的简单项目中开发的技术如何应用于更一般的场景。这个项目的工作远未结束。当前的算法不够健壮，不足以推广到挑战视频，但性能非常好。我们将在最终报告中详细介绍一个更强大的算法。</p><p id="489c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">致谢</strong>:</p><p id="f9a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我非常感谢Udacity选择我作为第一批，这让我能够与许多志同道合的人联系。一如既往，从与亨里克·特纳曼和陈志强的讨论中学到了很多。我也感谢获得NVIDA的GPU拨款。虽然这是工作用的，但我也用它来办公。</p><p id="48bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">特别感谢一位同学陈志强。John发布了一个简单的解决方案来实现管道的诊断视图，但是当论坛从旧论坛迁移过来时，这个解决方案被删除了。尽管约翰在度假，他还是及时上传了新论坛上的代码片段，并把<a class="ae lk" href="https://carnd-forums.udacity.com/questions/32706990/want-to-create-a-diagnostic-view-into-your-lane-finding-pipeline" rel="noopener ugc nofollow" target="_blank">链接</a>发给了我。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mj"><img src="../Images/11014d1dbdc220f10df48ef9ea6990a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z0yEvC6N7_Clzd6qIWzBRA.png"/></div></div></figure></div></div>    
</body>
</html>