<html>
<head>
<title>MicroPython on ESP Using Jupyter Notebook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Jupyter 笔记本的 ESP 上的 MicroPython</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/micropython-on-esp-using-jupyter-6f366ff5ed9?source=collection_archive---------3-----------------------#2018-06-06">https://towardsdatascience.com/micropython-on-esp-using-jupyter-6f366ff5ed9?source=collection_archive---------3-----------------------#2018-06-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c1d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用 Jupyter 笔记本在 ESP 上玩 MicroPython，以便从传感器获取数据并在物理世界中采取行动。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/639287d1a330d53f8b79fb38c90b56ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5kCdBJOYis2texeO"/></div></div></figure><h2 id="3ce2" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">1.介绍</h2><p id="e83f" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">在之前的一篇文章中，我们探讨了如何使用 Jupyter 笔记本控制 Raspberry Pi:<a class="ae lv" href="https://medium.com/@rovai/physical-computing-using-jupyter-notebook-fb9e83e16760" rel="noopener">使用 Jupyter 笔记本进行物理计算</a></p><p id="519b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一次很棒的体验，一旦项目运行良好，我就想，“在 ESP8266 上(甚至在 ESP32 上)使用 MicroPython 测试 Jupyter Notebook 怎么样？”。</p><p id="51e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">众所周知，Jupyter Notebook 是一个开源的 web 应用程序，允许您创建和共享包含实时代码、等式、可视化和叙述性文本的文档。用途包括数据清理和转换、数值模拟、统计建模、数据可视化、机器学习等等。对于“更多”，我们还探讨了“物理计算”。</p><p id="a29b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，在我的项目中，我主要使用由 Arduino IDE 使用其 C/C++类型语言编程的 ESP8266–01、8266–12E(node MCU)和 ESP32 来探索物联网和物理计算项目。但是另一个用于编程这些设备的伟大工具是 MicroPython:</p><blockquote class="lw lx ly"><p id="3912" class="jn jo lz jp b jq jr js jt ju jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj kk ij bi translated">MicroPython 是 Python 3 编程语言的一个精简而高效的实现，它包括 Python 标准库的一个小子集，并针对在微控制器和受限环境中运行进行了优化。它的目标是尽可能与普通 Python 兼容，以允许您轻松地将代码从桌面转移到微控制器或嵌入式系统。</p></blockquote><p id="fcee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我认为使用 Jupyter Notebook 对使用 MicroPython 的 ESP 设备进行编程是一个很好的工具，可以向孩子们教授物理计算，还可以帮助科学家在获取数据时快速进入真实世界玩传感器。</p><p id="7825" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们将在本教程中尝试完成的任务:</p><ul class=""><li id="5dbe" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">输出数字信号以打开/关闭 LED</li><li id="a6fc" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">从按钮读取数字输入</li><li id="56c3" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">输出 PWM 信号以使 LED 变暗</li><li id="46e9" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">使用 PWM 输出控制伺服电机位置</li><li id="07fe" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">读取模拟信号(使用 LDR 的亮度)</li><li id="8528" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">读取温度阀 1 线(DS18B20)</li><li id="b806" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">读取温度和湿度(DHT22)</li><li id="5120" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">通过 I2C 总线使用有机发光二极管显示数据。</li></ul><h2 id="6629" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">2.安装 MicroPython</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/ac75469c170c09a688d68e32037107ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*-Ss5UFp7hNI7tAmK"/></div></figure><p id="a815" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于一个新的 NodeMCU(或 ESP32)，要做的第一件事是擦除其内存中加载的内容，“刷新”一个新的固件，这将是 MicroPython 解释器。</p><p id="a36c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">A.获取新固件:</p><p id="c895" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进入网站:<a class="ae lv" href="http://micropython.org/download#esp8266" rel="noopener ugc nofollow" target="_blank"> MicroPython 下载</a>并为您的设备下载相应的固件:</p><p id="b054" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，对于 ESP8266，最新版本为:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="1629" class="kx ky iq mt b gy mx my l mz na">esp8266-20180511-v1.9.4.bin (Latest 01Jun18)</span></pre><p id="f40d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(你可以在这里找到如何安装固件<a class="ae lv" href="http://docs.micropython.org/en/latest/esp8266/esp8266/tutorial/intro.html#deploying-the-firmware" rel="noopener ugc nofollow" target="_blank">的细节</a>)</p><p id="0a10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理想的情况是创建一个目录，您将在其中使用 MicroPython。例如，对于 mac，从您的根目录开始:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="b79d" class="kx ky iq mt b gy mx my l mz na">cd Documents<br/>mkdir MicroPython<br/>cd MicroPython</span></pre><p id="c93c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">B.将下载的 ESP8266 固件移动到这个最近创建的目录中。</p><blockquote class="lw lx ly"><p id="c600" class="jn jo lz jp b jq jr js jt ju jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj kk ij bi translated">此时:使用串行 USB 电缆将 NodeMCU 或 ESP32 连接到您的 PC。</p></blockquote><p id="cd9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">C.使用以下命令检查您的设备正在使用的串行端口:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="5cd0" class="kx ky iq mt b gy mx my l mz na">ls /dev/tty.*</span></pre><p id="e9e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就我而言，我得到了:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="a3b2" class="kx ky iq mt b gy mx my l mz na">/dev/tty.SLAB_USBtoUART</span></pre><p id="0f8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">D.安装<em class="lz"> esptool </em>(用于刷新/擦除设备固件的工具)</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="1620" class="kx ky iq mt b gy mx my l mz na">pip install esptool</span></pre><p id="51d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">E.擦除 NodeMCU 闪存:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="30c4" class="kx ky iq mt b gy mx my l mz na">esptool.py --port /dev/tty.SLAB_USBtoUART erase_flash</span></pre><p id="4151" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">F.刷新新固件:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="3fcd" class="kx ky iq mt b gy mx my l mz na">esptool.py --port /dev/tty.SLAB_USBtoUART --baud 460800 write_flash --flash_size=detect 0 esp8266-20180511-v1.9.4.bin</span></pre><p id="c5a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装固件后，您可以在终端上使用命令“Screen”玩 REPL*:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="e65d" class="kx ky iq mt b gy mx my l mz na">screen  /dev/tty.SLAB_USBtoUART 115200<br/>&gt;&gt;&gt; print (‘hello ESP8266’)<br/>&gt;&gt;&gt; hello ESP8266</span></pre><p id="7dd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你在 REPL，使用:</p><p id="b181" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[Ctrl+C]来中断 pgm 和</p><p id="0a8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[Ctrl+A] [K] [Y]退出并返回终端。</p><p id="139f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">* REPL 代表“<em class="lz">读取评估打印循环”</em>，是您可以在 ESP8266 上访问的交互式 MicroPython 提示符的名称。你可以在这里了解更多关于 REPL <a class="ae lv" href="http://docs.micropython.org/en/latest/esp8266/esp8266/tutorial/repl.html" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><h2 id="9377" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">3.安装 Jupyter MicroPython 内核</h2><p id="787f" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">为了通过串行 REPL 与 MicroPython ESP8266 或 ESP32 交互，我们需要安装一个特定的 Jupyter 内核。</p><blockquote class="lw lx ly"><p id="16ac" class="jn jo lz jp b jq jr js jt ju jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj kk ij bi translated">这只需要做一次。</p></blockquote><p id="5eeb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从<a class="ae lv" href="http://jupyter.org/documentation" rel="noopener ugc nofollow" target="_blank"> Jupyter 文档网站</a>，我们可以列出所有“社区维护的内核”。在那里，我们将被送到:</p><p id="9b9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lv" href="https://github.com/goatchurchprime/jupyter_micropython_kernel/" rel="noopener ugc nofollow" target="_blank"> Jupyter MicroPython 内核</a></p><p id="f33d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们在机器上安装了 Python 3(在我的例子中是 Mac)，使用 shell 命令(即在命令行上)将存储库克隆到一个目录中:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="9019" class="kx ky iq mt b gy mx my l mz na">git clone https://github.com/goatchurchprime/jupyter_micropython_kernel.git</span></pre><p id="4fad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，使用 shell 命令将库(在可编辑模式下)安装到 Python3 中:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="dd44" class="kx ky iq mt b gy mx my l mz na">pip install -e jupyter_micropython_kernel</span></pre><p id="a4a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将在 python/中创建一个指向该目录的小文件../site-packages 目录，并使它能够在以后得到改进时“git update”这个库。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nb"><img src="../Images/17be39cddc87af1129c67b3838f739b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fdxyl9JOfCFBhKcjVGo60A.png"/></div></div></figure><blockquote class="lw lx ly"><p id="8c6e" class="jn jo lz jp b jq jr js jt ju jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj kk ij bi translated">这里可能会出错，如果您安装了大量不同版本的 python，您可能需要“pip3”或“sudo pip”。</p></blockquote><p id="4968" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用 shell 命令将内核安装到 Jupyter 中:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="611f" class="kx ky iq mt b gy mx my l mz na">python -m jupyter_micropython_kernel.install</span></pre><p id="df03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将创建一个小文件”。local/share/jupyter/kernels/micropython/kernel . JSON ”, jupyter 用它来引用它的内核。</p><p id="a4f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要找出您的 kernelspecs 存储在哪里，您可以键入:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="22e1" class="kx ky iq mt b gy mx my l mz na">jupyter kernelspec list</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/3f9175865dbc92efcf5b8de13411651b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*ojccuaMkq2kcxXUL"/></div></figure><p id="515c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">终端 PrintScreen 显示了我在机器上安装的内核列表。注意，在我的例子中，我使用 PIP3 命令安装了 MicroPython 内核，因此，这个内核与其他内核不在同一个目录中(当我试图使用 PIP 安装我的内核时，出现了一个错误)。</p><p id="f7b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在运行 Jupyter 笔记本:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="58f6" class="kx ky iq mt b gy mx my l mz na">jupyter notebook</span></pre><p id="1ac4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在笔记本中单击右上角的“新建”按钮，您应该会看到列出的内核显示名称:“MicroPython — USB”。</p><p id="4f3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第一个单元格中，您需要定义将要使用的端口和波特率(115200 就可以了):</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="2a28" class="kx ky iq mt b gy mx my l mz na">%serialconnect to --port=/dev/tty.SLAB_USBtoUART --baud=115200</span></pre><p id="f989" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为响应，单元格将返回:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="0d50" class="kx ky iq mt b gy mx my l mz na">Connecting to --port=/dev/tty.SLAB_USBtoUART --baud=115200<br/>Ready.</span></pre><p id="3d6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！当“Ready”出现时，您应该能够通过运行单元来执行 MicroPython 命令。</p><p id="a113" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们试试:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="50ee" class="kx ky iq mt b gy mx my l mz na">print ('hello esp8266')</span></pre><p id="be77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该会在储存格的输出上收到 ESP8266 的回应:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="a59d" class="kx ky iq mt b gy mx my l mz na">hello esp8266</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/b8a089331e4db0ff36c696e5a773012c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*gbcYDEWtICM9-CLB"/></div></figure><h2 id="df68" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">4.LED 闪烁</h2><p id="2cf7" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">像往常一样，让我们开始我们的物理计算之旅，“闪烁的 LED”。</p><p id="4815" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">低于 NodeMCU 的典型引脚排列(ESP8266–12E 1.0 版):</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/81dd7b508293f2525cbf830e89d6647f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/0*A4mTcGH6sXBbpv6c"/></div></figure><blockquote class="lw lx ly"><p id="f76a" class="jn jo lz jp b jq jr js jt ju jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj kk ij bi translated">可用管脚有:0、1、2、3、4、5、12、13、14、15、16，对应的是 ESP8266 芯片的实际 GPIO 管脚数。请注意，许多最终用户板使用自己的专用引脚编号(例如标记为 D0、D1 等)。</p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/bdd86b74fc6a7e30beef5ac89758b07e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/0*n0Jc0yrz2JSTlCrS"/></div></figure><p id="c19d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在 NodeMCU 引脚 0 (D3)上安装一个 LED 并测试它，打开和关闭它:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="8fc1" class="kx ky iq mt b gy mx my l mz na"># import library to deal with pins:<br/>from machine import Pin</span><span id="eb0e" class="kx ky iq mt b gy ne my l mz na"># define pin 0 as output<br/>led = Pin(0, Pin.OUT)</span><span id="abad" class="kx ky iq mt b gy ne my l mz na"># define value of "led" as "1" or "True" to turn on the LED<br/>led.value(1)</span><span id="654a" class="kx ky iq mt b gy ne my l mz na"># define value of "led" as "0" or "False" to turn off the LED<br/>led.value(0)</span><span id="2e56" class="kx ky iq mt b gy ne my l mz na"># also you can use .on() or .off methods to control the pin:<br/>led.on()<br/>led.off()</span></pre><p id="2597" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们导入一个时间库并使 LED 闪烁:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="b5fc" class="kx ky iq mt b gy mx my l mz na">from time import sleep</span><span id="d471" class="kx ky iq mt b gy ne my l mz na">for i in range(5):<br/>    led.on()<br/>    sleep(0.5)<br/>    led.off()<br/>    sleep(0.5)</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mr"><img src="../Images/f01b3432e2df7e0c4ae8a7d4c7d8b8b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*qKKsL1DxziJu_LN8"/></div></div></figure><h2 id="55ba" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">5:输入数字信号</h2><p id="ff6f" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">你可以在 NodeMCU 上读取的简单传感器数据可以通过一个按钮获得。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/f2e8e662c2b3a33479c0c9dcce4dbdd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/0*j7HFrH_kD5f6wSlw"/></div></figure><p id="c78d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们如图所示，在 13 号插脚(D7)和 GND 之间安装一个按钮。</p><p id="2d0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们按钮的连接方式是，引脚 13 的正常状态为“高”(因此我们将使用一个内部上拉电阻来保证这种状态)。按下时，引脚 13 将为“低”。</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="797d" class="kx ky iq mt b gy mx my l mz na"># define pin 13 as an input and activate an internal Pull-up resistor:</span><span id="39ba" class="kx ky iq mt b gy ne my l mz na">button = Pin(13, Pin.IN, Pin.PULL_UP)</span><span id="6670" class="kx ky iq mt b gy ne my l mz na"># Read button state:<br/>print(button.value())</span></pre><p id="08fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当运行上述单元时(不按按钮)，结果将是:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="4347" class="kx ky iq mt b gy mx my l mz na">1</span></pre><p id="94e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按下按钮，再次运行电池:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="c987" class="kx ky iq mt b gy mx my l mz na"># Read button state:<br/>print(button.value())</span></pre><p id="8bea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在的结果是:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="4f53" class="kx ky iq mt b gy mx my l mz na">0</span></pre><p id="2048" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，停止按下按钮不会将“单元格值”返回到“1”。若要查看“^ 1”，您必须再次运行该单元格。</p><p id="4fb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们做一个小程序，仅当按钮被按下时才打开 LED:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="7209" class="kx ky iq mt b gy mx my l mz na">print (button.value())<br/>if button.value() == 0:<br/>    led.on()<br/>else:<br/>    led.off()</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/824b41b1165434714e2db490dd1d04ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*Ov5lMmSP5DXbxaFk"/></div></figure><h2 id="3f16" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">6.脉宽调制</h2><p id="bf6f" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">除引脚(16)外，所有引脚都可以使能 PWM。所有通道都有一个单一的频率，范围在 1 到 1000 之间(以 Hz 为单位)。占空比介于 0 和 1023 之间，包括 0 和 1023。</p><p id="b8d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开始调用适当的库:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="948a" class="kx ky iq mt b gy mx my l mz na">from machine import Pin, PWM</span></pre><p id="a4e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有几个命令可用:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="f25e" class="kx ky iq mt b gy mx my l mz na">pwm0 = PWM(Pin(0))      # create PWM object from a pin<br/>pwm0.freq()             # get current frequency<br/>pwm0.freq(1000)         # set frequency<br/>pwm0.duty()             # get current duty cycle<br/>pwm0.duty(200)          # set duty cycle<br/>pwm0.deinit()           # turn off PWM on the pin</span></pre><p id="e5c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者您可以设置立即配置 pin:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="e003" class="kx ky iq mt b gy mx my l mz na">pwm2 = PWM(Pin(2), freq=500, duty=512)</span></pre><p id="17ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们将连接到引脚 0 的 LED 从关闭调光到打开:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="75e8" class="kx ky iq mt b gy mx my l mz na">from machine import Pin, PWM<br/>pwm0 = PWM(Pin(0), freq=1000, duty=0)<br/>for i in range (0,1023,20):<br/>    pwm0.duty(i)<br/>    sleep(0.1)<br/>    pwm0.duty(0)<br/>    pwm0.deinit()</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ng"><img src="../Images/07f118ae7d21e9d9f16689498bb473f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxsJJCD68nABlwpu3RIz-g.png"/></div></div></figure><p id="d4e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">控制一个伺服电机怎么样？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/c0bbe41d8f53acb0b5d4282b7cebd96a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/0*3FajZQG27r4j8HjJ"/></div></figure><p id="50e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在 NodeMCU 上安装一个小的爱好伺服，如图所示。请注意，我将伺服 VCC 连接到 NodeMCU +3.3V。这对于本教程来说是可以的，但在实际项目中，您必须将伺服 VCC 连接到外部+5V 电源(不要忘记将 GNDs 连接到 NodeMCU GND)。</p><p id="ec9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">伺服数据引脚将连接到 NodeMCU 引脚 14 (D5)。</p><p id="a158" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">伺服系统通常以 50Hz 的频率工作，然后在大约 40 和 115 之间的占空比将它们分别从 0 度定位到 180 度。占空比 77 会将伺服定位在其中心值(90 度)。</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="d05f" class="kx ky iq mt b gy mx my l mz na">servo = PWM(Pin(14), freq=50)</span></pre><p id="b5e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在不同位置测试伺服系统:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="9112" class="kx ky iq mt b gy mx my l mz na"># Minimum position (angle 0)<br/>servo.duty(40)</span><span id="220e" class="kx ky iq mt b gy ne my l mz na"># Maximun position (angle 180)<br/>servo.duty(40)</span><span id="139e" class="kx ky iq mt b gy ne my l mz na"># center position (angle 90)<br/>servo.duty(40)</span></pre><p id="1912" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您也可以创建一个简单的交换程序来测试您的伺服:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="640b" class="kx ky iq mt b gy mx my l mz na"># swipping servo<br/>step = 2<br/>for i in range (40, 115, step):<br/>    servo.duty(i)<br/>    sleep (0.1)<br/>    step = -1*step</span><span id="3292" class="kx ky iq mt b gy ne my l mz na">for i in range (115, 40, step):<br/>    servo.duty(i)<br/>    sleep (0.1)<br/>    servo.duty(77)</span></pre><p id="5bf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果下方:</p><p id="f1a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在这里不使用声纳，所以我将留给你开发一个代码来使用它。很简单 alheady！试试看！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/67abd719f4e9bb0896a16d5fb789c211.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*GZ3GtTDYgAMGv2rG"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ni"><img src="../Images/a8be0ff56af1069d78e81b954b165685.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aq3rqG40RK9pDwFusIVmPA.png"/></div></div></figure><h2 id="6c0c" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">7.模拟输入(测量亮度)</h2><p id="af17" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">ESP8266 有一个引脚 A0，可用于读取模拟电压并将其转换为数字值。您可以使用以下公式构建这样一个 ADC 引脚对象:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="d617" class="kx ky iq mt b gy mx my l mz na">from machine import ADC<br/>adc = ADC(0)</span></pre><p id="4ab9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，您可以使用以下公式读取 A0 引脚的值:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="29d9" class="kx ky iq mt b gy mx my l mz na">adc.read()</span></pre><p id="beab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，模拟引脚可以用来读取作为分压器的电位计的变量值。这可以被解释为用于调暗 LED 或将伺服移动到特定位置的输出。你可以根据我们目前了解到的情况来尝试一下。</p><p id="a804" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个有用的例子是使用 LDR(“光敏电阻”)从模拟传感器捕获数据，如温度(LM35)、紫外线(UV)辐射或光度。</p><p id="1cdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当光度增加时，LDR 会减小其电阻。因此，您可以用 LDR 和电阻创建一个分压器，如图所示。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nj"><img src="../Images/48b9e15445ed88b64fe95391233fd863.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/0*g386p0EFHzefLuQ8"/></div></div></figure><p id="7a85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">直接读取电阻上的模拟电压，我们将获得与亮度成正比的信号。</p><p id="0add" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让传感器暴露在光线下，读取 ADC 值。</p><p id="e49e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，盖住传感器，得到一个较低的值。</p><p id="8d52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就我而言:</p><ul class=""><li id="b8a8" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">最大亮度==&gt; adc 值&gt; 850</li><li id="0ff5" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">最小亮度==&gt; adc 值&lt; 40</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/5e8be553c3bb3accca1f9189ee7ac41a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*2ORKVgHJ6oO52MkD"/></div></figure><h2 id="75e5" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">8. Controlling 1-Wire Devices</h2><p id="246e" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">The 1-wire bus is a serial bus that uses just a single wire for communication (in addition to wires for ground and power). The DS18B20 temperature sensor is a very popular 1-wire device, and here we show how to use the "onewire" module to read from such a device.</p><p id="8400" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">For the following code to work you need to have at least one DS18B20 temperature sensor with its data line connected to GPIO 2 (D4).</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/3e4f67898c384c438d46205b7e76b7bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*xO5ReB5mdWH9n6gQ"/></div></figure><p id="5538" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">You must also power the sensors and connect a 4.7k Ohm resistor between the data pin and the power pin as shown in the diagram.</p><p id="6257" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Import the libraries:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="0d90" class="kx ky iq mt b gy mx my l mz na">import onewire, ds18x20</span></pre><p id="9f66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Define which pin the 1-wire device will be connected. In our case ==&gt;引脚 2 (D4)</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="7661" class="kx ky iq mt b gy mx my l mz na">dat = Pin(2)</span></pre><p id="b782" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建单线对象:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="c1bd" class="kx ky iq mt b gy mx my l mz na">ds = ds18x20.DS18X20(onewire.OneWire(dat))</span></pre><p id="13ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">扫描总线上的设备。请记住，同一总线上可以连接多个设备。</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="4bf7" class="kx ky iq mt b gy mx my l mz na">sensors = ds.scan()<br/>print('found devices:', sensors)</span></pre><p id="3014" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“传感器”是一个数组，包含所有相连的单线传感器的地址。我们将使用“sensors[0]”来指向我们的传感器。</p><p id="2efa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，您必须执行<em class="lz"> convert_temp() </em>函数来启动温度读数，然后等待至少 750 毫秒再读取数值(不要忘记导入时间库)。要读取该值，请使用:<em class="lz">ds . read _ temp(sensors[0]):</em></p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="22d8" class="kx ky iq mt b gy mx my l mz na">ds.convert_temp()<br/>time.sleep_ms(750)<br/>print(ds.read_temp(sensors[0]))</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/7b8f994edf8a47bee9171f789055fe22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*RdpKyrM26QgzuS_o"/></div></figure><h2 id="7d44" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">9.使用 DHT 传感器读取温度和湿度</h2><p id="98d5" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">DHT(数字湿度和温度)传感器是低成本的数字传感器，配有电容式湿度传感器和热敏电阻来测量周围的空气。它们具有一个处理模数转换的芯片，并仅使用一根数据线提供数字接口。新型传感器还提供了 I2C 接口。</p><p id="5a63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">DHT11(蓝色)和 DHT22(白色)传感器提供相同的数字接口，但 DHT22 需要一个单独的对象，因为它有更复杂的计算。DHT22 的湿度和温度读数都有 1 位小数分辨率。DHT11 有两者的整数。自定义协议用于从传感器获取测量值。有效载荷由湿度值、温度值和校验和组成。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mr"><img src="../Images/04ae24cd0045e7624c45e5b83ee1b90e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*6Ib8M4kq9NYLEvKp"/></div></div></figure><p id="d295" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如图所示连接 DHT22。数据引脚将连接到 NodeMCU 引脚 12 (D6)。</p><p id="278c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要使用 DHT 接口，请构造引用其数据 pin 的对象。开始呼叫图书馆:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="6441" class="kx ky iq mt b gy mx my l mz na">from dht import DHT22</span></pre><p id="d93c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">定义适当的 pin 并构造对象:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="8253" class="kx ky iq mt b gy mx my l mz na">data = DHT22(Pin(12))</span></pre><p id="ddf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">获取温度和湿度值:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="84a5" class="kx ky iq mt b gy mx my l mz na">data.measure()<br/>temp = data.temperature()<br/>hum = data.humidity()</span><span id="a4fe" class="kx ky iq mt b gy ne my l mz na">print('Temp: {}oC'.format(temp))<br/>print('Hum:  {}%'.format(hum))</span></pre><p id="6326" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了获得最准确的结果，DHT11 每秒最多只能调用一次，DHT22 每两秒调用一次。传感器精度会随着时间的推移而降低。每个传感器支持不同的工作范围。详情请参考产品数据表。</p><blockquote class="lw lx ly"><p id="1c55" class="jn jo lz jp b jq jr js jt ju jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj kk ij bi translated">DHT22 传感器现在以 AM2302 的名称出售，在其他方面是相同的。</p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/c0639b823f9cf7783c166db2a3734ae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*fTZEwIJgH0cRB7cM"/></div></figure><h2 id="541e" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">10.I2C——使用有机发光二极管显示器</h2><p id="4590" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">I2C 是用于设备间通信的双线协议。在物理层，它由两条线路组成:</p><ul class=""><li id="a885" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">SCL 和 SDA，分别是时钟和数据线。</li></ul><p id="6b88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">I2C 对象是附加到特定总线上创建的。它们可以在创建时初始化，也可以在以后初始化。</p><p id="2db8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们导入库:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="8e4c" class="kx ky iq mt b gy mx my l mz na">from machine import I2C</span></pre><p id="3b1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑引脚 4 (SDA)和引脚 5 (SCL)上的器件，让我们创建一个 i2c 对象:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="faa2" class="kx ky iq mt b gy mx my l mz na">i2c = I2C(scl=Pin(5), sda=Pin(4))</span></pre><p id="8103" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，你应该扫描 I2C 总线上的最终设备。下面的函数将完成这项工作，返回连接设备的数量及其地址:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="e6a8" class="kx ky iq mt b gy mx my l mz na">def scanI2c():<br/>    print('Scan i2c bus...')<br/>    devices = i2c.scan()</span><span id="da98" class="kx ky iq mt b gy ne my l mz na">    if len(devices) == 0:<br/>        print("No i2c device !")<br/>    else:<br/>        print('i2c devices found:',len(devices))</span><span id="2e83" class="kx ky iq mt b gy ne my l mz na">    for device in devices:<br/>        print("Decimal address: ",device," | Hexa address: ",hex(device))</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mr"><img src="../Images/b4d9d2bcd0dfd41d523d97ac17220c58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*Mi3oxL07xu0otzY1"/></div></div></figure><p id="4702" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在节点 MCU 上安装一个 I2C·有机发光二极管显示器，如图所示。显示器是固态硬盘 1306 (128 x 64)。</p><p id="88ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行扫描功能:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="e73c" class="kx ky iq mt b gy mx my l mz na">scanI2c()</span></pre><p id="1a8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将得到的结果是，在地址 0x3c 找到了 1 个设备。</p><p id="ba9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该地址将用于创建 oled 对象，如下所示:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="b534" class="kx ky iq mt b gy mx my l mz na">import ssd1306<br/>i2c = I2C(scl=Pin(5), sda=Pin(4))<br/>oled = ssd1306.SSD1306_I2C(128, 64, i2c, 0x3c)</span></pre><p id="a92c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">管理显示的一些方法:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="289f" class="kx ky iq mt b gy mx my l mz na">poweroff(), turns off the screen. Convenient for battery operation.</span><span id="f512" class="kx ky iq mt b gy ne my l mz na">contrast(), to adjust the contrast</span><span id="b479" class="kx ky iq mt b gy ne my l mz na">invert(), invert the colors of the screen (finally white and black!)</span><span id="d528" class="kx ky iq mt b gy ne my l mz na">show(), to refresh the view</span><span id="4047" class="kx ky iq mt b gy ne my l mz na">fill(), to fill the screen in black (1) or white (0)</span><span id="9d06" class="kx ky iq mt b gy ne my l mz na">pixel(), to turn on a particular pixel</span><span id="5f84" class="kx ky iq mt b gy ne my l mz na">scroll(), scroll the screen.</span><span id="9384" class="kx ky iq mt b gy ne my l mz na">text(), to display on text at the indicated x, y position</span><span id="7f5a" class="kx ky iq mt b gy ne my l mz na">Draw lines hline(), vline() or any line line()</span><span id="6d32" class="kx ky iq mt b gy ne my l mz na">Draw a rect rect rectangle() or rectangle filled fill_rect()</span></pre><p id="c906" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们测试一下我们的展示:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="b46f" class="kx ky iq mt b gy mx my l mz na">oled.fill(0)<br/>oled.text("Hello esp8266", 0, 0)<br/>oled.show()</span></pre><p id="570a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们在 put 有机发光二极管上显示 DHT22 传感器数据:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="d56d" class="kx ky iq mt b gy mx my l mz na">data.measure()<br/>temp = data.temperature()<br/>hum = data.humidity()</span><span id="2254" class="kx ky iq mt b gy ne my l mz na">oled.fill(0)<br/>oled.text("Temp:  " + str(temp) + "oC", 0, 0)<br/>oled.text("Hum:   " + str(hum) + "%",0, 16)<br/>oled.show()</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/ccf68d96bc8c81380c7badeeaa28c995.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*3p_PoN0qRoC-KlPZ"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/45fba87a872fe5b3b6a8aeea75f3c50e.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/0*ImwANSr-XvZROeUc"/></div></figure><h2 id="2645" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">11.更进一步</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/fa368db565ce4cd6c49f3cdcc354d843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*kdYO0TaSQbin25nH"/></div></figure><p id="0b27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文为您提供了构建一个更健壮的项目的一些细节，使用 MicroPython 作为编程语言，使用 Jupyter Notebook 作为快速开发和分析的工具。</p><p id="97fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，如果您想在独立于您的 PC 和 Jupyter 的 NodeMCU 上运行用 MicroPython 编写的程序，您必须在任何文本编辑器中将您的代码保存为“main.py”文件，并使用 Adafruit 开发的实用程序:"<a class="ae lv" href="https://github.com/adafruit/ampy" rel="noopener ugc nofollow" target="_blank"> Ampy </a>"将其下载到您的设备上，以便通过串行连接与 MicroPython 板进行交互。</p><p id="6a85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Ampy 是一个简单的命令行工具，通过串行连接在 MicroPython 板上操作文件和运行代码。使用 ampy，您可以将文件从您的计算机发送到 MicroPython 板的文件系统，将文件从板下载到您的计算机，甚至将 Python 脚本发送到板来执行。</p><p id="820b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="c8ba" class="kx ky iq mt b gy mx my l mz na">sudo pip3 install adafruit-ampy</span></pre><p id="f7e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Ampy 通过其串行连接与 MicroPython 板通信。您需要连接您的主板，并安装任何驱动程序来访问它的串行端口。然后，例如，要列出板上的文件，运行如下命令:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="7c2c" class="kx ky iq mt b gy mx my l mz na">ampy --port /dev/tty.SLAB_USBtoUART ls</span></pre><p id="4a47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了方便起见，您可以设置一个 AMPY_PORT 环境变量，如果未指定 PORT 参数，将使用该变量。例如在 Linux 或 OSX 上:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="cb0f" class="kx ky iq mt b gy mx my l mz na">export AMPY_PORT=/dev/tty.SLAB_USBtoUART</span></pre><p id="7079" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，从现在开始，您可以简化命令:</p><p id="b732" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">列出内部节点 MCU 文件:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="ede2" class="kx ky iq mt b gy mx my l mz na">ampy ls</span></pre><p id="d0b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用以下命令读取安装在 nodeMCU 上的文件:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="fc48" class="kx ky iq mt b gy mx my l mz na">ampy get boot.py</span></pre><p id="93b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦使用文本编辑器(例如 nano)创建了一个文件，就可以使用以下命令将其安装到 NodeMCU 上:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="0ba2" class="kx ky iq mt b gy mx my l mz na">ampy put main.py</span></pre><p id="37e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，当您按下 NodeMcu 上的“Reset”按钮时，首先运行的程序是“main.py”。</p><p id="da05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于 Windows，请参见此处的 Adafruit 说明<a class="ae lv" href="https://github.com/adafruit/ampy" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="058b" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">12.结论</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/b6ff0e69e5b48ef97ba1e53ccc59664d.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/0*eCJH5xcWnGfaXZGd"/></div></figure><p id="c67c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一如既往，我希望这个项目可以帮助其他人找到进入令人兴奋的电子世界的方法！</p><p id="0051" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">详情和最终代码请访问我的 GitHub 存管:<a class="ae lv" href="https://github.com/Mjrovai/Python4DS/tree/master/Micropython" rel="noopener ugc nofollow" target="_blank"> Pyhon4DS/Micropython </a></p><p id="b64a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更多项目，请访问我的博客:【MJRoBot.org T4】</p><p id="4f98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来自世界南部的 Saludos！</p><p id="e87c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的下一篇文章再见！</p><p id="f9f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谢谢你，</p><p id="9e6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">马塞洛</p></div></div>    
</body>
</html>