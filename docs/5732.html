<html>
<head>
<title>Mocking a method in the same test class using Mockito</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Mockito 模仿同一个测试类中的方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mocking-a-method-in-the-same-test-class-using-mockito-b8f997916109?source=collection_archive---------0-----------------------#2018-11-06">https://towardsdatascience.com/mocking-a-method-in-the-same-test-class-using-mockito-b8f997916109?source=collection_archive---------0-----------------------#2018-11-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/69ed1e1330631bf4579472763d424f09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*rmU-GuLHRkE9BKSZyvkKUQ.png"/></div></figure><p id="eefb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在测试驱动开发(TDD)中，单元测试是隐含实现质量的子部分。在使用 junit 进行单元测试时，您会遇到想要模拟类的地方。当您调用具有外部通信(如数据库调用或 rest 调用)的类的方法时，就完成了模仿。通过模仿，您可以显式地定义方法的返回值，而无需实际执行方法的步骤。在这篇文章中，我将讨论在你编写测试用例的同一个测试类中模仿方法。</p><p id="a6ad" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">假设您有一个 Person 类，它有外部通信并相应地返回值。</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="8fc3" class="lb lc iq kx b gy ld le l lf lg"><br/>public class Person {<br/><br/>  private String name;<br/>  private int age;</span><span id="84a2" class="lb lc iq kx b gy lh le l lf lg">  public Person(String name, int age) {<br/>    this.name = name;<br/>    this.age = age;<br/>  }<br/>  public String getName() {<br/>    return name;<br/>  }<br/><br/>  public void setName(String name) {<br/>    this.name = name;<br/>  }<br/><br/>  public int getAge() {<br/>    return age;<br/>  }<br/><br/>  public void setAge(int age) {<br/>    this.age = age;<br/>  }<br/><br/>  public boolean runInGround(String location) {<br/>    if(location.equals("ground")) {<br/>      System.<em class="li">out</em>.println("The person runs in the " + location);<br/>      return true;<br/>    } else {<br/>      System.<em class="li">out</em>.println("The person doesn't run in the " +   location);<br/>      return false;<br/>    }<br/><br/>  }<br/><br/>  public boolean isPlay() {<br/><br/>    if(this.runInGround("ground")) {<br/>      System.<em class="li">out</em>.println("The person plays.");<br/>      return true;<br/>    }<br/>    else {<br/>      System.<em class="li">out</em>.println("The person doesn't play");<br/>      return false;<br/>    }<br/>  }<br/>}</span></pre><p id="5611" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">出于解释的目的，让我们假设 runInGround(字符串位置)方法通过检查数据库值来返回值，这是一个外部通信。这个特殊的方法是在同一个 Person 类的 isPlay()方法中调用的，它影响 isPlay()方法的返回值。</p><p id="68e3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">那么如何在不让 runInGround(字符串位置)执行并与数据库对话的情况下测试 isPlay()。</strong></p><p id="bb8c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以模仿 PersonTest 类中的<em class="li"> runInGround(字符串位置)</em>方法，如下所示。</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="84c1" class="lb lc iq kx b gy ld le l lf lg"><br/>import org.junit.Assert;<br/>import org.junit.Test;<br/>import org.mockito.Mockito;<br/><br/>public class PersonTest{<br/><br/>  @Test<br/>  public void playTest() {<br/>    Person person = new Person("name", 15, "23435678V");<br/><br/>    Person person1 = Mockito.<em class="li">spy</em>(person);<br/><br/>    Mockito.<em class="li">doReturn</em>(true).when(person1).runInGround("ground");<br/><br/>    Assert.<em class="li">assertEquals</em>(true, person1.isPlay());<br/>  }<br/>}</span></pre><p id="bac4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里我们需要使用 Mockito.spy()来模拟我们正在测试的同一个类，而不是使用 mock(class)。然后我们可以如下模拟我们想要的方法。</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="be65" class="lb lc iq kx b gy ld le l lf lg">Mockito.<em class="li">doReturn</em>(true).when(person1).runInGround("ground");</span></pre><p id="36e2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">希望这将有所帮助。用单元测试快乐编码:d。</p><p id="7567" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">延伸阅读</strong></p><p id="73a0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">[1]<a class="ae lj" href="http://www.vogella.com/tutorials/Mockito/article.html" rel="noopener ugc nofollow" target="_blank">http://www.vogella.com/tutorials/Mockito/article.html</a></p><p id="5b5e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae lj" href="https://dzone.com/articles/introduction-to-java-tdd" rel="noopener ugc nofollow" target="_blank">https://dzone.com/articles/introduction-to-java-tdd</a></p></div></div>    
</body>
</html>