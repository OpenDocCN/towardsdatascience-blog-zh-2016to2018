# 存储数据的巧妙方式

> 原文：<https://towardsdatascience.com/smart-way-of-storing-data-d22dd5077340?source=collection_archive---------1----------------------->

![](img/7025e4f427ec26a8305cc2d8881ad3e0.png)

## 让我们来谈谈位打包、重复数据删除等等

位打包就是让数据表示像手套一样适合你的数据。这是一个非常形象的比喻，但可能会有点混乱，所以让我们直接看第一个也是最简单的例子:

```
00000001 00000000 00000001
```

上面看到的是一个布尔数组的二进制表示:`true, false, true`。在大多数编程语言中，布尔值以 8 位存储，其中`0`是`false`，而`>=1`是`true`。这一切都是有意义的，因为 CPU 是如何读取数据的，但是如果我们知道我们要存储一个布尔值数组，我们可以使用一个[位数组](https://en.wikipedia.org/wiki/Bit_array):

```
00000101
```

在这种情况下，bool 数组可以表示为一个字节数组，其中 size 是`ceil(size/8)`。当我们请求索引`i`处的元素时，我们需要从`i`创建两个索引:

1.  字节索引`floor(i/8)`
2.  位索引`i mod 8`，或者你也可以做`i — (byteIndex * 8)`如果你不想做[模](https://en.wikipedia.org/wiki/Modulo_operation)运算。

为了找出索引`i`处的值是`true`还是`false`，我们需要从比特索引`1 << bitIndex`创建一个比特掩码，然后应用下面的表达式:`bitArray[byteIndex] & mask != 0`。

正如我们所看到的，从位数组中读取布尔值需要一些计算，但在最好的情况下可以将存储数据的大小减少 87.5%。

现在我们来谈谈数字。数字以字节存储:

*   1 字节:0… **256**
*   2 字节:0…**65536**
*   4 字节:0… **4，294，967，296**
*   8 字节:0… **18，446，744，073，709，551，616**

## 但是如果我们知道我们的数据是由较小的数字组成的呢？

四分之一字节可以代表数字 0…3，一半字节可以代表数字 0…15。

我们可以使用与位数组中相同的技术——计算两个索引，并通过几次[位移操作](https://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts)得到值。

```
00000001 00000010 00000011 00000000
```

其中值为`1, 2, 3, 0`。可以变成:

```
00111001
```

实现了 75%的减少。我将让读者去思考如何用半字节表示保存一个数组。

## 存储一个 6 位数字有意义吗？

如果我们存储的数不是二位数的幂(1，2，4，8)，我们将不得不面对这样一个事实，即一个数存储在两个字节之间。这意味着我们必须先读取第一个字节，然后再读取第二个字节。所以一般来说这是可能的，但老实说我从未见过有人这样做。然而，我所看到的是——将两个小数字的元组一起存储在一个字节中。例如 [FlexBuffers 类型定义](https://google.github.io/flatbuffers/flatbuffers_internals.html)是:

*   2 个较低的位代表子的位宽(8，16，32，64)
*   6 位代表实际类型

## 如果我不知道我的数字会有多大呢？

在这种情况下，你可以选择尽可能大的尺寸，或者应用[可变长度数量](https://en.wikipedia.org/wiki/Variable-length_quantity)技术。

在这种技术中，我们取一个代表数字的比特流，并将其分成 7 个比特。第 8 位成为“标志”位。如果下一个 7 位分区不包含所有的`0`，标志位将被设置为`1`，如果您对细节感兴趣，请查看[维基百科文章](https://en.wikipedia.org/wiki/Variable-length_quantity)。

协议缓冲区中使用了可变长度数量技术，这对格式非常重要，这是[编码文档](https://developers.google.com/protocol-buffers/docs/encoding)解释的第一件事。

有趣的是，如果你看看 [UTF-8](https://en.wikipedia.org/wiki/UTF-8) 编码。这基本上是相同的技术，只是在扫描字节方面有一点小小的调整。字节序列中的第一个字节，它编码一个 [Unicode 字符](https://en.wikipedia.org/wiki/Unicode)告诉你序列有多长。如果字节以`0`开始(从左到右方向),则只有这一个字节。如果 unicode 字符需要两个字节，那么第一个字节的“开始”将是`11`，如果是三个字节，则是`111`，依此类推。

在我们转向重复数据消除之前，我还想讨论一项技术。我说的是**存储增量**。

假设您正在存储一个时间戳序列，表示为 [unix 时间](https://en.wikipedia.org/wiki/Unix_time)。如果我们按原样存储时间戳，每个条目将消耗 4 个字节。然而，如果我们只按原样存储第一个条目，而所有其他条目只作为增量存储，那么我们可以对所有后续条目使用小得多的数字表示。最佳情况下，事件之间的间隔总是小于 255 秒(4 分 15 秒)。因此，我们可以用 1 字节存储时间戳，节省大约 75%的空间。

## 现在我们来谈谈重复数据消除。

每个数据都有某种重复。重复数据删除技术试图找到这些重复数据并*【消除】*它们。

消除是一个很强的词，我们不能因为一个值存储了两次就删除它。我们能做的，是间接地储存价值。一个很好的重复数据删除的老例子是 [GIF 格式](https://en.wikipedia.org/wiki/GIF)。在 GIF 中，一种颜色用 24 位——3 字节来表示。它存储在调色板中。一个调色板可以容纳 256 个条目(3 * 256 = 768 字节)。存储图像中的每个像素都存储为 1 字节调色板索引。

## 让我们做一些数学

我们有 768 字节的开销，每像素 66%的收益。这意味着，如果我们有超过 384 像素:`384 * 3 = 384 * 1 + 768`我们弥补了调色板的成本，并开始了我们的旅程，以减少 66%的空间。

同样的技术可以应用于大数字、文本串或任何其他在我们的数据集中重复出现的数据。这种技术的唯一问题是，我们需要知道数据有多少种不同的表现形式。使用 GIF，调色板是以某种方式创建的，一些颜色可能被“挤压”成一种颜色。这不是图像的问题，但是你可能不想对文本做同样的事情。

如果你仔细阅读前面的章节，你可能已经知道答案了。我们可以将调色板索引存储为可变长度的量。

我们还可以做另一件聪明的事情。我们可以尝试使用大数定律。在一个大的数据集中，我们可以假设一些条目会比其他条目出现得更频繁。在这种情况下，我们可以为 X 个最常出现的值创建一个小调色板，使用另一个调色板/数组来存储不经常出现的数字，这些值将存储在一个位打包数组中，该数组将指示该数字是否经常出现。好的，这很抽象，让我们举个小例子。

假设我们正在存储数字，我们知道`7, 13, 42`是我们通常存储的三个最常用的数字。现在让我们看一个数据序列的例子:

```
Initial: 7, 7, 7, 13, 13, 13, 2345, 42, 42, 7, 13, 6543, 7=>Index:    1, 1, 1, 2, 2, 2, 0, 3, 3, 1, 2, 0, 1
Frequent: 7, 13, 42
Other:    2345, 6543
```

所以我们看到我们有一个 13 个条目的索引，它存储从`0`到`3`的数字。这是我们存储的一系列值。如果值大于`0`，则表示“频繁”的号码:`1 -> 7, 2 -> 13, 3 -> 42`。如果是`0`，那么我们需要从“其他”数组中取出下一个数字。

这意味着我们不能通过索引来访问值，我们只能遍历它们，但是由于索引是一个在`0`和`3`之间的数字，我们可以用四分之一字节来存储 13 个值，用 2 个字节来存储 5 个其他值。让我们再计算一下:

*   索引:`ceil(13 / 4) = 4`字节
*   频率+其他:`5 * 2 = 10`字节

总计`14`字节与`13 * 2 = 26`字节相比。

看起来，如果你有很多条目，并且[大数定律](https://en.wikipedia.org/wiki/Law_of_large_numbers)站在你这边，那么争论是值得的。

一个用例是当你处理一个稀疏值序列时，大数定律肯定是对你有利的。我说的稀疏值序列是指一个序列，其中许多值可以是“默认”或`null`(缺少值)。在这种情况下，我们的索引可以只是一个位数组，表示没有值。我们不需要“频繁”数组，我们只需要“其他/值”。

```
Initial: 23, 45, null, null, null, null, null, 3=>Index:  1, 1, 0, 0, 0, 0, 0, 1
Values: 23, 45, 3
```

另一种技术是基于大数定律的 T2 霍夫曼编码。我认为理解其背后概念的最好方法，是看一下[莫尔斯电码](https://en.wikipedia.org/wiki/Morse_code)。在莫尔斯电码中，最常用的字符用最短的序列表示，不常用的用最长的序列表示。这样，当你用莫尔斯电码交流时，你可能会花更少的时间传输。[霍夫曼编码](https://en.wikipedia.org/wiki/Huffman_coding)有点复杂，因为它是二进制格式，其中[莫尔斯码](https://en.wikipedia.org/wiki/Morse_code)是三进制的(短、长、无声)，但想法非常接近。

可能有更聪明的方法来存储数据，但遗憾的是，这是我所能得到的。我很乐意在评论中看到更多的技巧。如果你愿意，你可以鼓掌。