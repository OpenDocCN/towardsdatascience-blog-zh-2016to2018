<html>
<head>
<title>Sensor Fusion — Part 2: Kalman Filter Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">传感器融合第 2 部分:卡尔曼滤波器代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sensor-fusion-part-2-kalman-filter-code-78b82c63dcd?source=collection_archive---------3-----------------------#2018-08-24">https://towardsdatascience.com/sensor-fusion-part-2-kalman-filter-code-78b82c63dcd?source=collection_archive---------3-----------------------#2018-08-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/aa6d880a4da948c99ce77d705067b938.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sKpJmj16sJwoAIkAlhkYgQ.jpeg"/></div></div></figure><p id="694b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第一部分中，我们在推导了卡尔曼滤波算法的基本方程后离开。为便于参考，在此再次陈述。</p><p id="ec58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">A.预测:<br/>A . X = A * X+B * u<br/>B . P = A * P * AT * Q<br/>B .测量<br/>A . Y = Z—H * X<br/>B . K =(P * HT)/((H * P * HT)+R<br/>c .更新<br/> a. X = X + K * Y <br/> b. P = ( I — K * H ) * P</p><p id="c46a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我们将使用 Udacity 的 github handle 上免费提供的文本文件中的传感器读数，对上述等式进行编码。该文本文件(<em class="kx">obj _ pose-Laser-Radar-synthetic-input . txt</em>)包含来自激光和雷达的传感器读数，以及读数的时间戳和地面真实值。到目前为止，我们只介绍了基本的卡尔曼滤波算法，因此在这个编码练习中，我们将只使用上述输入文件中的激光读数。一旦我们在以后的文章中谈到“扩展卡尔曼滤波”，我们也将开始使用雷达读数。但是以我们目前对卡尔曼滤波方程的理解，仅仅使用激光读数就可以作为一个完美的例子，在编码的帮助下巩固我们的概念。</p><p id="ad3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输入文本文件中捕获的传感器读数格式如下。</p><p id="c279" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于包含雷达数据的行，列有:sensor_type (R)、rho_measured、phi_measured、rhodot_measured、timestamp、x_groundtruth、y_groundtruth、vx_groundtruth、vy_groundtruth、yaw_groundtruth、yawrate_groundtruth。</p><p id="177b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于包含激光雷达数据的行，列包括:传感器类型(L)、x 测量值、y 测量值、时间戳、x 地面真实值、y 地面真实值、vx 地面真实值、vy 地面真实值、yaw 地面真实值、yawrate 地面真实值。</p><p id="f18b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这些信息，让我们开始编码吧，不要再拖延了。与任何 Python 文件一样，让我们首先导入所有需要的库</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="7a22" class="lh li iq ld b gy lj lk l ll lm">#**************Importing Required Libraries*************<br/>import numpy as np<br/>import pandas as pd<br/>from numpy.linalg import inv</span></pre><p id="75eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，读取包含传感器读数的输入文本文件。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="b299" class="lh li iq ld b gy lj lk l ll lm">#*************Declare Variables**************************<br/>#Read Input File<br/>measurements = pd.read_csv('obj_pose-laser-radar-synthetic-input.txt', header=None, delim_whitespace = True, skiprows=1)</span></pre><p id="ee1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将“skiprows”参数设为 1，因为当我们开始实施 KF 算法时，我们没有任何关于车辆状态的先验知识。在这种情况下，我们通常将状态默认为传感器输出的第一个读数。这正是我们将要做的。在下面显示的代码中，我们将通过从输入文件的第一行读取来初始化我们的状态<strong class="ka ir"> <em class="kx"> X </em> </strong>。由于这个读数已经被使用，我们在读取输入文件时简单地跳过它。除了状态向量<strong class="ka ir"> <em class="kx"> X </em> </strong>的初始值，我们还将使用输入文件中的第一个<em class="kx">时间戳</em>作为我们的<strong class="ka ir"> <em class="kx">先前时间</em> </strong> <em class="kx">。</em>正如上一篇文章所解释的，我们需要当前和以前的时间戳来计算<strong class="ka ir"> <em class="kx"> delta_t </em> </strong> <em class="kx">。提供的时间戳以微秒为单位，我们将除以 10⁶.这有两个原因，第一，较小的数量更容易维护。第二，速度地面实况读数(以及我们代码中的速度值)是以<em class="kx">秒为单位的。</em></em></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="57d2" class="lh li iq ld b gy lj lk l ll lm"># Manualy copy initial readings from first row of input file.<br/>prv_time = 1477010443000000/1000000.0<br/>x = np.array([<br/>        [0.312242],<br/>        [0.5803398],<br/>        [0],<br/>        [0]<br/>        ])</span></pre><p id="c340" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们初始化变量来存储地面真相和 RMSE 值。RMSE(均方根误差)用于相对于地面真实值来判断我们的算法的性能。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="866f" class="lh li iq ld b gy lj lk l ll lm">#Initialize variables to store ground truth and RMSE values<br/>ground_truth = np.zeros([4, 1])<br/>rmse = np.zeros([4, 1])</span></pre><p id="aab0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们初始化矩阵<strong class="ka ir"> <em class="kx"> P </em> </strong>和<strong class="ka ir"> <em class="kx"> A </em> </strong>。关于<strong class="ka ir"> <em class="kx"> P </em> </strong>和<strong class="ka ir"> <em class="kx"> A </em> </strong>矩阵的详细结构，请参考<a class="ae kw" rel="noopener" target="_blank" href="/sensor-fusion-part-1-kalman-filter-basics-4692a653a74c">第 1 部分</a>中更深入的解释。基本上，矩阵<strong class="ka ir"> <em class="kx"> A </em> </strong>用于实现距离、速度和时间的运动学方程，矩阵<strong class="ka ir"> <em class="kx"> P </em> </strong>是状态协方差矩阵，具有作为其对角元素的<em class="kx"> x、y、vx </em>和<em class="kx"> vy </em>的方差。这个初始<strong class="ka ir"> <em class="kx"> P </em> </strong>值的意思是，我们对我们的位置值具有高置信度(这是有意义的，因为我们已经从实际传感器读数中得到它)，由相对低的方差值表示，而对速度值具有低置信度(这也是有意义的，因为我们不知道速度)，由相对大的方差值表示。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="39e2" class="lh li iq ld b gy lj lk l ll lm">#Initialize matrices P and A<br/>P = np.array([<br/>        [1, 0, 0, 0],<br/>        [0, 1, 0, 0],<br/>        [0, 0, 1000, 0],<br/>        [0, 0, 0, 1000]<br/>        ])<br/>A = np.array([<br/>        [1.0, 0, 1.0, 0],<br/>        [0, 1.0, 0, 1.0],<br/>        [0, 0, 1.0, 0],<br/>        [0, 0, 0, 1.0]<br/>        ])</span></pre><p id="06b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来我们定义<strong class="ka ir"> <em class="kx"> H </em> </strong>和<strong class="ka ir"> <em class="kx"> I </em> </strong>矩阵，正如我在上一篇文章中解释的，它们将分别是 4 x 2 和 4 x 4 矩阵。我们定义矢量<strong class="ka ir"> <em class="kx"> Z </em> </strong>，由于我们的激光雷达读数将由 2 个位置读数(x 和 y)组成，因此它将是一个 2 x 1 矢量。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="7645" class="lh li iq ld b gy lj lk l ll lm">H = np.array([<br/>        [1.0, 0, 0, 0],<br/>        [0, 1.0, 0, 0]<br/>        ])<br/>I = np.identity(4)<br/>z_lidar = np.zeros([2, 1])</span></pre><p id="7beb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们定义测量协方差矩阵<strong class="ka ir"> <em class="kx"> R </em> </strong>，根据上一篇文章，它也将是一个 2×2 的矩阵。我们将在以后的文章中详细讨论如何获取<strong class="ka ir"> <em class="kx"> R </em> </strong>矩阵和<strong class="ka ir"> <em class="kx"> noise_ax </em> </strong>和<strong class="ka ir"> <em class="kx"> noise_ay </em> </strong>的值。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="0353" class="lh li iq ld b gy lj lk l ll lm">R = np.array([<br/>        [0.0225, 0],<br/>        [0, 0.0225]<br/>        ])</span></pre><p id="52c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来我们定义<strong class="ka ir"> <em class="kx"> noise_ax </em> </strong>，<strong class="ka ir"> <em class="kx"> noise_ay </em> </strong>和 matrix <strong class="ka ir"> <em class="kx"> Q </em> </strong>。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="4234" class="lh li iq ld b gy lj lk l ll lm">noise_ax = 5<br/>noise_ay = 5<br/>Q = np.zeros([4, 4])</span></pre><p id="c350" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们花点时间来理解它们。如果我们重温本系列第一部分中定义的运动学方程，你可以看到在位置和速度项中有一个加速度因子。为了方便起见，在这里对它们进行了重写。</p><ol class=""><li id="10ab" class="ln lo iq ka b kb kc kf kg kj lp kn lq kr lr kv ls lt lu lv bi translated">Px(t+1)= Px+δ_ t * VX+0.5 * ax *δ_ t</li><li id="6dd9" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated">Py(t+1)= Py+δ_ t * vy+0.5 * ay *δ_ t</li><li id="da70" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated">Vx(t+1) = Vx + ax * delta_t</li><li id="e34a" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated">Vy(t+1) = Vy + ay * delta_t</li></ol><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/29f7764dafd75f684cc2a118f8120145.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*Yw3U9rHIonB5o44A0JVvkQ.png"/></div></figure><p id="b604" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于加速度未知，我们可以将其添加到噪声成分中，这种随机噪声可以解析地表示为上面推导的等式中的最后一项。因此，我们有一个随机加速度向量<em class="kx"> v </em>，它由一个零均值和一个协方差矩阵<strong class="ka ir"> <em class="kx"> Q. </em> </strong>描述</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/2ef8ddd7327e155884ba94f58bb5d356.png" data-original-src="https://miro.medium.com/v2/resize:fit:294/format:webp/1*KGh-ppbBlYZH6K50MflbNQ.png"/></div></figure><p id="9562" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">向量<strong class="ka ir"> <em class="kx"> v </em> </strong>可以分解成两个分量:不包含随机变量的 4 乘 2 矩阵 G 和包含随机加速度分量的 2 乘 1 矩阵<em class="kx"> a </em>:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi md"><img src="../Images/d5439311f4f1de133664e55f54f7a62c.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*rwU2OtGKev_Tr4omTWpc5Q.png"/></div></figure><p id="876a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在卡尔曼滤波器的每次迭代中计算 delta_t，并且由于我们没有任何加速度数据，我们将加速度<strong class="ka ir"><em class="kx"/></strong><em class="kx"/>定义为具有零均值和标准差 noise_ax 和 noise_ay 的随机向量。基于我们的噪声向量，我们现在可以定义新的协方差矩阵 q。协方差矩阵被定义为噪声向量<em class="kx"> v </em>乘以噪声向量<em class="kx"> v </em>转置的期望值。所以让我们把这个写下来:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/58615d4c6454cbd08ac50429841d53b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*3kifoOgBrucWtjeheiUY7A.png"/></div></figure><p id="493d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要了解更多关于“期望值”的信息，请观看汗学院的<a class="ae kw" href="https://youtu.be/j__Kredt7vY" rel="noopener ugc nofollow" target="_blank">视频。由于 G 不包含随机变量，我们可以把它放在期望计算之外</a></p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/490f267c84080acf0a59eb5c4ca61c1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*RKtmd49ZNF-yElMyeEwnnA.png"/></div></figure><p id="3e2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ax 和 ay 被假定为不相关的噪声过程。这意味着 Q 中的协方差 sigma_axy 为零。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/728900a3c4403dcf68950caa386ca841.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*MJ2t3C79ighIQeDx6ccY1Q.png"/></div></figure><p id="e54a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在将所有内容合并到一个矩阵中后，我们获得了 4x 4 Q 矩阵:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/ba14125fd214f0cc1cc002e7a010c25c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*0m-n6cFW5BgopOr9L83VMw.png"/></div></figure><p id="9480" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在卡尔曼滤波器的每次迭代中，我们将按照上面的公式计算矩阵 Q。定义好所有变量后，让我们开始遍历传感器数据，并对它们应用卡尔曼滤波器。运行 for 循环直到测量长度，读取测量线，检查是否是激光雷达(‘L’)读数。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="9870" class="lh li iq ld b gy lj lk l ll lm">#**********************Iterate through main loop********************<br/>#Begin iterating through sensor data<br/>for i in range (len(measurements)):<br/>    new_measurement = measurements.iloc[i, :].values<br/>    if new_measurement[0] == 'L':</span></pre><p id="96a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从当前读数中获取时间戳，通过与先前时间戳进行比较来计算时间变化，然后在下一次迭代中将当前时间戳替换为先前时间戳。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="6109" class="lh li iq ld b gy lj lk l ll lm">        #Calculate Timestamp and its power variables<br/>        cur_time = new_measurement[3]/1000000.0<br/>        dt = cur_time - prv_time<br/>        prv_time = cur_time</span></pre><p id="37b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">计算 delta_t 的平方、立方和 delta_t 的四次方(代码中的“dt ”),这是计算 Q 矩阵所需的。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="57cc" class="lh li iq ld b gy lj lk l ll lm">        dt_2 = dt * dt<br/>        dt_3 = dt_2 * dt<br/>        dt_4 = dt_3 * dt</span></pre><p id="f3ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用 delta_t 值更新矩阵 A。Delta_t 将乘以速度以得出位置值。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="6c3d" class="lh li iq ld b gy lj lk l ll lm">        #Updating matrix A with dt value<br/>        A[0][2] = dt<br/>        A[1][3] = dt</span></pre><p id="1448" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更新 Q 矩阵。如果你回头看看上面导出的 Q 矩阵方程，你可以很容易地找到下面提供的代码行。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="8b8d" class="lh li iq ld b gy lj lk l ll lm">        #Updating Q matrix<br/>        Q[0][0] = dt_4/4*noise_ax<br/>        Q[0][2] = dt_3/2*noise_ax<br/>        Q[1][1] = dt_4/4*noise_ay<br/>        Q[1][3] = dt_3/2*noise_ay<br/>        Q[2][0] = dt_3/2*noise_ax<br/>        Q[2][2] = dt_2*noise_ax<br/>        Q[3][1] = dt_3/2*noise_ay<br/>        Q[3][3] = dt_2*noise_ay</span><span id="07a3" class="lh li iq ld b gy mi lk l ll lm">        #Updating sensor readings<br/>        z_lidar[0][0] = new_measurement[1]<br/>        z_lidar[1][0] = new_measurement[2]</span><span id="b6bc" class="lh li iq ld b gy mi lk l ll lm">        #Collecting ground truths<br/>        ground_truth[0] = new_measurement[4]<br/>        ground_truth[1] = new_measurement[5]<br/>        ground_truth[2] = new_measurement[6]<br/>        ground_truth[3] = new_measurement[7]</span></pre><p id="935b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后调用预测和更新函数。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="9be1" class="lh li iq ld b gy lj lk l ll lm">        predict()<br/>        update(z_lidar)</span></pre><p id="ecd1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看看我们的 predict()函数，它与我们在本系列中使用的以下预测方程非常相似。在代码部分没有太多要解释的，它实际上只是派生公式的直接复制。<br/> A .预测<br/> a. X = A * X + B * u <br/> b. P = A * P * AT * Q</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="5e7c" class="lh li iq ld b gy lj lk l ll lm">#**********************Define Functions*****************************<br/>def predict():<br/>    # Predict Step<br/>    global x, P, Q<br/>    x = np.matmul(A, x)<br/>    At = np.transpose(A)<br/>    P = np.add(np.matmul(A, np.matmul(P, At)), Q)</span></pre><p id="c59f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">继续定义 update()函数。我们将在该功能中实施“测量”和“更新”步骤。<br/> B .测量<br/>a . Y = Z—H * X<br/>b . K =(P * HT)/((H * P * HT)+R<br/>c .更新<br/> a. X = X + K * Y <br/> b. P = ( I — K * H ) * P</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="7c30" class="lh li iq ld b gy lj lk l ll lm">def update(z):<br/>    global x, P    <br/>    # Measurement update step<br/>    Y = np.subtract(z_lidar, np.matmul(H, x))<br/>    Ht = np.transpose(H)<br/>    S = np.add(np.matmul(H, np.matmul(P, Ht)), R)<br/>    K = np.matmul(P, Ht)<br/>    Si = inv(S)<br/>    K = np.matmul(K, Si)<br/>    <br/>    # New state<br/>    x = np.add(x, np.matmul(K, Y))<br/>    P = np.matmul(np.subtract(I ,np.matmul(K, H)), P)</span></pre><p id="043a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">…至此，您已经完成了卡尔曼滤波算法的完整代码。尽管这看起来像是一小步，但它是传感器融合技术的许多高级版本的基础算法。如前所述，卡尔曼滤波器的所有变体都由我们在本系列中定义的相同预测、测量和更新状态组成。在更高级的版本中，唯一的区别是它们使用不同的运动学和传感器方程。在本系列中，我们也将一步一步地介绍它们。但此时此刻，让我们击掌庆祝完成经典卡尔曼滤波算法的基础步骤。你可以在我的 github repo <a class="ae kw" href="https://github.com/PercyJaiswal/Kalman_Filter" rel="noopener ugc nofollow" target="_blank">这里</a>找到完整的代码和输入文件。</p><p id="7cf4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像往常一样，如果你喜欢我的文章，用喜欢和评论来表达你的欣赏。你也可以在<a class="ae kw" href="https://twitter.com/percyjaiswal" rel="noopener ugc nofollow" target="_blank"> twitter </a>找到我和我的其他文章</p><p id="a5ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下次再见，干杯！！</p></div></div>    
</body>
</html>