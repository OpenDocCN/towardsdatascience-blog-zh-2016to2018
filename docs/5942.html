<html>
<head>
<title>Credit Card Fraud Detection using Autoencoders in H2O</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 H2O 使用自动编码器检测信用卡欺诈</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/credit-card-fraud-detection-using-autoencoders-in-h2o-399cbb7ae4f1?source=collection_archive---------5-----------------------#2018-11-17">https://towardsdatascience.com/credit-card-fraud-detection-using-autoencoders-in-h2o-399cbb7ae4f1?source=collection_archive---------5-----------------------#2018-11-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/85753b40e33b10824ebcbb47bf1f493e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uKz4L2ui3BBSgBdaAoP1JA.jpeg"/></div></div></figure><p id="f0a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">金融领域的欺诈很少被发现。正因为如此，它会对金融领域造成严重损害。据估计，在所有的保险业务中，欺诈每年至少造成 800 亿美元的损失。如果发现欺诈活动的可能性很小，这可能会对年度损失产生重大影响。这就是为什么金融公司投资机器学习作为应对欺诈的先发制人的方法。</p><p id="0fdc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用机器学习方法的好处是，</p><ul class=""><li id="f93f" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">它有助于发现数据中隐藏和隐含的相关性。</li><li id="8e72" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">更快的数据处理和更少的手动工作</li><li id="77c1" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">自动检测可能的欺诈场景。</li></ul><p id="110d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检测欺诈的最佳方法是异常检测。</p><h1 id="4893" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">异常检测</h1><p id="b24c" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">异常检测是一种识别不符合预期行为的异常模式的技术，称为异常值。它在商业中有许多应用，从信用卡交易中的欺诈检测到操作环境中的故障检测。异常检测的机器学习方法:</p><ul class=""><li id="87c8" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">k-最近邻</li><li id="273d" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">自动编码器—深度神经网络</li><li id="ef88" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">k 均值</li><li id="a3e7" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">支持向量机</li><li id="a537" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">朴素贝叶斯</li></ul><p id="e8d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天我们将使用自动编码器来训练模型。</p><h1 id="ecd0" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><strong class="ak">自动编码器</strong></h1><p id="98f3" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">我们大多数人都不熟悉这种模式。Autoencoders 是一个无监督的神经网络。它是一种数据压缩算法，采用输入并经过压缩表示，然后给出重构的输出。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/cb7ad5ee163b758b75fd269180591dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zR85x1bb6OuhXjY9"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Figure 1: Neural network representation of Autoencoders</figcaption></figure><h1 id="1273" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">资料组</h1><p id="5e8a" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">至于数据集，我们将使用 Kaggle 提供的信用卡交易数据集:【https://www.kaggle.com/mlg-ulb/creditcardfraud T2】</p><p id="17c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该数据集包括 284，807 笔交易。其中，492 笔交易被标记为欺诈。因此，数据集非常不平衡。它只包含数字变量。特性<strong class="ka ir">‘时间’</strong>包含数据集中每个事务和第一个事务之间经过的秒数。特征<strong class="ka ir">‘金额’</strong>是交易金额，该特征可用于依赖于示例的成本敏感学习。特征<strong class="ka ir">‘类’</strong>是响应变量，在欺诈的情况下取值 1，否则取值 0。</p><p id="c006" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这里找到我的 Kaggle 内核:<a class="ae mw" href="https://www.kaggle.com/maneesha96/credit-card-fraud-detection-using-autoencoders" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/mane esha 96/信用卡欺诈检测使用自动编码器</a></p><p id="3ecf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完整代码:<a class="ae mw" href="https://github.com/Mash96/Credit-Card-Fraud-Detection" rel="noopener ugc nofollow" target="_blank">https://github.com/Mash96/Credit-Card-Fraud-Detection</a></p><p id="6d42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那我们开始吧！！！</p><h2 id="2d07" class="mx ll iq bd lm my mz dn lq na nb dp lu kj nc nd ly kn ne nf mc kr ng nh mg ni bi translated">设置</h2><p id="019e" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">我们今天将使用 H2O 作为 ML 平台。你可以在这里找到更多信息:<a class="ae mw" href="https://www.h2o.ai" rel="noopener ugc nofollow" target="_blank"> https://www.h2o.ai </a></p><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="4dff" class="mx ll iq nk b gy no np l nq nr">import h2o<br/>import matplotlib.pyplot as plt<br/>from pylab import rcParams<br/>import numpy as np # linear algebra<br/>import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)<br/>import os<br/>from h2o.estimators.deeplearning import H2OAutoEncoderEstimator, H2ODeepLearningEstimator</span></pre><p id="baf3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">初始化 H2O 服务器</p><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="48e0" class="mx ll iq nk b gy no np l nq nr">h2o.init(max_mem_size = 2) # initializing h2o server<br/>h2o.remove_all()</span></pre><p id="693c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用 pandas 数据框加载数据集</p><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="0e92" class="mx ll iq nk b gy no np l nq nr">creditData = pd.read_csv(r"File_Path\creditcard.csv") <br/>creditData.describe()<br/># H2O method</span><span id="a1af" class="mx ll iq nk b gy ns np l nq nr"># creditData_df = h2o.import_file(r"File_Path\creditcard.csv") </span></pre><h2 id="0ab8" class="mx ll iq bd lm my mz dn lq na nb dp lu kj nc nd ly kn ne nf mc kr ng nh mg ni bi translated">探测</h2><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="e0b4" class="mx ll iq nk b gy no np l nq nr">creditData.shape</span><span id="420d" class="mx ll iq nk b gy ns np l nq nr">&gt; (284807, 31)</span></pre><p id="a42d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查数据集中的空值</p><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="1d61" class="mx ll iq nk b gy no np l nq nr">creditData.isnull().values.any() # pandas method<br/># creditData_h2o.na_omit() # h2o method<br/># creditData_h2o.nacnt() # no missing values found</span><span id="4f64" class="mx ll iq nk b gy ns np l nq nr">&gt; False</span></pre><p id="f626" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了继续，我们需要将熊猫数据框架转换为 H2O 数据框架</p><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="160e" class="mx ll iq nk b gy no np l nq nr"># Turns python pandas frame into an H2OFrame<br/>creditData_h2o  = h2o.H2OFrame(creditData)</span><span id="3eff" class="mx ll iq nk b gy ns np l nq nr"># Let’s plot the Transaction class against the Frequency<br/>labels = [‘normal’,’fraud’]<br/>classes = pd.value_counts(creditData[‘Class’], sort = True)<br/>classes.plot(kind = ‘bar’, rot=0)<br/>plt.title(“Transaction class distribution”)<br/>plt.xticks(range(2), labels)<br/>plt.xlabel(“Class”)<br/>plt.ylabel(“Frequency”)</span></pre><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/b7e8013e367e9ba6e776534430be1cce.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*wIR9F--T1kQs7aWTqSJPog.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Figure 2</figcaption></figure><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="492d" class="mx ll iq nk b gy no np l nq nr">fraud = creditData[creditData.Class == 1]<br/>normal = creditData[creditData.Class == 0]<br/># Amount vs Class<br/>f, (ax1, ax2) = plt.subplots(2,1,sharex=True)<br/>f.suptitle('Amount per transaction by class')</span><span id="45a9" class="mx ll iq nk b gy ns np l nq nr">ax1.hist(fraud.Amount, bins = 50)<br/>ax1.set_title('Fraud List')</span><span id="8724" class="mx ll iq nk b gy ns np l nq nr">ax2.hist(normal.Amount, bins = 50)<br/>ax2.set_title('Normal')</span><span id="59ab" class="mx ll iq nk b gy ns np l nq nr">plt.xlabel('Amount')<br/>plt.ylabel('Number of Transactions')<br/>plt.xlim((0, 10000))<br/>plt.yscale('log')<br/>plt.show()</span></pre><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/09a9c59577eef87d503934ef9e3db780.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*a8yDQUpb7MWUW0y_GJDD8g.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Figure 3</figcaption></figure><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="d7e5" class="mx ll iq nk b gy no np l nq nr"># time vs Amount<br/>f, (ax1, ax2) = plt.subplots(2, 1, sharex=True)<br/>f.suptitle('Time of transaction vs Amount by class')</span><span id="9641" class="mx ll iq nk b gy ns np l nq nr">ax1.scatter(fraud.Time, fraud.Amount)<br/>ax1.set_title('Fraud List')</span><span id="895b" class="mx ll iq nk b gy ns np l nq nr">ax2.scatter(normal.Time, normal.Amount)<br/>ax2.set_title('Normal')</span><span id="bec7" class="mx ll iq nk b gy ns np l nq nr">plt.xlabel('Time (in seconds)')<br/>plt.ylabel('Amount')<br/>plt.show()</span></pre><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/1a123750f9d9a7244e375af830b4f038.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*Iy6VMcvz2WSn8btOaY_EkA.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Figure 4</figcaption></figure><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="3a7b" class="mx ll iq nk b gy no np l nq nr">#plotting the dataset considering the class<br/>color = {1:'red', 0:'yellow'}<br/>fraudlist = creditData[creditData.Class == 1]<br/>normal = creditData[creditData.Class == 0]<br/>fig,axes = plt.subplots(1,2)</span><span id="cec2" class="mx ll iq nk b gy ns np l nq nr">axes[0].scatter(list(range(1,fraudlist.shape[0] + 1)), fraudlist.Amount,color='red')<br/>axes[1].scatter(list(range(1, normal.shape[0] + 1)), normal.Amount,color='yellow')<br/>plt.show()</span></pre><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/6b062e08f8f03890eb9a1ce049185123.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*MRmiK5-LXpfbc4r4SBGccg.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Figure 5: Frauds vs Normals</figcaption></figure><h2 id="2926" class="mx ll iq bd lm my mz dn lq na nb dp lu kj nc nd ly kn ne nf mc kr ng nh mg ni bi translated">准备数据</h2><p id="9932" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated"><em class="nx">时间</em>变量对模型预测没有影响。这可以从数据可视化中搞清楚。在进入训练部分之前，我们需要弄清楚哪些变量是重要的，哪些是不重要的。所以我们可以去掉不需要的变量。</p><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="0ada" class="mx ll iq nk b gy no np l nq nr">features= creditData_h2o.drop(['Time'], axis=1)</span></pre><p id="0325" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将数据帧分为训练集和测试集，其中 80%用于训练集，其余用于测试集。</p><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="70b6" class="mx ll iq nk b gy no np l nq nr">train, test = features.split_frame([0.8])<br/>print(train.shape)<br/>print(test.shape)</span><span id="b354" class="mx ll iq nk b gy ns np l nq nr">&gt; (227722, 30)<br/>&gt; (57085, 30)</span></pre><p id="0c77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的数据集有很多非欺诈交易。由于这是为了模型训练，我们只发送非欺诈交易。以便模型能够学习正常交易的模式。</p><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="f578" class="mx ll iq nk b gy no np l nq nr"># converting to pandas dataframe<br/>train_df = train.as_data_frame()<br/>test_df = test.as_data_frame()</span><span id="6cdf" class="mx ll iq nk b gy ns np l nq nr">train_df = train_df[train_df['Class'] == 0]<br/># drop the Class variable<br/>train_df = train_df.drop(['Class'], axis=1)</span><span id="fdd0" class="mx ll iq nk b gy ns np l nq nr">Y_test_df = test_df['Class'] # true labels of the testing set</span><span id="9801" class="mx ll iq nk b gy ns np l nq nr">test_df = test_df.drop(['Class'], axis=1)</span><span id="4553" class="mx ll iq nk b gy ns np l nq nr">train_df.shape</span><span id="52e8" class="mx ll iq nk b gy ns np l nq nr">&gt; (227335, 29)</span></pre><h2 id="5eec" class="mx ll iq bd lm my mz dn lq na nb dp lu kj nc nd ly kn ne nf mc kr ng nh mg ni bi translated">模型结构</h2><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="3b9e" class="mx ll iq nk b gy no np l nq nr">train_h2o = h2o.H2OFrame(train_df) # converting to h2o frame<br/>test_h2o = h2o.H2OFrame(test_df)<br/>x = train_h2o.columns</span></pre><p id="076b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当建立模型时，选择 4 个完全连接的隐藏层，每层具有[14，7，7，14]个节点。前两个用于<strong class="ka ir">编码器</strong>，后两个用于<strong class="ka ir">解码器</strong>。</p><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="4262" class="mx ll iq nk b gy no np l nq nr">anomaly_model = H2ODeepLearningEstimator(activation = "Tanh",<br/>                               hidden = [14,7,7,14],<br/>                               epochs = 100,<br/>                               standardize = True,<br/>                                stopping_metric = 'MSE', <br/>                                loss = 'automatic',<br/>                                train_samples_per_iteration = 32,<br/>                                shuffle_training_data = True,     <br/>                               autoencoder = True,<br/>                               l1 = 10e-5)<br/>anomaly_model.train(x=x, training_frame = train_h2o)</span></pre><h2 id="4a49" class="mx ll iq bd lm my mz dn lq na nb dp lu kj nc nd ly kn ne nf mc kr ng nh mg ni bi translated">模型评估</h2><p id="6fde" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated"><em class="nx">变量重要性:</em>在 H2O 有一种特殊的方法来分析哪些变量对模型的影响更大。</p><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="4d85" class="mx ll iq nk b gy no np l nq nr">anomaly_model._model_json['output']['variable_importances'].as_data_frame()</span></pre><p id="eef4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">可视化</strong></p><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="7216" class="mx ll iq nk b gy no np l nq nr"># plotting the variable importance<br/>rcParams['figure.figsize'] = 14, 8<br/>#plt.rcdefaults()<br/>fig, ax = plt.subplots()<br/><br/>variables = anomaly_model._model_json['output']['variable_importances']['variable']<br/>var = variables[0:15]<br/>y_pos = np.arange(len(var))<br/><br/>scaled_importance = anomaly_model._model_json['output']['variable_importances']['scaled_importance']<br/>sc = scaled_importance[0:15]<br/><br/>ax.barh(y_pos, sc, align='center', color='green', ecolor='black')<br/>ax.set_yticks(y_pos)<br/>ax.set_yticklabels(variables)<br/>ax.invert_yaxis()<br/>ax.set_xlabel('Scaled Importance')<br/>ax.set_title('Variable Importance')<br/>plt.show()</span></pre><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/23bcb109c386b001ef3ddf75d3e72e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lms7bYGKkpSmDwoVbtEqrA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Figure 6</figcaption></figure><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="76fc" class="mx ll iq nk b gy no np l nq nr"># plotting the loss<br/>scoring_history = anomaly_model.score_history()<br/>%matplotlib inline<br/>rcParams['figure.figsize'] = 14, 8<br/>plt.plot(scoring_history['training_mse'])<br/>plt.title('model loss')<br/>plt.ylabel('loss')<br/>plt.xlabel('epoch')</span></pre><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/d6b842d5ad3c9cea5d5cfb9912fdb73a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g5mH7ilWkNjBaGXqEM8fKA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Figure 7</figcaption></figure><p id="522a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">测试集</strong>包含正常交易和欺诈交易。自动编码器将学习识别输入数据的模式。如果异常测试点与学习的模式不匹配，则自动编码器在重构该数据时可能具有高错误率，从而指示异常数据。这样我们就能识别数据的异常。为了计算误差，它使用<strong class="ka ir">均方误差</strong> (MSE)</p><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="818a" class="mx ll iq nk b gy no np l nq nr">test_rec_error = anomaly_model.anomaly(test_h2o) <br/># anomaly is a H2O function which calculates the error for the dataset</span><span id="7c9b" class="mx ll iq nk b gy ns np l nq nr"># converting to pandas dataframe<br/>test_rec_error_df = test_rec_error.as_data_frame()</span><span id="3001" class="mx ll iq nk b gy ns np l nq nr"># plotting the testing dataset against the error<br/>test_rec_error_df['id']=test_rec_error_df.index<br/>rcParams['figure.figsize'] = 14, 8<br/>test_rec_error_df.plot(kind="scatter", x='id', y="Reconstruction.MSE")<br/>plt.show()</span></pre><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/6665a1168d9d59826a15172436861dff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xGCPPGGtEWdg7RQfmBOtuQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Figure 8: Anomalies in testing set</figcaption></figure><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="f342" class="mx ll iq nk b gy no np l nq nr"># predicting the class for the testing dataset<br/>predictions = anomaly_model.predict(test_h2o)</span><span id="cd75" class="mx ll iq nk b gy ns np l nq nr">error_df = pd.DataFrame({'reconstruction_error': test_rec_error_df['Reconstruction.MSE'],<br/>                        'true_class': Y_test_df})<br/>error_df.describe()</span></pre><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/bc657208c785445d1b70505d1c1941ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*Eg5Q8HXM6HqEWhGW4Oissg.jpeg"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Figure 9</figcaption></figure><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="418f" class="mx ll iq nk b gy no np l nq nr"># reconstruction error for the normal transactions in the testing dataset<br/>fig = plt.figure()<br/>ax = fig.add_subplot(111)<br/>rcParams['figure.figsize'] = 14, 8<br/>normal_error_df = error_df[(error_df['true_class']== 0) &amp; (error_df['reconstruction_error'] &lt; 10)]<br/>_ = ax.hist(normal_error_df.reconstruction_error.values, bins=10)</span></pre><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/c008835d9a5bbd2f1c9d57da20dbb17b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nDQ8PxR-H8YDUcu4pjb5dQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Figure 10</figcaption></figure><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="0a23" class="mx ll iq nk b gy no np l nq nr"># reconstruction error for the fraud transactions in the testing dataset<br/>fig = plt.figure()<br/>ax = fig.add_subplot(111)<br/>rcParams['figure.figsize'] = 14, 8<br/>fraud_error_df = error_df[error_df['true_class'] == 1]<br/>_ = ax.hist(fraud_error_df.reconstruction_error.values, bins=10)</span></pre><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/4afa7d75133f042651f2d5f40a6e7c7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BxjhMKoFHCTr6tVm3JJSaA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Figure 11</figcaption></figure><h2 id="c902" class="mx ll iq bd lm my mz dn lq na nb dp lu kj nc nd ly kn ne nf mc kr ng nh mg ni bi translated">受试者工作特征曲线</h2><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="5d68" class="mx ll iq nk b gy no np l nq nr">from sklearn.metrics import (confusion_matrix, precision_recall_curve, auc,<br/>                             roc_curve, recall_score, classification_report, f1_score,<br/>                             precision_recall_fscore_support)<br/>fpr, tpr, thresholds = roc_curve(error_df.true_class, error_df.reconstruction_error)<br/>roc_auc = auc(fpr, tpr)</span><span id="2038" class="mx ll iq nk b gy ns np l nq nr">plt.title('Receiver Operating Characteristic')<br/>plt.plot(fpr, tpr, label='AUC = %0.4f'% roc_auc)<br/>plt.legend(loc='lower right')<br/>plt.plot([0,1],[0,1],'r--')<br/>plt.xlim([-0.001, 1])<br/>plt.ylim([0, 1.001])<br/>plt.ylabel('True Positive Rate')<br/>plt.xlabel('False Positive Rate')<br/>plt.show();</span></pre><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/686025b9bbf8de991b9a7cc9d2bf4e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xmiiEPH_k-w0ZF17iaS78w.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Figure 12</figcaption></figure><p id="3b91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="nx">精度</em> </strong> <em class="nx"> </em>为<strong class="ka ir"> 0.9718 </strong></p><h2 id="bd40" class="mx ll iq bd lm my mz dn lq na nb dp lu kj nc nd ly kn ne nf mc kr ng nh mg ni bi translated">精确度和召回率</h2><p id="1a5b" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">由于数据是高度不平衡的，所以不能只用精度来衡量。选择精度与召回率作为分类任务的矩阵。</p><p id="6533" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">精度</strong>:测量所得结果的相关性。</p><p id="86f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[真阳性/(真阳性+假阳性)]</p><p id="cf25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">回忆</strong>:测量返回多少相关结果。</p><p id="844f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[真阳性/(真阳性+假阴性)]</p><p id="ea41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">真阳性</strong> —预测为欺诈的实际欺诈数量</p><p id="d665" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">误报</strong> —预测为欺诈的非欺诈数量</p><p id="4741" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">假阴性</strong> —预测为非欺诈的欺诈数量。</p><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="7d91" class="mx ll iq nk b gy no np l nq nr">precision, recall, th = precision_recall_curve(error_df.true_class, error_df.reconstruction_error)<br/>plt.plot(recall, precision, 'b', label='Precision-Recall curve')<br/>plt.title('Recall vs Precision')<br/>plt.xlabel('Recall')<br/>plt.ylabel('Precision')<br/>plt.show()</span></pre><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/afca88b9c440eea16f02d932fdab38ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y2aychfyiaB4euYh5iWcbA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Figure 13</figcaption></figure><p id="4c15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要找到一个更好的阈值来区分异常和正常。这可以通过计算<strong class="ka ir">精度/召回与阈值</strong>图的交集来完成。</p><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="2c1d" class="mx ll iq nk b gy no np l nq nr">plt.plot(th, precision[1:], label="Precision",linewidth=5)<br/>plt.plot(th, recall[1:], label="Recall",linewidth=5)<br/>plt.title('Precision and recall for different threshold values')<br/>plt.xlabel('Threshold')<br/>plt.ylabel('Precision/Recall')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/f030634ec1017e5beab49c454c505658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1m4vg1LefOe1P4g3ZWROoQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Figure 14</figcaption></figure><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="a769" class="mx ll iq nk b gy no np l nq nr"># plot the testing set with the threshold<br/>threshold = 0.01<br/>groups = error_df.groupby('true_class')<br/>fig, ax = plt.subplots()</span><span id="754e" class="mx ll iq nk b gy ns np l nq nr">for name, group in groups:<br/>    ax.plot(group.index, group.reconstruction_error, marker='o', ms=3.5, linestyle='',<br/>            label= "Fraud" if name == 1 else "Normal")<br/>ax.hlines(threshold, ax.get_xlim()[0], ax.get_xlim()[1], colors="r", zorder=100, label='Threshold')<br/>ax.legend()<br/>plt.title("Reconstruction error for different classes")<br/>plt.ylabel("Reconstruction error")<br/>plt.xlabel("Data point index")<br/>plt.show();</span></pre><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/c6b5808ecd2beb777de8dbc103601900.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QYv2hGzaU9X6FwJc-cwt0w.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Figure 15</figcaption></figure><h2 id="439d" class="mx ll iq bd lm my mz dn lq na nb dp lu kj nc nd ly kn ne nf mc kr ng nh mg ni bi translated">混淆矩阵</h2><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="4d39" class="mx ll iq nk b gy no np l nq nr">import seaborn as sns<br/>LABELS = ['Normal', 'Fraud']<br/>y_pred = [1 if e &gt; threshold else 0 for e in error_df.reconstruction_error.values]<br/>conf_matrix = confusion_matrix(error_df.true_class, y_pred)<br/>plt.figure(figsize=(12, 12))<br/>sns.heatmap(conf_matrix, xticklabels=LABELS, yticklabels=LABELS, annot=True, fmt="d");<br/>plt.title("Confusion matrix")<br/>plt.ylabel('True class')<br/>plt.xlabel('Predicted class')<br/>plt.show()</span></pre><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/84e6087364c8f58e7ca8d8805c8d1e88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*7UOWqffPGmdzfN_H3x-M2Q.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Figure 16</figcaption></figure><h2 id="1848" class="mx ll iq bd lm my mz dn lq na nb dp lu kj nc nd ly kn ne nf mc kr ng nh mg ni bi translated">分类报告</h2><pre class="mo mp mq mr gt nj nk nl nm aw nn bi"><span id="8b89" class="mx ll iq nk b gy no np l nq nr">csr = classification_report(error_df.true_class, y_pred)<br/>print(csr)</span></pre><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/bc7c47e5a223b0e80d31c6522f9cfa8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i9NL9YhwON_87p5dYbSd0w.jpeg"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Figure 17</figcaption></figure><h1 id="f63b" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">结论</h1><p id="24a8" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">我们的模型捕捉到了大部分欺诈数据。在自动编码器中，它提供了很好的准确性。但是，如果我们考察数据集的精度和召回率，它的性能还不够。正如我前面提到的，还有其他异常检测方法在高度不平衡的数据集中表现良好。</p><p id="3278" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在这个数据集上尝试了更多的方法。所以我很快会带着这些来见你。:)</p><h2 id="0651" class="mx ll iq bd lm my mz dn lq na nb dp lu kj nc nd ly kn ne nf mc kr ng nh mg ni bi translated">参考</h2><p id="5701" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated"><a class="ae mw" href="https://medium.com/@curiousily/credit-card-fraud-detection-using-autoencoders-in-keras-tensorflow-for-hackers-part-vii-20e0c85301bd" rel="noopener">https://medium . com/@ curiously/credit-card-fraud-detection-using-auto encoders-in-keras-tensor flow-for-hacker-part-VII-20 e0c 85301 BD</a></p></div></div>    
</body>
</html>