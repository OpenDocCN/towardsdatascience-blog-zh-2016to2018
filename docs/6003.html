<html>
<head>
<title>Create Better Data Science Projects With Business Impact: Churn Prediction with R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建具有业务影响的更好的数据科学项目:使用 R</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/create-better-data-science-projects-with-business-impact-churn-prediction-with-r-f609c23a6287?source=collection_archive---------9-----------------------#2018-11-20">https://towardsdatascience.com/create-better-data-science-projects-with-business-impact-churn-prediction-with-r-f609c23a6287?source=collection_archive---------9-----------------------#2018-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e4a9314ea4b52fad54dd450da7fd09f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4EouSbqe3zDJrpdT.jpg"/></div></div></figure><p id="4efd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">找份工作并不容易，你需要让自己与众不同。</p><p id="b098" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">仅仅展示你知道如何使用像<strong class="ka ir"> scikit-learn </strong>或<strong class="ka ir"> ggplot2 </strong>这样的工具是不够的，这是已知的。</p><p id="8df5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以问题是，你能做什么？</p><p id="247f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我最喜欢的策略之一是<strong class="ka ir">展示商业影响</strong>。</p><p id="8ad8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我所说的<strong class="ka ir">“业务影响”是什么意思</strong></p><p id="fa1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在一天结束时，你将直接或间接地从事与业务相关的工作。</p><p id="00ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那可能是<strong class="ka ir">降低成本</strong>、<strong class="ka ir">增加收入</strong>、<strong class="ka ir">改善客户体验</strong>等等。</p><p id="2fd1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将一步一步地向你展示如何建立一个<a class="ae kw" href="https://www.dataoptimal.com/churn-prediction-with-r/" rel="noopener ugc nofollow" target="_blank">客户流失预测模型</a>来显示<strong class="ka ir">重大的商业影响</strong>。</p><p id="3dd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个简单的概述:</p><ul class=""><li id="8635" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">工作经历</li><li id="dc9d" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">逻辑回归</li><li id="b747" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">准备数据</li><li id="19a8" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">拟合模型</li><li id="284c" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">做预测</li><li id="fa21" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">业务影响</li></ul><h1 id="5012" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">工作经历</h1><p id="b1e0" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在任何现实世界的数据科学项目开始时，你都需要问一系列问题<a class="ae kw" rel="noopener" target="_blank" href="/how-to-construct-valuable-data-science-projects-in-the-real-world-203a4f520d54"/>。</p><p id="f5a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有几个好的开始:</p><ul class=""><li id="9ffb" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">你想解决什么问题？</li><li id="3cfa" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">你的潜在解决方案是什么？</li><li id="4a52" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">你将如何评价你的模型？</li></ul><p id="4aa0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">继续前面的<strong class="ka ir">客户流失</strong>想法，让我们假设你在电信行业工作。</p><p id="6e94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有一天，你的老板找到你，问你，“我们如何利用现有的数据来改善业务？”</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/3ac1612031f9608ac3586b13ea96316b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7rip4G3jfPoUcqyO.jpg"/></div></div></figure><p id="4a40" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看一下如何详细回答每个问题，以提出解决老板问题的战略方法。</p><h1 id="5196" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">你想解决什么问题？</h1><p id="cb20" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在查看了现有数据后，您发现获得新客户的成本大约是留住现有客户的五倍。</p><p id="73dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，更集中的问题变成了，<strong class="ka ir">“我们如何提高客户保持率以降低成本？”</strong></p><h1 id="ce55" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">你的潜在解决方案是什么？</h1><p id="11a5" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">由于我们可以访问现有的客户数据，我们可以尝试建立一个机器学习模型来预测客户流失。</p><p id="eecb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了避免过于抽象而无法向管理层解释的事情变得过于复杂，我们将使用<a class="ae kw" href="https://en.wikipedia.org/wiki/Logistic_regression" rel="noopener ugc nofollow" target="_blank">逻辑回归模型</a>。</p><h1 id="596d" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">你将如何评价你的模型？</h1><p id="f8f3" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我们将使用一系列机器学习<strong class="ka ir">评估指标</strong> ( <a class="ae kw" href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic" rel="noopener ugc nofollow" target="_blank"> ROC </a>，AUC，灵敏度，特异性)以及<strong class="ka ir">业务导向指标</strong>(成本节约)。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/3ddd8095def766a2c349b0ea81f96210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_vDZFV0eW9DVezS_.jpg"/></div></div></figure><h1 id="eea7" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">逻辑回归</h1><p id="1b80" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">既然我们已经熟悉了业务背景，并且已经确定了问题的范围，那么让我们来看看我们潜在的解决方案。</p><p id="7b48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以尝试使用许多机器学习模型。都有利弊。</p><p id="0fab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使事情简单，让我们只坚持逻辑回归。</p><p id="dda5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">逻辑回归是一个线性分类器。由于我们试图预测“流失”或“没有流失”，分类模型正是我们所需要的。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/e7bdbfc5375cf1a37460bda0f2a84aca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YempQFcmdt9C_ffK.jpg"/></div></div></figure><p id="61ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个很棒的模型，因为它比许多其他模型更容易解释，比如随机森林。我所说的“解释”是指我们可以更容易地看到特征和输出之间的关系。</p><p id="ed86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">逻辑回归的缺点是它有一个偏向线性拟合的<a class="ae kw" href="https://stats.stackexchange.com/questions/13643/bias-an-intuitive-definition" rel="noopener ugc nofollow" target="_blank">偏差</a>。如果决策边界不是线性的，它的性能可能不如随机森林这样的模型。</p><p id="99f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本上，我们是在用灵活性来换取可解释性。在实现机器学习模型时，这始终是一个需要考虑的问题。</p><h1 id="3822" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">准备数据</h1><p id="0098" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">下一步是准备数据。</p><p id="4af5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此工作流程因项目而异，但对于我们的示例，我将使用以下工作流程:</p><ol class=""><li id="f60a" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv mv ld le lf bi translated">导入数据</li><li id="bc90" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv mv ld le lf bi translated">快速看一眼</li><li id="178c" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv mv ld le lf bi translated">清理数据</li><li id="dcfe" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv mv ld le lf bi translated">拆分数据</li></ol><p id="13cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在工作流程中省略了一个完整的探索阶段。在以后的文章中，我会详细介绍这一点，因为我认为这与建模阶段同等重要，甚至更重要。</p><h1 id="e757" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">1)导入数据</h1><p id="e856" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">让我们首先导入<a class="ae kw" href="https://github.com/dataoptimal/posts/tree/master/business%20impact%20project" rel="noopener ugc nofollow" target="_blank">数据</a>。你可以到我们的 github 页面去拿一份。</p><p id="099e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将利用<a class="ae kw" href="https://www.tidyverse.org/" rel="noopener ugc nofollow" target="_blank"> Tidyverse </a>库。这是使用 r 的数据科学家的必备库，请务必查看他们的文档。</p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="4c1e" class="nb lm iq mx b gy nc nd l ne nf">library(tidyverse)<br/><br/># setting the working directory<br/>path_loc &lt;- "C:/Users/Jonathan/Desktop/post"<br/>setwd(path_loc)<br/><br/># reading in the data<br/>df &lt;- read_csv("Telco Data.csv")</span></pre><p id="ce02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我喜欢在开始时设置工作目录的路径。确保将您的<code class="fe ng nh ni mx b">path_loc</code>变量修改到您的代码和数据集所在的工作目录。</p><p id="7a8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于这是一个 csv 文件，我使用了<code class="fe ng nh ni mx b">read_csv</code>函数将数据读入数据帧<code class="fe ng nh ni mx b">df</code>。</p><h1 id="3570" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">2)快速浏览一下</h1><p id="309a" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">导入数据后，您可能想快速浏览一下。我认为“快速浏览”就是这样，而不是探索数据。</p><p id="d10a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我喜欢从查看特性列的维度和名称开始。</p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="4951" class="nb lm iq mx b gy nc nd l ne nf"># dimensions of the data<br/>dim_desc(df)<br/><br/># names of the data<br/>names(df)</span><span id="bf9f" class="nb lm iq mx b gy nj nd l ne nf">&gt; # dimensions of the data<br/>&gt; dim_desc(df)<br/>[1] "[7,043 x 21]"<br/>&gt; <br/>&gt; # names of the data<br/>&gt; names(df)<br/> [1] "customerID"       "gender"           "SeniorCitizen"    "Partner"          "Dependents"       "tenure"          <br/> [7] "PhoneService"     "MultipleLines"    "InternetService"  "OnlineSecurity"   "OnlineBackup"     "DeviceProtection"<br/>[13] "TechSupport"      "StreamingTV"      "StreamingMovies"  "Contract"         "PaperlessBilling" "PaymentMethod"</span></pre><p id="7f0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到有 21 个特征和 7，043 行。有各种各样的功能，如<code class="fe ng nh ni mx b">TotalCharges </code>和<code class="fe ng nh ni mx b">tenure </code>。我们将要尝试和预测的输出是“流失”。</p><p id="4d89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个很棒的功能是<code class="fe ng nh ni mx b">glimpse</code>。这使我们能够更详细地快速查看我们的功能。</p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="0aa2" class="nb lm iq mx b gy nc nd l ne nf"># taking a look at the data<br/>glimpse(df)</span><span id="8d28" class="nb lm iq mx b gy nj nd l ne nf">&gt; glimpse(df)<br/>Observations: 7,043<br/>Variables: 21<br/>$ customerID        "7590-VHVEG", "5575-GNVDE", "3668-QPYBK", "7795-CFOCW", "9237-HQITU", "9305-CDSKC", "1452-K...<br/>$ gender            "Female", "Male", "Male", "Male", "Female", "Female", "Male", "Female", "Female", "Male", "...<br/>$ SeniorCitizen     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1...<br/>$ Partner           "Yes", "No", "No", "No", "No", "No", "No", "No", "Yes", "No", "Yes", "No", "Yes", "No", "No...<br/>$ Dependents        "No", "No", "No", "No", "No", "No", "Yes", "No", "No", "Yes", "Yes", "No", "No", "No", "No"...<br/>$ tenure            1, 34, 2, 45, 2, 8, 22, 10, 28, 62, 13, 16, 58, 49, 25, 69, 52, 71, 10, 21, 1, 12, 1, 58, 4...<br/>$ PhoneService      "No", "Yes", "Yes", "No", "Yes", "Yes", "Yes", "No", "Yes", "Yes", "Yes", "Yes", "Yes", "Ye...<br/>$ MultipleLines     "No phone service", "No", "No", "No phone service", "No", "Yes", "Yes", "No phone service",...<br/>$ InternetService   "DSL", "DSL", "DSL", "DSL", "Fiber optic", "Fiber optic", "Fiber optic", "DSL", "Fiber opti...<br/>$ OnlineSecurity    "No", "Yes", "Yes", "Yes", "No", "No", "No", "Yes", "No", "Yes", "Yes", "No internet servic...<br/>$ OnlineBackup      "Yes", "No", "Yes", "No", "No", "No", "Yes", "No", "No", "Yes", "No", "No internet service"...<br/>$ DeviceProtection  "No", "Yes", "No", "Yes", "No", "Yes", "No", "No", "Yes", "No", "No", "No internet service"...<br/>$ TechSupport       "No", "No", "No", "Yes", "No", "No", "No", "No", "Yes", "No", "No", "No internet service", ...<br/>$ StreamingTV       "No", "No", "No", "No", "No", "Yes", "Yes", "No", "Yes", "No", "No", "No internet service",...<br/>$ StreamingMovies   "No", "No", "No", "No", "No", "Yes", "No", "No", "Yes", "No", "No", "No internet service", ...<br/>$ Contract          "Month-to-month", "One year", "Month-to-month", "One year", "Month-to-month", "Month-to-mon...<br/>$ PaperlessBilling  "Yes", "No", "Yes", "No", "Yes", "Yes", "Yes", "No", "Yes", "No", "Yes", "No", "No", "Yes",...<br/>$ PaymentMethod     "Electronic check", "Mailed check", "Mailed check", "Bank transfer (automatic)", "Electroni...<br/>$ MonthlyCharges    29.85, 56.95, 53.85, 42.30, 70.70, 99.65, 89.10, 29.75, 104.80, 56.15, 49.95, 18.95, 100.35...<br/>$ TotalCharges      29.85, 1889.50, 108.15, 1840.75, 151.65, 820.50, 1949.40, 301.90, 3046.05, 3487.95, 587.45,...<br/>$ Churn             "No", "No", "Yes", "No", "Yes", "Yes", "No", "No", "Yes", "No", "No", "No", "No", "Yes", "N...</span></pre><h1 id="3154" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">3)清理数据</h1><p id="a8e2" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在开始使用逻辑回归模型之前，我们需要做一些小的清理。</p><p id="0955" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从将字符变量突变为因子开始。</p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="58cd" class="nb lm iq mx b gy nc nd l ne nf"># changing character variables to factors<br/>df &lt;- df %&gt;% mutate_if(is.character, as.factor)</span></pre><p id="844a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这段代码中，我们使用<a class="ae kw" href="https://dplyr.tidyverse.org/" rel="noopener ugc nofollow" target="_blank"> dplyr </a>的<code class="fe ng nh ni mx b">mutate_if</code>函数将字符变量转换为因子类型。</p><p id="9480" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ng nh ni mx b">%&gt;%</code>被称为管道操作员。它来自马格里特图书馆，也是 Tidyverse 的一部分。</p><p id="0947" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个操作符的基本思想是使你的代码更具可读性。你可以在这里了解更多关于管道运营商<a class="ae kw" href="https://r4ds.had.co.nz/pipes.html" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="ee09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们也将<code class="fe ng nh ni mx b">SeniorCitizen</code>变量从一个整数改为一个因子。</p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="cf5b" class="nb lm iq mx b gy nc nd l ne nf"># changing SeniorCitizen variable to factor<br/>df$SeniorCitizen &lt;- as.factor(df$SeniorCitizen)</span></pre><p id="b661" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将检查丢失的值。我们可以使用来自<a class="ae kw" href="https://purrr.tidyverse.org/" rel="noopener ugc nofollow" target="_blank"> purrr </a>库中的<code class="fe ng nh ni mx b">map</code>函数来完成这项工作。如果你还没有猜到，这个库也是 Tidyverse 的一部分。</p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="ed1a" class="nb lm iq mx b gy nc nd l ne nf"># looking for missing values<br/>df %&gt;% map(~ sum(is.na(.)))</span><span id="6213" class="nb lm iq mx b gy nj nd l ne nf">&gt; df %&gt;% map(~ sum(is.na(.)))<br/>$`customerID`<br/>[1] 0<br/><br/>$gender<br/>[1] 0<br/><br/>$SeniorCitizen<br/>[1] 0<br/><br/>$Partner<br/>[1] 0<br/><br/>$Dependents<br/>[1] 0<br/><br/>$tenure<br/>[1] 0<br/><br/>$PhoneService<br/>[1] 0<br/><br/>$MultipleLines<br/>[1] 0<br/><br/>$InternetService<br/>[1] 0<br/><br/>$OnlineSecurity<br/>[1] 0<br/><br/>$OnlineBackup<br/>[1] 0<br/><br/>$DeviceProtection<br/>[1] 0<br/><br/>$TechSupport<br/>[1] 0<br/><br/>$StreamingTV<br/>[1] 0<br/><br/>$StreamingMovies<br/>[1] 0<br/><br/>$Contract<br/>[1] 0<br/><br/>$PaperlessBilling<br/>[1] 0<br/><br/>$PaymentMethod<br/>[1] 0<br/><br/>$MonthlyCharges<br/>[1] 0<br/><br/>$TotalCharges<br/>[1] 11<br/><br/>$Churn<br/>[1] 0</span></pre><p id="21a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到<code class="fe ng nh ni mx b">TotalCharges</code>有 11 个缺失值。为了替换这些丢失的值，我们只需要用中间值做一个简单的替换。</p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="9426" class="nb lm iq mx b gy nc nd l ne nf"># imputing with the median<br/>df &lt;- df %&gt;% <br/>  mutate(TotalCharges = replace(TotalCharges,<br/>                                is.na(TotalCharges),<br/>                                median(TotalCharges, na.rm = T)))</span></pre><p id="e11d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于替换缺失值的更严格的技术方法，请查看来源。</p><p id="0b79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们要做的最后一件事是移除<code class="fe ng nh ni mx b">CustomerID</code>特性。这是每个客户的唯一标识符，所以它可能不会给我们的模型添加任何有用的信息。</p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="864c" class="nb lm iq mx b gy nc nd l ne nf"># removing customerID; doesn't add any value to the model<br/>df &lt;- df %&gt;% select(-customerID)</span></pre><p id="1c45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想测试这个，你可以一直保持这个特性，看看结果如何比较。</p><h1 id="8992" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">4)拆分数据</h1><p id="fac9" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">为了确保我们没有过度拟合我们的模型，我们将把数据分成训练集和测试集。这被称为<a class="ae kw" href="https://en.wikipedia.org/wiki/Cross-validation_(statistics)" rel="noopener ugc nofollow" target="_blank">交叉验证</a>。</p><p id="a9f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在训练集上训练模型，然后在测试集上测试它的性能。我们将随机选择 75%的数据作为我们的训练集，25%作为我们的测试集。我鼓励你尝试不同的分割，看看你的结果如何比较(也许你的训练/测试集是 80%/20%和 60%/40%)。</p><p id="c146" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了创建分割，我们将使用<a class="ae kw" href="http://topepo.github.io/caret/index.html" rel="noopener ugc nofollow" target="_blank">插入符号</a>包。让我们从导入 Caret 并设置种子开始，这样我们的结果是可重复的。</p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="829c" class="nb lm iq mx b gy nc nd l ne nf">library(caret)<br/><br/># selecting random seed to reproduce results<br/>set.seed(5)</span></pre><p id="343d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将使用<code class="fe ng nh ni mx b">createDataPartition</code>函数选择 75%的数据用于训练集。这将随机选择 75%的行。</p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="1a0f" class="nb lm iq mx b gy nc nd l ne nf"># sampling 75% of the rows<br/>inTrain &lt;- createDataPartition(y = df$Churn, p=0.75, list=FALSE)</span></pre><p id="714c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们将使用上面的行样本创建我们的训练和测试数据帧。</p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="7e57" class="nb lm iq mx b gy nc nd l ne nf"># train/test split; 75%/25%<br/>train &lt;- df[inTrain,]<br/>test &lt;- df[-inTrain,]</span></pre><p id="b402" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有其他方法，如 k 倍交叉验证，所以一定要仔细阅读这些方法。</p><p id="a9bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有关如何在 Caret 中实现 k-fold 交叉验证的信息，请在 R 控制台中键入<code class="fe ng nh ni mx b">help(“createFolds”)</code>。</p><h1 id="8d66" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">拟合模型</h1><p id="ac62" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">既然我们已经将数据分成了训练集和测试集，现在是时候拟合模型了。</p><p id="a911" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了实现逻辑回归模型，我们将使用<a class="ae kw" href="https://www.statmethods.net/advstats/glm.html" rel="noopener ugc nofollow" target="_blank">广义线性模型</a> (GLM)函数<code class="fe ng nh ni mx b">glm</code>。</p><p id="f078" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有不同类型的<a class="ae kw" href="https://en.wikipedia.org/wiki/Generalized_linear_model" rel="noopener ugc nofollow" target="_blank"> GLMs </a>，其中包括逻辑回归。为了指定我们想要执行二元逻辑回归，我们将使用参数<code class="fe ng nh ni mx b">family=binomial</code>。</p><p id="bffa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是拟合逻辑回归模型的完整代码:</p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="51e8" class="nb lm iq mx b gy nc nd l ne nf"># fitting the model<br/>fit &lt;- glm(Churn~., data=train, family=binomial)</span></pre><p id="581d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下一节中，我们将进行预测并评估我们的模型。</p><h1 id="e623" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">做预测</h1><p id="82f5" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">现在我们已经拟合了我们的模型，是时候看看它的表现了。</p><p id="2f2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我们将使用<code class="fe ng nh ni mx b">test</code>数据集进行预测。我们将传递上一节中的<code class="fe ng nh ni mx b">fit</code>模型。为了预测概率，我们将指定<code class="fe ng nh ni mx b">type=”response”</code>。</p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="6834" class="nb lm iq mx b gy nc nd l ne nf"># making predictions<br/>churn.probs &lt;- predict(fit, test, type="response")<br/>head(churn.probs)</span><span id="a228" class="nb lm iq mx b gy nj nd l ne nf">&gt; head(churn.probs)<br/>         1          2          3          4          5          6 <br/>0.32756804 0.77302887 0.56592677 0.20112771 0.05152568 0.15085976</span></pre><p id="e989" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们预测的<code class="fe ng nh ni mx b">Churn </code>变量是“是”或“否”，所以我们希望将这些概率转换成二元响应。</p><p id="3304" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不确定 R 是如何编码响应的，但是我可以使用<code class="fe ng nh ni mx b">contrasts</code>函数快速检查这一点。</p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="74aa" class="nb lm iq mx b gy nc nd l ne nf"># Looking at the response encoding<br/>contrasts(df$Churn)</span><span id="e7a7" class="nb lm iq mx b gy nj nd l ne nf">&gt; contrasts(df$Churn)<br/>    Yes<br/>No    0<br/>Yes   1</span></pre><p id="056a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">查看结果，我们可以看到<code class="fe ng nh ni mx b">Yes</code>正在使用<code class="fe ng nh ni mx b">1</code>进行编码。</p><p id="a0eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们知道了响应编码，我们可以将预测结果转换成<code class="fe ng nh ni mx b">Yes</code>和<code class="fe ng nh ni mx b">No</code>响应。</p><p id="ff2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将响应阈值设置为<code class="fe ng nh ni mx b">0.5</code>，因此如果预测概率高于<code class="fe ng nh ni mx b">0.5</code>，我们将把这个响应转换为<code class="fe ng nh ni mx b">Yes</code>。</p><p id="8a75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一步是将角色反应转换成<a class="ae kw" href="https://stats.idre.ucla.edu/r/modules/factor-variables/" rel="noopener ugc nofollow" target="_blank">因素类型</a>。这是为了使逻辑回归模型的编码是正确的。</p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="a14c" class="nb lm iq mx b gy nc nd l ne nf"># converting probabilities to "Yes" and "No" <br/>glm.pred = rep("No", length(churn.probs))<br/>glm.pred[churn.probs &gt; 0.5] = "Yes"<br/>glm.pred &lt;- as.factor(glm.pred)</span></pre><p id="7347" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">稍后我们将进一步了解阈值，所以不要担心我们为什么将它设置为<code class="fe ng nh ni mx b">0.5</code>。现在，我们将在这个例子中使用这个值。</p><p id="9e1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">进行预测的一个重要部分是评估和验证模型。</p><p id="fa2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们详细看看一些评估指标，并以一种更严格的模型验证方法结束，<a class="ae kw" href="https://machinelearningmastery.com/k-fold-cross-validation/" rel="noopener ugc nofollow" target="_blank"> k 倍交叉验证</a>。</p><h1 id="2a3a" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">评估模型</h1><p id="956b" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在我们做出预测之后，是时候评估我们的模型了。</p><p id="7163" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">快速做到这一点的一个很好的工具是使用 Caret 中的<code class="fe ng nh ni mx b">confusionMatrix</code>函数。</p><p id="94a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将输入我们的<code class="fe ng nh ni mx b">glm.pred</code>预测数组，以及来自<code class="fe ng nh ni mx b">test$Churn</code>的实际结果。</p><p id="1adf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们将使用<code class="fe ng nh ni mx b">positive=”Yes”</code>将正类指定为“Yes”。</p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="73a3" class="nb lm iq mx b gy nc nd l ne nf"># creating a confusion matrix<br/>confusionMatrix(glm.pred, test$Churn, positive = "Yes")</span><span id="5e0f" class="nb lm iq mx b gy nj nd l ne nf">&gt; confusionMatrix(glm.pred, test$Churn, positive = "Yes")<br/>Confusion Matrix and Statistics<br/><br/>          Reference<br/>Prediction   No  Yes<br/>       No  1165  205<br/>       Yes  128  262<br/>                                          <br/>               Accuracy : 0.8108          <br/>                 95% CI : (0.7917, 0.8288)<br/>    No Information Rate : 0.7347          <br/>    P-Value [Acc &gt; NIR] : 4.239e-14       <br/>                                          <br/>                  Kappa : 0.4877          <br/> Mcnemar's Test P-Value : 3.117e-05       <br/>                                          <br/>            Sensitivity : 0.5610          <br/>            Specificity : 0.9010          <br/>         Pos Pred Value : 0.6718          <br/>         Neg Pred Value : 0.8504          <br/>             Prevalence : 0.2653          <br/>         Detection Rate : 0.1489          <br/>   Detection Prevalence : 0.2216          <br/>      Balanced Accuracy : 0.7310          <br/>                                          <br/>       'Positive' Class : Yes</span></pre><p id="74f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个函数产生一个<a class="ae kw" href="https://www.dataschool.io/simple-guide-to-confusion-matrix-terminology/" rel="noopener ugc nofollow" target="_blank">混淆矩阵</a>，以及其他感兴趣的统计数据。</p><p id="0478" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">混淆矩阵显示了每个类别中有多少正确和不正确的预测。</p><p id="c2a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面快速浏览一下我们模型中的混淆矩阵:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/b65443ac554865486852d20e540c6ec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*f7_8-qyOh1hXC222.jpg"/></div></div></figure><p id="5547" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到，该模型正确预测了 1165 次“否”，而在实际回答为“是”的情况下，错误预测了 205 次“否”。</p><p id="dcd9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，当实际答案是“是”的时候，该模型正确地预测了“是”262 次。与此同时，它错误地预测了“是”，而实际的回答是“否”128 次。</p><p id="ed39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的总体准确率是 81%。一个简单的基线模型是预测多数类，在我们的例子中是“否”。</p><p id="88ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们只是预测多数类，我们的准确率将是 73%。测试集中有 1760 个观察值，1293 个是“否”。如果你用 1293 除以 1760，你就可以得到 73%的准确率。</p><p id="3b42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其他一些有用的指标是<a class="ae kw" href="https://en.wikipedia.org/wiki/Sensitivity_and_specificity" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">灵敏度</strong>和<strong class="ka ir">特异性</strong> </a>。由于我们的类别略有不平衡(约 73%=“否”，约 27%=“是”)，这些指标可能更有用。</p><p id="fdda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">灵敏度</strong>表示<strong class="ka ir">“真阳性”</strong>率。这是对我们预测正类的准确程度的度量，在我们的例子中是“是”。</p><p id="1468" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ng nh ni mx b">confusionMatrix</code>函数直接报告这个，但是如果你想自己计算，用“真阳性”除以“真阳性”和“假阴性”之和。这里有一个形象化的例子来说明这一点:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/e68f19cd65930bbd5e6be0018ff42788.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0YLvphNVzneuXDpR.jpg"/></div></div></figure><p id="fb42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个有用的指标是<strong class="ka ir">特异性</strong>，它表示<strong class="ka ir">“真阴性”</strong>率。这是对我们预测负类的准确度的一种衡量。这里有一个解释特异性的图像:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/9268eb70eef651ab64b9cb8c6ed1b952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xYXsjy3ZnQG4ppmc.jpg"/></div></div></figure><p id="954f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个有用的指标是受试者工作特征曲线下的面积，也称为 AUC。</p><p id="f4dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ROC 最初在第二次世界大战期间用于分析雷达信号，它是一张<strong class="ka ir">真阳性率与</strong>假阳性率的曲线图。</p><p id="11b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到我们最初的模型，我声明我将使用 0.5 作为做出“是”(或积极)预测的阈值。不过，我并没有很好的理由选择 0.5。</p><p id="2938" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ROC 是一个很好的工具，因为它绘制了阈值变化时 TPR 与 FPR 的关系。我们可以使用<a class="ae kw" href="https://cran.r-project.org/web/packages/ROCR/ROCR.pdf" rel="noopener ugc nofollow" target="_blank"> ROCR </a>库绘制 ROC 曲线。以下是完整的 R 代码:</p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="6f7d" class="nb lm iq mx b gy nc nd l ne nf">library(ROCR)<br/># need to create prediction object from ROCR<br/>pr &lt;- prediction(churn.probs, test$Churn)<br/><br/># plotting ROC curve<br/>prf &lt;- performance(pr, measure = "tpr", x.measure = "fpr")<br/>plot(prf)</span></pre><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/bab711471e97aceb550d521d24debd4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gdU4qJ20M49syvd8.jpeg"/></div></div></figure><p id="fa51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如前所述，另一个有用的指标是 ROC 曲线下的面积，称为<a class="ae kw" href="https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc" rel="noopener ugc nofollow" target="_blank"> AUC </a>。</p><p id="e45a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">AUC 可以取 0 到 1 之间的任何值，1 为最佳值。这是一种将 ROC 归结为一个数字来评估模型的简便方法。下面是评估我们模型的 R 代码:</p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="37cd" class="nb lm iq mx b gy nc nd l ne nf"># AUC value<br/>auc &lt;- performance(pr, measure = "auc")<br/>auc &lt;- auc@y.values[[1]]<br/>auc</span><span id="03f4" class="nb lm iq mx b gy nj nd l ne nf">&gt; auc<br/>[1] 0.8481338</span></pre><p id="d943" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的模型的 AUC 为 0.85，相当不错。如果我们只是随机猜测，我们的 ROC 将是一条 45 度线。这相当于 AUC 为 0.5。</p><p id="694a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们胜过随机猜测，所以我们知道我们的模型至少增加了一些价值！</p><h1 id="6a1d" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">k 倍交叉验证</h1><p id="3bd5" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">既然我们已经训练、测试和评估了我们的模型，让我们更严格地评估模型。</p><p id="123f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将数据集分为训练数据集和测试数据集，这是一种防止过度拟合的好方法。</p><p id="3fe7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个更好的方法是使用<a class="ae kw" href="http://statweb.stanford.edu/~tibs/sta306bfiles/cvwrong.pdf" rel="noopener ugc nofollow" target="_blank"> K 倍交叉验证</a>。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/59b98b92d9f52836e39964c3760de814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*74KaK-Hfpm4v2QN4.jpg"/></div></div></figure><p id="f7f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种模型验证技术中，我们通过指定一定数量的“折叠”将数据随机划分为测试集和训练集。在上面的例子中，折叠的数量是 k=4。</p><p id="ba6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们对每个折叠运行模型后，我们对每个折叠的评估指标进行平均。因此，如果我们使用 ROC 运行模型四次，我们将对四个 ROC 值进行平均。这是尝试和防止过度拟合模型的好方法。</p><p id="76a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">常用的折叠数是 10，所以我们将在数据中使用 10。我们还将重复这个过程 3 次，只是为了给我们的方法增加一点技术上的严谨性。以下是完整的 R 代码:</p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="d3e5" class="nb lm iq mx b gy nc nd l ne nf"># setting a seed for reproduceability<br/>set.seed(10)<br/><br/># changing the positive class to "Yes"<br/>df$Churn &lt;- as.character(df$Churn)<br/>df$Churn[df$Churn == "No"] &lt;- "Y"<br/>df$Churn[df$Churn == "Yes"] &lt;- "N"<br/>df$Churn[df$Churn == "Y"] &lt;- "Yes"<br/>df$Churn[df$Churn == "N"] &lt;- "No"<br/><br/># train control<br/>fitControl &lt;- trainControl(## 10-fold CV<br/>  method = "repeatedcv",<br/>  number = 10,<br/>  ## repeated 3 times<br/>  repeats = 3,<br/>  classProbs = TRUE,<br/>  summaryFunction = twoClassSummary)<br/><br/># logistic regression model<br/>logreg &lt;- train(Churn ~., df,<br/>                method = "glm",<br/>                family = "binomial",<br/>                trControl = fitControl,<br/>                metric = "ROC")<br/>logreg</span><span id="31d4" class="nb lm iq mx b gy nj nd l ne nf">&gt; logreg<br/>Generalized Linear Model <br/><br/>7043 samples<br/>  19 predictor<br/>   2 classes: 'No', 'Yes' <br/><br/>No pre-processing<br/>Resampling: Cross-Validated (10 fold, repeated 3 times) <br/>Summary of sample sizes: 6338, 6339, 6338, 6339, 6339, 6339, ... <br/>Resampling results:<br/><br/>  ROC        Sens       Spec   <br/>  0.8455546  0.5500297  0.89602</span></pre><p id="7b5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从使用<code class="fe ng nh ni mx b">trainControl</code>功能设置 k 倍 CV 开始。所有的输入都非常简单。正如我之前提到的，我们使用 10 次折叠，重复 3 次。</p><p id="2555" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来我们训练我们的模型。正如我们前面所做的，我们使用“glm”方法中的“<a class="ae kw" href="https://cran.r-project.org/web/packages/rstanarm/vignettes/binomial.html" rel="noopener ugc nofollow" target="_blank">二项式</a>”族。为了评估我们的模型，我们将使用“ROC”。该模型实际上是报告 AUC，但我们在<code class="fe ng nh ni mx b">train</code>函数中指定的方式是用<code class="fe ng nh ni mx b">metric=”ROC”</code>。</p><p id="87b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还会注意到，我在<code class="fe ng nh ni mx b">trainControl</code>函数的代码前将正类更改为“Yes”。我这样做是为了将敏感性和特异性与我们以前的结果进行比较。这只是函数中的一个小问题，所以不要纠结于此。</p><p id="1796" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果与我们以前得到的相似。</p><p id="3413" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和之前一样，我们的<strong class="ka ir"> AUC 是 0.85 </strong>。这在输出中报告为 ROC，但实际上是 AUC。</p><p id="0dc9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">真阳性率</strong>(敏感性)为<strong class="ka ir"> 0.55 </strong>，而<strong class="ka ir">真阴性率</strong>(特异性)为<strong class="ka ir"> 0.90 </strong>。</p><h1 id="7dda" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">业务影响</h1><p id="02c6" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">到目前为止，我们已经使用了<strong class="ka ir"> k 倍交叉验证</strong>和<strong class="ka ir">逻辑回归</strong>来预测客户流失。</p><p id="aaf3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经查看了有用的评估指标，如<strong class="ka ir"> AUC </strong>、<strong class="ka ir">灵敏度</strong>和<strong class="ka ir">特异性</strong>。</p><p id="b6a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很好，但现在怎么办？</p><p id="9e0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们去见首席执行官并单独展示这些结果，他或她会说<strong class="ka ir">“那又怎么样？”</strong></p><p id="4564" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们开发该模型的实际目标是展示<strong class="ka ir">业务影响</strong>。在我们的案例中，这将是<strong class="ka ir">成本节约</strong>。</p><p id="e4c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我一步一步地介绍一下我们如何节约成本。</p><p id="a5ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们对各种成本做一些假设。</p><p id="19cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们假设<strong class="ka ir">电信行业的客户获取成本</strong>约为<strong class="ka ir">300 美元</strong>。如果我们预测某个客户不会流失，但实际上他们会流失(假阴性，FN)，那么我们就必须出去花 300 美元为该客户找一个替代品。</p><p id="d86d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们假设获得一个新客户比留住一个现有客户要贵 5 倍。如果我们预测某个客户会流失，我们需要花费<strong class="ka ir">60 美元来留住那个客户</strong>。</p><p id="c319" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有时我们会正确地预测客户会流失(真阳性，TP)，有时我们会错误地预测客户会流失(假阳性，FP)。在这两种情况下，我们将花费 60 美元来留住客户。</p><p id="dcf8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，在这种情况下，我们正确地预测客户不会流失(真阴性，TN)。在这种情况下，我们不会花钱。这些是快乐的顾客，我们正确地将他们定义为快乐的顾客。</p><p id="0e7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里是成本的快速汇总:</p><ul class=""><li id="cbf1" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir"> FN </strong>(预测客户不会流失，但他们确实流失了):<strong class="ka ir"> $300 </strong></li><li id="374e" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir"> TP </strong>(预测客户会流失，而实际上他们会流失):<strong class="ka ir"> $60 </strong></li><li id="6aba" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir"> FP </strong>(预测客户会流失，而实际上他们不会):<strong class="ka ir"> $60 </strong></li><li id="68b6" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir"> TN </strong>(预测客户不会流失，而实际上他们不会):<strong class="ka ir"> $0 </strong></li></ul><p id="6015" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们将每种预测类型(FN、TP、FP 和 TN)的数量乘以与每种类型相关联的成本，并将它们相加，那么我们可以计算出与我们的模型相关联的总成本。这个等式是这样的:</p><p id="a8aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">成本= FN($ 300)+TP($ 60)+FP($ 60)+TN($ 0)</p><p id="60cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为一个例子，让我们假设我们对每一个做出如下数量的预测:</p><ul class=""><li id="40a1" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">FN = 10</li><li id="4729" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">TP = 5</li><li id="845d" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">FP = 5</li><li id="0bc5" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">TN = 5</li></ul><p id="7e5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么我们的总成本将是 3600 美元。</p><p id="0ee1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">10 *(300 美元)+5 *(60 美元)+5 *(60 美元)+5 *(0 美元)= <strong class="ka ir"> $3600 </strong></p><p id="fc35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们将这个成本评估应用到我们的模型中。</p><p id="baf3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将从拟合模型开始，并以概率的形式进行预测。</p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="f475" class="nb lm iq mx b gy nc nd l ne nf"># fitting the logistic regression model<br/>fit &lt;- glm(Churn~., data=train, family=binomial)<br/><br/># making predictions<br/>churn.probs &lt;- predict(fit, test, type="response")</span></pre><p id="b552" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，让我们创建一个阈值向量和一个成本向量。</p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="93cf" class="nb lm iq mx b gy nc nd l ne nf"># threshold vector<br/>thresh &lt;- seq(0.1,1.0, length = 10)<br/><br/>#cost vector<br/>cost = rep(0,length(thresh))</span></pre><p id="0470" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">阈值向量将保存每个模型的阈值。之前，我们只是使用 0.5 作为阈值，但让我们看看阈值在 0 和 1 之间的增量为 0.1(例如，0.1、0.2、0.3…0.9、1.0)。</p><p id="0e8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">成本向量将是长度为 10 的向量，以零开始。我们将在循环函数时填充它，并在循环过程中评估每个阈值。为了评估成本，我们将使用刚刚讨论过的相同成本等式。</p><p id="c329" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将创建一个 for 循环，使用各种阈值进行预测，并评估每个阈值的成本。</p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="702b" class="nb lm iq mx b gy nc nd l ne nf"># cost as a function of threshold<br/>for (i in 1:length(thresh)){<br/>  <br/>  glm.pred = rep("No", length(churn.probs))<br/>  glm.pred[churn.probs &gt; thresh[i]] = "Yes"<br/>  glm.pred &lt;- as.factor(glm.pred)<br/>  x &lt;- confusionMatrix(glm.pred, test$Churn, positive = "Yes")<br/>  TN &lt;- x$table[1]/1760<br/>  FP &lt;- x$table[2]/1760<br/>  FN &lt;- x$table[3]/1760<br/>  TP &lt;- x$table[4]/1760<br/>  cost[i] = FN*300 + TP*60 + FP*60 + TN*0<br/>}</span></pre><p id="82a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我没有使用 TN、FP、FN 和 TP 的每个结果的总数，而是使用了一个百分比。这就是为什么我用混淆矩阵取出每个值，然后除以 1760。</p><p id="98c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的测试集中有 1760 个观察值，这就是这个数字的来源。通过这样做，我正在计算每位顾客的成本。</p><p id="f80b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们假设我们的公司正在使用我们称之为<strong class="ka ir">“简单模型”</strong>，它只是默认为 0.5 的<strong class="ka ir">阈值。我们可以继续下去，拟合模型，进行预测，并计算成本。我们将这个模型称为<code class="fe ng nh ni mx b">cost_simple</code>。</strong></p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="3567" class="nb lm iq mx b gy nc nd l ne nf"># simple model - assume threshold is 0.5<br/>glm.pred = rep("No", length(churn.probs))<br/>glm.pred[churn.probs &gt; 0.5] = "Yes"<br/>glm.pred &lt;- as.factor(glm.pred)<br/><br/>x &lt;- confusionMatrix(glm.pred, test$Churn, positive = "Yes")<br/>TN &lt;- x$table[1]/1760<br/>FP &lt;- x$table[2]/1760<br/>FN &lt;- x$table[3]/1760<br/>TP &lt;- x$table[4]/1760<br/>cost_simple = FN*300 + TP*60 + FP*60 + TN*0</span></pre><p id="b281" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们可以把所有的结果放在一个数据框中，并把它们画出来。</p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="6dd5" class="nb lm iq mx b gy nc nd l ne nf"># putting results in a dataframe for plotting<br/>dat &lt;- data.frame(<br/>  model = c(rep("optimized",10),"simple"),<br/>  cost_per_customer = c(cost,cost_simple),<br/>  threshold = c(thresh,0.5)<br/>)<br/><br/># plotting<br/>ggplot(dat, aes(x = threshold, y = cost_per_customer, group = model, colour = model)) +<br/>  geom_line() +<br/>  geom_point()</span></pre><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/ca34b81754a6bc7014c5ccc160706083.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*voJQVHsR7ATrzQpX.jpg"/></div></div></figure><p id="606b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">查看结果，我们可以看到，在阈值为<strong class="ka ir"> 0.2 </strong>时，每位客户的<strong class="ka ir">最低成本约为<strong class="ka ir">40.00 美元</strong>。</strong></p><p id="7780" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我公司目前正在实施的<strong class="ka ir">【简单】模式</strong>每个客户的成本约为<strong class="ka ir"/>48.00 美元，门槛为<strong class="ka ir"> 0.50 </strong>。</p><p id="c1e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们假设我们有大约<strong class="ka ir"> 500，000 </strong>的客户群，从简单模型到优化模型的转换产生了 400 万美元的<strong class="ka ir">成本节约。</strong></p><pre class="mp mq mr ms gt mw mx my mz aw na bi"><span id="dfb5" class="nb lm iq mx b gy nc nd l ne nf"># cost savings of optimized model (threshold = 0.2) compared to baseline model (threshold = 0.5)<br/>savings_per_customer = cost_simple - min(cost)<br/><br/>total_savings = 500000*savings_per_customer<br/><br/>total_savings</span><span id="5b84" class="nb lm iq mx b gy nj nd l ne nf">&gt; total_savings<br/>[1] 4107955</span></pre><p id="e165" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据企业的规模，这种类型的成本节约可能会产生重大的业务影响。</p><h1 id="4e4f" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="6282" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在这篇文章中，我们开发了一个机器学习模型来预测<a class="ae kw" href="https://www.dataoptimal.com/churn-prediction-with-r/" rel="noopener ugc nofollow" target="_blank">客户流失</a>。</p><p id="a06e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">具体来说，我们完成了以下每个步骤:</p><ul class=""><li id="5fc8" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">工作经历</li><li id="4760" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">逻辑回归</li><li id="c464" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">准备数据</li><li id="2fc1" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">拟合模型</li><li id="4d73" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">做预测</li><li id="7332" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">业务影响</li></ul><p id="99b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们针对客户流失问题开发了一个<strong class="ka ir">优化的逻辑回归模型</strong>。</p><p id="3416" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设公司使用的逻辑回归模型的默认阈值为 0.5 ，我们能够确定最优阈值实际上是 0.2 。</p><p id="a664" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将每位客户的成本从<strong class="ka ir">48.00 美元</strong>降至<strong class="ka ir">40.00 美元</strong>。由于客户群约为<strong class="ka ir"> 50 万</strong>，这将产生每年 400 万美元的<strong class="ka ir">成本节约。这是一个重大的业务影响！</strong></p><p id="2c69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管这是一个纯粹假设的例子，但它与您在现实世界中遇到的情况非常相似。</p><p id="d36a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">能够有效地识别问题并展示真实的<strong class="ka ir">业务影响</strong>将使你在就业市场上从其他数据科学家中脱颖而出。</p><p id="5d5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">能够实现机器学习模型并对其进行评估是一回事。如果你能做到所有这些，并像我们在这篇文章中所做的那样，以商业影响的形式展示结果，那么你就能顺利找到工作了！</p></div></div>    
</body>
</html>