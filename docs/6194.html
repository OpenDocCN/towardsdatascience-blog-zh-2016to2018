<html>
<head>
<title>How to Flatten Deeply Nested JSON Objects in Non-Recursive Elegant Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在非递归优雅 Python 中展平深度嵌套的 JSON 对象</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-flatten-deeply-nested-json-objects-in-non-recursive-elegant-python-55f96533103d?source=collection_archive---------0-----------------------#2018-12-01">https://towardsdatascience.com/how-to-flatten-deeply-nested-json-objects-in-non-recursive-elegant-python-55f96533103d?source=collection_archive---------0-----------------------#2018-12-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="320a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用递归 python 解决方案来扁平化深度嵌套的 JSON 对象是很危险的。因为 python 解释器限制了堆栈的深度，以避免可能导致堆栈溢出的无限递归。从性能的角度来看，递归通常比迭代解决方案慢。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/f246f5a04c9aa4ec6025a57cd58f0e65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*ZZV6qxL3E25RDmKbV_ssRw.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">Deeply Nested “JSON”. Photo credit to <a class="ae la" href="https://en.wikipedia.org/wiki/Matryoshka_doll" rel="noopener ugc nofollow" target="_blank">wikipedia</a>.</figcaption></figure><p id="aba0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文的目的是分享一种使用 python 源代码和提供的示例来展平深度嵌套的 JSON 对象的迭代方法，这类似于迭代地将所有嵌套的 matryoshka 玩偶带到外面呼吸一些新鲜空气。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/2a4193592d3aed6f632eef65f5dcbf09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*WwAELFLfmRHuVq4OIUJptA.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">Photo credit to <a class="ae la" href="https://www.google.ca/imgres?imgurl=https%3A%2F%2Fae01.alicdn.com%2Fkf%2FHTB1Ur9qlZjI8KJjSsppq6xbyVXar%2F10pcs-Set-Wooden-Flower-Round-Stomach-Matryoshka-Doll-Nesting-Dolls-Craft-Gift-Home-Decor-Travel-Gift.jpg&amp;imgrefurl=http%3A%2F%2Fwww.wtresb.com%2Fyryazn-v123717-romklyadk%2F&amp;docid=sJ_fUZBlzFcy_M&amp;tbnid=w4q_TeAdee7kNM%3A&amp;vet=12ahUKEwjm8Nn009TeAhXL7IMKHfhsB0w4ZBAzKCswK3oECAEQLA..i&amp;w=800&amp;h=800&amp;itg=1&amp;bih=550&amp;biw=1018&amp;q=matryoshka%20doll%20nested&amp;ved=2ahUKEwjm8Nn009TeAhXL7IMKHfhsB0w4ZBAzKCswK3oECAEQLA&amp;iact=mrc&amp;uact=8" rel="noopener ugc nofollow" target="_blank">MagiDeal</a></figcaption></figure><h2 id="853b" class="lc ld it bd le lf lg dn lh li lj dp lk kb ll lm ln kf lo lp lq kj lr ls lt lu bi translated">简化 JSON 的传统递归 python 解决方案</h2><p id="07c1" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">下面的函数是递归展平 JSON 的一个例子。第 16 行和第 20 行的代码调用函数“flatten”来保持 JSON 对象中项的解包，直到所有值都是原子元素(没有字典或列表)。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="6fdb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下面的示例中，“pets”是两级嵌套的。键“dolphin”的值是一个字典列表。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mc"><img src="../Images/83097e929d0f5dad487797b97001f163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h_GFBl4md0I64Zcf4mVsVg.png"/></div></div></figure><p id="6954" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将展平后的结果加载到 pandas 数据框中，我们可以得到</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/f8515154b43fbf7d6eb2dd0f374078e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*KehE28HlLBewPjtIPdWJyA.png"/></div></figure><h2 id="bf41" class="lc ld it bd le lf lg dn lh li lj dp lk kb ll lm ln kf lo lp lq kj lr ls lt lu bi translated">使用迭代方法展平深度嵌套的 JSON</h2><p id="c11a" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">函数“flatten _ json _ iterative _ solution”用迭代的方法解决了嵌套的 JSON 问题。这个想法是，我们扫描 JSON 文件中的每个元素，如果元素是嵌套的，就只解包一层。我们不断迭代，直到所有的值都是原子元素(没有字典或列表)。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ma mb l"/></div></figure><ul class=""><li id="a996" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn mn mo mp mq bi translated"><a class="ae la" href="https://docs.python.org/3.7/library/itertools.html" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">第 27 行的 chain.from_iterable() </strong> </a>用于从单个可迭代参数中获取链式输入，即 chain.from_iterable(['ABC '，' DEF']) → A B C D E F</li><li id="ab53" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">第 27 行的<a class="ae la" href="https://docs.python.org/3.7/library/itertools.html" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> starmap() </strong> </a>用于创建一个迭代器，该迭代器使用从 dictionary.items()获得的参数来计算函数“unpack”</li></ul><p id="2d6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用新的迭代解决方案“flatten _ JSON _ iterative _ solution”，例如“pets”:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/74d7d16b965cad8ac81267009c5492ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*yWrH3r2U0htwbqxMWy1wrQ.png"/></div></figure><p id="1769" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用另一个示例“pets2”进行单元测试，该示例在键“dolphin”处嵌套了 3 层。一个 list <em class="mx"> [{ "鸟":"蓝鸟" }，{ "鱼":"海豚" }] </em>打包成 key "老虎"的值。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi my"><img src="../Images/810c14fe0a4cbc6ae9f096de3a58efb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LUk3-lvrpOWjDNouer2l8A.png"/></div></div></figure><p id="cd90" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我描述了一种用于展平深度嵌套的 JSON 对象的迭代解决方案。在实践中可以随意使用源代码。如果你有任何优化迭代解的想法，请给我发消息。</p><p id="b593" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">恭喜你！你刚刚读完一篇文章，同时解放了一些套娃。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="bc9b" class="ng ld it bd le nh ni nj lh nk nl nm lk nn no np ln nq nr ns lq nt nu nv lt nw bi translated">报名参加🦞:的 Udemy 课程</h1><h2 id="8dd1" class="lc ld it bd le lf lg dn lh li lj dp lk kb ll lm ln kf lo lp lq kj lr ls lt lu bi translated"><a class="ae la" href="https://www.udemy.com/course/recommender-system-with-machine-learning-and-statistics/?referralCode=178D030EF728F966D62D" rel="noopener ugc nofollow" target="_blank">具有机器学习和统计的推荐系统</a></h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nx"><img src="../Images/1bc21612997f8444fd0645e2051bfaf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rKOCPURU3yAr82_zvOXIJw.jpeg"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk"><a class="ae la" href="https://www.udemy.com/course/recommender-system-with-machine-learning-and-statistics/?referralCode=178D030EF728F966D62D" rel="noopener ugc nofollow" target="_blank">https://www.udemy.com/course/recommender-system-with-machine-learning-and-statistics/?referralCode=178D030EF728F966D62D</a></figcaption></figure></div></div>    
</body>
</html>