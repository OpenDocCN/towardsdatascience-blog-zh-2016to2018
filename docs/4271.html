<html>
<head>
<title>Python for data science : Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于数据科学的 Python:第 3 部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-for-data-science-part-3-be9b08660af9?source=collection_archive---------5-----------------------#2018-08-03">https://towardsdatascience.com/python-for-data-science-part-3-be9b08660af9?source=collection_archive---------5-----------------------#2018-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="75d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在“Python 用于数据科学”系列的前几部分中，我们研究了:</p><p id="7d0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" rel="noopener" target="_blank" href="/python-for-data-science-part-1-759524eb493b">第 1 部分</a>:Python 中的基本内置特性，如函数、数据类型、日期/时间、映射、归约、过滤、lambda 函数等。</p><p id="0971" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" rel="noopener" target="_blank" href="/python-for-data-science-part-2-373d6473fa40">第 2 部分</a>:用于创建、访问和操作数组的 Numpy 库</p><p id="ecdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将关注最广泛使用的数据分析库——Pandas。它的名字是怎么来的？熊猫这个名字来源于<strong class="jp ir">潘</strong>埃尔<strong class="jp ir">达</strong>塔。面板数据由对相同个体的多个时间段的观察组成。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/537d85762040cb5b2e78aedf7e5f6eaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/1*Z1FmUp4Eld97wnCgdq4MUQ.gif"/></div></figure><p id="0405" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Pandas 提供易于使用的数据结构和数据分析工具来创建和操作数据集。我们将会看到熊猫的以下特征:</p><ol class=""><li id="bae8" class="ku kv iq jp b jq jr ju jv jy kw kc kx kg ky kk kz la lb lc bi translated">系列和数据框架</li><li id="1c53" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">查询系列</li><li id="ebcb" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">读写文件</li><li id="2a2a" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">索引</li><li id="d200" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">合并</li><li id="53ff" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">聚集</li><li id="6851" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">过滤</li></ol><p id="2265" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和往常一样，第一步是导入库。让我们导入熊猫和 numpy 库。</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="3244" class="ln lo iq lj b gy lp lq l lr ls">import pandas as pd<br/>import numpy as np</span></pre><h1 id="7333" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">1.熊猫系列</h1><p id="09b4" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">系列是一维数据结构，可以保存任何数据类型，如整数和字符串。它类似于 Python 中的列表。</p><p id="1967" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们创建一个列表</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="7a8b" class="ln lo iq lj b gy lp lq l lr ls">name = ['Rohan','Joseph','Rohit']<br/>name</span></pre><p id="279d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mv">输出:['罗汉'，'约瑟夫'，'罗希特'] </em> </strong></p><p id="707a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们将同一个列表转换成熊猫系列。</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="225e" class="ln lo iq lj b gy lp lq l lr ls">name = pd.Series(name)<br/>name</span></pre><p id="8206" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mv">输出:</em> </strong></p><p id="f312" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mv"> 0 罗汉<br/> 1 约瑟夫<br/> 2 罗希特<br/>dtype:object</em>T22】</strong></p><p id="db66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以观察到熊猫系列显示了指数以及每个位置的值。同样，让我们创建一个字典，并将其转换为熊猫系列。</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="313d" class="ln lo iq lj b gy lp lq l lr ls">sport = {'cricket' : 'India',<br/>        'soccer' : 'UK',<br/>        'Football' : 'USA'}</span><span id="0574" class="ln lo iq lj b gy mw lq l lr ls">sport = pd.Series(sport)<br/>sport</span></pre><p id="2348" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mv">输出:</em> </strong></p><p id="174f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mv">板球印度<br/>足球英国<br/>足球美国<br/>d 类型:对象</em> </strong></p><p id="d99e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">字典的“键”成为序列中的索引，字典的“值”保持为序列的值。让我们通过查询一个熊猫系列来进一步理解这一点。</p><h1 id="f6ee" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">2.查询熊猫系列</h1><p id="e972" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">让我们继续上面创建的同一个系列“运动”。让我们访问系列中的第三个值</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="5f71" class="ln lo iq lj b gy lp lq l lr ls">sport.iloc[2]</span></pre><p id="71b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mv">输出:“美国”</em> </strong></p><p id="5a48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“iloc”用于根据值的整数位置选择值。现在，让我们使用值的索引来访问同一个值。</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="6752" class="ln lo iq lj b gy lp lq l lr ls">sport.loc['Football']</span></pre><p id="0069" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mv">输出:“美国”</em> </strong></p><p id="a748" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了，让我们把一系列的值加起来</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="4b41" class="ln lo iq lj b gy lp lq l lr ls">a = pd.Series([1,2,3])<br/>np.sum(a) #np sum function is a faster than the in-built function</span></pre><p id="35db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mv">输出:6 </em> </strong></p><p id="914f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">向现有系列添加数据。</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="90df" class="ln lo iq lj b gy lp lq l lr ls">a = pd.Series([1,2,3])<br/>a.loc[‘City’] = ‘Delhi’</span></pre><p id="1198" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mv">输出:</em> </strong></p><p id="2fb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">T51】0 1<br/>1 2<br/>2 3<br/>城市德里<br/>d 类型:对象 T57】</strong></p><p id="107d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们创建一个具有相同索引的多个值的序列。</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="9176" class="ln lo iq lj b gy lp lq l lr ls">b = pd.Series([‘a’,’b’,’c’,’d’],index=[‘e’,’e’,’e’,’e’])<br/>b</span></pre><p id="cdc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mv">输出:</em> </strong></p><p id="3ee2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"><em class="mv">e a<br/>e b<br/>e c<br/>e d<br/>d type:object</em></strong></p><h1 id="0aba" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">3.熊猫数据框</h1><p id="d41d" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">Dataframe 是具有不同数据类型(字符串、整数、日期等)的列的二维数据结构。).</p><p id="6553" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在熊猫中创建一个数据框架。我们正在创建一个包含三列的数据集——姓名、职业和年龄。</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="a409" class="ln lo iq lj b gy lp lq l lr ls">df1 = pd.DataFrame([{'Name' : 'John', 'Occupation' :  'Data Scientist', 'Age' : 25},{'Name' : 'David', 'Occupation' :  'Analyst', 'Age' : 28},{'Name' : 'Mark', 'Occupation' :  'Teacher', 'Age' : 30}],index=['1','2','3'] )</span><span id="b5e3" class="ln lo iq lj b gy mw lq l lr ls">df1</span></pre><p id="e865" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mv">输出:</em> </strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/1c9bba03810efd708089f11e09612552.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*M5Kwz6TiJ52IfRpg-p2q0A.png"/></div></figure><p id="6a5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们通过追加两个系列来创建一个数据帧。</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="411c" class="ln lo iq lj b gy lp lq l lr ls">s1 = pd.Series({'Name' : 'Rohan',<br/>                   'Age':'25'})<br/>s2 = pd.Series({'Name' : 'Rohit',<br/>                'Age' : 28})]<br/>df1 = pd.DataFrame([s1,s2],index=['1','2'])<br/>df1</span></pre><p id="c667" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mv">输出:</em> </strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/cba0bb419de2182c35c40d0b447f4200.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/format:webp/1*4eVE9twktjbhiyQoTq8I7A.png"/></div></figure><h1 id="18fb" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">4.读写文件</h1><p id="3709" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">让我们看看如何读取 csv 文件。</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="a32c" class="ln lo iq lj b gy lp lq l lr ls">iris = pd.read_csv('C:\\Users\\rohan\\Documents\\Analytics\\Data\\iris.csv')</span></pre><p id="8110" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看文件的前 5 行。</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="3045" class="ln lo iq lj b gy lp lq l lr ls">iris.head()</span></pre><p id="e7e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mv">输出:</em> </strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/40023851c4b65987c4123c6742f36b50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*vaI3s_M88c8-300gcJdQeA.png"/></div></figure><p id="4565" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将文件保存回本地目录。</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="1e13" class="ln lo iq lj b gy lp lq l lr ls">iris.to_csv('iris2.csv')</span></pre><h1 id="c3cb" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">5.索引数据帧</h1><p id="7c15" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">检查上一步导入的 iris 数据集的索引。</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="dd21" class="ln lo iq lj b gy lp lq l lr ls">iris.index.values</span></pre><p id="f6b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mv">输出:</em> </strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/69d170a3161d7a4592818953bc9d26a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mzeNsT902MaKj3-dXlPMww.png"/></div></div></figure><p id="740a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，将索引改为物种名称。“名称”列将显示为索引，并替换先前的索引。</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="0a3b" class="ln lo iq lj b gy lp lq l lr ls">b = iris.set_index('Name')<br/>b.head()</span></pre><p id="3e3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mv">输出:</em> </strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/e0f24a021cdf07d33f8ce1bac4d7c697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*QhzJnyYh4aGTC31dqU4GJQ.png"/></div></figure><p id="3d18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要恢复到以前的索引，只需按如下方式重置索引。</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="fccb" class="ln lo iq lj b gy lp lq l lr ls">c = b.reset_index()<br/>c.index.values</span></pre><p id="22c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">T29】输出:T31】</strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/7d1b54aa953d8e91893b5ae44ee83086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*3b3r97TmKKNQCS9YVOnZHA.png"/></div></figure><h1 id="172b" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">6.合并数据帧</h1><p id="1c3b" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">让我们再次导入虹膜数据，并将其与另一个数据集合并。</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="b6a5" class="ln lo iq lj b gy lp lq l lr ls">df1 = pd.read_csv('iris.csv')<br/>df1.head()</span></pre><p id="fbfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">T33】输出:T35】</strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/0f73f8f4234e067ecd09b3e4ef2e3c3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*H13r4-DdVYbkFHzLmiqSqw.png"/></div></figure><p id="1df2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个新的 dataframe 以与此合并。</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="615b" class="ln lo iq lj b gy lp lq l lr ls">df2 = pd.DataFrame([{'Name' : 'setosa', 'Species' : 'Species 1'},<br/>                  {'Name':'versicolor','Species':'Species 2'},<br/>                   {'Name':'virginica','Species':'Species 3'}])<br/>df2</span></pre><p id="44d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">T37】输出:T39】</strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/bcfce38e5e454a601899de4d9b8e15c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*Jc6sh1gKL1IQvyBhjGreyQ.png"/></div></figure><p id="47f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过执行一个<strong class="jp ir">内部连接</strong>，在名称列上合并上述两个数据集<strong class="jp ir">。</strong></p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="a319" class="ln lo iq lj b gy lp lq l lr ls">df3 = pd.merge(df1,df2,how='inner',left_on='Name',right_on='Name')<br/>df3.head()</span></pre><p id="27e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mv">输出:</em> </strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/7b251bd6c74f58ba7cd192aa5dd1ea45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*m0AFAr5yARwERStwvm6W5Q.png"/></div></figure><h1 id="1a4c" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">7.聚合函数</h1><p id="f527" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">让我们聚集 iris 数据集中的几列。首先，让我们找出每个物种的平均萼片长度。</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="bae9" class="ln lo iq lj b gy lp lq l lr ls">df1.groupby('Name')['SepalLength'].mean()</span></pre><p id="d0e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mv">输出:</em> </strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nk"><img src="../Images/dca1f1eed11e31426fd97e085e8e36af.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*Vqpn8Nz-riZBG_tna-sVzA.png"/></div></div></figure><p id="2a5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们按物种找出所有数字列的平均值。</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="f044" class="ln lo iq lj b gy lp lq l lr ls">df1.groupby('Name')[['SepalLength','SepalWidth','PetalLength','PetalWidth']].mean()</span></pre><p id="66d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出:输出:</strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/d0e5a31ea9ea44e22457452d3d47695a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*MdSQ61QfdcwN0MHTQ1vj0g.png"/></div></figure><p id="840e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而不是找到所有列的平均值；让我们对一列(萼片长度)取平均值，对另一列(萼片宽度)求和</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="070b" class="ln lo iq lj b gy lp lq l lr ls">a=df1.groupby('Name').agg({'SepalLength':'mean','SepalWidth':'sum'})<br/>a</span></pre><p id="b1bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出:输出:</strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/98c8e58718f80146acdaccfc77e7ad29.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*V9I1pAD5UvbB2pbydBp4YQ.png"/></div></figure><p id="a89a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们重命名这些列。</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="01bd" class="ln lo iq lj b gy lp lq l lr ls">a.rename(columns={'SepalLength':'Avg_SepalLength','SepalWidth':'Sum_SepalWidth'})</span></pre><p id="2094" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mv">输出:</em> </strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/e58792d3c0763d7daca68ea9cf006db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*4gBno3qwPPe6pTx9Ua1CZg.png"/></div></figure><h1 id="3a7a" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">8.过滤数据帧</h1><p id="4668" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">让我们再一次导入 iris 数据集，并执行操作来划分数据集的子集。首先，让我们对萼片长度大于 7 厘米的数据进行分组。</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="ab20" class="ln lo iq lj b gy lp lq l lr ls">iris = pd.read_csv(‘iris.csv’)  #import file<br/>a = iris[(iris.SepalLength&gt;7)]<br/>a.head()</span></pre><p id="6b5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mv">输出:</em> </strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/4f6a6094295e5b89881816baa4bd45f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*s3rfN43dNs8w_zoJu7fSEA.png"/></div></figure><p id="f140" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们根据两个条件对数据进行子集划分。</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="ccf3" class="ln lo iq lj b gy lp lq l lr ls">b = iris[(iris.SepalLength&gt;5) &amp; (iris.PetalLength&gt;6)]<br/>b.head()</span></pre><p id="dd74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mv">输出:</em> </strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/0fb78b121eca5900932f0424e3c60fdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*5gfPIwkzKzqkV4GtBGOemg.png"/></div></figure><p id="8eb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过对“名称”列进行筛选来对数据进行子集划分。</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="68c2" class="ln lo iq lj b gy lp lq l lr ls">c = iris[iris['Name']=='versicolor']<br/>c.head()</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/434c9e2d91aaa4a80d9229876f18fb7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*u_enuk1_qfgy1q7s3Y7H0g.png"/></div></figure><p id="a2b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再次过滤姓名列，但过滤两个姓名。</p><pre class="kn ko kp kq gt li lj lk ll aw lm bi"><span id="e1c6" class="ln lo iq lj b gy lp lq l lr ls">d = iris[iris['Name'].isin(['virginica','versicolor'])]<br/>d.head()</span></pre><p id="ab89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">T73】输出:T75】</strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/5a6c71c6bde051e2374d8fd0f78d2ab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*-Odm6NTPef0K4D5BLlvdGA.png"/></div></figure></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="171f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在这篇文章中看到的是在数据科学中使用的 Pandas 中最常用的功能，尽管还有更多功能值得了解，如广播、数据透视表、多索引和可视化。在本系列的下一部分中，我们将继续我们的旅程，看看我们如何将 Pandas 与其他功能结合起来操作数据。</p><p id="55ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kl" href="https://www.linkedin.com/feed/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上连接，并查看 Github(如下)以获得完整的笔记本。</p><div class="nz oa gp gr ob oc"><a href="https://github.com/rohanjoseph93/Python-for-data-science/blob/master/Python%20for%20Data%20Science%20-%20Part%203.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd ir gy z fp oh fr fs oi fu fw ip bi translated">rohanjoseph 93/用于数据科学的 Python</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">Python-for-data-science -用 Python 学习数据科学</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">github.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq ks oc"/></div></div></a></div></div></div>    
</body>
</html>