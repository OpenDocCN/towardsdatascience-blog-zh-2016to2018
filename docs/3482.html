<html>
<head>
<title>Feature Encoding Made Simple With Spark 2.3.0 — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spark 2.3.0 简化了特征编码—第 1 部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/feature-encoding-with-spark-2-3-0-part-1-9ede45562740?source=collection_archive---------4-----------------------#2018-05-16">https://towardsdatascience.com/feature-encoding-with-spark-2-3-0-part-1-9ede45562740?source=collection_archive---------4-----------------------#2018-05-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="8c44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ko">“每一次解码都是另一次编码”~戴维·洛奇</em>T3】</strong></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/13f85b0bfa6d94845f480cc050b46c4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M86nn3BvSSwEq65X6mLPBA.jpeg"/></div></div></figure><p id="a9f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如在<a class="ae lb" href="https://medium.com/@roshinijohri/spark-diaries-ad9eec6d9266" rel="noopener">之前的博客</a>中提到的，接下来的几篇博客将关注特性工程。机器学习项目中的许多工作都归结于此。不管我们喜不喜欢，我们都要花 95%的时间来生成特征向量，这将使我们的数据发挥最大作用。</p><p id="33e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Spark 为我们如何优化这一流程提供了很多余地。我将简要介绍一下我发现有用的编码类型，然后更详细地讨论使用大数据时可能会遇到的问题。出于这篇博文的目的，我假设您对 spark 函数及其数据类型有基本的了解。如果不是，为了合理的背景理解，请参考此<a class="ae lb" href="https://spark.apache.org/docs/latest/ml-features.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h2 id="7002" class="lc ld it bd le lf lg dn lh li lj dp lk kb ll lm ln kf lo lp lq kj lr ls lt lu bi translated"><strong class="ak">管道:</strong></h2><p id="5792" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">我将从管道开始，因为它使您的特性转换更加容易。管道背后的主要概念是结合复杂的算法和转换来创建工作流。假设您必须对一些分类特征进行热编码，并运行 xgboost 模型。您应该采取以下步骤。</p><ul class=""><li id="f063" class="ma mb it js b jt ju jx jy kb mc kf md kj me kn mf mg mh mi bi translated">索引类别特征</li><li id="0360" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">编码成一个热点向量</li><li id="5de1" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">集合成一个特征向量</li><li id="d492" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">火车模型</li></ul><p id="f2bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这四个步骤可以作为一系列管道阶段运行，以形成工作流。数据预处理部分将是一组适合输入数据帧的转换器(如 one hot 编码器)和估算器。可以按如下方式创建管道对象:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mo"><img src="../Images/98d80eee7588d5d598f10862c1ad5598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2y128hFa8yVXuvZVwt6NUg.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Note: the uid here “myPipeline” is optional</figcaption></figure><p id="29a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看如何包含阶段并使管道模型适合输入数据帧。我们可以使用 spark 中称为字符串索引器的一种特性索引方法来理解字符串索引器和管道。</p><h2 id="a8f7" class="lc ld it bd le lf lg dn lh li lj dp lk kb ll lm ln kf lo lp lq kj lr ls lt lu bi translated">字符串索引器:</h2><p id="2186" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">字符串索引器将一列字符串标签/类别编码为一列索引。索引的<strong class="js iu">排序是基于流行度</strong>完成的，范围是[0，numOfLabels。让我们举一个简单数据帧的玩具例子。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mt"><img src="../Images/61b49da37eebbf1c3cc5d8891e21bbdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b-x3aQdZyJZfHcXJdN3vlw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Toy Data Frame</figcaption></figure><p id="29f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要使用字符串索引器索引类别，您需要执行以下操作:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mu"><img src="../Images/dbff065fd40cc15f75bf05dc562c5b12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_BjF0_zPHPkj0ouX_7WvBA.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Transformed Dataframe</figcaption></figure><p id="a844" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意如何指定希望列输出被调用的名称。当您拥有包含大量需要编码的分类特征的大数据时，这非常有用。使用一点 scala 和 spark magic，这可以在几行代码中完成。让我们将另一列追加到我们的玩具数据帧中。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mv"><img src="../Images/4cd370268f7cc052af8faf0f848a13cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ob6UKjmSPjaYk_J7h1c4CA.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Toy Dataframe with a extra column</figcaption></figure><p id="f806" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，一点火花管道和 scala 魔术…</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mw"><img src="../Images/e090cd29fdc0f885d26e3edd7860b573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sQXG84fnExJUy6MTC0O_aw.png"/></div></div></figure><p id="f7b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并且如下所示的结果数据帧具有颜色和类别索引。整洁！这里的编码特征可以被设置为流水线阶段。然后，可以将其与输入数据进行拟合，以创建管道模型。我们使用这个模型将数据帧转换成如下所示的结果数据帧。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mx"><img src="../Images/641409afff43f2f8f6474870de2ef476.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-dNplwRJ8Bua6b-PLtMl9Q.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Note: You can retrieve the labels that were transformed by the string indexer by using the inverse called <a class="ae lb" href="https://people.apache.org/~pwendell/spark-nightly/spark-master-docs/latest/ml-features.html#indextostring" rel="noopener ugc nofollow" target="_blank">IndexToString</a>.</figcaption></figure><p id="afec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们在 spark 中探索更多的编码方法，并在我们的管道中添加更多的阶段！</p><h2 id="46a8" class="lc ld it bd le lf lg dn lh li lj dp lk kb ll lm ln kf lo lp lq kj lr ls lt lu bi translated">一个热编码器:</h2><p id="1387" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">一个 hot 编码器将标签索引映射到至多具有单个 1 值的二进制向量表示。当我们需要使用分类特征但算法期望连续特征时，通常使用这些方法。spark one hot 编码器从字符串索引器获取索引标签/类别，然后将其编码为稀疏向量。这与通常的虚拟列创建风格略有不同。让我们在上面的例子中添加一个热编码器，看看它是如何工作的。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi my"><img src="../Images/07cd31428242437266cd26d5ae4b37e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vZVif0X5iteiDwPczSedFg.png"/></div></div></figure><p id="2ec7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并且产生的数据帧…</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mz"><img src="../Images/7c8c7ebafe616252e2fb4374a188e60d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sOnaK2FfAxpwJEYSGvBy4g.png"/></div></div></figure><p id="b040" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这一点上，对于那些不熟悉 spark 中矢量类型的人，我想指出上面数据帧中看到的稀疏矢量有 4 个不同的组成部分。第一个为 0 的分量表示它是一个稀疏向量。第二部分是关于向量的大小。第三个组件讨论填充向量的索引，而第四个组件讨论这些索引是什么值。这将截断向量，当您有非常大的向量表示时非常有效。如果你想看到它的密集向量表示，很容易使用 udf 来转换它。类似这样的操作示例如下:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi na"><img src="../Images/2a6d630bb29d77d642030c3394f1175e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zw_Zs7moxg3UqxpDLYHZJQ.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Note: Spark has two vector types, org.apache.spark.mllib.linalg.Vector is also valid.</figcaption></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nb"><img src="../Images/2da323966165548815124abefcca9f62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s6J9vHkAvAnTg_jM6_KmVA.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Both sparse and dense representations for category_vec</figcaption></figure><p id="0bea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，我们已经讨论了管道、分类特性的一些索引和编码。我们现在有两个索引和编码的特征。spark 中的大多数机器学习算法都期望一个编码的数字向量作为输入。为了做到这一点，我们使用了一种叫做<a class="ae lb" href="https://people.apache.org/~pwendell/spark-nightly/spark-master-docs/latest/ml-features.html#vectorassembler" rel="noopener ugc nofollow" target="_blank">矢量汇编器的东西。</a></p><h2 id="f34c" class="lc ld it bd le lf lg dn lh li lj dp lk kb ll lm ln kf lo lp lq kj lr ls lt lu bi translated">向量汇编程序:</h2><p id="1c48" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated"><a class="ae lb" href="https://people.apache.org/~pwendell/spark-nightly/spark-master-docs/latest/ml-features.html#vectorassembler" rel="noopener ugc nofollow" target="_blank">矢量组装器</a>的工作是将原始特征和各种变换生成的特征组合成一个单一的特征矢量。它接受布尔型、数字型和矢量型输入。让我们修改前面的代码，将类别和颜色向量合并成一个特征向量。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nc"><img src="../Images/6abcd0e3f4bee26c76d944f420813891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y2Oq9qtYuXsESNgs5XclVg.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Adding vector assembler to get the final feature vector</figcaption></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nd"><img src="../Images/ec3379eee0069ffc9de2e16eaa70ab76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MxDBwZKgZJzSsoaELD5Wlw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Resulting data frame</figcaption></figure><p id="faf4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常，当您希望在训练模型或对模型评分之前组合所有功能时，Vector assembler 将始终出现在您的工作流中。spark 中也存在的一种转换是矢量索引器。</p><h2 id="d726" class="lc ld it bd le lf lg dn lh li lj dp lk kb ll lm ln kf lo lp lq kj lr ls lt lu bi translated">向量索引器:</h2><p id="89c6" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">在我们的例子中，向量索引器将让我们跳过对分类特征进行编码的一个热编码阶段。该算法基于特征值自动进行推断，并进行变换以获得最终的特征向量。我们可以改变上面的例子，添加向量索引器如下:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ne"><img src="../Images/9a0adb85ae7f637ba3e61e77837053c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BDTJqCxsb2JhXJK48fMQrQ.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Applying vector indexer to the string indexer’s output</figcaption></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nf"><img src="../Images/c20ad938b5c03863aaa2db51cc84df64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kc82IAdZz_EsAU6QYPVQJw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Feature is the output of the assembler but the categorical features are not encoded yet. The vector indexer will do this and produces indexed_features as the final feature vector</figcaption></figure><p id="d854" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以上几点评论。在不明显的情况下，直接使用字符串索引器的输出作为一个特征是没有意义的，因为如果苹果被索引为 1，而桔子被索引为 2，这可能被推断为苹果比桔子等级高，或者桔子比苹果大。这些都没有意义，因此我们不对它们进行编码。向量索引器做同样的事情，但是在后端。我通常更喜欢在自己的工作流程中直接使用 one hot 编码器。</p><p id="9261" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，我们只涉及了分类特性和一些关于管道和向量组装器的概念。在<a class="ae lb" rel="noopener" target="_blank" href="/feature-encoding-made-simple-with-spark-2-3-0-part-2-5bfc869a809a">第二部分</a>中，我将介绍一些数字特征编码的概念。我们还将涉及如何处理高基数分类特征。请随时提问或指出任何可能没有意义的事情。^_^</p><p id="eff3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ps:如果你喜欢，请鼓掌！让我知道它帮助了你！</p></div></div>    
</body>
</html>