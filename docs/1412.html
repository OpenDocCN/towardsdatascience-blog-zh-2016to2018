<html>
<head>
<title>Pairwise Sequence Alignment using Biopython</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Biopython的成对序列比对</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pairwise-sequence-alignment-using-biopython-d1a9d0ba861f?source=collection_archive---------0-----------------------#2017-09-02">https://towardsdatascience.com/pairwise-sequence-alignment-using-biopython-d1a9d0ba861f?source=collection_archive---------0-----------------------#2017-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bc63" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python生物信息学工具检查两个序列有多相似</h2></div><blockquote class="ki"><p id="4322" class="kj kk it bd kl km kn ko kp kq kr ks dk translated">两个序列有多相似？</p></blockquote><p id="fb6c" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln ks im bi translated">想要回答这个问题，你需要对<strong class="kv iu">序列比对</strong>有一个基本的了解。正如我在<a class="ae lo" href="https://medium.com/towards-data-science/dna-sequence-data-analysis-starting-off-in-bioinformatics-3dba4cea04f" rel="noopener">的上一篇文章</a>、<strong class="kv iu">序列比对</strong>中描述的，序列比对是一种排列DNA、RNA或蛋白质序列以识别相似区域的方法。被鉴定的相似性可能是序列之间的功能、结构或进化关系的结果。</p><p id="4263" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">在这篇文章中，我将带你完成<strong class="kv iu">两两序列比对</strong>。此外，我们将使用一个名为<strong class="kv iu"> Biopython </strong>的很酷的python工具尝试一些编码。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lu"><img src="../Images/a924d6253681a67b674c9fbe047aa011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MvF9NUzn54va1_TO8RMLoA.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Figure 1: Pairwise Sequence Alignment using Biopython</figcaption></figure><h1 id="ab61" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">什么是成对序列比对？</h1><p id="1e15" class="pw-post-body-paragraph kt ku it kv b kw nc ju ky kz nd jx lb lc ne le lf lg nf li lj lk ng lm ln ks im bi translated"><strong class="kv iu">成对序列比对</strong>是序列比对技术的一种形式，这里我们只比较<strong class="kv iu"> <em class="nh">两个序列</em> </strong>。这个过程包括找到两个序列之间的最佳比对，根据它们的相似性(它们有多相似)或距离(它们有多不同)进行评分，然后评估这个评分的显著性。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/68020681ef20e83a3151bb62035051ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*pPBmp7Uq8HgBTadPglJp4w.jpeg"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Figure 2: Image Scource: <a class="ae lo" href="http://compbio.pbworks.com/w/page/16252912/Pairwise%20Sequence%20Alignment" rel="noopener ugc nofollow" target="_blank">http://compbio.pbworks.com/w/page/16252912/Pairwise%20Sequence%20Alignment</a></figcaption></figure><h1 id="1cb8" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated"><strong class="ak">评分</strong></h1><p id="3a38" class="pw-post-body-paragraph kt ku it kv b kw nc ju ky kz nd jx lb lc ne le lf lg nf li lj lk ng lm ln ks im bi translated">在继续进行成对序列比对技术之前，让我们看一下评分过程。</p><p id="d2d4" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">序列比对的基础在于评分过程，在该过程中，根据两个序列彼此相似(或不同)的程度给它们打分。成对序列比对算法需要一个<strong class="kv iu">评分矩阵</strong>来记录分配的分数。评分矩阵为匹配分配一个正分，为不匹配分配一个罚分。</p><p id="9789" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">分配分数时考虑三个基本方面。他们是，</p><ol class=""><li id="54e3" class="nj nk it kv b kw lp kz lq lc nl lg nm lk nn ks no np nq nr bi translated"><strong class="kv iu">匹配值</strong> —分配给匹配字符的值</li><li id="281e" class="nj nk it kv b kw ns kz nt lc nu lg nv lk nw ks no np nq nr bi translated"><strong class="kv iu">不匹配值</strong> —分配给不匹配字符的值</li><li id="2408" class="nj nk it kv b kw ns kz nt lc nu lg nv lk nw ks no np nq nr bi translated"><strong class="kv iu">空位罚分</strong> —分配给空位的值</li></ol><p id="c09f" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">下面给出的图3显示了如何识别两个序列之间的匹配、错配和缺口。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/a74d8aef431f70e313fc63edc47c6ce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*2Wh0jTmRhXLcJQsHhirviw.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Figure 3: Match, mismatch and gap</figcaption></figure><p id="09b5" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">两个序列的第一个字符是匹配的<strong class="kv iu"/>，因为两个都是字母<strong class="kv iu"> A </strong>。第一个序列的第二个字符是<strong class="kv iu"> C </strong>，第二个序列的第二个字符是<strong class="kv iu"> T </strong>。所以，是<strong class="kv iu">不匹配</strong>。</p><p id="c7a1" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">在第二个序列的末尾引入一个空格以匹配g。这个空格被称为<strong class="kv iu">间隙</strong>。间隙是给定比对中单个序列中最大的连续空格。</p><p id="ec24" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">一般来说，缺口被表示为<strong class="kv iu">缺口罚函数</strong>，该函数将缺口的成本作为其长度的函数(可能是非线性的)来测量。</p><h1 id="2bf2" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">成对序列比对的类型</h1><p id="238e" class="pw-post-body-paragraph kt ku it kv b kw nc ju ky kz nd jx lb lc ne le lf lg nf li lj lk ng lm ln ks im bi translated">考虑给你两个序列如下。</p><pre class="lv lw lx ly gt ny nz oa ob aw oc bi"><span id="f5d8" class="od ml it nz b gy oe of l og oh"><strong class="nz iu"><em class="nh">X = x1 … xi … xn</em></strong></span><span id="12c4" class="od ml it nz b gy oi of l og oh"><strong class="nz iu"><em class="nh">Y = y1 … yj … ym</em></strong></span></pre><ol class=""><li id="b102" class="nj nk it kv b kw lp kz lq lc nl lg nm lk nn ks no np nq nr bi translated"><strong class="kv iu">全局比对</strong>:该方法在2个序列的整个长度上寻找最佳比对。序列<strong class="kv iu"> <em class="nh"> X </em> </strong>和<strong class="kv iu"> <em class="nh"> Y </em> </strong>的最大相似度是多少？</li><li id="1caf" class="nj nk it kv b kw ns kz nt lc nu lg nv lk nw ks no np nq nr bi translated"><strong class="kv iu">局部比对</strong>:该方法在两个序列中寻找最相似的子序列。<strong class="kv iu"> <em class="nh"> X </em> </strong>的一个子序列和<strong class="kv iu"> <em class="nh"> Y </em> </strong>的一个子序列的最大相似度是多少？</li></ol><h1 id="73a3" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">全球对齐</h1><p id="63fd" class="pw-post-body-paragraph kt ku it kv b kw nc ju ky kz nd jx lb lc ne le lf lg nf li lj lk ng lm ln ks im bi translated">在该方法中，我们考虑2个序列的整个长度，并尝试将它们匹配以获得最佳比对。将<strong class="kv iu"><em class="nh">gap</em></strong>(空格)插入到<em class="nh"> X </em>和<em class="nh"> Y </em>中，直到两个序列的长度相同，这样两个序列就匹配了。</p><p id="36f1" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">例如，考虑序列X = <strong class="kv iu"> ACGCTGAT </strong>和Y = <strong class="kv iu"> CAGCTAT </strong>。一种可能的全局对准是，</p><pre class="lv lw lx ly gt ny nz oa ob aw oc bi"><span id="19c6" class="od ml it nz b gy oe of l og oh"><strong class="nz iu">AC-GCTGAT<br/> | ||  ||<br/>-CAGC-TAT</strong></span></pre><p id="05cd" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">并不是说我们已经包含了<strong class="kv iu"> <em class="nh">间隙</em> </strong>以便字符串对齐。</p><p id="ea47" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">如果我们设置一个评分方案为<em class="nh">匹配分数= 1 </em>，<em class="nh">错配分数= 0 </em>，<em class="nh">空位罚分= 0 </em>，那么上述比对的总分数将为:</p><pre class="lv lw lx ly gt ny nz oa ob aw oc bi"><span id="8174" class="od ml it nz b gy oe of l og oh">Score = nMatch x 1 + nMismatch x 0 + nGap x 0<br/>      = 6x1 + 1x0 + 2x0<br/>      = 6</span></pre><h2 id="665b" class="od ml it bd mm oj ok dn mq ol om dp mu lc on oo mw lg op oq my lk or os na ot bi translated"><strong class="ak"> Needleman-Wunsch算法</strong></h2><p id="62b3" class="pw-post-body-paragraph kt ku it kv b kw nc ju ky kz nd jx lb lc ne le lf lg nf li lj lk ng lm ln ks im bi translated">使用动态编程获得全局比对的算法之一是<strong class="kv iu"> <em class="nh"> Needleman-Wunsch算法</em> </strong>。该算法由<strong class="kv iu"> Needleman </strong>和<strong class="kv iu"> Wunsch </strong>于1970年发表，用于两个蛋白质序列的比对，这是动态编程首次应用于生物序列分析。Needleman-Wunsch算法寻找两个序列之间的最佳得分全局比对。</p><h1 id="949e" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">局部对齐</h1><p id="03ca" class="pw-post-body-paragraph kt ku it kv b kw nc ju ky kz nd jx lb lc ne le lf lg nf li lj lk ng lm ln ks im bi translated">在这种方法中，我们考虑2个序列中每一个的子序列，并试图匹配它们以获得最佳比对。</p><p id="6d34" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">例如，将两个序列视为X=GGT <strong class="kv iu"> CTGAT </strong> G和Y=AAA <strong class="kv iu"> CGAT </strong> C。粗体字符是要考虑的子序列。最佳的局部对准是，</p><pre class="lv lw lx ly gt ny nz oa ob aw oc bi"><span id="8ddd" class="od ml it nz b gy oe of l og oh"><strong class="nz iu">CTGAT</strong> (in X)<br/><strong class="nz iu">| |||<br/>C-GAT</strong> (in Y)</span></pre><p id="a756" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">这里，引入一个<strong class="kv iu"> <em class="nh">缺口</em> </strong>以匹配2个子序列。</p><p id="7560" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">如果我们设置一个评分方案为<em class="nh">匹配分数= 1 </em>，<em class="nh">错配分数= 0 </em>，<em class="nh">空位罚分= 0 </em>，那么上述比对的总分数为:</p><pre class="lv lw lx ly gt ny nz oa ob aw oc bi"><span id="ff59" class="od ml it nz b gy oe of l og oh">Score = nMatch x 1 + nMismatch x 0 + nGap x 0<br/>      = 4x1 + 0x0 + 1x0<br/>      = 4</span></pre><h2 id="d0d7" class="od ml it bd mm oj ok dn mq ol om dp mu lc on oo mw lg op oq my lk or os na ot bi translated"><strong class="ak">史密斯-沃特曼算法</strong></h2><p id="7456" class="pw-post-body-paragraph kt ku it kv b kw nc ju ky kz nd jx lb lc ne le lf lg nf li lj lk ng lm ln ks im bi translated">使用动态编程在两个给定序列内获得局部比对的算法之一是<strong class="kv iu"> <em class="nh"> Smith-Waterman算法</em> </strong>。<strong class="kv iu"> Smith </strong>和<strong class="kv iu"> Waterman </strong>在1981年发表了一个动态规划的应用来寻找最优的局部排列。该算法类似于Needleman-Wunsch算法，但与评分过程略有不同。</p><p id="3027" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">在本文中，我们不会深入讨论上述两种算法的细节。</p><h1 id="2225" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">练习时间到了</h1><p id="0ecd" class="pw-post-body-paragraph kt ku it kv b kw nc ju ky kz nd jx lb lc ne le lf lg nf li lj lk ng lm ln ks im bi translated">既然我们有了关于成对序列比对的基本概念和两个有用的算法，现在是时候尝试一些编码了。</p><h2 id="c4b0" class="od ml it bd mm oj ok dn mq ol om dp mu lc on oo mw lg op oq my lk or os na ot bi translated">biopython——用于计算分子生物学的python工具</h2><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/691aab6e9baefe05944da5cd01057572.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*RUb8pD0g-kcNa8QHGIDQgw.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Figure 4: Biopython (<a class="ae lo" href="http://biopython.org" rel="noopener ugc nofollow" target="_blank">http://biopython.org</a>)</figcaption></figure><p id="46e5" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">在这篇文章中，我将向你介绍一套工具，我们将使用它来处理以后的生物数据。<a class="ae lo" href="http://biopython.org" rel="noopener ugc nofollow" target="_blank"> <strong class="kv iu"> Biopython </strong> </a>是一套用python编写的工具，可用于各种生物计算、模拟和分析。</p><p id="aab0" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">你可以从<a class="ae lo" href="http://biopython.org/wiki/Download" rel="noopener ugc nofollow" target="_blank"> <em class="nh">这里</em> </a>下载并安装Biopython。确保您已经安装了<a class="ae lo" href="http://www.python.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv iu"> Python 2.7、3.4、3.5或3.6 </strong> </a>。你可以参考<a class="ae lo" href="http://biopython.org/DIST/docs/tutorial/Tutorial.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kv iu"> Biopython教程和食谱</strong> </a>来进一步了解我们能做什么以及如何使用这些工具。</p><h2 id="3d2a" class="od ml it bd mm oj ok dn mq ol om dp mu lc on oo mw lg op oq my lk or os na ot bi translated"><strong class="ak">bio . pairwise 2-P</strong>使用动态编程进行空中序列比对</h2><p id="a657" class="pw-post-body-paragraph kt ku it kv b kw nc ju ky kz nd jx lb lc ne le lf lg nf li lj lk ng lm ln ks im bi translated">让我们试用一些编码来模拟使用Biopython的成对序列比对。我将成对使用<a class="ae lo" href="http://biopython.org/DIST/docs/api/Bio.pairwise2-module.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kv iu">模块，该模块可以在<strong class="kv iu"> Bio </strong>包中找到。该模块提供了<strong class="kv iu">比对函数</strong>来获得两个序列之间的全局和局部比对。</strong></a></p><p id="ab7e" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">对齐函数的名称遵循惯例；</p><pre class="lv lw lx ly gt ny nz oa ob aw oc bi"><span id="a083" class="od ml it nz b gy oe of l og oh"><strong class="nz iu">&lt;alignment type&gt;XX </strong></span></pre><p id="138e" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">其中<strong class="kv iu"> &lt;对准类型&gt; </strong>是<strong class="kv iu">全局</strong>或<strong class="kv iu">局部</strong>并且<strong class="kv iu"> XX </strong>是一个2字符代码，表示它所采用的参数。第一个字符表示匹配(和不匹配)的参数，第二个字符表示空位罚分的参数。</p><p id="35e4" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated"><strong class="kv iu">匹配参数</strong>为:</p><pre class="lv lw lx ly gt ny nz oa ob aw oc bi"><span id="c9bf" class="od ml it nz b gy oe of l og oh">CODE  DESCRIPTION<br/>x     No parameters. Identical characters have score of 1, else 0.<br/>m     A match score is the score of identical chars, else mismatch<br/>      score.<br/>d     A dictionary returns the score of any pair of characters.<br/>c     A callback function returns scores.</span></pre><p id="2d64" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated"><strong class="kv iu">间隙惩罚参数</strong>为:</p><pre class="lv lw lx ly gt ny nz oa ob aw oc bi"><span id="47c8" class="od ml it nz b gy oe of l og oh">CODE  DESCRIPTION<br/>x     No gap penalties.<br/>s     Same open and extend gap penalties for both sequences.<br/>d     The sequences have different open and extend gap penalties.<br/>c     A callback function returns the gap penalties.</span></pre><p id="d3bb" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">让我们使用<strong class="kv iu"> <em class="nh"> Bio.pairwise2 </em> </strong>模块尝试几个成对序列比对的例子。</p><h2 id="1fb3" class="od ml it bd mm oj ok dn mq ol om dp mu lc on oo mw lg op oq my lk or os na ot bi translated">示例1</h2><p id="70c4" class="pw-post-body-paragraph kt ku it kv b kw nc ju ky kz nd jx lb lc ne le lf lg nf li lj lk ng lm ln ks im bi translated">考虑下面给出的两个序列。我们想找出所有可能的具有最大相似性得分的<strong class="kv iu">全局比对</strong>。</p><pre class="lv lw lx ly gt ny nz oa ob aw oc bi"><span id="20b5" class="od ml it nz b gy oe of l og oh"><strong class="nz iu">X = ACGGGT<br/>Y = ACG</strong></span></pre><p id="0a2f" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">下面给出了获得给定两个序列的全局比对的python代码。请注意我们是如何使用<strong class="kv iu"> <em class="nh"> Bio.pairwise2 </em> </strong>模块及其功能的。</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="ov ow l"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Code Snippet 1: Pairwise sequence alignment (global)</figcaption></figure><p id="2adb" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">通过运行代码，我们可以得到所有可能的全局比对，如图5所示。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi ox"><img src="../Images/1f422be3ca7d4e113f9993f84d63e205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EIn7QrQ5k1BEoNL0sVlpHw.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Figure 5: Pairwise sequence alignment (global) output</figcaption></figure><p id="f204" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">在这个例子中，注意匹配的字符被给予1分。没有因不匹配或差距而扣分。</p><h2 id="dbd8" class="od ml it bd mm oj ok dn mq ol om dp mu lc on oo mw lg op oq my lk or os na ot bi translated">示例2</h2><p id="9622" class="pw-post-body-paragraph kt ku it kv b kw nc ju ky kz nd jx lb lc ne le lf lg nf li lj lk ng lm ln ks im bi translated">考虑前面例子中给出的两个序列。我们想要找出所有可能的具有最大相似性得分的<strong class="kv iu">局部比对</strong>。</p><p id="5062" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">下面给出了获得给定两个序列的局部比对的python代码。</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="ov ow l"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Code Snippet 2: Pairwise sequence alignment (local)</figcaption></figure><p id="2dc8" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">通过运行代码，我们可以得到所有可能的局部比对，如图6所示。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi oy"><img src="../Images/d13d493943787615e6d850f6cae2a8d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pN88e3e9tYq8axSIzyPpbQ.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Figure 6: Pairwise sequence alignment (local) output</figcaption></figure><p id="05d2" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">在这个例子中，注意匹配的字符被给予1分。没有因不匹配或差距而扣分。</p><h2 id="25a3" class="od ml it bd mm oj ok dn mq ol om dp mu lc on oo mw lg op oq my lk or os na ot bi translated">示例3</h2><p id="65fb" class="pw-post-body-paragraph kt ku it kv b kw nc ju ky kz nd jx lb lc ne le lf lg nf li lj lk ng lm ln ks im bi translated">在本例中，我们将更改评分方案，并为匹配、不匹配和差距赋值。我们将考虑和以前一样的两个序列。我们想找出所有可能的具有最大相似性得分的<strong class="kv iu">全局比对</strong>。</p><p id="7e10" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">匹配字符得2分，每不匹配一个字符扣1分。开一个缺口扣0.5分，延伸一个缺口扣0.1分。</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="ov ow l"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Code Snippet 3: Pairwise sequence alignment (global with custom scoring)</figcaption></figure><p id="0cc0" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">通过运行代码，我们可以得到所有可能的全局比对，如图7所示。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi oy"><img src="../Images/9b595721ff0c1b5932fda361de1eb5d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m0kC9UeotkqLbyfJgmhDMQ.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Figure 7: Pairwise sequence alignment (global with custom scoring) output</figcaption></figure></div><div class="ab cl oz pa hx pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="im in io ip iq"><p id="d7b3" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">希望你喜欢读这篇文章，并学到一些有用和有趣的东西。</p><p id="6880" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">因为我对这个领域还很陌生，所以我想听听你的建议。😇</p><p id="679a" class="pw-post-body-paragraph kt ku it kv b kw lp ju ky kz lq jx lb lc lr le lf lg ls li lj lk lt lm ln ks im bi translated">感谢阅读…😃</p></div></div>    
</body>
</html>