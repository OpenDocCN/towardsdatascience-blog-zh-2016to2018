<html>
<head>
<title>Cutting the Cord: Predicting Customer Churn for a Telecom Company</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">切断绳索:预测电信公司的客户流失</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/cutting-the-cord-predicting-customer-churn-for-a-telecom-company-268e65f177a5?source=collection_archive---------12-----------------------#2018-11-02">https://towardsdatascience.com/cutting-the-cord-predicting-customer-churn-for-a-telecom-company-268e65f177a5?source=collection_archive---------12-----------------------#2018-11-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5645e4c0387265fe423e2e13e9c2a625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qjPKnMibxxX98BbQ8FWO2A.png"/></div></div></figure><p id="8f40" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这里找到 Github 项目库中的<a class="ae kw" href="https://github.com/athena15/project_mcnulty" rel="noopener ugc nofollow" target="_blank">代码，或者在这里</a>查看<a class="ae kw" href="https://docs.google.com/presentation/d/11sF4lvK3YN3HboN2kcaCh0DWFBSYYQvWvHPWNumpTps/edit?usp=sharing" rel="noopener ugc nofollow" target="_blank">的最终演示幻灯片。</a></p><h1 id="986d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">为什么要研究客户流失？</h1><p id="c084" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">客户流失是大多数企业面临的最大问题之一。<a class="ae kw" href="https://hbr.org/2014/10/the-value-of-keeping-the-right-customers" rel="noopener ugc nofollow" target="_blank">根据哈佛商业评论</a>，<strong class="ka ir">发现一个新客户的成本是留住一个现有客户的 5 到 25 倍</strong>。换句话说，你现有的客户价值连城！</p><p id="070e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">防止客户流失是一项重要的业务职能。这也是一个经常用漫无目的的、粗略的方法来处理的问题。通过建立一个模型，用机器学习算法预测客户流失，理想情况下，我们可以将不满意的客户问题扼杀在萌芽状态，并保持收入流动。</p><h1 id="8bfe" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">背景</h1><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/041bbd46f8de95590b9dc65e713a5e99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*351NhpSQAd5R13I6Lb7WEg.jpeg"/></div></div></figure><p id="5d50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用了来自 Kaggle.com 的<a class="ae kw" href="https://www.kaggle.com/blastchar/telco-customer-churn" rel="noopener ugc nofollow" target="_blank">数据集，其中包括一家名为 Telco 的电信公司的 7033 条独特的客户记录。每个条目都有关于客户的信息，包括以下特征:</a></p><blockquote class="mf mg mh"><p id="3222" class="jy jz mi ka b kb kc kd ke kf kg kh ki mj kk kl km mk ko kp kq ml ks kt ku kv ij bi translated">服务—客户订购的服务(互联网、电话、有线电视等。)</p><p id="64ca" class="jy jz mi ka b kb kc kd ke kf kg kh ki mj kk kl km mk ko kp kq ml ks kt ku kv ij bi translated">每月账单总额</p><p id="dfa5" class="jy jz mi ka b kb kc kd ke kf kg kh ki mj kk kl km mk ko kp kq ml ks kt ku kv ij bi translated">任期——他们成为客户多长时间了</p><p id="0f7a" class="jy jz mi ka b kb kc kd ke kf kg kh ki mj kk kl km mk ko kp kq ml ks kt ku kv ij bi translated">基本的人口统计信息——他们是否是老年人，是否有家属，等等。</p></blockquote><p id="cbb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的研究中，因变量是客户在过去一个月中是否有过“<strong class="ka ir">搅动</strong>”。事实上，我们有整整 27%的客户被贴上了上个月离开公司的标签。随着流失率如此之高，如果我们不干预，公司失去大部分客户只是几个月的事情。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/be731dadfb956db59812f77f0b4687a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sTBlmz5hsAiHRlPO"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Churn!</figcaption></figure><h1 id="7b6f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">假设</h1><p id="31d3" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">出于我们分析的目的，我们做了两个假设:</p><ol class=""><li id="fc66" class="mq mr iq ka b kb kc kf kg kj ms kn mt kr mu kv mv mw mx my bi translated"><strong class="ka ir">对于每个离开公司的客户，电信公司需要花费 500 美元来替换该客户。</strong>营销、广告、活动和外展——成本不断增加。</li><li id="f120" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">我们可以通过投资 100 美元留住每个可能流失的客户。这可以通过折扣、改善服务(例如提升网速)或提供额外津贴来实现。</li></ol><h1 id="dd1c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">树立标杆</h1><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/f578a8b43f07e9c24b93cb4012e44f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pAJ2XWzHhAUfFfWxkVxPkA.jpeg"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Let’s make our model better.</figcaption></figure><p id="1336" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了宣告胜利，我们需要知道成功是什么样子的！我们成功的主要衡量标准是我们的模型相对于默认的虚拟模型的表现如何。请将此视为“维持现状”选项。因为我们知道花 100 美元留住一个客户从长远来看会为我们节省 500 美元——但是我们不知道哪些客户可能会流失——<strong class="ka ir">我们默认的“虚拟”模式就是在我们所有的<em class="mi">客户身上花 100 美元，以确保我们抓住那些流失的客户。</em></strong>这是我们想要击败的模式。</p><h1 id="146f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">方法学</h1><p id="9d3d" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">对于我们的模型，我们首先查看了几种不同的机器学习算法，以确定应该使用哪种算法。我们的第一步是<strong class="ka ir">使用训练-测试-分割将我们的数据分割成训练集和测试集</strong>，这将允许我们稍后交叉验证我们的结果。<strong class="ka ir">我们还对训练-测试-分割进行了分层，</strong>以确保我们的目标变量在训练和测试集中的比例相同。</p><pre class="mb mc md me gt nf ng nh ni aw nj bi"><span id="c058" class="nk ky iq ng b gy nl nm l nn no"># Stratify our train-test-split so that we have a balanced split<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=40, stratify=y)</span></pre><p id="8c9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还使用了一些<strong class="ka ir">少数过采样</strong>来平衡我们的数据集。由于我们数据库中只有大约 27%的记录被标记为“搅动的”，在没有过采样的情况下将我们的数据输入我们的算法会导致它对我们的目标变量分类不足。我们使用<strong class="ka ir"> imblearn 的 SMOTE 使我们的少数民族类达到数据集的 50% </strong>。</p><pre class="mb mc md me gt nf ng nh ni aw nj bi"><span id="908f" class="nk ky iq ng b gy nl nm l nn no">sm = SMOTE(random_state=42, ratio=1.0)<br/>X_train_res, y_train_res = sm.fit_sample(X_train, y_train)</span></pre><p id="0ec7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们的数据已经平衡了，我们接着执行<strong class="ka ir">另一个训练测试分割</strong>——这一次只是在我们的训练数据上。这样做的原因是为了不违反交叉验证的基本原则——根据测试数据提供的结果做决定。</p><pre class="mb mc md me gt nf ng nh ni aw nj bi"><span id="7598" class="nk ky iq ng b gy nl nm l nn no">X_train_2, X_test_2, y_train_2, y_test_2 = train_test_split(X_train_res, y_train_res, test_size=0.33, random_state=20)</span></pre><p id="614b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在所有这些辉煌的数据管理之后，我们绘制了一条 ROC 曲线，以比较每个算法在识别真阳性(灵敏度)和假阳性(特异性)方面的表现。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/8d288826dce15f0b9d8487a5e3e1fe28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q7JiIJkMQAPj3xIK"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">The ROC Curve, in all its glory.</figcaption></figure><p id="d5f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基于这个图，我们决定用 4 个主要的分类模型前进:逻辑回归、梯度推进、随机森林和 AdaBoost。我们着手调整这些模型，以充分利用它们。</p><p id="7b0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的分析，<strong class="ka ir">召回是我们的目标指标</strong>。我们最关心的是用我们的模型捕捉尽可能多的<em class="mi">真阳性</em>(可能流失的人)，我们不太关心我们可能会把一些<em class="mi">假阴性</em>(没有流失的人)一起扫进去。</p><p id="270e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">了解了这一点，我们然后使用 Sci-Kit Learn 的 GridSearchCV 函数，它允许我们调整我们的模型。我们将召回率设置为优化的评分标准，然后使用不同超参数的组合来找到最适合的模型。我们的目标是从我们的模型中挤出最后一点召回，不能少！</p><pre class="mb mc md me gt nf ng nh ni aw nj bi"><span id="8f30" class="nk ky iq ng b gy nl nm l nn no">pipe = Pipeline([('scaler', StandardScaler()),<br/>                 ('clf', RandomForestClassifier())])<br/>​<br/>param_grid = [{'clf__max_depth': [4, 5, 6],<br/>               'clf__max_features': [5, 10, 15, 20],<br/>               'clf__n_estimators': [50, 100, 150]}]<br/>​<br/>gs = GridSearchCV(pipe, param_grid, cv=5, n_jobs=-1, scoring='recall')<br/>gs.fit(X_train_res, y_train_res)</span></pre><p id="6b69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GridSearchCV 还包括一个方便的交叉验证功能(这就是 CV 的含义！)，所以我们在每个模型的新参数通道上执行<strong class="ka ir">分层 K 折交叉验证</strong>。不用说，我们在试图避免过度拟合我们的模型时非常仔细。</p><p id="d7f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们分析的很大一部分与创建一个<strong class="ka ir">“节省的净美元”函数</strong>有关，该函数将确定我们在留住客户上花了多少钱，而不是因为不必替换他们而节省了多少钱。这和回忆一起，构成了我们判断是否有一个成功模型的决策标准。</p><h1 id="21b8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结果</h1><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/bd53d0b6f6bef3ab6e04389156151360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M8Vv0nxGxhcHgEm7hSNCAw.jpeg"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">All of our models performed well.</figcaption></figure><p id="75e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">调整了我们的模型后，结果是 3 个模型并驾齐驱。<strong class="ka ir">我们的最后一步是调整每个模型的概率阈值(在 i = .01 和 i = 1 之间)。</strong>这让我们能够优化“节省的净美元”功能。本质上，对于每个概率阈值<em class="mi"> i </em>，我们要求我们的模型预测客户是否会流失——即使是非常低和非常高的 I 值。当然，当<em class="mi"> i </em>接近 0 时，我们的模型基本上会预测<em class="mi">每个人</em>都会流失——相反，当它接近 1 时，没有人会流失。通过绘制这个函数，我们能够看到优化我们的“净节省美元”函数的确切概率。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/469144aa6ca010f3104b7d09e3967402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7-R61YZpN_H5CPQJOaegUw.jpeg"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Making money by keeping customers.</figcaption></figure><p id="895e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最终，<strong class="ka ir">Logistic 回归模型胜出。</strong>它显示了 81%的出色召回率，并且<strong class="ka ir">最大化了我们的“净节省美元”功能。总的来说，我们的模型为我们节省了 272，200 美元，轻松击败了“现状”模型。这种模式只节省了(微不足道的)16.2 万美元。</strong></p><p id="9e70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读！如果你喜欢这个帖子，<a class="ae kw" href="https://www.linkedin.com/in/brennerheintz/" rel="noopener ugc nofollow" target="_blank">在 LinkedIn 上找到我</a>，在 Medium 上给我鼓掌，或者<a class="ae kw" href="mailto:brenner.heintz@gmail.com" rel="noopener ugc nofollow" target="_blank">在这里给我发电子邮件</a>。向前向上，朋友们！</p></div></div>    
</body>
</html>