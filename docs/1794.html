<html>
<head>
<title>Introduction to the Telegram API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">电报 API 简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-the-telegram-api-b0cd220dbed2?source=collection_archive---------0-----------------------#2017-10-24">https://towardsdatascience.com/introduction-to-the-telegram-api-b0cd220dbed2?source=collection_archive---------0-----------------------#2017-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9ccc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用程序分析你的电报通话记录</h2></div><p id="12b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di"> T </span> <a class="ae lk" href="https://telegram.org/" rel="noopener ugc nofollow" target="_blank"> elegram </a>是一种即时通讯服务，就像 WhatsApp、Facebook Messenger 和微信一样。近年来，它因为各种原因而广受欢迎:它的非盈利性质、跨平台支持、安全承诺<a class="ae lk" href="#ed69" rel="noopener ugc nofollow"> </a>，以及它的<a class="ae lk" href="https://core.telegram.org/api" rel="noopener ugc nofollow" target="_blank">开放 API</a>。</p><p id="c223" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将使用<a class="ae lk" href="https://github.com/LonamiWebs/Telethon" rel="noopener ugc nofollow" target="_blank"> Telethon </a>，一个用于 Telegram API 的 Python 客户端库，来统计我们每个 Telegram 聊天中的消息数量。</p><h1 id="9975" class="ll lm iq bd ln lo lp lq lr ls lt lu lv jw lw jx lx jz ly ka lz kc ma kd mb mc bi translated">电报 API</h1><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/98d88b2a8ad1f758e2c5294566c1fef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wPLlcEtOC5gybWVdy1DxQg.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">“ <strong class="bd mt">Telegram</strong> has an open <a class="ae lk" href="https://core.telegram.org/api" rel="noopener ugc nofollow" target="_blank">API</a> and <a class="ae lk" href="https://core.telegram.org/mtproto" rel="noopener ugc nofollow" target="_blank">protocol</a> free for everyone.” — Telegram homepage</figcaption></figure><p id="ed19" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Telegram 的 API 中最著名的是它的 Bot API，这是一个基于 HTTP 的 API，供开发人员与 Bot 平台进行交互。Bot API 允许开发者控制电报机器人，例如接收消息和回复其他用户。</p><p id="324f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了 Bot API，还有 Telegram API 本身。这是 Telegram 应用程序使用的 API，用于您在 Telegram 上的所有操作。仅举几个例子:查看您的聊天记录、发送和接收消息、更改您的显示图片或创建新群组。通过 Telegram API，你可以用编程的方式做你在 Telegram 应用程序中能做的任何事情。</p><p id="641d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Telegram API 比 Bot API 复杂得多。您可以使用标准 JSON、表单或查询字符串有效负载通过 HTTP 请求访问 Bot API，而 Telegram API 使用自己的自定义有效负载格式和加密协议。</p><h1 id="df56" class="ll lm iq bd ln lo lp lq lr ls lt lu lv jw lw jx lx jz ly ka lz kc ma kd mb mc bi translated">电报 API</h1><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mu"><img src="../Images/c844102523a367a940a99993801361b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ap61JFvLyGJFkV6S."/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Diagram for MTProto server-client flow</figcaption></figure><p id="7b6f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">MTProto 是定制的加密方案，支持 Telegram 的安全承诺。它是一种应用层协议，直接写入底层传输流，如 TCP 或 UDP，以及 HTTP。幸运的是，在使用客户端库时，我们不需要直接关心它。另一方面，为了进行 API 调用，我们确实需要理解有效载荷的格式。</p><h2 id="8dd9" class="mv lm iq bd ln mw mx dn lr my mz dp lv ko na nb lx ks nc nd lz kw ne nf mb ng bi translated">类型语言</h2><p id="10b6" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">Telegram API 是基于 RPC 的，因此与 API 的交互包括发送表示函数调用的有效载荷和接收结果。例如，读取一个对话的内容包括用必要的参数调用<code class="fe nm nn no np b">messages.getMessage</code>函数，并接收一个<code class="fe nm nn no np b">messages.Messages</code>作为返回。</p><p id="053a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类型语言或 TL 用于表示 API 使用的类型和函数。TL 模式是可用类型和函数的集合。在 MTProto 中，TL 构造在作为 MTProto 消息的有效载荷嵌入之前将被<a class="ae lk" href="https://core.telegram.org/mtproto/serialize" rel="noopener ugc nofollow" target="_blank">序列化为二进制形式</a>，但是我们可以将此留给我们将使用的客户端库。</p><p id="58dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个 TL 模式的例子(首先声明类型，然后声明函数，函数之间用分隔符隔开):</p><pre class="me mf mg mh gt nq np nr ns aw nt bi"><span id="42ef" class="mv lm iq np b gy nu nv l nw nx">auth.sentCode#efed51d9 phone_registered:Bool phone_code_hash:string send_call_timeout:int is_password:Bool = auth.SentCode;</span><span id="af9b" class="mv lm iq np b gy ny nv l nw nx">auth.sentAppCode#e325edcf phone_registered:Bool phone_code_hash:string send_call_timeout:int is_password:Bool = auth.SentCode;</span><span id="41f3" class="mv lm iq np b gy ny nv l nw nx">---functions---</span><span id="c12b" class="mv lm iq np b gy ny nv l nw nx">auth.sendCode#768d5f4d phone_number:string sms_type:int api_id:int api_hash:string lang_code:string = auth.SentCode;</span></pre><p id="bc80" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用上述 TL 模式中的函数和类型的 TL 函数调用和结果，以及等效的二进制表示(来自<a class="ae lk" href="https://core.telegram.org/method/auth.sendCode" rel="noopener ugc nofollow" target="_blank">官方文档</a>):</p><pre class="me mf mg mh gt nq np nr ns aw nt bi"><span id="eacd" class="mv lm iq np b gy nu nv l nw nx">(auth.sendCode "79991234567" 1 32 "test-hash" "en")<br/>=<br/>(auth.sentCode<br/>  phone_registered:(boolFalse)<br/>  phone_code_hash:"2dc02d2cda9e615c84"<br/>)<br/><br/>d16ff372 3939370b 33323139 37363534 00000001 00000020 73657409 61682d74 00006873 e77e812d<br/>=<br/>2215bcbd bc799737 63643212 32643230 39616463 35313665 00343863 e12b7901</span></pre><h2 id="f00d" class="mv lm iq bd ln mw mx dn lr my mz dp lv ko na nb lx ks nc nd lz kw ne nf mb ng bi translated">TL-模式层</h2><p id="486c" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">电报 API 使用 TL 模式层进行版本控制；每一层都有一个唯一的 TL 模式。Telegram 网站包含当前的 TL 模式和 https://core.telegram.org/schema<a class="ae lk" href="https://core.telegram.org/schema" rel="noopener ugc nofollow" target="_blank">的先前层。</a></p><p id="42de" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来是这样，事实证明，虽然 Telegram 网站上最新的 TL-Schema 层是第 23 层，但在撰写本文时，最新的层实际上已经是第 71 层了。你可以在这里找到最新的 TL-Schema。</p><h1 id="0942" class="ll lm iq bd ln lo lp lq lr ls lt lu lv jw lw jx lx jz ly ka lz kc ma kd mb mc bi translated">入门指南</h1><h2 id="170f" class="mv lm iq bd ln mw mx dn lr my mz dp lv ko na nb lx ks nc nd lz kw ne nf mb ng bi translated">创建电报应用程序</h2><p id="2d5e" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">您将需要获得一个<code class="fe nm nn no np b">api_id</code>和<code class="fe nm nn no np b">api_hash</code>来与电报 API 交互。请遵循官方文档中的说明:<a class="ae lk" href="https://core.telegram.org/api/obtaining_api_id" rel="noopener ugc nofollow" target="_blank">https://core.telegram.org/api/obtaining_api_id</a>。</p><p id="0dcd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您必须访问<a class="ae lk" href="https://my.telegram.org/" rel="noopener ugc nofollow" target="_blank">https://my.telegram.org/</a>，使用您的电话号码和确认码登录，确认码将通过电报发送，并在“API 开发工具”下的表格中填写应用标题和简称。之后，你可以在同一个地方找到你的<code class="fe nm nn no np b">api_id</code>和<code class="fe nm nn no np b">api_hash</code>。</p><p id="0dab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，相同的说明提到您可以使用电报源代码中的样本凭证进行测试。为了方便起见，我将在这里的示例代码中使用我在 GitHub 上的<a class="ae lk" href="https://github.com/telegramdesktop/tdesktop" rel="noopener ugc nofollow" target="_blank"> Telegram 桌面源代码中找到的凭证。</a></p><h2 id="b4d6" class="mv lm iq bd ln mw mx dn lr my mz dp lv ko na nb lx ks nc nd lz kw ne nf mb ng bi translated">安装天线</h2><p id="6f77" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">我们将使用 Telethon 与 Telegram API 通信。Telethon 是用于 Telegram API 的 Python 3 客户端库(这意味着您必须使用 Python 3 ),它将为我们处理所有特定于协议的任务，因此我们只需要知道使用什么类型和调用什么函数。</p><p id="e273" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用<code class="fe nm nn no np b">pip</code>安装 Telethon:</p><pre class="me mf mg mh gt nq np nr ns aw nt bi"><span id="eb4c" class="mv lm iq np b gy nu nv l nw nx">pip install telethon</span></pre><p id="12d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用与您的 Python 3 解释器相对应的<code class="fe nm nn no np b">pip</code>；这可能是<code class="fe nm nn no np b">pip3</code>代替。(随机:最近 Ubuntu 17.10 发布了，它使用 Python 3 作为默认的 Python 安装。)</p><h2 id="0dce" class="mv lm iq bd ln mw mx dn lr my mz dp lv ko na nb lx ks nc nd lz kw ne nf mb ng bi translated">创建客户端</h2><p id="a0a7" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">在开始与 Telegram API 交互之前，您需要用您的<code class="fe nm nn no np b">api_id</code>和<code class="fe nm nn no np b">api_hash</code>创建一个客户端对象，并用您的电话号码对其进行认证。这类似于在新设备上登录 Telegram 你可以把这个客户端想象成另一个 Telegram 应用。</p><p id="569f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是创建和验证客户端对象的一些代码，修改自 Telethon 文档:</p><pre class="me mf mg mh gt nq np nr ns aw nt bi"><span id="229f" class="mv lm iq np b gy nu nv l nw nx">from telethon import TelegramClient<br/>from telethon.errors.rpc_errors_401 import SessionPasswordNeededError<br/><br/># (1) Use your own values here<br/>api_id = 17349<br/>api_hash = '344583e45741c457fe1862106095a5eb'<br/><br/>phone = 'YOUR_NUMBER_HERE'<br/>username = 'username'<br/><br/># (2) Create the client and connect<br/>client = TelegramClient(username, api_id, api_hash)<br/>client.connect()<br/><br/># Ensure you're authorized<br/>if not client.is_user_authorized():<br/>    client.send_code_request(phone)<br/>    try:<br/>        client.sign_in(phone, input('Enter the code: '))<br/>    except SessionPasswordNeededError:<br/>        client.sign_in(password=input('Password: '))<br/><br/>me = client.get_me()<br/>print(me)</span></pre><p id="bd95" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如前所述，上面的<code class="fe nm nn no np b">api_id</code>和<code class="fe nm nn no np b">api_hash</code>来自电报桌面源代码。将您自己的电话号码放入<code class="fe nm nn no np b">phone</code>变量中。</p><p id="0c94" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Telethon 将在其工作目录中创建一个<code class="fe nm nn no np b">.session</code>文件来保存会话细节，就像你不必在每次关闭和重新打开 Telegram 应用程序时重新验证它们一样。文件名将以<code class="fe nm nn no np b">username</code>变量开始。如果您想使用多个会话，您可以决定是否要更改它。</p><p id="1638" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有之前的会话，运行此代码将通过电报向您发送授权代码。如果您在电报帐户上启用了两步验证，您还需要输入您的电报密码。认证一次并保存<code class="fe nm nn no np b">.session</code>文件后，即使您再次运行脚本，您也不必再次重新认证，直到您的会话到期。</p><p id="ce7a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果成功创建并验证了客户机，应该会在控制台上打印出一个代表您自己的对象。它看起来类似于(省略号<code class="fe nm nn no np b">…</code>表示跳过了一些内容):</p><pre class="me mf mg mh gt nq np nr ns aw nt bi"><span id="4b5c" class="mv lm iq np b gy nu nv l nw nx">User(is_self=True <!-- -->…<!-- --> first_name='Jiayu', last_name=None, username='USERNAME', phone='PHONE_NUMBER' <!-- -->…</span></pre><p id="6937" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您可以使用这个客户机对象开始向 Telegram API 发出请求。</p><h1 id="c198" class="ll lm iq bd ln lo lp lq lr ls lt lu lv jw lw jx lx jz ly ka lz kc ma kd mb mc bi translated">使用电报 API</h1><h2 id="132c" class="mv lm iq bd ln mw mx dn lr my mz dp lv ko na nb lx ks nc nd lz kw ne nf mb ng bi translated">检查 TL 模式</h2><p id="72c7" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">如前所述，使用 Telegram API 包括调用 TL 模式中的可用函数。在这种情况下，我们对<code class="fe nm nn no np b">messages.GetDialogs</code>函数感兴趣。我们还需要注意函数参数中的相关类型。下面是我们将用来发出这个请求的 TL 模式的一个子集:</p><pre class="me mf mg mh gt nq np nr ns aw nt bi"><span id="fa8f" class="mv lm iq np b gy nu nv l nw nx">messages.dialogs#15ba6c40 dialogs:Vector&lt;Dialog&gt; messages:Vector&lt;Message&gt; chats:Vector&lt;Chat&gt; users:Vector&lt;User&gt; = messages.Dialogs;</span><span id="e322" class="mv lm iq np b gy ny nv l nw nx">messages.dialogsSlice#71e094f3 count:int dialogs:Vector&lt;Dialog&gt; messages:Vector&lt;Message&gt; chats:Vector&lt;Chat&gt; users:Vector&lt;User&gt; = messages.Dialogs;</span><span id="b782" class="mv lm iq np b gy ny nv l nw nx">---functions---</span><span id="d14c" class="mv lm iq np b gy ny nv l nw nx">messages.getDialogs#191ba9c5 flags:# exclude_pinned:flags.0?true offset_date:int offset_id:int offset_peer:InputPeer limit:int = messages.Dialogs;</span></pre><p id="c6d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这并不容易理解，但请注意，<code class="fe nm nn no np b">messages.getDialogs</code>函数将返回一个<code class="fe nm nn no np b">messages.Dialogs</code>，它是一个抽象类型，用于包含<code class="fe nm nn no np b">Dialog</code>、<code class="fe nm nn no np b">Message</code>、<code class="fe nm nn no np b">Chat</code>和<code class="fe nm nn no np b">User</code>向量的<code class="fe nm nn no np b">messages.dialogs</code>或<code class="fe nm nn no np b">messages.dialogsSlice</code>对象。</p><h2 id="434a" class="mv lm iq bd ln mw mx dn lr my mz dp lv ko na nb lx ks nc nd lz kw ne nf mb ng bi translated">使用 Telethon 文档</h2><p id="ace4" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">幸运的是，Telethon 文档给出了关于如何调用这个函数的更多细节。从<a class="ae lk" href="https://lonamiwebs.github.io/Telethon/index.html" rel="noopener ugc nofollow" target="_blank">https://lonamiwebs.github.io/Telethon/index.html</a>，如果您在搜索框中键入<code class="fe nm nn no np b">getdialogs</code>，您将看到一个名为<code class="fe nm nn no np b">GetDialogsRequest</code>的方法的结果(TL-Schema 函数由 Telethon 中的<code class="fe nm nn no np b">*Request</code>对象表示)。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nz"><img src="../Images/6ba76a87ac9ea6300693bb6b091ba2d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hu8TvvjPOR7X0u9IBseljQ.png"/></div></div></figure><p id="22d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nm nn no np b">GetDialogsRequest</code>的文档陈述了方法的返回类型以及关于参数的更多细节。当我们想要使用这个对象时,“复制导入到剪贴板”按钮特别有用，就像现在。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi oa"><img src="../Images/d14a600428b1191cb488391090ac3571.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*56Z1VTBbm-srK0lw3piKKg.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk"><a class="ae lk" href="https://lonamiwebs.github.io/Telethon/methods/messages/get_dialogs.html" rel="noopener ugc nofollow" target="_blank">https://lonamiwebs.github.io/Telethon/methods/messages/get_dialogs.html</a></figcaption></figure><p id="8be6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nm nn no np b">messages.getDialogs</code>函数以及<code class="fe nm nn no np b">GetDialogsRequest</code>的构造函数接受一个<code class="fe nm nn no np b">InputPeer</code>类型的<code class="fe nm nn no np b">offset_peer</code>参数。在 GetDialogsRequest 的文档中，单击<code class="fe nm nn no np b">InputPeer</code>链接可以看到一个页面，其中描述了获取和返回该类型的构造函数和方法。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ob"><img src="../Images/b41bd84112a4f9b25f3d16e3870baaac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QmF60qGEl7EApDW-9J_qXw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk"><a class="ae lk" href="https://lonamiwebs.github.io/Telethon/types/input_peer.html" rel="noopener ugc nofollow" target="_blank">https://lonamiwebs.github.io/Telethon/types/input_peer.html</a></figcaption></figure><p id="8f47" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们想创建一个<code class="fe nm nn no np b">InputPeer</code>对象作为<code class="fe nm nn no np b">GetDialogsRequest</code>的参数，所以我们对<code class="fe nm nn no np b">InputPeer</code>的构造函数感兴趣。在这种情况下，我们将使用<code class="fe nm nn no np b">InputPeerEmpty</code>构造函数。再次点击进入<code class="fe nm nn no np b">InputPeerEmpty</code>页面，复制它的导入路径来使用它。<code class="fe nm nn no np b">InputPeerEmpty</code>构造函数没有参数。</p><h2 id="1402" class="mv lm iq bd ln mw mx dn lr my mz dp lv ko na nb lx ks nc nd lz kw ne nf mb ng bi translated">提出请求</h2><p id="9e05" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">下面是我们完成的<code class="fe nm nn no np b">GetDialogsRequest</code>以及如何通过将它传递给我们授权的客户端对象来获得它的结果:</p><pre class="me mf mg mh gt nq np nr ns aw nt bi"><span id="957b" class="mv lm iq np b gy nu nv l nw nx">from telethon.tl.functions.messages import GetDialogsRequest<br/>from telethon.tl.types import InputPeerEmpty<br/><br/>get_dialogs = GetDialogsRequest(<br/>    offset_date=None,<br/>    offset_id=0,<br/>    offset_peer=InputPeerEmpty(),<br/>    limit=30,<br/>)</span><span id="8ad5" class="mv lm iq np b gy ny nv l nw nx">dialogs = client(get_dialogs)<br/>print(dialogs)</span></pre><p id="2e4a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的例子中，我得到了一个包含对话、消息、聊天和用户列表的<code class="fe nm nn no np b">DialogsSlice</code>对象，正如我们基于 TL-Schema 所期望的:</p><pre class="me mf mg mh gt nq np nr ns aw nt bi"><span id="7bad" class="mv lm iq np b gy nu nv l nw nx">DialogsSlice(count=204, dialogs=[<!-- -->…<!-- -->], messages=[<!-- -->…<!-- -->], chats=[<!-- -->…<!-- -->], users=[<!-- -->…<!-- -->])</span></pre><p id="1266" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">收到一个<code class="fe nm nn no np b">DialogsSlice</code>而不是<code class="fe nm nn no np b">Dialogs</code>意味着不是我所有的对话框都被返回，但是<code class="fe nm nn no np b">count</code>属性告诉我我总共有多少个对话框。如果您的对话少于某个数量，您可能会收到一个<code class="fe nm nn no np b">Dialogs</code>对象，在这种情况下，您的所有对话都被返回，您拥有的对话的数量就是向量的长度。</p><h2 id="2da0" class="mv lm iq bd ln mw mx dn lr my mz dp lv ko na nb lx ks nc nd lz kw ne nf mb ng bi translated">术语</h2><p id="26a7" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">Telegram API 使用的术语有时可能会有点混乱，尤其是在缺少类型定义以外的信息的情况下。什么是“对话”、“消息”、“聊天”和“用户”？</p><ul class=""><li id="79cc" class="oc od iq kh b ki kj kl km ko oe ks of kw og la oh oi oj ok bi translated"><code class="fe nm nn no np b">dialogs</code>代表您的对话历史中的对话</li><li id="5fba" class="oc od iq kh b ki ol kl om ko on ks oo kw op la oh oi oj ok bi translated"><code class="fe nm nn no np b">chats</code>代表与您的对话历史中的对话相对应的群组和频道</li><li id="ce60" class="oc od iq kh b ki ol kl om ko on ks oo kw op la oh oi oj ok bi translated"><code class="fe nm nn no np b">messages</code>包含发送给每个对话的最后一条消息，就像您在 Telegram 应用程序的对话列表中看到的那样</li><li id="6037" class="oc od iq kh b ki ol kl om ko on ks oo kw op la oh oi oj ok bi translated"><code class="fe nm nn no np b">users</code>包含您与之进行一对一聊天的个人用户，或者向您的某个群组发送最后一条消息的人</li></ul><p id="b8cf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我的聊天记录是我从 Play Store 中的<a class="ae lk" href="https://play.google.com/store/apps/details?id=org.telegram.messenger" rel="noopener ugc nofollow" target="_blank"> Telegram 应用程序获取的截图:</a></p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi oq"><img src="../Images/be21067f1996561cedd4f1a353038bb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/0*yp_9BNzYD3NyEgul."/></div></div></figure><p id="484e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nm nn no np b">dialogs</code>将包含截图中的对话:老海盗，新闻发布室，莫妮卡，吉安娜…</p><p id="28a1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将包含老海盗、新闻发布室和 Meme 工厂的条目。</p><p id="c539" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nm nn no np b">messages</code>将包含消息“请上车！”来自老海盗，“哇，提得好！”从新闻发布室，一条代表发给莫妮卡的照片的消息，一条代表吉安娜的回复的消息等等。</p><p id="54e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nm nn no np b">users</code>将包含自从 Ashley 向新闻发布室发送最后一条消息以来的条目，以及自从他向 Meme 工厂发送最后一条消息以来的 Monika、Jaina、Kate 和 Winston 的条目。</p><p id="1d60" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(我还没有通过 Telegram API 处理过秘密聊天，所以我不确定它们是如何处理的。)</p><h2 id="bcc0" class="mv lm iq bd ln mw mx dn lr my mz dp lv ko na nb lx ks nc nd lz kw ne nf mb ng bi translated">计数消息</h2><p id="75fa" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">我们的目标是统计每次对话中的消息数量。要获得一个会话的消息数量，我们可以使用 TL-Schema 中的<code class="fe nm nn no np b">messages.getHistory</code>函数:</p><pre class="me mf mg mh gt nq np nr ns aw nt bi"><span id="2e78" class="mv lm iq np b gy nu nv l nw nx">messages.getHistory#afa92846 peer:<a class="ae lk" href="https://lonamiwebs.github.io/Telethon/types/input_peer.html" rel="noopener ugc nofollow" target="_blank">InputPeer</a> offset_id:<a class="ae lk" href="https://lonamiwebs.github.io/Telethon/index.html#int" rel="noopener ugc nofollow" target="_blank">int</a> offset_date:<a class="ae lk" href="https://lonamiwebs.github.io/Telethon/index.html#date" rel="noopener ugc nofollow" target="_blank">date</a> add_offset:<a class="ae lk" href="https://lonamiwebs.github.io/Telethon/index.html#int" rel="noopener ugc nofollow" target="_blank">int</a> limit:<a class="ae lk" href="https://lonamiwebs.github.io/Telethon/index.html#int" rel="noopener ugc nofollow" target="_blank">int</a> max_id:<a class="ae lk" href="https://lonamiwebs.github.io/Telethon/index.html#int" rel="noopener ugc nofollow" target="_blank">int</a> min_id:<a class="ae lk" href="https://lonamiwebs.github.io/Telethon/index.html#int" rel="noopener ugc nofollow" target="_blank">int</a> = <a class="ae lk" href="https://lonamiwebs.github.io/Telethon/types/messages/messages.html" rel="noopener ugc nofollow" target="_blank">messages.Messages</a></span></pre><p id="f49d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">按照与前面使用<code class="fe nm nn no np b">messages.getDialogs</code>类似的过程，我们可以使用<code class="fe nm nn no np b">GetHistoryRequest</code>来解决如何使用 Telethon 调用它。这将返回一个<code class="fe nm nn no np b">Messages</code>或<code class="fe nm nn no np b">MessagesSlice</code>对象，或者包含一个<code class="fe nm nn no np b">count</code>属性，告诉我们一个对话中有多少条消息，或者一个对话中的所有消息，这样我们就可以计算它包含的消息数。</p><p id="4013" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们首先必须为我们的<code class="fe nm nn no np b">GetHistoryRequest</code>构建正确的<code class="fe nm nn no np b">InputPeer</code>。这一次，我们使用<code class="fe nm nn no np b">InputPeerEmpty</code>,因为我们想要检索特定对话的消息历史。相反，我们必须根据对话的性质使用<code class="fe nm nn no np b">InputPeerUser</code>、<code class="fe nm nn no np b">InputPeerChat</code>或<code class="fe nm nn no np b">InputPeerChannel</code>构造函数。</p><h2 id="3552" class="mv lm iq bd ln mw mx dn lr my mz dp lv ko na nb lx ks nc nd lz kw ne nf mb ng bi translated">操纵响应数据</h2><p id="ac47" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">为了统计每个对话中的消息数量，我们必须为该对话创建一个<code class="fe nm nn no np b">GetHistoryRequest</code>，并为该对话创建相应的<code class="fe nm nn no np b">InputPeer</code>。</p><p id="084f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有相关的<code class="fe nm nn no np b">InputPeer</code>构造函数都采用相同的<code class="fe nm nn no np b">id</code>和<code class="fe nm nn no np b">access_hash</code>参数，但是根据对话是一对一聊天、群组还是频道，这些值出现在<code class="fe nm nn no np b">GetDialogsRequest</code>响应的不同位置:</p><ul class=""><li id="e142" class="oc od iq kh b ki kj kl km ko oe ks of kw og la oh oi oj ok bi translated"><code class="fe nm nn no np b">dialogs</code>:我们希望对其中的消息进行计数的会话列表，包含一个<code class="fe nm nn no np b">peer</code>值，以及对应于该会话的对等方的类型和<code class="fe nm nn no np b">id</code>，但不包含<code class="fe nm nn no np b">access_hash</code>。</li><li id="40b1" class="oc od iq kh b ki ol kl om ko on ks oo kw op la oh oi oj ok bi translated"><code class="fe nm nn no np b">chats</code>:包含<code class="fe nm nn no np b">id</code>、<code class="fe nm nn no np b">access_hash</code>以及本集团和频道的标题。</li><li id="b63a" class="oc od iq kh b ki ol kl om ko on ks oo kw op la oh oi oj ok bi translated"><code class="fe nm nn no np b">users</code>:包含我们个人聊天的<code class="fe nm nn no np b">id</code>、<code class="fe nm nn no np b">access_hash</code>和名字。</li></ul><p id="19e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在伪代码中，我们有:</p><pre class="me mf mg mh gt nq np nr ns aw nt bi"><span id="3096" class="mv lm iq np b gy nu nv l nw nx">let counts be a mapping from conversations to message counts</span><span id="b1a5" class="mv lm iq np b gy ny nv l nw nx">for each dialog in dialogs:<br/>    if dialog.peer is a channel:<br/>        channel = corresponding object in chats<br/>        name = channel.title<br/>        id = channel.id<br/>        access_hash = channel.access_hash<br/>        peer = InputPeerChannel(id, access_hash)<br/>    else if dialog.peer is a group:<br/>        group = corresponding object in chats<br/>        name = group.title<br/>        id = group.id<br/>        peer = InputPeerChat(id)<br/>    else if dialog.peer is a user:<br/>        user = corresponding object in users<br/>        name = user.first_name<br/>        id = user.id<br/>        access_hash = user.access_hash<br/>        peer = InputPeerUser(id, access_hash)</span><span id="416e" class="mv lm iq np b gy ny nv l nw nx">    history = message history for peer<br/>    count = number of messages in history</span><span id="499f" class="mv lm iq np b gy ny nv l nw nx">    counts[name] = count</span></pre><p id="6ba7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">转换成 Python 代码(注意上面的<code class="fe nm nn no np b">dialogs</code>、<code class="fe nm nn no np b">chats</code>和<code class="fe nm nn no np b">users</code>是我们的<code class="fe nm nn no np b">GetDialogsRequest</code>的结果的成员，也称为<code class="fe nm nn no np b">dialogs</code>):</p><pre class="me mf mg mh gt nq np nr ns aw nt bi"><span id="b9fa" class="mv lm iq np b gy nu nv l nw nx">counts = {}<br/><br/># create dictionary of ids to users and chats<br/>users = {}<br/>chats = {}<br/><br/>for u in dialogs.users:<br/>    users[u.id] = u<br/><br/>for c in dialogs.chats:<br/>    chats[c.id] = c<br/><br/>for d in dialogs.dialogs:<br/>    peer = d.peer<br/>    if isinstance(peer, PeerChannel):<br/>        id = peer.channel_id<br/>        channel = chats[id]<br/>        access_hash = channel.access_hash<br/>        name = channel.title<br/><br/>        input_peer = InputPeerChannel(id, access_hash)<br/>    elif isinstance(peer, PeerChat):<br/>        id = peer.chat_id<br/>        group = chats[id]<br/>        name = group.title<br/><br/>        input_peer = InputPeerChat(id)<br/>    elif isinstance(peer, PeerUser):<br/>        id = peer.user_id<br/>        user = users[id]<br/>        access_hash = user.access_hash<br/>        name = user.first_name<br/><br/>        input_peer = InputPeerUser(id, access_hash)<br/>    else:<br/>        continue<br/><br/>    get_history = GetHistoryRequest(<br/>        peer=input_peer,<br/>        offset_id=0,<br/>        offset_date=None,<br/>        add_offset=0,<br/>        limit=1,<br/>        max_id=0,<br/>        min_id=0,<br/>    )<br/><br/>    history = client(get_history)<br/>    if isinstance(history, Messages):<br/>        count = len(history.messages)<br/>    else:<br/>        count = history.count<br/><br/>    counts[name] = count<br/><br/>print(counts)</span></pre><p id="0554" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的<code class="fe nm nn no np b">counts</code>对象是一个聊天名称到消息计数的字典。我们可以对它进行排序和漂亮的打印，以查看我们的热门对话:</p><pre class="me mf mg mh gt nq np nr ns aw nt bi"><span id="3420" class="mv lm iq np b gy nu nv l nw nx">sorted_counts = sorted(counts.items(), key=lambda x: x[1], reverse=True)<br/>for name, count in sorted_counts:<br/>    print('{}: {}'.format(name, count))</span></pre><p id="2d95" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">示例输出:</p><pre class="me mf mg mh gt nq np nr ns aw nt bi"><span id="1edd" class="mv lm iq np b gy nu nv l nw nx">Group chat 1: 10000<br/>Group chat 2: 3003<br/>Channel 1: 2000<br/>Chat 1: 1500<br/>Chat 2: 300</span></pre><h2 id="517d" class="mv lm iq bd ln mw mx dn lr my mz dp lv ko na nb lx ks nc nd lz kw ne nf mb ng bi translated">图书馆魔术</h2><p id="61a4" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">Telethon 有一些帮助功能来简化常见操作。实际上，我们可以用其中的两个帮助器方法来完成上面的工作，<code class="fe nm nn no np b">client.get_dialogs()</code>和<code class="fe nm nn no np b">client.get_message_history()</code>，取而代之:</p><pre class="me mf mg mh gt nq np nr ns aw nt bi"><span id="a467" class="mv lm iq np b gy nu nv l nw nx">from telethon.tl.types import User<br/><br/>_, entities = client.get_dialogs(limit=30)<br/><br/>counts = []<br/>for e in entities:<br/>    if isinstance(e, User):<br/>        name = e.first_name<br/>    else:<br/>        name = e.title<br/><br/>    count, _, _ = client.get_message_history(e, limit=1)<br/>    counts.append((name, count))<br/><br/>message_counts.sort(key=lambda x: x[1], reverse=True)<br/>for name, count in counts:<br/>    print('{}: {}'.format(name, count))</span></pre><p id="eefe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我觉得首先直接调用 Telegram API 方法是一种更好的学习体验，特别是因为没有一个助手方法适用于所有情况。然而，有一些事情使用 helper 方法要简单得多，比如我们如何在开始时认证我们的客户端，或者上传文件之类的动作，否则这些动作会很乏味。</p><h1 id="bbb8" class="ll lm iq bd ln lo lp lq lr ls lt lu lv jw lw jx lx jz ly ka lz kc ma kd mb mc bi translated">包扎</h1><p id="b8f0" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">这个例子的完整代码可以在这里找到一个要点:<a class="ae lk" href="https://gist.github.com/yi-jiayu/7b34260cfbfa6cbc2b4464edd41def42" rel="noopener ugc nofollow" target="_blank">https://Gist . github . com/yi-Jiayu/7b 34260 cfbfa 6 CB C2 b 4464 edd 41 def 42</a></p><p id="56ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用 Telegram API 可以做更多的事情，尤其是从分析的角度来看。在想到我的一个老项目后，我开始研究这个项目，试图从导出的 WhatsApp 聊天记录中创建数据可视化:<a class="ae lk" href="https://github.com/yi-jiayu/chat-analytics" rel="noopener ugc nofollow" target="_blank">https://github.com/yi-jiayu/chat-analytics</a>。</p><p id="46bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用 regex 解析通过电子邮件发送的纯文本聊天记录，我可以生成一个类似于 GitHub punch card 存储库图表的图表，显示一周中的哪些时间聊天最活跃:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi or"><img src="../Images/a5bce496e5259d0c6d4f267499de6ddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GY0aUncq3tKQ6c9I."/></div></div></figure><p id="c58c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，使用“电子邮件聊天”功能来导出是相当粗糙的，你需要手动导出每个聊天的对话历史，一旦你收到新消息，它就会过时。我并没有继续这个项目，但是我一直认为可以从聊天记录中获得其他见解。</p><p id="b845" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过编程访问聊天记录，Telegram 聊天可以做更多的事情。像<code class="fe nm nn no np b">messages.search</code>这样的方法对我来说非常有用。也许是动态生成高峰和低谷对话的统计数据，或者是持续活跃的对话，或者是找到你最喜欢的表情符号或最常见的 n 字母组合？天空是极限(或 API 速率极限，以较低者为准)。</p><h2 id="1fee" class="mv lm iq bd ln mw mx dn lr my mz dp lv ko na nb lx ks nc nd lz kw ne nf mb ng bi translated">更新</h2><p id="4cc5" class="pw-post-body-paragraph kf kg iq kh b ki nh jr kk kl ni ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">(2017–10–25 09:45 SGT)修改了消息计数以跳过意外对话框</p></div><div class="ab cl os ot hu ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="ij ik il im in"><ol class=""><li id="c281" class="oc od iq kh b ki kj kl km ko oe ks of kw og la oz oi oj ok bi translated"><a class="ae lk" href="#12b2" rel="noopener ugc nofollow"> ^ </a>就我个人而言，我不能对 Telegram 的安全性发表评论，只能指出 Telegram 的对话在默认情况下不是端到端加密的，并提到 Telegram 的加密协议是自行开发的，与 Signal Protocol 等更成熟的协议相比，它受到的审查更少。</li></ol></div></div>    
</body>
</html>