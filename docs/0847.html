<html>
<head>
<title>Audio processing in TensorFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TensorFlow中的音频处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/audio-processing-in-tensorflow-208f1a4103aa?source=collection_archive---------0-----------------------#2017-06-30">https://towardsdatascience.com/audio-processing-in-tensorflow-208f1a4103aa?source=collection_archive---------0-----------------------#2017-06-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b733e458f128f9b2fa87bd31aa23506d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YsFMNUMSZv4Axbp-ouOLiA.png"/></div></div></figure><h1 id="fb5a" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">短时傅立叶变换的一种实现</h1><h2 id="3da6" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">我发现TensorFlow中的音频处理很难，下面是我的修复方法</strong></h2><p id="d466" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">有无数种方法可以执行音频处理。在TensorFlow中用人工神经网络运行带有音频输入的实验的通常流程是首先预处理音频，然后将其馈送到神经网络。</p><p id="9124" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">当一个人想要在计算图的中间执行音频处理时，会发生什么呢？<br/> TensorFlow附带了<a class="ae ml" href="https://www.tensorflow.org/api_docs/python/tf/fft" rel="noopener ugc nofollow" target="_blank">快速傅立叶变换</a>的实现，但这还不够。</p><p id="e84b" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">在这篇文章中，我将解释我们如何实现它，并提供代码，以便短时傅立叶变换可以在计算图中的任何地方使用。</p><h2 id="4fc8" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated">代码</h2><p id="c29c" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">所有代码都可以在我的<strong class="ln ir">GitHub</strong>:<a class="ae ml" href="https://github.com/dariocazzani/TensorFlow-audio-processing" rel="noopener ugc nofollow" target="_blank">tensor flow</a>中音频处理。请随意在那里添加您的贡献。</p><h2 id="32e4" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated">音频预处理:常用方法</h2><p id="6f41" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">当开发一个使用深度神经网络的语音识别引擎时，我们需要将音频输入到我们的神经网络，但是…预处理这个输入的正确方法是什么？</p><p id="c084" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">有两种常见的方式来表示声音:</p><ul class=""><li id="44bd" class="mm mn iq ln b lo mg ls mh lb mo le mp lh mq mf mr ms mt mu bi translated"><em class="mv">时域:</em>每个样本代表气压的变化。</li><li id="50e5" class="mm mn iq ln b lo mw ls mx lb my le mz lh na mf mr ms mt mu bi translated"><em class="mv">频域</em>:在每个时间戳，我们指示每个频率的振幅。</li></ul><p id="50af" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">尽管深度神经网络非常擅长自动学习特征，但依靠携带我们试图解决的任务所需信息的已知特征总是一个好主意。</p><p id="6a28" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">对于大多数应用，包括语音识别引擎，我们感兴趣的特征被编码在声音的频域表示中。</p><h2 id="2b26" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated">频谱图和短时傅立叶变换</h2><p id="2656" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated"><a class="ae ml" href="https://en.wikipedia.org/wiki/Spectrogram" rel="noopener ugc nofollow" target="_blank">频谱图</a>显示了信号的频率成分如何随时间变化，并且可以从时域信号中计算出来。<br/>用来做这件事的操作或变换被称为<a class="ae ml" href="https://en.wikipedia.org/wiki/Short-time_Fourier_transform" rel="noopener ugc nofollow" target="_blank">短时傅立叶变换</a>。</p><p id="c305" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">我可以让神经网络知道如何学习这个操作，但事实证明学习1个隐藏层是非常复杂的。(参考<a class="ae ml" href="https://en.wikipedia.org/wiki/Universal_approximation_theorem" rel="noopener ugc nofollow" target="_blank">通用逼近定理</a>)</p><p id="1b64" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">我可以添加更多的层，但是我想保持神经网络的复杂性尽可能小，并且只在最需要的地方学习特征。</p><p id="9a34" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">我已经使用了开发自动语音识别引擎的例子，但是使用声谱图作为深度神经网络的输入对于涉及非语音音频的类似任务也是常见的，例如降噪、音乐流派分类、鲸叫声检测等。</p><p id="fe16" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">我想提到的一个特别的项目是来自<a class="ae ml" href="https://research.google.com/teams/brain/" rel="noopener ugc nofollow" target="_blank">谷歌大脑团队</a>的<a class="ae ml" href="https://magenta.tensorflow.org/welcome-to-magenta" rel="noopener ugc nofollow" target="_blank"> Magenta </a>，他的目标是为音乐和艺术世代推进机器智能的艺术状态。</p><h2 id="aec1" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">为什么是TensorFlow？</strong></h2><p id="15ff" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">在实现人工神经网络时，我主要使用TensorFlow，因为我还没有在TF中找到短时傅立叶变换的实现，所以我决定实现我们自己的。<br/>【编辑:2018年6月4日】—从TensorFlow 1.3开始，他们增加了一些有用的<a class="ae ml" href="https://www.tensorflow.org/api_docs/python/tf/contrib/signal" rel="noopener ugc nofollow" target="_blank"> DSP功能</a>。</p><p id="0a5a" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">深度学习实践者可能想要在计算图中包括短时傅立叶变换(我朋友的STFT)也可能有多种原因，而不仅仅是作为单独的预处理步骤。</p><p id="0099" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">请记住，我并没有把重点放在提高效率上。在用于生产之前，它应该(也将会)得到改进。</p><h2 id="faf6" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">你需要知道的事情</strong></h2><p id="1286" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">为了理解STFT是如何计算的，您需要理解如何计算离散傅里叶变换。</p><h2 id="dafe" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">离散傅立叶变换— DFT </strong></h2><p id="4356" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">对于那些不熟悉这些概念的人来说，这一部分可能显得很专业，但是我认为为了对代码有一个完整的理解，通过一些数学是很重要的。</p><p id="1522" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated"><strong class="ln ir">理论<br/>当函数和它的傅立叶变换都被离散化的对应物代替时，它被称为离散傅立叶变换(DFT)。</strong></p><p id="98a9" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">给定一个矢量<strong class="ln ir"> <em class="mv"> x </em> </strong>的<em class="mv"> n </em>输入幅值如:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="00e1" class="kw jz iq ng b gy nk nl l nm nn">{x[0], x[1], x[2], x[3], …, x[N-1]}</span></pre><p id="77f5" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">离散傅立叶变换产生一组<em class="mv"> n </em>个频率幅度。</p><p id="f008" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">DFT由下式定义:</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/b1daa56b8b66c8e8391f0676788e9e57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PKevkPcpgv2kWU84QT17XQ.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">DFT equation</figcaption></figure><ul class=""><li id="96eb" class="mm mn iq ln b lo mg ls mh lb mo le mp lh mq mf mr ms mt mu bi translated">k用于表示频域序数</li><li id="00ba" class="mm mn iq ln b lo mw ls mx lb my le mz lh na mf mr ms mt mu bi translated">n用于表示时域序数</li><li id="b088" class="mm mn iq ln b lo mw ls mx lb my le mz lh na mf mr ms mt mu bi translated">n是要变换的序列的长度。</li></ul><p id="859e" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated"><strong class="ln ir">快速傅立叶变换<br/></strong><a class="ae ml" href="https://en.wikipedia.org/wiki/Fast_Fourier_transform" rel="noopener ugc nofollow" target="_blank">快速傅立叶变换</a>是DFT方程的有效实现。信号的大小必须限制为2的幂。</p><p id="bafe" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">这解释了为什么N(输入到DFT函数的信号大小)必须是2的幂，以及为什么它必须以零填充。</p><p id="22e3" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">在python中可以很简单地检测出x是否是2的幂:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="d4f8" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated"><strong class="ln ir">我们只需要它的一半<br/> </strong>实数正弦波可以用<a class="ae ml" href="https://en.wikipedia.org/wiki/Euler%27s_formula" rel="noopener ugc nofollow" target="_blank">欧拉恒等式</a>表示为复数正弦波的和</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/df1994c8a5091797e576fb98120e0dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eU5F-WZZGiFX9Ov26E3iVw.png"/></div></div></figure><p id="b2c3" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">因为DFT是线性函数，所以正弦波之和的DFT是每个正弦波的DFT之和。对于频谱情况，有两个DFT，一个针对正频率，一个针对负频率，它们是对称的。<br/>这种对称性出现在可以被视为正弦波的无限(或有限)和的真实信号中。</p><p id="b687" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated"><strong class="ln ir">开窗<br/> </strong>在时域截断信号会导致频域出现纹波。<br/>如果您认为截断信号就像应用了一个矩形窗口，这是可以理解的。在时域中应用窗口会导致频域中的卷积。<br/>当我们将两个频域表示卷积在一起时，会产生纹波。</p><p id="926f" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">如果你有兴趣的话，可以找到更多关于<a class="ae ml" href="https://mil.ufl.edu/nechyba/www/__eel3135.s2003/lectures/lecture19/spectral_leakage.pdf" rel="noopener ugc nofollow" target="_blank"> spectral_leakage </a>的信息。</p><p id="0d94" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">下面是一个在Python中实现窗口的示例:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="61fc" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated"><strong class="ln ir">零相位填充</strong></p><p id="4961" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">为了使用FFT，输入信号的长度必须是2的幂。如果输入信号的长度不合适，可以在信号本身的开头和结尾附加零。<br/>因为零样本最初位于输入信号的中心，所以我从中间分割填充信号，并交换这两部分的顺序。</p><p id="02d0" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">下一个代码片段展示了如何在TensorFlow中对一批输入执行此操作:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="f2fb" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated"><strong class="ln ir"> FFT、幅度和相位<br/> </strong>现在，您已经拥有了计算频谱图幅度(分贝)和信号相位所需的一切:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="2ae3" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">短时傅立叶变换</strong></h2><p id="a198" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">现在，您已经知道如何计算DFT来评估信号的频率成分。<br/>当信号的频率成分随时间变化时，STFT用于分析信号的频率成分。<br/>你可以这样做:</p><ol class=""><li id="7e50" class="mm mn iq ln b lo mg ls mh lb mo le mp lh mq mf nw ms mt mu bi translated">获取信号片段。</li><li id="3900" class="mm mn iq ln b lo mw ls mx lb my le mz lh na mf nw ms mt mu bi translated">将这些信号从剩余的信号中分离出来，并将DFT应用于每个片段。</li><li id="b60d" class="mm mn iq ln b lo mw ls mx lb my le mz lh na mf nw ms mt mu bi translated">沿着每个线段滑动此窗口。</li></ol><p id="9f27" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">DFT系数是时间和频率的函数。</p><p id="7661" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">完整的代码分为两部分:<em class="mv"> helpers.py </em>和<em class="mv"> stft.py </em>。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="5418" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated">结论</h2><p id="6b3c" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">在TensorFlow中执行STFT的可能性允许机器学习实践者在计算图中的任何地方执行信号从时域到频域的变换。新工具总是带来新的想法，我们希望这篇文章将成为开发新的深度学习解决方案的新想法的来源。</p></div></div>    
</body>
</html>