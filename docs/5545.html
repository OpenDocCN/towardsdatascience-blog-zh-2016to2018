<html>
<head>
<title>Zombies &amp; Model Rot (with ML Engine + DataStore)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">僵尸和模型腐烂(带 ML 引擎+数据存储)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/zombies-model-rot-with-ml-engine-datastore-747b299526e9?source=collection_archive---------16-----------------------#2018-10-24">https://towardsdatascience.com/zombies-model-rot-with-ml-engine-datastore-747b299526e9?source=collection_archive---------16-----------------------#2018-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/edf9696bdc3d05393aa051d553af8849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*uWwW72D4mHiZHOJYJa-Ctg.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Don’t leave your models to rot into obscurity</figcaption></figure><p id="5f7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以你已经把你的机器学习模型部署到了云端，你的所有应用和服务都能够从中获取预测，太好了！你可以永远不去管那个模型去做它的事情…也许不会。大多数机器学习模型都在建模这个世界的一些东西，而这个世界是不断变化的。要么和它一起改变，要么被甩在后面！</p><h1 id="7227" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是模型腐烂？</h1><p id="e2eb" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">模型腐，数据腐，AI 腐，随便你怎么叫，都不好！假设我们已经建立了一个模型来预测僵尸是否友好。我们将它部署到云端，现在世界各地的应用程序都在使用它来帮助公众了解他们可以与哪些僵尸交朋友而不会被咬。令人惊讶的是，人们似乎对你的模型非常满意，但是几个月后，你开始收到人们发来的愤怒的电子邮件，他们说你的模型很糟糕！原来是丧尸种群变异了！现在你的模式是过时了，还是<strong class="ka ir">烂了</strong>！您需要更新您的模型，更好的是，添加一种方法来跟踪您的模型的腐烂状态，以便这种情况不会再次发生。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi lz"><img src="../Images/140ae4af6bd727d7e3fb8aa90d91f296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*AW5ZhXxEa8OV-pVc908C8w.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">This is an example of a very sudden case of model rot!</figcaption></figure><h1 id="690c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">改变的不仅仅是僵尸</h1><p id="0a84" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">当然，虚构的生物可以改变，但金融市场、居住环境、交通模式、天气模式、人们写微博的方式、猫的样子也可以改变！好吧，也许猫永远看起来像猫(虽然给它几百万年，也许不是)。关键是，取决于你的模型预测的东西会影响它们腐烂的速度。</p><p id="f579" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样重要的是要注意到，你预测的东西不需要为了你的模型腐烂而改变。也许您用来捕获输入数据的传感器发生了变化。当部署模型时，任何对模型性能产生负面影响的东西都会导致模型腐烂，要么移除导致性能降低的东西，要么更新模型(很可能是后一种选择)。</p><h1 id="f92d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">让我们与模型腐烂作斗争(用 ML 引擎+数据存储)</h1><p id="c4e1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">有一个僵尸爆发，但它并不像电影会让你相信的那样可怕。它们是相当缓慢移动的生物，它们中的许多只是在寻找人类朋友，但有些不是。为了帮助人们正确选择僵尸朋友，我们开发了一个模型，根据几个特征来预测僵尸是否友好:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mi"><img src="../Images/d839494ab1010a2911708acf7ec3e4bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F8Dby00KywP6Z29Xj5x7vQ.png"/></div></div></figure><p id="a59f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用 Scikit-Learn 构建了一个决策树分类器模型。查看<a class="ae mj" href="https://github.com/ZackAkil/rotting-zombie-model/blob/master/Friendly_zombie_predictor.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">笔记本此处</strong> </a>查看做这件事的确切代码。</p><p id="79ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在的计划是将我们的模型部署到<a class="ae mj" href="https://cloud.google.com/ml-engine/" rel="noopener ugc nofollow" target="_blank"> ML 引擎</a>，它将在云上为我们托管我们的模型。(<a class="ae mj" href="https://github.com/ZackAkil/rotting-zombie-model/blob/master/Deploying_a_Sk_Learn_model_to_ML_Engine.ipynb" rel="noopener ugc nofollow" target="_blank"> <em class="mk">在笔记本</em> </a>中查看我们如何使用 gcloud 命令做到这一点)</p><p id="b829" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们将把我们的模型放到云存储中:</p><pre class="ma mb mc md gt ml mm mn mo aw mp bi"><span id="f220" class="mq kx iq mm b gy mr ms l mt mu">gsutil cp model.joblib gs://your-storage-bucket/v1/model.joblib</span></pre><p id="bee9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后创建一个新的 ML 引擎模型，你可以使用 Google Cloud 控制台 UI 或使用<strong class="ka ir"> gcloud </strong>命令(<a class="ae mj" href="https://github.com/ZackAkil/rotting-zombie-model/blob/master/Deploying_a_Sk_Learn_model_to_ML_Engine.ipynb" rel="noopener ugc nofollow" target="_blank"> <em class="mk">，你可以在这里看到在笔记本</em> </a>)来完成:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mv"><img src="../Images/e1d0e35a9a1eeeb25f7e3d9830fe884c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZF3DVx-l5CL92Drwg0L9TQ.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">ML Engine UI</figcaption></figure><p id="609b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们将决策树模型部署为版本 1:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mw"><img src="../Images/227cef87b0772f04defd624caa9f5145.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0sHZ1Xwom_e3hImLqOhZyQ.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Creating a new version of your model using the Cloud Console UI</figcaption></figure><p id="1ba6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了让应用程序更容易从我们的模型中获取预测，我们将使用云函数创建一个公共端点。你可以在我和我的同事 Sara Robinson 写的这篇博客文章中读到更多关于如何做到这一点的内容。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mx"><img src="../Images/bbd3f2bf21e38017a3e226dbec0b7128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1O-GzUlURbvYYyRcQ6XreA.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">here’s the current architecture of our system</figcaption></figure><p id="3a2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，我们的模型已经部署好了，应用程序可以很容易地从中获取预测！现在，使用数据存储监视模型 rot！</p><h1 id="214b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">数据存储？</h1><p id="fa3a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">想象一下，在云中有一个地方，可以快速存储数百万个 python 字典，然后查询它们(也很快)。那就是<a class="ae mj" href="https://cloud.google.com/datastore/" rel="noopener ugc nofollow" target="_blank">数据存储</a>，一个在谷歌云平台上完全托管的 NoSQL 数据库。如果您以前有过使用数据库的经验，那么您可能习惯于仔细计划在表中存储什么样的数据结构，然后体验创建迁移脚本来更新数据库结构的痛苦。对于数据存储来说，不要胡说八道，要存储以下数据:</p><pre class="ma mb mc md gt ml mm mn mo aw mp bi"><span id="45e0" class="mq kx iq mm b gy mr ms l mt mu">{<br/>  "name": "Alex"<br/>  "occupation": "Zombr trainer"<br/>}</span></pre><p id="e094" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后这样做(<em class="mk">使用 python 客户端库</em>):</p><pre class="ma mb mc md gt ml mm mn mo aw mp bi"><span id="150a" class="mq kx iq mm b gy mr ms l mt mu"># create new entity/row<br/>new_person = datastore.Entity(key=client.key('person'))</span><span id="7317" class="mq kx iq mm b gy my ms l mt mu">new_person['name'] = 'Alex'<br/>new_person['occupation'] = 'Zombr trainer'</span><span id="201d" class="mq kx iq mm b gy my ms l mt mu"># save to datastore<br/>client.put(new_person)</span></pre><p id="87e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">哦，等等，你想开始储存人们的 githubs 和 twitters？去做吧:</p><pre class="ma mb mc md gt ml mm mn mo aw mp bi"><span id="ed1e" class="mq kx iq mm b gy mr ms l mt mu"># create new entity/row<br/>new_person = datastore.Entity(key=client.key('person'))</span><span id="e325" class="mq kx iq mm b gy my ms l mt mu">new_person['name'] = 'Zack'<br/>new_person['occupation'] = 'Zombr CEO'<br/>new_person['github'] = '<a class="ae mj" href="https://github.com/zackakil" rel="noopener ugc nofollow" target="_blank">https://github.com/zackakil</a>'<br/>new_person['twitter'] = '<a class="ae mj" href="https://twitter.com/zackakil" rel="noopener ugc nofollow" target="_blank">@zackakil</a>'</span><span id="3e93" class="mq kx iq mm b gy my ms l mt mu"># save to datastore<br/>client.put(new_person)</span></pre><p id="6c23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">数据存储会说“谢谢”:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mz"><img src="../Images/dbda5763377d4738197ab7f61d4d207d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m2cUpreghQwk8Wl75Pjnrw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">DataStore’s UI</figcaption></figure><h1 id="8c42" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使用数据存储收集模型反馈</h1><p id="41d6" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们将要收集的反馈数据如下所示:</p><pre class="ma mb mc md gt ml mm mn mo aw mp bi"><span id="24aa" class="mq kx iq mm b gy mr ms l mt mu">{<br/>"model": "v1",<br/>"prediction input": [2.1, 1.4, 5.3, 8.0],<br/>"prediction output": 1,<br/>"was correct": False,<br/>"time": "23-10-2018,14:45:23"<br/>}</span></pre><p id="2424" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些数据将告诉我们 ML 引擎上的哪个版本的模型用于生成预测(<strong class="ka ir">模型</strong>)、预测的输入数据是什么(<strong class="ka ir">预测输入</strong>)、模型做出的预测是什么(<strong class="ka ir">预测输出</strong>)、预测是否正确(来自用户的实际反馈)(<strong class="ka ir">是正确的</strong>)，以及反馈提交的时间(<strong class="ka ir">时间</strong>)。</p><p id="9473" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将再次使用云函数来创建另一个 web API 端点，这次是为了接收反馈数据并将其存储在数据存储中:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">don’t forget to add “google-cloud-datastore” to the Cloud Function’s requirements.txt</figcaption></figure><p id="d259" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们的系统架构如下所示:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nc"><img src="../Images/858a95e334fc6ea34dabf774b3fe0ea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LEYpFJCmZ3294kR_fMibqQ.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">the new architecture of our system</figcaption></figure><p id="e0cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">客户端应用程序只需要以一种直观的方式添加用户提交他们的反馈。在我们的例子中，它可以是一个简单的“拇指向上或拇指向下”的提示，在用户看到一个预测之后:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nd"><img src="../Images/6741d997ac015cc6663719907d20a0a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5hW0dAlgij1W1fdR_J7WTg.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">You may have come across feedback prompts like this before</figcaption></figure><h1 id="981b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">创造性地收集反馈</h1><p id="9765" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">很多时候，你可以推断出关于你的模型的反馈，而不是像我在<strong class="ka ir"> Zombr </strong>界面<strong class="ka ir">中所做的那样，明确地向用户请求反馈。</strong>例如，如果我们看到用户在预测后立即停止使用应用程序，我们可以使用该数据来指示错误的预测😬。</p><p id="3ec2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到现实中，狗收养机构可能有一个新主人的推荐系统。模型的成功采用率是它自己的性能反馈。如果代理商突然发现系统成功匹配的次数比平时少了很多，那么他们就可以用这个来表明模型已经损坏，可能需要更新。</p><h1 id="b773" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">反馈收集完毕，现在做什么？</h1><p id="6d34" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">现在我们可以分析反馈数据。对于任何数据分析工作，我默认使用 Jupyter 笔记本。</p><p id="9997" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mj" href="https://github.com/ZackAkil/rotting-zombie-model/blob/master/Feedback_analyse_from_DataStore.ipynb" rel="noopener ugc nofollow" target="_blank">点击此处查看我如何从数据存储中获取数据并分析反馈的完整记录</a>。</p><p id="ba7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从数据存储中获取数据的要点是，首先安装数据存储 python 客户端库:</p><pre class="ma mb mc md gt ml mm mn mo aw mp bi"><span id="1467" class="mq kx iq mm b gy mr ms l mt mu">pip install google-cloud-datastore</span></pre><p id="d4c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，您可以导入它并连接到数据存储:</p><pre class="ma mb mc md gt ml mm mn mo aw mp bi"><span id="3e45" class="mq kx iq mm b gy mr ms l mt mu"><strong class="mm ir">from</strong> google.cloud <strong class="mm ir">import</strong> datastore</span><span id="10a8" class="mq kx iq mm b gy my ms l mt mu"><em class="mk"># connect to DataStore</em><br/><strong class="mm ir">client = datastore.Client('your project id')</strong></span><span id="a9cc" class="mq kx iq mm b gy my ms l mt mu"><em class="mk"># query for all prediction-feedback items</em> <br/><strong class="mm ir">query = client.query(kind='prediction-feedback') <br/> </strong><br/><em class="mk"># order by the time field</em> <br/><strong class="mm ir">query.order = ['time'] </strong><br/> <br/><em class="mk"># fetch the items <br/># (returns an iterator so we will empty it into a list)</em> <br/><strong class="mm ir">data = list(query.fetch())</strong></span></pre><p id="b5b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该库自动将所有数据转换成 python 字典:</p><pre class="ma mb mc md gt ml mm mn mo aw mp bi"><span id="3cbe" class="mq kx iq mm b gy mr ms l mt mu">print(data[0]['was correct'])<br/>print(data[0]['model'])<br/>print(data[0]['time'])<br/>print(data[0]['input data'])</span><span id="1113" class="mq kx iq mm b gy my ms l mt mu">&gt;&gt;&gt; True<br/>&gt;&gt;&gt; v1<br/>&gt;&gt;&gt; 2018-10-22 14:21:02.199917+00:00<br/>&gt;&gt;&gt; [-0.8300105114555543, 0.3990742221560673, 1.9084475908892906, 0.3804372006233603]</span></pre><p id="040a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们在反馈数据中保存了一个“was correct”布尔值，我们可以通过查看该字段的“<strong class="ka ir">true”</strong>比率，轻松计算出反馈模型的准确性:</p><pre class="ma mb mc md gt ml mm mn mo aw mp bi"><span id="651f" class="mq kx iq mm b gy mr ms l mt mu">number_of_items = len(data)<br/>number_of_was_correct = len([d <strong class="mm ir">for</strong> d <strong class="mm ir">in</strong> data <strong class="mm ir">if</strong> d['was correct']])</span><span id="61c3" class="mq kx iq mm b gy my ms l mt mu">print(number_of_was_correct / number_of_items)</span><span id="e5ab" class="mq kx iq mm b gy my ms l mt mu">&gt;&gt;&gt; 0.84</span></pre><p id="f2bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">0.84 并不算太糟糕，因为我们<a class="ae mj" href="https://github.com/ZackAkil/rotting-zombie-model/blob/master/Friendly_zombie_predictor.ipynb" rel="noopener ugc nofollow" target="_blank">第一次训练我们的模型</a>，其得分约为 0.9，但这是使用所有反馈数据一起计算的。如果我们在数据的滑动窗口上进行同样的精度计算并绘制出来会怎么样？(<em class="mk">你可以在</em> <a class="ae mj" href="https://github.com/ZackAkil/rotting-zombie-model/blob/master/Feedback_analyse_from_DataStore.ipynb" rel="noopener ugc nofollow" target="_blank"> <em class="mk">分析笔记本</em> </a>里看到这么做的代码)</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/957acc96d70cc86cbdcfc66eeda58da4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*fsLb8wHZohYfFdzwRytfyA.png"/></div></figure><p id="1e73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于最近的反馈，这是一个很大的性能下降。</p><p id="08be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们应该进一步调查。让我们比较高精度和低精度时的输入数据(即僵尸特征数据)。好在我们在反馈中也收集了这些信息:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/c36db95de08705c02deda8b5acdcdf5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*epRqaSvi6ZFhjgflekeGSw.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">blue = correct prediction, red = incorrect prediction</figcaption></figure><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/85e9a62f34bed85dd72b6099cc6ef5fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*u0LnadB81REpsSRmGjdjCw.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">blue = correct prediction, red = incorrect prediction</figcaption></figure><p id="f0b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">啊，数据看起来完全不一样。我猜僵尸种群已经变异了！我们需要尽快用新数据重新训练我们的模型。好在我们收集了反馈中的输入数据，我们可以将其用作新的训练数据(使我们不必手动收集新数据)。我们可以使用有关模型所做预测(“预测”字段)和用户反馈(“正确”字段)的信息来推断新训练数据的正确预测标签:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="805d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mj" href="https://github.com/ZackAkil/rotting-zombie-model/blob/master/Feedback_analyse_from_DataStore.ipynb" rel="noopener ugc nofollow" target="_blank">在反馈分析笔记本</a>的底部查看这段代码是如何使用的。</p><p id="bc79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这个新的数据集，我们可以训练一个新版本的模型。这是与训练初始模型相同的过程，但是使用不同的数据集(<a class="ae mj" href="https://github.com/ZackAkil/rotting-zombie-model/blob/master/Friendly_zombie_predictor_re_train.ipynb" rel="noopener ugc nofollow" target="_blank">参见笔记本</a>)，然后将其作为模型的新版本上传到 ML 引擎。</p><p id="dc01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦它在 ML 引擎上，您可以将其设置为僵尸模型的新默认版本，以便您的所有客户端将自动开始将其预测请求发送到新模型，或者您可以指示您的客户端在其预测请求中指定版本名称:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ng"><img src="../Images/f9ec495573de58352b53df54eb416e4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PjAjfJd5k4S6-JCfYFNHTw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">setting v2 as the default model</figcaption></figure><p id="82e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您将默认模型设置为 v2，那么所有对“僵尸”的预测请求都将转到 v2 版本:</p><pre class="ma mb mc md gt ml mm mn mo aw mp bi"><span id="ca07" class="mq kx iq mm b gy mr ms l mt mu">PREDICTION REQUEST BODY:<br/>{<br/>"instances":[[2.0, 3.4, 5.1, 1.0]],<br/>"model":"zombies"<br/>}</span></pre><p id="8a44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者你的客户可以说得更具体一些:</p><pre class="ma mb mc md gt ml mm mn mo aw mp bi"><span id="4522" class="mq kx iq mm b gy mr ms l mt mu">PREDICTION REQUEST BODY:<br/>{<br/>"instances":[[2.0, 3.4, 5.1, 1.0]],<br/>"model":"zombies/versions/v2"<br/>}</span></pre><p id="c2d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成所有这些后，您可以坐下来，在收集到更多反馈后运行相同的分析:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/08e63832ed0bd79aa80517d91df49a9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*paMZjeQqTQUgzXJekmXWXA.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">seems like people find our v2 model helpful</figcaption></figure><p id="d75f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望这已经给了您一些关于如何监控您部署的模型模型腐烂的想法。使用的所有代码都可以在<a class="ae mj" href="http://ZackAkil/rotting-zombie-model" rel="noopener ugc nofollow" target="_blank"> github repo </a>中找到:</p><div class="ni nj gp gr nk nl"><a href="https://github.com/ZackAkil/rotting-zombie-model" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">ZackAkil/腐烂僵尸模型</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">🧟资源反击腐烂你部署的机器学习模型。预测僵尸！…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">github.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz js nl"/></div></div></a></div><p id="c304" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您对监控模型腐烂有任何想法或问题，请联系我。</p></div></div>    
</body>
</html>