<html>
<head>
<title>A gentle introduction to genetic algorithms with Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Go 对遗传算法的简单介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-gentle-introduction-to-genetic-algorithms-c5bc15827e2d?source=collection_archive---------5-----------------------#2018-01-06">https://towardsdatascience.com/a-gentle-introduction-to-genetic-algorithms-c5bc15827e2d?source=collection_archive---------5-----------------------#2018-01-06</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="664a" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">通过进化蒙娜丽莎引入遗传算法</h2></div><p id="60b6" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">乍一看可能不太明显，但计算机科学算法经常受到自然和生物过程的启发。这些算法包括神经网络、粒子群优化、人工蜂群、蚁群优化、进化算法等等。事实上，你可以把生物过程看作是大自然想出的解决问题的简单算法。从这个角度来看，很容易理解为什么这些算法是优化试探法和元试探法。毕竟，大自然为了生存而优化。</p><p id="738b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><a class="ae lf" href="https://stackoverflow.com/questions/2334225/what-is-the-difference-between-a-heuristic-and-an-algorithm" rel="noopener ugc nofollow" target="_blank">试探法</a>，如果你不熟悉这个术语，是通过做一些假设来试图更快解决问题的算法。因此，试探法通常不是最佳的，但在获得最佳结果需要很长时间的情况下更有用。<a class="ae lf" href="https://www.researchgate.net/post/What_are_the_differences_between_heuristics_and_metaheuristics" rel="noopener ugc nofollow" target="_blank">元启发式</a>把这带到下一个层次——它们是一种产生或发现启发式的启发式方法。</p><h1 id="6624" class="lg lh iu bd li lj lk ll lm ln lo lp lq ka lr kb ls kd lt ke lu kg lv kh lw lx bi translated">遗传算法</h1><p id="4f15" class="pw-post-body-paragraph kj kk iu kl b km ly jv ko kp lz jy kr ks ma ku kv kw mb ky kz la mc lc ld le in bi translated">遗传算法是基于<a class="ae lf" href="https://en.wikipedia.org/wiki/Natural_selection" rel="noopener ugc nofollow" target="_blank">自然选择</a>过程的元启发式算法。遗传算法是一种进化算法。</p><p id="3683" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">自然选择，作为一种更新，是进化中的一个关键机制。这是一个自然过程，随着时间的推移，导致(生物)种群适应它们的环境。这些群体在特征上有所不同。具有更合适特征的个体生物在环境中生存的机会更高。从这些幸存下来的生物体中繁殖的下一代将继承它们的特征，最终产生具有这些更合适特征的种群。</p><p id="2b0c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">然而，如果整个种群都有相同的特征，而环境改变了，种群就会灭绝。幸运的是，偶尔发生的突变会导致性状的变异，这使得具有更适合变化的环境的性状的生物体得以生存并成为主导。</p><p id="1b7f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">一个普遍使用的例子是英国胡椒蛾的颜色变化。在 19 世纪早期之前，英格兰的胡椒蛾大多是白色的，它的颜色有助于它躲避食肉鸟类，因为它与浅色的地衣和英国树木很好地融合在一起。然而，在工业革命期间，浅色的地衣因污染而死亡，许多飞蛾栖息的树木被煤烟熏黑。这使得深色的蛾子在躲避捕食者时具有优势，而浅色的蛾子很容易被发现。到了 19 世纪中期，深色蛾子的数量增加了，到了 19 世纪末，几乎所有的胡椒蛾都是深色品种。1956 年《清洁空气法案》的影响打破了这种平衡，深色的蛾子又变得罕见了。</p><figure class="me mf mg mh gu mi gi gj paragraph-image"><div class="gi gj md"><img src="../Images/47e0ef5be1cba9a873c763457683ed57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*BRZHhjKVHky6Xt6G7cuzkg.jpeg"/></div><figcaption class="ml mm gk gi gj mn mo bd b be z dk">Peppered moth (credits: <a class="ae lf" href="https://commons.wikimedia.org/wiki/File:Lichte_en_zwarte_versie_berkenspanner_crop.jpg" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/wiki/File:Lichte_en_zwarte_versie_berkenspanner_crop.jpg</a>)</figcaption></figure><p id="78f3" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这就是自然选择。遗传算法是如何出现的？遗传算法是启发式的，使用与自然选择相同的机制——DNA、种群、变异、适应度、选择、繁殖、遗传和突变。</p><ul class=""><li id="a2c5" class="mp mq iu kl b km kn kp kq ks mr kw ms la mt le mu mv mw mx bi translated"><em class="my">DNA</em>——定义拥有一个或多个 DNA 的生物体</li><li id="6b9f" class="mp mq iu kl b km mz kp na ks nb kw nc la nd le mu mv mw mx bi translated"><em class="my">种群</em>——从 DNA 基因(值)不同的生物体初始种群开始</li><li id="e5a6" class="mp mq iu kl b km mz kp na ks nb kw nc la nd le mu mv mw mx bi translated"><em class="my">适合度</em> —确定每种生物对其环境的适合度</li><li id="3429" class="mp mq iu kl b km mz kp na ks nb kw nc la nd le mu mv mw mx bi translated"><em class="my">选择</em>——选择最适合的生物，给它们更高的繁殖机会</li><li id="9cdb" class="mp mq iu kl b km mz kp na ks nb kw nc la nd le mu mv mw mx bi translated"><em class="my">繁殖</em> —从选择的最适合的生物体中创造下一代种群</li><li id="77b9" class="mp mq iu kl b km mz kp na ks nb kw nc la nd le mu mv mw mx bi translated"><em class="my">遗传</em> —人口的下一代必须继承基因的值</li><li id="4f04" class="mp mq iu kl b km mz kp na ks nb kw nc la nd le mu mv mw mx bi translated"><em class="my">突变</em>——每一代人的基因值都有微小的变化</li></ul><h1 id="53a7" class="lg lh iu bd li lj lk ll lm ln lo lp lq ka lr kb ls kd lt ke lu kg lv kh lw lx bi translated">猴子、打字机和莎士比亚</h1><p id="016e" class="pw-post-body-paragraph kj kk iu kl b km ly jv ko kp lz jy kr ks ma ku kv kw mb ky kz la mc lc ld le in bi translated"><a class="ae lf" href="http://www.ietf.org/rfc/rfc2795.txt" rel="noopener ugc nofollow" target="_blank">无限猴子定理</a>说的是，无限数量的猴子坐在无限数量的打字机前随机敲击键盘，只要给足够的时间，最终会重现莎士比亚的全集。假设我们只想让一只猴子复制这句话:<em class="my">“生存还是毁灭”。</em>你觉得猴子随机锤出这个要多长时间？</p><figure class="me mf mg mh gu mi gi gj paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gi gj ne"><img src="../Images/ba31d5c5c791cf0b1d4c18f5b06544a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EyduUuShUfAYIfYAwNq35A.jpeg"/></div></div><figcaption class="ml mm gk gi gj mn mo bd b be z dk">Monkeying around with Shakespeare (credits: <a class="ae lf" href="https://commons.wikimedia.org/wiki/File:Chimpanzee_seated_at_typewriter.jpg" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/wiki/File:Chimpanzee_seated_at_typewriter.jpg</a>)</figcaption></figure><p id="e39e" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">报价有 18 个字符(包括空格)。猴子打出<em class="my">【t】</em>(姑且说全是小盘也可以)的概率是 26 分之一。因此，键入确切序列<em class="my">“生存还是毁灭”</em>的概率是 26 的 18 次方分之一，或者是大约 29，479，510，200，013，920，000，000，000 的 1 分之一。假设猴子每秒钟打一封信，那么在 934，789，136，225，707，600 年中，它只有 1 次机会打出这句话。这是 934 万亿年的 1 倍。</p><p id="2569" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">显然，这种野蛮的方式不会让我们有任何进展。如果我们尝试“改进”报价会怎么样？让我们看看如何使用遗传算法来做到这一点。下面是用于解决该问题的遗传算法的步骤:</p><h2 id="cf60" class="nj lh iu bd li nk nl dn lm nm nn dp lq ks no np ls kw nq nr lu la ns nt lw nu bi translated">定义由一个或多个 DNA 组成的有机体</h2><p id="8f6f" class="pw-post-body-paragraph kj kk iu kl b km ly jv ko kp lz jy kr ks ma ku kv kw mb ky kz la mc lc ld le in bi translated">我们的莎士比亚-喷算法中的一个生物体由单个 DNA 组成，它是一个字节数组和一个代表生物体适应度的数字。</p><pre class="me mf mg mh gu nv nw nx ny aw nz bi"><span id="db2d" class="nj lh iu nw b gz oa ob l oc od">type Organism struct {<br/>	DNA    []byte<br/>	Fitness float64<br/>}</span></pre><p id="0894" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">从最初的生物群体开始</p><p id="9b1f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们需要为我们的初始种群创建有机体，所以这里有一个函数来做这件事。</p><pre class="me mf mg mh gu nv nw nx ny aw nz bi"><span id="90af" class="nj lh iu nw b gz oa ob l oc od">func createOrganism(target []byte) (organism Organism) {<br/>	ba := make([]byte, len(target))<br/>	for i := 0; i &lt; len(target); i++ {<br/>		ba[i] = byte(rand.Intn(95) + 32)<br/>	}<br/>	organism = Organism{<br/>		DNA:    ba,<br/>		Fitness: 0,<br/>	}<br/>	organism.calcFitness(target)<br/>	return<br/>}</span></pre><p id="3918" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe oe of og nw b">target</code>是我们想要实现的，在这种情况下，它是字符串“生存还是毁灭”的字节数组表示。在这个函数中，我们随机创建一个与目标长度相同的字节数组，并将其设置为新创建的生物体中基因的值。</p><p id="bedd" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">既然我们可以创造生物体，我们需要创造一个生物体群体。</p><pre class="me mf mg mh gu nv nw nx ny aw nz bi"><span id="6cc7" class="nj lh iu nw b gz oa ob l oc od">func createPopulation(target []byte) (population []Organism) {<br/>	population = make([]Organism, PopSize)<br/>	for i := 0; i &lt; PopSize; i++ {<br/>		population[i] = createOrganism(target)<br/>	}<br/>	return<br/>}</span></pre><p id="d82f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe oe of og nw b">population</code>是一组生物体，而<code class="fe oe of og nw b">PopSize</code>是一个定义种群规模的全局变量。</p><h2 id="6cbb" class="nj lh iu bd li nk nl dn lm nm nn dp lq ks no np ls kw nq nr lu la ns nt lw nu bi translated">找到生物体的适合度</h2><p id="9c05" class="pw-post-body-paragraph kj kk iu kl b km ly jv ko kp lz jy kr ks ma ku kv kw mb ky kz la mc lc ld le in bi translated">我们需要计算我们种群中生物体的适合度。这在我们创造有机体时被称为早期，但在我们交叉有机体时也会被称为晚期。</p><pre class="me mf mg mh gu nv nw nx ny aw nz bi"><span id="d3bd" class="nj lh iu nw b gz oa ob l oc od">func (d *Organism) calcFitness(target []byte) {<br/>	score := 0<br/>	for i := 0; i &lt; len(d.DNA); i++ {<br/>		if d.DNA[i] == target[i] {<br/>			score++<br/>		}<br/>	}<br/>	d.Fitness = float64(score) / float64(len(d.DNA))<br/>	return<br/>}</span></pre><p id="3224" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这个健身功能比较简单。我们简单地计算基因中的字节与目标匹配的次数。分数除以目标中的总字节数，以使适合度为一个百分比，即 0.0 到 1.0 之间的数字。这意味着如果适应度是 1.0，我们将进化生物体的基因以匹配“生存还是毁灭”的引用。</p><h2 id="cb4c" class="nj lh iu bd li nk nl dn lm nm nn dp lq ks no np ls kw nq nr lu la ns nt lw nu bi translated">选择最适合的生物，给它们更高的繁殖机会</h2><p id="bbcd" class="pw-post-body-paragraph kj kk iu kl b km ly jv ko kp lz jy kr ks ma ku kv kw mb ky kz la mc lc ld le in bi translated">现在我们有了一个种群，我们可以找出哪些生物最适合，我们想挑选最适合的生物，让它们繁殖来创造种群的下一代。有许多不同的方法可以做到这一点，但在这种情况下，我们使用的是一种“繁殖池”机制。</p><pre class="me mf mg mh gu nv nw nx ny aw nz bi"><span id="e8fc" class="nj lh iu nw b gz oa ob l oc od">func createPool(population []Organism, target []byte, maxFitness float64) (pool []Organism) {<br/>	pool = make([]Organism, 0)<br/>	// create a pool for next generation<br/>	for i := 0; i &lt; len(population); i++ {<br/>		population[i].calcFitness(target)<br/>		num := int((population[i].Fitness / maxFitness) * 100)<br/>		for n := 0; n &lt; num; n++ {<br/>			pool = append(pool, population[i])<br/>		}<br/>	}<br/>	return<br/>}</span></pre><p id="92bb" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们所做的是创造一种繁殖池，在这里我根据生物的适合度将相同生物的多个副本放入池中。有机体的适应度越高，池中就有越多的有机体副本。</p><h2 id="d135" class="nj lh iu bd li nk nl dn lm nm nn dp lq ks no np ls kw nq nr lu la ns nt lw nu bi translated">从所选择的最适合的生物体中创建种群的下一代</h2><p id="de0d" class="pw-post-body-paragraph kj kk iu kl b km ly jv ko kp lz jy kr ks ma ku kv kw mb ky kz la mc lc ld le in bi translated">之后，我们从繁殖池中随机挑选 2 个生物体，用它们作为亲本，为种群创造下一代生物体。</p><pre class="me mf mg mh gu nv nw nx ny aw nz bi"><span id="b11c" class="nj lh iu nw b gz oa ob l oc od">func naturalSelection(pool []Organism, population []Organism, target []byte) []Organism {<br/>	next := make([]Organism, len(population))</span><span id="fdb0" class="nj lh iu nw b gz oh ob l oc od">	for i := 0; i &lt; len(population); i++ {<br/>		r1, r2 := rand.Intn(len(pool)), rand.Intn(len(pool))<br/>		a := pool[r1]<br/>		b := pool[r2]</span><span id="f651" class="nj lh iu nw b gz oh ob l oc od">		child := crossover(a, b)<br/>		child.mutate()<br/>		child.calcFitness(target)</span><span id="eea9" class="nj lh iu nw b gz oh ob l oc od">		next[i] = child<br/>	}<br/>	return next<br/>}</span></pre><h2 id="fe1c" class="nj lh iu bd li nk nl dn lm nm nn dp lq ks no np ls kw nq nr lu la ns nt lw nu bi translated">人口的下一代必须继承基因的价值</h2><p id="ea26" class="pw-post-body-paragraph kj kk iu kl b km ly jv ko kp lz jy kr ks ma ku kv kw mb ky kz la mc lc ld le in bi translated">然后，下一代的<code class="fe oe of og nw b">child</code>由两个随机挑选的生物体杂交而成，<em class="my">继承了两个生物体的</em>DNA。</p><pre class="me mf mg mh gu nv nw nx ny aw nz bi"><span id="b9f4" class="nj lh iu nw b gz oa ob l oc od">func crossover(d1 Organism, d2 Organism) Organism {<br/>	child := Organism{<br/>		DNA:    make([]byte, len(d1.DNA)),<br/>		Fitness: 0,<br/>	}<br/>	mid := rand.Intn(len(d1.DNA))<br/>	for i := 0; i &lt; len(d1.DNA); i++ {<br/>		if i &gt; mid {<br/>			child.DNA[i] = d1.DNA[i]<br/>		} else {<br/>			child.DNA[i] = d2.DNA[i]<br/>		}</span><span id="938f" class="nj lh iu nw b gz oh ob l oc od">	}<br/>	return child<br/>}</span></pre><p id="b344" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">对于交叉，我简单地选择了一个中点<code class="fe oe of og nw b">mid</code>，并使用第一个生物体的第一个<code class="fe oe of og nw b">mid</code>字节和第二个生物体的剩余字节。</p><h2 id="9ee6" class="nj lh iu bd li nk nl dn lm nm nn dp lq ks no np ls kw nq nr lu la ns nt lw nu bi translated">随机变异每一代</h2><p id="5536" class="pw-post-body-paragraph kj kk iu kl b km ly jv ko kp lz jy kr ks ma ku kv kw mb ky kz la mc lc ld le in bi translated">在一个新的子有机体从两个亲代有机体中复制出来后，我们观察子有机体是否发生了突变。</p><pre class="me mf mg mh gu nv nw nx ny aw nz bi"><span id="bad5" class="nj lh iu nw b gz oa ob l oc od">func (d *Organism) mutate() {<br/>	for i := 0; i &lt; len(d.DNA); i++ {<br/>		if rand.Float64() &lt; MutationRate {<br/>			d.DNA[i] = byte(rand.Intn(95) + 32)<br/>		}<br/>	}<br/>}</span></pre><p id="62ca" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这里的突变仅仅意味着确定一个随机生成的数是否低于<code class="fe oe of og nw b">MutationRate</code>。为什么我们需要突变子生物体？如果突变从未发生，群体中的 DNA 将始终保持与原始群体相同。这意味着如果原始种群没有所需的特定基因(值),将永远无法获得最佳结果。就像在这个例子中，如果字母<code class="fe oe of og nw b">t</code>在初始种群中根本找不到，那么无论我们经历多少代，我们都无法得出这个引用。换句话说，没有突变，自然选择就不起作用。</p><p id="2463" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">更专业地说，突变让我们摆脱局部最大值，以找到全局最大值。如果我们将遗传算法视为一种寻找最优解的机制，如果我们没有突变，一旦找到局部最大值，该机制将简单地停留在这一点上，而不会继续寻找全局最大值。突变可以使群体跳出局部最大值，因此为算法提供了继续寻找全局最大值的机会。</p><p id="abe0" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">一旦我们检查了突变，我们就计算出子生物体的适应度，并将其插入到下一代种群中。</p><p id="a5b0" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这就是遗传算法的全部内容！现在让我们把它们放在<code class="fe oe of og nw b">main</code>函数中。</p><pre class="me mf mg mh gu nv nw nx ny aw nz bi"><span id="0b54" class="nj lh iu nw b gz oa ob l oc od">func main() {<br/>	start := time.Now()<br/>	rand.Seed(time.Now().UTC().UnixNano())</span><span id="e3e0" class="nj lh iu nw b gz oh ob l oc od">	target := []byte("To be or not to be")<br/>	population := createPopulation(target)</span><span id="b515" class="nj lh iu nw b gz oh ob l oc od">	found := false<br/>	generation := 0<br/>	for !found {<br/>		generation++<br/>		bestOrganism := getBest(population)<br/>		fmt.Printf("\r generation: %d | %s | fitness: %2f", generation, string(bestOrganism.DNA), bestOrganism.Fitness)</span><span id="60b3" class="nj lh iu nw b gz oh ob l oc od">		if bytes.Compare(bestOrganism.DNA, target) == 0 {<br/>			found = true<br/>		} else {<br/>			maxFitness := bestOrganism.Fitness<br/>			pool := createPool(population, target, maxFitness)<br/>			population = naturalSelection(pool, population, target)<br/>		}</span><span id="d662" class="nj lh iu nw b gz oh ob l oc od">	}<br/>	elapsed := time.Since(start)<br/>	fmt.Printf("\nTime taken: %s\n", elapsed)<br/>}</span></pre><p id="8650" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在主函数中，我们经历了几代，每一代我们都试图找到最适合的有机体。如果最适合的生物体的基因与目标相同，我们就会找到答案。</p><p id="a16c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">现在运行软件程序！你花了多长时间？</p><figure class="me mf mg mh gu mi gi gj paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gi gj oi"><img src="../Images/a36c93879935863c7940cea9881bd384.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OIQZEGN9G3dW9Rsjg8xVRg.png"/></div></div></figure><p id="705b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">因为初始群体是随机生成的，所以每次您都会得到不同的答案，但大多数情况下，我们可以在不到一秒钟的时间内完成报价！如果我们不得不强行计算的话，这与 934 万亿年有很大的不同。</p><h1 id="a532" class="lg lh iu bd li lj lk ll lm ln lo lp lq ka lr kb ls kd lt ke lu kg lv kh lw lx bi translated">进化中的蒙娜丽莎</h1><p id="dc77" class="pw-post-body-paragraph kj kk iu kl b km ly jv ko kp lz jy kr ks ma ku kv kw mb ky kz la mc lc ld le in bi translated">进化莎士比亚似乎很简单。毕竟只是一串。来点不同的怎么样，比如说一个图像？还是有史以来最著名的画作，达芬奇的《蒙娜丽莎》?我们能进化吗？</p><figure class="me mf mg mh gu mi gi gj paragraph-image"><div class="ab gv cl oj"><img src="../Images/2f20e986243eeed7083017b488e768ab.png" data-original-src="https://miro.medium.com/v2/format:webp/0*Oc0TiXUTZ931knmM.png"/></div><figcaption class="ml mm gk gi gj mn mo bd b be z dk">Mona Lisa (public domain)</figcaption></figure><p id="5206" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">让我们给它同样的待遇。我们将从定义生物体来代表蒙娜丽莎的照片开始。</p><h2 id="92f9" class="nj lh iu bd li nk nl dn lm nm nn dp lq ks no np ls kw nq nr lu la ns nt lw nu bi translated">定义由一个或多个 DNA 组成的有机体</h2><p id="4e51" class="pw-post-body-paragraph kj kk iu kl b km ly jv ko kp lz jy kr ks ma ku kv kw mb ky kz la mc lc ld le in bi translated">我们的 DNA 不再是字节数组，而是来自<code class="fe oe of og nw b">image</code>标准库的结构。</p><pre class="me mf mg mh gu nv nw nx ny aw nz bi"><span id="a658" class="nj lh iu nw b gz oa ob l oc od">type Organism struct {<br/>	DNA     *image.RGBA<br/>	Fitness int64<br/>}</span></pre><h2 id="2160" class="nj lh iu bd li nk nl dn lm nm nn dp lq ks no np ls kw nq nr lu la ns nt lw nu bi translated">从最初的生物群体开始</h2><p id="8dd4" class="pw-post-body-paragraph kj kk iu kl b km ly jv ko kp lz jy kr ks ma ku kv kw mb ky kz la mc lc ld le in bi translated">像以前一样，让我们先看看如何创造一个有机体。</p><pre class="me mf mg mh gu nv nw nx ny aw nz bi"><span id="d890" class="nj lh iu nw b gz oa ob l oc od">func createOrganism(target *image.RGBA) (organism Organism) {<br/>	organism = Organism{<br/>		DNA:     createRandomImageFrom(target),<br/>		Fitness: 0,<br/>	}<br/>	organism.calcFitness(target)<br/>	return<br/>}</span></pre><p id="1d58" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们不创建随机字节数组，而是调用另一个函数来创建随机图像。</p><pre class="me mf mg mh gu nv nw nx ny aw nz bi"><span id="7efa" class="nj lh iu nw b gz oa ob l oc od">func createRandomImageFrom(img *image.RGBA) (created *image.RGBA) {<br/>	pix := make([]uint8, len(img.Pix))<br/>	rand.Read(pix)<br/>	created = &amp;image.RGBA{<br/>		Pix:    pix,<br/>		Stride: img.Stride,<br/>		Rect:   img.Rect,<br/>	}<br/>	return<br/>}</span></pre><p id="b935" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">一个<code class="fe oe of og nw b">image.RGBA</code> struct 由一个字节数组<code class="fe oe of og nw b">Pix</code> ( <code class="fe oe of og nw b">byte</code>和<code class="fe oe of og nw b">uint8</code>是一回事)、一个<code class="fe oe of og nw b">Stride</code>和一个<code class="fe oe of og nw b">Rect</code>组成。对我们来说重要的是<code class="fe oe of og nw b">Pix</code>，我们使用相同的<code class="fe oe of og nw b">Stride</code>和<code class="fe oe of og nw b">Rect</code>作为目标图像(这是蒙娜丽莎的图像)。幸运的是，<code class="fe oe of og nw b">math/rand</code>标准库有一个名为<code class="fe oe of og nw b">Read</code>的方法，可以用随机字节很好地填充一个字节数组。</p><p id="bdc8" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">你可能会好奇，那么我们在这里讨论的字节数组有多大呢？<code class="fe oe of og nw b">Pix</code>无非是用 4 个字节代表一个像素的字节数组(R，G，B，A 各用一个字节表示)。对于一个 800 x 600 的图像，我们谈论的是每个图像中有 192 万字节！为了保持程序相对较快的速度，我们将使用一个 67 x 100 大小的较小图像，它给出了一个 26，800 字节的数组。如果你到现在还没有意识到，这和我们在上一个程序中使用的 18 字节相差甚远。</p><p id="153b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">此外，你可能会意识到，因为每个像素现在是随机着色的，我们最终会得到一个彩色的静态雪花图案。</p><figure class="me mf mg mh gu mi gi gj paragraph-image"><div class="gi gj ok"><img src="../Images/40817b4a18262ad3fe85abbef609dde9.png" data-original-src="https://miro.medium.com/v2/resize:fit:134/format:webp/1*3sfas3j8st-s4FxClON3kw.png"/></div><figcaption class="ml mm gk gi gj mn mo bd b be z dk">Randomly generate image</figcaption></figure><p id="901f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们继续吧。</p><h2 id="bbc4" class="nj lh iu bd li nk nl dn lm nm nn dp lq ks no np ls kw nq nr lu la ns nt lw nu bi translated">找到生物体的适合度</h2><p id="c287" class="pw-post-body-paragraph kj kk iu kl b km ly jv ko kp lz jy kr ks ma ku kv kw mb ky kz la mc lc ld le in bi translated">有机体的适合度是两个图像之间的差异。</p><pre class="me mf mg mh gu nv nw nx ny aw nz bi"><span id="f7dd" class="nj lh iu nw b gz oa ob l oc od">// calculate the fitness of an organism<br/>func (o *Organism) calcFitness(target *image.RGBA) {<br/>	difference := diff(o.DNA, target)<br/>	if difference == 0 {<br/>		o.Fitness = 1<br/>	}<br/>	o.Fitness = difference</span><span id="8c51" class="nj lh iu nw b gz oh ob l oc od">}</span><span id="0363" class="nj lh iu nw b gz oh ob l oc od">// find the difference between 2 images<br/>func diff(a, b *image.RGBA) (d int64) {<br/>	d = 0<br/>	for i := 0; i &lt; len(a.Pix); i++ {<br/>		d += int64(squareDifference(a.Pix[i], b.Pix[i]))<br/>	}<br/>	return int64(math.Sqrt(float64(d)))<br/>}</span><span id="eb88" class="nj lh iu nw b gz oh ob l oc od">// square the difference between 2 uint8s<br/>func squareDifference(x, y uint8) uint64 {<br/>	d := uint64(x) - uint64(y)<br/>	return d * d<br/>}</span></pre><p id="92d7" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">为了找到区别，我们可以回到勾股定理。如果你记得，我们可以找到两点之间的距离，如果我们平方<code class="fe oe of og nw b">x</code>和<code class="fe oe of og nw b">y</code>值的差，将它们相加，然后平方根结果。</p><figure class="me mf mg mh gu mi gi gj paragraph-image"><div class="gi gj ol"><img src="../Images/a3fb185dad09ae05e701cb2596465c74.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*v6W2zAj-PpjQv3tdagW-CA.png"/></div><figcaption class="ml mm gk gi gj mn mo bd b be z dk">Pythagorean theorem</figcaption></figure><p id="c132" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">给 2 个点<code class="fe oe of og nw b">a</code> (x1，y1)和<code class="fe oe of og nw b">b</code> (x2，y2)，<code class="fe oe of og nw b">a</code>和<code class="fe oe of og nw b">b</code>之间的距离<code class="fe oe of og nw b">d</code>为:</p><figure class="me mf mg mh gu mi gi gj paragraph-image"><div class="gi gj ol"><img src="../Images/aeef4ab7f308dbf3a7c6f8494d3b868f.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*kGBIOWZGj6OTExE646cnJw.png"/></div></figure><p id="e398" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">那是在二维空间。在三维空间中，我们简单地做两次勾股定理，在四维空间中，我们做三次。一个像素的 RGBA 值本质上是 4 维空间中的一个点，因此为了找出两个像素之间的差异，我们对两个像素的<code class="fe oe of og nw b">r</code>、<code class="fe oe of og nw b">g</code>、<code class="fe oe of og nw b">b</code>和<code class="fe oe of og nw b">a</code>值之间的差异求平方，将它们相加，然后对结果求平方根。</p><figure class="me mf mg mh gu mi gi gj paragraph-image"><div class="gi gj om"><img src="../Images/02cef400a3d42e67bf208fb5eb5f0a35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*_6_oxWHpsftlisg4ChDyIA.png"/></div></figure><p id="8921" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这就是 2 个像素的区别。为了找出所有像素之间的差异，我们只需将所有结果加在一起，就可以得到最终的差异。因为<code class="fe oe of og nw b">Pix</code>本质上是一个包含连续 RGBA 值的长字节数组，所以我们可以使用一个简单的快捷方式。我们简单地平方图像和目标中每个对应字节之间的差异，然后将它们全部相加，并对最终数字求平方根，以找到两个图像之间的差异。</p><p id="dcae" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">作为参考，如果两个图像完全相同，差异将为 0，如果两个图像完全相反，差异将为 26，800。换句话说，最适合的生物体应该具有 0 的适合度，并且数字越高，生物体越不适合。</p><h2 id="e7d6" class="nj lh iu bd li nk nl dn lm nm nn dp lq ks no np ls kw nq nr lu la ns nt lw nu bi translated">选择最适合的生物，给它们更高的繁殖机会</h2><p id="4ac0" class="pw-post-body-paragraph kj kk iu kl b km ly jv ko kp lz jy kr ks ma ku kv kw mb ky kz la mc lc ld le in bi translated">我们仍然使用繁殖池机制，但有所不同。首先，我们将人群从最佳健康状态到最差健康状态进行排序。然后我们把最好的生物放入繁殖池。我们使用一个参数<code class="fe oe of og nw b">PoolSize</code>来表示我们希望池中有多少最适合的生物体。</p><p id="3852" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">为了计算出应该把什么放入繁殖池，我们减去每一个最好的生物体，最不适合的生物体在最上面。这在最好的生物体之间产生了不同的等级，并且根据该不同的等级，我们将该生物体的相应数量的拷贝放入繁殖池中。例如，如果最适合的生物体和最不适合的生物体之间的差异是 20，我们将 20 个生物体放入育种池。</p><p id="46d5" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果最适合的生物之间没有差异，这意味着种群是稳定的，我们不能真正创造一个合适的繁殖池。为了克服这一点，如果差值为 0，我们将池设置为整个群体。</p><pre class="me mf mg mh gu nv nw nx ny aw nz bi"><span id="c0ed" class="nj lh iu nw b gz oa ob l oc od">func createPool(population []Organism, target *image.RGBA) (pool []Organism) {<br/>	pool = make([]Organism, 0)<br/>	// get top best fitting organisms<br/>	sort.SliceStable(population, func(i, j int) bool {<br/>		return population[i].Fitness &lt; population[j].Fitness<br/>	})<br/>	top := population[0 : PoolSize+1]<br/>	// if there is no difference between the top  organisms, the population is stable<br/>	// and we can't get generate a proper breeding pool so we make the pool equal to the<br/>	// population and reproduce the next generation<br/>	if top[len(top)-1].Fitness-top[0].Fitness == 0 {<br/>		pool = population<br/>		return<br/>	}<br/>	// create a pool for next generation<br/>	for i := 0; i &lt; len(top)-1; i++ {<br/>		num := (top[PoolSize].Fitness - top[i].Fitness)<br/>		for n := int64(0); n &lt; num; n++ {<br/>			pool = append(pool, top[i])<br/>		}<br/>	}<br/>	return<br/>}</span></pre><h2 id="b112" class="nj lh iu bd li nk nl dn lm nm nn dp lq ks no np ls kw nq nr lu la ns nt lw nu bi translated">从所选择的最适合的生物体中创建种群的下一代</h2><p id="3a03" class="pw-post-body-paragraph kj kk iu kl b km ly jv ko kp lz jy kr ks ma ku kv kw mb ky kz la mc lc ld le in bi translated">有了游泳池之后，我们需要创造下一代。这里自然选择的代码和前面的程序没有什么不同，所以我们在这里就不展示了。</p><h2 id="d2cf" class="nj lh iu bd li nk nl dn lm nm nn dp lq ks no np ls kw nq nr lu la ns nt lw nu bi translated">人口的下一代必须继承基因的价值</h2><p id="6abb" class="pw-post-body-paragraph kj kk iu kl b km ly jv ko kp lz jy kr ks ma ku kv kw mb ky kz la mc lc ld le in bi translated"><code class="fe oe of og nw b">crossover</code>函数略有不同，因为孩子的 DNA 不是字节数组，而是 image.RGBA。实际的交叉机制在<code class="fe oe of og nw b">Pix</code>上工作，而是像素的字节数组。</p><pre class="me mf mg mh gu nv nw nx ny aw nz bi"><span id="cc80" class="nj lh iu nw b gz oa ob l oc od">func crossover(d1 Organism, d2 Organism) Organism {<br/>	pix := make([]uint8, len(d1.DNA.Pix))<br/>	child := Organism{<br/>		DNA: &amp;image.RGBA{<br/>			Pix:    pix,<br/>			Stride: d1.DNA.Stride,<br/>			Rect:   d1.DNA.Rect,<br/>		},<br/>		Fitness: 0,<br/>	}<br/>	mid := rand.Intn(len(d1.DNA.Pix))<br/>	for i := 0; i &lt; len(d1.DNA.Pix); i++ {<br/>		if i &gt; mid {<br/>			child.DNA.Pix[i] = d1.DNA.Pix[i]<br/>		} else {<br/>			child.DNA.Pix[i] = d2.DNA.Pix[i]<br/>		}</span><span id="2edb" class="nj lh iu nw b gz oh ob l oc od">	}<br/>	return child<br/>}</span></pre><h2 id="078c" class="nj lh iu bd li nk nl dn lm nm nn dp lq ks no np ls kw nq nr lu la ns nt lw nu bi translated">随机变异每一代</h2><p id="a469" class="pw-post-body-paragraph kj kk iu kl b km ly jv ko kp lz jy kr ks ma ku kv kw mb ky kz la mc lc ld le in bi translated"><code class="fe oe of og nw b">mutate</code>功能也相应不同。</p><pre class="me mf mg mh gu nv nw nx ny aw nz bi"><span id="01a3" class="nj lh iu nw b gz oa ob l oc od">func (o *Organism) mutate() {<br/>	for i := 0; i &lt; len(o.DNA.Pix); i++ {<br/>		if rand.Float64() &lt; MutationRate {<br/>			o.DNA.Pix[i] = uint8(rand.Intn(255))<br/>		}<br/>	}<br/>}</span></pre><p id="92a3" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">现在我们已经有了所有的东西，我们把它们放在<code class="fe oe of og nw b">main</code>函数中。</p><pre class="me mf mg mh gu nv nw nx ny aw nz bi"><span id="d624" class="nj lh iu nw b gz oa ob l oc od">func main() {<br/>	start := time.Now()<br/>	rand.Seed(time.Now().UTC().UnixNano())<br/>	target := load("./ml.png")<br/>	printImage(target.SubImage(target.Rect))<br/>	population := createPopulation(target)</span><span id="a44e" class="nj lh iu nw b gz oh ob l oc od">	found := false<br/>	generation := 0<br/>	for !found {<br/>		generation++<br/>		bestOrganism := getBest(population)<br/>		if bestOrganism.Fitness &lt; FitnessLimit {<br/>			found = true<br/>		} else {<br/>			pool := createPool(population, target)<br/>			population = naturalSelection(pool, population, target)<br/>			if generation%100 == 0 {<br/>				sofar := time.Since(start)<br/>				fmt.Printf("\nTime taken so far: %s | generation: %d | fitness: %d | pool size: %d", <br/>				sofar, generation, bestOrganism.Fitness, len(pool))<br/>				save("./evolved.png", bestOrganism.DNA)<br/>				fmt.Println()<br/>				printImage(bestOrganism.DNA.SubImage(bestOrganism.DNA.Rect))<br/>			}<br/>		}<br/>	}<br/>	elapsed := time.Since(start)<br/>	fmt.Printf("\nTotal time taken: %s\n", elapsed)<br/>}</span></pre><p id="f595" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">现在运行它看看。你得到了什么？</p><figure class="me mf mg mh gu mi gi gj paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gi gj on"><img src="../Images/e23bddcc641a4d7f120018656a465c69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fN16NSvowd7uGT698FAKFQ.png"/></div></div><figcaption class="ml mm gk gi gj mn mo bd b be z dk">Start evolving Mona Lisa</figcaption></figure><p id="78ca" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">按照我设置的参数，当我运行它时，我通常会以 19，000 左右的健身值开始。平均来说，我需要 20 多分钟才能达到低于 7500 的体能。</p><figure class="me mf mg mh gu mi gi gj paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gi gj on"><img src="../Images/1485e3594b689b3aff8cc071895ae5ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jAbyBLCcnRebDkZTdzdcUA.png"/></div></div><figcaption class="ml mm gk gi gj mn mo bd b be z dk">After about 20 minutes</figcaption></figure><p id="366a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这是一系列随着时间推移而产生的图像:</p><figure class="me mf mg mh gu mi gi gj paragraph-image"><div class="gi gj oo"><img src="../Images/e8551d28ac4f5f25148148e9f01cbc1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*Ayq7ItK4bGlcr0J6bgx01A.png"/></div><figcaption class="ml mm gk gi gj mn mo bd b be z dk">Evolving Mona Lisa</figcaption></figure><h1 id="7b9c" class="lg lh iu bd li lj lk ll lm ln lo lp lq ka lr kb ls kd lt ke lu kg lv kh lw lx bi translated">用圆形和三角形进化蒙娜丽莎</h1><p id="a76b" class="pw-post-body-paragraph kj kk iu kl b km ly jv ko kp lz jy kr ks ma ku kv kw mb ky kz la mc lc ld le in bi translated">我通过在一张图片上画圆圈和三角形来玩《蒙娜丽莎》的演变。结果没有那么快，图像也没有那么明显，但它显示了实际发生的一瞥。你可以从资源库中找到剩下的代码，自己调整参数，看看是否能得到更好的图片，但这里有一些我得到的图片。</p><h2 id="827c" class="nj lh iu bd li nk nl dn lm nm nn dp lq ks no np ls kw nq nr lu la ns nt lw nu bi translated">蒙娜丽莎三角形</h2><figure class="me mf mg mh gu mi gi gj paragraph-image"><div class="gi gj op"><img src="../Images/c88306371f8be3adf4e51cfeef5e9bb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*5kCzqIvn_lm7D1B6dt0wtg.png"/></div></figure><h2 id="abec" class="nj lh iu bd li nk nl dn lm nm nn dp lq ks no np ls kw nq nr lu la ns nt lw nu bi translated">蒙娜丽莎的圆圈</h2><figure class="me mf mg mh gu mi gi gj paragraph-image"><div class="gi gj oq"><img src="../Images/d8af4df06755f8ac4b94e305075e0357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*2mcUXvUJeNxiJZsEy_n5Dg.png"/></div></figure><p id="5ef0" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">玩得开心！</p><h1 id="297f" class="lg lh iu bd li lj lk ll lm ln lo lp lq ka lr kb ls kd lt ke lu kg lv kh lw lx bi translated">在终端上显示图像</h1><p id="736b" class="pw-post-body-paragraph kj kk iu kl b km ly jv ko kp lz jy kr ks ma ku kv kw mb ky kz la mc lc ld le in bi translated">你可能在我的截图中注意到了，我实际上在终端上显示了图像。我本来可以创建一个 web 应用程序来展示这一点，但是我想让事情简单得多，所以我想直接在终端上显示图像。虽然终端控制台不是您通常期望显示图像的地方，但实际上有几种方法可以做到这一点。</p><p id="75eb" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我选了一个最简单的。我正好用了优秀的<a class="ae lf" href="https://www.iterm2.com/" rel="noopener ugc nofollow" target="_blank"> iTerm2 </a>，这是 MacOS 中默认终端应用的替代品，iTerm2 中有一个<a class="ae lf" href="https://www.iterm2.com/documentation-images.html" rel="noopener ugc nofollow" target="_blank">有趣的 hack，可以显示图像</a>。</p><p id="3a13" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">诀窍是这样的——如果你可以用 Base64 编码你的图像，你可以用一个特殊的命令把图像打印到终端上。下面是实现这一点的 Go 代码，但是您也可以用任何其他语言实现这一点。上面的文档中有几个脚本展示了如何使用简单的 shell 脚本来实现这一点。</p><pre class="me mf mg mh gu nv nw nx ny aw nz bi"><span id="e1c1" class="nj lh iu nw b gz oa ob l oc od">func printImage(img image.Image) {<br/>	var buf bytes.Buffer<br/>	png.Encode(&amp;buf, img)<br/>	imgBase64Str := base64.StdEncoding.EncodeToString(buf.Bytes())<br/>	fmt.Printf("\x1b]1337;File=inline=1:%s\a\n", imgBase64Str)<br/>}</span></pre><p id="c5f2" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">不幸的是，这意味着如果你在 iTerm2 之外的任何地方运行这段代码，你将看不到图像的变化。但是，您可以随时调整输出，以便每隔几代就捕获一次输出。</p><h1 id="dd83" class="lg lh iu bd li lj lk ll lm ln lo lp lq ka lr kb ls kd lt ke lu kg lv kh lw lx bi translated">密码</h1><p id="6b07" class="pw-post-body-paragraph kj kk iu kl b km ly jv ko kp lz jy kr ks ma ku kv kw mb ky kz la mc lc ld le in bi translated">这篇文章中的所有代码和图片都可以在这里找到:<a class="ae lf" href="https://github.com/sausheong/ga" rel="noopener ugc nofollow" target="_blank">https://github.com/sausheong/ga</a></p><h1 id="2da5" class="lg lh iu bd li lj lk ll lm ln lo lp lq ka lr kb ls kd lt ke lu kg lv kh lw lx bi translated">参考</h1><p id="9268" class="pw-post-body-paragraph kj kk iu kl b km ly jv ko kp lz jy kr ks ma ku kv kw mb ky kz la mc lc ld le in bi translated">示例代码受到了以下工作的启发:</p><ul class=""><li id="bb6b" class="mp mq iu kl b km kn kp kq ks mr kw ms la mt le mu mv mw mx bi translated">丹尼尔·席夫曼的优秀著作<em class="my">代码的本质</em>【http://natureofcode.com】T2——这是一本很棒且容易理解的读物！我还用 Java 编写了一些丹尼尔的代码，并将其转换成莎士比亚引用算法</li><li id="bc5c" class="mp mq iu kl b km mz kp na ks nb kw nc la nd le mu mv mw mx bi translated">罗杰·约翰逊在《遗传编程:蒙娜丽莎的进化》一文中的出色工作<em class="my">https://rogerjohansson . blog/2008/12/07/Genetic-Programming-evolution-of-Mona-Lisa/——尽管我最终使用了一种完全不同的方式来完成遗传算法，但他的原创工作给了我灵感，让我使用蒙娜丽莎，并尝试用三角形和圆形来完成它</em></li></ul></div></div>    
</body>
</html>