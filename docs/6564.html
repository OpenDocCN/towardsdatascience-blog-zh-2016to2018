<html>
<head>
<title>Transfer Learning for Image Classification using Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于 Keras 的图像分类迁移学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/transfer-learning-for-image-classification-using-keras-c47ccf09c8c8?source=collection_archive---------4-----------------------#2018-12-19">https://towardsdatascience.com/transfer-learning-for-image-classification-using-keras-c47ccf09c8c8?source=collection_archive---------4-----------------------#2018-12-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cc3e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用几个简单的步骤训练一个图像分类器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c0971a2e93b185e9e2df4e46f2e085b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XHC3nIez0n-VjDL48lbuaQ.jpeg"/></div></div></figure><blockquote class="ku kv kw"><p id="6572" class="kx ky kz la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我为学习者写了一份名为《强大的知识》的时事通讯。每一期都包含链接和最佳内容的关键课程，包括引文、书籍、文章、播客和视频。每一个人都是为了学习如何过上更明智、更快乐、更充实的生活而被挑选出来的。<a class="ae lu" href="https://mighty-knowledge.ck.page/b2d4518f88" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">在这里报名</strong> </a>。</p></blockquote><p id="e34f" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">在本教程中，您将学习如何为图像分类任务进行迁移学习。Keras 的高级 API 使这变得非常容易，只需要几个简单的步骤。</p><p id="acf7" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">迁移学习允许我们使用比我们从头开始训练时少得多的数据来训练深度网络。通过转移学习，我们实际上是<em class="kz">将模型从之前的任务中学到的“知识”转移到我们当前的任务中。这个想法是，这两个任务并不是完全分离的，因此我们可以利用模型通过大量训练学习到的任何网络参数，而不必自己进行训练。</em></p><p id="1a5c" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">迁移学习一直被证明可以提高模型准确性并减少所需的训练时间。更少的数据，更少的时间，更高的准确性。</p><h1 id="52d1" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">装东西</h1><p id="6acb" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lv ms lj lk lw mt ln lo lx mu lr ls lt im bi translated">我们要做的第一件事是准备我们的数据。对于 Keras 中的影像分类，最简单的方法是将您的数据分成每个类别的文件夹。例如，如果你的数据集有 3 个类:Pizza、Burger 和 Taco，那么你应该有 3 个名为 Pizza、Burger 和 Taco 的文件夹。你的每个文件夹都应该包含该特定类别的图像。您的文件夹结构应该如下所示:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="2f32" class="na lz it mw b gy nb nc l nd ne">food_dataset<br/>---&gt; Pizza<br/>-------&gt; p_1.jpg<br/>-------&gt; p_2.jpg<br/>-------&gt; p_3.jpg<br/>-------&gt; ....<br/>---&gt; Burger<br/>-------&gt; b_1.jpg<br/>-------&gt; b_2.jpg<br/>-------&gt; b_3.jpg<br/>-------&gt; ....<br/>---&gt; Taco<br/>-------&gt; ....</span></pre><p id="9b06" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">接下来，我们可以选择要对其执行迁移学习的模型。Keras 为此提供了许多选项。在进行选择时，您可以大致相信(出于我们的目的)较小的模型(以 MB 为单位)会更快但不太准确，而较大的模型会更慢但更准确。截至今天的文章，MobileNet 是最快的，NASNetLarge 是最准确的。我们今天将选择 ResNet50 型号，它位于光谱的中间。</p><p id="11f5" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">查看下面的代码。我们从导入必要的模型和预处理函数开始。ResNet50 模型使用一些非常特殊的预处理进行训练，我们希望重用这些预处理，以便正确地重新训练它。请注意，当我们初始化基本模型时，我们是如何设置<code class="fe nf ng nh mw b">include_top=False</code>的。这个设置很重要，因为这意味着我们<strong class="la iu">不会</strong>在模型的末尾保留全连接(FC)层。这正是我们想要的，因为我们要为迁移学习训练我们自己的<em class="kz">全新的</em> FC 层。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="5e3f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">流动数据</h1><p id="eede" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lv ms lj lk lw mt ln lo lx mu lr ls lt im bi translated">现在我们需要创建一个数据生成器，以自动的方式从我们的文件夹中获取数据并放入 Keras。为此，Keras 提供了方便的 python 生成器函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="37f6" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">我们定义了名为“food_dataset”的训练目录，其中包含我们之前设置的每类图像的文件夹。我们还定义了图像尺寸和批量大小；Keras 生成器将使用双线性插值法自动将所有加载的图像调整到<code class="fe nf ng nh mw b">target_size</code>的大小。</p><p id="255b" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">我们将向生成器添加一些额外的数据增强，翻转和旋转，以尝试提高我们模型的准确性。我们使用<code class="fe nf ng nh mw b">flow_from_directory</code>函数创建我们的最终生成器，它将使用一个队列来保持加载和准备图像的连续流！</p><h1 id="278a" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">弹出图层</h1><p id="f008" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lv ms lj lk lw mt ln lo lx mu lr ls lt im bi translated">是时候建立我们迁移学习的最终模型了。如果将来要再次使用它，您可能会发现为此编写一个函数非常方便。下面有一个你可以从它开始。</p><p id="3ef3" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">我们从冻结基本模型的所有层开始。我们不想训练这些层，因为我们试图利用网络从以前的数据集(在这种情况下是 ImageNet)中学习的知识。通过设置<code class="fe nf ng nh mw b">layer.trainable=False</code>，我们告诉 Keras <em class="kz">而不是</em>在训练期间更新那些权重，这正是我们想要的！</p><p id="1d3d" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">现在，我们可以添加 FC 层。我们在一个循环中这样做，因为许多网络有多个 FC 层，循环通过一个列表使事情变得简单明了。我们还将在每个 FC 层中添加一些 dropout，以减少过度拟合的机会(这部分是可选的)。最后，我们加上最终的 Softmax 层，建立 Keras 模型。</p><p id="4837" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">一旦我们的功能都设置好了，创建最终模型就变得非常简单了。只需忽略 softmax 层的类的数量、列表中 FC 层的大小(因为我们对它进行了循环)和丢失概率。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="421e" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">训练它</h1><p id="7405" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lv ms lj lk lw mt ln lo lx mu lr ls lt im bi translated">最后一步是设置我们的训练，并点击大红色按钮，使所有运行！</p><p id="7a8a" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">我们将使用 Adam 优化器，它的学习率值很小。我们选择 Adam 是因为它比 SGD 更快更容易使用。我们将学习率设置得很小，因为我们在这里只是微调我们的模型，特别是 FC 层；我们不寻求任何大的改变，只是微调。</p><p id="7ccc" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">我们还将设置一些检查点，为以后保存权重。应用<code class="fe nf ng nh mw b">fit_generator</code>函数运行整个训练团，可选择时期数、批量大小和数据混排。一旦训练全部完成，我们可以使用<code class="fe nf ng nh mw b">history</code>输出来绘制我们的训练结果。</p><p id="bbe0" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">瞧，转移学习！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="2efc" class="ly lz it bd ma mb nr md me mf ns mh mi jz nt ka mk kc nu kd mm kf nv kg mo mp bi translated">喜欢学习？</h1><p id="b222" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lv ms lj lk lw mt ln lo lx mu lr ls lt im bi translated">在<a class="ae lu" href="https://twitter.com/GeorgeSeif94" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，我会在那里发布所有最新最棒的人工智能、技术和科学！也在<a class="ae lu" href="https://www.linkedin.com/in/georgeseif/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上和我联系吧！</p></div></div>    
</body>
</html>