<html>
<head>
<title>Deploy TensorFlow models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">部署张量流模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploy-tensorflow-models-9813b5a705d5?source=collection_archive---------2-----------------------#2018-03-17">https://towardsdatascience.com/deploy-tensorflow-models-9813b5a705d5?source=collection_archive---------2-----------------------#2018-03-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/22b104939df07ab3ef043ff00afbe545.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_9sfjL1W97gNTdMVbAh_hw.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://unsplash.com/photos/OHOU-5UVIYQ?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">SpaceX</a> on <a class="ae jg" href="https://unsplash.com/search/photos/falcon-heavy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="774f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">了解如何将您的模型部署到生产中</em></p><p id="a534" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">更新至tensorflow 1.7 </em></p><p id="c6d6" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好，你有一个模型，你想让它可以从网上访问。有几种方法可以做到这一点，但最快和最强大的是TensorFlow服务。</p><p id="7067" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它是如何工作的？基本上TensorFlow服务创建了一个<a class="ae jg" href="https://en.wikipedia.org/wiki/GRPC" rel="noopener ugc nofollow" target="_blank"> gRPC </a>服务器，您可以在其中发送和接收来自模型的响应。你并不真正了解成为巫师背后的魔力。</p><p id="5651" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些是我们要做的步骤:</p><ul class=""><li id="164e" class="lf lg jj ki b kj kk kn ko kr lh kv li kz lj ld lk ll lm ln bi translated">做一个笨模型做例子，训练存储</li><li id="2cbf" class="lf lg jj ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">从存储的模型中获取您需要的变量</li><li id="06e3" class="lf lg jj ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">从它们中建立张量信息</li><li id="f837" class="lf lg jj ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">创建模型签名</li><li id="3fd6" class="lf lg jj ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">创建并保存模型构建器</li><li id="217d" class="lf lg jj ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">下载已经编译了TensorFlow服务的Docker映像</li><li id="edd8" class="lf lg jj ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">使用正确的配置运行docker映像</li><li id="9490" class="lf lg jj ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">创建客户端以发送gRPC请求</li><li id="a72e" class="lf lg jj ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">制作一个API</li><li id="698f" class="lf lg jj ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">测试一下</li></ul><p id="5d87" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码可以在这里找到<a class="ae jg" href="https://github.com/FrancescoSaverioZuppichini/TensorFlow-Serving-Example" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="6e96" class="lt lu jj bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">制作一个愚蠢的模型作为例子，训练和存储它</h1><p id="2287" class="pw-post-body-paragraph kg kh jj ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">我们只需要一个模型来玩。下面是一个非常基本的模型，它以两个随机数组作为输入和目标。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="700a" class="nf lu jj nb b gy ng nh l ni nj"><em class="le">import </em>tensorflow <em class="le">as </em>tf<br/><em class="le">import </em>numpy <em class="le">as </em>np<br/><em class="le">import </em>os, sys<br/><br/>DATA_SIZE = 100<br/>SAVE_PATH = './save'<br/>EPOCHS = 1000<br/>LEARNING_RATE = 0.01<br/>MODEL_NAME = 'test'<br/><br/><em class="le">if not </em>os.path.exists(SAVE_PATH):<br/>    os.mkdir(SAVE_PATH)<br/><br/>data = (np.random.rand(DATA_SIZE, 2), np.random.rand(DATA_SIZE, 1))<br/>test = (np.random.rand(DATA_SIZE // 8, 2), np.random.rand(DATA_SIZE // 8, 1))<br/><br/>tf.reset_default_graph()<br/><br/>x = tf.placeholder(tf.float32, shape=[<em class="le">None</em>, 2], name='inputs')<br/>y = tf.placeholder(tf.float32, shape=[<em class="le">None</em>, 1], name='targets')<br/><br/>net = tf.layers.dense(x, 16, activation=tf.nn.relu)<br/>net = tf.layers.dense(net, 16, activation=tf.nn.relu)<br/>pred = tf.layers.dense(net, 1, activation=tf.nn.sigmoid, name='prediction')<br/><br/>loss = tf.reduce_mean(tf.squared_difference(y, pred), name='loss')<br/>train_step = tf.train.AdamOptimizer(LEARNING_RATE).minimize(loss)<br/><br/>checkpoint = tf.train.latest_checkpoint(SAVE_PATH)<br/>should_train = checkpoint == <em class="le">None<br/><br/>with </em>tf.Session() <em class="le">as </em>sess:<br/>    sess.run(tf.global_variables_initializer())<br/>    <em class="le">if </em>should_train:<br/>        print("Training")<br/>        saver = tf.train.Saver()<br/>        <em class="le">for </em>epoch <em class="le">in </em>range(EPOCHS):<br/>            _, curr_loss = sess.run([train_step, loss], feed_dict={x: data[0], y: data[1]})<br/>            print('EPOCH = {}, LOSS = {:0.4f}'.format(epoch, curr_loss))<br/>        path = saver.save(sess, SAVE_PATH + '/' + MODEL_NAME + '.ckpt')<br/>        print("saved at {}".format(path))<br/>    <em class="le">else</em>:<br/>        print("Restoring")<br/>        graph = tf.get_default_graph()<br/>        saver = tf.train.import_meta_graph(checkpoint + '.meta')<br/>        saver.restore(sess, checkpoint)<br/><br/>        loss = graph.get_tensor_by_name('loss:0')<br/><br/>        test_loss = sess.run(loss, feed_dict={'inputs:0': test[0], 'targets:0': test[1]})<br/>        print(sess.run(pred, feed_dict={'inputs:0': np.random.rand(10,2)}))<br/>        print("TEST LOSS = {:0.4f}".format(test_loss))</span></pre><p id="cd81" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">记住:如果你使用tf.layers.dense，实际的输出是用你提供的名字+ </em>函数名(lol)来调用的</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="a2b8" class="nf lu jj nb b gy ng nh l ni nj">x = tf.placeholder(tf.float32, shape=[<em class="le">None</em>, 2], name='inputs')</span><span id="8487" class="nf lu jj nb b gy nk nh l ni nj">...<br/>pred = tf.layers.dense(net, 1, activation=tf.nn.sigmoid, name='prediction') </span></pre><p id="eb18" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您运行代码，它将创建<code class="fe nl nm nn nb b">./save</code>文件夹(如果它不存在),或者如果已经有一个存储的实例，它将只评估测试集上的模型。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="2f74" class="nf lu jj nb b gy ng nh l ni nj"># training the model<br/>...<br/>EPOCH = 997, LOSS = 0.0493<br/>EPOCH = 998, LOSS = 0.0495<br/>EPOCH = 999, LOSS = 0.0497<br/>saved at ./save/test.ckpt</span></pre><p id="eba2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们再次运行脚本，我们会看到</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="0d3e" class="nf lu jj nb b gy ng nh l ni nj">Restoring<br/>TEST LOSS = 0.0710</span></pre><p id="7047" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完美！现在我们有了保存的模型</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div class="gh gi no"><img src="../Images/5a69e0dc74640454a226489af03d3016.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*13cswk67jsfeyhYqrHob7w.png"/></div></figure><h1 id="045f" class="lt lu jj bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">从存储的模型中获取您需要的变量</h1><p id="47fa" class="pw-post-body-paragraph kg kh jj ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">让我们创建一个名为<code class="fe nl nm nn nb b">serve.py</code>的文件，它将处理服务于我们的TF模型背后的逻辑。首先要做的是从存储的图中获取我们需要的变量。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="9614" class="nf lu jj nb b gy ng nh l ni nj"><em class="le">import </em>tensorflow <em class="le">as </em>tf<br/><em class="le">import </em>os<br/><br/>SAVE_PATH = './save'<br/>MODEL_NAME = 'test'<br/>VERSION = 1<br/>SERVE_PATH = './serve/{}/{}'.format(MODEL_NAME, VERSION)<br/><br/>checkpoint = tf.train.latest_checkpoint(SAVE_PATH)<br/><br/>tf.reset_default_graph()<br/><br/><em class="le">with </em>tf.Session() <em class="le">as </em>sess:<br/>    # import the saved graph<br/>    saver = tf.train.import_meta_graph(checkpoint + '.meta')<br/>    # get the graph for this session<br/>    graph = tf.get_default_graph()<br/>    sess.run(tf.global_variables_initializer())<br/>    # get the tensors that we need<br/>    inputs = graph.get_tensor_by_name('inputs:0')<br/>    predictions = graph.get_tensor_by_name('prediction/Sigmoid:0')</span></pre><h1 id="99ef" class="lt lu jj bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">从它们中建立张量信息</h1><p id="56e5" class="pw-post-body-paragraph kg kh jj ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">现在我们有了我们的变量<code class="fe nl nm nn nb b">inputs</code>和<code class="fe nl nm nn nb b">predictions</code>。我们需要从它们中构建张量信息，该信息将用于创建将被传递给<strong class="ki jk"> SavedModelBuilder </strong>实例的<strong class="ki jk">签名定义</strong>。非常容易</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="0db4" class="nf lu jj nb b gy ng nh l ni nj"># create tensors info<br/>model_input = tf.saved_model.utils.build_tensor_info(inputs)<br/>model_output = tf.saved_model.utils.build_tensor_info(predictions)</span></pre><h1 id="da9d" class="lt lu jj bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated"><strong class="ak">创建模型签名</strong></h1><p id="263f" class="pw-post-body-paragraph kg kh jj ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">现在，我们终于可以创建<strong class="ki jk">模型签名</strong>了，它标识了服务对客户端的期望。在我们的情况下</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="a4f3" class="nf lu jj nb b gy ng nh l ni nj"># build signature definition<br/>signature_definition = tf.saved_model.signature_def_utils.build_signature_def(<br/>    inputs={'inputs': model_input},<br/>    outputs={'outputs': model_output},<br/>    method_name= tf.saved_model.signature_constants.PREDICT_METHOD_NAME)</span></pre><p id="7f2b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们从TF中调用一个utils函数，它接受<code class="fe nl nm nn nb b">inputs</code>、<code class="fe nl nm nn nb b">outputs</code>和<code class="fe nl nm nn nb b">method_name</code>。最后一个只是一个常量，表示将要做什么，在我们想要预测的情况下，它们被定义为:</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div class="gh gi np"><img src="../Images/6caf2b38be0f92039a732e8488c297fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*p0IX7GLSrIXa-EnRaGN_SA.png"/></div></figure><h1 id="2b71" class="lt lu jj bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">创建并保存模型构建器</h1><p id="e788" class="pw-post-body-paragraph kg kh jj ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">创建一个<strong class="ki jk"> SavedModelBuilder </strong>实例，并传递我们需要的所有信息。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="8512" class="nf lu jj nb b gy ng nh l ni nj">builder = tf.saved_model.builder.SavedModelBuilder(SERVE_PATH)<br/><br/>builder.add_meta_graph_and_variables(<br/>    sess, [tf.saved_model.tag_constants.SERVING],<br/>    signature_def_map={<br/>        tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY:<br/>            signature_definition<br/>    })<br/># Save the model so we can serve it with a model server :)<br/>builder.save()</span></pre><p id="275c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe nl nm nn nb b">add_meta_graph_and_variables</code>中，我们通过当前会话，一个我不知道为什么需要它们的<code class="fe nl nm nn nb b">tags</code>数组，<code class="fe nl nm nn nb b">SERVING</code>常量和<code class="fe nl nm nn nb b">signature_def_map</code>。同样，对于最后一个，我不知道我们为什么需要它，但是基本上我们传递一个字典，在那里我们告诉<code class="fe nl nm nn nb b">DEFAULT_SERVING_SIGNATURE_DEF_KEY</code>我们有那个签名定义(在前面的“创建模型签名”一节中定义的那个)。</p><p id="264c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完整剧本<a class="ae jg" href="https://github.com/FrancescoSaverioZuppichini/TensorFlow-Serving-Example/blob/master/serve.py" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="06d3" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行脚本，它会创建<code class="fe nl nm nn nb b">serve</code>目录:</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/91d384d8cc20cb4fb24ca89787b9945d.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*UD3yDmdxY6Ul_c_nBoywKA.png"/></div></figure><h1 id="0647" class="lt lu jj bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">下载已经编译了TensorFlow服务的Docker映像</h1><p id="d872" class="pw-post-body-paragraph kg kh jj ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">首先安装<a class="ae jg" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> docker </a>。</p><p id="f9bf" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不要遵循TensorFlow文档，因为它们解释了如何设置docker映像和编译TF serving，这需要花费很长时间。</p><p id="97ab" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">现在单据坏了，查看这里:</strong></p><p id="8929" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae jg" href="https://github.com/tensorflow/tensorflow/issues/19006" rel="noopener ugc nofollow" target="_blank"><strong class="ki jk">https://github.com/tensorflow/tensorflow/issues/19006</strong></a></p><p id="276c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有人制作了一个<a class="ae jg" href="https://hub.docker.com/r/epigramai/model-server/" rel="noopener ugc nofollow" target="_blank"> docker图像，上面已经编译了所有东西</a>，所以我们将使用这个图像。图像链接:</p><p id="b17b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae jg" href="https://hub.docker.com/r/epigramai/model-server/" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/r/epigramai/model-server/</a></p><p id="6fd0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用正确的参数运行该命令</p><p id="9ae4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nl nm nn nb b">docker run -it -p &lt;PORT&gt;:&lt;PORT&gt; — name &lt;CONTAINER_NAME&gt; -v &lt;ABSOLUTE_PATH_TO_SERVE_DIR&gt;:&lt;SERVE_DIR&gt; epigramai/model-server:light-universal-1.7 — port=&lt;PORT&gt; — model_name=&lt;MODEL_NAME&gt; — model_base_path=&lt;MODEL_DIR&gt;</code></p><p id="8089" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的情况下</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="aedc" class="nf lu jj nb b gy ng nh l ni nj">docker run -it -p 9000:9000 --name tf-serve -v $(pwd)/serve/:/serve/ epigramai/model-server:light-universal-1.7 --port=9000 --model_name=test --model_base_path=/serve/test</span></pre><p id="8130" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果一切正常，您应该会看到类似这样的内容:</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nr"><img src="../Images/5ad0c5f3764fa8a0980402ff2cee3b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L2VPCw4u-69KSeJC5ItbsA.png"/></div></div></figure><h1 id="f3c7" class="lt lu jj bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">创建客户端以发送gRPC请求</h1><p id="59a4" class="pw-post-body-paragraph kg kh jj ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">怎么做呢？好吧，再说一次，医生真的不太好。所以我们将使用一个<a class="ae jg" href="https://github.com/epigramai/tfserving-python-predict-client" rel="noopener ugc nofollow" target="_blank">库</a>，这将使事情变得更容易。</p><p id="8c47" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe nl nm nn nb b">pip</code>运行这个命令来安装它，在我的例子中，我使用的是python3</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="6da4" class="nf lu jj nb b gy ng nh l ni nj">pip3 install git+ssh://<a class="ae jg" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>/epigramai/tfserving-python-predict-client.git</span></pre><p id="66c3" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们创建一个名为<code class="fe nl nm nn nb b">client.py</code>的新文件</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="da2b" class="nf lu jj nb b gy ng nh l ni nj"><em class="le">import </em>numpy <em class="le">as </em>np<br/><em class="le">from </em>predict_client.prod_client <em class="le">import </em>ProdClient<br/><br/>HOST = '0.0.0.0:9000'<br/># a good idea is to place this global variables in a shared file<br/>MODEL_NAME = 'test'<br/>MODEL_VERSION = 1<br/><br/>client = ProdClient(HOST, MODEL_NAME, MODEL_VERSION)<br/><br/>req_data = [{'in_tensor_name': 'inputs', 'in_tensor_dtype': 'DT_FLOAT', 'data': np.random.rand(1,2)}]<br/><br/>prediction = client.predict(req_data, request_timeout=10)<br/><br/>print(prediction)</span></pre><p id="5846" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在运行它之前，确保您已经启动了docker容器。午饭后你应该会看到这样的脚本:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="28db" class="nf lu jj nb b gy ng nh l ni nj">{'outputs': array([[ 0.53334153]])}</span></pre><p id="697e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以<code class="fe nl nm nn nb b">outputs</code>为关键字、以正确预测为值的字典</p><h1 id="d4a5" class="lt lu jj bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">创建API端点</h1><p id="bb5c" class="pw-post-body-paragraph kg kh jj ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">是时候最终让我们的模型可以从网上访问了。我们将使用<a class="ae jg" href="http://flask.pocoo.org/" rel="noopener ugc nofollow" target="_blank"> Flask </a>来创建HTTP服务器。让我们重构我们的<code class="fe nl nm nn nb b">client.py</code></p><p id="163e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">客户端必须接受HTTP调用，将响应数据转换为numpy数组，调用模型并返回包含预测的JSON。下面是<a class="ae jg" href="https://github.com/FrancescoSaverioZuppichini/TensorFlow-Serving-Example/blob/master/client.py" rel="noopener ugc nofollow" target="_blank">的最终代码</a>。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="054a" class="nf lu jj nb b gy ng nh l ni nj"><em class="le">import </em>numpy <em class="le">as </em>np<br/><em class="le">from </em>predict_client.prod_client <em class="le">import </em>ProdClient<br/><em class="le">from </em>flask <em class="le">import </em>Flask<br/><em class="le">from </em>flask <em class="le">import </em>request<br/><em class="le">from </em>flask <em class="le">import </em>jsonify<br/><br/>HOST = 'localhost:9000'<br/>MODEL_NAME = 'test'<br/>MODEL_VERSION = 1<br/><br/>app = Flask(__name__)<br/>client = ProdClient(HOST, MODEL_NAME, MODEL_VERSION)<br/><br/><em class="le">def </em>convert_data(<em class="le">raw_data</em>):<br/>    <em class="le">return </em>np.array(<em class="le">raw_data</em>, dtype=np.float32)<br/><br/><em class="le">def </em>get_prediction_from_model(<em class="le">data</em>):<br/>    req_data = [{'in_tensor_name': 'inputs', 'in_tensor_dtype': 'DT_FLOAT', 'data': <em class="le">data</em>}]<br/><br/>    prediction = client.predict(req_data, request_timeout=10)<br/><br/>    <em class="le">return </em>prediction<br/><br/><br/>@app.route("/prediction", methods=['POST'])<br/><em class="le">def </em>get_prediction():<br/>    req_data = request.get_json()<br/>    raw_data = req_data['data']<br/><br/>    data = convert_data(raw_data)<br/>    prediction = get_prediction_from_model(data)<br/><br/>    # ndarray cannot be converted to JSON<br/>    <em class="le">return </em>jsonify({ 'predictions': prediction['outputs'].tolist() })<br/><br/><em class="le">if </em>__name__ == '__main__':<br/>    app.run(host='localhost',port=3000)</span></pre><h1 id="b9e5" class="lt lu jj bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">测试一下</h1><p id="23fa" class="pw-post-body-paragraph kg kh jj ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">终于！我成功了！是时候尝试一下了，打开您最喜欢的HTTP客户端，在我的例子中是<a class="ae jg" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank"> postman </a>，尝试使用<code class="fe nl nm nn nb b">POST</code>请求向<code class="fe nl nm nn nb b">localhost:3000/prediction</code>发送一个以<code class="fe nl nm nn nb b">data</code>为键、以矢量为值的JSON</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ns"><img src="../Images/8b610fc61182b94c3b4f7a2d335ac029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OxCFwpBMGspD_AwEuaZwxQ.png"/></div></div></figure><p id="a45f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">发送后，我们有了回应</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nt"><img src="../Images/90dfc953aeaaf1ec3da871d70b59ebd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6iOheJh7PtX8-w1ZGRVLVw.png"/></div></div></figure><p id="a426" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完美！它工作了。</p><p id="f8ea" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最终代码可以在<a class="ae jg" href="https://github.com/FrancescoSaverioZuppichini/TensorFlow-Serving-Example" rel="noopener ugc nofollow" target="_blank">这里</a>找到</p><h1 id="b90a" class="lt lu jj bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">结论</h1><p id="7eed" class="pw-post-body-paragraph kg kh jj ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">我们已经看到了服务TensorFlow模型并使用Flask通过HTTP请求访问它的最佳方式。</p><p id="0d26" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也许你还可以找到值得一读的我的其他文章:</p><p id="8b66" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/reinforcement-learning-cheat-sheet-2f9453df7651">https://towards data science . com/reinforcement-learning-cheat-sheet-2f 9453 df 7651</a></p><p id="aed5" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/how-to-use-dataset-in-tensorflow-c758ef9e4428">https://towards data science . com/how-to-use-dataset-in-tensor flow-c 758 ef 9 e 4428</a></p><p id="37cd" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，</p><p id="a07a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">弗朗西斯科·萨维里奥</p></div></div>    
</body>
</html>