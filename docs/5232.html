<html>
<head>
<title>TensorFlow &amp; reflective tape 🏀 (am I bad at basketball?)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TensorFlow &amp;反光胶带🏀(我篮球打得不好吗？)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tensorflow-reflective-tape-why-im-bad-at-basketball-a30a923332de?source=collection_archive---------13-----------------------#2018-10-05">https://towardsdatascience.com/tensorflow-reflective-tape-why-im-bad-at-basketball-a30a923332de?source=collection_archive---------13-----------------------#2018-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d23aecdf35069465c9dc5a1bfec6462b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J1rVK_jZ_Lodt7fimRJ3FQ.jpeg"/></div></div></figure><p id="5ab5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近一个朋友让我迷上了篮球。事实证明，这比看起来难多了。没关系，我可以用机器学习来设计解决方案。如果你对 ML 和投篮感兴趣，那么也有<a class="ae kw" href="https://medium.com/tensorflow/tf-jam-shooting-hoops-with-machine-learning-7a96e1236c32" rel="noopener">这篇文章</a>在模拟中结合了张量流和篮球。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/90f18d0b8c98b8bcd2d5373e260c5200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*V1eZtAdA1sUfqX7WNNIClg.gif"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">nothing but net… if there was a net</figcaption></figure><p id="9e9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">任务是找到我拍摄的准确角度。然后，我就可以积极主动地利用这些信息，变得更好。</p><p id="60a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lg">嘶！这一切的代码都在我的</em> <a class="ae kw" href="https://github.com/ZackAkil/optimising-basketball" rel="noopener ugc nofollow" target="_blank"> <em class="lg"> Github </em> </a>上</p><h1 id="81a7" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">任务 1:收集数据</h1><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/8d99fb323a69b04215810d88c7f89c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w3-DOoutfsTxgGyxyF36tA.jpeg"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">I didn’t need to follow the seems of the ball, but it looks cool</figcaption></figure><p id="a830" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我没有配备 200 个摄像头的 3D 追踪工作室，但我有 Ebay。网上买<a class="ae kw" href="https://www.google.com/search?q=reflective+tape" rel="noopener ugc nofollow" target="_blank">反光带</a>贴在球上还是挺容易的。然后(由于我当地的球场缺乏照明)，我可以录下一些我晚上练习的镜头，并捕捉球的运动。</p><p id="e323" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我手机内置的手电筒提供了完美的光源来反射球的反光。</p><p id="684c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，捕捉到的镜头显示了一个闪闪发光的物体飞过一个几乎黑暗的场景，非常适合在 python 中进行一些图像处理。</p><h1 id="fdc6" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">任务 2:将我们的视频导入 python</h1><p id="a0d9" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">首先，我用 Python 做所有事情，将视频导入 Python 的一个非常简单的方法是使用一个名为'<a class="ae kw" href="http://www.scikit-video.org" rel="noopener ugc nofollow" target="_blank"> scikit-video </a>'的库，所以我安装了:</p><pre class="ky kz la lb gt ml mm mn mo aw mp bi"><span id="60c9" class="mq li iq mm b gy mr ms l mt mu">pip install scikit-video</span></pre><p id="b1c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后用它来加载我的视频作为一个矩阵:</p><pre class="ky kz la lb gt ml mm mn mo aw mp bi"><span id="e246" class="mq li iq mm b gy mr ms l mt mu">from skvideo.io import vread</span><span id="3fe1" class="mq li iq mm b gy mv ms l mt mu">video_data = vread('VID_20180930_193148_2.mp4')</span></pre><p id="a9e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个数据的形状(可以通过运行<strong class="ka ir"> video_data.shape </strong>找到)是(220，1080，1920，3)。这意味着 3 个颜色通道(红、绿、蓝)的 1080×1920 像素的 220 帧:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/493a2e9b7fc191f710e43a64b6e94714.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*1tn3tKyuCMNidLyQillYZw.gif"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">raw video data</figcaption></figure><h1 id="f688" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">任务 3:提取镜头(图像处理)</h1><p id="67a5" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">所以我想得到球运动的数据。幸运的是，这是视频中唯一会动的东西之一。所以我可以做我最喜欢的视频处理技巧:<strong class="ka ir">增量帧提取</strong>！(<em class="lg">我就是这么叫的，不过可能还有另外一个名字</em>)。</p><p id="0f57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过从下一帧中的所有像素值中减去一帧中的所有像素值，您将只在已经改变的像素中得到非零值。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/8dfe0fd2a8081bd23a5753c53465cba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*KeA9dwEEeuXqNE7AVKb8uw.png"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">calculating delta frame in order to isolate moving pixels</figcaption></figure><p id="4e94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">酷酷酷，现在我对视频中的每一帧都这样做，并将结果合并成一幅图像:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/fce1d74c6f1c94675ec296aa6ddad116.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*tYmopdxUS4b0iiJ5QwQJ8w.png"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">adding together all of the delta frames from the video sequence</figcaption></figure><p id="5821" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来是将拍摄数据提取成可用的格式。所以我们将把精简后的像素值转换成一个由<strong class="ka ir"><em class="lg">【x】</em></strong>和<strong class="ka ir"> <em class="lg"> y </em> </strong>点组成的列表。完成这项工作的代码是一个名为<a class="ae kw" href="https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.where.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> numpy.where </strong> </a>的 numpy 函数，它将在一个数组中找到所有<strong class="ka ir">为真</strong>的值，并返回它们的索引(即它们在矩阵中的位置)。</p><p id="cd0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但在此之前，我们将快速裁剪出球的轨迹并翻转数据，使其从原点(场景的左下方)开始:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/518b091a85aa4d36a4e7aac7b5418079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wlWVcZEObJePb1zEzeNN1Q.png"/></div></div></figure><p id="818b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由此产生的图像:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/2a4f20af2fa3827aa7373a96e7aaaad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OxS6pId6J1aMXM7rlthu5w.png"/></div></div></figure><p id="11b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意到它看起来还是上下颠倒了吗？这只是因为图像倾向于从左上角的<strong class="ka ir">开始绘制(注意轴编号)。当我们将像素转换为数据点并将它们绘制在普通图上时，它们将从底部的<strong class="ka ir">左下角开始绘制。</strong></strong></p><p id="0cc3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们运行我们的<strong class="ka ir"> numpy.where </strong>代码来获取像素作为数据点:</p><pre class="ky kz la lb gt ml mm mn mo aw mp bi"><span id="ac81" class="mq li iq mm b gy mr ms l mt mu">pixels_that_are_not_black = cropped_trail.sum(axis=2) &gt; 0</span><span id="7443" class="mq li iq mm b gy mv ms l mt mu">y_data, x_data = numpy.where(pixels_that_are_not_black)</span></pre><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/616d19c2823b0173810a3e2be8caf0b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*JFCUAmNTHhqWUB3lUyXDCg.png"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">awesome! our relatively clean ball trajectory data</figcaption></figure><h1 id="561a" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">任务 4:构建张量流模型</h1><p id="3b69" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">这就是 TensorFlow 大放异彩的地方。你可能习惯于听说使用 TensorFlow 来构建神经网络，但你可以定义几乎任何数学公式，并告诉它优化你想要的任何部分。在我们的例子中，我们将使用从小学就知道的轨迹公式:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/e44c992515a3e914b5abc025881e94b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*5VB-_Rbf_mxycVAzxtY2fA.png"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">extremely mathematical equation of trajectory that I found online</figcaption></figure><p id="6802" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> θ </strong> (theta)是拍摄的角度(<em class="lg">我们真正关心的值</em>)</p><p id="c310" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="lg"> v </em> </strong>是初速度</p><p id="669b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="lg"> g </em> </strong>是重力(9.8m/s)</p><p id="e0c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="lg"> x </em> </strong>是水平位置(<em class="lg">数据我们已经</em>)</p><p id="d047" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="lg"> y </em> </strong>是垂直位置(<em class="lg">数据我们已经</em>)</p><p id="111b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个更有趣的方式来看这个方程的作用是用<a class="ae kw" href="https://www.desmos.com/calculator/gjnco6mzjo" rel="noopener ugc nofollow" target="_blank">这个轨迹工具</a>来玩。</p><p id="16ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用我击球的球轨迹作为<strong class="ka ir"> <em class="lg"> x </em> </strong>和<em class="lg">y</em><strong class="ka ir"><em class="lg"/></strong>方程和任务张量流，找到适合我击球的正确角度(<strong class="ka ir"> θ </strong>)和初始速度(<strong class="ka ir"> <em class="lg"> v </em> </strong>)</p><p id="f2d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将开始在张量流中重建我们的轨迹方程:</p><p id="5d3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先告诉它，当我们运行优化时，我们将输入什么数据:</p><pre class="ky kz la lb gt ml mm mn mo aw mp bi"><span id="fa4b" class="mq li iq mm b gy mr ms l mt mu">x = tf.placeholder(tf.float32, [<strong class="mm ir">None</strong>, 1])<br/>y = tf.placeholder(tf.float32, [<strong class="mm ir">None</strong>, 1])</span></pre><p id="fe25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，告诉它我们希望它调整哪些变量，以使轨迹曲线符合我们的数据:</p><pre class="ky kz la lb gt ml mm mn mo aw mp bi"><span id="eda6" class="mq li iq mm b gy mr ms l mt mu">angle_variable = tf.Variable(40.0, name='angle_variable')<br/>force_variable = tf.Variable(100.0, name='force_variable')<br/><br/>gravity_constant = tf.constant(9.8, name='gravity_constant')</span></pre><p id="9db6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并将所有这些结合在一起(<strong class="ka ir">警告</strong>:这看起来会很乱，但这只是之前看到的用 TensorFlow 语法编写的数学方程):</p><pre class="ky kz la lb gt ml mm mn mo aw mp bi"><span id="6285" class="mq li iq mm b gy mr ms l mt mu">left_hand_side = x * tf.tan(deg2rad(angle_variable))<br/>top = gravity_constant * x ** 2<br/>bottom = (2*(force_variable)**2) * <br/>            (tf.cos(deg2rad(angle_variable))**2)</span><span id="5d0d" class="mq li iq mm b gy mv ms l mt mu">output = left_hand_side - (top / bottom)</span></pre><p id="a6fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后告诉 TensorFlow 如何判断它在将轨迹函数拟合到我们的数据时是否做得很好:</p><pre class="ky kz la lb gt ml mm mn mo aw mp bi"><span id="75ef" class="mq li iq mm b gy mr ms l mt mu"># the lower this score, the better<br/>error_score = tf.losses.mean_squared_error(y, output)</span></pre><p id="2e63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一个优化器，对变量(angle_variable 和 force_variable)进行实际调整，以降低 error_score:</p><pre class="ky kz la lb gt ml mm mn mo aw mp bi"><span id="1534" class="mq li iq mm b gy mr ms l mt mu">optimiser = tf.train.AdamOptimizer(learning_rate=5) <br/>optimiser_op = optimiser.minimize(error_score)</span></pre><h1 id="f6d0" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">任务 5:魔法</h1><p id="a41e" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">我们现在可以运行优化任务来找到适合我的镜头的<strong class="ka ir">角度变量</strong>和<strong class="ka ir">力变量</strong>值。</p><pre class="ky kz la lb gt ml mm mn mo aw mp bi"><span id="9955" class="mq li iq mm b gy mr ms l mt mu">sess = tf.Session()<br/>sess.run(tf.global_variables_initializer())</span><span id="dd42" class="mq li iq mm b gy mv ms l mt mu"># do 150 steps of optimisation<br/>for i in range(150):</span><span id="b134" class="mq li iq mm b gy mv ms l mt mu">    sess.run([optimiser_op], <br/>             feed_dict={x: np.array(x_data).reshape(-1, 1), <br/>                        y: np.array(y_data).reshape(-1, 1)})</span><span id="10cb" class="mq li iq mm b gy mv ms l mt mu">found_angle = sess.run(angle_constant.value())</span><span id="ed01" class="mq li iq mm b gy mv ms l mt mu">print(found_angle)</span></pre><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/c741125aa9df7d4feb755e1a4ff84f55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/1*4DTRp298z0G0LHxFp3WWGA.gif"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">TensorFlow finding the angle of my shot</figcaption></figure><p id="abfd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在优化的最后，我们发现最符合我的拍摄数据的轨迹函数的角度约为 61 度…不知道如何处理这些信息…我想我可以看看专业拍摄角度是什么，以便进行比较…待续。</p><blockquote class="ne"><p id="73f6" class="nf ng iq bd nh ni nj nk nl nm nn kv dk translated">要吸取的教训:你总是可以用完全不必要(但有趣)的机器学习来分散注意力。</p></blockquote><p id="183f" class="pw-post-body-paragraph jy jz iq ka b kb no kd ke kf np kh ki kj nq kl km kn nr kp kq kr ns kt ku kv ij bi translated">我使用的所有代码都可以在我的 Github 上找到:</p><div class="nt nu gp gr nv nw"><a href="https://github.com/ZackAkil/optimising-basketball" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">ZackAkil/优化-篮球</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">用张量流和图像处理分析我的篮球技术。-ZackAkil/优化-篮球</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">github.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok jw nw"/></div></div></a></div></div></div>    
</body>
</html>