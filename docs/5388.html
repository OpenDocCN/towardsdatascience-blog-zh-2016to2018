<html>
<head>
<title>Pandas vs. Spark: how to handle dataframes (Part II)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫 vs. Spark:如何处理数据帧(下)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-pandas-vs-scala-how-to-handle-dataframes-part-ii-d3e5efe8287d?source=collection_archive---------6-----------------------#2018-10-15">https://towardsdatascience.com/python-pandas-vs-scala-how-to-handle-dataframes-part-ii-d3e5efe8287d?source=collection_archive---------6-----------------------#2018-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8f449ac482cde8467ad5f6108a786645.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DSIo5PnX246bcJ4x"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">“Panda statues on gray concrete stairs during daytime” by <a class="ae kc" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">chuttersnap</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a>. “Scala” means “stairway” in Italian, my native language: hence the choice of the picture. It just seemed appropriate.</figcaption></figure><p id="3148" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">前几天我发表了一篇<a class="ae kc" rel="noopener" target="_blank" href="/python-vs-scala-a-comparison-of-the-basic-commands-fae23b3ede23">帖子</a>比较 Python 和 Scala 的基本命令:如何处理列表和数组、函数、循环、字典等等。随着我继续练习 Scala，似乎应该继续第二部分，比较如何在两种编程语言中处理数据帧，以便在建模过程之前准备好数据。在 Python 中，我们将通过使用 Pandas 库来完成所有这些，而在 Scala 中，我们将使用 Spark。</p><blockquote class="lb lc ld"><p id="c5a9" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">在这个练习中，我将使用 Titanic train 数据集，该数据集可以通过链接轻松下载<a class="ae kc" href="https://www.kaggle.com/c/titanic/data" rel="noopener ugc nofollow" target="_blank">。此外，我在 Databricks 中进行了 Scala 实践:如果你也这样做，记得首先通过点击 Data 导入数据集，然后添加数据。</a></p></blockquote></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><h1 id="885a" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">1.读取数据帧</h1><p id="20b4" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">我将导入并命名我的数据帧<em class="le"> df </em>，在<strong class="kf ir"> Python </strong>中这将只有两行代码。如果您将<em class="le"> train.csv </em>保存在笔记本所在的同一个文件夹中，这将有效。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="f076" class="nb lq iq mx b gy nc nd l ne nf">import pandas as pd<br/>df = pd.read_csv('train.csv')</span></pre><p id="9730" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Scala 需要更多的输入。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="ec12" class="nb lq iq mx b gy nc nd l ne nf">var df = sqlContext<br/>    .read<br/>    .format("csv")<br/>    .option("header", "true")<br/>    .option("inferSchema", "true")<br/>    .load("Filestore/tables/train.csv")</span></pre><p id="c702" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看这里发生了什么。Scala 不假设你的数据集有一个头，所以我们需要指定它。另外，Python 会自动为 dataframe 列分配一个 dtype，而 Scala 不会这样做，除非我们指定<code class="fe ng nh ni mx b">.option("inferSchema", "true")</code>。还要注意，我没有导入 Spark Dataframe，因为我在<a class="ae kc" href="https://databricks.com/" rel="noopener ugc nofollow" target="_blank"> Databricks </a>中练习 Scala，它是预加载的。否则我们将需要这样做。</p><blockquote class="lb lc ld"><p id="9fad" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">注意:在 Python 中布尔值是大写的，而在 Scala 中是小写的！</p></blockquote><h1 id="490c" class="lp lq iq bd lr ls nj lu lv lw nk ly lz ma nl mc md me nm mg mh mi nn mk ml mm bi translated">2.显示数据帧的前几行</h1><p id="ca15" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在<strong class="kf ir"> Python </strong>中，<code class="fe ng nh ni mx b">df.head()</code>将默认显示前五行:输出如下。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/eba440e7a0dcda2e549b86b26b2544f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ZvDRoJd9DXoPLqTp4AlAw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">df.head() output in Python.</figcaption></figure><p id="54db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您希望看到的行数不是 5，您可以在括号中传递一个不同的数字。<strong class="kf ir"> Scala </strong>及其<code class="fe ng nh ni mx b">df.show()</code>，将默认显示前 20 行。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/9e29b7941579c34a87e8420bc2eb9f9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7OfENvo-y_bOk5oGmC9yqQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">df.show() in Scala.</figcaption></figure><p id="5453" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想让它更短，并且去掉省略号，以便阅读列的全部内容，我们可以运行<code class="fe ng nh ni mx b">df.show(5, false)</code>。</p><h1 id="8ccb" class="lp lq iq bd lr ls nj lu lv lw nk ly lz ma nl mc md me nm mg mh mi nn mk ml mm bi translated">3.数据帧列和数据类型</h1><p id="81ef" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">要检索列名，在这两种情况下我们只需键入<code class="fe ng nh ni mx b">df.columns</code> : <strong class="kf ir"> Scala </strong>和<strong class="kf ir"> Pandas </strong>将分别返回一个数组和一个字符串索引。</p><p id="a8a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想要检查 dtypes，那么对于两种语言来说，命令还是一样的:<code class="fe ng nh ni mx b">df.dtypes</code>。Pandas 将返回一个 Series 对象，而 Scala 将返回一个元组数组，每个元组分别包含</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/8fa3f1c28b1c16e1eeb51a546df8229d.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*7TKnEnYemucWRQmQ_Clnmg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">df.dtypes in Python</figcaption></figure><p id="653d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">列和数据类型。因此，如果我们在 Python 中想要检查<em class="le">年龄</em>列是什么类型，我们运行<code class="fe ng nh ni mx b">df.dtypes['Age']</code>，而在 Scala 中我们需要过滤并使用元组索引:<code class="fe ng nh ni mx b">df.dtypes.filter(colTup =&gt; colTup._1 == "Age")</code>。</p><h1 id="d287" class="lp lq iq bd lr ls nj lu lv lw nk ly lz ma nl mc md me nm mg mh mi nn mk ml mm bi translated">4.汇总统计数据</h1><p id="3e90" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">这是每个数据科学家在探索他/她的数据时做的另一件事:汇总统计。对于每一个数字列，我们可以看到诸如计数、均值、中值、偏差等信息，以便立即看到是否有什么地方看起来不对劲。在这两种情况下，这将返回一个数据帧，其中列是原始数据帧的数字列，行是统计值。</p><p id="6bf1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kf ir"> Python </strong>中，我们键入<code class="fe ng nh ni mx b">df.describe()</code>，而在<strong class="kf ir">Scala</strong>T4【中。我们必须在后一种情况下添加<code class="fe ng nh ni mx b">.show()</code>的原因是因为 Scala 不会自动输出结果数据帧，而 Python 会自动输出(只要我们不把它赋给新变量)。</p><h1 id="70b3" class="lp lq iq bd lr ls nj lu lv lw nk ly lz ma nl mc md me nm mg mh mi nn mk ml mm bi translated">5.选择列</h1><p id="06a3" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">假设我们希望看到列的子集，例如名称为和<em class="le">的列保留了下来。</em></p><p id="4b79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kf ir"> Python </strong>中，我们可以不加区分地使用<code class="fe ng nh ni mx b">df[['Name','Survived]]</code>或<code class="fe ng nh ni mx b">df.loc[:,['Name','Survived]</code>。请记住，这里的<code class="fe ng nh ni mx b">:</code>表示“所有行”。</p><p id="fa22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kf ir"> Scala </strong>中，我们会键入<code class="fe ng nh ni mx b">df.select("Name","Survived").show()</code>。如果你想把子集赋给一个新变量，记得省略<code class="fe ng nh ni mx b">.show()</code>。</p><h1 id="40fe" class="lp lq iq bd lr ls nj lu lv lw nk ly lz ma nl mc md me nm mg mh mi nn mk ml mm bi translated">6.过滤</h1><p id="b50c" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">假设我们想看看幸存乘客的姓名和职业。我们需要在<em class="le">幸存</em>列中过滤一个条件，然后选择其他条件。</p><p id="1a28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kf ir"> Python </strong>中，我们将再次使用<code class="fe ng nh ni mx b">.loc</code>，通过在行的位置传递过滤器，然后用列表选择列。基本上和上面的例子一样，但是用一个过滤器代替了<code class="fe ng nh ni mx b">:</code>，这意味着<code class="fe ng nh ni mx b">df.loc[df['Survived'] == 1, ['Name','Pclass']]</code>。</p><p id="286c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kf ir"> Scala </strong>中我们将使用<code class="fe ng nh ni mx b">.filter</code>后跟<code class="fe ng nh ni mx b">.select</code>，也就是<code class="fe ng nh ni mx b">df.filter("Survived = 1").select("Name","Pclass").show()</code>。</p><h2 id="2956" class="nb lq iq bd lr nr ns dn lv nt nu dp lz ko nv nw md ks nx ny mh kw nz oa ml ob bi translated">6.1.过滤空值</h2><p id="65ef" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">如果我们想要检查空值，例如在<em class="le">开始的</em>列中，它将像普通过滤器一样工作，只是条件不同。</p><p id="38a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kf ir"> Python </strong>中，我们在传递条件时应用<code class="fe ng nh ni mx b">.isnull()</code>，在本例中是<code class="fe ng nh ni mx b">df[df['Embarked'].isnull()]</code>。由于我们没有指定任何列，这将返回一个 dataframe，它将包含所有原始列，但只有包含<em class="le">和</em>值的行是空的。</p><p id="a1d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kf ir"> Scala </strong>中，我们将再次使用<code class="fe ng nh ni mx b">.filter</code>:<code class="fe ng nh ni mx b">df.filter("Embarked IS NULL").show()</code>。注意，我们在 Scala 中传递的布尔过滤器有点像 SQL 查询。</p><h1 id="3446" class="lp lq iq bd lr ls nj lu lv lw nk ly lz ma nl mc md me nm mg mh mi nn mk ml mm bi translated">7.输入空值</h1><p id="23eb" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在数据集中输入空值之前，我们应该始终进行一些思考，因为它会影响我们的最终模型，我们希望对此保持谨慎。然而，仅仅出于演示的目的，假设我们想将字符串“N/A”归入数据帧中的空值。</p><p id="cd82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe ng nh ni mx b">df = df.fillna('N/A')</code>或<code class="fe ng nh ni mx b">df.fillna('N/A', inplace = True)</code>在<strong class="kf ir"> Python </strong>中这样做。</p><p id="97c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kf ir"> Scala </strong>中，非常类似地，这将通过<code class="fe ng nh ni mx b">df = df.na.fill("N/A")</code>来实现。记住在这种情况下不要使用<code class="fe ng nh ni mx b">.show()</code>,因为我们正在将修改后的数据帧赋给一个变量。</p><h1 id="7136" class="lp lq iq bd lr ls nj lu lv lw nk ly lz ma nl mc md me nm mg mh mi nn mk ml mm bi translated">8.重命名列</h1><p id="b029" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">这是你在 Scala 中需要确定的事情，因为机器学习模型需要两个名为<em class="le">特征</em>和<em class="le">标签</em>的列来训练。然而，举例来说，如果您不喜欢某个列的命名方式，您可能也想在 Pandas 中这样做。为此，我们想将幸存的<em class="le">列改为<em class="le">标签</em>。</em></p><p id="8686" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kf ir"> Python </strong>中，我们将传递一个字典，其中的键和值分别是列的旧名称和新名称。这种情况下会是<code class="fe ng nh ni mx b">df.rename(columns = {"Survived": "label"}, inplace = True)</code>。</p><p id="f676" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kf ir"> Scala </strong>中，这等于<code class="fe ng nh ni mx b">df = df.withColumnRenamed("Survived", "label")</code>。</p><h1 id="ae77" class="lp lq iq bd lr ls nj lu lv lw nk ly lz ma nl mc md me nm mg mh mi nn mk ml mm bi translated">9.分组依据和聚合</h1><p id="5a86" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">假设我们想要分别计算男性和女性的最大<em class="le">年龄</em>，在这种情况下<code class="fe ng nh ni mx b">.groubpby</code>会派上用场。不仅检索最大值；在<code class="fe ng nh ni mx b">.groupby</code>之后，我们可以使用各种聚合函数:均值、计数、中位数等等。对于这个例子，我们坚持使用<code class="fe ng nh ni mx b">.max()</code>。</p><p id="4577" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kf ir"> Python </strong>中，这将是<code class="fe ng nh ni mx b">df.groupby('Sex').mean()['Age']</code>。如果我们不在<code class="fe ng nh ni mx b">.mean()</code>后指定<code class="fe ng nh ni mx b">['Age']</code>，这将返回一个 dataframe，其中包含所有数字列的最大值，并按<em class="le">性别</em>分组。</p><p id="0651" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kf ir"> Scala </strong>中，我们首先需要导入我们想要使用的聚合函数。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="daac" class="nb lq iq mx b gy nc nd l ne nf">import org.apache.spark.sql.functions.max<br/>df.groupBy("Sex").agg(max("Age")).show()</span></pre><h1 id="8b9f" class="lp lq iq bd lr ls nj lu lv lw nk ly lz ma nl mc md me nm mg mh mi nn mk ml mm bi translated">10.创建新列</h1><p id="d2ad" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">这对于特征工程来说非常有用，我们可能想要结合两个变量来看它们的交互是如何与目标相关的。出于纯粹的演示目的，让我们看看如何创建一个包含在<em class="le">年龄</em>和<em class="le">费用之间的产品的列。</em></p><p id="7051" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 Python 中，这非常简单。</p><p id="b887" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ng nh ni mx b">df['Age_times_Fare'] = df['Age'] * df['Fare']</code></p><p id="0893" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kf ir"> Scala </strong>中，我们需要将<code class="fe ng nh ni mx b">$</code>放在我们想要使用的列的名称之前，以便考虑具有相应名称的列对象。</p><p id="37af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ng nh ni mx b">df = df.withColumn("AgeTimesFare", $"Age" * $"Fare")</code></p><h1 id="edf7" class="lp lq iq bd lr ls nj lu lv lw nk ly lz ma nl mc md me nm mg mh mi nn mk ml mm bi translated">11.相互关系</h1><p id="71b2" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">探索数字变量和目标之间的相关性总是很方便的，在<strong class="kf ir"> Python </strong>中，只需运行<code class="fe ng nh ni mx b">df.corr()</code>就可以获得所有数字变量之间的相关系数矩阵。如果您想查看相关性，假设在<em class="le">年龄</em>和<em class="le">票价</em>之间，我们只需指定列:<code class="fe ng nh ni mx b">df[['Age','Fare']].corr()</code>。</p><p id="840d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 Scala 中，我们首先需要导入，然后通过指定列来运行命令。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="fe9f" class="nb lq iq mx b gy nc nd l ne nf">import org.apache.spark.sql.functions.corr<br/>df.select(corr("Age","Fare")).show()</span></pre></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><p id="8427" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这个！我希望你觉得这篇文章很有用，就像我写这篇文章一样有用。我打算发表第三部分，在那里我可以通过机器学习模型的例子来完成这个循环！</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/e617ba7ebe3f3cc33ed5ad510738322e.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*-3XTARCS1twqTj73tB78wg.png"/></div></figure><p id="c737" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请随意查看:</p><p id="f01f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" rel="noopener" target="_blank" href="/python-vs-scala-a-comparison-of-the-basic-commands-fae23b3ede23">本帖第一部分</a>。</p><p id="b6ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://medium.com/@emmagrimaldi" rel="noopener">我的其他中帖。</a></p><p id="e83a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的 LinkedIn 个人资料。</p><p id="4fe9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">感谢您的阅读！</strong></p></div></div>    
</body>
</html>