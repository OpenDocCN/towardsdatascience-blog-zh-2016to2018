<html>
<head>
<title>How I test Ruby APIs in a non-Rails environment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何在非 Rails 环境中测试 Ruby APIs</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-i-test-ruby-apis-in-a-non-rails-environment-718aba24b189?source=collection_archive---------1-----------------------#2017-01-31">https://towardsdatascience.com/how-i-test-ruby-apis-in-a-non-rails-environment-718aba24b189?source=collection_archive---------1-----------------------#2017-01-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9fc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我用 Ruby 编程已经快 5 年了，但是(喘气)不要用<a class="ae kl" href="http://rubyonrails.org/" rel="noopener ugc nofollow" target="_blank"> Ruby on Rails </a>。尽管<a class="ae kl" href="http://www.sinatrarb.com/" rel="noopener ugc nofollow" target="_blank"> Sinatra </a>是一个很好的框架，但它可能是 Rails 拥有 Ruby 社区 90%以上的份额之后才想到的。在 Rails 之外让一个 gem 工作并被很好地记录下来，几乎就像在苏联得到一双 Levi's。也就是说，通过一点点尝试和错误，你可以准备好任何宝石生产。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/95b1c24f8220d037809c5f085ae665a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*5-MjnNwjyFa118V36wEg0A.jpeg"/></div></figure><p id="9f1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有时候，让一个专注于 rails 的 gem 在 Rails 之外工作需要更长的时间。例如，我的团队在弄清楚如何让<a class="ae kl" href="https://github.com/rails/rails/tree/master/activerecord" rel="noopener ugc nofollow" target="_blank"> ActiveRecord </a>与多种模式一起工作之前，使用了将近一年的数据映射器。ActiveRecord 是 Rails 核心的一部分，除了自动重新连接失败之外，我们很喜欢它。我们的测试也有类似的问题，这导致我们放弃了测试覆盖率。直到我们的暑期实习生 Parker McGowan 整个夏天都在这个项目上，我们才最终得到了一个好的 Sinatra 测试套件。它看起来是这样的:</p><h1 id="dac6" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">我们如何运行我们的测试</h1><p id="d9eb" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">我们的团队使用非常传统的 web 开发设置。我们选择在前端(Angular)和后端(Ruby)之间进行硬分离。我们使用 Sinatra 框架运行微服务(小型 REST APIs ),并将数据存储在 MySQL 中。我们偶尔会用 Redis，Beanstalk 进行排队，联系 Twitter 之类的公共 API。为了测试，我们选择了<a class="ae kl" href="https://github.com/seattlerb/minitest" rel="noopener ugc nofollow" target="_blank"> MiniTest </a>而不是 Rspec，因为<a class="ae kl" href="https://tenderlovemaking.com/2015/01/23/my-experience-with-minitest-and-rspec.html" rel="noopener ugc nofollow" target="_blank">很像 Tenderlove </a>，我们更喜欢它的语法。它使用普通的老 ruby 代替 DSL，库现在在 core Ruby 中。</p><p id="717c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用 SQLite 作为我们的测试数据库。不要使用 MySQL，因为您的测试会在每次运行时清除您的本地数据库。我们的数据库也遇到了一个有趣的问题。我的团队使用 SQL 已经有 10-15 年了，所以我们更喜欢手工创建表，而不是使用迁移来构建表。它给了我们更多的控制，但是超出了 Rails 的约定，使得用 ActiveRecord 测试变得很痛苦。我们手工创建我们的表，然后使用<a class="ae kl" href="https://github.com/thuss/standalone-migrations" rel="noopener ugc nofollow" target="_blank">独立迁移</a> gem 来生成迁移，然后我们可以使用它来动态生成我们的数据库以供测试。</p><p id="d652" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lx">注意:如果您使用独立迁移，您将使用</em> <strong class="jp ir"> <em class="lx">。standalone _ migrations</em></strong><em class="lx">文件而不是 Rakefile。看起来是这样的:</em></p><pre class="kn ko kp kq gt ly lz ma mb aw mc bi"><span id="ffa4" class="md kv iq lz b gy me mf l mg mh"># .standalone_migrations</span><span id="edb0" class="md kv iq lz b gy mi mf l mg mh">config:<br/> database: config/development.yml<br/>db:<br/> schema: test/db/schema.rb</span></pre><p id="0ec8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们用<code class="fe mj mk ml lz b">bundle exec rake test</code>从命令行运行我们的测试</p><p id="08f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的每个测试都需要测试助手文件:</p><pre class="kn ko kp kq gt ly lz ma mb aw mc bi"><span id="e74f" class="md kv iq lz b gy me mf l mg mh"># /test/helper.rb</span><span id="1224" class="md kv iq lz b gy mi mf l mg mh"><strong class="lz ir"># Setup our test environment</strong><br/>ENV[‘RACK_ENV’] = ‘test’<br/>require ‘minitest/autorun’<br/>require ‘mocha/mini_test’<br/>require ‘rack/test’</span><span id="6443" class="md kv iq lz b gy mi mf l mg mh"><strong class="lz ir"># Include our application</strong><br/>$LOAD_PATH.unshift ‘lib’<br/>$LOAD_PATH.unshift ‘routes’<br/>require File.expand_path ‘../../app.rb’, __FILE__ <strong class="lz ir"># Sinatra App</strong></span><span id="162a" class="md kv iq lz b gy mi mf l mg mh"><strong class="lz ir"># Setup database (and tear it down afterwards)</strong><br/>test_db = SQLite3::Database.new(‘test/db/test.db’)</span><span id="fa2e" class="md kv iq lz b gy mi mf l mg mh">Minitest.after_run do<br/> test_db.close<br/> File.delete(‘test/db/test.db’)<br/>end</span><span id="abcf" class="md kv iq lz b gy mi mf l mg mh">ActiveRecord::Base.establish_connection adapter: ‘sqlite3’, database: ‘test/db/test.db’<br/>load ‘test/db/schema.rb’</span></pre><p id="96ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这设置了我们的测试环境，包括我们的测试框架(rack 和 minitest)和 mocha 我们的模拟库。然后，在启动数据库和运行迁移之前，我们包括我们的应用程序特定的文件。由于 ActiveRecord 连接的运行方式，我们只运行一次迁移来构建我们的结构。为了保持测试的整洁，我们在每次测试后都清除数据库(截断表而不是删除它)。</p><h1 id="48d4" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">试验</h1><p id="3238" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">我们的自动化测试分为两类:<a class="ae kl" href="https://en.wikipedia.org/wiki/Unit_testing" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">单元</strong> </a>和<a class="ae kl" href="https://en.wikipedia.org/wiki/Integration_testing" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">集成</strong> </a>。我为库和助手编写单元测试，为路由编写集成测试。单元测试范围很小，但是很全面。他们也跑得非常快。集成测试可以覆盖很多动作，有时会测试多个 API 调用。状态被大量修改，所以从一个干净的石板开始每个单独的测试是必要的。此外，您必须假设集成测试中的单元正在工作。稍后我们将讨论当我们测试特定于业务的代码时，如何使用模拟来忽略经过良好测试的库。</p><p id="ca80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自动化测试基于一个简单的度量:<a class="ae kl" href="http://docs.seattlerb.org/minitest/Minitest/Assertions.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">断言</strong> </a>。你要么通过你的断言，要么失败。尽管有大量的断言(和反驳)可用，我倾向于只使用这些:</p><pre class="kn ko kp kq gt ly lz ma mb aw mc bi"><span id="ef65" class="md kv iq lz b gy me mf l mg mh"><strong class="lz ir">assert</strong>        # is it truthy?</span><span id="1406" class="md kv iq lz b gy mi mf l mg mh"><strong class="lz ir">assert_nil</strong>    # is it nil?</span><span id="7957" class="md kv iq lz b gy mi mf l mg mh"><strong class="lz ir">assert_equal</strong>  # do the 2 parameters match?</span><span id="9f63" class="md kv iq lz b gy mi mf l mg mh"><strong class="lz ir">assert_match</strong>  # test string against a pattern</span></pre><h1 id="0c73" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">单元测试</h1><p id="822a" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">那么应该如何选择用单元测试测试什么，用集成测试测试什么呢？我建议为副作用少、代码使用频繁的库编写单元测试。我认为为您的数据库模型编写它们是很忙的，因为您的 ORM 应该经过良好的测试。对于包装类(例如，包装对另一个 API 的调用的方法)，我也会忽略它们。话又说回来，我倾向于只写集成测试，除非一个库几乎没有副作用(错误不太可能发生在那些方法中看不到的代码中)并且经常被使用:</p><ul class=""><li id="21e1" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated"><strong class="jp ir">人物计数器</strong>——我的<a class="ae kl" href="http://edgetheory.com" rel="noopener ugc nofollow" target="_blank">公司</a>为社交媒体编写工具。我们必须在用户发送/安排消息之前验证文本的长度。</li><li id="5dfc" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated"><strong class="jp ir">Url shorter 的哈希生成器</strong> —我们运行自己定制的 Url shorter。一个常见的函数是将整数(数据库表 ID)转换为 base 62 字符串，反之亦然。</li></ul><p id="bd75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是 Url Shortener 的一些测试:</p><pre class="kn ko kp kq gt ly lz ma mb aw mc bi"><span id="ab29" class="md kv iq lz b gy me mf l mg mh">require ‘./test/test_helper’</span><span id="191f" class="md kv iq lz b gy mi mf l mg mh">class BaseConversionTest &lt; MiniTest::Test</span><span id="0a64" class="md kv iq lz b gy mi mf l mg mh">def setup<br/> <a class="ae kl" href="http://twitter.com/logger" rel="noopener ugc nofollow" target="_blank">@logger</a> = Logger.new(STDOUT)<br/> end</span><span id="16dd" class="md kv iq lz b gy mi mf l mg mh"># Encode</span><span id="b881" class="md kv iq lz b gy mi mf l mg mh">def test_convert_b10_to_b62_zero<br/> assert_equal(‘0’, Leadify::LinkShortener::Math.to_base(0, base=62))<br/> end</span><span id="8eba" class="md kv iq lz b gy mi mf l mg mh">def test_convert_b10_to_b62_one_digit<br/> assert_equal(‘5’, Leadify::LinkShortener::Math.to_base(5, base=62))<br/> end</span><span id="0bd8" class="md kv iq lz b gy mi mf l mg mh">def test_convert_b10_to_b62_two_digit<br/> assert_equal(‘A’, Leadify::LinkShortener::Math.to_base(36, base=62))<br/> end</span><span id="91f4" class="md kv iq lz b gy mi mf l mg mh">def test_convert_b10_to_b62_two_digit_b62<br/> assert_equal(‘10’, Leadify::LinkShortener::Math.to_base(62, base=62))<br/> end</span><span id="5288" class="md kv iq lz b gy mi mf l mg mh">def test_convert_b10_to_b62_two_char_b62<br/> assert_equal(‘1A’, Leadify::LinkShortener::Math.to_base(98, base=62))<br/> end</span><span id="4b65" class="md kv iq lz b gy mi mf l mg mh">def test_convert_b10_to_b62_max_two_char_b62<br/> assert_equal(‘ZZ’, Leadify::LinkShortener::Math.to_base(3_843, base=62))<br/> end</span><span id="6b8b" class="md kv iq lz b gy mi mf l mg mh"># ...</span></pre><p id="9da5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，这变得非常乏味。<a class="ae kl" href="https://en.wikipedia.org/wiki/Code_coverage" rel="noopener ugc nofollow" target="_blank">代码覆盖率</a>不够。您必须涵盖代码中可能遇到的所有变化。我们测试 0、5、36、62、98 和 3843。这给了我们一组广泛的数据，让我们可以专注于失败。我们知道，如果我们在新的基本系统中处理一位数、两位数、带进位的两位数，等等。</p><p id="9f0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在为函数编写了这样的测试之后，我们仍然有可能错过一些东西。由于我们有编码和解码功能，我们可以使用我们的代码来测试自己。我们可以做一个<a class="ae kl" href="https://en.wikipedia.org/wiki/Monte_Carlo_method" rel="noopener ugc nofollow" target="_blank">蒙特卡罗模拟</a>，并使用函数<code class="fe mj mk ml lz b">x = decode(encode(x))</code>测试一组随机输入。</p><pre class="kn ko kp kq gt ly lz ma mb aw mc bi"><span id="e7ce" class="md kv iq lz b gy me mf l mg mh"># Reversibility Sampler<br/>def test_monte_carlo_b10_to_b62_to_b10<br/> 1000.times do |i|<br/>  seed = rand(1_073_741_823) # Max 32 bit Fixnum<br/>  b62 = Leadify::LinkShortener::Math.to_base(seed, base=62) <br/>  assert_equal(seed, Leadify::LinkShortener::Math.from_base(b62, base=62))<br/> end<br/>end</span></pre><p id="c5d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但即使这样也不能囊括一切。你的编码器和解码器都可能损坏，但损坏的方式通过了<code class="fe mj mk ml lz b">x = decode(encode(x))</code>测试。你的单元测试应该是健壮的，但是你不能抓住所有的东西。只要尽可能多的测试，当你看到一个失败时，添加一个测试。一旦你修改了你的代码，你就可以解决这个问题了。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><p id="89aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想看一套好的单元测试，看看<a class="ae kl" href="https://github.com/rails/rails/blob/master/activerecord/test" rel="noopener ugc nofollow" target="_blank">热门</a> <a class="ae kl" href="https://github.com/ohler55/oj/tree/master/test" rel="noopener ugc nofollow" target="_blank">库</a>。您还可以使用它们来理解文档记录不良的特性，或者找到有用的未记录的方法。通过阅读其他人的代码，你也可以学习编码风格。</p><h1 id="6d85" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">集成测试</h1><p id="5d56" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">如果单元测试是树，那么集成测试就是森林。我们不再测试小而独特的组件。在我们的 Sinatra 集成测试中，我们通常测试单个 API 调用，然后测试一系列 API 调用。</p><p id="e7af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">创建、读取、更新、删除(CRUD) </strong>路由大量使用我们的永久数据存储，我们使用 ActiveRecord 来访问它。正如我前面提到的，我们在生产中使用 MySQL，在测试中使用 sqlite。除了删除之外，我们所有的路由都返回 JSON 数据。因此，我们可以通过返回的 http 状态代码和输出 JSON 来验证 API 调用的正确性。这里有一个例子:</p><pre class="kn ko kp kq gt ly lz ma mb aw mc bi"><span id="3104" class="md kv iq lz b gy me mf l mg mh"><strong class="lz ir">def test_post_messages_with_message</strong><br/>    post '/messages', text: '<a class="ae kl" href="http://twitter.com/ash_ketchum_all" rel="noopener ugc nofollow" target="_blank">@ash_ketchum_all</a>, check out this pikachu I found digging through the dumpster behind the #Pokestop!'<br/>    assert last_response.ok?</span><span id="9ccd" class="md kv iq lz b gy mi mf l mg mh">    response = Oj.load(last_response.body)<br/>    assert(response.key?('message'))<br/>    message = response['message']<br/>    assert_equal '<a class="ae kl" href="http://twitter.com/ash_ketchum_all" rel="noopener ugc nofollow" target="_blank">@ash_ketchum_all</a>, check out this pikachu I found   digging through the dumpster behind the #Pokestop!', message['text']<br/><strong class="lz ir">end</strong></span></pre><p id="85e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于有了<a class="ae kl" href="https://github.com/brynary/rack-test" rel="noopener ugc nofollow" target="_blank"> Rack::Test </a>库，我们可以进行这些 CRUD 调用。它提供了 http 方法，<code class="fe mj mk ml lz b">get</code>、<code class="fe mj mk ml lz b">post</code>、<code class="fe mj mk ml lz b">put</code>、<code class="fe mj mk ml lz b">patch</code>和<code class="fe mj mk ml lz b">delete</code>。您可以用一种非常简单的方式来调用它们:</p><pre class="kn ko kp kq gt ly lz ma mb aw mc bi"><span id="0496" class="md kv iq lz b gy me mf l mg mh">&lt;http method&gt; &lt;route name&gt;, &lt;parameters&gt;, &lt;headers&gt;</span><span id="045c" class="md kv iq lz b gy mi mf l mg mh"># Examples<br/>get '/messages'<br/>post '/messages', text: "Gotta catch 'em all"<br/>post '/shares', { facebook_post_id: '1337' }, 'rack.session' =&gt; { visit_id: 1 }</span></pre><p id="7d59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些 Rack::Test 方法允许我们导航我们的 API，MiniTest 允许我们断言应用程序的状态是我们所期望的。</p><p id="c2c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的 CRUD 路线整合测试涵盖以下模式:</p><h2 id="7ae9" class="md kv iq bd kw nh ni dn la nj nk dp le jy nl nm li kc nn no lm kg np nq lq nr bi translated"><strong class="ak"> 1)验证</strong></h2><p id="16b2" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">路由是否按照我们期望的方式处理不存在或无效的参数？每次验证失败时，它应该停止执行并返回一个错误代码，有时还会返回一条错误消息(例如，“name 是必填字段”)。</p><h2 id="6057" class="md kv iq bd kw nh ni dn la nj nk dp le jy nl nm li kc nn no lm kg np nq lq nr bi translated">2)输出</h2><p id="4624" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">首先，我们检查 http 状态是成功还是失败。如果它失败了，我们可以就此打住，我们必须找出它出错的原因。</p><p id="b22e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们检查 JSON 输出是什么。它是否返回了一个格式正确的对象？数据是我们预期的吗？如果我们有问题，具体是哪里的问题？</p><h2 id="37eb" class="md kv iq bd kw nh ni dn la nj nk dp le jy nl nm li kc nn no lm kg np nq lq nr bi translated">3)持久数据</h2><p id="dfe3" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">当我们发布、上传或删除数据时，我们希望修改我们的数据。我们可以验证我们的 API 调用返回了正确的输出，但这并不意味着我们的应用程序永久地存储了数据。因为我们使用 ActiveRecord，所以我们可以在测试和生产中使用完全不同的数据库引擎。由于 ActiveRecord 经过了很好的测试，我们简单地假设，如果它在测试中有效，它将在生产中有效。为了验证永久存储中的数据是否被修改，我们只需要在 API 调用后检查我们的数据存储。</p><h2 id="2c40" class="md kv iq bd kw nh ni dn la nj nk dp le jy nl nm li kc nn no lm kg np nq lq nr bi translated">4)业务逻辑</h2><p id="6470" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">API 中总是会有业务逻辑。如果它很小并且容易测试，那么我们可以把它移到库中，为它编写单元测试。那是首选。但是隔离这种行为通常很困难或者很费时间。对于这些情况，我们可以使用集成测试。例如，我们在新用户的注册过程中使用了大量的业务逻辑。我们首先创建一个登录名和一个帐户，然后为用户创建一个订阅，并将其连接到他们的<a class="ae kl" href="http://stripe.com" rel="noopener ugc nofollow" target="_blank"> Stripe </a>订阅。然后，我们的一些用户在完成注册过程并登录我们的 web 应用程序之前授权他们的 twitter 帐户。</p><p id="ca99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们依赖于一些外部依赖(Stripe 和 Twitter)，我们不能通过在测试模式下调用我们的 API 来模拟这一点。我们必须启动一个真正的网络浏览器，通过模拟用户界面上的点击来进行端到端的测试。我们的 UI 超出了 API 测试的范围。此外，我们将依赖这些网站的可用性和速度。出于这些原因，模拟您的数据和模拟您的外部依赖性要好得多。</p><h1 id="5b99" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">嘲弄</h1><p id="ea48" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">当我说<a class="ae kl" href="https://martinfowler.com/articles/mocksArentStubs.html" rel="noopener ugc nofollow" target="_blank"> mocks 时，我实际上是指 stubs </a>。实际上，您可能会听到<em class="lx"> Mock </em>既用于 Mock 又用于 stubs。FWIW，我们用<a class="ae kl" href="https://github.com/freerange/mocha" rel="noopener ugc nofollow" target="_blank">摩卡</a>(懂了吗？)宝石写我们的存根。存根通常用于覆盖类方法。他们的名字来源于他们的长相。下面是一个覆盖 Stripe 类方法的模拟示例:</p><pre class="kn ko kp kq gt ly lz ma mb aw mc bi"><span id="c376" class="md kv iq lz b gy me mf l mg mh"><strong class="lz ir"># Mock for a class method</strong><br/>Stripe::Plan.stubs(:create).returns(<br/>      stripe_uuid: 'vindaloo',<br/>      name: 'Red Dwarf',<br/>      subtitle: 'Spaceship',<br/>      statement_descriptor: 'EDGETHEORY SB VIP',<br/>      amount: 9999,<br/>      currency: 'usd',<br/>      interval: 'month',<br/>      interval_count: 1,<br/>      is_active: false<br/>    )</span></pre><p id="4398" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模拟实例方法需要更多技巧。您必须首先创建一个模拟对象，然后用一个存根来扩展该模拟对象。下面是一个示例存根，它覆盖了他们的计划类的条带实例上的删除方法:</p><pre class="kn ko kp kq gt ly lz ma mb aw mc bi"><span id="7043" class="md kv iq lz b gy me mf l mg mh"><strong class="lz ir"># Mock for an instance method</strong><br/>object = mock('object')<br/>Stripe::Plan.stubs(:retrieve).returns(object)<br/>object.stubs(:delete).returns(true)</span></pre><p id="5291" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些模拟允许我们消除外部 api 的不可预测性和缓慢性。我们在 MiniTest 应用程序的 setup 块中运行这两个代码片段，这样当我们创建或删除一个计划时，我们可以得到一个可预测的结果。当我们创建一个计划时，我们总是返回相同的散列，我们也可以干净地删除一个。</p><h1 id="2144" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">例子</h1><p id="123e" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">我在下面包含了一个完整的集成测试的例子，所以你可以看到一些相关的样板文件。我们包含了<strong class="jp ir">测试助手</strong>，并且必须使用<strong class="jp ir"> app </strong>方法，这样 Rack::Test 就可以访问我们的 Sinatra app 并调用我们的内部 API routes。我还有<strong class="jp ir">设置</strong>(在测试用例运行之前)和<strong class="jp ir">拆卸</strong>(在测试用例完成之后)的方法。</p><pre class="kn ko kp kq gt ly lz ma mb aw mc bi"><span id="2524" class="md kv iq lz b gy me mf l mg mh">require File.expand_path '../helper.rb', __FILE__</span><span id="ab5b" class="md kv iq lz b gy mi mf l mg mh">class ShareTest &lt; MiniTest::Test<br/>  include Rack::Test::Methods</span><span id="072d" class="md kv iq lz b gy mi mf l mg mh">def app<br/>    EdgeTheory::Loyalty::ApplicationController # Require our Sinatra app<br/>  end</span><span id="8c85" class="md kv iq lz b gy mi mf l mg mh"><strong class="lz ir"># Called before each individual test case is run</strong><br/>def setup<br/>    @account  = EdgeTheory::DB::Loyalty::Account.create!(name: 'Your Cash Now', key: 'yourcashnow', is_active: true)<br/>    @style    = EdgeTheory::DB::Loyalty::Style.create!(<br/>      account_id: <a class="ae kl" href="http://twitter.com/account" rel="noopener ugc nofollow" target="_blank">@account</a>.id,<br/>      logo: '<a class="ae kl" href="http://rs278.pbsrc.com/albums/kk110/joker8851/PIKACHU.jpg~c200'" rel="noopener ugc nofollow" target="_blank">http://rs278.pbsrc.com/albums/kk110/joker8851/PIKACHU.jpg~c200'</a><br/>    )<br/>    @promotion = EdgeTheory::DB::Loyalty::Promotion.create!(account_id: @account.id)</span><span id="74a5" class="md kv iq lz b gy mi mf l mg mh">@reward = EdgeTheory::DB::Loyalty::Reward.create!(reward_type: 'instant',<br/>                                                      name: 'Your Cash Now',<br/>                                                      title: 'Fast cash, Money Now.',<br/>                                                      instruction: 'Give us your social security number?')<br/>    <a class="ae kl" href="http://twitter.com/promotion" rel="noopener ugc nofollow" target="_blank">@promotion</a>.instant_reward_id = <a class="ae kl" href="http://twitter.com/reward" rel="noopener ugc nofollow" target="_blank">@reward</a>.id<br/>    <a class="ae kl" href="http://twitter.com/promotion" rel="noopener ugc nofollow" target="_blank">@promotion</a>.save<br/>    <a class="ae kl" href="http://twitter.com/message" rel="noopener ugc nofollow" target="_blank">@message</a> = EdgeTheory::DB::Loyalty::Message.create!(account_id: <a class="ae kl" href="http://twitter.com/account" rel="noopener ugc nofollow" target="_blank">@account</a>.id, text: 'They gave me money')</span><span id="7327" class="md kv iq lz b gy mi mf l mg mh"><a class="ae kl" href="http://twitter.com/visit" rel="noopener ugc nofollow" target="_blank">@visit</a> = EdgeTheory::DB::Loyalty::Visit.create!(promotion_id: <a class="ae kl" href="http://twitter.com/promotion" rel="noopener ugc nofollow" target="_blank">@promotion</a>.id)<br/>  end</span><span id="29cb" class="md kv iq lz b gy mi mf l mg mh"><strong class="lz ir"># Called after each individual test case is completed</strong><br/>def teardown<br/>    ActiveRecord::Base.connection.tables.each do |table|<br/>      ActiveRecord::Base.connection.execute("DELETE FROM #{table}")<br/>      ActiveRecord::Base.connection.execute("DELETE FROM sqlite_sequence where name='#{table}'")<br/>    end<br/>    ActiveRecord::Base.connection.execute('VACUUM')<br/>  end</span><span id="6ff9" class="md kv iq lz b gy mi mf l mg mh">def test_requires_visit<br/>    err = assert_raises(EdgeTheory::Loyalty::SessionError) { post '/shares' }<br/>    assert_match('Session has no visit_id', err.message)<br/>  end</span><span id="b395" class="md kv iq lz b gy mi mf l mg mh">def test_share<br/>    post '/shares', {}, 'rack.session' =&gt; { visit_id: <a class="ae kl" href="http://twitter.com/visit" rel="noopener ugc nofollow" target="_blank">@visit</a>.id }<br/>    assert last_response.ok?<br/>  end</span><span id="9c51" class="md kv iq lz b gy mi mf l mg mh">def test_create_share<br/>    post '/shares', {}, 'rack.session' =&gt; { visit_id: <a class="ae kl" href="http://twitter.com/visit" rel="noopener ugc nofollow" target="_blank">@visit</a>.id }<br/>    assert last_response.ok?</span><span id="95b3" class="md kv iq lz b gy mi mf l mg mh">shares = EdgeTheory::DB::Loyalty::Share.all<br/>    assert_equal(1, shares.length)<br/>    assert_equal(1, shares[0].id)<br/>    assert_equal(1, shares[0].visit_id)<br/>  end</span><span id="fd3a" class="md kv iq lz b gy mi mf l mg mh">def test_create_share_with_facebook_post_id<br/>    post '/shares', { facebook_post_id: '1337' }, 'rack.session' =&gt; { visit_id: <a class="ae kl" href="http://twitter.com/visit" rel="noopener ugc nofollow" target="_blank">@visit</a>.id }<br/>    assert last_response.ok?</span><span id="3801" class="md kv iq lz b gy mi mf l mg mh">shares = EdgeTheory::DB::Loyalty::Share.all<br/>    assert_equal('1337', shares[0].facebook_post_id)<br/>  end</span><span id="8e2c" class="md kv iq lz b gy mi mf l mg mh">def test_create_share_with_message<br/>    post '/shares', { message_id: 1 }, 'rack.session' =&gt; { visit_id: <a class="ae kl" href="http://twitter.com/visit" rel="noopener ugc nofollow" target="_blank">@visit</a>.id }<br/>    assert last_response.ok?</span><span id="57a0" class="md kv iq lz b gy mi mf l mg mh">shares = EdgeTheory::DB::Loyalty::Share.all<br/>    assert_equal(1, shares[0].message_id)<br/>  end</span><span id="2ac9" class="md kv iq lz b gy mi mf l mg mh">def test_create_share_with_invalid_message<br/>    post '/shares', { message_id: 1_337 }, 'rack.session' =&gt; { visit_id: <a class="ae kl" href="http://twitter.com/visit" rel="noopener ugc nofollow" target="_blank">@visit</a>.id }<br/>    assert last_response.ok?</span><span id="e68e" class="md kv iq lz b gy mi mf l mg mh">shares = EdgeTheory::DB::Loyalty::Share.all<br/>    assert_equal(1, shares.length)<br/>    assert_equal(1, shares[0].id)<br/>    assert_equal(1_337, shares[0].message_id)<br/>  end</span><span id="48e1" class="md kv iq lz b gy mi mf l mg mh">def test_create_share_with_message_and_facebook_post_id<br/>    post '/shares', { message_id: 1, facebook_post_id: '1337' }, 'rack.session' =&gt; { visit_id: <a class="ae kl" href="http://twitter.com/visit" rel="noopener ugc nofollow" target="_blank">@visit</a>.id }<br/>    assert last_response.ok?</span><span id="9efd" class="md kv iq lz b gy mi mf l mg mh">shares = EdgeTheory::DB::Loyalty::Share.all<br/>    assert_equal(1, shares[0].message_id)<br/>    assert_equal('1337', shares[0].facebook_post_id)<br/>  end<br/>end</span></pre><h1 id="f448" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">进一步阅读</h1><p id="bc73" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">我希望你觉得这很有用。我不想写一个正式的教程，而是想把几个月的学习成果传递给大家，我绞尽脑汁，直到最终在 Ruby 中完成测试。</p><div class="ns nt gp gr nu nv"><a href="http://www.iain.nl/testing-activerecord-in-isolation" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">隔离测试 active record-Iain . nl</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">不加载 Rails 测试 ActiveRecord 并不困难。让我告诉你如何开始。</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">www.iain.nl</p></div></div></div></a></div><div class="ns nt gp gr nu nv"><a href="http://www.mattsears.com/articles/2011/12/10/minitest-quick-reference/" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">马特·西尔斯|迷你测试快速参考</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">给出了所有 MiniTest 断言的示例</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">www.mattsears.com</p></div></div></div></a></div><div class="ns nt gp gr nu nv"><a href="http://www.sinatrarb.com/testing.html" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">使用 Rack 测试 Sinatra::Test</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">以下各节中的所有示例都假定正在使用，以尽可能做到通用。请参见…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">www.sinatrarb.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj ks nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a href="https://martinfowler.com/articles/mocksArentStubs.html" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">模仿不是树桩</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">几年前，我在极限编程(XP)社区第一次接触到“模拟对象”这个术语。从那以后我就…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">martinfowler.com</p></div></div><div class="oe l"><div class="ok l og oh oi oe oj ks nv"/></div></div></a></div></div></div>    
</body>
</html>