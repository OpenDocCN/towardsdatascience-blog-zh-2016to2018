<html>
<head>
<title>Part 3: Implementation in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第 3 部分:Java 实现</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/part-3-implementation-in-java-7bd305faad0?source=collection_archive---------15-----------------------#2018-12-15">https://towardsdatascience.com/part-3-implementation-in-java-7bd305faad0?source=collection_archive---------15-----------------------#2018-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="bfab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，您将看到如何用易于理解的 java 代码实现前两篇文章中介绍的理论。完整的神经网络实现可以下载、详细检查、构建和实验。</p><p id="010c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是系列文章的第三部分:</p><ul class=""><li id="bd40" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><a class="ae ku" href="https://medium.com/@tobias_hill/part-1-a-neural-network-from-scratch-foundation-e2d119df0f40" rel="noopener">第一部分:基础</a>。</li><li id="b666" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><a class="ae ku" href="https://medium.com/@tobias_hill/part-2-gradient-descent-and-backpropagation-bf90932c066a" rel="noopener">第二部分:梯度下降和反向传播</a>。</li><li id="efe3" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><a class="ae ku" href="https://medium.com/@tobias_hill/part-3-implementation-in-java-7bd305faad0" rel="noopener">第 3 部分:用 Java 实现</a>。</li><li id="9799" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">第四部分:更好、更快、更强。</li><li id="8dfa" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><a class="ae ku" href="https://medium.com/@tobias_hill/part-5-training-the-network-to-read-handwritten-digits-c2288f1a2de3" rel="noopener">第 5 部分:训练网络阅读手写数字</a>。</li><li id="3191" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><a class="ae ku" href="https://medium.com/@tobias_hill/extra-1-how-i-got-1-better-accuracy-by-data-augmentation-2475c509349a" rel="noopener">额外 1:我如何通过数据扩充提高 1%的准确度</a>。</li><li id="73cb" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><a class="ae ku" href="https://machinelearning.tobiashill.se/extra-2-a-mnist-playground/" rel="noopener ugc nofollow" target="_blank">号外 2:MNIST 游乐场</a>。</li></ul><p id="9d14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我假设您已经阅读了前两篇文章，并且对神经网络的前向传递和学习/训练传递有了相当好的理解。</p><p id="f21f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章会很不一样。它将用几段 java 代码来展示和描述这一切。</p><p id="e1fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我所有的代码，一个完全工作的神经网络实现，可以在这里找到、检查和下载<a class="ae ku" href="https://bitbucket.org/tobias_hill/neuralnet/src/master/" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="adea" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">追求</h1><p id="ac59" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">通常在编写软件时，我会使用大量的开源软件。这样我能更快地得到好的结果，并且我能使用别人花了很多心思的好的抽象概念。</p><p id="da08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而这一次不同了。我的目标是展示一个神经网络是如何工作的，并且只需要你了解其他开源库。如果你设法阅读 Java 8 代码，你应该没问题。这些都在几个简短而整洁的文件里。</p><p id="e549" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个野心的结果是我甚至没有导入线性代数的库。相反，创建了两个简单的类，只包含所需的操作——满足通常的猜想:Vec 和 Matrix 类。这两个都是非常普通的实现，包含典型的算术运算加、减、乘和点积。</p><p id="2334" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">向量和矩阵的好处在于，它们通常可以用来使代码更有表现力、更整洁。通常，当您面临对一个集合中的每个元素与另一个集合中的每个其他元素进行运算时，例如对一组输入进行<em class="md">加权求和，您很有可能可以将数据排列成向量和/或矩阵，并获得非常紧凑且富有表现力的代码。神经网络也不例外。</em></p><p id="9413" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也尽可能地通过使用 Vec 和 Matrix 类型的对象来压缩计算。结果是整洁的，离数学表达式不远。for-loops 中没有 for-loops 模糊了俯视图。然而，在检查代码时，我鼓励你确保对 Vec 或 Matrix 类型对象的任何看起来简洁的调用实际上都产生了一系列算术运算，这些运算在<a class="ae ku" href="https://medium.com/@tobias_hill/part-1-a-neural-network-from-scratch-foundation-e2d119df0f40" rel="noopener">第 1 部分</a>和<a class="ae ku" href="https://medium.com/@tobias_hill/part-2-gradient-descent-and-backpropagation-bf90932c066a" rel="noopener">第 2 部分</a>中有定义。</p><p id="0f93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Vec 类上的两个操作不像我上面提到的典型操作那样常见。这些是:</p><ul class=""><li id="1333" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><a class="ae ku" href="https://en.wikipedia.org/wiki/Outer_product" rel="noopener ugc nofollow" target="_blank">外积</a> (Vec.outerProduct())，它是列向量和行向量的逐元素乘法，产生一个矩阵。</li><li id="e6f7" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><a class="ae ku" href="https://en.wikipedia.org/wiki/Hadamard_product_(matrices)" rel="noopener ugc nofollow" target="_blank"> Hadamard 乘积</a> (Vec.elementProduct())，它只是两个向量(都是列向量或行向量)的逐元素乘法，产生一个新向量。</li></ul><h1 id="0a98" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">概观</h1><p id="6010" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">典型的<strong class="jp ir">神经网络</strong>有许多层。每个<strong class="jp ir">层</strong>可以是任意大小，包含前一层与其自身之间的权重以及偏差。每一层还配置了一个<strong class="jp ir">激活</strong>和一个<strong class="jp ir">优化器</strong>(后面会详细介绍)。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi me"><img src="../Images/5ce64b7380763dc3b5cc0861d7abaca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mFcxrobalNNUdcGQO0N6kg.png"/></div></div></figure><p id="2e95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无论何时设计高度可配置的东西，构建器模式都是一个好的选择。这为我们提供了一种非常简单易懂的方法来定义和创建神经网络:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="88e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要使用这样一个网络，通常要么给它提供一个输入向量，要么在调用<strong class="jp ir">evaluate()</strong>-方法时添加一个预期结果。当进行后者时，网络将观察实际输出和预期输出之间的差异，并存储这一印象。换句话说，它将反向传播错误。出于很好的原因(我将在下一篇文章中回到这一点)，网络不会立即更新它的权重和偏差。要做到这一点，也就是让任何印象“深入人心”，必须调用<strong class="jp ir">updatefromleang()</strong>。例如:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="e203" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">正向输送</h1><p id="c830" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">让我们深入研究一下<strong class="jp ir"> evaluate() </strong>方法中的前馈通道。请注意下面(第 9 行和第 10 行)输入数据是逐层传递的:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="8c0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在层内，输入向量与权重相乘，然后加上偏差。这又被用作激活功能的输入。见第 11 行。该层还存储输出向量，因为它用于反向传播。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="0f92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(我将在下一篇文章中回到 out 变量上的 get 和 set 操作的原因。现在就把它看作是 Vec 类型的变量)</p><h1 id="41d5" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">激活功能</h1><p id="0bd2" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">该代码包含一些预定义的激活函数。其中每一个都包含实际的激活函数，<strong class="jp ir"> σ </strong>，以及导数，<strong class="jp ir">σ’</strong>。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="2e77" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">成本函数</h1><p id="9256" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">还包括一些成本函数。二次曲线看起来像这样:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="428d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">成本函数有一种计算总成本(作为标量)的方法，但也有一种重要的成本函数微分法，可用于</p><h1 id="1f29" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">反向传播</h1><p id="d955" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">正如我在前面关于前馈传递的部分中提到的:如果一个预期的结果被传递给 evaluate 函数，网络将通过调用<strong class="jp ir"> learnFrom() </strong> -method 从中学习。请参见第 12–13 行。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="a165" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在该方法中，实际的反向传播发生了。在这里，你应该能够在代码中详细地遵循<a class="ae ku" href="https://medium.com/@tobias_hill/part-2-gradient-descent-and-backpropagation-bf90932c066a" rel="noopener">第 2 部分</a>的步骤。看到<a class="ae ku" href="https://medium.com/@tobias_hill/part-2-gradient-descent-and-backpropagation-bf90932c066a" rel="noopener">第二部分</a>中相当冗长的数学表达式可以归结为以下内容，这也多少令人欣慰:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="e3a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，反向传播中的<em class="md">学习</em>(偏导数)是通过调用<strong class="jp ir">adddeltaweightsandbias()</strong>-方法逐层存储的。</p><p id="b4cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">直到调用<strong class="jp ir">update from learning()</strong>-方法后，权重和偏差才会改变:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="7f1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之所以将此设计为两个独立的步骤，是因为它允许网络观察大量样本并从中学习……然后最终更新权重和偏差，作为所有观察的平均值。这实际上叫做<em class="md">批量梯度下降</em>或<em class="md">小型批量梯度下降</em>。我们将在下一篇文章中回到这些变体。现在，您也可以在每次调用后调用 updateFromLearning 来评估(带着期望)以使网络在每次采样后得到改进。在每个样本之后更新网络，这被称为<em class="md">随机梯度下降</em>。</p><p id="e395" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是<strong class="jp ir">updateWeightsAndBias()</strong>-方法的样子。请注意，权重和偏差的所有计算更改的平均值被提供给优化器对象上的两个方法<strong class="jp ir"> updateWeights() </strong>和<strong class="jp ir"> updateBias() </strong>。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="42d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还没有真正讨论过优化器的概念。我们已经说过，权重和偏差是通过减去用一些小的学习率缩放的偏导数来更新的，即:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ms"><img src="../Images/625508bf08c11d3bc76f98829cebf82a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*slkV-Ua67d9cVFuiIGOQLA.png"/></div></div></figure><p id="98c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，这是一个很好的方法，也很容易理解。然而，还有其他方法。其中一些稍微复杂一些，但是提供了更快的收敛。关于如何更新权重和偏差的不同策略通常被称为优化器。我们将在下一篇文章中看到另一种方法。因此，将此作为网络可以配置使用的可插拔<a class="ae ku" href="https://en.wikipedia.org/wiki/Strategy_pattern" rel="noopener ugc nofollow" target="_blank">策略</a>是合理的。</p><p id="1d0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们只是使用简单的梯度下降策略来更新我们的权重和偏差:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="1740" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">差不多就是这样。通过几行代码，我们有可能配置一个神经网络，通过它输入数据，并让它学习如何对看不见的数据进行分类。这将在<a class="ae ku" href="https://medium.com/@tobias_hill/part-5-training-the-network-to-read-handwritten-digits-c2288f1a2de3" rel="noopener">第 5 部分:训练网络读取手写数字</a>中显示。</p><p id="a189" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但首先，让我们把这个提升几个档次。第四部分:更好、更快、更强再见。</p><p id="1293" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎反馈！</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="ed55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="md">原载于 2018 年 12 月 15 日</em><a class="ae ku" href="https://machinelearning.tobiashill.se/part-3-implementation-in-java/" rel="noopener ugc nofollow" target="_blank"><em class="md">machine learning . tobiashill . se</em></a><em class="md">。</em></p></div></div>    
</body>
</html>