<html>
<head>
<title>Scopes in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript 中的作用域</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/still-confused-in-js-scopes-f7dae62c16ee?source=collection_archive---------8-----------------------#2018-12-24">https://towardsdatascience.com/still-confused-in-js-scopes-f7dae62c16ee?source=collection_archive---------8-----------------------#2018-12-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/25300581ec324633a0b6e2c57d6cfd7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*roSB7io2f1c1_-U4"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://unsplash.com/@serjosoza?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">sergio souza</a> on <a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="kg kh ki"><p id="01de" class="kj kk kl km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">如果您正在学习 javascript，或者对输出问题感到困惑，甚至难以理解 javascript 的其他核心概念，那么这篇文章将会有所帮助。</p></blockquote><h2 id="1b18" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">什么是示波器？</h2><p id="aee3" class="pw-post-body-paragraph kj kk it km b kn me kp kq kr mf kt ku lr mg kx ky lv mh lb lc lz mi lf lg lh im bi translated">范围是运行时代码中某个特定部分的变量、函数或对象的可访问性。</p><p id="f44b" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lr kw kx ky lv la lb lc lz le lf lg lh im bi translated">当最小特权的<a class="ae kf" href="https://en.wikipedia.org/wiki/Principle_of_least_privilege" rel="noopener ugc nofollow" target="_blank">原则</a>应用于编程语言设计时，它们就出现了。</p><h2 id="c915" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">我们为什么要学它呢？</h2><p id="3020" class="pw-post-body-paragraph kj kk it km b kn me kp kq kr mf kt ku lr mg kx ky lv mh lb lc lz mi lf lg lh im bi translated">它们为你的代码提供了一定程度的安全性，也就是说，只有在真正需要的时候才使用它们。</p><p id="5b53" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lr kw kx ky lv la lb lc lz le lf lg lh im bi translated">界定代码的范围有助于提高效率，跟踪和减少错误。</p><p id="d864" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lr kw kx ky lv la lb lc lz le lf lg lh im bi translated">它还解决了不同作用域中同名变量的命名问题，因此减少了命名空间冲突。</p><h2 id="6139" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">范围的类型有哪些？</h2><ol class=""><li id="d98d" class="mj mk it km b kn me kr mf lr ml lv mm lz mn lh mo mp mq mr bi translated">全球和本地</li><li id="3e75" class="mj mk it km b kn ms kr mt lr mu lv mv lz mw lh mo mp mq mr bi translated">词汇的</li><li id="494d" class="mj mk it km b kn ms kr mt lr mu lv mv lz mw lh mo mp mq mr bi translated">街区</li><li id="1459" class="mj mk it km b kn ms kr mt lr mu lv mv lz mw lh mo mp mq mr bi translated">公共和私人</li></ol><p id="271c" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lr kw kx ky lv la lb lc lz le lf lg lh im bi translated">让我们用实例逐一查看它们。</p><h2 id="3f1e" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">全局范围和局部范围</h2><p id="7c3a" class="pw-post-body-paragraph kj kk it km b kn me kp kq kr mf kt ku lr mg kx ky lv mh lb lc lz mi lf lg lh im bi translated">任何在函数外部声明的变量都属于全局范围，因此可以从代码中的任何地方访问和修改。</p><p id="6436" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lr kw kx ky lv la lb lc lz le lf lg lh im bi translated">函数内部定义的变量在局部范围内。对于该函数的每次调用，它们都有不同的作用域。这意味着同名的变量可以在不同的函数中使用。这是因为这些变量被绑定到它们各自的函数，每个函数都有不同的作用域，并且不能在其他函数中访问。</p><p id="a891" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lr kw kx ky lv la lb lc lz le lf lg lh im bi translated">新函数=新的局部范围——这是规则。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="e88f" class="li lj it nc b gy ng nh l ni nj">// Gobal<br/>var mouse = "Mouse";</span><span id="61da" class="li lj it nc b gy nk nh l ni nj">function test1() {<br/>  // Local<br/>  var name = "Cat";<br/>  console.log(name);<br/>}</span><span id="53b6" class="li lj it nc b gy nk nh l ni nj">function test2() {<br/>  // Local<br/>  var name = "Dog";<br/>  console.log(name);<br/>}</span><span id="a028" class="li lj it nc b gy nk nh l ni nj">test1();<br/>test2();</span><span id="8ce2" class="li lj it nc b gy nk nh l ni nj">console.log(name);</span></pre><h2 id="2dbd" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">词汇范围</h2><p id="896d" class="pw-post-body-paragraph kj kk it km b kn me kp kq kr mf kt ku lr mg kx ky lv mh lb lc lz mi lf lg lh im bi translated">当一个函数在另一个函数中时，内部函数可以访问外部函数中的作用域，这称为词法作用域，也称为静态作用域，因为它可能只在定义它的代码块中被<em class="kl">调用</em>(引用)。</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/5069b1d984c749546b13f7319972324f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vCeupGQE7otzeRZQj0-ZJA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Lexical scope</figcaption></figure><p id="0bf5" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lr kw kx ky lv la lb lc lz le lf lg lh im bi translated">JavaScript 从最里面的范围开始向外搜索，直到找到它要寻找的变量/对象/函数。</p><blockquote class="kg kh ki"><p id="08a3" class="kj kk kl km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">需要记住的重要一点是，词法作用域并不向后工作<em class="it">而不是</em>。也就是说，在上面的例子中，我们不能访问 SocialMedia 函数和 Platform 函数中的注释变量。</p></blockquote><h2 id="0b35" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">块范围</h2><p id="6b56" class="pw-post-body-paragraph kj kk it km b kn me kp kq kr mf kt ku lr mg kx ky lv mh lb lc lz mi lf lg lh im bi translated">像<code class="fe nm nn no nc b">if</code>和<code class="fe nm nn no nc b">switch</code>条件或者<code class="fe nm nn no nc b">for</code>和<code class="fe nm nn no nc b">while</code>循环和{}不像函数这样的块语句，不会创建新的作用域。block 语句中定义的变量将保留在它们原来所在的范围内。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="dd67" class="li lj it nc b gy ng nh l ni nj">// Gobal<br/>var name = "Mouse";</span><span id="0edb" class="li lj it nc b gy nk nh l ni nj">{<br/>  // Local<br/>  var name = "Cat";<br/>  console.log(name); // Cat<br/>}</span><span id="44da" class="li lj it nc b gy nk nh l ni nj">console.log(name); // Mouse</span></pre><p id="0a6f" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lr kw kx ky lv la lb lc lz le lf lg lh im bi translated">让我们看看围绕它的一个面试问题(执行上下文、闭包和范围的混合)</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="654c" class="li lj it nc b gy ng nh l ni nj">for (var i = 0; i &lt; 3; i++) {<br/>  setTimeout(function() { console.log(i); }, 1000 + i);<br/>}</span></pre><p id="f536" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lr kw kx ky lv la lb lc lz le lf lg lh im bi translated">每次分配相同的变量值时，上面将输出 3，3，3。</p><blockquote class="kg kh ki"><p id="fe83" class="kj kk kl km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">在第一次迭代中，console.log(i)将被添加到堆栈中，事件循环检测到它有延迟，它被发送到事件队列，这种情况又发生了 2 次，最后当事件循环开始一个接一个地挑选它们来执行时，由于最后的 i++的缘故，变量 I 的最终值是 3，并且由于变量的范围是相同的，所以当它返回时，每个变量的值都变成 3。</p></blockquote><p id="8985" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lr kw kx ky lv la lb lc lz le lf lg lh im bi translated">然而，ECMAScript 6 引入了<code class="fe nm nn no nc b">let</code>和<code class="fe nm nn no nc b">const</code>关键字。这些关键字可以用来代替<code class="fe nm nn no nc b">var</code>关键字，而<code class="fe nm nn no nc b">let</code>和<code class="fe nm nn no nc b">const</code>关键字支持在块语句中声明局部作用域。</p><p id="362d" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lr kw kx ky lv la lb lc lz le lf lg lh im bi translated">如果我们把 var i 改成 let i，现在让我们看看区别。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="38d7" class="li lj it nc b gy ng nh l ni nj">for (let i = 0; i &lt; 3; i++) {<br/>  setTimeout(function() { console.log(i); }, 1000 + i);<br/>}</span></pre><p id="34ce" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lr kw kx ky lv la lb lc lz le lf lg lh im bi translated">每当创建一个新的变量范围时，上面的函数将输出 0，1，2。</p><h2 id="a24c" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">公共和私有范围</h2><p id="2408" class="pw-post-body-paragraph kj kk it km b kn me kp kq kr mf kt ku lr mg kx ky lv mh lb lc lz mi lf lg lh im bi translated">从公共(全局)范围包装函数使它们免受易受攻击的攻击。但是在 JavaScript 中，没有公共或私有范围这种东西。然而，我们可以模仿他们。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="500c" class="li lj it nc b gy ng nh l ni nj">(function () {   <br/>    var test = function () {<br/>     // do some stuff here   <br/>    }; <br/>})(); <br/>// The parenthesis at the end of the function tells the interpreter to execute it as soon as it reads it without invocation.</span><span id="c6a8" class="li lj it nc b gy nk nh l ni nj">test(); // Uncaught ReferenceError</span></pre><p id="1521" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lr kw kx ky lv la lb lc lz le lf lg lh im bi translated">称为模块模式的设计模式也可以用来创建这样的功能。</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi np"><img src="../Images/8f8b4f8f0c09b84dde644ed58eb881ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WnaeIpYJF2RiVaO0R_1EFw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Private and public scopes in javascript</figcaption></figure><blockquote class="kg kh ki"><p id="b74e" class="kj kk kl km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">modulePattern 的 return 语句包含我们的公共函数。私有函数只是那些不被返回的函数。不返回函数会使它们在 modulePattern 名称空间之外不可访问。但是我们的公共函数可以访问我们的私有函数，这使得它们对于辅助函数来说非常方便。</p></blockquote></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="a73f" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lr kw kx ky lv la lb lc lz le lf lg lh im bi translated">下一篇文章将讨论什么是 javascript 上下文和关于作用域的执行上下文。</p><p id="fe42" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lr kw kx ky lv la lb lc lz le lf lg lh im bi translated">如果您想被添加到我的电子邮件列表中，请考虑在此输入您的电子邮件地址<a class="ae kf" href="https://goo.gl/forms/MOPINWoY7q1f1APu2" rel="noopener ugc nofollow" target="_blank"><strong class="km iu"/></a><strong class="km iu">关注我的</strong><a class="ae kf" href="https://medium.com/@ideepak.jsd" rel="noopener"><strong class="km iu">medium</strong></a><strong class="km iu">阅读更多关于 javascript 的文章，并关注</strong><a class="ae kf" href="https://github.com/dg92" rel="noopener ugc nofollow" target="_blank"><strong class="km iu">github</strong></a><strong class="km iu">查看我的疯狂代码</strong>。如果有什么不清楚或者你想指出什么，请在下面评论。</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="f656" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lr kw kx ky lv la lb lc lz le lf lg lh im bi translated">你可能也会喜欢我的其他文章</p><ol class=""><li id="9e1e" class="mj mk it km b kn ko kr ks lr nx lv ny lz nz lh mo mp mq mr bi translated"><a class="ae kf" href="https://levelup.gitconnected.com/javascript-execution-context-and-hoisting-c2cc4993e37d" rel="noopener ugc nofollow" target="_blank"> Javascript 执行上下文和提升</a></li><li id="ae72" class="mj mk it km b kn ms kr mt lr mu lv mv lz mw lh mo mp mq mr bi translated"><a class="ae kf" href="https://medium.com/datadriveninvestor/javascript-generator-yield-next-async-await-8442d2c77185" rel="noopener"> Javascript —生成器-产出/下一个&amp;异步-等待🤔</a></li><li id="edcb" class="mj mk it km b kn ms kr mt lr mu lv mv lz mw lh mo mp mq mr bi translated"><a class="ae kf" href="https://medium.com/datadriveninvestor/javascript-context-this-keyword-9a78a19d5786" rel="noopener">理解 Javascript‘this’关键字(上下文)</a>。</li><li id="43be" class="mj mk it km b kn ms kr mt lr mu lv mv lz mw lh mo mp mq mr bi translated"><a class="ae kf" href="https://levelup.gitconnected.com/write-beautiful-javascript-with-%CE%BB-fp-es6-350cd64ab5bf" rel="noopener ugc nofollow" target="_blank">带有映射、归约、过滤的 Javascript 数据结构</a></li><li id="201e" class="mj mk it km b kn ms kr mt lr mu lv mv lz mw lh mo mp mq mr bi translated"><a class="ae kf" href="https://medium.com/datadriveninvestor/javascript-currying-vs-partial-application-4db5b2442be8" rel="noopener"> Javascript- Currying VS 部分应用</a></li><li id="7b8f" class="mj mk it km b kn ms kr mt lr mu lv mv lz mw lh mo mp mq mr bi translated"><a class="ae kf" href="https://medium.com/datadriveninvestor/javascript-es6-iterables-and-iterators-de18b54f4d4" rel="noopener"> Javascript ES6 —可迭代程序和迭代器</a></li><li id="a8af" class="mj mk it km b kn ms kr mt lr mu lv mv lz mw lh mo mp mq mr bi translated"><a class="ae kf" href="https://medium.com/datadriveninvestor/why-to-use-javascript-proxy-5cdc69d943e3" rel="noopener"> Javascript —代理</a>，<a class="ae kf" href="https://medium.com/datadriveninvestor/still-confused-in-js-scopes-f7dae62c16ee" rel="noopener"> Javascript —作用域</a></li></ol></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h2 id="1b6d" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">如果你喜欢这篇文章，请随意分享并帮助他人找到它！</h2><p id="100c" class="pw-post-body-paragraph kj kk it km b kn me kp kq kr mf kt ku lr mg kx ky lv mh lb lc lz mi lf lg lh im bi translated"><strong class="km iu">谢谢！</strong></p></div></div>    
</body>
</html>