<html>
<head>
<title>Why you should start using .npy file more often…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么你应该开始使用。npy文件更频繁…</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-you-should-start-using-npy-file-more-often-df2a13cc0161?source=collection_archive---------1-----------------------#2018-03-20">https://towardsdatascience.com/why-you-should-start-using-npy-file-more-often-df2a13cc0161?source=collection_archive---------1-----------------------#2018-03-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="91f5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">数据科学/机器学习需要数据的快速计算和转换。Python中的原生NumPy对象提供了优于常规编程对象的优势。它的工作就像从磁盘上的文件中读取数字数据集一样简单。我们用几行代码展示了它的优势。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b12ac626ccb79acd72aa137e254be8e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a4u9hP8sRmZKu-sZ6BTrDg.png"/></div></div></figure><h2 id="d11e" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">介绍</h2><p id="f7d7" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi mj translated"><span class="l mk ml mm bm mn mo mp mq mr di"> N </span> umpy，简称<a class="ae ms" href="http://numpy.org" rel="noopener ugc nofollow" target="_blank">数值Python </a>，是Python生态系统中高性能科学计算和数据分析所需的基础包。它是几乎所有高级工具如<a class="ae ms" href="https://pandas.pydata.org" rel="noopener ugc nofollow" target="_blank">熊猫</a>和<a class="ae ms" href="http://scikit-learn.org/" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>的基础。<a class="ae ms" href="https://www.tensorflow.org" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>使用NumPy数组作为基本的构建模块，在此基础上他们构建了用于深度学习任务的张量对象和graphflow(在长列表/向量/数字矩阵上大量使用线性代数运算)。</p><p id="156d" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">已经有很多文章展示了Numpy数组相对于普通Python列表的优势。在数据科学、机器学习和Python社区中，您会经常遇到这样的断言:Numpy的速度要快得多，这是因为它的矢量化实现以及它的许多核心例程都是用C语言编写的(基于<a class="ae ms" href="https://en.wikipedia.org/wiki/CPython" rel="noopener ugc nofollow" target="_blank"> CPython框架</a>)。这确实是真的(<a class="ae ms" href="http://notes-on-cython.readthedocs.io/en/latest/std_dev.html" rel="noopener ugc nofollow" target="_blank">这篇文章很好地展示了使用Numpy可以使用的各种选项</a>，甚至可以使用Numpy APIs编写基本的C例程)。Numpy数组是同构类型的密集数组。相反，Python列表是指向对象的指针数组，即使它们都是同一类型。你得到了<a class="ae ms" href="https://en.wikipedia.org/wiki/Locality_of_reference" rel="noopener ugc nofollow" target="_blank">参考位置</a>的好处。</p><p id="5732" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated"><a class="ae ms" rel="noopener" target="_blank" href="/why-you-should-forget-for-loop-for-data-science-code-and-embrace-vectorization-696632622d5f"> <strong class="ls iu"> <em class="my">在我的一篇被大量引用的关于走向数据科学平台</em> </strong> </a>的文章中，我展示了使用Numpy向量化操作相对于传统编程结构(如<em class="my"> for-loop </em>)的优势。</p><blockquote class="mz na nb"><p id="6b84" class="lq lr my ls b lt mt ju lv lw mu jx ly nc mv ma mb nd mw md me ne mx mg mh mi im bi translated">然而，不太为人所知的是，当涉及到从本地(或网络)磁盘存储中重复读取相同数据时，<strong class="ls iu"> Numpy提供了另一个名为。npy文件格式</strong>。这种文件格式使得<strong class="ls iu">的阅读速度比从纯文本或CSV文件中阅读</strong>快得多。</p></blockquote><p id="b0e0" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">问题是——当然，您第一次必须以传统方式读取数据，并创建一个内存中的NumPy <code class="fe nf ng nh ni b">ndarray</code>对象。但是如果您使用同一个CSV文件来重复读取相同的数字数据集，那么将<code class="fe nf ng nh ni b">ndarray</code>存储在<code class="fe nf ng nh ni b">npy</code>文件中，而不是从原始CSV文件中一遍又一遍地读取它，这是非常有意义的。</p><h2 id="2fd7" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">这是什么？NPY文件？</h2><p id="1470" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">这是一种标准的二进制文件格式，用于在磁盘上保存单个任意的NumPy数组。该格式存储了正确重建数组所需的所有形状和数据类型信息，即使在另一台具有不同体系结构的计算机上也是如此。在实现其有限目标的同时，格式被设计得尽可能简单。该实现是纯Python的，并作为主NumPy包的一部分分发。</p><p id="b088" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">该格式必须能够:</p><ul class=""><li id="b797" class="nj nk it ls b lt mt lw mu ld nl lh nm ll nn mi no np nq nr bi translated">表示所有NumPy数组，包括嵌套的记录数组和对象数组。</li><li id="fb13" class="nj nk it ls b lt ns lw nt ld nu lh nv ll nw mi no np nq nr bi translated">以本机二进制形式表示数据。</li><li id="4794" class="nj nk it ls b lt ns lw nt ld nu lh nv ll nw mi no np nq nr bi translated">包含在一个文件中。</li><li id="df8f" class="nj nk it ls b lt ns lw nt ld nu lh nv ll nw mi no np nq nr bi translated">在不同架构的机器上存储重建数组所需的所有信息，包括形状和数据类型。小端和大端数组都必须得到支持，具有小端编号的文件将在任何读取该文件的机器上生成小端数组。这些类型必须根据它们的实际大小来描述。例如，如果具有64位C“long int”的机器写出具有“long int”的数组，则具有32位C“long int”的读取机器将产生具有64位整数的数组。</li><li id="722e" class="nj nk it ls b lt ns lw nt ld nu lh nv ll nw mi no np nq nr bi translated">被逆向工程。数据集通常比创建它们的程序存在的时间更长。一个有能力的开发人员应该能够用他喜欢的编程语言创建一个解决方案，来阅读他得到的没有多少文档的大多数NPY文件。</li><li id="a3dd" class="nj nk it ls b lt ns lw nt ld nu lh nv ll nw mi no np nq nr bi translated">允许数据的内存映射。</li></ul><h2 id="95c3" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">使用简单代码进行演示</h2><p id="9685" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">和往常一样，你可以从我的<a class="ae ms" href="https://github.com/tirthajyoti/PythonMachineLearning" rel="noopener ugc nofollow" target="_blank"> Github库</a>下载<a class="ae ms" href="https://github.com/tirthajyoti/PythonMachineLearning/blob/master/Pandas%20and%20Numpy/Numpy_Reading.ipynb" rel="noopener ugc nofollow" target="_blank">样板代码笔记本</a>。这里我展示了基本的代码片段。</p><p id="c868" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">首先，读取列表中的CSV文件并将其转换为ndarray的常用方法。</p><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="5728" class="ku kv it ni b gy ob oc l od oe">import numpy as np<br/>import time</span><span id="0ee2" class="ku kv it ni b gy of oc l od oe"><strong class="ni iu"># 1 million samples</strong><br/>n_samples=1000000</span><span id="fcec" class="ku kv it ni b gy of oc l od oe"><strong class="ni iu"># Write random floating point numbers as string on a local CSV file</strong><br/>with open('fdata.txt', 'w') as fdata:<br/>    for _ in range(n_samples):<br/>        fdata.write(str(10*np.random.random())+',')</span><span id="12a1" class="ku kv it ni b gy of oc l od oe"><strong class="ni iu"># Read the CSV in a list, convert to ndarray (reshape just for fun) and time it</strong><br/>t1=time.time()<br/>with open('fdata.txt','r') as fdata:<br/>    datastr=fdata.read()<br/>lst = datastr.split(',')<br/>lst.pop()<br/>array_lst=np.array(lst,dtype=float).reshape(1000,1000)<br/>t2=time.time()</span><span id="6c38" class="ku kv it ni b gy of oc l od oe">print(array_lst)<br/>print('\nShape: ',array_lst.shape)<br/>print(f"Time took to read: {t2-t1} seconds.")</span><span id="18be" class="ku kv it ni b gy of oc l od oe">&gt;&gt; [[0.32614787 6.84798256 2.59321025 ... 5.02387324 1.04806225 2.80646522]<br/> [0.42535168 3.77882315 0.91426996 ... 8.43664343 5.50435042 1.17847223]<br/> [1.79458482 5.82172793 5.29433626 ... 3.10556071 2.90960252 7.8021901 ]<br/> ...<br/> [3.04453929 1.0270109  8.04185826 ... 2.21814825 3.56490017 3.72934854]<br/> [7.11767505 7.59239626 5.60733328 ... 8.33572855 3.29231441 8.67716649]<br/> [4.2606672  0.08492747 1.40436949 ... 5.6204355  4.47407948 9.50940101]]</span><span id="f0c9" class="ku kv it ni b gy of oc l od oe">&gt;&gt; Shape:  (1000, 1000)<br/>&gt;&gt; Time took to read: <strong class="ni iu">1.018733024597168 seconds</strong>.</span></pre><p id="fec1" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">这是第一次阅读，无论如何你都要做。<em class="my">但是如果您可能会多次使用同一个数据集</em>，那么，在您的数据科学过程完成之后，不要忘记在<strong class="ls iu">中保存ndarray对象。npy</strong>T5】格式。</p><p id="42f4" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated"><code class="fe nf ng nh ni b"><strong class="ls iu">np.save('fnumpy.npy', array_lst)</strong></code></p><p id="875c" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">因为如果你这样做了，下一次，从磁盘读取将会非常快！</p><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="40f2" class="ku kv it ni b gy ob oc l od oe">t1=time.time()<br/>array_reloaded = np.load('fnumpy.npy')<br/>t2=time.time()</span><span id="a7a2" class="ku kv it ni b gy of oc l od oe">print(array_reloaded)<br/>print('\nShape: ',array_reloaded.shape)<br/>print(f"Time took to load: {t2-t1} seconds.")</span><span id="647d" class="ku kv it ni b gy of oc l od oe">&gt;&gt; [[0.32614787 6.84798256 2.59321025 ... 5.02387324 1.04806225 2.80646522]<br/> [0.42535168 3.77882315 0.91426996 ... 8.43664343 5.50435042 1.17847223]<br/> [1.79458482 5.82172793 5.29433626 ... 3.10556071 2.90960252 7.8021901 ]<br/> ...<br/> [3.04453929 1.0270109  8.04185826 ... 2.21814825 3.56490017 3.72934854]<br/> [7.11767505 7.59239626 5.60733328 ... 8.33572855 3.29231441 8.67716649]<br/> [4.2606672  0.08492747 1.40436949 ... 5.6204355  4.47407948 9.50940101]]</span><span id="8f09" class="ku kv it ni b gy of oc l od oe">&gt;&gt; Shape:  (1000, 1000)<br/>&gt;&gt; Time took to load: <strong class="ni iu">0.009010076522827148 seconds</strong>.</span></pre><p id="d802" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">如果您想以其他形式加载数据，这并不重要，</p><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="aea1" class="ku kv it ni b gy ob oc l od oe">t1=time.time()<br/>array_reloaded = np.load('fnumpy.npy').<strong class="ni iu">reshape(10000,100)</strong><br/>t2=time.time()</span><span id="3c00" class="ku kv it ni b gy of oc l od oe">print(array_reloaded)<br/>print('\nShape: ',array_reloaded.shape)<br/>print(f"Time took to load: {t2-t1} seconds.")</span><span id="c259" class="ku kv it ni b gy of oc l od oe">&gt;&gt; [[0.32614787 6.84798256 2.59321025 ... 3.01180325 2.39479796 0.72345778]<br/> [3.69505384 4.53401889 8.36879084 ... 9.9009631  7.33501957 2.50186053]<br/> [4.35664074 4.07578682 1.71320519 ... 8.33236349 7.2902005  5.27535724]<br/> ...<br/> [1.11051629 5.43382324 3.86440843 ... 4.38217095 0.23810232 1.27995629]<br/> [2.56255361 7.8052843  6.67015391 ... 3.02916997 4.76569949 0.95855667]<br/> [6.06043577 5.8964256  4.57181929 ... 5.6204355  4.47407948 9.50940101]]<br/><br/>&gt;&gt; Shape:  <strong class="ni iu">(10000, 100)</strong><br/>&gt;&gt; Time took to load: <strong class="ni iu">0.010006189346313477 seconds.</strong></span></pre><p id="ad4d" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">事实证明，至少在这种特殊的情况下，磁盘上的文件大小对于。npy格式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/b3c66788da63b6ad886ee1327bf40199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZFKxrRzqMUuAwoEG4IURZA.png"/></div></div></figure><h2 id="4172" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">摘要</h2><p id="0bc3" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">在本文中，我们演示了使用原生NumPy文件格式的效用。npy over CSV，用于读取大型数值数据集。如果需要多次读取同一个CSV数据文件，这可能是一个有用的技巧。</p><p id="68c8" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated">点击阅读更多关于这种文件格式的细节。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="c5b7" class="pw-post-body-paragraph lq lr it ls b lt mt ju lv lw mu jx ly ld mv ma mb lh mw md me ll mx mg mh mi im bi translated"><em class="my">喜欢这篇文章吗？成为</em> <a class="ae ms" href="https://medium.com/@tirthajyoti/membership" rel="noopener"> <strong class="ls iu"> <em class="my">中等会员</em> </strong> </a> <em class="my">继续</em> <strong class="ls iu"> <em class="my">无限制学习</em> </strong> <em class="my">。如果您使用下面的链接，</em> <strong class="ls iu"> <em class="my">，我将收取您的一部分会员费，而不会对您产生额外费用</em> </strong> <em class="my">。</em></p><div class="oo op gp gr oq or"><a href="https://medium.com/@tirthajyoti/membership" rel="noopener follow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">通过我的推荐链接加入Medium—Tirthajyoti Sarkar</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">medium.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf ks or"/></div></div></a></div></div></div>    
</body>
</html>