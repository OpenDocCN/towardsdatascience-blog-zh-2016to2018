<html>
<head>
<title>Using signal processing to extract neural events in Python — Spike sorting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用信号处理提取 Python 中的神经事件——锋电位排序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-signal-processing-to-extract-neural-events-in-python-964437dc7c0?source=collection_archive---------13-----------------------#2018-08-23">https://towardsdatascience.com/using-signal-processing-to-extract-neural-events-in-python-964437dc7c0?source=collection_archive---------13-----------------------#2018-08-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/40d3136b478aca0f3e2d557d90d6fa5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WiCYrTIjgRiHPrtnaBALaA.jpeg"/></div></div></figure><p id="b416" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">生物神经网络，如人脑，由称为神经元的特殊细胞组成。有各种类型的神经元，但它们都基于相同的概念。被称为神经递质的信号分子在突触(两个神经元之间的连接点)释放。神经递质通过与细胞膜内的离子通道相互作用来改变突触后细胞的膜电位。如果突触后细胞的去极化足够强，就会在轴突小丘产生动作电位。动作电位将沿着轴突传播，并触发神经递质释放到突触间隙中，这将影响下一个神经元的膜电位。通过这种方式，信号可以通过(整个)网络从一个细胞传递到下一个细胞，动作电位是突触释放神经递质的触发器。神经通信本质上是电化学的，知道何时以及在何种条件下产生动作电位可以对大脑的工作提供有价值的见解。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi kz"><img src="../Images/8a680f04699ee9e76e75d0da62b5c34c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tpCpuLgmmVwfhRyA8ZRXDA.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">By BruceBlaus [CC BY 3.0 (<a class="ae li" href="https://creativecommons.org/licenses/by/3.0" rel="noopener ugc nofollow" target="_blank">https://creativecommons.org/licenses/by/3.0</a>)], from Wikimedia Commons</figcaption></figure><p id="1c8f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是研究活体大脑中单个神经元的活动是一项具有挑战性的任务。没有一种非侵入性的方法可以在单细胞水平上实时监测神经活动。通常在大脑中插入一个电极来记录其附近的电活动。在这些类型的电生理记录中，动作电位表现为快速高振幅尖峰。但是由于神经元在大脑中密集分布，记录电极通常一次会从不止一个神经元上获得尖峰信号。因此，如果我们想了解单个神经元的行为，我们需要从记录中提取尖峰信号，并检查它们是由一个还是潜在的几个神经元产生的。从数据中提取尖峰并对其进行聚类被称为尖峰排序。在下文中，我们将概述从原始数据中提取单个尖峰并将它们准备用于尖峰排序的过程。</p><h2 id="130a" class="lj lk it bd ll lm ln dn lo lp lq dp lr km ls lt lu kq lv lw lx ku ly lz ma mb bi translated">入门指南</h2><p id="644d" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">所以首先我们需要数据。Matlab 有一个流行的尖峰排序算法叫做<a class="ae li" href="https://www2.le.ac.uk/centres/csn/software" rel="noopener ugc nofollow" target="_blank">波簇</a>。在其网页的<a class="ae li" href="https://www2.le.ac.uk/centres/csn/software" rel="noopener ugc nofollow" target="_blank">数据部分，他们提供了一个测试数据集，我们将在这里使用。根据网页上提供的信息，该录音长约 30 分钟，来自一名癫痫患者。数据存储在。<em class="mh"> ncs </em>文件，这是制造记录系统的公司的数据格式。因此，如果我们想将记录读入 Python，我们需要了解数据是如何存储的。关于<em class="mh">有详细的描述。公司<a class="ae li" href="https://neuralynx.com/software/NeuralynxDataFileFormats.pdf" rel="noopener ugc nofollow" target="_blank">网页</a>上的 ncs </em>文件格式，我们可以用它来导入文件:</a></p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="d31d" class="lj lk it mj b gy mn mo l mp mq">&gt;&gt;&gt; # Define data path<br/>&gt;&gt;&gt; data_file = './UCLA_data/CSC4.Ncs'</span><span id="ad42" class="lj lk it mj b gy mr mo l mp mq">&gt;&gt;&gt; # Header has 16 kilobytes length<br/>&gt;&gt;&gt; header_size   = 16 * 1024</span><span id="c937" class="lj lk it mj b gy mr mo l mp mq">&gt;&gt;&gt; # Open file<br/>&gt;&gt;&gt; fid = open(data_file, 'rb')</span><span id="c443" class="lj lk it mj b gy mr mo l mp mq">&gt;&gt;&gt; # Skip header by shifting position by header size<br/>&gt;&gt;&gt; fid.seek(header_size)</span><span id="8352" class="lj lk it mj b gy mr mo l mp mq">&gt;&gt;&gt; # Read data according to Neuralynx information<br/>&gt;&gt;&gt; data_format = np.dtype([('TimeStamp', np.uint64),<br/>&gt;&gt;&gt;                         ('ChannelNumber', np.uint32),<br/>&gt;&gt;&gt;                         ('SampleFreq', np.uint32),<br/>&gt;&gt;&gt;                         ('NumValidSamples', np.uint32),<br/>&gt;&gt;&gt;                         ('Samples', np.int16, 512)])</span><span id="a673" class="lj lk it mj b gy mr mo l mp mq">&gt;&gt;&gt; raw = np.fromfile(fid, dtype=data_format)</span><span id="ab6b" class="lj lk it mj b gy mr mo l mp mq">&gt;&gt;&gt; # Close file<br/>&gt;&gt;&gt; fid.close()</span><span id="75d7" class="lj lk it mj b gy mr mo l mp mq">&gt;&gt;&gt; # Get sampling frequency<br/>&gt;&gt;&gt; sf = raw['SampleFreq'][0]</span><span id="a3e0" class="lj lk it mj b gy mr mo l mp mq">&gt;&gt;&gt; # Create data vector<br/>&gt;&gt;&gt; data = raw['Samples'].ravel()</span></pre><p id="876f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的代码中我们可以看到<em class="mh">。ncs </em>文件还包含一些关于录音的附加信息。最重要的是，采样频率告诉我们每秒记录了多少数据点。有了采样频率和数据中的样本数，我们现在可以创建一个时间向量，以便绘制信号随时间的变化图。下面的代码将做到这一点，并绘制信号的第一秒。</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="1fe0" class="lj lk it mj b gy mn mo l mp mq">&gt;&gt;&gt; # Determine duration of recording in seconds<br/>&gt;&gt;&gt; dur_sec = data.shape[0]/sf</span><span id="3664" class="lj lk it mj b gy mr mo l mp mq">&gt;&gt;&gt; # Create time vector<br/>&gt;&gt;&gt; time = np.linspace(0, dur_sec,data.shape[0])</span><span id="2f85" class="lj lk it mj b gy mr mo l mp mq">&gt;&gt;&gt; # Plot first second of data<br/>&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(15, 5))<br/>&gt;&gt;&gt; ax.plot(time[0:sf], data[0:sf])<br/>&gt;&gt;&gt; ax.set_title('Broadband; Sampling Frequency: {}Hz'.format(sf), &gt;&gt;&gt;               fontsize=23)<br/>&gt;&gt;&gt; ax.set_xlim(0, time[sf])<br/>&gt;&gt;&gt; ax.set_xlabel('time [s]', fontsize=20)<br/>&gt;&gt;&gt; ax.set_ylabel('amplitude [uV]', fontsize=20)<br/>&gt;&gt;&gt; plt.show()</span></pre><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ms"><img src="../Images/666e39cc648c3ff05b936ca4bd350e7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NHhy4TQnl-TYk4YZw7d0WQ.png"/></div></div></figure><p id="979f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好吧，我们看到尖峰了吗？…不，我们没有。但是我们确实在数据中看到了某种有节奏的活动。那么这是一个有意义的信号吗？同样，答案是否定的。如果我们要计算第一秒数据中的峰值数量，我们最终会得到 60 个峰值，这意味着我们看到的是 60 Hz 的振荡。我们可以通过绘制信号的功率谱来进一步证实这一点，该功率谱在 60 Hz 处显示出清晰的峰值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/0433321791d46270d30c40215a0a64a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*aCXVd7AKX4nJRUM8CwoGnQ.png"/></div></figure><p id="3b4c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在看什么？在我们获得数据的网页上说录音来自伊扎克·弗里德在美国加州大学洛杉矶分校的实验室。美国的供电频率是 60 Hz。因此，我们看到的实际上是数据收集期间房间内电子设备发出的电噪声。</p><h2 id="7f83" class="lj lk it bd ll lm ln dn lo lp lq dp lr km ls lt lu kq lv lw lx ku ly lz ma mb bi translated">找到信号中的尖峰</h2><p id="abe3" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">即使数据中有 60 Hz 噪声，我们仍然可以处理它。幸运的是，动作电位是只持续 1 到 2 毫秒的快速事件。因此，我们可以在排除 60 Hz 噪声的范围内对原始宽带信号进行滤波。典型的滤波器设置为 500 至 9000 Hz，我们的 Python 实现如下所示:</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="0bc6" class="lj lk it mj b gy mn mo l mp mq">&gt;&gt;&gt; # Import libarys<br/>&gt;&gt;&gt; from scipy.signal import butter, lfilter</span><span id="db6f" class="lj lk it mj b gy mr mo l mp mq">&gt;&gt;&gt; def filter_data(data, low=500, high=9000, sf, order=2):<br/>&gt;&gt;&gt;     # Determine Nyquist frequency<br/>&gt;&gt;&gt;     nyq = sf/2</span><span id="55ed" class="lj lk it mj b gy mr mo l mp mq">&gt;&gt;&gt;     # Set bands<br/>&gt;&gt;&gt;     low = low/nyq<br/>&gt;&gt;&gt;     high = high/nyq</span><span id="585d" class="lj lk it mj b gy mr mo l mp mq">&gt;&gt;&gt;     # Calculate coefficients<br/>&gt;&gt;&gt;     b, a = butter(order, [low, high], btype='band')</span><span id="1670" class="lj lk it mj b gy mr mo l mp mq">&gt;&gt;&gt;     # Filter signal<br/>&gt;&gt;&gt;     filtered_data = lfilter(b, a, data)<br/>&gt;&gt;&gt;    <br/>&gt;&gt;&gt;     return filtered_data</span></pre><p id="54f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用上述函数处理数据将得到信号的高频带或尖峰通道。我们的期望是，该棘波通道包含动作电位，并且不再有 60 Hz 噪声。让我们看看滤波后的尖峰通道，并将其与原始宽带信号进行比较。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mu"><img src="../Images/a2fc57144ed7060a6f781f35bf7a440c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t9oi31p9U1c07yHXa0XPmg.png"/></div></div></figure><p id="0e4f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如所料，尖峰通道不再显示 60 赫兹的振荡。最重要的是，我们终于可以看到记录中的第一个尖峰。在记录开始大约 0.5 秒时，它在过滤数据中清晰可见。同样，既然我们现在看哪里，我们可以在未过滤的数据中看到它。然而，由于 60 赫兹的噪音，它更难被发现。</p><h2 id="3bf2" class="lj lk it bd ll lm ln dn lo lp lq dp lr km ls lt lu kq lv lw lx ku ly lz ma mb bi translated">从信号中提取尖峰信号</h2><p id="60f3" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">既然我们已经将高频尖峰信号带从噪声低频带中分离出来，我们就可以提取单个尖峰信号。为此，我们将编写一个简单的函数来执行以下操作:</p><ol class=""><li id="5313" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky na nb nc nd bi translated">找到信号中高于特定阈值的数据点</li><li id="ebd0" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">围绕这些事件定义一个窗口，并“将它们剔除”</li><li id="825b" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">将它们对准它们的峰值振幅</li></ol><p id="32e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，我们还将定义一个上限。高于该阈值的数据点将被拒绝，因为它们可能是高频伪影。这种伪影可能是由于患者的移动而产生的，或者可能反映了电气事件，如打开或关闭房间中的灯泡。可以详细看看<a class="ae li" href="https://github.com/akcarsten/akcarsten.github.io/blob/master/spike_sorting/Spike_sorting%20.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter 笔记本</a>里的尖刺提取功能。这里我们只看一下用我们的函数从信号中提取的 100 个随机尖峰。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/79a86191e7d8d98d072971fb7555f61e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*282BDfhvk5Cdb2M9Yzhnbw.png"/></div></div></figure><p id="b389" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上图中，我们可以看到数据中至少有两种类型的波形。一组尖峰具有尖锐的高振幅峰值，第二组具有较宽的初始峰值。所以这些尖峰信号很可能是由不止一个神经元产生的。因此，下一个任务是找到一种将波形分组到不同簇的方法。但是因为这不能用两三行来编码或解释，我们将在下一篇文章<a class="ae li" rel="noopener" target="_blank" href="/whos-talking-using-k-means-clustering-to-sort-neural-events-in-python-e7a8a76f316">中看到尖峰排序的主题。</a></p><p id="64a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同时，你可以在这里查看完整的代码<a class="ae li" href="https://github.com/akcarsten/spike_sorting" rel="noopener ugc nofollow" target="_blank">，在</a><a class="ae li" href="https://twitter.com/ak_carsten" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我或者通过<a class="ae li" href="https://www.linkedin.com/in/carsten-klein/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p><p id="0573" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个项目的代码可以在<a class="ae li" href="https://github.com/akcarsten/spike_sorting" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p><div class="nk nl gp gr nm nn"><a href="https://github.com/akcarsten/spike_sorting" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">akcarsten/spike _ 排序</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">在 GitHub 上创建一个帐户，为 akcarsten/spike_sorting 开发做贡献。</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">github.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob jz nn"/></div></div></a></div></div></div>    
</body>
</html>