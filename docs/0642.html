<html>
<head>
<title>Convolutional Attention Model for Natural Language Inference</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自然语言推理的卷积注意模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/convolutional-attention-model-for-natural-language-inference-a754834c0d83?source=collection_archive---------2-----------------------#2017-06-01">https://towardsdatascience.com/convolutional-attention-model-for-natural-language-inference-a754834c0d83?source=collection_archive---------2-----------------------#2017-06-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c04f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我想向你展示一个我在 Quora 问题配对竞赛中使用的模型。首先，我将描述一个用于自然语言推理的可分解注意力模型(<a class="ae kl" href="https://arxiv.org/pdf/1606.01933.pdf" rel="noopener ugc nofollow" target="_blank"> Parikh 等人，2016 </a>)，然后用卷积层扩展它，以提高损失和分类精度。出于本文的目的，我将使用斯坦福 NLI 语料库进行比较。</p><h1 id="35f1" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">介绍</h1><p id="a8d3" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">自然语言推理(NLI)和复述检测是自然语言处理的主要研究课题之一。自然语言推理指的是确定两个语句之间的蕴涵和矛盾的问题，而复述检测的重点是确定句子的重复。发表在这方面的论文使用递归神经网络<a class="ae kl" href="https://arxiv.org/pdf/1611.01747.pdf" rel="noopener ugc nofollow" target="_blank">王&amp;江，2016 </a>，<a class="ae kl" href="https://arxiv.org/pdf/1702.03814.pdf" rel="noopener ugc nofollow" target="_blank">王等，2017 </a>，卷积神经网络<a class="ae kl" href="https://arxiv.org/abs/1512.08422" rel="noopener ugc nofollow" target="_blank">牟等，2016 </a>或带软对齐和注意的前馈神经网络<a class="ae kl" href="https://arxiv.org/pdf/1606.01933v1.pdf" rel="noopener ugc nofollow" target="_blank">帕里克等，2016 </a>。</p><h1 id="8d26" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">模型架构</h1><p id="fd77" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">模型的输入是表示为单词嵌入向量序列的两个短语<code class="fe lp lq lr ls b">a = {a1,...,am}</code>和<code class="fe lp lq lr ls b">b = {b1,...,bn}</code>。目标是估计这两个短语相互蕴涵或矛盾的概率。在模型训练过程中，我们还将使用一个变量<code class="fe lp lq lr ls b">y</code>，它是一个基础事实和辅助输入<code class="fe lp lq lr ls b">a_len</code>和<code class="fe lp lq lr ls b">b_len</code>来帮助我们构建掩蔽矩阵。下图描绘了由三层组成的核心模型架构:关注、比较和聚集。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/e08137c5d9d9e7eafed845e8ed67f1ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZByTGTbUbqmwyr8M1cAVjg.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">A high-level overview of the model architecture. (Image credit: Parikh et al., 2017)</figcaption></figure><h2 id="4994" class="mj kn iq bd ko mk ml dn ks mm mn dp kw jy mo mp la kc mq mr le kg ms mt li mu bi translated">注意力</h2><p id="3778" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">注意力层使用的是<a class="ae kl" href="https://arxiv.org/pdf/1409.0473.pdf" rel="noopener ugc nofollow" target="_blank"> Bahdanau et al .，2016 </a>提出的一种神经注意力的变体。它是使用分别应用于这两个问题的前馈神经网络<code class="fe lp lq lr ls b">F</code>实现的(Bahdanau 的工作使用递归神经网络的内部状态)。然后，使用 softmax 函数对神经网络的输出进行归一化，并将其与第二个句子软对齐。该图层的方程式如下所示:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/bec8206d1d499877ce5c2014ded15a9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*rM0ZoGYjNT5-p23-q_T2Kg.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">where m = number of words in a, n = number of words in b</figcaption></figure><p id="0a93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于训练，我使用预先训练的 300 维手套单词嵌入。<code class="fe lp lq lr ls b">F(a)</code>的输出大小是<code class="fe lp lq lr ls b">mx200</code>，而<code class="fe lp lq lr ls b">F(b)</code>的输出大小是<code class="fe lp lq lr ls b">nx200</code>，这意味着注意力权重矩阵<code class="fe lp lq lr ls b">e</code>将具有形状<code class="fe lp lq lr ls b">mxn</code>。<code class="fe lp lq lr ls b">beta</code>和<code class="fe lp lq lr ls b">alpha</code>则是 softmax 标准化注意力权重和相应句子矩阵之间的点积。</p><h2 id="5b55" class="mj kn iq bd ko mk ml dn ks mm mn dp kw jy mo mp la kc mq mr le kg ms mt li mu bi translated">比较</h2><p id="64d1" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">下一步是比较软对齐的句子矩阵。类似于前一步骤，使用前馈神经网络<code class="fe lp lq lr ls b">G</code>，并且网络的输入分别是连接的句子矩阵<code class="fe lp lq lr ls b">[a, beta]</code>和<code class="fe lp lq lr ls b">[b, alpha]</code>。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/7469210d299e762d2a0f2bc512e06490.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*v6OK4HGTsKAhTUuCmrLn5A.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">Soft-aligned matrix comparison</figcaption></figure><h2 id="1eae" class="mj kn iq bd ko mk ml dn ks mm mn dp kw jy mo mp la kc mq mr le kg ms mt li mu bi translated">聚合</h2><p id="4d7f" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">核心模型架构的最后一部分是聚合层。这一层所做的只是对比较网络的输出进行列式求和，这样我们就可以获得每个句子的固定大小的表示。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/1ae9d209fb91735db84b66e351b99a7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:350/format:webp/1*zcLzbe47LBqkq7XrXenRmg.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">Comparison matrix aggregation</figcaption></figure><p id="bef5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，聚合的句子表示被连接起来并输入到一个密集的分类网络中。分类器的输出层是 softmax 标准化的，以便我们获得目标类的概率分布。</p><h1 id="f643" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">卷积层</h1><p id="a41c" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">NLI 的可分解注意力模型的扩展是基于这样一个事实，即同一个单词在给定的上下文中可以有不同的含义。类似于我们人类在上下文中理解单词的方式，机器学习模型可以通过使用递归神经网络(计算成本更高)或卷积层(成本更低但效率也更低)来学习这些更高级的单词表示。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi my"><img src="../Images/401675fc4ba1ff5695580fac0b71fcb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bJfETESx8qYZKxYSpM8fwQ.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">Two convolutional layers with filter size 3 and stride 1</figcaption></figure><p id="af6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上图显示了如何使用卷积层构建更高级别的表示。例句“<em class="mz">我们在动物园里看到了一只漂亮的鹤”</em>包含单词<strong class="jp ir"> crane </strong> which <strong class="jp ir"> </strong>可以是一只鸟，但根据句子的上下文，它也可以是一个结构装置。</p><h1 id="ead4" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">模特培训</h1><p id="c907" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">首先使用<code class="fe lp lq lr ls b">nltk.word_tokenize</code>函数对句子进行标记化，然后执行嵌入索引查找。如果在字典中找不到某个标记，则将其忽略，不进行插补。然后用零向量填充嵌入索引，直到给定批次中最长句子的长度。卷积层然后在第一个令牌之前和最后一个令牌之后附加零向量，以便在应用卷积之后，有效句子长度保持不变。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi na"><img src="../Images/3eb4c09652c25627cb427f30abc485b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_fUDENwZnkW1aI4tvSJRlg.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">High level overview of a Tensorflow model graph</figcaption></figure><p id="d6e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意力权重矩阵<code class="fe lp lq lr ls b">e</code>将所有填充值替换为<code class="fe lp lq lr ls b">-np.inf</code>，以便在应用 softmax 归一化后，我们获得句子有效部分的概率分布，并且所有填充值为<code class="fe lp lq lr ls b">0</code>。最后，如本文的<strong class="jp ir">模型架构</strong>部分所述，应用比较、聚集和分类层，并使用交叉熵损失来训练模型。</p><h1 id="5813" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结果</h1><p id="bf9a" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">首先，我在 Tensorflow 中实现了 NLI 最初的可分解注意力模型，以获得基线分数。虽然原始论文报告了 86.3%的测试准确性，但我无法将它提高到 83.8%以上(这可能是因为我使用了 AdaM optimizer 而不是 Adagrad，并且只训练了 100 个时期)。加入卷积层后，模型达到了分类精度<em class="mz"> 84.5% </em>。我还将 optimizer 改为 Adagrad，因为它与卷积架构配合得更好。</p><p id="0460" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mz">在撰写本文时，目前最先进的自然语言推理模型是双边多视角匹配模型(</em> <a class="ae kl" href="https://arxiv.org/pdf/1702.03814.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="mz">王等，2017 </em> </a> <em class="mz">)，达到分类准确率 88.8%。我在这篇文章中选择 NLI 的可分解注意力模型的原因是，该模型的架构更简单，因此运行训练/推理花费的时间更少，我可以更多地进行实验。</em></p><h1 id="f0ae" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结论</h1><p id="2e2a" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">正如我们所看到的，卷积层在分类精度上给了我们一点点改进。这种扩展可以对包含更多具有上下文条件意义的单词的数据集提供更大的改进，也可以对没有这种单词的数据集提供很少或没有改进。对于具有多个超参数组合的更多训练时期，训练模型也可以获得更好的分数。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="1e84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完整的 Tensorflow 模型代码可以在<a class="ae kl" href="https://gist.github.com/marekgalovic/a1a4073b917ae1b18dc7413436794dca" rel="noopener ugc nofollow" target="_blank">这里</a>找到。如果你喜欢这篇文章，请随意推荐给其他人。此外，如果你对我做错了什么或者本可以做得不一样有任何建议，请在下面的评论区留下它们。</p></div></div>    
</body>
</html>