<html>
<head>
<title>Understanding GRU Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解 GRU 网络</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-gru-networks-2ef37df6c9be?source=collection_archive---------0-----------------------#2017-12-16">https://towardsdatascience.com/understanding-gru-networks-2ef37df6c9be?source=collection_archive---------0-----------------------#2017-12-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/8696cdc165c9e9aeeaa44a500cc2acf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iUkc2IfBOMxL5Dj3KrajRw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk"><a class="ae jd" href="https://pixabay.com" rel="noopener ugc nofollow" target="_blank">https://pixabay.com</a></figcaption></figure><div class=""/><p id="d8ba" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我将尝试对一种真正令人着迷的神经网络类型给出一个相当简单易懂的解释。由<a class="ae jd" href="https://arxiv.org/pdf/1406.1078v3.pdf" rel="noopener ugc nofollow" target="_blank"> Cho 等人</a>在 2014 年提出的 GRU(门控递归单元)旨在解决标准递归神经网络中的<strong class="kf jh">消失梯度问题</strong>。GRU 也可以被认为是 LSTM 的变体，因为两者设计相似，在某些情况下，产生同样优秀的结果。如果你不熟悉递归神经网络，我推荐阅读<a class="ae jd" href="https://medium.com/@simeon.kostadinoff/learn-how-recurrent-neural-networks-work-84e975feaaf7" rel="noopener">我的简介</a>。为了更好地了解 LSTM，许多人推荐克里斯托弗·奥拉的文章。我还想补充一下这篇论文，它清楚地区分了 GRU 和 LSTM。</p><h2 id="fbcd" class="lb lc jg bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">GRUs 是如何工作的？</h2><p id="2837" class="pw-post-body-paragraph kd ke jg kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">如上所述，GRUs 是标准递归神经网络的改进版本。但是是什么让它们如此特别和有效呢？</p><p id="0eb7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决标准 RNN 的消失梯度问题，GRU 使用所谓的<strong class="kf jh">更新门和</strong>复位门。基本上，这是决定什么信息应该被传递到输出的两个向量。它们的特别之处在于，它们可以被训练来保留很久以前的信息，而不会随着时间的推移而消失，也不会删除与预测无关的信息。</p><p id="f1bb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解释这一过程背后的数学原理，我们将考察以下递归神经网络中的一个单元:</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lz"><img src="../Images/e7fe65bed1e3dfd437a96b61b4dac2d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7oE-4Wg6bZ7u8yDf5cjJPA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Recurrent neural network with Gated Recurrent Unit</figcaption></figure><p id="4ec3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是那首单曲《GRU》的更详细版本:</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi me"><img src="../Images/ad0e2f37ff0842d3b469d0d181df401f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6eNTqLzQ08AABo-STFNiBw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Gated Recurrent Unit</figcaption></figure><p id="90a5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们介绍一下符号:</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mf"><img src="../Images/de133e8ed51e5e264a336508619a25a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qx5uUSVgL_QCvsJ_yM2pMA.png"/></div></div></figure><p id="8b72" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你不熟悉以上术语，我推荐你看这些关于<a class="ae jd" href="https://www.youtube.com/watch?v=9vB5nzrL4hY" rel="noopener ugc nofollow" target="_blank">“sigmoid”和“tanh”功能</a>和<a class="ae jd" href="https://www.youtube.com/watch?v=2GPZlRVhQWY" rel="noopener ugc nofollow" target="_blank">“hada mard product”操作</a>的教程。</p><h2 id="53a0" class="lb lc jg bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">#1.更新门</h2><p id="3f24" class="pw-post-body-paragraph kd ke jg kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们从使用以下公式计算时间步长 t 的<strong class="kf jh">更新门 z_t 开始:</strong></p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mg"><img src="../Images/042f3062928e7949d880970bb2af5be3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o7NzuF8w0H7qybG8Fn-Shw.png"/></div></div></figure><p id="afe5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<em class="mh"> x_t </em>插入网元时，乘以自身重量<em class="mh"> W(z) </em>。对于<em class="mh"> h_(t-1) </em>来说也是如此，它保存先前<em class="mh"> t-1 </em>单元的信息，并乘以其自身的权重<em class="mh"> U(z)。</em>将两个结果相加，并应用 sigmoid 激活函数将结果压缩在 0 和 1 之间。按照上面的模式，我们有:</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi me"><img src="../Images/d73a04ed0df29bb7c7026ab36defab9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gSlR_JLNeuZBSCAKyjmAdA.png"/></div></div></figure><p id="67d9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">更新门帮助模型确定有多少过去的信息(来自以前的时间步骤)需要传递给未来。</strong>这非常强大，因为模型可以决定复制过去的所有信息，并消除消失梯度问题的风险。稍后我们将看到更新门的用法。现在记住<em class="mh"> z_t </em>的公式。</p><h2 id="f9bf" class="lb lc jg bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">#2.复位门</h2><p id="aa34" class="pw-post-body-paragraph kd ke jg kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">本质上，<strong class="kf jh">这个门是用来从模型中决定有多少过去的信息要忘记</strong>。为了计算它，我们使用:</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mi"><img src="../Images/3ed064f44ab0e4e2851ee729c5e4a374.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j1j1mLIyTm97hCay4GRC_Q.png"/></div></div></figure><p id="4110" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该公式与更新门的公式相同。区别在于重量和门的用途，稍后会看到。下图显示了重置门的位置:</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi me"><img src="../Images/8b2905ea09ced6ff4363c368a20b2c4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5M6LYj544UKKHkFkDmDQ8A.png"/></div></div></figure><p id="a504" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像以前一样，我们插入<em class="mh"> h_(t-1) —蓝线</em>和<em class="mh"> x_t —紫线</em>，将它们与相应的权重相乘，将结果求和并应用 sigmoid 函数。</p><h2 id="80db" class="lb lc jg bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">#3.当前存储内容</h2><p id="e452" class="pw-post-body-paragraph kd ke jg kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">让我们看看这些门究竟会如何影响最终输出。首先，我们从复位门的使用开始。我们引入了一种新的存储内容，它将使用复位门来存储过去的相关信息。其计算方法如下:</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mj"><img src="../Images/98aed9696e366c11791953f12207c823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CxQBMqy8dvgJNjeJcur6pQ.png"/></div></div></figure><ol class=""><li id="c304" class="mk ml jg kf b kg kh kk kl ko mm ks mn kw mo la mp mq mr ms bi translated">将输入<em class="mh"> x_t </em>乘以权重<em class="mh"> W </em>并将<em class="mh"> h_(t-1) </em>乘以权重<em class="mh"> U. </em></li><li id="a14e" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">计算复位门<em class="mh"> r_t </em>和<em class="mh"> Uh_(t-1)之间的 Hadamard(逐元素)乘积。</em>这将决定从先前的时间步骤中删除什么。假设我们有一个情感分析问题，要从一个人写的评论中判断他对一本书的看法。正文以“这是一本奇幻的书，它阐释了……”开始，几段后以“我不太喜欢这本书，因为我认为它捕捉了太多的细节”结束。要确定这本书的总体满意度，我们只需要最后一部分的评论。在这种情况下，随着神经网络接近文本的结尾，它将学习将<em class="mh"> r_t </em>向量赋值为接近 0，洗去过去，只关注最后的句子。</li><li id="6b4a" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">总结第一步和第二步的结果。</li><li id="ab96" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">应用非线性激活功能<em class="mh"> tanh </em>。</li></ol><p id="11e8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以清楚地看到这里的步骤:</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi me"><img src="../Images/aea9b5cce91ace78436f169c515e79e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AZObvZ2GXSDYkJ2iv28MaQ.png"/></div></div></figure><p id="40d1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们对<em class="mh"> h_(t-1) —蓝线</em>和<em class="mh"> r_t —橙线</em>进行逐元素乘法，然后将<em class="mh">结果—粉线</em>与输入<em class="mh"> x_t —紫线</em>相加。最后用<em class="mh"> tanh </em>产生<em class="mh">h’_ t—亮绿线</em>。</p><h2 id="52b9" class="lb lc jg bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">#4.当前时间步的最终记忆</h2><p id="3ed4" class="pw-post-body-paragraph kd ke jg kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">作为最后一步，网络需要计算<em class="mh"> h_t </em> —保存当前单元信息的向量，并将其传递给网络。为此，需要更新门。它决定了从当前内存内容中收集什么— <em class="mh"> h'_t </em>，从前面的步骤中收集什么— <em class="mh"> h_(t-1) </em>。这是按如下方式完成的:</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi my"><img src="../Images/752fe39305f7f517f6a4e33a0f64f38f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zxSTnqedwLRoicgHKYKsVQ.png"/></div></div></figure><ol class=""><li id="5189" class="mk ml jg kf b kg kh kk kl ko mm ks mn kw mo la mp mq mr ms bi translated">对更新门<em class="mh"> z_t </em>和<em class="mh"> h_(t-1)应用逐元素乘法。</em></li><li id="61ea" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">对<em class="mh"> (1-z_t) </em>和<em class="mh"> h'_t. </em>应用逐元素乘法</li><li id="9cf9" class="mk ml jg kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">将步骤 1 和步骤 2 的结果相加。</li></ol><p id="53bc" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们举一个关于书评的例子。这一次，最相关的信息被定位在正文的开头。该模型可以学习将向量<em class="mh"> z_t </em>设置为接近 1，并保留大部分先前信息。由于<em class="mh"> z_t </em>在这个时间步将接近于 1，<em class="mh"> 1-z_t </em>将接近于 0，这将忽略当前内容的大部分(在这种情况下是解释书籍情节的评论的最后部分),这与我们的预测无关。</p><p id="5a25" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个强调上述等式的例子:</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi me"><img src="../Images/521c89aeeeb277d83d2dc6f5f133200d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UxZ0pTQW8kofL9bzPVYV1w.png"/></div></div></figure><p id="6be7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，您可以看到如何使用<em class="mh"> z_t —绿线</em>来计算<em class="mh"> 1-z_t </em>，它与<em class="mh">h’_ t—亮绿线</em>一起产生结果<em class="mh">暗红线</em>。<em class="mh"> z_t </em>也与<em class="mh"> h_(t-1) —蓝线</em>一起用于逐元素乘法。最后，<em class="mh"> h_t —蓝线</em>是对应于<em class="mh">亮红线和暗红线</em>的输出相加的结果。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="15a6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您可以看到 gru 如何使用它们的更新和重置门来存储和过滤信息。这消除了消失梯度问题，因为模型不是每次都洗去新的输入，而是保留相关信息，并将其传递给网络的下一个时间步骤。如果仔细训练，他们甚至可以在复杂的情况下表现得非常好。</p><p id="8641" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望这篇文章能让你更好地理解这个被称为 GRU 的最先进的深度学习模型。</p><blockquote class="ng"><p id="21dd" class="nh ni jg bd nj nk nl nm nn no np la dk translated">更多 AI 内容，<a class="ae jd" href="https://www.linkedin.com/in/simeonkostadinov/" rel="noopener ugc nofollow" target="_blank">关注我 LinkedIn </a>。</p></blockquote><h2 id="b9da" class="lb lc jg bd ld le nq dn lg lh nr dp lj ko ns ll lm ks nt lo lp kw nu lr ls lt bi translated">感谢您的阅读。如果你喜欢这篇文章，给它一些掌声👏。希望你有一个伟大的一天！</h2></div></div>    
</body>
</html>