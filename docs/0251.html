<html>
<head>
<title>Record linking with Apache Spark’s MLlib &amp; GraphX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与Apache Spark的MLlib &amp; GraphX的记录链接</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/record-linking-with-apache-sparks-mllib-graphx-d118c5f31f83?source=collection_archive---------1-----------------------#2017-04-05">https://towardsdatascience.com/record-linking-with-apache-sparks-mllib-graphx-d118c5f31f83?source=collection_archive---------1-----------------------#2017-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="75e6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一种可扩展的模糊数据匹配方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7e457f00af3e8502377ed5b6f13c6647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lLzCPJcSNMCTTeoPX4-yVA.png"/></div></div></figure><h2 id="7ab2" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">挑战</h2><p id="47c3" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">最近，Datlinq 的一位同事让我帮她解决一个数据问题，这个问题看起来非常简单。<br/>她从商会(Kamer van Koophandel: KvK)购买了一小组数据，其中包含大约5万家小公司(5-20名全职员工)，在网上很难找到。<br/>她注意到许多公司共用同一个地址，这是有道理的，因为许多公司倾向于聚集在商业区。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/c29da9dc9e80131ea598324da93189ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nMPpX9uZGN1gUvhlHkQLyg.png"/></div></div></figure><p id="8d89" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">然而，她还发现，同一地址上的许多公司实际上是一个公司，分多次注册。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/120910a56fb8c8929b5ce55f78c9a65e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SON3yUxr7xQFl2rPubu6Nw.png"/></div></div></figure><p id="b54a" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">这两家公司在技术上是不同的，但在这种特殊情况下，应被视为一家拥有联合劳动力的公司。</p><blockquote class="mr ms mt"><p id="1de4" class="lq lr mu ls b lt ml ju lv lw mm jx ly mv mn ma mb mw mo md me mx mp mg mh mi im bi translated">因此，我们只需将“属于”的公司组合在一起，并将在那里工作的FTE汇总为一个实体。</p></blockquote><h2 id="2eb6" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">方法</h2><p id="b56e" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">当然，我一开始做了一些if-then-else编码，但是a .那很快就变得一团糟，b .那有什么乐趣呢？</p><p id="5bab" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">因此，我定义了实现动态、可扩展和可配置解决方案的步骤:</p><ul class=""><li id="1c14" class="my mz it ls b lt ml lw mm ld na lh nb ll nc mi nd ne nf ng bi translated">加载/清除数据</li><li id="8cf3" class="my mz it ls b lt nh lw ni ld nj lh nk ll nl mi nd ne nf ng bi translated">创建距离度量</li><li id="3ece" class="my mz it ls b lt nh lw ni ld nj lh nk ll nl mi nd ne nf ng bi translated">组合所有数据</li><li id="74f8" class="my mz it ls b lt nh lw ni ld nj lh nk ll nl mi nd ne nf ng bi translated">手动训练匹配组合</li><li id="96a5" class="my mz it ls b lt nh lw ni ld nj lh nk ll nl mi nd ne nf ng bi translated">训练模型</li><li id="ecac" class="my mz it ls b lt nh lw ni ld nj lh nk ll nl mi nd ne nf ng bi translated">在模型中运行所有组合</li><li id="e95a" class="my mz it ls b lt nh lw ni ld nj lh nk ll nl mi nd ne nf ng bi translated">制作所有链接记录的图表</li><li id="db1a" class="my mz it ls b lt nh lw ni ld nj lh nk ll nl mi nd ne nf ng bi translated">提取所有连接的顶点，并将它们保存为唯一的组</li><li id="e296" class="my mz it ls b lt nh lw ni ld nj lh nk ll nl mi nd ne nf ng bi translated">将这些组合并到一个数据源中，该数据源包含1个id、汇总的FTE和分组id列表</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/28d51883c7f2f4642a6cb7472e09d790.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*fGNxnc0E3HUmyorPspx8oA.png"/></div></figure><p id="4912" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">这些步骤中的任何一个都可以通过大量的工具、库和语言来完成，但是有一个似乎(几乎)适合它们中的每一个:<br/> <a class="ae mj" href="http://spark.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Spark </a></p><p id="6e39" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">好吧，我可能有点偏见，我认为Python和SciKit learn也足够了，除了Spark似乎有点过头，但我喜欢Scala和Spark…</p><p id="5b3d" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">所以我点燃了美好的火花</p><h2 id="9f5d" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">1.加载/清除数据</h2><p id="a63b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">数据以Excel格式提供，所以简单的“另存为”csv开始了这一步</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="5fe2" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">此外，这一步相当直接；数据非常干净。我只是选择了模型可能感兴趣的字段/特征。<br/> <em class="mu">稍后我将介绍KvKRecord案例类</em></p><h2 id="378a" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">2.创建距离度量</h2><p id="cef4" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">要查看来自同一数据源的两个记录是否“匹配”，理论上你必须比较每一个组合。</p><blockquote class="mr ms mt"><p id="4a3c" class="lq lr mu ls b lt ml ju lv lw mm jx ly mv mn ma mb mw mo md me mx mp mg mh mi im bi translated">这种比较本身就是这种努力的全部挑战，这就是机器学习介入的地方。</p></blockquote><p id="d125" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">但是ML模型仍然需要一个“特征向量”来训练、测试和预测，所以我需要创建一个方法来比较两个<em class="mu"> KvKRecords </em>并返回这个“特征向量”</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="42fe" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">我选择创建一个<em class="mu">向量</em>，其中每个元素对应于case类的每个属性之间的距离度量。</p><p id="2940" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">我使用<em class="mu"> Math.log10 </em>和一个除法来归一化整数之间的距离，以获得0和1之间的所有数字(我事先知道范围)。这不是最好的方法，但我强烈怀疑这些都无关紧要，所以我几乎没有花时间调优非字符串特性。</p><p id="28ef" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">对于字符串比较，有<a class="ae mj" href="http://www.joyofdata.de/blog/comparison-of-string-distance-algorithms/" rel="noopener ugc nofollow" target="_blank">很多很多选项</a> <br/>，但我最终使用了<a class="ae mj" href="https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance" rel="noopener ugc nofollow" target="_blank"> Jaro-Winkler </a>。我想试试其他的，但这似乎工作得很好，并返回一个介于0和1之间的正常值。</p><h2 id="4942" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">3.组合所有数据</h2><p id="ae6a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">我在这里有一些优势，因为地址数据非常干净，所以我不必创建笛卡尔乘积，而只需在地址上连接。使用<em class="mu"> joinWith </em>方法，<em class="mu"> KvKRecords </em>保持完整，特征向量被附加上。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><blockquote class="mr ms mt"><p id="c794" class="lq lr mu ls b lt ml ju lv lw mm jx ly mv mn ma mb mw mo md me mx mp mg mh mi im bi translated">现在，我们有了一个经过筛选的数据集，包含了同一地址的所有公司组合。</p></blockquote><p id="868a" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">我不得不指出，这多少是一种欺骗。有些公司地址相同，但地址符号不同，尽管提供的数据非常清晰。</p><p id="e13f" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">例如，"<em class="mu"> Keizersgracht 62" </em>和"<em class="mu">Keizersgracht 62–64 "</em>和"<em class="mu"> Keizersgracht 62-A" </em>可能被认为是相同的地址，但排除了这种方式。然而，我们也可以假设，谁注册这些公司，使用相同的地址，如果它是同一家公司？我不知道，但在快速手动检查后，这种影响似乎可以忽略不计/不存在。</p><p id="5dd7" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">一种替代方法是做一个完整的笛卡尔乘积(将每个公司与其他公司匹配)，并在不同街道/城市的公司上训练该工具。我担心，不匹配的公司之间的纯粹差异会使模型远离实际上位于同一地址的公司之间的细微差别。</p><h2 id="138b" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">4.手动训练匹配组合</h2><p id="7d2f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">如果你没有东西来训练你的ML，所有这些组合和向量不会让你去任何地方。我需要一个带标签的数据集用于监督学习。</p><p id="17a2" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">用Excel基于原始csv手动创建这些，看起来容易出错而且很麻烦，所以作为一个优秀的(懒惰的)开发人员，我编写了一个程序来帮助我创建一个带标签的训练集。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/76232046909b0fd9ad5e4be42eb421b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*YWhz58v87A6gGF4W0SHYzw.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">console output</figcaption></figure><p id="a52e" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">我必须承认，我只为这个项目创建了大约100个带标签的样本(使用&lt; 0.2%), but the features are pretty simple and the work was extremely boring, so I was ok with it.</p><p id="434f" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">The <em class="mu"> LabeledVector </em> case类，因为它具有名为“<em class="mu"> features </em>”和“<em class="mu"> label </em>”的属性，这是Spark MLlib模型的默认属性。</p><h2 id="46f6" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">5.训练模型</h2><blockquote class="mr ms mt"><p id="35f3" class="lq lr mu ls b lt ml ju lv lw mm jx ly mv mn ma mb mw mo md me mx mp mg mh mi im bi translated">现在我们有了这个漂亮的标记数据集，我们准备好展示我们的机器学习肌肉了。</p></blockquote><p id="61de" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">不过，我不得不让你有点失望，因为我刚刚使用<a class="ae mj" href="http://spark.apache.org/docs/latest/ml-guide.html" rel="noopener ugc nofollow" target="_blank"> Spark的MLLib </a>创建了一个直接的逻辑回归模型，但结果才是最重要的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d488" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">其他项目使用随机森林、感知器甚至朴素贝叶斯可能会更好，但我基于这种方法得到了一些好结果:</p><ul class=""><li id="6382" class="my mz it ls b lt ml lw mm ld na lh nb ll nc mi nd ne nf ng bi translated">精确度:0.96</li><li id="b9ba" class="my mz it ls b lt nh lw ni ld nj lh nk ll nl mi nd ne nf ng bi translated">ROC曲线下面积:0.92</li></ul><p id="9aee" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated"><em class="mu">(如果有人知道如何从Spark轻松地</em><strong class="ls iu"><em class="mu"/></strong><em class="mu">创建ROC/AUC-plot，请告诉我)</em></p><p id="e733" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">更多的时间可以花在超参数调整上，但是拥有超过80个训练样本也会有所帮助；-)</p><h2 id="71b7" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">6.在模型中运行所有组合</h2><p id="e8bd" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">下一步是将这个模型应用到我们的组合数据集</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="84b5" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">因为我们的<em class="mu"> comparableDataset </em>已经有了所需的'<em class="mu"> features </em> : Vector '，我可以应用这个模型，它添加了<em class="mu">标签</em>和<em class="mu">概率</em>列。</p><blockquote class="mr ms mt"><p id="ca3c" class="lq lr mu ls b lt ml ju lv lw mm jx ly mv mn ma mb mw mo md me mx mp mg mh mi im bi translated">对于链接，我们现在只对实际的匹配感兴趣，所以得到的数据集只有被认为相同的公司的组合。</p></blockquote><p id="6c5a" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated"><em class="mu"> PredictedVector </em>又是一个简单明了的case类。</p><h2 id="a7c0" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">7.制作所有链接记录的图表</h2><p id="b93f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">拥有一个包含所有关联公司的数据集固然很好，但要真正理解这些数据，我必须按“独立组”进行分组。含义:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/6d5324c96b0cfb8c86d373897300244d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*hu-If17tQoElHIhAY9jDSw.png"/></div></figure><p id="6079" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">(A，B) <br/> (A，C) <br/> (B，C) <br/> (D，E) <br/> (F，G) <br/> (G，H)</p><p id="e4eb" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">需要产生以下结果:</p><p id="feab" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">(A，B，C) <br/> (D，E) <br/> (F，G，H)</p><p id="9a24" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">任何熟悉离散数学/图论的人都会注意到这些可以用图形来表示。</p><blockquote class="mr ms mt"><p id="b689" class="lq lr mu ls b lt ml ju lv lw mm jx ly mv mn ma mb mw mo md me mx mp mg mh mi im bi translated">有很多很酷的工具可以用来处理图形，我最喜欢的一个是<a class="ae mj" href="https://neo4j.com/" rel="noopener ugc nofollow" target="_blank"> Neo4j </a>，但是Spark还是提供了开箱即用的<a class="ae mj" href="http://spark.apache.org/docs/latest/graphx-programming-guide.html" rel="noopener ugc nofollow" target="_blank"> GraphX </a>，所以我们现在还是坚持使用它。</p></blockquote><p id="dfba" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">我只需要把我们的数据集变成两个RDD，即:边和顶点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="0a9b" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">8.提取所有连接的顶点，并将它们保存为唯一的组</h2><p id="8e24" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">现在有了一个图(<em class="mu"> linkedGraph </em>)，我想找到所有不相连的子图并把它们组合在一起。</p><blockquote class="mr ms mt"><p id="3f3d" class="lq lr mu ls b lt ml ju lv lw mm jx ly mv mn ma mb mw mo md me mx mp mg mh mi im bi translated">这里神奇的关键词是:<a class="ae mj" href="https://en.wikipedia.org/wiki/Connected_component_(graph_theory)" rel="noopener ugc nofollow" target="_blank">连通分量</a></p></blockquote><p id="45f8" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">GraphX方法<em class="mu"> connectedComponents </em>创建了每个<em class="mu"> VertexId </em>和其子图中最小的<em class="mu"> VertexId </em>的元组列表。</p><p id="d051" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">反转这些元组并在最小的<em class="mu"> VertexId </em>上分组，创建了一个连接的<em class="mu"> VertexId的</em> c.q .子图列表</p><p id="d6d1" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">使用广播查找，我将这些VertexId重新映射到相应的<em class="mu"> KvKRecord </em>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="12d2" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">最后，我得到了一个包含所有唯一组的数据集，以及该组中所有<em class="mu"> KvKRecords </em>的列表。</p><h2 id="841d" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">9.在单个数据源中组合组</h2><p id="3c85" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">最后一步是为我的同事创建一个csv文件，用于她的特定用例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="0862" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">整个代码虽然对这个过程不感兴趣，但它的目的是将这些结果整理成一个csv文件，该文件可以由MS Excel以</p><p id="743d" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated"><em class="mu">【关联公司数量】</em>；<em class="mu">【总FTE】</em>；<em class="mu">【公司id /栏目】</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/c0553830f7e1f4d1ec9f769d21bb768d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qekxb_Pn2y9oMxFi1AvFyw.png"/></div></div></figure><h1 id="90b5" class="nw kv it bd kw nx ny nz kz oa ob oc lc jz od ka lg kc oe kd lk kf of kg lo og bi translated">结论</h1><p id="e5ad" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">最终，这个看似简单的数据问题有了一个相当复杂的解决方案，并且花费了我比预期更多的时间。</p><p id="ca8d" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">但是我并没有对结果失望，也没有选择在Scala &amp; Spark中构建它。我学到了很多东西，并相信随着时间的推移，它将改进这个项目和其他项目。事实上，我可以在我的机器上运行这段代码，也可以在云中运行100个节点的集群，而不需要修改任何代码，这仍然让我感到惊讶。</p><p id="15c4" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly ld mn ma mb lh mo md me ll mp mg mh mi im bi translated">我分享这个的原因是:</p><ul class=""><li id="bd69" class="my mz it ls b lt ml lw mm ld na lh nb ll nc mi nd ne nf ng bi translated">通知你星火的威力:<em class="mu">不吓人，好玩！</em></li><li id="d24a" class="my mz it ls b lt nh lw ni ld nj lh nk ll nl mi nd ne nf ng bi translated">去炒作机器学习:<em class="mu">很酷，但还是软件开发带试用&amp;错误。</em></li><li id="bb07" class="my mz it ls b lt nh lw ni ld nj lh nk ll nl mi nd ne nf ng bi translated">淡化大数据:<em class="mu">重要的不总是规模。数据还是数据。</em></li><li id="7833" class="my mz it ls b lt nh lw ni ld nj lh nk ll nl mi nd ne nf ng bi translated">帮助/激励有类似问题的人:<em class="mu">分享是关爱；-) </em></li><li id="265e" class="my mz it ls b lt nh lw ni ld nj lh nk ll nl mi nd ne nf ng bi translated">请对本文、我的方法、代码或任何东西进行反馈:<em class="mu">！</em></li></ul></div></div>    
</body>
</html>