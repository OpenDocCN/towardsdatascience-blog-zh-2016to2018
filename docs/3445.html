<html>
<head>
<title>Unit Testing and Logging for Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学的单元测试和日志记录</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/unit-testing-and-logging-for-data-science-d7fb8fd5d217?source=collection_archive---------3-----------------------#2018-05-12">https://towardsdatascience.com/unit-testing-and-logging-for-data-science-d7fb8fd5d217?source=collection_archive---------3-----------------------#2018-05-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3a5424d523aff1076584ac5e87024191.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ABT84nBYSvIMjpCGMeITxQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Laufen Castle &amp; Rhein Falls, Schaffhausen, Switzerland.</figcaption></figure><p id="fabf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在我们的行业中，数据科学家的职责包括各种任务。通常，它从数据库查询开始，以完成的模型结束，事实上，这是许多公司的规范，它允许数据科学家专注于只存在于他们专业领域的任务；这是可以理解的，因为研究比其他任务更昂贵。然而，在许多资源匮乏的公司，数据科学家工作的端到端定义包括创建简单的 API、单元测试和日志记录。</p><p id="96f1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在本教程中，我将创建输入输出单元测试、一个日志记录类和一个 API 合适的部署。为此，我们将创建一个使用 MNIST 数据集的监督分类器。请注意，单元测试和记录器的 python 代码是由科里·斯查费<a class="ae ld" href="https://github.com/CoreyMSchafer/code_snippets/tree/master/Python-Unit-Testing" rel="noopener ugc nofollow" target="_blank">在这里</a>和<a class="ae ld" href="https://github.com/CoreyMSchafer/code_snippets/tree/master/Decorators" rel="noopener ugc nofollow" target="_blank">在这里</a>提供的。</p><p id="a701" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们的 logger 是一个 decorator，它是一个具有日志功能的函数，使用“@my_function”语法包装其他函数。这个想法是使用一个通用的包装器，在我们的例子中:</p><ol class=""><li id="b2fd" class="le lf it kh b ki kj km kn kq lg ku lh ky li lc lj lk ll lm bi translated">每次执行函数时，为每个函数创建一个文件日志，其中每行包含函数的参数。</li><li id="f717" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated">报告运行该函数所花费的时间。</li></ol><p id="73ae" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将“@ my _ logger”&amp;“@ my _ timer”添加到我们想要记录的每个函数中，并知道它们的运行时间。请记住，您可以脱机查看这些日志文件，如果出现错误，您可以相应地调试代码。</p><figure class="ls lt lu lv gt ju"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="8fa9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">以下函数下载 MNIST 数据集，使用 MinMaxScaler 归一化数据，并将原始数据拆分为训练和测试数据集。</p><figure class="ls lt lu lv gt ju"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="a627" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">作为数据科学家，我们的任务之一是创建一个可以在以后的生产中使用的类。因此，我以一种非常熟悉的方式设计了‘the algorithm’类，你会注意到该类遵循 sklearn 的函数结构，即我们有众所周知的‘fit’和‘predict’函数(以及<strong class="kh iu"> init </strong>)。这些函数将在生产过程中使用，以使用训练集和测试集初始化类，使用训练集(即 fit())训练模型，以及使用测试集(即 predict())进行测试。为了简化，我特意使用了一个简单的训练测试分割。本教程的主要目的是解释单元测试和日志记录是如何工作的，而不是进行交叉验证、网格搜索或其他机器学习方法。最后用“@ my _ logger”&amp;“@ my _ timer”修饰每个函数。</p><figure class="ls lt lu lv gt ju"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="4dfc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在我们创建单元测试之前，我们需要一些基于数据集的输入和输出示例。首先，我们下载 MNIST 数据集，我们将其分割为 60K &amp; 10K，我们创建一个“算法”类变量并执行 fit()，我们观察训练精度和产生的混淆矩阵。就输入和输出而言，精确度数字和混淆矩阵是唯一的，并且如果我们的模型中有任何变化，包括输入、分割比、随机种子等，精确度数字和混淆矩阵也会变化。因此，在运行模型之后，我们保存单元测试的输出，我们的想法是，如果“算法”类或伴随的函数中有什么变化或中断，输出将会不匹配，测试将会失败。我们对类的 predict()函数做同样的事情，并保存最终的测试准确度和混淆矩阵。</p><figure class="ls lt lu lv gt ju"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="c890" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">以下是运行上述算法时的输出:</p><figure class="ls lt lu lv gt ju"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="68f4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们的单元测试类“TestInput”继承自“unittest”。' TestCase '，这允许我们使用几个已知的函数如' setUpClass，tearDownClass，setUp，tearDown '，前两个是先执行后执行，后两个是在每个测试函数之前执行。在“设置”功能中，我们下载数据，分割数据，并保存训练和测试精度以及混淆矩阵。这些变量将使我们能够创建两个使用 fit()和 predict()的测试，使用一个众所周知的输入，最后将结果输出与预期输出进行比较。</p><p id="40fb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为此，我们创建了“test_fit()”和“test_predict()”。在每个函数中，我们使用“assertEqual”将使用 fit()或 predict()时的结果输出与预期的输出变量进行比较。预期输出是训练和测试阶段的准确度和混淆矩阵图。如果这些输入输出单元测试失败，这意味着我们的算法有一个关键的变化。最后，我们执行我们的单元测试，如下面的输出所示，你可以看到两个测试都通过了。</p><p id="5680" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请注意，在这里有额外的断言可用于单元测试<a class="ae ld" href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.debug" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="ls lt lu lv gt ju"><div class="bz fp l di"><div class="lw lx l"/></div></figure><figure class="ls lt lu lv gt ju"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="6c28" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Ori Cohen 拥有计算机科学博士学位，并在机器学习、脑机接口和神经生物学领域完成了博士学位。</p></div></div>    
</body>
</html>