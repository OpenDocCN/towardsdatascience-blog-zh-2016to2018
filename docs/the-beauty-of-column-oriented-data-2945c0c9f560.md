# 面向列的数据之美

> 原文：<https://towardsdatascience.com/the-beauty-of-column-oriented-data-2945c0c9f560?source=collection_archive---------2----------------------->

![](img/76a9a884bd42162327270316f82c1367.png)

当我们考虑数据集时，我们自然会想到基于行的形式，其中行是一个条目，列是条目的某个属性。

好吧，我又变得太抽象了，抱歉。我们举个例子。看看 JSON 中聊天历史的简单表示:

```
[
  {
    "message": "Hi Bob. How are you?",
    "timestamp": 1508423069,
    "senderId": 238476,
    "seen": true
  },{
    "message": "This is Alex.",
    "timestamp": 1508423226,
    "senderId": 238476,
    "seen": true
  },{
    "message": "Hi Alex. I am fine. How are you?",
    "timestamp": 1508423238,
    "senderId": 9837498,
    "seen": false
  }
]
```

我们看到两个参与者之间的三条消息。消息对象是一行，消息的属性可以看作是列。这种表现方式对我们来说是很自然的，这是数据产生的方式，也是我们存储数据的方式。

现在让我们尝试一些东西，让我们旋转表示:

```
{
  "messages": ["Hi Bob. How are you?", "This is Alex.", "Hi Alex. I am fine. How are you?"],
  "timestamps": [1508423069, 1508423226, 1508423238],
  "senderId": [238476, 238476, 9837498],
  "seen": [true, true, false]
}
```

在这个 JSON 中，我们有一个面向列的表示。我们的 JSON 不再是对象的数组，它变成了数组的对象。这意味着，如果我们需要得到第二条消息，我们做类似于`o["messages"][2]`而不是`o[2]["message"]`的事情。

这样，我们就不需要重复属性名，从而使大小减少了大约 30%。可悲的是，当谈到 JSON 时，这是关于它的好处🙃。但是让我们以不同的形式来检查相同的数据。让我们看看 CSV 文件形式的相同聊天记录。

```
Hi Bob. How are you?,1508423069,238476,true
This is Alex.,1508423226,238476,true
Hi Alex. I am fine. How are you?,1508423238,9837498,false
```

## 和...相对

```
Hi Bob. How are you?,This is Alex.,Hi Alex. I am fine. How are you?
1508423069,1508423226,1508423238
238476,238476,9837498
true,true,false
```

在 CSV 中，当我们旋转表示时，尺寸没有增加。字符的数量保持不变，但我们获得了另一个有趣的好处。假设我们想要查找包含字符串“Alex”的每封邮件。面向列的 CSV 中的简单消息字符串搜索可能如下所示:

```
var index = 0
var result: Set<Int> = []for (c1, pos1) in fileContent.enumerated {
  var found = true for (c2, pos2) in searchPattern.enumerated {
    if fileContent[pos1+pos2] != c2 { found = false; break }
  }
  if found {
    result.append(index)
  } else {
    if c1 == "," {
      index += 1
    } else if c1 == "\n" {
      break
    }
  }
}
```

这个伪 Swift 代码应该可视化，在面向列的 CSV 的情况下，线性搜索被限制在第一个文本行，我们不必考虑其他行，因为我们知道消息文本被一起放在第一行。因此，搜索的最差性能是第一行的长度乘以搜索模式的长度。相反，如果数据是基于行的，最差的性能是整个文件内容的长度乘以搜索模式的长度。我们可以实现不那么简单的算法，但是它会更复杂，并且仍然具有更差的最坏情况性能，因为你不能扫描所有的字符。

现在让我们考虑二进制表示。在二进制中，我们可以从面向列的数据中获益更多。重复相同类型的数据使对齐变得简单。**等等你说的对齐是什么意思？**

维基百科上有一篇文章“[数据结构对齐](https://en.wikipedia.org/wiki/Data_structure_alignment)”你可以读一下，跳过下一段。或者如果你对我的解释更感兴趣，我会这样解释:

CPU 以 8、16、32、64 或 128 位的“块”访问内存，这取决于 CPU 的类型。假设我们有一个以 64 位= 8 字节“块”读取的 CPU。要求 CPU 转到地址 7 并读取 1 个字节是可以的，因为 CPU 实际上会从地址 0 到 8 读取数据，并给你第 7 个字节。然而，如果你要求 CPU 从地址 7 开始读取 2 个字节，你就做错了。最好的情况是您得到一个[分段故障](https://en.wikipedia.org/wiki/Segmentation_fault)，它可以通过从地址 0 到 7，然后从地址 8 到 15 加载数据来处理。最坏的情况，它变成了一个[总线错误](https://en.wikipedia.org/wiki/Bus_error)，或者未处理的[分段错误](https://en.wikipedia.org/wiki/Segmentation_fault)，导致你的应用程序崩溃。这就是数据应该对齐的原因。在我们的例子中，如果我们有一个以 8 字节“块”读取的 CPU，我们需要存储 2 字节，我们可以存储它的地址应该是`n % 8 <= 6`。

如果你认为内存对齐是一个非常深奥的话题，那你就错了。看看下面两个结构:

```
struct S1 {
 let a: Bool
 let b: Int64
 let c: Bool
 let d: Int64
 let e: Bool
}struct S2 {
 let b: Int64
 let d: Int64
 let a: Bool
 let c: Bool
 let e: Bool
}
```

struct `S1`的一个实例将被存储在 40 个字节中，但是`S2`只需要 24 个字节，即使它们存储相同的信息。结构`S1`需要在属性`a`和`b`之间填充 7 个字节，因为我们不能从地址 1 开始读取 8 个字节。这同样适用于属性`c`和`d`，为了以防万一，我们必须在属性`e`后放置 7 位填充符——因为我们不知道在`S1`后将存储什么类型的数据。在`S2`的情况下，我们只需要在属性`e`后填充 5 个字节。

我说你*有点*错了，因为大部分人都不在乎这样的内存浪费。他们与 ***【内存廉价】*** 争论。我将让您自己决定，在您的用例中，您可以允许多少内存浪费。然而，当我们谈论数据存储和加载时，我认为我们有责任将不必要的内存浪费降到最低。

让我们再次以聊天历史为例，将其作为二进制结构来研究。

```
Hi Bob. How are you?\0|1508423069|238476|true
```

假设我们想将消息保存为 UTF8 字符数组，用`0`作为字符串终止标志。时间戳将是一个 8 字节的单位。发送者 id 也是一个 8 字节的 uint，seen 标志是一个 1 字节的 bool 值。如果我们保持顺序不变，我们将不得不在消息中添加填充，因为时间戳是 8 个字节。因此应该从地址`n % 8 == 0`开始。因此，为了减少内存浪费，我们将存储如下条目

```
1508423069|238476|true|Hi Bob. How are you?\0
```

这很好，但是当我们存储许多条目时会发生什么呢

```
1508423069|238476|true|Hi Bob. How are you?\0
1508423226|238476|true|This is Alex.\0
1508423238|9837498|false|Hi Alex. I am fine. How are you?\0
```

现在我们仍然需要在文本的末尾添加填充，因为下一个条目需要从地址`n % 8 == 0`开始。因此，在最坏的情况下，我们将有 7 乘以条目数作为内存浪费。

让我们来看看面向列的表示:

```
1508423069|1508423226|1508423238
238476|238476|9837498
true|true|false
Hi Bob. How are you?\0|This is Alex.\0|Hi Alex. I am fine. How are you?\0
```

有了这样的表示，我们仍然应该在消息的末尾添加填充符——以防万一。通过这种方式，丢失了多达 7 个字节(不是每个条目，总共)，但我们也可以将 3 个 bool 值作为一个[位数组](https://en.wikipedia.org/wiki/Bit_array)存储在仅 1 个字节中，并在每个 bool 条目上获得 2 个字节或实际上是`floor(n — (n / 8))`个字节。

你可能想知道为什么我们在连接字符串时不需要关心内存对齐。我假设我们存储的是 UTF8 编码的字符串，这意味着一个文本基本上是一个 1 字节字符的数组。当将一个 UTF8 字符串加载到内存(String class/struct)时，我们一个字节一个字节地加载数据，并将其放入一个单独的缓冲区。加载单个字节不会导致任何问题。

我们看到以面向列的方式存储数据可以带来关于*字节打包的好处。*然而事实并非如此。我们在搜索方面获得了与 CSV 部分所述相同的好处。我们可以走得更远。二进制的时间戳被描述为一个 8 字节的单位。如果我们有一个固定大小的数据，我们知道它从哪里开始，我们有多少个条目，这是很容易实现随机存取:`start + (size * index)`。对于聊天历史，时间戳值按升序排序。如果我们有一个排序的数组，我们可以通过使用二分搜索法找到值甚至范围。这意味着查找在特定时间范围内发送的消息将非常有效。

## 所以你是说，面向列的数据表示是一个完美的解决方案？

哦，不！🙃

这是通过字节打包或避免重复来减小大小的一个非常好的解决方案。如果你需要迭代所有条目的一个属性，这也是一个很好的解决方案，比如当你搜索的时候。然而，如果您需要处理同一个条目的多个属性——比如您想在 UI 中显示消息，那么这并不是最佳选择。在这种情况下，我们必须从许多不同的列中提取行属性。

在 CSV(和其他基于文本的格式)的情况下，这是非常糟糕的。我说的是纯粹的 CSV 数据，没有将它吸收到一些中间数据结构中。基于文本的格式不支持随机值访问，我们需要进行扫描，以确定该列中的哪个值属于“第三”行。

像 FlexBuffers 和 ByteCabinet(我目前正在开发的一种格式)这样的二进制格式可以支持随机值访问。在这种情况下，从多个列中检索数据是合理的，但是没有打包在一起的数据快。如果您对原因感兴趣，请查看[参考位置](https://en.wikipedia.org/wiki/Locality_of_reference)文章。

## 所以你是说，我不应该对 UI 使用面向列的数据表示？

哦，不！🙃🙃

你需要考虑你的用例。如果您有一个支持随机访问的面向列的数据表示，并且您有一个向用户显示几十行的列表。这不是问题。您可以遍历 **X** 列(属性数)并读取 **Y** 条目(行数)。您将不得不在内存中跳来跳去，并且可能会产生缓存未命中，但是您只会对几十个条目这样做，UX 不会受到影响。然而，如果你需要为用户提供一个搜索，你需要浏览你所有的数据，你有数以千计，甚至数百万计的条目。从 UX 的角度来看，加载不需要的数据和 CPU 缓存缺失是非常明显的。

意识到这一点是令人难过的，但是当涉及到软件开发或任何其他现实世界的问题时，没有什么灵丹妙药。本文不应该赞扬面向列的数据表示，它应该展示它的存在、美丽以及它在某些用例中提供的好处。非常感谢你坚持和我讨论这个无聊的话题。如果你愿意，你可以鼓掌。