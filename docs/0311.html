<html>
<head>
<title>Course 1 — Algorithmic toolbox — Part 4: Dynamic programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">课程1 —算法工具箱—第4部分:动态编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/course-1-algorithmic-toolbox-part-4-dynamic-programming-223ffc01984a?source=collection_archive---------0-----------------------#2017-04-16">https://towardsdatascience.com/course-1-algorithmic-toolbox-part-4-dynamic-programming-223ffc01984a?source=collection_archive---------0-----------------------#2017-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a804" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">动态规划是一种非常强大的算法设计技术，用于解决许多指数问题。实际上，动态编程喜欢递归和“重用”。因此，为了解决动态编程的问题，我们分两步来做:</p><ul class=""><li id="8de9" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">找出正确的重现(子问题)。</li><li id="b85c" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">计算并记忆所有子问题的结果以“重复使用”。</li></ul><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/c00a777cfb8b7ef1ad2c27ae94915054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KzOeC7Z0rVPbZhln1VwrHw.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Dynamic Drinking.</figcaption></figure><p id="0876" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看<strong class="jp ir">换钱</strong>问题:</p><p id="c2af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有3种硬币:6分、5分和1分。兑换9美分最少需要多少硬币？</p><p id="ad06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了用动态规划解决这个问题，我们要做的第一件事是找到这个问题的正确递归。</p><p id="e2df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到，需要兑换9美分的最小硬币数是我们需要兑换3(= 9–6)或4(= 9–5)或8(= 9–1)的最小硬币数。所以我们有复发:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi lp"><img src="../Images/179c8b86a7ea372e4de7537139c4c493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ddfsCkeBchf8c28JAXLng.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Change Money Recurrence.</figcaption></figure><p id="edd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用递归技术来实现这个问题，但它会非常慢。为什么慢？当我们想改变76美分时，看一看递归树:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi lq"><img src="../Images/330ac8cf26bba88e93636948b58862f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pNeet1iumgO1KGSGyUYO8g.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Change 76 cents.</figcaption></figure><p id="bef4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们在可视化的树中看到的，为了计算最小数目的零钱76美分，我们计算最小数目的零钱70美分、71美分、75美分等等……零钱<strong class="jp ir"> 70 </strong>的计算重复了3次，对于大量的零钱，我们将重复许多子问题。这要花很多时间。所以，动态规划通常喜欢“存储所有子问题的结果并重用”。这个想法是，如果我们计算改变了70美分，我们不需要再次计算，我们只是返回计算结果70美分。</p><p id="e8ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现动态编程的好方法是我们首先计算更小的子问题，将结果保存到dp_array中，继续直到我们得到结果。例如，要解决兑换9美分的问题，我们将计算我们想要兑换0、1、2、3、4的最小硬币数…首先，将结果保存到dp_array中，继续直到我们计算出9美分并得到答案。</p><p id="596e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们一步一步来:</p><ol class=""><li id="1e8d" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk lr kr ks kt bi translated">计算兑换0美分=&gt; 0硬币的最小值</li></ol><p id="4c20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">dp_array = [0]</p><p id="b35b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.计算最少兑换1美分=&gt; 1枚硬币</p><p id="f472" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">dp_array = [0，1]</p><p id="0355" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.计算最小找零2美分= &gt; 2个硬币</p><p id="846a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">dp_array = [0，1，2]。</p><p id="79c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解释:2分钱= 1分钱+ 1分钱。</p><p id="0e3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.计算最少兑换3美分=&gt; 3枚硬币</p><p id="03cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">dp_array = [0，1，2，3]。</p><p id="0827" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解释:3分= 1美分+ 1美分+ 1美分。</p><p id="1dca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">……</p><p id="3cd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">8.计算最少找7美分= &gt; 2美分</p><p id="444b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">dp_array = [0，1，2，3，4，1，1，2]。</p><p id="f04c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解释:</strong>在我们计算6美分的步骤，很容易发现dp_array = [0，1，2，3，4，1，1]。</p><p id="e732" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要计算7美分的变化，按照循环，我们需要找到(compute(6 = 7–1)，compute(2 = 7–5)，compute(1 = 7–6)的最小值。</p><p id="ae09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有dp_array是计算小钱的缓存结果，所以我们有compute(6) = 1，compute(2) = 2，compute(1) = 1。这些计算货币的最小值是1。我们有两个选择:</p><ul class=""><li id="1a0c" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">1 from compute(6= 7 -1)表示我们选择1美分，需要6美分。</li><li id="a867" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">1 from compute(1 = 7–6)表示我们选择6美分，还需要1美分。</li></ul><p id="3c6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我们需要2(= 1 + 1)枚硬币将1、5、6美分换成7美分。</p><p id="fdc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">继续这样做，我们可以构建最终的dp_array = [0，1，2，3，4，1，1，2，3，4]。</p><p id="60fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">换9分钱的答案是dp_array[9] = 4个硬币。</p><p id="f8f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总而言之，我们将首先计算更小的子问题，保存结果，在每一步，我们从保存的结果中重用子问题结果。一直做下去，直到我们得到答案。</p><p id="7cdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">换钱问题的伪代码:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ls"><img src="../Images/b82da45681ea852675cc4a6e820b8e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I2YJoTEh0Z3IK_bnv4r1Qg.png"/></div></div></figure><h1 id="f624" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">编辑距离问题</h1><p id="ecd3" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">编辑距离问题有点难以理解的问题和解决的思路。但是一旦你理解了，问题似乎就很清楚了，很容易用动态编程来解决。</p><p id="1609" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以看到，当你输入拼写错误的东西时，拼写检查器会通过在字典中查找附近的其他单词来发出警告。什么是测量标准？换句话说，我们如何计算两个字符串之间的距离？</p><p id="eedd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">计算两个字符串之间距离的自然方法是扩展，对齐以匹配尽可能多的字符。例如，下雪和晴天的两种可能路线<strong class="jp ir">【1】</strong></p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi mw"><img src="../Images/944555bddb4e4bd70048833c8808e45d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2gX_I7TaD3YPYo6uXHf0Yg.png"/></div></div></figure><p id="94ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们试图将下雪和晴天的字符串对齐，以获得尽可能多的匹配字符。匹配的字符越多，我们的距离就越近。如果我们把“S_NOWY”中的“_”叫做<strong class="jp ir">插入运算符</strong>或者<strong class="jp ir">删除运算符</strong>(从SUNNY中删除“U”)和“SUNN_Y”中的“_”是一样的，<strong class="jp ir">插入运算符</strong>到SUNNY或者<strong class="jp ir">删除运算符</strong>(在SNOWY中删除W)而不匹配(O和N)就是不匹配运算符。那么我们可以说，将晴天转换为下雪天需要花费3个操作符(插入或删除，不匹配)。它们是"插入U "、"替换O-N "和"删除W "。</p><p id="c5d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意:</strong>我们将使用<strong class="jp ir">插入操作符</strong>表示上面字符串中的“_ ”,使用<strong class="jp ir">删除操作符</strong>表示下面字符串中的“_”。</p><p id="8cda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，两个字符串的距离是将字符串A转换为字符串b的插入、删除和不匹配操作符的最小数目。</p><h2 id="5136" class="mx lu iq bd lv my mz dn lz na nb dp md jy nc nd mh kc ne nf ml kg ng nh mp ni bi translated"><strong class="ak">计算编辑距离</strong></h2><p id="3b42" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">为了计算A和B的编辑距离，我们需要找出正确的递归。我们有A[1…n]，B[1…m]叫做字符串A有n个字符，字符串B有m个字符。我们会找到子问题的关系:A[1…i]，B[1…j]。我们有4种方法来对齐A[1…i]，B[1…j]。</p><ul class=""><li id="7d2d" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">插入:A[1…i，<strong class="jp ir"> "_ </strong> "]和B[1…j-1，<strong class="jp ir"> B[j] </strong> ]</li><li id="9dc3" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">删除:A[1…i-1，<strong class="jp ir"> A[i] </strong>和B[1…j，<strong class="jp ir"> "_" </strong> ]</li><li id="626e" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">错配A[1…i-1，<strong class="jp ir"> A[i] </strong>和B[1…j-1，<strong class="jp ir"> B[j] </strong> ]，是A[i] ≠ B[j]</li><li id="4542" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">匹配A[1…i-1，<strong class="jp ir"> A[i] </strong> ]和B[1…j-1，<strong class="jp ir"> B[j] </strong> ]，就是A[i] = B[j]</li></ul><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nj"><img src="../Images/cd972a95906e767bc3bd6bccd0b099dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b73v77_08rfMCrafgDh5xQ.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">4 ways to align</figcaption></figure><p id="34ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要计算A[1…i]和B[1…j]之间的距离D(i，j)，我们需要计算D(i，j-1)，D(i-1，j)，D(i-1，j-1)。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nk"><img src="../Images/8ae65680f3b5e1476e98f8681ec37dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mQZNaeSPiFlT_CMxhz7Kdw.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Edit distance recurrences.</figcaption></figure><p id="3b80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们将使用二维数组来保存计算出的距离D。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nl"><img src="../Images/42be82ca20a2f2266f8f51ba441e1db6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CeaLTroNaPEsRSjLfU-6pw.png"/></div></div></figure><p id="95a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很明显，如果D(0，j) = j和D(i，o) = i。</p><p id="2423" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了计算D(1，1)，我们只需要从这个计算出的距离D中得到值D(i，j-1)，D(i-1，j)，D(i-1，j-1)，意味着D(1，0)，D(0，1)，D(0，0)。</p><p id="865c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么<strong class="jp ir"> D(1，1) = min(2，2，1) = 1 </strong></p><p id="5a26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以此类推，我们计算D(1，2)，D(1，3)…。，D(8，7)。我们有了最终计算出的距离d。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nm"><img src="../Images/88030af4dc9943df9808336cf3e922cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xOCua2vtX-xA4u6dFlbs3A.png"/></div></div></figure><p id="f410" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们看到，编辑和距离的距离是D(7，8) = 5。</p><p id="48c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从表中，我们可以很容易地得到距离的编辑和距离是D(4，8) = 6。每个子问题都被计算、存储以便重复使用。这是动态编程。</p><p id="cddc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编辑距离的伪代码:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi mw"><img src="../Images/65096a6545baeb6b4b06f1234355ae3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WvOTSdx-AlAsPJqqOVfOcw.png"/></div></div></figure><h2 id="551f" class="mx lu iq bd lv my mz dn lz na nb dp md jy nc nd mh kc ne nf ml kg ng nh mp ni bi translated"><strong class="ak">回溯</strong></h2><p id="2443" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">回溯是动态编程的一部分。我们在编辑和距离之间找到了编辑距离的答案，但是我们怎样才能打印出对齐的结果呢？</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/e061e4200a1a78eef809820bd7608b51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*lYVC5eB7taPMEgYaOYqv_Q.png"/></div></figure><p id="600a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们有缓存的结果——计算的距离d，回溯就很容易。</p><p id="8105" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将从D(7，8)(最终结果)，知道D(7，8)是如何对齐的，我们只是检查我们如何计算D(7，8)的值是从D(7，7)，D(6，8)和D(6，7)。在这种情况下，D(7，8) = D(6，7) + 1是不匹配运算符。继续这样做，我们找到最终的排列。</p><p id="a364" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以概括我们回溯结果的方式，要知道D(i，j)是对齐的，我们需要检查<strong class="jp ir">插入操作符</strong> - D(i，j-1) + 1、<strong class="jp ir">删除操作符</strong>-D(I-1，j) + 1、<strong class="jp ir">不匹配操作符</strong>-D(I-1，j-1)和<strong class="jp ir">匹配操作符</strong> D(i-1，j-1)。D(i，j)是这些值中的一个。</p><p id="072e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回溯编辑距离的伪代码:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ls"><img src="../Images/831739ca75a742e0b324aa5eb3d6f4ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gMb0Rc7h80jIx18S0cteUw.png"/></div></div></figure><h1 id="0836" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">离散背包问题</h1><p id="a88c" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">在上一篇关于Big-O和Greedy算法的文章中，我们讨论了分数背包，也就是物品可以被分割。离散背包问题就不同了，每个物品要么拿，要么不拿。</p><p id="e88e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有两种类型的离散背包:有重复和没有重复。</p><ul class=""><li id="863e" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">有重复:有无限的项目，你可以采取每个项目多次你想要的。</li><li id="eb02" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">没有重复:每个项目都有一个，所以每个项目，你只能拿一个。</li></ul><h2 id="0596" class="mx lu iq bd lv my mz dn lz na nb dp md jy nc nd mh kc ne nf ml kg ng nh mp ni bi translated">重复背包问题。</h2><p id="2e3d" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated"><strong class="jp ir">输入:</strong>我们有n个项目，权重为:w1，w2，…，wn，值为v1，v2，…，vn。和总容量重量:w</p><p id="7782" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出:</strong>重量不超过w的物品的最大值<strong class="jp ir">每个物品可以使用任意次。</strong></p><p id="9d5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了用动态编程解决这个问题，我们需要找出递归(子问题)并设计缓存结果。</p><p id="a519" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们很容易看到的，要找到项目W(w1 + w2 + …wi)的最大值，我们需要找到(w2 + w3 + … + wi) + v1，(w1 +w3 + … + wi) + v2，…..、(w1+w2+…+w(i-1)) + wi。形式上，</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi no"><img src="../Images/3aa0681670b43e27aa4d0c45553064ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sHwN045KbVX78i7_EYSGTw.png"/></div></div></figure><p id="d5a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们需要的重现。所以我们计算W = 1，W=2，…的最大值..直到我们得到W = W。我们只需要一个数组W[0…W]来保存缓存的结果。</p><p id="2753" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重复背包问题的伪代码:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi np"><img src="../Images/cdd3bfe5e17266d4332ce32ce4ead651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9as6TBNmzWFeRCtD6tQ-YA.png"/></div></div></figure><h2 id="3018" class="mx lu iq bd lv my mz dn lz na nb dp md jy nc nd mh kc ne nf ml kg ng nh mp ni bi translated">背包无重复问题。</h2><p id="de69" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated"><strong class="jp ir">输入:</strong>我们有n个项目，权重为:w1，w2，…，wn，值为v1，v2，…，vn。和总容量重量:w</p><p id="ae53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出:</strong>重量不超过w的物品最大值<strong class="jp ir">每件物品最多使用一次。</strong></p><p id="20df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了找出这个问题的重复出现，我们需要澄清要点:</p><ul class=""><li id="c226" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">每一项要么拿，要么不拿。换句话说，W(w1，w2，…)的最大值。wi)由W(w1，w2，…，wi)或W(w1，w2，…)的最大值构成。w(i-1))。形式上:</li></ul><p id="ca13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> value(w，i) </strong> = max{ <strong class="jp ir"> value(w-wi，i-1) + vi </strong>，<strong class="jp ir"> value(w，i-1) </strong> }</p><p id="ca63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我们需要计算(w = 1，2，…)的最大值。w，<strong class="jp ir"> i = 1 </strong>)，(w = 1，2…w，<strong class="jp ir"> i = 2 </strong>)，…。(w= 1，2，…w，<strong class="jp ir"> i = n </strong>)得到结果<strong class="jp ir">值(w，n) </strong>。我们需要一个二维数组来存储缓存的结果。</p><p id="7080" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">背包重复问题的伪代码。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nq"><img src="../Images/2788987ed4db33bcd8ee4a77c0320700.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5QZtbs8yOnvhzAz0Txnzbg.png"/></div></div></figure><p id="33ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例子:</strong></p><p id="55ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有4个权重为(w1，v1)= (6，30)，(w2，v2)= (3，14)，(w3，v3)= (4，16)，(w4，v4)= (2，9)的项目。</p><p id="d450" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过使用该策略，我们可以构建最终表:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nr"><img src="../Images/88aaacda030d3cf8b50719b943c40d1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fw58PdqLO0qsKwoAl3AVCw.png"/></div></div></figure><p id="eb41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到，值[w=10，i=4]是46。该值的计算公式如下</p><p id="c775" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">max{ value[(w=10) —(wi=2)，i=2] + vi=9，value[w=10，i=2]}</p><p id="0e54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">= max{value[8，2] + 9，value[10，1] }</p><p id="ec31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">= max{ 46，30} = 46。</p><h2 id="63e4" class="mx lu iq bd lv my mz dn lz na nb dp md jy nc nd mh kc ne nf ml kg ng nh mp ni bi translated"><strong class="ak">回溯</strong></h2><p id="b511" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">在我们建立了这个表之后，它包含了所有的结果值。我们可以用它回溯来标记哪个项目被使用。像上面的例子一样，值(10，4) = 46选自值(8，2) + 9。因此，我们可以标记第4项未使用。</p><h1 id="7649" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">放置括号的问题。</h1><p id="cfee" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">动态规划要解决的一个好问题是括号问题。</p><p id="a728" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入:</strong>一串数字d1，.。。、dn和一系列操作</p><p id="efa6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">op1，…，op(n 1)∈{+，，×}。</p><p id="f470" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出:</strong>应用这些操作的顺序</p><p id="c007" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">表达式的值。<strong class="jp ir">D1 op1 D2 op2 op(n1)dn。</strong></p><p id="a5d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例如:</strong></p><p id="899d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何在一个表达式<strong class="jp ir"> 1 + 2 — 3 x 4 — 5 </strong>中放置括号使其值最大化？</p><p id="2a57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">答案是:((1+2)(3×(45)))= 6。</p><p id="5f5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">找出这个问题的正确重现。我们假设表达式<strong class="jp ir">58+7×48+9</strong>的最佳括号中的最后一个操作是<strong class="jp ir"> x. </strong></p><p id="4b2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以目标是找出(58+7)<strong class="jp ir">×</strong>(48+9)的最大值</p><p id="94b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以看到子问题，我们有两个子表达式:s1，s2。为了找到s1 x s2的最大值，我们将找到max{ min(s1) x min(s2)，min(s1) x max(s2)，max(s1) x min(s2)，max(s1) x max(s2) }。在此基础上，我们可以计算出<strong class="jp ir">(58+7)×(48+9)</strong>的最大值</p><p id="55c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">min(58+7)=(5(8+7))= 10</p><p id="29c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">max(58+7)=((58)+7)= 4</p><p id="8170" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">min(48+9)=(4(8+9))= 13</p><p id="4652" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">max(48+9)=((48)+9)= 5</p><p id="d498" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然，<strong class="jp ir">max((58+7)×(48+9))= 130</strong></p><p id="c6f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，为了找到子表达式E(i，j)的最大值，我们遵循递归:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ns"><img src="../Images/233516c53e80e78fcd80247cd1b40f4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eUZfB_95WJReQ5KNuwkkiA.png"/></div></div></figure><p id="e0fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">M(i，j)是E(i，j)的最大值，m(i，j)是E(i，j)的最小值。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nt"><img src="../Images/3f748f75859897538c4d37bd79576e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-g_Dhl0rp97azSFs58aClw.png"/></div></div></figure><p id="2ce9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着为了计算M(i，j ),我们需要首先计算并缓存结果M(i，k)和M(k+1，j)。为此，我们将按照(j — i)递增的顺序计算所有子问题。换句话说，我们需要先计算(j-i)= 1，然后(j-I)= 2……例如，为了计算<strong class="jp ir">5 8 + 7×4 8+9，</strong>我们需要先计算(<strong class="jp ir">5 8)，(8+7)，(7 x 4)，(4 8)，(8 + 9) </strong>子问题，然后计算<strong class="jp ir"> (5 — 8 +7)，(8+7 x 4)，(7 x 4–8)，(4–8+9)</strong>等等……</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nu"><img src="../Images/50b3cde055689202dfb71d67c8cd4554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WfM5ZhaU3SylBEFmcPexAQ.png"/></div></div></figure><p id="4e9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于该策略，我们可以构建表达式表:<strong class="jp ir">58+7×48+9</strong></p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nv"><img src="../Images/be9caf30da7de302e7ec12ecdaa8317a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hNFf_LPaN5KNvb4dhYzRLw.png"/></div></div></figure><p id="a68d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理解每个问题的动态编程需要时间，但是一旦你理解了它并找到了正确的递归，代码就很容易实现了。让我们通过练习一些问题来全面理解动态编程。</p><h1 id="b930" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">问题1:原始计算器</h1><p id="824d" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">给你一个可以用当前数x进行以下三种运算的原始计算器:x乘以2，x乘以3，或者x加1 .给你的目标是一个正整数n，求从数1开始得到数n所需的最小运算次数。</p><p id="2466" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题描述</strong></p><p id="a8ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">任务。</strong>给定一个整数n，从数字1开始计算得到数字n所需的最少运算次数。</p><p id="b015" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出格式。</strong>在第一行，输出从1得到n所需的最小运算次数k。在第二行输出一系列中间数字。也就是说，第二行应该包含正整数a0，a2，…，a(k-1)使得a0 =1，a(k-1) =n并且对于所有0≤i &lt; k-1，ai + 1等于ai+1，2 x ai，或者3 x ai。如果有许多这样的序列，输出其中的任何一个。</p><p id="096f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">样品1。</strong></p><p id="13cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入:</strong> 5</p><p id="1bfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出:</strong></p><p id="eb66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">3</p><p id="084d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">1 2 4 5</p><p id="3d13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解释:</strong> <br/>这里我们先把1乘以2两次，然后再加1((1 x 2)x 2)+1)。还有一种可能是先乘以3，再加两次1。因此，在这种情况下,“1 3 4 5”也是有效的输出。</p><p id="5829" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">样品2: </strong></p><p id="9e14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入:</strong> 96234</p><p id="fd1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出:</strong></p><p id="98bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">14</p><p id="0395" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">1 3 9 10 11 22 66 198 594 1782 5346 16038 16039 32078 96234</p><p id="f828" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解释:</strong> <br/>同样，这种情况下的另一个有效输出是“1 3 9 10 11 33 99 297 891 2673 8019 16038 16039 48117 96234”。</p><p id="cb95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你的目标是为这个问题设计并实现一个动态编程解决方案。在这种情况下，一个自然的子问题如下:C(n)是从1得到n所需的最小运算数(使用三个基本运算)。如何通过C(n/3)，C(n/2)，C(n-1)表示C(n)？</p><h2 id="f75e" class="mx lu iq bd lv my mz dn lz na nb dp md jy nc nd mh kc ne nf ml kg ng nh mp ni bi translated"><strong class="ak">解决方案:</strong></h2><p id="b450" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">首先要做的是找出这个问题的重现。很容易看出对于n = 0，2，3。我们只需要一次手术。n = 1成本0操作。</p><p id="59f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于n = 4，我们可以表示为4 = 4/2 * 2或4 =(4–1)+1。</p><p id="8026" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即C(4) = C(n/2) + 1或C(4) = C(n-1) + 1。因为4不能被3除，所以我们忽略C(n/3)。</p><p id="e8ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过这个观察，我们可以推广这个问题的递归性:</p><p id="b27b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">C(n) = min{ <strong class="jp ir"> C(n/3) + 1如果n ⋮ 3 </strong>，<strong class="jp ir"> C(n/2) + 1如果n ⋮ 2 </strong>，<strong class="jp ir"> C(n-1) + 1 </strong> }</p><p id="69b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有递归，我们可以很容易地实现它:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="1245" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们计算出运算的最小值后，我们需要<strong class="jp ir">回溯</strong>来给出数列。正如我们之前所说的，在我们计算了最少的操作之后，我们得到了缓存的结果:<strong class="jp ir"> result </strong>。它包含了我们从0，1，2，… n需要达到的所有操作数。</p><p id="7a93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，对于计算编号n，我们有一个操作数组:</p><p id="4dcf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果= [0，0，1，1，2，<strong class="jp ir"> 3 </strong>，2，3，3，2，<strong class="jp ir"> 3 </strong></p><p id="ad3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，n = 10 =&gt; result[10] = 3。n = 5 = &gt;结果[5] = 3。</p><p id="42c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了计算结果[10]，我们将基于结果[10/2] = 3和结果[10–1]= 2。我们为前一个数字选择较小的运算。所以我们会选择10 -1 = 9为前面的数10 — ( 9 -&gt; 10)用-1运算。</p><p id="e52c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">小心能除以2和3的数。因此，我们将选择除以3，以获得更小数量的下一个n = n/3</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="ac2c" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">问题2:尽可能多拿黄金</h1><p id="fd42" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">这个问题是关于实现无重复背包问题的算法。</p><p id="3dd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题描述</strong></p><p id="f9b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">任务。在这个问题中，给你一套金条，你的目标是将尽可能多的金子放进你的包里。每个条形只有一个副本，对于每个条形，你可以选择接受或不接受(因此你不能接受条形的一部分)。</strong></p><p id="19d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入格式。输入的第一行包含背包的容量W和金条的数量n。下一行包含n个整数w0，w1，.。。w(n-1)定义金条的重量。</strong></p><p id="4460" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出格式。输出一个容量为W的背包所能装下的最大重量的黄金。</strong></p><p id="882b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">样品1。</strong></p><p id="5c5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入:</strong></p><p id="b9e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">10 3</p><p id="27ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">1 4 8</p><p id="cfd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出:</strong></p><p id="daba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">9</p><p id="a67e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解释:</strong> <br/>这里我们有W = 10，3根金条:1，4，8。第一个和最后一个条形的权重之和等于9。</p><p id="4adc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要解决这个问题，只需仔细实现讲座中涉及的相应算法即可。</p><h2 id="921d" class="mx lu iq bd lv my mz dn lz na nb dp md jy nc nd mh kc ne nf ml kg ng nh mp ni bi translated">解决方案:</h2><p id="cd2e" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">我们只是实现了背包，没有重复以上。但是我们需要澄清:金条的价值和金条的重量是一样的。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="ec27" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">问题3:计算两个字符串之间的编辑距离</h1><p id="52f8" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">两个字符串之间的编辑距离是两个字符串对齐中插入、删除和不匹配的最小数量。</p><p id="09d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题描述</strong></p><p id="19fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">任务。这个问题的目标是实现计算两个字符串之间编辑距离的算法。</strong></p><p id="a11d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入格式。</strong>两行输入的每一行都包含一个由小写拉丁字母组成的字符串。</p><p id="8a97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出格式。</strong>输出给定的两个字符串之间的编辑距离。</p><p id="3067" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">样品1。</strong></p><p id="80f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入</strong>:</p><p id="0877" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">短裤</p><p id="44c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">港口</p><p id="8423" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出</strong>:</p><p id="461f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">3</p><p id="07d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">说明:<br/>总成本3的对齐:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/462f18862378ebffe281c1fb94a0655f.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*f3lVWGaYzCrTMt1Vkiz-SQ.png"/></div></figure><p id="d6da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要解决这个问题，只需仔细实现讲座中涉及的相应算法即可。</p><p id="1134" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解决方案:</strong></p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="073a" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">问题4:最大化算术表达式的值</h1><p id="cef0" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">在这个问题中，你的目标是给一个给定的算术表达式加上括号，使其值最大化。</p><p id="0e01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题描述</strong></p><p id="9b69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">任务</strong>。通过使用附加括号指定算术运算的应用顺序，找到算术表达式的最大值。</p><p id="b566" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入格式</strong>。输入的唯一一行包含长度为2n + 1的字符串s，对于某些n，符号为s0，s1，.。。，s2n。s的偶数位置上的每个符号是一个数字(即从0到9的整数)，而奇数位置上的每个符号是{+、-、*}的三种运算之一。</p><p id="931d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出格式。</strong>在应用算术运算的不同顺序中，输出给定算术表达式的最大可能值。</p><p id="96e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">样品2。</strong></p><p id="bd2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入:</strong></p><p id="2f19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">5–8+7*4–8+9</p><p id="3f2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出:</strong></p><p id="5c0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">200</p><p id="7d41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解释:</strong></p><p id="ed01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">200 = (5 ((8 + 7) x (4 (8 + 9))))</p><p id="2fd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要解决这个问题，只需仔细实现讲座中涉及的相应算法即可。</p><h2 id="6c63" class="mx lu iq bd lv my mz dn lz na nb dp md jy nc nd mh kc ne nf ml kg ng nh mp ni bi translated"><strong class="ak">解决方案:</strong></h2><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="de3e" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated"><strong class="ak">高级问题5:三个序列的最长公共子序列</strong></h1><p id="844d" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">在这个问题中，你的目标是计算三个序列的最长公共子序列的长度。</p><p id="515c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题描述</strong></p><p id="8d19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">任务。</strong>给定三个序列A = (a1，a2，…，an)，B = (b1，b2，…，bm)，C = (c1，c2，…，cl)，求它们的最长公共子序列的长度。</p><p id="6af5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入格式。</strong>第一行:n .第二行:a1，a2，.。。，安。第三行:m .第四行:b1，b2，.。。，bm。第五行:l .第六行:c1，c2，…，cl。</p><p id="e3cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出。</strong>它们最长公共子序列的长度。</p><p id="4ee6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">样品1。</strong></p><p id="4a21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入:</strong></p><p id="0446" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">3</p><p id="c5c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">1 2 3</p><p id="763c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">3</p><p id="ef84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">2 1 3</p><p id="995c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">3</p><p id="f12f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">1 3 5</p><p id="beec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出:</strong> 2</p><p id="adca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解释:<br/> </strong>长度为2的一个常见子序列是(1，3)。</p><p id="92ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先设计一个寻找两个(而不是三个)序列的最长公共子序列的算法可能更容易。为此，请复习课堂上计算编辑距离的算法。</p><h2 id="519e" class="mx lu iq bd lv my mz dn lz na nb dp md jy nc nd mh kc ne nf ml kg ng nh mp ni bi translated"><strong class="ak">解决方案:</strong></h2><p id="a80b" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">这个问题最难的工作是找出复发。在每一步，我们如何从<strong class="jp ir"> D(x-1，y，z) </strong>、<strong class="jp ir"> D(x，y-1，z) </strong>和<strong class="jp ir"> D(x，y，z-1)之间找到<strong class="jp ir"> D(x，y，z) </strong>的关系。</strong></p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="6b63" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">最后的话:</h1><p id="1372" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">这是<strong class="jp ir">课程1 —算法工具箱</strong>系列的最后一篇文章。我们有3种解决问题的策略:贪婪，分而治之，动态规划。我们确实讨论了Big-O，并解决了许多关于非常大的数据集和边的问题。通过小测试很容易，但是快速、有效地通过测试却一点也不容易。</p><p id="f442" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢您抽出时间阅读。如果你觉得不错，你可以点击♡把我的文章推荐给你的朋友。</p><p id="aa34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如果你喜欢这篇文章，你可能会喜欢:</strong></p><p id="e29c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae nz" href="https://medium.com/towards-data-science/course-1-algorithmic-toolbox-part-1-introduction-c29b8175430f" rel="noopener">算法工具箱—第1部分:简介</a></p><p id="9559" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae nz" href="https://medium.com/towards-data-science/course-1-algorithmic-toolbox-part-2-big-o-and-greedy-6265d9065f05" rel="noopener">算法工具箱—第2部分:大O和贪婪</a></p><p id="c7e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae nz" href="https://medium.com/towards-data-science/course-1-algorithmic-toolbox-part-3-divide-and-conquer-dd9022bfa2c0" rel="noopener">算法工具箱—第三部分:分而治之</a></p><p id="2911" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">资源:</strong></p><p id="2402" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[1]:编辑距离:[DPV08]的第6.3节</p><p id="b3c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">变更问题:[CP]的“动态编程简介:变更问题”一节</p><p id="1d5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">背包:[DPV08]第6.4节</p><p id="a2f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae nz" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/lecture-21-dp-iii-parenthesization-edit-distance-knapsack/#vid_related" rel="noopener ugc nofollow" target="_blank">麻省理工学院动态编程讲座。</a></p><p id="155f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">进阶阅读:</strong>【CP】第五章“我们如何比较生物序列”</p><p id="190b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">进阶阅读:</strong> <a class="ae nz" href="http://jeffe.cs.illinois.edu/teaching/algorithms/notes/06-sparsedynprog.pdf" rel="noopener ugc nofollow" target="_blank">高级动态编程讲义</a>杰夫·埃里克森著</p><p id="376c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">参考文献:</strong></p><p id="0c1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Sanjoy Dasgupta、Christos Papadimitriou和Umesh Vazirani。算法(第一版)。麦格劳-希尔高等教育。2008.</p><p id="fcf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">托马斯·h·科尔曼，查尔斯·e·莱瑟森，罗纳德·L·李维斯特，克利福德·斯坦。算法导论(第三版)。麻省理工学院出版社和麦格劳-希尔。2009.</p><p id="8b0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">菲利普·孔波夫，帕维尔·佩夫兹纳。生物信息学算法:一种主动学习方法。主动学习出版商。2014.</p></div></div>    
</body>
</html>