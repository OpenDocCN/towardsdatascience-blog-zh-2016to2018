<html>
<head>
<title>Processing XML in Python — ElementTree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 处理 XML—element tree</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/processing-xml-in-python-elementtree-c8992941efd2?source=collection_archive---------0-----------------------#2018-09-15">https://towardsdatascience.com/processing-xml-in-python-elementtree-c8992941efd2?source=collection_archive---------0-----------------------#2018-09-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fd9f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">初学者指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/662f0a1c298d7845f4618bd665e70cd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HPDFQsj8jJUXI6nU"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">“shallow focus photography of spider web” by <a class="ae kv" href="https://unsplash.com/@diesektion?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Robert Anasch</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="92c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">了解如何使用 Python ElementTree 包解析、浏览、修改和填充 XML 文件，用于循环和 XPath 表达式。作为一名数据科学家，您会发现理解 XML 对于 web 抓取和解析结构化文档的一般实践都是非常有用的</p><p id="fa50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">可扩展标记语言</strong> (XML)是一种标记语言，它通过定义一组机器可读和人类可读格式的规则来编码文档。从 SGML(标准通用标记语言)扩展而来，它让我们描述文档的结构。在 XML 中，我们可以定义自定义标签。我们也可以使用 XML 作为交换信息的标准格式。</p><ul class=""><li id="376c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">XML 文档有几个部分，叫做<strong class="ky ir"> <em class="mb">元素</em> </strong>，由一个开始<strong class="ky ir">和一个结束<em class="mb">标签</em> </strong>定义。标签是一种标记结构，以<code class="fe mc md me mf b">&lt;</code>开始，以<code class="fe mc md me mf b">&gt;</code>结束。开始标记和结束标记之间的字符(如果有的话)是元素的内容。元素可以包含标记，包括其他元素，这些元素称为“子元素”。</li><li id="9bec" class="ls lt iq ky b kz mg lc mh lf mi lj mj ln mk lr lx ly lz ma bi translated">最大的顶级元素称为<strong class="ky ir"> <em class="mb">根</em> </strong>，它包含所有其他元素。</li><li id="5d59" class="ls lt iq ky b kz mg lc mh lf mi lj mj ln mk lr lx ly lz ma bi translated">属性是存在于开始标记或空元素标记中的名称-值对。XML 属性只能有一个值，并且每个属性在每个元素中最多只能出现一次。</li></ul><p id="07b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一张<code class="fe mc md me mf b">movies.xml</code>的快照，我们将在本教程中使用:</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="94bf" class="mp mq iq mf b gy mr ms l mt mu">&lt;?xml version="1.0"?&gt;<br/>&lt;collection&gt;<br/>    &lt;genre category="Action"&gt;<br/>        &lt;decade years="1980s"&gt;<br/>            &lt;movie favorite="True" title="Indiana Jones: The raiders of the lost Ark"&gt;<br/>                &lt;format multiple="No"&gt;DVD&lt;/format&gt;<br/>                &lt;year&gt;1981&lt;/year&gt;<br/>                &lt;rating&gt;PG&lt;/rating&gt;<br/>                &lt;description&gt;<br/>                'Archaeologist and adventurer Indiana Jones <br/>                is hired by the U.S. government to find the Ark of  the Covenant before the Nazis.'<br/>                &lt;/description&gt;<br/>            &lt;/movie&gt;<br/>               &lt;movie favorite="True" title="THE KARATE KID"&gt;<br/>               &lt;format multiple="Yes"&gt;DVD,Online&lt;/format&gt;<br/>               &lt;year&gt;1984&lt;/year&gt;<br/>               &lt;rating&gt;PG&lt;/rating&gt;<br/>               &lt;description&gt;None provided.&lt;/description&gt;<br/>            &lt;/movie&gt;<br/>            &lt;movie favorite="False" title="Back 2 the Future"&gt;<br/>               &lt;format multiple="False"&gt;Blu-ray&lt;/format&gt;<br/>               &lt;year&gt;1985&lt;/year&gt;<br/>               &lt;rating&gt;PG&lt;/rating&gt;<br/>               &lt;description&gt;Marty McFly&lt;/description&gt;<br/>            &lt;/movie&gt;<br/>        &lt;/decade&gt;<br/>        &lt;decade years="1990s"&gt;<br/>            &lt;movie favorite="False" title="X-Men"&gt;<br/>               &lt;format multiple="Yes"&gt;dvd, digital&lt;/format&gt;<br/>               &lt;year&gt;2000&lt;/year&gt;<br/>               &lt;rating&gt;PG-13&lt;/rating&gt;<br/>               &lt;description&gt;Two mutants come to a private academy for their kind whose resident superhero team must oppose a terrorist organization with similar powers.&lt;/description&gt;<br/>            &lt;/movie&gt;<br/>            &lt;movie favorite="True" title="Batman Returns"&gt;<br/>               &lt;format multiple="No"&gt;VHS&lt;/format&gt;<br/>               &lt;year&gt;1992&lt;/year&gt;<br/>               &lt;rating&gt;PG13&lt;/rating&gt;<br/>               &lt;description&gt;NA.&lt;/description&gt;<br/>            &lt;/movie&gt;<br/>               &lt;movie favorite="False" title="Reservoir Dogs"&gt;<br/>               &lt;format multiple="No"&gt;Online&lt;/format&gt;<br/>               &lt;year&gt;1992&lt;/year&gt;<br/>               &lt;rating&gt;R&lt;/rating&gt;<br/>               &lt;description&gt;WhAtEvER I Want!!!?!&lt;/description&gt;<br/>            &lt;/movie&gt;<br/>        &lt;/decade&gt;    <br/>    &lt;/genre&gt;<br/><br/>    &lt;genre category="Thriller"&gt;<br/>        &lt;decade years="1970s"&gt;<br/>            &lt;movie favorite="False" title="ALIEN"&gt;<br/>                &lt;format multiple="Yes"&gt;DVD&lt;/format&gt;<br/>                &lt;year&gt;1979&lt;/year&gt;<br/>                &lt;rating&gt;R&lt;/rating&gt;<br/>                &lt;description&gt;"""""""""&lt;/description&gt;<br/>            &lt;/movie&gt;<br/>        &lt;/decade&gt;<br/>        &lt;decade years="1980s"&gt;<br/>            &lt;movie favorite="True" title="Ferris Bueller's Day Off"&gt;<br/>                &lt;format multiple="No"&gt;DVD&lt;/format&gt;<br/>                &lt;year&gt;1986&lt;/year&gt;<br/>                &lt;rating&gt;PG13&lt;/rating&gt;<br/>                &lt;description&gt;Funny movie on funny guy &lt;/description&gt;<br/>            &lt;/movie&gt;<br/>            &lt;movie favorite="FALSE" title="American Psycho"&gt;<br/>                &lt;format multiple="No"&gt;blue-ray&lt;/format&gt;<br/>                &lt;year&gt;2000&lt;/year&gt;<br/>                &lt;rating&gt;Unrated&lt;/rating&gt;<br/>                &lt;description&gt;psychopathic Bateman&lt;/description&gt;<br/>            &lt;/movie&gt;<br/>        &lt;/decade&gt;<br/>    &lt;/genre&gt;</span></pre><h1 id="a657" class="mv mq iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">元素树简介</h1><p id="b554" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">XML 树结构使得导航、修改和移除在程序上相对简单。Python 有一个内置的库，<strong class="ky ir"> ElementTree </strong>，它有读取和操作 XML(和其他类似结构的文件)的函数。</p><p id="bce5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一、导入<code class="fe mc md me mf b">ElementTree</code>。使用<code class="fe mc md me mf b">ET</code>的化名是很常见的做法:</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="63bb" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">import xml.etree.ElementTree as ET</strong></span></pre><h2 id="49e4" class="mp mq iq bd mw nr ns dn na nt nu dp ne lf nv nw ng lj nx ny ni ln nz oa nk ob bi translated">解析 XML 数据</h2><p id="e8c0" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">在提供的 XML 文件中，有一个描述电影的基本集合。唯一的问题是数据很乱！这个收藏有很多不同的管理者，每个人都有自己的方式将数据输入文件。本教程的主要目标是用 Python 阅读和理解文件，然后解决问题。</p><p id="416d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先你需要用<code class="fe mc md me mf b">ElementTree</code>读入文件。</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="f648" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">tree = ET.parse('movies.xml')<br/>root = tree.getroot()</strong></span></pre><p id="f23e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在已经初始化了树，您应该查看 XML 并打印出值，以便理解树是如何构造的。</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="67a2" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">root.tag</strong></span><span id="45b2" class="mp mq iq mf b gy oc ms l mt mu">'collection'</span></pre><p id="de9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在顶层，您会看到这个 XML 植根于<code class="fe mc md me mf b">collection</code>标签。</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="1bf3" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">root.attrib</strong></span><span id="fda1" class="mp mq iq mf b gy oc ms l mt mu">{}</span></pre><h2 id="d271" class="mp mq iq bd mw nr ns dn na nt nu dp ne lf nv nw ng lj nx ny ni ln nz oa nk ob bi translated">对于循环</h2><p id="dc9a" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">通过使用一个简单的“for”循环，可以很容易地迭代根中的子元素(通常称为“子元素”)。</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="61a1" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">for child in root:<br/>    print(child.tag, child.attrib)</strong></span><span id="fee1" class="mp mq iq mf b gy oc ms l mt mu">genre {'category': 'Action'}<br/>genre {'category': 'Thriller'}<br/>genre {'category': 'Comedy'}</span></pre><p id="d6c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你知道根<code class="fe mc md me mf b">collection</code>的孩子都是<code class="fe mc md me mf b">genre</code>。为了指定流派，XML 使用属性<code class="fe mc md me mf b">category</code>。根据<code class="fe mc md me mf b">genre</code>元素，有动作片、惊悚片和喜剧片。</p><p id="cb30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，了解整个树中的所有元素是很有帮助的。一个有用的功能是<code class="fe mc md me mf b">root.iter()</code>。</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="1f53" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">[elem.tag for elem in root.iter()]</strong></span><span id="0f3b" class="mp mq iq mf b gy oc ms l mt mu">['collection',<br/> 'genre',<br/> 'decade',<br/> 'movie',<br/> 'format',<br/> 'year',<br/> 'rating',<br/> 'description',<br/> 'movie',<br/> .<br/> .<br/> .<br/> .<br/> 'movie',<br/> 'format',<br/> 'year',<br/> 'rating',<br/> 'description']</span></pre><p id="6d54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一种查看整个文档的有用方法。如果将根传递给<code class="fe mc md me mf b">.tostring()</code>方法，就可以返回整个文档。在 ElementTree 中，这个方法采用了一种稍微奇怪的形式。</p><p id="5d4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于 ElementTree 是一个功能强大的库，它不仅可以解释 XML，还必须指定显示为字符串的文档的编码和解码。</p><p id="2227" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以扩展<code class="fe mc md me mf b">iter()</code>函数的用途，以帮助查找感兴趣的特定元素。<code class="fe mc md me mf b">root.iter()</code>将列出根下与指定元素匹配的所有子元素。这里，您将列出树中<code class="fe mc md me mf b">movie</code>元素的所有属性:</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="c373" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">for movie in root.iter('movie'):<br/>    print(movie.attrib)</strong></span><span id="abbe" class="mp mq iq mf b gy oc ms l mt mu">{'favorite': 'True', 'title': 'Indiana Jones: The raiders of the lost Ark'}<br/>{'favorite': 'True', 'title': 'THE KARATE KID'}<br/>{'favorite': 'False', 'title': 'Back 2 the Future'}<br/>{'favorite': 'False', 'title': 'X-Men'}<br/>{'favorite': 'True', 'title': 'Batman Returns'}<br/>{'favorite': 'False', 'title': 'Reservoir Dogs'}<br/>{'favorite': 'False', 'title': 'ALIEN'}<br/>{'favorite': 'True', 'title': "Ferris Bueller's Day Off"}<br/>{'favorite': 'FALSE', 'title': 'American Psycho'}<br/>{'favorite': 'False', 'title': 'Batman: The Movie'}<br/>{'favorite': 'True', 'title': 'Easy A'}<br/>{'favorite': 'True', 'title': 'Dinner for SCHMUCKS'}<br/>{'favorite': 'False', 'title': 'Ghostbusters'}<br/>{'favorite': 'True', 'title': 'Robin Hood: Prince of Thieves'}</span></pre><h2 id="4d7d" class="mp mq iq bd mw nr ns dn na nt nu dp ne lf nv nw ng lj nx ny ni ln nz oa nk ob bi translated">XPath 表达式</h2><p id="5b17" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">很多时候元素没有属性，它们只有文本内容。使用属性<code class="fe mc md me mf b">.text</code>，可以打印出这个内容。</p><p id="1cff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，打印出电影的所有描述。</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="5138" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">for description in root.iter('description'):<br/>    print(description.text)</strong></span><span id="e399" class="mp mq iq mf b gy oc ms l mt mu">'Archaeologist and adventurer Indiana Jones is hired by the U.S. government to find the Ark of the Covenant before the Nazis.'</span><span id="b89f" class="mp mq iq mf b gy oc ms l mt mu">None provided.<br/>Marty McFly<br/>Two mutants come to a private academy for their kind whose resident superhero team must oppose a terrorist organization with similar powers.<br/>NA.<br/>WhAtEvER I Want!!!?!<br/>"""""""""<br/>Funny movie about a funny guy<br/>psychopathic Bateman<br/>What a joke!<br/>Emma Stone = Hester Prynne<br/>Tim (Rudd) is a rising executive who “succeeds” in finding the perfect guest, IRS employee Barry (Carell), for his boss’ monthly event, a so-called “dinner for idiots,” which offers certain <br/>advantages to the exec who shows up with the biggest buffoon.</span><span id="ce84" class="mp mq iq mf b gy oc ms l mt mu">Who ya gonna call?<br/>Robin Hood slaying</span></pre><p id="5e8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打印出 XML 很有帮助，但是 XPath 是一种查询语言，用于快速方便地搜索 XML。然而，理解 XPath 对于扫描和填充 XML 至关重要。<code class="fe mc md me mf b">ElementTree</code>有一个<code class="fe mc md me mf b">.findall()</code>函数，它将遍历被引用元素的直接子元素。</p><p id="bf37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，您将搜索 1992 年上映的电影树:</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="5604" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">for movie in root.findall("./genre/decade/movie/[year='1992']"):<br/>    print(movie.attrib)</strong></span><span id="8b33" class="mp mq iq mf b gy oc ms l mt mu">{'favorite': 'True', 'title': 'Batman Returns'}<br/>{'favorite': 'False', 'title': 'Reservoir Dogs'}</span></pre><p id="27aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数<code class="fe mc md me mf b">.findall()</code>总是从指定的元素开始。这种类型的功能对于“查找和替换”来说非常强大。你甚至可以搜索属性！</p><p id="6fc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，只打印多种格式的电影(一个属性)。</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="548f" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">for movie in root.findall("./genre/decade/movie/format/[@multiple='Yes']"):<br/>    print(movie.attrib)</strong></span><span id="355a" class="mp mq iq mf b gy oc ms l mt mu">{'multiple': 'Yes'}<br/>{'multiple': 'Yes'}<br/>{'multiple': 'Yes'}<br/>{'multiple': 'Yes'}<br/>{'multiple': 'Yes'}</span></pre><p id="ee50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">集思广益，为什么在这种情况下，print 语句返回<code class="fe mc md me mf b">multiple</code>的“是”值。想想“for”循环是怎么定义的。</p><p id="22bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">提示</strong>:在 XPath 内部使用<code class="fe mc md me mf b">'...'</code>返回当前元素的父元素。</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="120a" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">for movie in root.findall("./genre/decade/movie/format[@multiple='Yes']..."):<br/>    print(movie.attrib)</strong></span><span id="79b2" class="mp mq iq mf b gy oc ms l mt mu">{'favorite': 'True', 'title': 'THE KARATE KID'}<br/>{'favorite': 'False', 'title': 'X-Men'}<br/>{'favorite': 'False', 'title': 'ALIEN'}<br/>{'favorite': 'False', 'title': 'Batman: The Movie'}<br/>{'favorite': 'True', 'title': 'Dinner for SCHMUCKS'}</span></pre><h2 id="ca14" class="mp mq iq bd mw nr ns dn na nt nu dp ne lf nv nw ng lj nx ny ni ln nz oa nk ob bi translated">修改 XML</h2><p id="482e" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">早些时候，电影的名字是绝对的混乱。现在，再把它们打印出来:</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="02b5" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">for movie in root.iter('movie'):<br/>    print(movie.attrib)</strong></span><span id="c420" class="mp mq iq mf b gy oc ms l mt mu">{'favorite': 'True', 'title': 'Indiana Jones: The raiders of the lost Ark'}<br/>{'favorite': 'True', 'title': 'THE KARATE KID'}<br/>{'favorite': 'False', 'title': 'Back 2 the Future'}<br/>{'favorite': 'False', 'title': 'X-Men'}<br/>{'favorite': 'True', 'title': 'Batman Returns'}<br/>{'favorite': 'False', 'title': 'Reservoir Dogs'}<br/>{'favorite': 'False', 'title': 'ALIEN'}<br/>{'favorite': 'True', 'title': "Ferris Bueller's Day Off"}<br/>{'favorite': 'FALSE', 'title': 'American Psycho'}<br/>{'favorite': 'False', 'title': 'Batman: The Movie'}<br/>{'favorite': 'True', 'title': 'Easy A'}<br/>{'favorite': 'True', 'title': 'Dinner for SCHMUCKS'}<br/>{'favorite': 'False', 'title': 'Ghostbusters'}<br/>{'favorite': 'True', 'title': 'Robin Hood: Prince of Thieves'}</span></pre><p id="a486" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在未来修正后面 2 中的 2。这应该是一个查找和替换的问题。编写代码以找到标题“Back 2 the Future”并将其保存为变量:</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="c6c5" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">b2tf = root.find("./genre/decade/movie[@title='Back 2 the Future']")<br/>print(b2tf)</strong></span><span id="d66c" class="mp mq iq mf b gy oc ms l mt mu">&lt;Element 'movie' at 0x10ce00ef8&gt;</span></pre><p id="9c26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，使用<code class="fe mc md me mf b">.find()</code>方法返回树的一个元素。很多时候，编辑元素中的内容更有用。</p><p id="6532" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将 Back 2 未来元素变量的<code class="fe mc md me mf b">title</code>属性修改为“回到未来”。然后，打印出变量的属性以查看您的更改。通过访问元素的属性，然后给它分配一个新值，可以很容易地做到这一点:</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="be89" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">b2tf.attrib["title"] = "Back to the Future"<br/>print(b2tf.attrib)</strong></span><span id="02af" class="mp mq iq mf b gy oc ms l mt mu">{'favorite': 'False', 'title': 'Back to the Future'}</span></pre><p id="b7b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将您的更改写回 XML，以便它们在文档中永久固定。再次打印出您的电影属性，以确保您的更改生效。使用<code class="fe mc md me mf b">.write()</code>方法来做这件事:</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="c04c" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">tree.write("movies.xml")</strong></span><span id="6566" class="mp mq iq mf b gy oc ms l mt mu"><strong class="mf ir">tree = ET.parse('movies.xml')<br/>root = tree.getroot()</strong></span><span id="250a" class="mp mq iq mf b gy oc ms l mt mu"><strong class="mf ir">for movie in root.iter('movie'):<br/>    print(movie.attrib)</strong></span><span id="4126" class="mp mq iq mf b gy oc ms l mt mu">{'favorite': 'True', 'title': 'Indiana Jones: The raiders of the lost Ark'}<br/>{'favorite': 'True', 'title': 'THE KARATE KID'}<br/>{'favorite': 'False', 'title': 'Back to the Future'}<br/>{'favorite': 'False', 'title': 'X-Men'}<br/>{'favorite': 'True', 'title': 'Batman Returns'}<br/>{'favorite': 'False', 'title': 'Reservoir Dogs'}<br/>{'favorite': 'False', 'title': 'ALIEN'}<br/>{'favorite': 'True', 'title': "Ferris Bueller's Day Off"}<br/>{'favorite': 'FALSE', 'title': 'American Psycho'}<br/>{'favorite': 'False', 'title': 'Batman: The Movie'}<br/>{'favorite': 'True', 'title': 'Easy A'}<br/>{'favorite': 'True', 'title': 'Dinner for SCHMUCKS'}<br/>{'favorite': 'False', 'title': 'Ghostbusters'}<br/>{'favorite': 'True', 'title': 'Robin Hood: Prince of Thieves'}</span></pre><h2 id="9f3b" class="mp mq iq bd mw nr ns dn na nt nu dp ne lf nv nw ng lj nx ny ni ln nz oa nk ob bi translated">修复属性</h2><p id="4d4d" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated"><code class="fe mc md me mf b">multiple</code>属性有些地方不正确。使用<code class="fe mc md me mf b">ElementTree</code>根据电影的格式来固定指示器。首先，打印<code class="fe mc md me mf b">format</code>属性和文本，看看哪些部分需要修复。</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="7cf9" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">for form in root.findall("./genre/decade/movie/format"):<br/>    print(form.attrib, form.text)</strong></span><span id="01df" class="mp mq iq mf b gy oc ms l mt mu">{'multiple': 'No'} DVD<br/>{'multiple': 'Yes'} DVD,Online<br/>{'multiple': 'False'} Blu-ray<br/>{'multiple': 'Yes'} dvd, digital<br/>{'multiple': 'No'} VHS<br/>{'multiple': 'No'} Online<br/>{'multiple': 'Yes'} DVD<br/>{'multiple': 'No'} DVD<br/>{'multiple': 'No'} blue-ray<br/>{'multiple': 'Yes'} DVD,VHS<br/>{'multiple': 'No'} DVD<br/>{'multiple': 'Yes'} DVD,digital,Netflix<br/>{'multiple': 'No'} Online,VHS<br/>{'multiple': 'No'} Blu_Ray</span></pre><p id="282a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个标签需要做一些工作。</p><p id="faac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用正则表达式来查找逗号——这将告诉您<code class="fe mc md me mf b">multiple</code>属性应该是“是”还是“否”。使用<code class="fe mc md me mf b">.set()</code>方法可以很容易地添加和修改属性。</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="9397" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">import re</strong></span><span id="50a4" class="mp mq iq mf b gy oc ms l mt mu"><strong class="mf ir">for form in root.findall("./genre/decade/movie/format"):<br/>    # Search for the commas in the format text<br/>    match = re.search(',',form.text)<br/>    if match:<br/>        form.set('multiple','Yes')<br/>    else:<br/>        form.set('multiple','No')</strong></span><span id="da68" class="mp mq iq mf b gy oc ms l mt mu"><strong class="mf ir"># Write out the tree to the file again<br/>tree.write("movies.xml")</strong></span><span id="efa3" class="mp mq iq mf b gy oc ms l mt mu"><strong class="mf ir">tree = ET.parse('movies.xml')<br/>root = tree.getroot()</strong></span><span id="a663" class="mp mq iq mf b gy oc ms l mt mu"><strong class="mf ir">for form in root.findall("./genre/decade/movie/format"):<br/>    print(form.attrib, form.text)</strong></span><span id="b7d7" class="mp mq iq mf b gy oc ms l mt mu">{'multiple': 'No'} DVD<br/>{'multiple': 'Yes'} DVD,Online<br/>{'multiple': 'No'} Blu-ray<br/>{'multiple': 'Yes'} dvd, digital<br/>{'multiple': 'No'} VHS<br/>{'multiple': 'No'} Online<br/>{'multiple': 'No'} DVD<br/>{'multiple': 'No'} DVD<br/>{'multiple': 'No'} blue-ray<br/>{'multiple': 'Yes'} DVD,VHS<br/>{'multiple': 'No'} DVD<br/>{'multiple': 'Yes'} DVD,digital,Netflix<br/>{'multiple': 'Yes'} Online,VHS<br/>{'multiple': 'No'} Blu_Ray</span></pre><h2 id="4cca" class="mp mq iq bd mw nr ns dn na nt nu dp ne lf nv nw ng lj nx ny ni ln nz oa nk ob bi translated">移动元素</h2><p id="5a90" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">一些数据被放在了错误的年代。使用你所学到的关于 XML 和<code class="fe mc md me mf b">ElementTree</code>的知识来查找和修复十年数据错误。</p><p id="9da5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在整个文档中打印出<code class="fe mc md me mf b">decade</code>标签和<code class="fe mc md me mf b">year</code>标签将会很有用。</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="5d29" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">for decade in root.findall("./genre/decade"):<br/>    print(decade.attrib)<br/>    for year in decade.findall("./movie/year"):<br/>        print(year.text)</strong></span><span id="0bc4" class="mp mq iq mf b gy oc ms l mt mu">{'years': '1980s'}<br/>1981 <br/>1984 <br/>1985 <br/>{'years': '1990s'}<br/>2000 <br/>1992 <br/>1992 <!-- --> <br/>{'years': '1970s'}<br/>1979 <br/>{'years': '1980s'}<br/>1986 <br/>2000 <br/>{'years': '1960s'}<br/>1966 <br/>{'years': '2010s'}<br/>2010 <br/>2011 <br/>{'years': '1980s'}<br/>1984 <br/>{'years': '1990s'}<br/>1991</span></pre><p id="c3a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两年是错误的十年，是 2000 年代的电影。使用 XPath 表达式找出这些电影是什么。</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="cf3b" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">for movie in root.findall("./genre/decade/movie/[year='2000']"):<br/>    print(movie.attrib)</strong></span><span id="2825" class="mp mq iq mf b gy oc ms l mt mu">{'favorite': 'False', 'title': 'X-Men'}<br/>{'favorite': 'FALSE', 'title': 'American Psycho'}</span></pre><p id="f6c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了转移 x 战警的数据，你必须在动作片中添加一个新的十年标签，即 2000 年代。可以使用<code class="fe mc md me mf b">.SubElement()</code>方法将这个标签添加到 XML 的末尾。</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="c5a1" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">action = root.find("./genre[@category='Action']")<br/>new_dec = ET.SubElement(action, 'decade')<br/>new_dec.attrib["years"] = '2000s'</strong></span></pre><p id="f811" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在分别使用<code class="fe mc md me mf b">.append()</code>和<code class="fe mc md me mf b">.remove()</code>将 x 战警电影添加到 2000 年代，并将其从 20 世纪 90 年代删除。</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="fa59" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">xmen = root.find("./genre/decade/movie[@title='X-Men']")<br/>dec2000s = root.find("./genre[@category='Action']/decade[@years='2000s']")<br/>dec2000s.append(xmen)<br/>dec1990s = root.find("./genre[@category='Action']/decade[@years='1990s']")<br/>dec1990s.remove(xmen)</strong></span></pre><h2 id="0103" class="mp mq iq bd mw nr ns dn na nt nu dp ne lf nv nw ng lj nx ny ni ln nz oa nk ob bi translated">构建 XML 文档</h2><p id="52b5" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">很好，所以你可以把整部电影推进到一个新的十年。将您的更改保存回 XML。</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="8823" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">tree.write("movies.xml")</strong></span><span id="53bf" class="mp mq iq mf b gy oc ms l mt mu"><strong class="mf ir">tree = ET.parse('movies.xml')<br/>root = tree.getroot()</strong></span><span id="4032" class="mp mq iq mf b gy oc ms l mt mu"><strong class="mf ir">print(ET.tostring(root, encoding='utf8').decode('utf8'))</strong></span></pre><h1 id="df73" class="mv mq iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">结论</h1><p id="bc46" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated"><em class="mb"> ElementTree </em>是一个重要的 Python 库，允许您解析和导航 XML 文档。使用 ElementTree 将 XML 文档分解成一个易于使用的树结构。如果有疑问，打印出来(<code class="fe mc md me mf b">print(ET.tostring(root, encoding='utf8').decode('utf8'))</code>)——使用这个有用的 print 语句一次性查看整个 XML 文档。</p><h1 id="4c54" class="mv mq iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated"><em class="od">参考文献</em></h1><ul class=""><li id="51e1" class="ls lt iq ky b kz nm lc nn lf oe lj of ln og lr lx ly lz ma bi translated">斯蒂芬·豪森发布的原始帖子:<a class="ae kv" href="https://www.datacamp.com/community/tutorials/python-xml-elementtree#intro" rel="noopener ugc nofollow" target="_blank">数据营</a></li><li id="8f1b" class="ls lt iq ky b kz mg lc mh lf mi lj mj ln mk lr lx ly lz ma bi translated">Python 3 文档:<a class="ae kv" href="https://docs.python.org/3.5/library/xml.etree.elementtree.html" rel="noopener ugc nofollow" target="_blank">元素树</a></li><li id="6772" class="ls lt iq ky b kz mg lc mh lf mi lj mj ln mk lr lx ly lz ma bi translated">维基百科:<a class="ae kv" href="https://en.wikipedia.org/wiki/XML" rel="noopener ugc nofollow" target="_blank"> XML </a></li></ul></div></div>    
</body>
</html>