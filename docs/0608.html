<html>
<head>
<title>Are UUIDs really unique?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">UUIDs 真的唯一吗？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/are-uuids-really-unique-57eb80fc2a87?source=collection_archive---------0-----------------------#2017-05-28">https://towardsdatascience.com/are-uuids-really-unique-57eb80fc2a87?source=collection_archive---------0-----------------------#2017-05-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7ba5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">UUID 一般代表<strong class="jp ir">u</strong>u<strong class="jp ir">u</strong>nique<strong class="jp ir">id</strong>标识符。它看起来像由破折号分隔的 32 个字符的字母和数字序列。一些例子:</p><p id="c445" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">8 f14 a65f-3032-42 c8-a196-1 cf 66d 11 b 930</p><p id="d63b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">b 400 af 61-6cb 4-4565-89 C4-d6ba 43 f 948 b 7</p><p id="32e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">UUIDs 便于给实体起自己的特殊名称，例如在数据库中。有几种方法可以生成它们，包括基于时间、MAC 地址、哈希和随机数的方法，但它们都做出了相同的承诺:没有两个是相同的。每一个在空间和时间上都是独一无二的。</p><p id="edcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">直觉上，这似乎不对。如果 UUIDs 是随机生成的，那么一定有<em class="kl">某种</em>的机会，一个序列被生成不止一次，特别是当我们生成越来越多的时候。让我们计算在一组 UUIDs 中没有重复的概率。</p><p id="1a7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">UUID 的 32 个字符是十六进制的，或以 16 为基数的表示法。每个字符可以是数字 0 到 9，或者是字母 a 到 f。在 UUID 中，32 个十六进制 x log2(16)位/十六进制= 128 位。在版本 4，变体 1 类型的 UUID 中，6 个比特是固定的，剩余的 122 个比特是随机生成的，总共有 2 个可能的 uuid。我们将这个值称为<em class="kl"> n </em>。我们马上知道，如果生成的 uuid 的数量超过了可能的 uuid 的空间，即如果<em class="kl"> r </em> &gt; <em class="kl"> n </em>，那么一定有一些重复。</p><p id="2075" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无重复的方式数为<em class="kl">n</em>*(<em class="kl">n</em>-1)*(<em class="kl">n</em>-2)*……(<em class="kl">n</em>-(<em class="kl">r-</em>1)。第一个 UUID 可以是<em class="kl"> n </em>种可能性中的任意一种，第二个可以是除第一个之外的<em class="kl"> n </em>中的任意一种(<em class="kl"> n </em> -1)，第三个可以是除前两个之外的任意一种(<em class="kl"> n </em> -2)，以此类推。生成<em class="kl">r</em>uuid 的方式总数是<em class="kl"> n^r </em>，因为每个<em class="kl">r</em>uuid 有<em class="kl"> n </em>种不同的可能性。将两个计数相除，得到没有重复 UUIDs 的概率:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/b1f3a4c63aae6192f380aae498eee939.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*URlNnxv6kAxK7D2SDkzYgg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Probability of generating r unique UUIDs</figcaption></figure><p id="4fef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于如此大的数量，直接计算概率在计算上是不可行的。大阶乘可以通过<a class="ae ky" href="https://en.wikipedia.org/wiki/Stirling%27s_approximation" rel="noopener ugc nofollow" target="_blank">斯特林公式</a>来近似，给出:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/70f0c4a4efe72b40db7e60a8d4e5a990.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*dJ34Hv00Hnete4_xu_cheA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Approximate probability of generating r unique UUIDs</figcaption></figure><p id="8c93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果 r 固定且 n →∞，则上述等式的第一部分可表示为:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi la"><img src="../Images/e43798e0ef4c172c466a4847f78599ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IwYbMZeh96iCrrha7_fAMg.png"/></div></div></figure><p id="cef0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">乘以第二部分，乘积为 1。因此如果<em class="kl"> n </em> ≫ <em class="kl"> r </em>几乎可以肯定不会有重复。但是如果<em class="kl"> r </em>确实接近<em class="kl"> n </em>，UUID 可能会重复。</p><p id="2253" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">r 到底应该有多大？我们可以从不同的角度来处理这个问题，这里我们不是从<em class="kl"> n </em>和<em class="kl"> r </em>开始，并试图计算<em class="kl"> p，</em>而是从<em class="kl"> n </em>和<em class="kl"> p </em>开始，并得到<em class="kl"> r </em>。下面的图表显示了给定唯一性概率下 UUIDs 的大致数量。它的值是用维基百科引用的一篇<a class="ae ky" href="https://en.wikipedia.org/wiki/Universally_unique_identifier#cite_note-14" rel="noopener ugc nofollow" target="_blank">论文的近似公式计算出来的，其中<em class="kl">r</em>= . 5+sqrt(. 25–2 * ln(p)*<em class="kl">n</em>)。</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi lf"><img src="../Images/c7d3331ca95d68d0f66c5773736872e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nAyhwGzJghFJRfFm5pykYA.png"/></div></div></figure><p id="5cbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.26 * 10⁶uuid 的样本有 99.99%的可能性没有任何重复。以每秒一个的速度生成这么多 UUIDs 需要十亿年。因此，虽然 UUIDs 并不是真正唯一的，但考虑到人类寿命的自然限制和系统的分离，它们对于实际用途来说是足够唯一的。</p></div></div>    
</body>
</html>