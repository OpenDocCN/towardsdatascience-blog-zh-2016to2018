<html>
<head>
<title>The beauty of column-oriented data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向列的数据之美</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-beauty-of-column-oriented-data-2945c0c9f560?source=collection_archive---------2-----------------------#2017-10-20">https://towardsdatascience.com/the-beauty-of-column-oriented-data-2945c0c9f560?source=collection_archive---------2-----------------------#2017-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/76a9a884bd42162327270316f82c1367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6bcLOwL0f53xx95ZEKQP-w.jpeg"/></div></div></figure><div class=""/><p id="4a0f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们考虑数据集时，我们自然会想到基于行的形式，其中行是一个条目，列是条目的某个属性。</p><p id="257d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，我又变得太抽象了，抱歉。我们举个例子。看看 JSON 中聊天历史的简单表示:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="6937" class="lf lg jb lb b gy lh li l lj lk">[<br/>  {<br/>    "message": "Hi Bob. How are you?",<br/>    "timestamp": 1508423069,<br/>    "senderId": 238476,<br/>    "seen": true<br/>  },{<br/>    "message": "This is Alex.",<br/>    "timestamp": 1508423226,<br/>    "senderId": 238476,<br/>    "seen": true<br/>  },{<br/>    "message": "Hi Alex. I am fine. How are you?",<br/>    "timestamp": 1508423238,<br/>    "senderId": 9837498,<br/>    "seen": false<br/>  }<br/>]</span></pre><p id="23d4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们看到两个参与者之间的三条消息。消息对象是一行，消息的属性可以看作是列。这种表现方式对我们来说是很自然的，这是数据产生的方式，也是我们存储数据的方式。</p><p id="534f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们尝试一些东西，让我们旋转表示:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="6c4d" class="lf lg jb lb b gy lh li l lj lk">{<br/>  "messages": ["Hi Bob. How are you?", "This is Alex.", "Hi Alex. I am fine. How are you?"],<br/>  "timestamps": [1508423069, 1508423226, 1508423238],<br/>  "senderId": [238476, 238476, 9837498],<br/>  "seen": [true, true, false]<br/>}</span></pre><p id="9826" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个 JSON 中，我们有一个面向列的表示。我们的 JSON 不再是对象的数组，它变成了数组的对象。这意味着，如果我们需要得到第二条消息，我们做类似于<code class="fe ll lm ln lb b">o["messages"][2]</code>而不是<code class="fe ll lm ln lb b">o[2]["message"]</code>的事情。</p><p id="7d0c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，我们就不需要重复属性名，从而使大小减少了大约 30%。可悲的是，当谈到 JSON 时，这是关于它的好处🙃。但是让我们以不同的形式来检查相同的数据。让我们看看 CSV 文件形式的相同聊天记录。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="7a54" class="lf lg jb lb b gy lh li l lj lk">Hi Bob. How are you?,1508423069,238476,true<br/>This is Alex.,1508423226,238476,true<br/>Hi Alex. I am fine. How are you?,1508423238,9837498,false</span></pre><h2 id="e85f" class="lf lg jb bd lo lp lq dn lr ls lt dp lu kj lv lw lx kn ly lz ma kr mb mc md me bi translated">和...相对</h2><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="a82f" class="lf lg jb lb b gy lh li l lj lk">Hi Bob. How are you?,This is Alex.,Hi Alex. I am fine. How are you?<br/>1508423069,1508423226,1508423238<br/>238476,238476,9837498<br/>true,true,false</span></pre><p id="d42b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在 CSV 中，当我们旋转表示时，尺寸没有增加。字符的数量保持不变，但我们获得了另一个有趣的好处。假设我们想要查找包含字符串“Alex”的每封邮件。面向列的 CSV 中的简单消息字符串搜索可能如下所示:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="b2e5" class="lf lg jb lb b gy lh li l lj lk">var index = 0<br/>var result: Set&lt;Int&gt; = []</span><span id="0635" class="lf lg jb lb b gy mf li l lj lk">for (c1, pos1) in fileContent.enumerated {<br/>  var found = true</span><span id="c257" class="lf lg jb lb b gy mf li l lj lk">  for (c2, pos2) in searchPattern.enumerated {<br/>    if fileContent[pos1+pos2] != c2 { found = false; break }<br/>  }<br/>  if found {<br/>    result.append(index)<br/>  } else {<br/>    if c1 == "," {<br/>      index += 1<br/>    } else if c1 == "\n" {<br/>      break<br/>    }<br/>  }<br/>}</span></pre><p id="76ae" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个伪 Swift 代码应该可视化，在面向列的 CSV 的情况下，线性搜索被限制在第一个文本行，我们不必考虑其他行，因为我们知道消息文本被一起放在第一行。因此，搜索的最差性能是第一行的长度乘以搜索模式的长度。相反，如果数据是基于行的，最差的性能是整个文件内容的长度乘以搜索模式的长度。我们可以实现不那么简单的算法，但是它会更复杂，并且仍然具有更差的最坏情况性能，因为你不能扫描所有的字符。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="fbfd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们考虑二进制表示。在二进制中，我们可以从面向列的数据中获益更多。重复相同类型的数据使对齐变得简单。<strong class="ka jc">等等你说的对齐是什么意思？</strong></p><p id="140f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">维基百科上有一篇文章“<a class="ae mn" href="https://en.wikipedia.org/wiki/Data_structure_alignment" rel="noopener ugc nofollow" target="_blank">数据结构对齐</a>”你可以读一下，跳过下一段。或者如果你对我的解释更感兴趣，我会这样解释:</p><p id="da1f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">CPU 以 8、16、32、64 或 128 位的“块”访问内存，这取决于 CPU 的类型。假设我们有一个以 64 位= 8 字节“块”读取的 CPU。要求 CPU 转到地址 7 并读取 1 个字节是可以的，因为 CPU 实际上会从地址 0 到 8 读取数据，并给你第 7 个字节。然而，如果你要求 CPU 从地址 7 开始读取 2 个字节，你就做错了。最好的情况是您得到一个<a class="ae mn" href="https://en.wikipedia.org/wiki/Segmentation_fault" rel="noopener ugc nofollow" target="_blank">分段故障</a>，它可以通过从地址 0 到 7，然后从地址 8 到 15 加载数据来处理。最坏的情况，它变成了一个<a class="ae mn" href="https://en.wikipedia.org/wiki/Bus_error" rel="noopener ugc nofollow" target="_blank">总线错误</a>，或者未处理的<a class="ae mn" href="https://en.wikipedia.org/wiki/Segmentation_fault" rel="noopener ugc nofollow" target="_blank">分段错误</a>，导致你的应用程序崩溃。这就是数据应该对齐的原因。在我们的例子中，如果我们有一个以 8 字节“块”读取的 CPU，我们需要存储 2 字节，我们可以存储它的地址应该是<code class="fe ll lm ln lb b">n % 8 &lt;= 6</code>。</p><p id="4484" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你认为内存对齐是一个非常深奥的话题，那你就错了。看看下面两个结构:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="7fa2" class="lf lg jb lb b gy lh li l lj lk">struct S1 {<br/> let a: Bool<br/> let b: Int64<br/> let c: Bool<br/> let d: Int64<br/> let e: Bool<br/>}</span><span id="9ab2" class="lf lg jb lb b gy mf li l lj lk">struct S2 {<br/> let b: Int64<br/> let d: Int64<br/> let a: Bool<br/> let c: Bool<br/> let e: Bool<br/>}</span></pre><p id="bf85" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">struct <code class="fe ll lm ln lb b">S1</code>的一个实例将被存储在 40 个字节中，但是<code class="fe ll lm ln lb b">S2</code>只需要 24 个字节，即使它们存储相同的信息。结构<code class="fe ll lm ln lb b">S1</code>需要在属性<code class="fe ll lm ln lb b">a</code>和<code class="fe ll lm ln lb b">b</code>之间填充 7 个字节，因为我们不能从地址 1 开始读取 8 个字节。这同样适用于属性<code class="fe ll lm ln lb b">c</code>和<code class="fe ll lm ln lb b">d</code>，为了以防万一，我们必须在属性<code class="fe ll lm ln lb b">e</code>后放置 7 位填充符——因为我们不知道在<code class="fe ll lm ln lb b">S1</code>后将存储什么类型的数据。在<code class="fe ll lm ln lb b">S2</code>的情况下，我们只需要在属性<code class="fe ll lm ln lb b">e</code>后填充 5 个字节。</p><p id="817e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我说你<em class="mo">有点</em>错了，因为大部分人都不在乎这样的内存浪费。他们与<strong class="ka jc"> <em class="mo">【内存廉价】</em> </strong>争论。我将让您自己决定，在您的用例中，您可以允许多少内存浪费。然而，当我们谈论数据存储和加载时，我认为我们有责任将不必要的内存浪费降到最低。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="dd19" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们再次以聊天历史为例，将其作为二进制结构来研究。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="1a33" class="lf lg jb lb b gy lh li l lj lk">Hi Bob. How are you?\0|1508423069|238476|true</span></pre><p id="c385" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们想将消息保存为 UTF8 字符数组，用<code class="fe ll lm ln lb b">0</code>作为字符串终止标志。时间戳将是一个 8 字节的单位。发送者 id 也是一个 8 字节的 uint，seen 标志是一个 1 字节的 bool 值。如果我们保持顺序不变，我们将不得不在消息中添加填充，因为时间戳是 8 个字节。因此应该从地址<code class="fe ll lm ln lb b">n % 8 == 0</code>开始。因此，为了减少内存浪费，我们将存储如下条目</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="e58b" class="lf lg jb lb b gy lh li l lj lk">1508423069|238476|true|Hi Bob. How are you?\0</span></pre><p id="e3da" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很好，但是当我们存储许多条目时会发生什么呢</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="4524" class="lf lg jb lb b gy lh li l lj lk">1508423069|238476|true|Hi Bob. How are you?\0<br/>1508423226|238476|true|This is Alex.\0<br/>1508423238|9837498|false|Hi Alex. I am fine. How are you?\0</span></pre><p id="0977" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们仍然需要在文本的末尾添加填充，因为下一个条目需要从地址<code class="fe ll lm ln lb b">n % 8 == 0</code>开始。因此，在最坏的情况下，我们将有 7 乘以条目数作为内存浪费。</p><p id="9dcb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看看面向列的表示:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="3cd1" class="lf lg jb lb b gy lh li l lj lk">1508423069|1508423226|1508423238<br/>238476|238476|9837498<br/>true|true|false<br/>Hi Bob. How are you?\0|This is Alex.\0|Hi Alex. I am fine. How are you?\0</span></pre><p id="d4be" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这样的表示，我们仍然应该在消息的末尾添加填充符——以防万一。通过这种方式，丢失了多达 7 个字节(不是每个条目，总共)，但我们也可以将 3 个 bool 值作为一个<a class="ae mn" href="https://en.wikipedia.org/wiki/Bit_array" rel="noopener ugc nofollow" target="_blank">位数组</a>存储在仅 1 个字节中，并在每个 bool 条目上获得 2 个字节或实际上是<code class="fe ll lm ln lb b">floor(n — (n / 8))</code>个字节。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="b1c8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能想知道为什么我们在连接字符串时不需要关心内存对齐。我假设我们存储的是 UTF8 编码的字符串，这意味着一个文本基本上是一个 1 字节字符的数组。当将一个 UTF8 字符串加载到内存(String class/struct)时，我们一个字节一个字节地加载数据，并将其放入一个单独的缓冲区。加载单个字节不会导致任何问题。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="ef99" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们看到以面向列的方式存储数据可以带来关于<em class="mo">字节打包的好处。</em>然而事实并非如此。我们在搜索方面获得了与 CSV 部分所述相同的好处。我们可以走得更远。二进制的时间戳被描述为一个 8 字节的单位。如果我们有一个固定大小的数据，我们知道它从哪里开始，我们有多少个条目，这是很容易实现随机存取:<code class="fe ll lm ln lb b">start + (size * index)</code>。对于聊天历史，时间戳值按升序排序。如果我们有一个排序的数组，我们可以通过使用二分搜索法找到值甚至范围。这意味着查找在特定时间范围内发送的消息将非常有效。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="58eb" class="lf lg jb bd lo lp lq dn lr ls lt dp lu kj lv lw lx kn ly lz ma kr mb mc md me bi translated">所以你是说，面向列的数据表示是一个完美的解决方案？</h2><p id="c4d9" class="pw-post-body-paragraph jy jz jb ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">哦，不！🙃</p><p id="0a8f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是通过字节打包或避免重复来减小大小的一个非常好的解决方案。如果你需要迭代所有条目的一个属性，这也是一个很好的解决方案，比如当你搜索的时候。然而，如果您需要处理同一个条目的多个属性——比如您想在 UI 中显示消息，那么这并不是最佳选择。在这种情况下，我们必须从许多不同的列中提取行属性。</p><p id="7e12" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在 CSV(和其他基于文本的格式)的情况下，这是非常糟糕的。我说的是纯粹的 CSV 数据，没有将它吸收到一些中间数据结构中。基于文本的格式不支持随机值访问，我们需要进行扫描，以确定该列中的哪个值属于“第三”行。</p><p id="7ab2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像 FlexBuffers 和 ByteCabinet(我目前正在开发的一种格式)这样的二进制格式可以支持随机值访问。在这种情况下，从多个列中检索数据是合理的，但是没有打包在一起的数据快。如果您对原因感兴趣，请查看<a class="ae mn" href="https://en.wikipedia.org/wiki/Locality_of_reference" rel="noopener ugc nofollow" target="_blank">参考位置</a>文章。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="679c" class="lf lg jb bd lo lp lq dn lr ls lt dp lu kj lv lw lx kn ly lz ma kr mb mc md me bi translated">所以你是说，我不应该对 UI 使用面向列的数据表示？</h2><p id="c539" class="pw-post-body-paragraph jy jz jb ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">哦，不！🙃🙃</p><p id="5ff6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你需要考虑你的用例。如果您有一个支持随机访问的面向列的数据表示，并且您有一个向用户显示几十行的列表。这不是问题。您可以遍历<strong class="ka jc"> X </strong>列(属性数)并读取<strong class="ka jc"> Y </strong>条目(行数)。您将不得不在内存中跳来跳去，并且可能会产生缓存未命中，但是您只会对几十个条目这样做，UX 不会受到影响。然而，如果你需要为用户提供一个搜索，你需要浏览你所有的数据，你有数以千计，甚至数百万计的条目。从 UX 的角度来看，加载不需要的数据和 CPU 缓存缺失是非常明显的。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="b6ad" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">意识到这一点是令人难过的，但是当涉及到软件开发或任何其他现实世界的问题时，没有什么灵丹妙药。本文不应该赞扬面向列的数据表示，它应该展示它的存在、美丽以及它在某些用例中提供的好处。非常感谢你坚持和我讨论这个无聊的话题。如果你愿意，你可以鼓掌。</p></div></div>    
</body>
</html>