<html>
<head>
<title>Machine learning in Clojure with XGBoost and clj-boost</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 XGBoost 和 clj-boost 在 Clojure 中进行机器学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-clojure-xgboost-clj-boost-e0d1339df1e1?source=collection_archive---------13-----------------------#2018-12-03">https://towardsdatascience.com/machine-learning-clojure-xgboost-clj-boost-e0d1339df1e1?source=collection_archive---------13-----------------------#2018-12-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d039" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">机器学习+ REPL = ❤</h2></div><blockquote class="kf kg kh"><p id="1c96" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">Clojure 这是一个<a class="ae lf" href="https://en.wikipedia.org/wiki/Lisp_(programming_language)" rel="noopener ugc nofollow" target="_blank"> LISP </a>。所以作为一个 LISP，它有很多括号。既然我们已经把那件事一吐为快，我们可以继续谈论更严肃的事情了。</p></blockquote><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/966a41195961c40fd4ae0cd32e856b5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*3AOKcFB_vJM5oTrS7VO1cw.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk"><em class="ls">Obligatory xkcd comic</em></figcaption></figure><h1 id="20c2" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">为什么是 Clojure？</h1><p id="565b" class="pw-post-body-paragraph ki kj iq kl b km ml jr ko kp mm ju kr mn mo ku kv mp mq ky kz mr ms lc ld le ij bi translated">你可能从来没有听说过<strong class="kl ir"> Clojure </strong>，更不用说数据科学和机器学习了。那么，为什么您会对使用它来做这些事情感兴趣呢？我来告诉你为什么:要让要紧的事(数据)<strong class="kl ir">一流</strong>！</p><p id="4138" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">在 Clojure 中我们不处理类、对象等等，一切都只是数据。而那个数据是<strong class="kl ir">不可变的</strong>。这意味着，如果您搞砸了您的转换，数据将是好的，您不必从头再来。</p><p id="5785" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">前一个只是我想到的原因之一，另一个可能是<a class="ae lf" href="https://en.wikipedia.org/wiki/Java_virtual_machine" rel="noopener ugc nofollow" target="_blank"> JVM </a>。是的，我们都在某种程度上讨厌它，但不要搞错:它自 1991 年开发以来，一直是<strong class="kl ir">生产级</strong>。这就是为什么全世界的企业仍然在 JVM 上运行和开发软件。考虑到这一点，Clojure 甚至可以被最保守的公司所接受，因为从根本上说，它是他们已经知道的东西。</p><p id="737d" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">我想说的第二点是 REPL。这不像通常的语言外壳(例如 Python REPL ),通常非常基础和烦人，但是它有<strong class="kl ir">超能力</strong>！去现场看看该服务在生产中发生了什么会很好吗？<a class="ae lf" href="https://github.com/nrepl/drawbridge" rel="noopener ugc nofollow" target="_blank">搞定！</a>你想要一个既能用于生产又能用于实验的绘图服务吗？<a class="ae lf" href="https://github.com/metasoarous/oz" rel="noopener ugc nofollow" target="_blank">搞定！</a>您是否碰巧有嵌套的数据结构，并且可视化地探索它们以更好地理解它们会很好？<a class="ae lf" href="https://github.com/eggsyntax/datawalk" rel="noopener ugc nofollow" target="_blank">搞定！</a></p><p id="4a4c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">这意味着你并不真的需要像 jupyter 笔记本这样的东西，尽管如果你在这样的环境中感觉更舒服，有一些选项可以无缝地工作:<a class="ae lf" href="https://github.com/clojupyter/clojupyter" rel="noopener ugc nofollow" target="_blank"> clojupyter </a>是用于 Jupyter 笔记本的 Clojure 内核，而<a class="ae lf" href="http://gorilla-repl.org/" rel="noopener ugc nofollow" target="_blank">大猩猩 REPL </a>是本地 Clojure 笔记本解决方案。</p><h1 id="0583" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">数据读取</h1><p id="bfc8" class="pw-post-body-paragraph ki kj iq kl b km ml jr ko kp mm ju kr mn mo ku kv mp mq ky kz mr ms lc ld le ij bi translated">如果你从未看过 Clojure 代码，或者如果你刚刚开始，我的建议是看一看<a class="ae lf" href="https://learnxinyminutes.com/docs/clojure/" rel="noopener ugc nofollow" target="_blank">在 Y 分钟内学会 clo jure</a>以便能够跟上这一点，那么当我开始学习时，我最喜欢的来源之一是<a class="ae lf" href="https://www.braveclojure.com/" rel="noopener ugc nofollow" target="_blank">clo jure for the Brave and True</a>。无论如何，我会仔细解释代码中的每一步，这样每个人都可以很容易地理解。</p><p id="e5f5" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">这只是一个介绍，所以我们将使用臭名昭著的<a class="ae lf" href="https://archive.ics.uci.edu/ml/datasets/iris" rel="noopener ugc nofollow" target="_blank">虹膜数据集</a>。如果你还没有<a class="ae lf" href="https://leiningen.org/" rel="noopener ugc nofollow" target="_blank"> Leiningen </a>获取并安装它，它真的很容易使用，并且是 Clojure 事实上的构建工具。现在，您可以通过启动以下命令从命令行创建一个新的项目框架:</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="9b3d" class="my lu iq mu b gy mz na l nb nc">lein new clj-boost-demo<br/>cd clj-boost-demo</span></pre><p id="7bde" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">您应该具有如下所示的目录结构:</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="768f" class="my lu iq mu b gy mz na l nb nc">.<br/>├── CHANGELOG.md<br/>├── doc<br/>│   └── intro.md<br/>├── LICENSE<br/>├── project.clj<br/>├── README.md<br/>├── resources<br/>├── src<br/>│   └── clj_boost_demo<br/>│       └── core.clj<br/>└── test<br/>└── clj_boost_demo<br/>└── core_test.clj</span></pre><p id="76d0" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">我们最关心的文件是<code class="fe nd ne nf mu b">project.clj</code>，它是 Leiningen 正确准备和构建项目的基础，<code class="fe nd ne nf mu b">src</code>是我们放置应用程序或库的代码的地方，<code class="fe nd ne nf mu b">resources</code>是我们放置 Iris csv 文件的地方，您可以从这里的<a class="ae lf" href="https://raw.githubusercontent.com/uiuc-cse/data-fa14/gh-pages/data/iris.csv" rel="noopener ugc nofollow" target="_blank">获得</a>。现在我们可以定义<code class="fe nd ne nf mu b">project.clj</code>文件，这是 Clojure 的另一个“明智”之处:你必须<strong class="kl ir">显式声明</strong>库和版本，这总是一件好事。</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="da77" class="my lu iq mu b gy mz na l nb nc">(defproject clj-boost-demo "0.1.0-SNAPSHOT"<br/>  :description "FIXME: write description"<br/>  :url "http://example.com/FIXME"<br/>  :license {:name "Eclipse Public License"<br/>            :url "http://www.eclipse.org/legal/epl-v10.html"}<br/>  :dependencies [[org.clojure/clojure "1.9.0"]<br/>                 [org.clojure/data.csv "0.1.4"]<br/>                 [clj-boost "0.0.3"]])</span></pre><p id="6adf" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">如果我们保存<code class="fe nd ne nf mu b">project.clj</code>并在 shell 中启动<code class="fe nd ne nf mu b">lein run</code>，Leiningen 将获得所有需要的依赖项并启动一个 REPL。我们可以通过打开和修改<code class="fe nd ne nf mu b">src/clj-boost-demo/core.clj</code>文件进入数据加载和传输。我们会在那里找到一些占位符代码，我们可以去掉它，开始写我们的代码。</p><p id="933c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">在 Clojure 中，我们使用名称空间，通常一个文件包含一个定义导入的名称空间:</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="c3e6" class="my lu iq mu b gy mz na l nb nc">(ns clj-boost-demo.core<br/>  (:require [clj-boost.core :as boost]<br/>            [clojure.java.io :as io]<br/>            [clojure.data.csv :as csv]))</span><span id="ab0e" class="my lu iq mu b gy ng na l nb nc">(def iris-path "resources/iris.csv")</span></pre><p id="1e84" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">定义一个新的名称空间，从名称空间定义导入库是一个好的实践，就像我们在这里做的一样。<code class="fe nd ne nf mu b">:require</code>这是一个<strong class="kl ir">关键字</strong>，它本身就是 Clojure 中的一个类型，我们稍后会看到它们为什么重要，<code class="fe nd ne nf mu b">[clj-boost.core :as boost]</code>意味着我们想要使用<code class="fe nd ne nf mu b">clj-boost</code>库中的<code class="fe nd ne nf mu b">core</code>名称空间，但是我们想要用名称<code class="fe nd ne nf mu b">boost</code>引用它下面的所有名称。如果你懂 Python，这和做<code class="fe nd ne nf mu b">import library as lbr</code>是一样的。</p><p id="1115" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">使用<code class="fe nd ne nf mu b">def</code>,我们在当前名称空间中全局创建新的<strong class="kl ir">变量</strong>。在这种情况下，我们指向一个表示数据集所在路径的字符串。通常在 Clojure 中我们不会定义很多全局名，除了函数名。事实上,<code class="fe nd ne nf mu b">iris-path</code>将是我们在本演示中使用的唯一全球名称！</p><p id="6f64" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">为了读取 Iris csv，我们使用以下代码:</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="4c3a" class="my lu iq mu b gy mz na l nb nc">(defn generate-iris<br/>  [iris-path]<br/>  (with-open [reader (io/reader iris-path)]<br/>    (into []<br/>          (comp (drop 1) (map #(split-at 4 %)))<br/>          (csv/read-csv reader))))</span></pre><p id="5669" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">这段代码定义了(<code class="fe nd ne nf mu b">defn</code>)一个名为<code class="fe nd ne nf mu b">generate-iris</code>的函数，它将 Iris csv 的路径作为参数。然后我们在给定的路径下打开一个到文件的连接，当我们完成时这个连接将被关闭(<code class="fe nd ne nf mu b">with-open</code>)。当你在一个函数调用之后看到一个<strong class="kl ir">向量</strong>，它带有一个符号，后面跟着一些代码——<code class="fe nd ne nf mu b">[reader (io/reader iris-path)]</code>——这就是局部绑定。</p><p id="a469" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">本地绑定有助于避免混淆全局名称空间，并将代码执行分成微小的部分。在这种情况下，我们使用一个 Java 阅读器，确切地说是一个<code class="fe nd ne nf mu b">BufferedReader</code>，来打开和读取文件。如您所见，我们通过执行<code class="fe nd ne nf mu b">io/reader</code>来使用导入的<code class="fe nd ne nf mu b">clojure.java.io</code>名称空间，而<code class="fe nd ne nf mu b">name/</code>是访问驻留在导入的名称空间中的名称的语法。</p><p id="f8f3" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">下面的代码可能看起来有点深奥，但这只是习惯问题。让我们从 REPL 开始分解所有的步骤。</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="4ea6" class="my lu iq mu b gy mz na l nb nc">(with-open [reader (io/reader iris-path)] <br/>  (csv/read-csv reader)) <br/>;IOException Stream closed java.io.BufferedReader.ensureOpen</span></pre><p id="f2a1" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">上面的代码抛出一个错误，那是因为<code class="fe nd ne nf mu b">csv/read-csv</code>是<strong class="kl ir">懒</strong>。默认懒惰是 Clojure 的另一个特性:大部分 Clojure 函数不会返回任何东西，直到你需要那些值。如果你考虑一下，这很好:如果我们有一个非常大的文件，我们不必将它全部加载到内存中来处理它，但是我们可以逐行读取和处理它，同时将结果写入另一个文件。</p><p id="f0e9" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">为了使函数变得更有吸引力，我们可以使用<code class="fe nd ne nf mu b">doall</code>:</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="3eef" class="my lu iq mu b gy mz na l nb nc">(with-open [reader (io/reader iris-path)] <br/>  (doall (csv/read-csv reader))) <br/>;(["sepal_length" "sepal_width" "petal_length" "petal_width" "species"] <br/>; ["5.1" "3.5" "1.4" "0.2" "setosa"] <br/>; ["4.9" "3" "1.4" "0.2" "setosa"]...)</span></pre><p id="1c42" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">结果是包含字符串的<strong class="kl ir">向量</strong>的<strong class="kl ir">序列</strong>。序列是 Clojure 中最重要的数据结构之一:它们是懒惰的、不可变的，可以由任何其他 Clojure 数据结构产生。更多关于他们的信息，请查看官方 Clojure 文件。<strong class="kl ir">向量</strong>非常类似于 Python 列表，区别在于它们是持久的。</p><p id="2207" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">为了更好地理解<strong class="kl ir">不变性</strong>和<strong class="kl ir">持久性</strong>让我们尝试一个小实验:</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="9788" class="my lu iq mu b gy mz na l nb nc">(def a [1 2 3]) <br/>(println a) <br/>;[1 2 3] </span><span id="ad1f" class="my lu iq mu b gy ng na l nb nc">(conj a 4) <br/>;[1 2 3 4] </span><span id="690c" class="my lu iq mu b gy ng na l nb nc">(println a) <br/>;[1 2 3]</span></pre><p id="a1c7" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">正如你所看到的，我们创建了一个向量<code class="fe nd ne nf mu b">a</code>，然后<code class="fe nd ne nf mu b">conj</code>(向向量追加元素)4 到<code class="fe nd ne nf mu b">a</code>，结果是一个全新的数据结构，事实上<code class="fe nd ne nf mu b">a</code>仍然有初始值。</p><h1 id="2cb1" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">数据处理</h1><p id="623d" class="pw-post-body-paragraph ki kj iq kl b km ml jr ko kp mm ju kr mn mo ku kv mp mq ky kz mr ms lc ld le ij bi translated">在这种情况下，我们不再关心标题，因为<code class="fe nd ne nf mu b">"species"</code>列是我们想要预测的类，也是最后一个，所以我们可以立即开始处理原始数据。为了简化这个过程，我们定义了一个在 REPL 中使用的<code class="fe nd ne nf mu b">demo-reader</code>函数，并开始处理结果数据:</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="21f7" class="my lu iq mu b gy mz na l nb nc">(defn demo-reader [] <br/>  (with-open [reader (io/reader iris-path)] <br/>    (doall (csv/read-csv reader))))</span></pre><p id="0137" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">然后，我们将使用<strong class="kl ir">线程宏</strong>来逐步试验和应用转换:</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="bdc2" class="my lu iq mu b gy mz na l nb nc">(-&gt;&gt; (demo-reader) (take 3)) <br/>;(["sepal_length" "sepal_width" "petal_length" "petal_width" "species"] <br/>; ["5.1" "3.5" "1.4" "0.2" "setosa"] <br/>; ["4.9" "3" "1.4" "0.2" "setosa"])</span></pre><p id="f882" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">让我们将一个值作为后续函数的最后一个参数:你肯定还记得在学校时他们教过你，要求解 f(g(x))，你应该从求解 g(x)= x’开始，然后 f(x’)= x”。线程宏它只是语法糖，使代码更可读。</p><p id="e9eb" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">这里有一个简单的例子:</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="e892" class="my lu iq mu b gy mz na l nb nc">(inc 1) <br/>;2 </span><span id="6140" class="my lu iq mu b gy ng na l nb nc">(dec (inc 1)) <br/>;1 </span><span id="24ec" class="my lu iq mu b gy ng na l nb nc">(-&gt; 1 inc dec) <br/>;1</span></pre><p id="6399" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">我们<code class="fe nd ne nf mu b">inc</code>将<code class="fe nd ne nf mu b">1</code>加 1，然后<code class="fe nd ne nf mu b">(dec (inc 1))</code>表示<code class="fe nd ne nf mu b">inc</code>加<code class="fe nd ne nf mu b">1</code>，然后<code class="fe nd ne nf mu b">dec</code>将结果-2-加 1，得到 1。基本上，我们从右到左阅读来理解函数的应用顺序。使用<code class="fe nd ne nf mu b">(-&gt; 1 inc dec)</code>我们可以从左至右阅读操作。有关<strong class="kl ir">线程宏</strong>的更多信息，请查看<a class="ae lf" href="https://clojure.org/guides/threading_macros" rel="noopener ugc nofollow" target="_blank">官方 Clojure 文档</a>。</p><p id="36b9" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">回到<code class="fe nd ne nf mu b">(-&gt;&gt; (demo-reader) (take 3))</code>正如你看到的结果，我们只从 csv 中获得前 3 个向量。<code class="fe nd ne nf mu b">take</code>完全按照您的想法去做:它懒洋洋地从给定的集合中获取<code class="fe nd ne nf mu b">n</code>值。这在实验时非常有用，否则我们将不得不处理整个序列。</p><p id="13af" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">要从序列中删除标题，我们可以从结果中<code class="fe nd ne nf mu b">drop</code>第一行:</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="1670" class="my lu iq mu b gy mz na l nb nc">(-&gt;&gt; (demo-reader) (take 3) (drop 1)) <br/>;(["5.1" "3.5" "1.4" "0.2" "setosa"] <br/>; ["4.9" "3" "1.4" "0.2" "setosa"])</span></pre><p id="789d" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">现在，因为我们想把 X 值从 Y 值(我们想预测的类)中分离出来，所以最好一次完成。如果您来自 Python 或其他类似 C 语言的语言，您可能会尝试使用循环来做这件事，但是在 Clojure 中，我们做的事情不同。</p><p id="0803" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">使用<code class="fe nd ne nf mu b">map</code>,我们可以对集合中的所有值应用一个函数:</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="b530" class="my lu iq mu b gy mz na l nb nc">(map inc [1 2 3]) <br/>;(2 3 4)</span></pre><p id="1fcd" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">在这种情况下，我们想要分割值，猜猜看，有一个<code class="fe nd ne nf mu b">split-at</code>函数在等着我们！</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="5875" class="my lu iq mu b gy mz na l nb nc">(split-at 2 [1 2 3])<br/><em class="kk">;[(1 2) (3)]</em></span></pre><p id="356d" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">这正是我们所需要的，所以我们将定义一个匿名函数并在我们的向量上使用它:</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="5323" class="my lu iq mu b gy mz na l nb nc">(-&gt;&gt; (demo-reader) <br/>     (take 3) <br/>     (drop 1) <br/>     (map #(split-at 4 %))) <br/>;([("5.1" "3.5" "1.4" "0.2") ("setosa")] <br/>; [("4.9" "3" "1.4" "0.2") ("setosa")])</span></pre><p id="8b6a" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">为了定义命名函数，我们使用<code class="fe nd ne nf mu b">defn</code>，它是一个<strong class="kl ir">宏</strong>，让我们避免每次都输入<code class="fe nd ne nf mu b">(def my-func (fn [arg] "do something"))</code>，所以通过简单的<code class="fe nd ne nf mu b">(fn [arg] "I have no name")</code>，我们得到一个匿名函数。</p><p id="176e" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated"><code class="fe nd ne nf mu b">#(split-at 4 %)</code>是另一个和<code class="fe nd ne nf mu b">(fn [x] (split-at 4 x))</code>解析一样的简写，所以只是省打字的一种方式。</p><p id="384f" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">现在让我们通过使用<strong class="kl ir">传感器</strong>将所有东西放在一起。如同带有传感器的线程宏一样，我们将<strong class="kl ir">的</strong>函数组合在一起，但是传感器返回一个只传递一次数据的函数。如果它们一开始看起来有点晦涩，不要担心，我也花了一些时间来理解这个概念，我建议你仔细阅读这个写得非常好的关于传感器的系列文章。</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="aabf" class="my lu iq mu b gy mz na l nb nc">(def xf (comp (drop 1) (map #(split-at 4 %)))) </span><span id="e144" class="my lu iq mu b gy ng na l nb nc">(into [] xf [[1 2 3 4 5] [1 2 3 4 5]]) <br/>;[[(1 2 3 4) (5)]]</span></pre><p id="a3fa" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">使用<code class="fe nd ne nf mu b">comp</code>我们将函数组合在一起，只返回一个函数，而使用<code class="fe nd ne nf mu b">into</code>我们循环遍历一个集合，并将结果放入作为第一个参数给出的集合中。我喜欢这样来思考这个过程:这就像我们从一个集合中把<strong class="kl ir">个值拉到另一个集合中，但是当我们这么做的时候，我们对所有的值都应用了一个函数<code class="fe nd ne nf mu b">xf</code>。</strong></p><p id="6428" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">结果是我们开始的<code class="fe nd ne nf mu b">generate-iris</code>函数:</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="0a94" class="my lu iq mu b gy mz na l nb nc">(defn generate-iris<br/>  [iris-path]<br/>  (with-open [reader (io/reader iris-path)]<br/>    (into []<br/>          (comp (drop 1) (map #(split-at 4 %)))<br/>          (csv/read-csv reader))))</span></pre><p id="ae87" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">现在我们想从这个<code class="fe nd ne nf mu b">([("5.1" "3.5" "1.4" "0.2") ("setosa")] [("4.9" "3" "1.4" "0.2") ("setosa")])</code>转到我们能以更简单的方式处理的东西:<code class="fe nd ne nf mu b">([5.1 3.5 1.4 0.2 0] [4.9 3.0 1.4 0.2 0])</code>。基本上，我们将字符串解析成数字，并将类(<em class="kk"> setosa </em>、<em class="kk"> virginica </em>和<em class="kk"> versicolor </em>)转换成整数。</p><p id="e9b9" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">让我们从抽象出所需的转换开始:</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="ab8a" class="my lu iq mu b gy mz na l nb nc">(defn parse-float<br/>  [s]<br/>  (Float/parseFloat s))</span><span id="ef5a" class="my lu iq mu b gy ng na l nb nc">(-&gt;&gt; (generate-iris iris-path) <br/>     (take 2) <br/>     (map first)) ; first returns the first element of a collection ;(("5.1" "3.5" "1.4" "0.2") ("4.9" "3" "1.4" "0.2")) </span><span id="6974" class="my lu iq mu b gy ng na l nb nc">(-&gt;&gt; (generate-iris iris-path) <br/>     (take 2) <br/>     (map first) <br/>     (map #(map parse-float %))) <br/>; ((5.1 3.5 1.4 0.2) (4.9 3.0 1.4 0.2)) </span><span id="b0a3" class="my lu iq mu b gy ng na l nb nc">(-&gt;&gt; (generate-iris iris-path) <br/>     (take 2) <br/>     (map first) <br/>     (map #(map parse-float %)) <br/>     (map vec)) <br/>; ([5.1 3.5 1.4 0.2] [4.9 3.0 1.4 0.2])</span></pre><p id="bffa" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">通过这些变换，我们可以为我们的模型构建 X。让我们建造一个名为<strong class="kl ir">的变压器</strong>:</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="20ce" class="my lu iq mu b gy mz na l nb nc">(def transform-x<br/>  (comp<br/>   (map first)<br/>   (map #(map parse-float %))<br/>   (map vec)))</span></pre><p id="27fc" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">取而代之的是 Y:</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="1951" class="my lu iq mu b gy mz na l nb nc">(-&gt;&gt; (generate-iris iris-path) <br/>     (take 2) <br/>     (map last)) ; last takes the last item from a collection <br/>;(("setosa") ("setosa")) </span><span id="95d6" class="my lu iq mu b gy ng na l nb nc">(let [l (first '("setosa"))] <br/>  (case l "setosa" 0 "versicolor" 1 "virginica" 2)) <br/>;0</span></pre><p id="7c44" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">停一下，用<code class="fe nd ne nf mu b">let</code>我们可以创建本地绑定，比如给只存在于本地空间而非全局的数据或函数命名。<code class="fe nd ne nf mu b">case</code>这是避免嵌套<code class="fe nd ne nf mu b">(if condition "this" "else this")</code>的一种方式。我们说的是:如果<code class="fe nd ne nf mu b">l</code>是<code class="fe nd ne nf mu b">=</code>到<code class="fe nd ne nf mu b">"setosa"</code>那么返回<code class="fe nd ne nf mu b">0</code>，如果是<code class="fe nd ne nf mu b">=</code>到<code class="fe nd ne nf mu b">"versicolor"</code>返回<code class="fe nd ne nf mu b">1</code>，而如果是<code class="fe nd ne nf mu b">=</code>到<code class="fe nd ne nf mu b">"virginica"</code>返回 2。</p><p id="2436" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">这样，如果给定值与三种情况都不匹配，我们就会得到一个错误。这也有助于检查数据质量。</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="c170" class="my lu iq mu b gy mz na l nb nc">(-&gt;&gt; (generate-iris iris-path) <br/>     (take 2) <br/>     (map last) <br/>     (map (fn [label] <br/>       (let [l (first label)] <br/>         (case l "setosa" 0 "versicolor" 1 "virginica" 2))))) <br/>;(0 0)</span><span id="0e05" class="my lu iq mu b gy ng na l nb nc">(def transform-y<br/>  (comp<br/>   (map last)<br/>   (map (fn [label]<br/>          (let [l (first label)]<br/>            (case l<br/>              "setosa"     0<br/>              "versicolor" 1<br/>              "virginica"  2))))))</span><span id="ae0e" class="my lu iq mu b gy ng na l nb nc">(defn munge-data<br/>  [iris-data]<br/>  (let [x (into [] transform-x iris-data)<br/>        y (into [] transform-y iris-data)]<br/>    (map conj x y)))</span></pre><h1 id="20b7" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">列车-测试分离</h1><p id="c9ac" class="pw-post-body-paragraph ki kj iq kl b km ml jr ko kp mm ju kr mn mo ku kv mp mq ky kz mr ms lc ld le ij bi translated">当进行机器学习时，要做的最重要的事情之一是在一个<strong class="kl ir">训练</strong>和一个<strong class="kl ir">测试</strong>集合上分割数据。一个好的分割需要随机采样，所以我们将从头实现一个非常简单的采样器。</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="374a" class="my lu iq mu b gy mz na l nb nc">(defn train-test-split<br/>  [n dataset]<br/>  (let [shuffled (shuffle dataset)]<br/>    (split-at n shuffled)))</span></pre><p id="fa53" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated"><code class="fe nd ne nf mu b">train-test-split</code>在训练集中获取一个集合和一些你想要的实例。<code class="fe nd ne nf mu b">shuffle</code>函数只是简单地打乱了集合，所以我们每次都会得到一个随机的结果，并且可以很容易地避免重复。</p><p id="d730" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">如果您有一个相当大的数据集，这种解决方案并不是最佳的，在这种情况下，您可能想要看一下<a class="ae lf" href="https://github.com/bigmlcom/sampling" rel="noopener ugc nofollow" target="_blank">采样</a>，这是一个非常好的库，可以处理关于采样的所有事情。</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="6065" class="my lu iq mu b gy mz na l nb nc">(defn train-set<br/>  [split-set]<br/>  (let [set (first split-set)]<br/>    {:x (mapv drop-last set)<br/>     :y (mapv last set)}))<br/><br/>(defn test-set<br/>  [split-set]<br/>  (let [set (last split-set)]<br/>    {:x (mapv drop-last set)<br/>     :y (mapv last set)}))</span></pre><p id="510a" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">利用上述函数，我们生成训练集和测试集，作为带有 2 个<strong class="kl ir">键</strong> : <code class="fe nd ne nf mu b">:x</code>和<code class="fe nd ne nf mu b">:y</code>的 2 个<strong class="kl ir">映射</strong>。Clojure 中的地图是一等公民，具有非常好的属性:</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="669c" class="my lu iq mu b gy mz na l nb nc">; Create a map with mixed types <br/>{:a 1 "key" "string" 2 1/3}<br/> <br/>; Maps are functions <br/>({:a 1} :a) <br/>;1 </span><span id="de0a" class="my lu iq mu b gy ng na l nb nc">; Keywords are functions as well <br/>(:a {:a 1}) <br/>;1 </span><span id="c4a8" class="my lu iq mu b gy ng na l nb nc">; Access other kinds of keys by using the map... <br/>({1 2} 1) <br/>;2 </span><span id="bb85" class="my lu iq mu b gy ng na l nb nc">; ...or the get function <br/>(get {"key" 1} "key") <br/>;1</span></pre><p id="515e" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">地图远不止这些，如果你不知道它们，你应该看看这里的<a class="ae lf" href="https://clojure.org/guides/learn/hashed_colls#_maps" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="a50c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">训练和预测</h1><p id="8cc7" class="pw-post-body-paragraph ki kj iq kl b km ml jr ko kp mm ju kr mn mo ku kv mp mq ky kz mr ms lc ld le ij bi translated"><strong class="kl ir"> XGBoost </strong>是一个集合模型，它使用梯度增强来最小化损失函数。如果你不能理解这些单词，我的建议是查看<a class="ae lf" href="https://medium.com/@samudralaajit/unveiling-mathematics-behind-xgboost-c7f1b8201e2a" rel="noopener">这个非常好的算法解释</a>(有图片和公式)。</p><p id="243c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated"><a class="ae lf" href="https://gitlab.com/alanmarazzi/clj-boost" rel="noopener ugc nofollow" target="_blank"> <strong class="kl ir"> clj-boost </strong> </a>给你一个 Clojure 接口到底层 Java 实现的库，这样我们可以避免 Java 互操作，得到同样的结果。为了训练一个模型，我们必须从数据中创建一个<em class="kk"> DMatrix </em>,我们希望将这些数据提供给算法进行学习。这不是我的选择，我可以将数据转换隐藏在 API 实现的后面，但是有一个问题:一旦你将数据放入一个<em class="kk"> DMatrix </em>中，你就不能再触摸或查看它们了。</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="c4c2" class="my lu iq mu b gy mz na l nb nc">(defn train-model<br/>  [train-set]<br/>  (let [data   (boost/dmatrix train-set)<br/>        params {:params         {:eta       0.00001<br/>                                 :objective "multi:softmax"<br/>                                 :num_class 3}<br/>                :rounds         2<br/>                :watches        {:train data}<br/>                :early-stopping 10}]<br/>    (boost/fit data params)))</span></pre><p id="331a" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">用<code class="fe nd ne nf mu b">dmatrix</code>我们序列化我们的训练集，有各种方法生成一个<em class="kk"> DMatrix </em>，所以我建议你看一下<a class="ae lf" href="https://cljdoc.org/d/clj-boost/clj-boost/CURRENT/api/clj-boost.core#dmatrix" rel="noopener ugc nofollow" target="_blank">文档</a>或<a class="ae lf" href="https://gitlab.com/alanmarazzi/clj-boost/tree/dev#dmatrix" rel="noopener ugc nofollow" target="_blank">自述文件</a>。<code class="fe nd ne nf mu b">:params</code>映射的作用就像是<em class="kk"> XGBoost </em>的配置，这是我们可以用它做什么的一个非常小的例子，要知道所有可能的选项总是参考<a class="ae lf" href="https://xgboost.readthedocs.io/en/latest/parameter.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><p id="4dfc" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">这里我们说<em class="kk"> XGBoost </em>应该以 0.00001 的<em class="kk">学习率</em> — <code class="fe nd ne nf mu b">:eta</code>进行训练，因为我们正在对 3 个类进行分类—<em class="kk">setosa、versicolor </em>和<em class="kk">virginica—</em>我们将<code class="fe nd ne nf mu b">:objective</code>设置为<em class="kk"> multi:softmax </em>，并告诉<em class="kk"> XGBoost </em>我们与<code class="fe nd ne nf mu b">:num_class</code>有多少个类。</p><p id="8003" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated"><em class="kk"> XGBoost </em>将进行 2 次<code class="fe nd ne nf mu b">:rounds</code>的增强，将通过将<em class="kk">训练集</em>传递给<code class="fe nd ne nf mu b">:watches</code>图来评估其准确性(这不是一个好的实践，但这只是一个例子),如果准确性将开始连续 10 次迭代增加，它将由于<code class="fe nd ne nf mu b">:early-stopping</code>参数而停止训练。</p><p id="8959" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">对定义的<em class="kk">数据</em>和<em class="kk">参数</em>调用<code class="fe nd ne nf mu b">fit</code>从头训练一个<em class="kk"> XGBoost </em>模型，并返回一个<em class="kk"> Booster </em>实例。我们可以使用<em class="kk"> Booster </em>进行预测，我们可以将它持久化到磁盘上，或者将其作为基线提供给另一个<em class="kk"> XGBoost </em>模型。</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="839c" class="my lu iq mu b gy mz na l nb nc">(defn predict-model<br/>  [model test-set]<br/>  (boost/predict model (boost/dmatrix test-set)))<br/><br/>(defn accuracy<br/>  [predicted real]<br/>  (let [right (map #(compare %1 %2) predicted real)]<br/>    (/ (count (filter zero? right))<br/>       (count real))))</span></pre><p id="9e36" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">虽然我们通过<em class="kk">训练装置</em>本身来检查训练性能，但我们将在之前准备的<em class="kk">测试装置</em>上检查准确性。<code class="fe nd ne nf mu b">predict</code>需要一个<em class="kk">模型</em>和数据作为我们想要预测的<em class="kk"> DMatrix </em>并返回一个预测向量。</p><p id="6df5" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">让我们把一切都打包成一个<code class="fe nd ne nf mu b">-main</code>函数，这样我们就可以从 REPL 和命令行运行整个分析。</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="8206" class="my lu iq mu b gy mz na l nb nc">(defn -main<br/>  []<br/>  (let [split-set    (-&gt;&gt; iris-path<br/>                          generate-iris<br/>                          munge-data<br/>                          (train-test-split 120))<br/>        [train test] (map #(% split-set) [train-set test-set])<br/>        model     (train-model train)<br/>        result    (predict-model model test)]<br/>    (println "Prediction:" (mapv int result))<br/>    (println "Real:      " (:y test))<br/>    (println "Accuracy:  " (accuracy result (:y test)))))</span></pre><p id="e869" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">我们生成<em class="kk">分裂集</em>，然后我们使用一个小技巧:我们将多个函数映射到一个集合上，而不是相反。然后我们训练 XGBoost 模型并得到预测。</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="1aa8" class="my lu iq mu b gy mz na l nb nc">(-main) <br/>Prediction: [1 1 2 0 2 2 2 2 2 1 1 0 1 2 0 1 1 1 0 1 0 2 1 1 0 0 1 2 1 1] <br/>Real: [1 1 2 0 2 2 2 2 2 1 1 0 1 2 0 1 1 1 0 1 0 2 1 1 0 0 1 2 2 1]<br/>Accuracy: 29/30</span></pre><h1 id="b456" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">灵活性与生产</h1><p id="9068" class="pw-post-body-paragraph ki kj iq kl b km ml jr ko kp mm ju kr mn mo ku kv mp mq ky kz mr ms lc ld le ij bi translated">您可能没有注意到，尽管我们编写的代码足够简单灵活，可以用于分析和实验，但这也是<strong class="kl ir">生产就绪</strong>代码。如果您在命令行中从项目的根目录执行<code class="fe nd ne nf mu b">lein run</code>，您将获得与从 REPL 执行<code class="fe nd ne nf mu b">(-main)</code>相同的结果。因此，向程序添加功能是微不足道的，例如，当程序发生变化时，您可能希望向它输入新数据，并且您希望重新训练您的模型。</p><p id="d0a4" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">如果我们现在在 Jupyter 笔记本上用 Python 做类似的事情，我们可能会到处都是任务，命令式代码必须从头开始重写，以使它在某种程度上为生产做好准备，我不会谈论这样一个事实，即如果数据管理性能可能是一个问题，通过组成转换器，我们几乎可以获得<strong class="kl ir">免费</strong>的并行化。</p><p id="a172" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">现在你可以用<a class="ae lf" href="https://gitlab.com/alanmarazzi/clj-boost" rel="noopener ugc nofollow" target="_blank"> clj-boost </a>玩一会儿了，不要忘了还有<a class="ae lf" href="https://cljdoc.org/d/clj-boost/clj-boost/CURRENT/doc/readme" rel="noopener ugc nofollow" target="_blank">文档</a>可用，这仍然是一项正在进行的工作，所以如果有问题、想法、改进方法或者只是你正在使用它并且你对它感到满意，请让我知道。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="e43a" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">你可以在<a class="ae lf" href="https://gitlab.com/alanmarazzi/clj-boost/blob/master/demo/tutorial.clj" rel="noopener ugc nofollow" target="_blank"> clj-boost repo </a>上找到完整的脚本，不要忘记 clj-boost 是自由/开源软件，任何形式的贡献都是可以接受的！</p><p id="2575" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mn kt ku kv mp kx ky kz mr lb lc ld le ij bi translated">这篇文章最初发表在<a class="ae lf" href="https://www.rdisorder.eu/2018/12/03/machine-learning-clojure-xgboost/" rel="noopener ugc nofollow" target="_blank"> rDisorder </a>上(请特别查看更好的代码片段)</p></div></div>    
</body>
</html>