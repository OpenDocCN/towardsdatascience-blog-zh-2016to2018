# Python 的生成器表达式:将大型数据集放入内存

> 原文：<https://towardsdatascience.com/pythons-list-generators-what-when-how-and-why-2a560abd3879?source=collection_archive---------5----------------------->

![](img/755bde4e4961f8c3e45780a84a402185.png)

Don’t forget to stay hydrated while you code. Source: [Pixabay](https://pixabay.com/en/home-office-workstation-office-336373/)

生成器表达式是 Python 中一个有趣的特性，它允许我们创建延迟生成的可迭代对象。如果您的数据不适合内存，它们可能是解决方案。

这篇文章是我写的介绍列表理解表达的那篇文章的后续，如果你以前从未接触过这个主题，我建议你在这篇文章之前读一读。

## 什么是生成器表达式？

为了用生成器创建一个 Iterable，你所要做的就是写一个 List Comprehension，但是用圆括号代替方括号。所有关于列表理解的语法规则在这里都适用:你可以用一个结尾的 *if* 子句过滤一个生成器，并用两个嵌套的 *for 循环从一个矩阵中生成一个生成器。*

不过生成器有一个有趣的特性，那就是它们以一种懒惰的方式生成它们的 Iterable 对象:Iterable 中的第 *i* 个元素直到必要时才会被创建(因此不会占用宝贵的虚拟内存)。作为一个 catch，您不能像对列表那样对生成器进行索引或切片——而不是从 Iterable 中检索任意元素，您只能按顺序迭代它。这也是为什么不能在生成器上调用 *len* 函数的原因。

**使用发电机的优势:一个简单的实验**

为了证明发电机为什么有用，我进行了以下实验:

如您所见，生成器存储“相同”的信息，仅使用 80 字节，而列表占用了 80Mb。发电机的加载速度也快了很多，虽然我们在这里谈论的是几秒钟。很明显，在任何内存不足的问题中，用生成器替换列表可能是一个明智的选择，只要我们记住前面提到的注意事项(不要任意检索，不要进行 *len* 检查)。

## 作为迭代器的生成器

对于那些有 Java/C++背景的人来说，知道生成器可以和类似迭代器的接口一起使用可能会很有趣。这是通过使用 Python 2 中的 *next* 方法和 Python 3+中的 *next* 函数来完成的。这里有一个关于我们如何在 Python 2.7 中迭代生成器的例子:

我们通常会像其他可迭代对象一样迭代它:使用一个 *for 循环。然而，给定循环结束或继续的非平凡条件，我们可能会在想要手动迭代的情况下结束。为此，我们将调用*的下一个*方法(Python 2)或函数(Python 3)，直到它抛出一个 *StopIteration* 异常。请注意，在检索时单独生成每个元素所花费的时间加起来将与以非懒惰方式初始化整个列表所花费的时间一样多。最后，给定一个生成器，我们总是可以通过调用 *list(our_generator)，*支付全部初始化成本*，将它转换成一个普通的旧非懒惰列表。**

**发电机的一个常见用法你可能错过了**

我的一位令人敬畏的读者提交了发电机的另一种使用方式。您可能熟悉我们在 Python 中打开文件并迭代其行的方式:

该代码片段实际上使用生成器一行一行地缓慢加载文件。你看，我们一直在使用发电机*！下一部夏马兰的电影怎么样？*

*总而言之，我们可以在任何情况下使用生成器，只要我们只需要迭代它们的结果，而不需要关心切片、索引或返回。在这些情况下使用它们通常是好的，因为我们将能够在内存中容纳非常大的数据集，而不会损失表达能力或计算时间——只要我们只需要迭代它们，一次一个对象或一行。*

*这是我对生成器表达式的介绍，我希望你会觉得有用。如果您认为我应该介绍任何用例，或者您认为我应该提到的任何重要特性，以及您发现的任何明显错误，请告诉我！我也很高兴知道在阅读本文后，您是否在代码中的任何地方应用了生成器。*

*最后，有一本我喜欢的 O'Reilly 的书，当我开始我的数据科学之旅时，我发现它非常有用。用 Python 叫做[从零开始的数据科学，大概也是我得到这份工作的一半原因。如果你读到这里，你可能会喜欢它！](https://www.bookdepository.com/book/9781491901427/?a_aid=strikingloo&chan=ws)*

**你可以在我的* [*个人网站*](http://strikingloo.github.io/wiki) *看到我正在做的事情以及我最近的文章和笔记。**

**一如既往，继续编码！**