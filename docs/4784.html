<html>
<head>
<title>Does power and heart rate go hand in hand when you ride a bike?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">骑车时力量和心率是齐头并进的吗？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/does-power-and-heart-rate-go-hand-in-hand-when-you-ride-a-bike-37a174785f37?source=collection_archive---------10-----------------------#2018-09-06">https://towardsdatascience.com/does-power-and-heart-rate-go-hand-in-hand-when-you-ride-a-bike-37a174785f37?source=collection_archive---------10-----------------------#2018-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a0bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">充分利用电表的数据分析方法。</p><h1 id="ea38" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">介绍</h1><p id="f8cb" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">你有功率表或者考虑买一个吗？也许你认为这样的设备是下一个收集成千上万数据却不给你任何信息的小工具？不管你的主要动机是什么，继续读下去。</p><p id="41ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇短文中，我将尝试通过户外骑行期间收集的功率表和心率的数据分析来指导您。对于统计计算和图形，我使用了 R 软件，所有代码都包含在文本中，供您参考。</p><p id="6b50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种关系的理论很简单。锻炼时你付出的努力越多，你的心率就必须向你的肌肉输送更多的血液，以便输送燃料(糖原)和氧气。</p><p id="2d9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并发症来自人体生理和锻炼环境。肌肉含有能量储备，可在紧急情况下立即使用。这种储存不会持续很长时间，但足以延迟心脏反应一段时间。户外环境对数据分析师来说也不是那么友好。丘陵、风或不平的道路使得骑自行车的人几乎不可能在最短的时间内保持稳定的功率输出水平。此外，大多数锻炼都设计了低功率输出和高功率输出的间隔，从而不断地来回拉动您的心率。</p><h1 id="0ea2" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">线性回归从 R 开始</h1><p id="c100" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在我们开始处理数据之前，我们需要准备一个 R 环境包，它可以很好地解释 Garmin fit 文件。如果你遇到任何问题，不要害怕在评论中提出问题。我们将同时加载所有的库，因此我们将完全覆盖这一部分。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="ddd0" class="lx km iq lt b gy ly lz l ma mb">#In order to install directly from github you have to get and use devtools<br/>install.packages('devtools')<br/>library(devtools)<br/>assignInNamespace("version_info", c(devtools:::version_info, list("3.5" = list(version_min = "3.3.0", version_max = "99.99.99", path = "bin"))), "devtools")<br/>#Library that is used to read garmin fit files is here <a class="ae mc" href="https://github.com/kuperov/fit" rel="noopener ugc nofollow" target="_blank">https://github.com/kuperov/fit</a> but it is better to use fork as this has more recent SDK.<br/>#add CXXFLAGS=-g -std=c++11 in C:\Program Files\R\R-3.5.1\etc\i386\Makeconf<br/>install_github("russelldb/fit")</span><span id="9fdd" class="lx km iq lt b gy md lz l ma mb">library(fit) # read fit files<br/>library(ggplot2) # plots in R<br/>library(TTR) # Exponential Moving Average<br/>library(gridExtra) # Plots aggregator <br/>library(dplyr) #lag and lead</span><span id="1118" class="lx km iq lt b gy md lz l ma mb">options("scipen"=100, "digits"=4) #print numbers in normal notation</span><span id="1baa" class="lx km iq lt b gy md lz l ma mb">#The part that reads exported workout file from Garmin Connect<br/>cycling &lt;- read.fit('2951865119.fit')</span></pre><p id="0c17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了所有可用的数据，我们可以绘制功率和心率图。</p><figure class="lo lp lq lr gt mf gh gi paragraph-image"><div class="gh gi me"><img src="../Images/663d6b3f1fc1d650b438c30c2634630d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*skAyIp3291UT13Gu4-97wA.png"/></div></figure><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="1357" class="lx km iq lt b gy ly lz l ma mb">#Prepare data<br/>record &lt;- cycling$record # make record data frame available globally<br/>record &lt;- record[!is.na(record$power) &amp; !is.na(record$heart_rate) ,] # remove NA<br/>record$time &lt;- (record$timestamp-record$timestamp[1])/60 # Show time in minutes<br/>record$from_start &lt;- record$timestamp - record$timestamp[1]  # create variable seconds from start</span><span id="abac" class="lx km iq lt b gy md lz l ma mb">#Plot the first graph<br/>ggplot(cycling$record, aes( x=time)) + <br/>  geom_line(aes(y = power, colour = "Power")) + <br/>  geom_line(aes(y = heart_rate, colour = "Heart Rate")) + <br/>  theme(axis.title.y=element_blank()) +<br/>  ggtitle("Power and Heart Rate")</span></pre><p id="1147" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你可能看到的那样，这种相关性是存在的，但是我们不应该期望有什么强的相关性。首先，测得的输出功率比我们在心率中看到的噪声(或方差)多得多。第二件事是，当你停止踩踏板时，功率为零，而心率仍然保持在高水平。</p><p id="72ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从基本的线性回归开始，即心率直接取决于产生的功率。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="d4ee" class="lx km iq lt b gy ly lz l ma mb">#linear regression<br/>linearMod &lt;- lm(heart_rate ~ power , data=record)<br/>summary(linearMod)</span></pre><p id="21ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在对我乘坐的数据进行快速计算后，我得到了如<code class="fe mi mj mk lt b">HRM = 105.33 + 0.1057 * PWR</code>这样的模型。这两个参数都具有统计学意义，更重要的是，它们都有很好的解释。<code class="fe mi mj mk lt b">105 </code>是我的基础心率，<code class="fe mi mj mk lt b">0.10</code>是力量增长比率。调整后的 R-squared: <code class="fe mi mj mk lt b">0.29</code>，表明模型只在很小的百分比上解释了数据。</p><h1 id="722d" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">心率功率的高级建模</h1><p id="3ac8" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">首先，让我们注意到功率比心率有更大的可变性，为了能够得到更好的解释，我们需要以某种方式重新调整它。此外，权力积累本身的内部和驱动心率在一个体积。可以用来实现它的一种方法是使用一段时间的平均值。</p><p id="2a46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们再加上一个可以反映疲劳的变量。最简单的方法是加上从健身程序开始算起的秒数。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="7a90" class="lx km iq lt b gy ly lz l ma mb">HRM ~ moving_average(PWR, window) + time from start</span></pre><p id="59c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用指数移动平均线而不是简单移动平均线，因为 SMA 被认为有一个被称为“吠两次”的问题。这对于耐久性数据来说尤其不方便，因为过去努力应该只有最小的影响。</p><p id="0a37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，问题可能是最适合我们的模型的最佳窗口参数是什么。让我们把它当作一个参数来估计，我们将迭代地做 0 到 250 秒之间的窗口大小的线性回归。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="132a" class="lx km iq lt b gy ly lz l ma mb">iterations = 250L<br/>variables = 5<br/>output &lt;- matrix(ncol=variables, nrow=(iterations))<br/>for (i in c(1:iterations)){<br/>  print(i)<br/>  linearMod &lt;- lm(heart_rate ~ EMA(power,n=i) + from_start, data=record)<br/>  summary &lt;- summary(linearMod)<br/>  output[i,] &lt;- c(i,summary$r.squared, summary$coefficients[1],summary$coefficients[2],summary$coefficients[3])<br/>}</span><span id="cedd" class="lx km iq lt b gy md lz l ma mb">summary.df &lt;- data.frame(output)</span><span id="4eff" class="lx km iq lt b gy md lz l ma mb">summary.df[summary.df$X2==max(summary.df$X2),]<br/>window  &lt;- summary.df[summary.df$X2==max(summary.df$X2),1] #declare variable for future use</span><span id="59f9" class="lx km iq lt b gy md lz l ma mb">ggplot(summary.df, aes(x = X1)) + <br/>  geom_line(aes(y = X2, colour = "R"), show.legend=F) +<br/>  xlab("[s]") +<br/>  theme(axis.title.y=element_blank()) +<br/>  ggtitle("R over mean window")</span></pre><figure class="lo lp lq lr gt mf gh gi paragraph-image"><div class="gh gi me"><img src="../Images/ee98510dcbc7ac05f6facd4ff28507c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*EjgoUQ5z-78I0cHU80r5SA.png"/></div></figure><p id="b04d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随后的下降有明显的局部最大值，这给这种方法以信心。r 平方增加到 0.78，这是一个体面的模型拟合。自行车静息心率下降到 84，这也是更可信的值。随着功率的下降，增长率略有上升。当平均值的窗口大约为 43 秒时，模型达到最佳拟合。</p><p id="8e1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一个值得检查的是基础 HR 和增长比率的行为。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="2d09" class="lx km iq lt b gy ly lz l ma mb">plot1 &lt;- ggplot(summary.df, aes(x = X1)) + <br/>  geom_line(aes(y = X3, colour = "Base HR"), show.legend=F) +<br/>  xlab("[s]") + theme(axis.title.y=element_blank()) +<br/>  ggtitle("Base HR over mean window")<br/>plot2 &lt;-ggplot(summary.df, aes(x = X1)) + <br/>  geom_line(aes(y = X4, colour = "Base HR"), show.legend=F) +<br/>  xlab("[s]") + theme(axis.title.y=element_blank()) +<br/>  ggtitle("Growth ratio over mean window")<br/>grid.arrange(plot1, plot2, nrow=2)</span></pre><figure class="lo lp lq lr gt mf gh gi paragraph-image"><div class="gh gi me"><img src="../Images/7e89f01d6674292ef8b988edd648c04b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*ui2FysK_KxkuqaHfxePLWA.png"/></div></figure><p id="58b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以看到，随着窗口大小的增加，基础 HR 不断下降，并稳定在一个更小的值。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="23ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ne 可能会问引入移动平均是否足以让模型完美拟合，并质疑心率反应是否有立竿见影的效果。事实上，我们应该以类似的方式检查滞后或超前是否改进了模型。</p><p id="0cc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">新模型将会是这样的:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="a96c" class="lx km iq lt b gy ly lz l ma mb">HRM ~ moving_average(lag or lead(PWR,difference), window) + time from start</span></pre><p id="8bb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">估计也是基于迭代方法，但这次我们需要计算每个<code class="fe mi mj mk lt b">i</code>的滞后和超前</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="c40e" class="lx km iq lt b gy ly lz l ma mb">iterations = 125L<br/>variables = 5<br/>output &lt;- matrix(ncol=variables, nrow=(iterations*2-1))<br/>for (i in c(1:iterations-1)){<br/>  print(i)<br/>  linearMod &lt;- lm(heart_rate ~ lead(EMA(power,n=window) ,n = i)  + from_start, data=record)<br/>  summary &lt;- summary(linearMod)<br/>  output[i+iterations,] &lt;- c(i,summary$r.squared, summary$coefficients[1],summary$coefficients[2],summary$coefficients[3])<br/>  linearMod &lt;- lm(heart_rate ~ lag(EMA(power,n=window) ,n = i) + from_start , data=record)<br/>  summary &lt;- summary(linearMod)<br/>  output[iterations-i,] &lt;- c(-i,summary$r.squared, summary$coefficients[1],summary$coefficients[2],summary$coefficients[3])<br/>}</span><span id="2517" class="lx km iq lt b gy md lz l ma mb">linearMod &lt;- lm(heart_rate ~ EMA(power,n=window)  + from_start , data=record)<br/>summary &lt;- summary(linearMod)<br/>output[iterations,] &lt;- c(0,summary$r.squared, summary$coefficients[1],summary$coefficients[2],summary$coefficients[3])</span><span id="035f" class="lx km iq lt b gy md lz l ma mb">summary.df &lt;- data.frame(output)</span><span id="4b42" class="lx km iq lt b gy md lz l ma mb">summary.df[summary.df$X2==max(summary.df$X2),]<br/>summary.df[summary.df$X4==max(summary.df$X4),]<br/>summary.df[summary.df$X3==min(summary.df$X3),]</span><span id="8e11" class="lx km iq lt b gy md lz l ma mb">ggplot(summary.df, aes(x = X1)) + <br/>  geom_line(aes(y = X2, colour = "R"), show.legend=F) +<br/>  xlab("[s]") + theme(axis.title.y=element_blank()) +<br/>  ggtitle("R with difference")<br/>  <br/>plot1 &lt;- ggplot(summary.df, aes(x = X1)) + <br/>  geom_line(aes(y = X3, colour = "Base HR"), show.legend=F) +<br/>  xlab("[s]") + theme(axis.title.y=element_blank()) +<br/>  ggtitle("Base HR  with difference")<br/>plot2 &lt;-ggplot(summary.df, aes(x = X1)) + <br/>  geom_line(aes(y = X4, colour = "Base HR"), show.legend=F) +<br/>  xlab("[s]") + theme(axis.title.y=element_blank()) +<br/>  ggtitle("Growth ratio  with difference")<br/>grid.arrange(plot1, plot2, nrow=2)</span></pre><figure class="lo lp lq lr gt mf gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/bb6cba1a199981ebca434313e4ab62f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*YxHnec_ck7HMUPJI5mF74g.png"/></div></figure><figure class="lo lp lq lr gt mf gh gi paragraph-image"><div class="gh gi me"><img src="../Images/fdf98bd9335c417f1506c36a5fb475d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*foO3MoQxawS_or7hEncjBw.png"/></div></figure><p id="49d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当没有超前或滞后时，达到模型的最佳拟合，并且基本 HR 的最小值和增长率的最大值同时达到。这是理想的，但是小的滞后或超前值也是可以接受的，因为可能会有一些设备记录时间不匹配。</p><p id="0463" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一件值得检查的事情是线性回归残差的分位数-分位数图。基本上，它告诉你没有被解释的部分是一个随机的正常噪音还是有一些隐藏的模式在里面。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="536d" class="lx km iq lt b gy ly lz l ma mb">linearMod &lt;- lm(heart_rate ~ EMA(power,n=window)+ from_start   , data=record)<br/>summary(linearMod)<br/>plot(linearMod)</span></pre><figure class="lo lp lq lr gt mf gh gi paragraph-image"><div class="gh gi me"><img src="../Images/d064427fa4dabda4e0b976392ae3ed89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*lGVELMMzWAFlRhGBly9RdA.png"/></div></figure><p id="a31a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在完美的排列中，所有的点都应该在一条直线上。在我们的例子中，尾部没有被很好地放置，这可能暗示了模型的一些改进领域。</p><p id="9373" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一部分是用热图交叉检查一张图上的所有数据。因此，我们将同时检查窗口大小参数和滞后或超前。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="a333" class="lx km iq lt b gy ly lz l ma mb">#check for moving average<br/>iterations = 201L<br/>variables = 6</span><span id="3038" class="lx km iq lt b gy md lz l ma mb">output &lt;- matrix(ncol=variables, nrow=iterations^2-1)<br/>for (j in c(1:iterations)){<br/>  for (i in c(1:(iterations/2L))){<br/>    print(iterations*(j-1)+i)<br/>    linearMod &lt;- lm(heart_rate ~ lead(EMA(power,n=j),n=i) + from_start  , data=record)<br/>    summary &lt;- summary(linearMod)<br/>    output[iterations*(j-1)+i+iterations/2,] &lt;- c(i,j,summary$r.squared, summary$coefficients[1],summary$coefficients[2],summary$coefficients[3])<br/>    linearMod &lt;- lm(heart_rate ~ lag(EMA(power,n=j),n=i) + from_start  , data=record)<br/>    summary &lt;- summary(linearMod)<br/>    output[iterations*(j-1)+iterations/2-i,] &lt;- c(-i,j,summary$r.squared, summary$coefficients[1],summary$coefficients[2],summary$coefficients[3])<br/>  }<br/>  linearMod &lt;- lm(heart_rate ~ EMA(power,n=j) + from_start  , data=record)<br/>  summary &lt;- summary(linearMod)<br/>  output[iterations*(j-1)+(iterations/2L),] &lt;- c(0,j,summary$r.squared, summary$coefficients[1],summary$coefficients[2],summary$coefficients[3])<br/>}</span><span id="4123" class="lx km iq lt b gy md lz l ma mb">summary.df &lt;- data.frame(output)</span><span id="e018" class="lx km iq lt b gy md lz l ma mb">summary.df[summary.df$X3==max(summary.df$X3),]</span><span id="bc20" class="lx km iq lt b gy md lz l ma mb">ggplot(summary.df, aes(x = X1,y=X2, color=X3)) +  geom_point() + scale_colour_gradientn(colours=rainbow(4)) +<br/>  labs(x = "Lag value", y = "Mean", color ="R")</span><span id="70d0" class="lx km iq lt b gy md lz l ma mb">ggplot(summary.df, aes(x = X1,y=X2, color=X4)) +  geom_point() + scale_colour_gradientn(colours=rainbow(4)) +<br/>  labs(x = "Lag value", y = "Mean", color ="Base HR")</span></pre><figure class="lo lp lq lr gt mf gh gi paragraph-image"><div class="gh gi me"><img src="../Images/8be50f35894a90dccfd22dea21e0e44c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*Efy3Bh3ClXuzLpcurB2FUA.png"/></div></figure><figure class="lo lp lq lr gt mf gh gi paragraph-image"><div class="gh gi me"><img src="../Images/3a73105303b2868d1794317b6e29e922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*LVmLdOp6unpWdXV_UGXFIA.png"/></div></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="c3a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想在这里展示的最后一件事是受过训练和未受过训练的运动员之间的比较。为此，我们有一组来自经常训练的高级选手和新手的数据。我们做了 5 分钟 150W 稳定负荷下的心率模拟。为了简化，不存在预热。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="4aa7" class="lx km iq lt b gy ly lz l ma mb">#Prepare data<br/>cycling2 &lt;- read.fit('Szosa-4x1395-98%FTP/2863955610.fit')<br/>record2 &lt;- cycling2$record # make record data frame available globally<br/>record2 &lt;- record2[!is.na(record2$power) &amp; !is.na(record2$heart_rate) ,] # remove NA<br/>record2$from_start &lt;- record2$timestamp - record2$timestamp[1]  # create variable seconds from start</span><span id="ca2c" class="lx km iq lt b gy md lz l ma mb">robert &lt;- lm(heart_rate ~ EMA(power,n=116) + from_start, data=record2)<br/>marek &lt;-  lm(heart_rate ~ EMA(power,n=43) + from_start, data=record)</span><span id="16ae" class="lx km iq lt b gy md lz l ma mb">warmUp &lt;- rep(0,3*60)<br/>powerPhase &lt;- rep(150,5*60)<br/>coolDown &lt;- rep(0,5*60)</span><span id="1d2d" class="lx km iq lt b gy md lz l ma mb">power &lt;- c(warmUp, powerPhase, coolDown)<br/>from_start &lt;- as.numeric(seq(power))</span><span id="69b7" class="lx km iq lt b gy md lz l ma mb">experiment &lt;- data.frame(power,from_start)<br/>experiment$heart_rate1&lt;-predict(robert,experiment)<br/>experiment$heart_rate2&lt;-predict(marek,experiment)<br/>experiment$time &lt;- experiment$from_start/60 # Show time in minutes</span><span id="5fed" class="lx km iq lt b gy md lz l ma mb">ggplot(experiment, aes( x=time)) + <br/>  geom_line(aes(y = heart_rate1, colour = "Heart Rate Advance")) + <br/>  geom_line(aes(y = heart_rate2, colour = "Heart Rate Novice")) + <br/>  theme(axis.title.y=element_blank()) +<br/>  scale_x_continuous(limits = c(2, 12)) +<br/>  ggtitle("Power and Heart Rate")</span></pre><figure class="lo lp lq lr gt mf gh gi paragraph-image"><div class="gh gi me"><img src="../Images/3059f0f642345edbc8235644a529fdde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*hqeKqETbdfT-g43FQAv0IA.png"/></div></figure><h1 id="df7a" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">接下来呢？</h1><ul class=""><li id="df58" class="mt mu iq jp b jq lj ju lk jy mv kc mw kg mx kk my mz na nb bi translated">构建一个出色的应用程序来处理您的数据</li><li id="7b9b" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">分析恢复时间，因为受过训练的运动员应该恢复得更快</li><li id="28d5" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">将厌氧效果添加到模型中</li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="027d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您发现任何不清楚的地方，请留下评论或提出问题。</p></div></div>    
</body>
</html>