<html>
<head>
<title>Data Scientists, The one Graph Algorithm you need to know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家，你需要知道的一个图算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/to-all-data-scientists-the-one-graph-algorithm-you-need-to-know-59178dbb1ec2?source=collection_archive---------4-----------------------#2018-12-09">https://towardsdatascience.com/to-all-data-scientists-the-one-graph-algorithm-you-need-to-know-59178dbb1ec2?source=collection_archive---------4-----------------------#2018-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1a8fed96a1ff78687989f8bca5d013a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-9PA7WEKDrVPgiby"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://unsplash.com/@alinnnaaaa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alina Grubnyak</a> on <a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="082c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">图表为我们提供了一种非常有用的数据结构。它们可以帮助我们找到数据中的结构。随着机器学习和大数据的出现，我们需要获得尽可能多的关于我们数据的信息。学习一点图论当然可以帮助我们。</p><p id="531b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个由 UCSanDiego 在 Coursera 上开设的<a class="ae kf" href="https://coursera.pxf.io/YgKbbe" rel="noopener ugc nofollow" target="_blank">大数据图形分析课程，我强烈推荐学习图论的基础知识。</a></p><p id="6565" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我在这篇文章中要关注的算法之一叫做<strong class="ki iu">连通域</strong>。为什么它很重要。我们都知道聚类。</p><p id="7e46" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">你可以用非常通俗的术语把连通分量看作是一种硬聚类算法，它在相关/连通的数据中寻找聚类/孤岛。举一个具体的例子:假设您有关于连接世界上任何两个城市的道路的数据。你需要找出世界上所有的大洲以及它们包含的城市。</em></p><h1 id="9e17" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">你将如何实现这一目标？来吧，考虑一下。</h1><p id="b6d5" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">从零售角度来看<strong class="ki iu"/>:比方说，我们有很多客户使用很多账户。使用连通分量算法的一种方法是在数据集中找出不同的族。我们可以基于相同的信用卡使用、相同的地址或相同的手机号码等假设客户之间的边界(道路)。一旦我们有了这些连接，我们就可以在相同的上运行连接组件算法来创建单独的聚类，然后我们可以为这些聚类分配一个家族 ID。我们可以使用这些家庭 id 根据家庭需求提供个性化建议。我们还可以使用这个家族 ID，通过创建基于家族的分组特征来推动我们的分类算法。</p><p id="060c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<strong class="ki iu">财务视角</strong>中:另一个用例是使用这些家庭 id 来捕获欺诈。如果一个帐户过去曾有过欺诈行为，那么关联的帐户也很有可能容易受到欺诈。</p><p id="66ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">足够多的用例。让我们从一个用 Python 编写的简单的 graph 类开始，用代码开始我们的开发。</p><p id="a767" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从现在开始，这篇文章将更多地围绕代码展开。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="f0b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您当然可以使用我们的新图形类。在这里，我们试图建立一些图表。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><pre class="mi mj mk ml gt mo mp mq mr aw ms bi"><span id="e387" class="mt lg it mp b gy mu mv l mw mx">Output:<br/>Vertices of graph:<br/>['a', 'c', 'b']<br/>Edges of graph:<br/>[['a', 'd', 2], ['c', 'b', 5], ['c', 'e', 5], ['c', 'd', 3], ['b', 'c', 2]]<br/>Add vertex:<br/>Vertices of graph:<br/>['a', 'c', 'b', 'z']<br/>Add an edge:<br/>Vertices of graph:<br/>['a', 'c', 'b', 'z']<br/>Edges of graph:<br/>[['a', 'z', 1], ['a', 'd', 2], ['c', 'b', 5], ['c', 'e', 5], ['c', 'd', 3], ['b', 'c', 2], ['z', 'a', 1]]<br/>Adding an edge {"x","y"} with new vertices:<br/>Vertices of graph:<br/>['a', 'c', 'b', 'y', 'x', 'z']<br/>Edges of graph:<br/>[['a', 'z', 1], ['a', 'd', 2], ['c', 'b', 5], ['c', 'e', 5], ['c', 'd', 3], ['b', 'c', 2], ['y', 'x', 1], ['x', 'y', 1], ['z', 'a', 1]]</span></pre><p id="5237" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们做一些有趣的事情。</p><p id="dd78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">出于理解的目的，我们将使用上面的 graph 类。python 中有许多模块，我们可以用来做我接下来要做的任何事情，但是为了理解这些方法，我们将从头开始编写所有的东西。<br/>让我们从一个示例图开始，我们可以用它来达到我们的目的。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/a5a72b77ac3157842bd2f3ebba029776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l5oANTUZ1SY718VODOnu5Q.png"/></div></div></figure><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><pre class="mi mj mk ml gt mo mp mq mr aw ms bi"><span id="ec66" class="mt lg it mp b gy mu mv l mw mx">Vertices of graph:<br/>['Mannheim', 'Erfurt', 'Munchen', 'Numberg', 'Stuttgart', 'Augsburg', 'Kassel', 'Frankfurt', 'Wurzburg', 'Karlsruhe']<br/>Edges of graph:<br/>[['Mannheim', 'Frankfurt', 85], ['Mannheim', 'Karlsruhe', 80], ['Erfurt', 'Wurzburg', 186], ['Munchen', 'Numberg', 167], ['Munchen', 'Augsburg', 84], ['Munchen', 'Kassel', 502], ['Numberg', 'Stuttgart', 183], ['Numberg', 'Wurzburg', 103], ['Numberg', 'Munchen', 167], ['Stuttgart', 'Numberg', 183], ['Augsburg', 'Munchen', 84], ['Augsburg', 'Karlsruhe', 250], ['Kassel', 'Munchen', 502], ['Kassel', 'Frankfurt', 173], ['Frankfurt', 'Mannheim', 85], ['Frankfurt', 'Wurzburg', 217], ['Frankfurt', 'Kassel', 173], ['Wurzburg', 'Numberg', 103], ['Wurzburg', 'Erfurt', 186], ['Wurzburg', 'Frankfurt', 217], ['Karlsruhe', 'Mannheim', 80], ['Karlsruhe', 'Augsburg', 250]]</span></pre><p id="65f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设给我们一张图表，上面有德国的城市以及它们之间各自的距离。<strong class="ki iu">你想知道如何从法兰克福(起点)到慕尼黑</strong>。可能有许多方法可以遍历该图，但您需要找到从法兰克福到慕尼黑至少需要访问多少个城市)这个问题类似于在未加权的图中找出节点之间的距离。</p><p id="6247" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们这里使用的算法叫做<strong class="ki iu">广度优先搜索</strong>。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="caed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在上面这段代码中所做的是创建一个队列，并根据级别遍历它。我们以法兰克福为起点。我们循环通过它的邻近城市(曼海姆、维尔茨堡和卡塞尔)并把它们推入队列。我们跟踪他们处于什么水平，以及我们到达他们的路径。因为我们弹出队列的第一个元素，我们确信我们将按照城市等级的顺序访问城市。</p><p id="ebcf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查看这篇关于 BFS 的<a class="ae kf" href="https://medium.com/basecs/breaking-down-breadth-first-search-cebe696709d9" rel="noopener">帖子</a>，了解更多关于排队和 BFS 的信息。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><pre class="mi mj mk ml gt mo mp mq mr aw ms bi"><span id="3836" class="mt lg it mp b gy mu mv l mw mx">({'Augsburg': 3,<br/>  'Erfurt': 2,<br/>  'Frankfurt': 0,<br/>  'Karlsruhe': 2,<br/>  'Kassel': 1,<br/>  'Mannheim': 1,<br/>  'Munchen': 2,<br/>  'Numberg': 2,<br/>  'Stuttgart': 3,<br/>  'Wurzburg': 1},<br/> {'Augsburg': ':-&gt;Frankfurt-&gt;Mannheim-&gt;Karlsruhe',<br/>  'Erfurt': ':-&gt;Frankfurt-&gt;Wurzburg',<br/>  'Frankfurt': ':',<br/>  'Karlsruhe': ':-&gt;Frankfurt-&gt;Mannheim',<br/>  'Kassel': ':-&gt;Frankfurt',<br/>  'Mannheim': ':-&gt;Frankfurt',<br/>  'Munchen': ':-&gt;Frankfurt-&gt;Kassel',<br/>  'Numberg': ':-&gt;Frankfurt-&gt;Wurzburg',<br/>  'Stuttgart': ':-&gt;Frankfurt-&gt;Wurzburg-&gt;Numberg',<br/>  'Wurzburg': ':-&gt;Frankfurt'})</span></pre><p id="ea1d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我做这个例子是为了展示 BFS 算法是如何工作的。我们可以扩展这个算法，在一个不连通的图中找出连通的部分。假设我们需要在图中找到几组不相连的顶点。</p><p id="0849" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，下图有 3 个不相连的子图。<strong class="ki iu">我们能找到哪些节点属于某个特定的子图吗？</strong></p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/e56224cf925a5a22ce8b26e43a08e617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5jLiNyvTWtp4a6eSX-cybg.png"/></div></div></figure><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><pre class="mi mj mk ml gt mo mp mq mr aw ms bi"><span id="b16a" class="mt lg it mp b gy mu mv l mw mx">[['Kassel',<br/>  'Munchen',<br/>  'Frankfurt',<br/>  'Numberg',<br/>  'Augsburg',<br/>  'Mannheim',<br/>  'Wurzburg',<br/>  'Stuttgart',<br/>  'Karlsruhe',<br/>  'Erfurt'],<br/> ['Bangalore', 'Kolkata', 'Delhi', 'Mumbai'],<br/> ['NY', 'ALB', 'TX']]</span></pre><p id="e471" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码类似于前面的 BFS 代码。我们将图的所有顶点保存在节点列表中。我们从节点列表中取出一个节点，并在其上启动 BFS。当我们访问一个节点时，我们从节点列表中删除该节点。每当 BFS 完成时，我们从节点列表中的另一个节点开始，直到节点列表为空。</p><p id="53b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，我们能够在数据中找到不同的组件。仅仅通过使用边和顶点。这个算法可以在不同的数据上运行，以满足我上面介绍的任何用例。</p><p id="73ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但通常使用零售案例的连接组件将涉及大量数据，您将需要扩展该算法。</p><h1 id="156a" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">PySpark 中的连接组件</h1><p id="b325" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">下面是这篇论文中关于 MapReduce 中<a class="ae kf" href="https://ai.google/research/pubs/pub43122" rel="noopener ugc nofollow" target="_blank">连接组件的实现，以及 Google Research 中</a>之后的实现。阅读 PPT 以更好地理解实施。一些现成的代码供您使用。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="e6ba" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">或者在 PySpark 中使用 GraphFrames:</h1><p id="168f" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">要安装图表框架:</p><p id="e594" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我在命令行上运行:py spark—packages graphframes:graph frames:0 . 5 . 0-spark 2.1-s _ 2.11，它打开了我的笔记本，并在我尝试在笔记本中导入后安装了 graph frames。</p><p id="30d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要格式化的字符串为:graphframes:(最新版本)-spark(你的 spark 版本)-s_(你的 scala 版本)。</p><p id="5edc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">查看</em> <a class="ae kf" href="http://go.databricks.com/hubfs/notebooks/3-GraphFrames-User-Guide-python.html" rel="noopener ugc nofollow" target="_blank">本指南介绍如何使用 GraphFrames </a>了解更多信息。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="4fb0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">GraphFrames 库实现了 CC 算法以及各种其他图形算法。</p><p id="9d99" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的帖子有很多代码，但希望对你有所帮助。我花了很多时间来实现算法，所以想让它对人们来说很容易。</p><p id="572b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想阅读更多关于图算法的内容，这里有一个由 UCSanDiego 在 Coursera 上开设的<a class="ae kf" href="https://coursera.pxf.io/YgKbbe" rel="noopener ugc nofollow" target="_blank">大数据图分析课程，我强烈推荐你学习图论的基础知识。</a></p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="5610" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请随时在<a class="ae kf" href="https://www.linkedin.com/in/rahulagwl/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上与我联系，在<a class="ae kf" href="https://twitter.com/MLWhiz" rel="noopener ugc nofollow" target="_blank"> Twitter </a> / <a class="ae kf" href="https://medium.com/@rahul_agarwal" rel="noopener"> Medium </a>上关注我，或者给我发消息征求意见。继续收听，继续学习。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="7599" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先发表在我的博客 mlwhiz.com<a class="ae kf" href="http://mlwhiz.com/blog/2018/12/07/connected_components/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h1 id="e087" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">参考</h1><ol class=""><li id="81aa" class="nh ni it ki b kj md kn me kr nj kv nk kz nl ld nm nn no np bi translated"><a class="ae kf" href="https://www.python-course.eu/graphs_python.php" rel="noopener ugc nofollow" target="_blank">Python 中的图形</a></li><li id="bc8e" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated"><a class="ae kf" href="https://medium.com/basecs/a-gentle-introduction-to-graph-theory-77969829ead8" rel="noopener">图论博客简介</a></li><li id="f4c6" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated"><a class="ae kf" href="https://www.coursera.org/learn/big-data-graph-analytics?ranMID=40328&amp;ranEAID=lVarvwc5BD0&amp;ranSiteID=lVarvwc5BD0-uD3tAFL0mCUdzcfwDd6FTQ&amp;siteID=lVarvwc5BD0-uD3tAFL0mCUdzcfwDd6FTQ&amp;utm_content=2&amp;utm_medium=partners&amp;utm_source=linkshare&amp;utm_campaign=lVarvwc5BD0" rel="noopener ugc nofollow" target="_blank">加州大学圣地亚哥分校 Coursera 大数据课程的图表分析</a></li></ol></div></div>    
</body>
</html>