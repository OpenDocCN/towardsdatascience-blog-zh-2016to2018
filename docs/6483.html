<html>
<head>
<title>Time-series Forecasting Flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列预测流程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-forecasting-flow-2e49740664de?source=collection_archive---------14-----------------------#2018-12-15">https://towardsdatascience.com/time-series-forecasting-flow-2e49740664de?source=collection_archive---------14-----------------------#2018-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4112" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需求预测的关键步骤简介</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/7f3d0107b873c536145b8854dd312902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OWUCs5dvoMXQJXQLKUqQRQ.png"/></div></div></figure><blockquote class="kx ky kz"><p id="b132" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">C <strong class="jp ir">收集</strong></p></blockquote><p id="cd92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的关键是数据存储的格式。</p><p id="62da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">直观上，我们认为时间序列数据的格式如下，也称为<strong class="jp ir">宽</strong>格式。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi le"><img src="../Images/d31070dc6ad709604d6515eef87394c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rxq3sLHPiHZeFVThMPzZAg.png"/></div></div></figure><p id="53ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，宽格式对于基于 SQL 的存储是不利的，因为当我们添加新日期时，我们需要向表中添加另一列，因此，最佳实践是以<strong class="jp ir"> long </strong>格式存储数据，如下所示。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lf"><img src="../Images/4a005309ffbe23d468f275ca5dd88aad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z2MAATE8uigIvNyIW6JT4Q.png"/></div></div></figure><p id="ac33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里值得一提的另一件事是，由于我们很可能在这里预测多个产品，一种方便的方法是使用 Python 字典，其中键是产品 ID，值是长数据格式(基本上是一个数据帧)。所以我们最终得到了一个数据框架的字典。</p><blockquote class="kx ky kz"><p id="9638" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated"><strong class="jp ir">清洗</strong></p></blockquote><p id="6ae3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的清洁很标准。基本上我们寻找异常值。通常的做法是，如果我们有奇怪的值，比如需求的固定负数(通常大于或等于 0)，我们就丢弃它们。这里我们需要寻找的另一件事是丢失的值。我们可以使用 pandas fillna 函数，在该函数中，我们指定是否要用 0 来替换它们，或者用诸如 last demand(回填)这样的方法来替换它们。</p><blockquote class="kx ky kz"><p id="9aad" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">测试</p></blockquote><p id="87d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也称为回溯测试。基本上最常见的两种开窗方式，一种是滑动(训练和预测时间固定)，一种是扩展(训练数据长度一次增加 x)。<a class="ae lg" href="https://eng.uber.com/forecasting-introduction/" rel="noopener ugc nofollow" target="_blank">优步</a>做了一项伟大的工作，将以下两种方法形象化。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lh"><img src="../Images/679240695efe96f7fdbc7387832795b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_fn80EUpyTVCL6Q9Dkp3NA.png"/></div></div></figure><p id="7d62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">常见的评估指标包括 MAPE、wMAPE、sMAPE，以及 RMSE 和 RMLSE(如果数据分布是偏斜的)。</p><blockquote class="kx ky kz"><p id="3d1d" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">M <strong class="jp ir">造型</strong></p></blockquote><p id="26db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里最重要的一点是，通常简单的方法(如所有数据点的平均值)优于更复杂的 ARIMA。FB 的 prophet 包(用 R 和 Python 两种语言)也可以是一个首选算法。</p><blockquote class="kx ky kz"><p id="7d1b" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">E <strong class="jp ir">估价</strong></p></blockquote><p id="05f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在评估性能时，我们可以尝试不同的训练和预测长度，以更好地理解我们的数据以及所使用的算法。例如，当训练数据为 1 周，预测数据为下一周时，Naive 方法表现极佳；在训练和预测方面，当我们拥有更长的数据长度时，ARIMA 会大放异彩。换句话说，我们需要首先确定我们的业务用例，无论是短期预测还是长期预测，这样我们才能更好地评估来自不同算法的结果。</p></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><p id="cd7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi lp translated">问问题？</p><p id="cbca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">jchen6912@gmail.com</p></div></div>    
</body>
</html>