<html>
<head>
<title>Time Series Analysis in Python: An Introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的时间序列分析:简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-analysis-in-python-an-introduction-70d5a5b1d52a?source=collection_archive---------0-----------------------#2018-01-13">https://towardsdatascience.com/time-series-analysis-in-python-an-introduction-70d5a5b1d52a?source=collection_archive---------0-----------------------#2018-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/74cfefec5990eb2d69047923f3bc0007.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*5nQ2sdmFTo9hfpDkcqAYnw.jpeg"/></div></figure><div class=""/><p id="0c72" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw iy">用于时间序列建模的可加模型</strong></p><p id="078b" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">时间序列是日常生活中最常见的数据类型之一。金融价格、天气、家庭能源使用量甚至体重都是可以定期收集的数据示例。几乎每个数据科学家都会在日常工作中遇到时间序列，学习如何对它们建模是数据科学工具箱中的一项重要技能。分析和预测周期性数据的一个强大而简单的方法是<a class="ae ks" href="https://en.wikipedia.org/wiki/Additive_model" rel="noopener ugc nofollow" target="_blank">加法模型</a>。这个想法很简单:将时间序列表示为不同尺度的模式组合，比如每天、每周、每季度和每年，以及总体趋势。你的能源消耗可能在夏天上升，在冬天下降，但是随着你提高你家的能源效率，总的趋势是下降的。加法模型可以向我们展示两种模式/趋势，并根据这些观察结果做出预测。</p><p id="3d81" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下图显示了将时间序列分解为总体趋势、年度趋势和周趋势的加法模型。</p><figure class="ku kv kw kx gt is gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/39ab826165d6796f4598b586aeab1656.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*p5l_eKG4we5d8GDzC6o_gg.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Example of Additive Model Decomposition</figcaption></figure><p id="c6ef" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">本文将介绍一个使用Python和脸书开发的<a class="ae ks" href="https://research.fb.com/prophet-forecasting-at-scale/" rel="noopener ugc nofollow" target="_blank"> Prophet预测包为金融时间序列数据创建附加模型的示例。在这个过程中，我们将介绍使用pandas的一些数据操作，使用Quandl库和</a>访问<a class="ae ks" href="https://www.quandl.com/tools/python" rel="noopener ugc nofollow" target="_blank">财务数据，以及使用matplotlib </a>进行<a class="ae ks" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank">绘图。我在有指导意义的地方加入了代码，我鼓励任何人查看GitHub上的</a><a class="ae ks" href="https://github.com/WillKoehrsen/Data-Analysis/tree/master/additive_models" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>以获得完整的分析。这个介绍将向你展示你自己开始建模时间序列所需的所有步骤！</p><p id="540e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">免责声明:现在到了令人厌烦的部分，我不得不提到，当谈到财务数据时，<a class="ae ks" href="https://seekingalpha.com/article/2453345-past-performance-is-not-an-indicator-of-future-results" rel="noopener ugc nofollow" target="_blank">过去的表现不是未来表现的指标</a>，你不能用这里的方法致富。我选择使用股票数据，因为它很容易在每天的频率上获得，而且玩起来很有趣。如果你真的想变得富有，学数据科学是比玩股市更好的选择！</p><h2 id="3877" class="lc ld ix bd le lf lg dn lh li lj dp lk kf ll lm ln kj lo lp lq kn lr ls lt lu bi translated"><strong class="ak">检索财务数据</strong></h2><p id="6168" class="pw-post-body-paragraph ju jv ix jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">通常，花费在数据科学项目上的大约80%的时间是获取和清理数据。多亏了quandl金融库，这个项目的这个比例降低到了5%。Quandl可以从命令行与pip一起安装，让您用一行Python就可以访问数千个财务指标，并且每天允许多达50个请求，无需注册。如果你注册了一个免费账户，你会得到一个允许无限请求的api密匙。</p><p id="a29b" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，我们导入所需的库并获取一些数据。Quandl自动将我们的数据放入pandas dataframe，这是数据科学的首选数据结构。(对于其他公司，只需用股票代码替换“TSLA”或“通用汽车”即可。您也可以指定日期范围)。</p><pre class="ku kv kw kx gt ma mb mc md aw me bi"><span id="2145" class="lc ld ix mb b gy mf mg l mh mi"># quandl for financial data<br/>import quandl<br/># pandas for data manipulation<br/>import pandas as pd</span><span id="e578" class="lc ld ix mb b gy mj mg l mh mi">quandl.ApiConfig.api_key = 'getyourownkey!'</span><span id="238e" class="lc ld ix mb b gy mj mg l mh mi"># Retrieve TSLA data from Quandl<br/>tesla = quandl.get('WIKI/TSLA')</span><span id="6b4a" class="lc ld ix mb b gy mj mg l mh mi"># Retrieve the GM data from Quandl<br/>gm = quandl.get('WIKI/GM')<br/>gm.head(5)</span></pre><figure class="ku kv kw kx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/57906273f07da88f2431847a4621474b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ixT_RnaZVNXh-ZKxKb2fmg.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Snapshot of GM data from quandl</figcaption></figure><p id="3002" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">关于quandl的数据几乎是无限的，但我想重点比较同一行业的两家公司，即特斯拉和通用汽车。特斯拉是一家令人着迷的公司，不仅因为它是111年来第一家成功的美国汽车初创公司，还因为在2017年的<a class="ae ks" href="https://www.recode.net/2017/8/2/16085822/tesla-ford-gm-worth-car-manufacturer-elon-musk-earnings" rel="noopener ugc nofollow" target="_blank">中，尽管只销售了4种不同的汽车，但它仍是美国最有价值的汽车公司</a>。最有价值汽车公司头衔的另一个竞争者是通用汽车公司，该公司最近显示出拥抱汽车未来的迹象，制造了一些非常酷(但看起来不酷)的全电动汽车。</p><figure class="ku kv kw kx gt is gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/7b79c327b9c855111899da0a81680861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*fqcIBhw_xHHgdGe1s74ciA.jpeg"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Not a very hard choice</figcaption></figure><p id="efea" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以轻松地花费数小时来搜索这些数据，并将其下载为csv电子表格文件，但是，多亏了quandl，我们在几秒钟内就获得了所有需要的数据！</p><h1 id="d9fc" class="mq ld ix bd le mr ms mt lh mu mv mw lk mx my mz ln na nb nc lq nd ne nf lt ng bi translated">数据探索</h1><p id="99e6" class="pw-post-body-paragraph ju jv ix jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">在我们开始建模之前，最好通过绘制一些探索图来了解一下结构和范围。这也将允许我们寻找需要纠正的异常值或缺失值。</p><p id="2aae" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">熊猫数据帧可以很容易地用matplotlib绘制。如果任何图形代码看起来吓人，不要担心。我还发现matplotlib不直观，经常从堆栈溢出或文档中复制并粘贴示例来获得我想要的图形。编程的规则之一是不要重新发明一个已经存在的解决方案！</p><pre class="ku kv kw kx gt ma mb mc md aw me bi"><span id="8c5e" class="lc ld ix mb b gy mf mg l mh mi"># The adjusted close accounts for stock splits, so that is what we should graph<br/>plt.plot(gm.index, gm['Adj. Close'])<br/>plt.title('GM Stock Price')<br/>plt.ylabel('Price ($)');<br/>plt.show()</span><span id="04cc" class="lc ld ix mb b gy mj mg l mh mi">plt.plot(tesla.index, tesla['Adj. Close'], 'r')<br/>plt.title('Tesla Stock Price')<br/>plt.ylabel('Price ($)');<br/>plt.show();</span></pre><figure class="ku kv kw kx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nh"><img src="../Images/ccbdb889f4a03ecab0ba25794dcb555e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0O-F4teSoUK_hs95LdNw4w.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Raw Stock Prices</figcaption></figure><p id="cef5" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">仅从股价上比较两家公司并不能说明哪家更有价值，因为公司的总价值(市值)还取决于股票数量(市值=股价*股票数量)。Quandl没有股票数量的数据，但我可以通过快速的谷歌搜索找到两家公司的平均年度股票。虽然不精确，但对我们的分析来说足够精确了。有时候我们不得不用不完美的数据来凑合！</p><p id="887a" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了在我们的数据框架中创建一列市值，我们使用了一些pandas的技巧，比如将索引移动到一列(reset_index ),同时使用ix 索引和修改数据框架<a class="ae ks" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.ix.html" rel="noopener ugc nofollow" target="_blank">中的值。</a></p><pre class="ku kv kw kx gt ma mb mc md aw me bi"><span id="aeaa" class="lc ld ix mb b gy mf mg l mh mi"># Yearly average number of shares outstanding for Tesla and GM<br/>tesla_shares = {2018: 168e6, 2017: 162e6, 2016: 144e6, 2015: 128e6, 2014: 125e6, 2013: 119e6, 2012: 107e6, 2011: 100e6, 2010: 51e6}</span><span id="09c5" class="lc ld ix mb b gy mj mg l mh mi">gm_shares = {2018: 1.42e9, 2017: 1.50e9, 2016: 1.54e9, 2015: 1.59e9, 2014: 1.61e9, 2013: 1.39e9, 2012: 1.57e9, 2011: 1.54e9, 2010:1.50e9}</span><span id="386f" class="lc ld ix mb b gy mj mg l mh mi"># Create a year column <br/>tesla['Year'] = tesla.index.year</span><span id="b191" class="lc ld ix mb b gy mj mg l mh mi"># Take Dates from index and move to Date column <br/>tesla.reset_index(level=0, inplace = True)<br/>tesla['cap'] = 0</span><span id="4c61" class="lc ld ix mb b gy mj mg l mh mi"># Calculate market cap for all years<br/>for i, year in enumerate(tesla['Year']):<br/>    # Retrieve the shares for the year<br/>    shares = tesla_shares.get(year)<br/>    <br/>    # Update the cap column to shares times the price<br/>    tesla.ix[i, 'cap'] = shares * tesla.ix[i, 'Adj. Close']</span></pre><p id="e40d" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这为特斯拉创造了一个“上限”栏。我们对GM数据做同样的处理，然后合并两者。<a class="ae ks" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.merge.html" rel="noopener ugc nofollow" target="_blank">合并</a>是数据科学工作流的重要组成部分，因为它允许我们在共享列上连接数据集。在这种情况下，我们有两个不同公司在相同日期的股票价格，因此我们希望连接日期列上的数据。我们执行“内部”合并，只保存同时出现在两个数据帧中的日期条目。合并后，我们重命名这些列，这样我们就知道哪一列对应哪一家汽车公司。</p><pre class="ku kv kw kx gt ma mb mc md aw me bi"><span id="dc20" class="lc ld ix mb b gy mf mg l mh mi"># Merge the two datasets and rename the columns<br/>cars = gm.merge(tesla, how='inner', on='Date')</span><span id="a242" class="lc ld ix mb b gy mj mg l mh mi">cars.rename(columns={'cap_x': 'gm_cap', 'cap_y': 'tesla_cap'}, inplace=True)</span><span id="add7" class="lc ld ix mb b gy mj mg l mh mi"># Select only the relevant columns<br/>cars = cars.ix[:, ['Date', 'gm_cap', 'tesla_cap']]</span><span id="2799" class="lc ld ix mb b gy mj mg l mh mi"># Divide to get market cap in billions of dollars<br/>cars['gm_cap'] = cars['gm_cap'] / 1e9<br/>cars['tesla_cap'] = cars['tesla_cap'] / 1e9</span><span id="40be" class="lc ld ix mb b gy mj mg l mh mi">cars.head()</span></pre><figure class="ku kv kw kx gt is gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/e31d2c97ed148d5dfb8e744e96715c19.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*kynRnPfMkB8i4VKWdVmWnQ.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Merged Market Capitalization Dataframe</figcaption></figure><p id="2aba" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">市值以十亿美元计。我们可以看到，在我们的分析期开始时，通用汽车的市值大约是特斯拉的30倍！事情会在整个时间线上保持不变吗？</p><pre class="ku kv kw kx gt ma mb mc md aw me bi"><span id="d06f" class="lc ld ix mb b gy mf mg l mh mi">plt.figure(figsize=(10, 8))<br/>plt.plot(cars['Date'], cars['gm_cap'], 'b-', label = 'GM')<br/>plt.plot(cars['Date'], cars['tesla_cap'], 'r-', label = 'TESLA')<br/>plt.xlabel('Date'); plt.ylabel('Market Cap (Billions $)'); plt.title('Market Cap of GM and Tesla')<br/>plt.legend();</span></pre><figure class="ku kv kw kx gt is gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/a0850d64c5cc0650089ea93530a3268d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*JA-_jUVv1B6b2TgRWnFEIg.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Market Capitalization Historical Data</figcaption></figure><p id="dce5" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在数据过程中，我们观察到特斯拉的快速增长和通用汽车的小幅增长。2017年期间，特斯拉的价值甚至超过了通用汽车！</p><pre class="ku kv kw kx gt ma mb mc md aw me bi"><span id="6a8b" class="lc ld ix mb b gy mf mg l mh mi">import numpy as np</span><span id="a1a5" class="lc ld ix mb b gy mj mg l mh mi"># Find the first and last time Tesla was valued higher than GM<br/>first_date = cars.ix[np.min(list(np.where(cars['tesla_cap'] &gt; cars['gm_cap'])[0])), 'Date']<br/>last_date = cars.ix[np.max(list(np.where(cars['tesla_cap'] &gt; cars['gm_cap'])[0])), 'Date']</span><span id="a72d" class="lc ld ix mb b gy mj mg l mh mi">print("Tesla was valued higher than GM from {} to {}.".format(first_date.date(), last_date.date()))</span><span id="f837" class="lc ld ix mb b gy mj mg l mh mi"><strong class="mb iy">Tesla was valued higher than GM from 2017-04-10 to 2017-09-21.</strong></span></pre><p id="3f1d" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在此期间，特斯拉卖了大约<a class="ae ks" href="https://en.wikipedia.org/wiki/Tesla,_Inc.#Production_and_sales" rel="noopener ugc nofollow" target="_blank"> 48，000辆</a>，而<a class="ae ks" href="http://gmauthority.com/blog/gm/general-motors-sales-numbers/" rel="noopener ugc nofollow" target="_blank">通用卖了1，500，000辆</a>。在一段时间内，通用汽车的销量是特斯拉的30倍，但其价值却低于特斯拉！这无疑展示了一个有说服力的高管和一个高质量(尽管数量非常少)产品的力量。虽然特斯拉的价值现在低于通用汽车，但一个好问题可能是，我们能期待特斯拉再次超过通用汽车吗？什么时候会这样？为此，我们求助于加法模型进行预测，或者换句话说，预测未来。</p><h1 id="792e" class="mq ld ix bd le mr ms mt lh mu mv mw lk mx my mz ln na nb nc lq nd ne nf lt ng bi translated">用先知建模</h1><p id="b2c3" class="pw-post-body-paragraph ju jv ix jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated"><a class="ae ks" href="https://facebook.github.io/prophet/docs/quick_start.html" rel="noopener ugc nofollow" target="_blank">2017年Python和R发布了脸书先知包</a>，全世界的数据科学家都欢欣鼓舞。Prophet设计用于分析具有日常观察的时间序列，这些观察显示不同时间尺度上的模式。它还具有高级功能，可以对假日对时间序列的影响进行建模，并实现自定义的变点，但我们将坚持使用基本功能来启动和运行模型。Prophet和quandl一样，可以从命令行安装pip。</p><p id="f2aa" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们首先导入prophet，并将数据中的列重命名为正确的格式。日期列必须称为' ds '，而我们要预测的值列必须称为' y '。然后，我们创建prophet模型并使其符合数据，就像Scikit-Learn机器学习模型一样:</p><pre class="ku kv kw kx gt ma mb mc md aw me bi"><span id="74b0" class="lc ld ix mb b gy mf mg l mh mi">import fbprophet</span><span id="246c" class="lc ld ix mb b gy mj mg l mh mi"># Prophet requires columns ds (Date) and y (value)<br/>gm = gm.rename(columns={'Date': 'ds', 'cap': 'y'})</span><span id="af82" class="lc ld ix mb b gy mj mg l mh mi"># Put market cap in billions<br/>gm['y'] = gm['y'] / 1e9</span><span id="baa6" class="lc ld ix mb b gy mj mg l mh mi"># Make the prophet model and fit on the data<br/>gm_prophet = fbprophet.Prophet(changepoint_prior_scale=0.15)<br/>gm_prophet.fit(gm)</span></pre><p id="76c1" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当创建prophet模型时，我将changepoint设置在0.15之前，高于默认值0.05。该超参数用于控制<a class="ae ks" href="https://facebook.github.io/prophet/docs/trend_changepoints.html" rel="noopener ugc nofollow" target="_blank">趋势对变化</a>的敏感程度，数值越高越敏感，数值越低越不敏感。这个值用于对抗机器学习中最基本的权衡之一:<a class="ae ks" href="https://en.wikipedia.org/wiki/Bias%E2%80%93variance_tradeoff" rel="noopener ugc nofollow" target="_blank">偏差与方差</a>。</p><p id="be6b" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果我们太接近我们的训练数据，称为<a class="ae ks" href="https://elitedatascience.com/overfitting-in-machine-learning" rel="noopener ugc nofollow" target="_blank">过拟合</a>，我们有太多的方差，我们的模型将不能很好地推广到新数据。另一方面，如果我们的模型没有捕捉到训练数据中的趋势，那么它就不合适，并且有太多的偏差。当模型拟合不足时，增加变点先验允许模型更灵活地拟合数据，如果模型拟合过度，减少先验会限制灵活性。变点先验比例的影响可以通过用一系列值做出的图形预测来说明:</p><figure class="ku kv kw kx gt is gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/71aed299a2ccc81268e0c1d710f4165a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*jEFOLncknBJ8cPQSBQDktA.png"/></div></figure><p id="e1d2" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">变点先验比例越高，模型就越灵活，越符合训练数据。这可能看起来正是我们想要的，但是学习训练数据太好可能会导致过度拟合，并且无法准确地对新数据进行预测。因此，我们需要在拟合训练数据和能够推广到新数据之间找到恰当的平衡。由于股票每天都在变化，我们希望我们的模型能够捕捉到这一点，所以在尝试了一系列值后，我增加了灵活性。</p><p id="b43c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在创建prophet模型的调用中，我们还可以指定变点，当时间序列从增加到减少，或从缓慢增加到快速增加时，会出现这些变点(它们位于时间序列中速率变化最大的位置<a class="ae ks" href="https://facebook.github.io/prophet/docs/trend_changepoints.html" rel="noopener ugc nofollow" target="_blank">)。转折点可能对应于重大事件，如产品发布或市场中的宏观经济波动。如果我们不指定变点，prophet将为我们计算它们。</a></p><p id="045d" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了进行预测，我们需要创建一个所谓的未来数据框架。我们指定要预测的未来周期数(两年)和预测频率(每天)。然后，我们用我们创建的先知模型和未来数据框架进行预测:</p><pre class="ku kv kw kx gt ma mb mc md aw me bi"><span id="42c8" class="lc ld ix mb b gy mf mg l mh mi"># Make a future dataframe for 2 years<br/>gm_forecast = gm_prophet.make_future_dataframe(periods=365 * 2, freq='D')</span><span id="5662" class="lc ld ix mb b gy mj mg l mh mi"># Make predictions<br/>gm_forecast = gm_prophet.predict(gm_forecast)</span></pre><p id="7908" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们未来的数据框架包含特斯拉和通用汽车未来两年的估计市值。我们可以用prophet plot函数可视化预测。</p><pre class="ku kv kw kx gt ma mb mc md aw me bi"><span id="3ff4" class="lc ld ix mb b gy mf mg l mh mi">gm_prophet.plot(gm_forecast, xlabel = 'Date', ylabel = 'Market Cap (billions $)')<br/>plt.title('Market Cap of GM');</span></pre><figure class="ku kv kw kx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nk"><img src="../Images/80d0637710266646ce2565b59727641e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OSW5XSzx-EmefhkXjhICuw.png"/></div></div></figure><p id="b04c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">黑点代表实际值(注意它们如何在2018年初停止)，蓝线表示预测值，浅蓝色阴影区域是不确定性(<a class="ae ks" href="https://medium.com/@williamkoehrsen/a-theory-of-prediction-10cb335cc3f2" rel="noopener">始终是任何预测</a>的关键部分)。由于初始不确定性会随着时间的推移而传播和增长，因此预测的不确定性区域会越来越大。这可以在<a class="ae ks" href="http://www.nytimes.com/2012/09/09/magazine/the-weatherman-is-not-a-moron.html" rel="noopener ugc nofollow" target="_blank">的天气预报中观察到，天气预报的时间越长越不准确</a>。</p><p id="45b8" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们还可以检查由模型识别的变更点。同样，变点表示时间序列增长率显著变化的时间(例如，从增加到减少)。</p><pre class="ku kv kw kx gt ma mb mc md aw me bi"><span id="af67" class="lc ld ix mb b gy mf mg l mh mi">tesla_prophet.changepoints[:10]</span><span id="8fa4" class="lc ld ix mb b gy mj mg l mh mi"><strong class="mb iy">61    2010-09-24<br/>122   2010-12-21<br/>182   2011-03-18<br/>243   2011-06-15<br/>304   2011-09-12<br/>365   2011-12-07<br/>425   2012-03-06<br/>486   2012-06-01<br/>547   2012-08-28<br/>608   2012-11-27</strong></span></pre><p id="860f" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了比较，我们可以看看这段时间内<a class="ae ks" href="https://trends.google.com/trends/explore?date=2010-09-01%202013-01-01&amp;q=Tesla%20Motors" rel="noopener ugc nofollow" target="_blank">谷歌对特斯拉</a>的搜索趋势，看看变化是否一致。我们在同一张图上绘制了变化点(垂直线)和搜索趋势:</p><pre class="ku kv kw kx gt ma mb mc md aw me bi"><span id="ce83" class="lc ld ix mb b gy mf mg l mh mi"># Load in the data <br/>tesla_search = pd.read_csv('data/tesla_search_terms.csv')</span><span id="447e" class="lc ld ix mb b gy mj mg l mh mi"># Convert month to a datetime<br/>tesla_search['Month'] = pd.to_datetime(tesla_search['Month'])<br/>tesla_changepoints = [str(date) for date in tesla_prophet.changepoints]</span><span id="acc5" class="lc ld ix mb b gy mj mg l mh mi"># Plot the search frequency<br/>plt.plot(tesla_search['Month'], tesla_search['Search'], label = 'Searches')</span><span id="b00f" class="lc ld ix mb b gy mj mg l mh mi"># Plot the changepoints<br/>plt.vlines(tesla_changepoints, ymin = 0, ymax= 100, colors = 'r', linewidth=0.6, linestyles = 'dashed', label = 'Changepoints')</span><span id="d3a8" class="lc ld ix mb b gy mj mg l mh mi"># Formatting of plot<br/>plt.grid('off'); plt.ylabel('Relative Search Freq'); plt.legend()<br/>plt.title('Tesla Search Terms and Changepoints');</span></pre><figure class="ku kv kw kx gt is gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/27812cf04d2f6c074c412c6acac08406.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*rSuNyepHa9lvQeDClGL5XA.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Tesla Search Frequency and Stock Changepoints</figcaption></figure><p id="3e70" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">特斯拉市值的一些变化点与特斯拉搜索频率的变化一致，但不是全部。由此，我会说相对谷歌搜索频率并不是一个很好的股票变化指标。</p><p id="27ae" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们仍然需要弄清楚特斯拉的市值何时会超过通用汽车。由于我们对未来两年都有预测，合并数据框架后，我们可以在同一张图上绘制两家公司。在合并之前，我们重命名列以跟踪数据。</p><pre class="ku kv kw kx gt ma mb mc md aw me bi"><span id="a22c" class="lc ld ix mb b gy mf mg l mh mi">gm_names = ['gm_%s' % column for column in gm_forecast.columns]<br/>tesla_names = ['tesla_%s' % column for column in tesla_forecast.columns]</span><span id="dc9a" class="lc ld ix mb b gy mj mg l mh mi"># Dataframes to merge<br/>merge_gm_forecast = gm_forecast.copy()<br/>merge_tesla_forecast = tesla_forecast.copy()</span><span id="02b0" class="lc ld ix mb b gy mj mg l mh mi"># Rename the columns<br/>merge_gm_forecast.columns = gm_names<br/>merge_tesla_forecast.columns = tesla_names</span><span id="91b8" class="lc ld ix mb b gy mj mg l mh mi"># Merge the two datasets<br/>forecast = pd.merge(merge_gm_forecast, merge_tesla_forecast, how = 'inner', left_on = 'gm_ds', right_on = 'tesla_ds')</span><span id="ada6" class="lc ld ix mb b gy mj mg l mh mi"># Rename date column<br/>forecast = forecast.rename(columns={'gm_ds': 'Date'}).drop('tesla_ds', axis=1)</span></pre><p id="1854" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，我们将只绘制估计值。估计值(在prophet软件包中称为“yhat ”)消除了数据中的一些噪声，因此它看起来与原始图略有不同。平滑程度将取决于变点先验比例-更高的先验意味着更灵活的模型和更多的起伏。</p><figure class="ku kv kw kx gt is gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/38407edf891ae16382e632a96b9faa6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*wtXXjTJK2J9MQFFkyGyhwA.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">GM and Tesla Predicted Market Capitalization</figcaption></figure><p id="1341" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的模型认为，特斯拉在2017年短暂超越通用汽车只是一个噪音，直到2018年初，特斯拉才在预测中永远击败通用汽车。确切的日期是2018年1月27日，所以如果这种情况发生，我会很高兴地因为预测未来而受到表扬！</p><p id="f13c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">制作上图时，我们忽略了预测中最重要的部分:不确定性！我们可以使用matplotlib(参见<a class="ae ks" href="https://github.com/WillKoehrsen/Data-Analysis/blob/master/additive_models/Additive%20Models%20for%20Prediction.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>)来显示有疑问的区域:</p><figure class="ku kv kw kx gt is gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/9fa1d1833a26b7468499268b528056f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*0rt_W8NzoFG_WQ0I9mncyg.png"/></div></figure><p id="5e0f" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是预测的一个更好的表示。这表明两家公司的价值都有望增加，但特斯拉的增长将比通用汽车更快。同样，不确定性随着时间的推移而增加，正如预测所预期的那样，特斯拉的下限低于通用汽车在2020年的上限，这意味着通用汽车可能会保持领先地位。</p><h2 id="5239" class="lc ld ix bd le lf lg dn lh li lj dp lk kf ll lm ln kj lo lp lq kn lr ls lt lu bi translated">趋势和模式</h2><p id="1362" class="pw-post-body-paragraph ju jv ix jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">市值分析的最后一步是查看整体趋势和模式。Prophet使我们能够轻松地可视化整体趋势和组件模式:</p><pre class="ku kv kw kx gt ma mb mc md aw me bi"><span id="3b83" class="lc ld ix mb b gy mf mg l mh mi"># Plot the trends and patterns<br/>gm_prophet.plot_components(gm_forecast)</span></pre><figure class="ku kv kw kx gt is gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/bdde5825b986ac4449df00f9b20094e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*TUWWhcVj8tHLEptgegyYRQ.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">General Motors Time Series Decomposition</figcaption></figure><p id="40cf" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">趋势非常明显:通用汽车的股票正在上涨，并将继续上涨。每年的模式很有趣，因为它似乎表明通用汽车的价值在年底增加，并在夏季缓慢下降。我们可以尝试确定在一段时间内通用汽车的年度市值和平均月销售额之间是否存在相关性。我首先从谷歌收集每月的汽车销量，然后用groupby计算几个月的平均值。这是另一个关键的数据科学操作，因为我们经常想要比较不同类别的统计数据，例如特定年龄组的用户，或者来自一个制造商的车辆。在这种情况下，我们希望计算每个月的平均销售额，因此我们将这些月份组合在一起，然后计算销售额的平均值。</p><pre class="ku kv kw kx gt ma mb mc md aw me bi"><span id="3b6a" class="lc ld ix mb b gy mf mg l mh mi">gm_sales_grouped = gm_sales.groupby('Month').mean()</span></pre><figure class="ku kv kw kx gt is gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/1464a139d08a912515085a3934ac768a.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*8SXNjfI4XBaINxGVQIUndg.png"/></div></figure><p id="3d85" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">看起来月销售额与市值并不相关。8月单月销量第二高，正好在市值最低点！</p><p id="63b6" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">查看每周趋势，似乎没有任何有意义的信号(周末没有记录股票价格，所以我们查看一周内的变化)。这是意料之中的，因为经济学中的<a class="ae ks" href="https://www.investopedia.com/terms/r/randomwalktheory.asp" rel="noopener ugc nofollow" target="_blank">随机游走理论</a>指出，股票价格每天都没有可预测的模式。正如我们的分析所证明的，从长期来看，股票往往会增加，但在日常尺度上，即使有最好的模型，我们也几乎没有可以利用的模式。</p><p id="fa81" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">简单看一下<a class="ae ks" href="https://en.wikipedia.org/wiki/Dow_Jones_Industrial_Average" rel="noopener ugc nofollow" target="_blank">道琼斯工业平均指数</a>(股票交易所30家最大公司的市场指数)就能很好地说明这一点:</p><figure class="ku kv kw kx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi no"><img src="../Images/f48fa64fffc7954aefee589750626acf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5OHpAvp_w5g7jccqJ8OYaA.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Dow Jones Industrial Average (<a class="ae ks" href="http://www.cityam.com/257792/dow-jones-industrial-average-breaks-20000-first-time" rel="noopener ugc nofollow" target="_blank">Source</a>)</figcaption></figure><p id="895e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">很明显，这个信息是回到1900年，投资你的钱！或者在现实中，当市场下跌时，不要退出，因为根据历史，它会重新上涨。总的来说，每天的波动太小，甚至看不到，如果我们像数据科学家一样思考，我们会意识到，与投资整个市场并长期持有相比，每天玩股票是愚蠢的。</p><p id="887c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Prophet还可以应用于更大规模的数据测量，如国内生产总值，这是一个国家经济总体规模的衡量指标。我根据美国和中国的历史GDP建立了先知模型，做出了以下预测。</p><figure class="ku kv kw kx gt is gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/f88c37601243656ef9c5f43a64feffcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*1I9G9ek3oXmuS2Fa9KVf9g.png"/></div></figure><p id="2fdc" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">中国GDP超过美国的确切日期是2036年！由于观察频率低(GDP每季度测量一次，但prophet使用每日数据效果最佳)，该模型存在局限性，但它提供了一个基本预测，不需要宏观经济知识。</p><p id="965e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有许多方法可以对时间序列建模，从<a class="ae ks" href="https://onlinecourses.science.psu.edu/stat501/node/250" rel="noopener ugc nofollow" target="_blank">简单的线性回归</a>到<a class="ae ks" href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" rel="noopener ugc nofollow" target="_blank">带有LSTM细胞的递归神经网络</a>。加法模型是有用的，因为它们开发快，训练快，提供可解释的模式，并做出具有不确定性的预测。Prophet的能力令人印象深刻，我们在这里只是触及了皮毛。我鼓励你利用这篇文章和笔记本来探索Quandl 提供的一些<a class="ae ks" href="https://www.quandl.com/search?query=" rel="noopener ugc nofollow" target="_blank">数据或者你自己的时间序列。请继续关注时间序列分析的未来工作，以及prophet在我日常生活中的应用，参见我在</a><a class="ae ks" rel="noopener" target="_blank" href="/data-science-a-practical-application-7056ec22d004">上的帖子，使用这些技术来建模和预测体重变化。</a>作为探索时间序列的第一步，Python中的附加模型是必由之路！</p><p id="5354" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一如既往，我欢迎反馈和建设性的批评。可以在wjk68@case.edu找到我。</p></div></div>    
</body>
</html>