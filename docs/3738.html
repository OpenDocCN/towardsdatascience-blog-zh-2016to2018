<html>
<head>
<title>IoT Made Easy: ESP-MicroPython-MQTT-ThingSpeak</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">物联网变得简单:ESP-MicroPython-MQTT-thing speak</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/iot-made-easy-esp-micropython-mqtt-thingspeak-ce05eea27814?source=collection_archive---------3-----------------------#2018-06-13">https://towardsdatascience.com/iot-made-easy-esp-micropython-mqtt-thingspeak-ce05eea27814?source=collection_archive---------3-----------------------#2018-06-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f077" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用 MQTT 协议，我们将从传感器获取捕获的数据，并将它们记录到物联网服务 ThingSpeak.com 和移动应用 Thingsview。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/80dd16ca65587afa02d39fafd4ae14eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MnjfiP1pOkQRtvl7GTaZKA.png"/></div></div></figure><h2 id="4e2d" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">1.介绍</h2><p id="1c2f" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">在我的上一篇文章<a class="ae lv" href="https://medium.com/@rovai/micropython-on-esp-using-jupyter-6f366ff5ed9" rel="noopener">MicroPython on ESP using Jupyter</a>中，我们学习了如何在 ESP 设备上安装和运行 MicroPython。使用 Jupyter Notebook 作为我们的开发环境，我们还学习了如何使用多种通信协议和方法从传感器读取数据(温度、湿度和亮度)，例如:模拟、数字、1 线和 I2C，后者用于在有机发光二极管显示器上显示我们捕获的数据。</p><p id="aa71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在这篇文章中，使用 MQTT 协议，我们将获得所有捕获的数据，将它们发送到物联网服务，【ThingSpeak.com】和移动应用，<em class="lw"> Thingsview </em>，在那里可以记录和播放它们。</p><p id="070b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是对我们的项目进行重新升级的概述:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/e54c1d2912bf55b285596b925c862e48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*M10grG85terQk6gS"/></div></figure><h2 id="2ec2" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">2.硬件</h2><p id="4a58" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">将要使用的硬件基本上与之前的项目相同:<a class="ae lv" href="https://medium.com/@rovai/micropython-on-esp-using-jupyter-6f366ff5ed9" rel="noopener">使用 Jupyter 的 ESP 上的 Micropython</a>。请参考它的详细硬件解释(例外是伺服，这将不会在这个项目中使用)。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/88208e9f951e56eca4fd28842deb978e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*bCWqVIQABWFv92Qh"/></div></figure><p id="45f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面你可以看到完整的硬件。如图所示连接设备。</p><h2 id="7c4d" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">3.Micropython，REPL 和 Jupyter 笔记本</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ly"><img src="../Images/9043bdf4b2e51a7f1a0ce29c710e8f2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EkXSGEX69pZ_iQipI5d6-Q.png"/></div></div></figure><p id="eeb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，您应该在您的 ESP 设备上加载了一个 Micropython 解释器，因此可以使用任何可用的 ide 对其进行编程，比如:</p><ul class=""><li id="b478" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated">REPL /Ampy</li><li id="0df9" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">Jupyter 笔记本(*)</li><li id="4fc3" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">希腊字母表中第十二个字母</li><li id="4ed0" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">ESPCut(仅适用于 Windows)</li><li id="fe7d" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">…等等</li></ul><p id="fac8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的文章<a class="ae lv" href="https://medium.com/@rovai/micropython-on-esp-using-jupyter-6f366ff5ed9" rel="noopener">Micropython on ESP Using Jupyter</a>中，我详细介绍了如何下载和安装 Micropython 解释器、ESPTool 来管理 ESP 设备，以及如何使用 Jupyter Notebook 作为<em class="lw">开发环境。</em>您可以随意使用更舒适的产品。</p><blockquote class="mn mo mp"><p id="f900" class="jn jo lw jp b jq jr js jt ju jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj kk ij bi translated">(*)我一般都是在 Jupyter Notebook 上做所有开发，一旦得到最终代码，就把它们复制到 Geany，保存为 python 脚本。使用 Ampy 将脚本上传到 ESP 上。我发现这种方法非常容易创建更复杂和专业的项目。</p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mt"><img src="../Images/00fcf9928160631271b788a72fd8cb8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*HaKx_KlIMOBczSJrRyvvOA.png"/></div></div></figure><h2 id="924c" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">4.传感器</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/58843ccd38aac984df1d9320ba93196a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/0*_Ns35MP4aqKO4pMk"/></div></figure><p id="5d5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们安装库，定义 GPIOs，分别为所有传感器创建对象和函数:</p><p id="912e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> A. DHT(温度和湿度)</strong></p><p id="8ecd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装 DHT 库并创建一个对象:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="3ce5" class="kx ky iq mw b gy na nb l nc nd">from dht import DHT22<br/>from machine import Pin<br/>dht22 = DHT22(Pin(12))</span></pre><p id="439e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个函数来读取 DHT 传感器:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="a330" class="kx ky iq mw b gy na nb l nc nd">def readDht():<br/>    dht22.measure()<br/>    return dht22.temperature(), dht22.humidity()</span></pre><p id="eb7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试 DHT 功能:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="891d" class="kx ky iq mw b gy na nb l nc nd">print (readDht())</span></pre><p id="314e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果应该是如下所示的元组:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="b170" class="kx ky iq mw b gy na nb l nc nd">(17.7, 43.4)</span></pre><p id="6111" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> B. DS18B20(外部温度)</strong></p><p id="08bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装库并创建一个对象:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="b3f7" class="kx ky iq mw b gy na nb l nc nd">import onewire, ds18x20<br/>import time</span><span id="cf91" class="kx ky iq mw b gy ne nb l nc nd"># Define the pin to be used with 1-wire bus ==&gt; pin 2 (D4)<br/>dat = Pin(2)</span><span id="e0a5" class="kx ky iq mw b gy ne nb l nc nd"># create the onewire object<br/>ds = ds18x20.DS18X20(onewire.OneWire(dat))</span></pre><p id="bfa1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">扫描总线上的设备</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="5c02" class="kx ky iq mw b gy na nb l nc nd">sensors = ds.scan()<br/>print('found devices:', sensors)</span></pre><p id="ccf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打印结果并不重要，我们需要的是第一个检测到的传感器:<em class="lw">传感器[0] </em>。现在，我们可以构建一个函数来读取传感器数据:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="a9b6" class="kx ky iq mw b gy na nb l nc nd">def readDs():<br/>    ds.convert_temp()<br/>    time.sleep_ms(750)<br/>    return ds.read_temp(sensors[0])</span></pre><p id="c019" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用创建的函数测试传感器总是很重要的</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="a35e" class="kx ky iq mw b gy na nb l nc nd">print(readDs())</span></pre><p id="1fd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你得到一个温度值，你的代码是正确的:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="9e85" class="kx ky iq mw b gy na nb l nc nd">17.5</span></pre><p id="5bed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">LDR(光度)</strong></p><p id="f1ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">LDR 将使用我们的 ESP 的模拟引脚(在 ESP8266 的情况下只有一个，在 ESP32 中有几个)。</p><p id="ea66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与之前相同:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="8b11" class="kx ky iq mw b gy na nb l nc nd"># import library<br/>from machine import ADC</span><span id="50bc" class="kx ky iq mw b gy ne nb l nc nd"># Define object<br/>adc = ADC(0)</span></pre><p id="61ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个简单的函数:<em class="lw"> adc.read() </em>可以用来读取 adc 值。但请记住，内部 ADC 会将 0 到 3.3V 之间的电压转换为相应的数字值，范围从 0 到 1023。一旦我们对“光度”感兴趣，我们就会认为最大光是传感器捕捉到的最大值(在我的例子中是 900)，最小光是 40。有了这些值，我们就可以将亮度值从[40 到 900]映射到[0 到 100%]。为此，我们将创建一个新函数:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="87ba" class="kx ky iq mw b gy na nb l nc nd">def readLdr():<br/>    lumPerct = (adc.read()-40)*(10/86) <br/>    return round(lumPerct)</span></pre><p id="f5ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你应该使用<em class="lw"> print (readLDR()) </em>来测试这个函数。结果应该是 0 到 100 之间的整数。</p><p id="e257" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> D .按钮(数字输入)</strong></p><p id="6d2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们使用一个按钮作为“数字传感器”，但它可能是一个执行器的“回声”(例如，一个开/关的泵)。</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="566e" class="kx ky iq mw b gy na nb l nc nd"># define pin 13 as an input and activate an internal Pull-up resistor:<br/>button = Pin(13, Pin.IN, Pin.PULL_UP)</span><span id="f76a" class="kx ky iq mw b gy ne nb l nc nd"># Function to read button state:<br/>def readBut():<br/>    return button.value()</span></pre><p id="521f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用功能<em class="lw"> print(readBut()) </em>测试按钮。如果不按，结果应该是“1”。按下按钮，结果应该是“0”。</p><h2 id="bc7c" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">5.捕获并在本地显示所有传感器数据</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/9f5cd9b198b42fbca04f1f1372fec1de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*rCF-00yjEeCEa88j"/></div></figure><p id="129f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们已经为每个传感器创建了一个函数，让我们创建另一个函数，负责同时读取所有传感器:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="ed0f" class="kx ky iq mw b gy na nb l nc nd">def colectData():<br/>    temp, hum, = readDht()<br/>    extTemp = readDs()<br/>    lum = readLdr()<br/>    butSts = readBut()<br/>    return temp, hum, extTemp, lum, butSts</span></pre><p id="03f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，使用:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="4737" class="kx ky iq mw b gy na nb l nc nd">print(colectData())</span></pre><p id="9a70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将产生一个元组，其中包括从传感器捕获的所有数据:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="af8e" class="kx ky iq mw b gy na nb l nc nd">(17.4, 45.2, 17.3125, 103, 1)</span></pre><p id="ae94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以选择在本地显示器上显示这些数据:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="464d" class="kx ky iq mw b gy na nb l nc nd"># import library and create object i2c<br/>from machine import I2C<br/>i2c = I2C(scl=Pin(5), sda=Pin(4))</span><span id="0a96" class="kx ky iq mw b gy ne nb l nc nd"># import library and create object oled<br/>import ssd1306<br/>i2c = I2C(scl=Pin(5), sda=Pin(4))<br/>oled = ssd1306.SSD1306_I2C(128, 64, i2c, 0x3c)</span><span id="6d0a" class="kx ky iq mw b gy ne nb l nc nd"># create a function:<br/>def displayData(temp, hum, extTemp, lum, butSts):<br/>    oled.fill(0)<br/>    oled.text("Temp:    " + str(temp) + "oC", 0, 4)<br/>    oled.text("Hum:     " + str(hum) + "%",0, 16)<br/>    oled.text("ExtTemp: " + str(extTemp) + "oC", 0, 29)<br/>    oled.text("Lumin:   " + str(lum) + "%", 0, 43)<br/>    oled.text("Button:  " + str(butSts), 0, 57<br/>    oled.show()</span><span id="ca40" class="kx ky iq mw b gy ne nb l nc nd"># display data using the function<br/>displayData(temp, hum, extTemp, lum, butSts)</span></pre><p id="f4d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为一个选项，我们可以使用 LED 在开始读取传感器时打开，在数据显示后关闭。这将有助于确认当我们将 ESP 与 PC 断开连接并自动运行时，该程序正在运行。</p><p id="388e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，“主要功能是:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="a508" class="kx ky iq mw b gy na nb l nc nd">def main():<br/>    led.on()<br/>    temp, hum, extTemp, lum, butSts = colectData()<br/>    displayData(temp, hum, extTemp, lum, butSts)<br/>    led.off()</span></pre><p id="fb0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，执行 main()，我们将获得显示在有机发光二极管上的传感器数据，如最后一张图片所示。</p><h2 id="b808" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">6.在 ESP 启动时运行本地站代码</h2><p id="3d47" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">如果您已经使用 Jupyter Notebook 创建和测试了这些功能，那么现在是时候让我们的 ESP 自动执行到目前为止在单个文件脚本上开发的所有功能了。</p><p id="5b6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们打开任何文本编辑器并在上面粘贴所有代码(我喜欢使用 Geany):</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="6e1d" class="kx ky iq mw b gy na nb l nc nd">from machine import Pin<br/>import time</span><span id="5f31" class="kx ky iq mw b gy ne nb l nc nd"># LED<br/>led = Pin(0, Pin.OUT)</span><span id="eff1" class="kx ky iq mw b gy ne nb l nc nd"># DHT<br/>from dht import DHT22<br/>dht22 = DHT22(Pin(12))<br/>def readDht():<br/>    dht22.measure()<br/>    return dht22.temperature(), dht22.humidity()</span><span id="54cf" class="kx ky iq mw b gy ne nb l nc nd"># DS18B20<br/>import onewire, ds18x20<br/>dat = Pin(2)<br/>ds = ds18x20.DS18X20(onewire.OneWire(dat))<br/>sensors = ds.scan()<br/>def readDs():<br/>    ds.convert_temp()<br/>    time.sleep_ms(750)<br/>    return round(ds.read_temp(sensors[0]), 1)</span><span id="82c6" class="kx ky iq mw b gy ne nb l nc nd"># LDR<br/>from machine import ADC<br/>adc = ADC(0)<br/>def readLdr():<br/>    lumPerct = (adc.read()-40)*(10/86)<br/>    return round(lumPerct)</span><span id="2d69" class="kx ky iq mw b gy ne nb l nc nd"># Push Button<br/>button = Pin(13, Pin.IN, Pin.PULL_UP)<br/>def readBut():<br/>    return button.value()</span><span id="4bcb" class="kx ky iq mw b gy ne nb l nc nd"># Read all data:<br/>def colectData():<br/>    temp, hum, = readDht()<br/>    extTemp = readDs()<br/>    lum = readLdr()<br/>    butSts = readBut()<br/>    return temp, hum, extTemp, lum, butSts</span><span id="29dc" class="kx ky iq mw b gy ne nb l nc nd"># I2C / OLED<br/>from machine import I2C<br/>import ssd1306<br/>i2c = I2C(scl=Pin(5), sda=Pin(4))<br/>oled = ssd1306.SSD1306_I2C(128, 64, i2c, 0x3c)<br/>def displayData(temp, hum, extTemp, lum, butSts):<br/>    oled.fill(0)<br/>    oled.text("Temp:    " + str(temp) + "oC", 0, 4)<br/>    oled.text("Hum:     " + str(hum) + "%",0, 16)<br/>    oled.text("ExtTemp: " + str(extTemp) + "oC", 0, 29)<br/>    oled.text("Lumin:   " + str(lum) + "%", 0, 43)<br/>    oled.text("Button:  " + str(butSts), 0, 57)<br/>    oled.show()</span><span id="d563" class="kx ky iq mw b gy ne nb l nc nd"># Main function<br/>def main():<br/>    led.on()<br/>    temp, hum, extTemp, lum, butSts = colectData()<br/>    displayData(temp, hum, extTemp, lum, butSts)<br/>    led.off()</span><span id="e438" class="kx ky iq mw b gy ne nb l nc nd">'''------ run main function --------'''<br/>main()</span></pre><p id="4e1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将其保存，例如保存为<em class="lw"> localData.py. </em></p><p id="ddf0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要在您的终端上直接运行这段代码，您需要 Ampy。</p><p id="3604" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，在终端上，让我们通知 Ampy 我们的串行端口:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="09fd" class="kx ky iq mw b gy na nb l nc nd">export AMPY_PORT=/dev/tty.SLAB_USBtoUART</span></pre><p id="4fc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以看到 ESP 根目录中的文件:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="dfc0" class="kx ky iq mw b gy na nb l nc nd">ampy ls</span></pre><p id="2ad6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为响应，我们将得到<em class="lw"> boot.py </em>，这是将在系统中运行的第一个文件。</p><p id="6e82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们使用 Ampy 将 python 脚本 LocalData.py 加载为/main.py，这样我们的脚本将在启动后立即运行:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="398c" class="kx ky iq mw b gy na nb l nc nd">ampy put localData.py /main.py</span></pre><p id="537d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们现在使用命令<em class="lw"> amp ls </em>，您将在 ESP 中看到两个文件:<em class="lw"> boot.py </em>和<em class="lw"> main.py </em></p><p id="e2df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重置 ESP 将使程序 localData.py(上传为/main.py)自动运行，并在显示屏上显示传感器数据。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lx"><img src="../Images/99f1d7e7704839cb3a8d156f7dfbf670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*qK7fh1aMIbvCCCri"/></div></div></figure><p id="ba12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的终端打印屏幕显示了我们所做的事情。</p><p id="6ab1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用上面的代码，显示将只显示一次，但是我们可以在<em class="lw"> main() </em>函数上定义一个循环，它将在每个定义的时间间隔(PUB_TIME_SEC)显示数据，例如，直到我们按下按钮:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="8739" class="kx ky iq mw b gy na nb l nc nd"># loop getting data until button is pressed<br/>while button.value():<br/>    led.on()<br/>    temp, hum, extTemp, lum, butSts = colectData()<br/>    displayData(temp, hum, extTemp, lum, butSts)<br/>    led.off()<br/>    time.sleep(PUB_TIME_SEC)</span></pre><p id="9930" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">变量 PUB_TIME_SEC 必须在你想要你的样本的时候声明。</p><p id="e26a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了增强我们的代码，最好通知我们将退出循环，因为我们将定义 2 个新的通用函数，一个用于清除显示，另一个用于使 LED 闪烁一定次数。</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="d1ff" class="kx ky iq mw b gy na nb l nc nd"># Clear display :<br/>def displayClear():<br/>    oled.fill(0)<br/>    oled.show()</span><span id="b920" class="kx ky iq mw b gy ne nb l nc nd"># create a blink function<br/>def blinkLed(num):<br/>    for i in range(0, num):<br/>    led.on()<br/>    sleep(0.5)<br/>    led.off()<br/>    sleep(0.5)</span></pre><p id="fa3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我们现在可以，重写我们的 main()函数:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="94a4" class="kx ky iq mw b gy na nb l nc nd">while button.value():<br/>    led.on()<br/>    temp, hum, extTemp, lum, butSts = colectData()<br/>    displayData(temp, hum, extTemp, lum, butSts)<br/>    led.off()<br/>    time.sleep(PUB_TIME_SEC)<br/>    blinkLed(3)<br/>    displayClear()</span></pre><p id="f20e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终代码可以从我的 GitHub: <a class="ae lv" href="https://github.com/Mjrovai/Python4DS/blob/master/Micropython/IoT_TS_MQTT/localData.py" rel="noopener ugc nofollow" target="_blank"> localData.py </a>下载，也可以从用于开发完整代码的 Jupyter 笔记本:<a class="ae lv" href="https://github.com/Mjrovai/Python4DS/blob/master/Micropython/IoT_TS_MQTT/LocalData%20Development.ipynb" rel="noopener ugc nofollow" target="_blank">Jupyter Local Data development . ipynb</a>下载。</p><h2 id="b2ad" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">7:将 ESP 连接到本地 WiFi</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/a87c14377f10cf13361b1adbc205920f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*GsPmMnh5w20pLlPG"/></div></figure><p id="bcbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">网络模块用于配置 WiFi 连接。有两个 WiFi 接口，一个用于工作站(当 ESP8266 连接到路由器时)，一个用于接入点(供其他设备连接到 ESP8266)。在这里，我们的 ESP 将通过路由器连接到本地网络。让我们调用库并定义我们的网络凭证:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="55a0" class="kx ky iq mw b gy na nb l nc nd">import network<br/>WiFi_SSID = "YOUR SSID"<br/>WiFi_PASS = "YOUR PASSWORD"</span></pre><p id="1214" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下功能可用于将 ESP 连接到您的本地网络:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="6116" class="kx ky iq mw b gy na nb l nc nd">def do_connect():<br/>    wlan = network.WLAN(network.STA_IF)<br/>    wlan.active(True)<br/>    if not wlan.isconnected():<br/>        print('connecting to network...')<br/>        wlan.connect(WiFi_SSID, WiFi_SSID)<br/>        while not wlan.isconnected():<br/>            pass<br/>    print('network config:', wlan.ifconfig())</span></pre><p id="13e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行该函数，您可以获得 IP 地址的结果:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="5c94" class="kx ky iq mw b gy na nb l nc nd">do_connect()</span></pre><p id="9a85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果将是:</p><p id="2485" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">网络配置:(10.0.1.2、255.255.255.0、10.0.1.1、10.0.1.1)</p><p id="b74d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的例子中，10.0.1.2 是 ESP 的 IP 地址。</p><h2 id="b20e" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">8.说话的东西</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/fd6f9fd902708d903c6ee5aea6ec1daa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7fo1QyG0jYc-zBY1.jpg"/></div></div></figure><p id="0800" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至此，我们已经学会了如何从所有传感器获取数据，并将其显示在我们的有机发光二极管上。现在，是时候看看如何将这些数据发送到物联网平台<em class="lw">ThingSpeak.com</em>了。</p><blockquote class="mn mo mp"><p id="3d2d" class="jn jo lw jp b jq jr js jt ju jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj kk ij bi translated"><strong class="jp ir"> "ThingSpeak </strong>是一款<a class="ae lv" href="https://en.wikipedia.org/wiki/Open_source" rel="noopener ugc nofollow" target="_blank">开源</a> <a class="ae lv" href="https://en.wikipedia.org/wiki/Internet_of_Things" rel="noopener ugc nofollow" target="_blank">物联网</a> (IoT)应用，使用 REST 和 MQTT APIs 存储和检索物联网数据。ThingSpeak 支持创建传感器日志应用程序、位置跟踪应用程序和带有状态更新的社交网络”</p></blockquote><p id="dcaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们开始吧！</p><p id="e21e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，你必须在 ThinkSpeak.com 有一个账户。接下来，按照说明创建一个通道，并记下您的<strong class="jp ir">通道 ID </strong>和<strong class="jp ir">写入 API 密钥。</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/65c707cb783a346c0c0cb1a453bfefb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*NuaGl0GUbTWgdC6Vpa4qMA.png"/></div></figure><p id="3c80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面你可以看到我们的渠道将使用的 5 个领域。</p><h2 id="7467" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">9.MQTT 协议和 ThingSpeak 连接</h2><p id="bc3d" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">MQTT 是一种发布/订阅架构，主要用于通过无线网络连接带宽和功率受限的设备。它是一个简单的轻量级协议，运行在 TCP/IP 套接字或 web 套接字上。WebSockets 上的 MQTT 可以用 SSL 保护。发布/订阅体系结构使得消息能够被推送到客户端设备，而无需设备持续轮询服务器。</p><p id="1013" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">MQTT 代理是通信的中心点，它负责在发送者和合法接收者之间分发所有消息。客户机是连接到代理的任何设备，可以发布或订阅主题以访问信息。主题包含代理的路由信息。每个想要发送消息的客户端将消息发布到某个主题，每个想要接收消息的客户端订阅某个主题。代理将带有匹配主题的所有消息传递给适当的客户端。</p><p id="afa0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ThingSpeak 在 URL<em class="lw">mqtt.thingspeak.com</em>和端口 1883 有一个 MQTT 代理。ThingSpeak 代理支持 MQTT 发布和 MQTT 订阅。</p><p id="b1ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，我们将使用:<em class="lw"> MQTT Publish。</em></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/d2cbded29cbd2a50f00e21a377d79967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/0*Fi8M5h2DXa6HgdS4"/></div></figure><p id="734f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上图描述了主题结构。发布需要写入 API 密钥。代理用 CONNACK 确认正确的连接请求。</p><p id="991b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Micropython 的内置库中支持 MQTT 协议。该协议可用于通过 WIFI 将数据从您的 ESP8266 发送到免费的云数据库。</p><p id="3494" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用<em class="lw"> umqtt.simple </em>库:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="75a1" class="kx ky iq mw b gy na nb l nc nd">from umqtt.simple import MQTTClient</span></pre><p id="a5fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">知道了我们的服务器 ID，就有可能创建我们的 MQTT 客户机对象:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="550d" class="kx ky iq mw b gy na nb l nc nd">SERVER = "mqtt.thingspeak.com"<br/>client = MQTTClient("umqtt_client", SERVER)</span></pre><p id="19ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，准备好你的 ThingSpeak 证书:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="aa21" class="kx ky iq mw b gy na nb l nc nd">CHANNEL_ID = "YOUR CHANNEL ID"<br/>WRITE_API_KEY = "YOUR KEY HERE"</span></pre><p id="b62a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们创建我们的 MQTT“主题”:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="4eef" class="kx ky iq mw b gy na nb l nc nd">topic = "channels/" + CHANNEL_ID + "/publish/" + WRITE_API_KEY</span></pre><p id="003b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用创建的函数获取要发送给 ThingSpeak 物联网服务的数据，并将其响应与特定数据变量相关联:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="9879" class="kx ky iq mw b gy na nb l nc nd">temp, hum, extTemp, lum, butSts = colectData()</span></pre><p id="d98b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更新这些变量后，我们可以创建我们的“MQTT 有效负载”:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="8284" class="kx ky iq mw b gy na nb l nc nd">payload "field1="+str(temp)+"&amp;field2="+str(hum)+"&amp;field3="+str(extTemp)+"&amp;field4="+str(lum)+"&amp;field5="+str(butSts)</span></pre><p id="030f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！我们已经准备好向 ThinsSpeak 发送数据，只需使用下面的 3 行代码:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="18ed" class="kx ky iq mw b gy na nb l nc nd">client.connect()<br/>client.publish(topic, payload)<br/>client.disconnect()</span></pre><p id="aa98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果您进入您的渠道页面(如下图所示),您会看到 5 个字段中的每一个都有与您的传感器相关的数据。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/8faec8e601d1b5b3486eccc24c26b932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/0*OAQjoHkzQF8icK-S"/></div></figure><h2 id="ce29" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">10.传感器数据记录器</h2><p id="f712" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">现在，我们知道只需几行代码就可以将数据上传到物联网服务，让我们创建一个循环函数，以固定的时间间隔自动完成这项工作(类似于我们对“本地数据”所做的工作)。</p><p id="4701" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用之前声明的相同变量(PUB_TIME_SEC ),可以创建一个简单的 main()函数来连续捕获数据，并将它们记录在我们的通道中:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="30bd" class="kx ky iq mw b gy na nb l nc nd">while True:<br/>    temp, hum, extTemp, lum, butSts = colectData()<br/>    payload = "field1="+str(temp)+"&amp;field2="+str(hum)+"&amp;field3="+str(extTemp)+"&amp;field4="+str(lum)+"&amp;field5="+str(butSts)<br/>    client.connect()<br/>    client.publish(topic, payload)<br/>    client.disconnect()<br/>    time.sleep(PUB_TIME_SEC)</span></pre><p id="f190" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，只有“有效负载”必须更新，因为“主题”与我们的渠道凭证相关，不会改变。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ni"><img src="../Images/18a55fee962384ab36e6343a642b1752.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/0*r-kIDbGuiKeUlO75"/></div></div></figure><p id="9fcc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">寻找你的 ThingSpeak 频道页面，你会发现数据会不断地加载到每个字段。</p><blockquote class="mn mo mp"><p id="903d" class="jn jo lw jp b jq jr js jt ju jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj kk ij bi translated">盖上 LDR，把手放在温度/嗡嗡声传感器上，按下按钮，等等。并查看通道如何自动“记录”这些数据以供将来分析。</p></blockquote><p id="eab6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，对于数据记录，我们应该尽量少用电，因此，我们不会使用 LED 或本地显示器。此外，对于 ESP 设备来说，让它们进入“深度睡眠”是很常见的，在这种情况下，微处理器将保持其最低能量状态，直到捕捉数据并将其发送到物联网平台的时间。</p><p id="9826" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，一旦这里的想法是学习，让我们也包括显示器和 LED 像我们以前做的。这样，我们的“日志”功能将是:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="abdc" class="kx ky iq mw b gy na nb l nc nd">while button.value():<br/>    led.on()<br/>    temp, hum, extTemp, lum, butSts = colectData()<br/>    displayData(temp, hum, extTemp, lum, butSts)<br/>    led.off()<br/>    payload = "field1="+str(temp)+"&amp;field2="+str(hum)+"&amp;field3="+str(extTemp)+"&amp;field4="+str(lum)+"&amp;field5="+str(butSts)<br/>    client.connect()<br/>    client.publish(topic, payload)<br/>    client.disconnect()<br/>    time.sleep(PUB_TIME_SEC)</span><span id="792e" class="kx ky iq mw b gy ne nb l nc nd">blinkLed(3)<br/>displayClear()</span></pre><p id="aae6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完整的 microPython 脚本可以在这里找到:<a class="ae lv" href="https://github.com/Mjrovai/Python4DS/blob/master/Micropython/IoT_TS_MQTT/dataLoggerTS_EXT.py" rel="noopener ugc nofollow" target="_blank">Data loggers _ ext . py</a>和用于开发的 Jupyter 笔记本也可以在这里找到:<a class="ae lv" href="https://github.com/Mjrovai/Python4DS/blob/master/Micropython/IoT_TS_MQTT/IoT%20-%20ThingSpeak%20-%20Data%20Logger%20EXT.ipynb" rel="noopener ugc nofollow" target="_blank">物联网 ThingSpeak 数据记录器 EXT.ipynb </a>。</p><p id="4b43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要在 ESP 上上传脚本，请在您的终端上使用以下命令:</p><pre class="km kn ko kp gt mv mw mx my aw mz bi"><span id="f915" class="kx ky iq mw b gy na nb l nc nd">ampy put dataLoggerTS.py /main.py</span></pre><p id="c2ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并按下 ESP 复位按钮。</p><p id="42ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您将让电潜泵捕捉数据并记录在 ThingSpeak.com 上，直到底部被按住(等待 LED 闪烁 3 次，有机发光二极管关闭)。</p><h2 id="67b8" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">11.ThingView 应用程序</h2><p id="5a13" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">记录的数据可以直接在 ThingSpeak.com 网站上查看，也可以通过应用程序查看，例如 ThingsView！</p><p id="e8f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ThingView 是由<a class="ae lv" href="http://www.cinetica-tech.com/" rel="noopener ugc nofollow" target="_blank"> CINETICA </a>开发的一款应用程序，它使你能够以一种简单的方式可视化你的 ThingSpeak 频道，只需输入频道 ID，你就可以开始了。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/0b1a616c26a8ae938b2d5c82327a05b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/0*7aYHs_PGNoFpvUS2"/></div></figure><p id="280f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于公共频道，应用程序将尊重您的 windows 设置:颜色，时间刻度，图表类型和结果的数量。当前版本支持折线图和柱形图，样条图显示为折线图。</p><p id="dac3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于私有通道，数据将使用默认设置显示，因为无法仅使用 API 键读取私有窗口设置。</p><p id="a241" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ThingView 应用可以为<a class="ae lv" href="https://play.google.com/store/apps/details?id=com.cinetica_tech.thingview&amp;hl=en" rel="noopener ugc nofollow" target="_blank">安卓</a>和<a class="ae lv" href="https://itunes.apple.com/us/app/thingview/id1284878579?mt=8" rel="noopener ugc nofollow" target="_blank"> IPHONE </a>下载。</p><h2 id="2856" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">12:结论</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/5216ee9789c9394f9b34226650349753.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/0*CH2kM7JG-RIgS2YE"/></div></figure><p id="2d2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一如既往，我希望这个项目可以帮助其他人找到进入令人兴奋的电子世界的方法！</p><p id="f561" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">详情和最终代码请访问我的 GitHub 仓库:<a class="ae lv" href="https://github.com/Mjrovai/Python4DS/tree/master/Micropython/IoT_TS_MQTT" rel="noopener ugc nofollow" target="_blank"> IoT_TS_MQTT </a></p><p id="c18a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更多项目，请访问我的博客:<a class="ae lv" href="https://mjrobot.org/" rel="noopener ugc nofollow" target="_blank">MJRoBot.org</a></p><p id="f9ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来自世界南部的 Saludos！</p><p id="7c12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的下一篇文章再见！</p><p id="864e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谢谢你，</p><p id="a5cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">马塞洛</p></div></div>    
</body>
</html>