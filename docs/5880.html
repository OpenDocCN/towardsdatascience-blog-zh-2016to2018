<html>
<head>
<title>Automated Feature Engineering for Predictive Modeling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于预测建模的自动化特征工程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/automated-feature-engineering-for-predictive-modeling-d8c9fa4e478b?source=collection_archive---------16-----------------------#2018-11-13">https://towardsdatascience.com/automated-feature-engineering-for-predictive-modeling-d8c9fa4e478b?source=collection_archive---------16-----------------------#2018-11-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/8897b1be7f3c45f19117f6b04a56db6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*u7x50VZiBfw6brf6.jpg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Source:Wikimedia Commons</figcaption></figure><div class=""/><p id="15fe" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用 Python 和 FeatureTools 库预测哪些 NHL 比赛是季后赛。</p><p id="73c1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我见过的数据科学家在构建数据产品时投入的主要时间之一是手动执行特征工程。虽然像<a class="ae lb" href="https://automl.github.io/auto-sklearn/stable/" rel="noopener ugc nofollow" target="_blank"> auto-sklearn </a>和<a class="ae lb" href="https://autokeras.com/" rel="noopener ugc nofollow" target="_blank"> Auto-Keras </a>这样的工具已经能够在构建预测模型时自动完成大部分模型拟合过程，但确定将哪些特征用作拟合过程的输入通常是一个手动过程。我最近开始使用 FeatureTools 库，它使数据科学家也能够自动化特征工程。</p><div class="ip iq gp gr ir lc"><a href="https://github.com/Featuretools/featuretools" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd jg gy z fp lh fr fs li fu fw je bi translated">功能工具/功能工具</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">用于自动化特征工程的开源 python 框架——feature tools/feature tools</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">github.com</p></div></div><div class="ll l"><div class="lm l ln lo lp ll lq ix lc"/></div></div></a></div><p id="e8a7" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">FeatureTools 可用于浅层(经典)机器学习问题，其中数据以结构化格式提供。该库提供了用于执行深度要素合成的功能，这近似于数据科学家在执行要素工程时将探索的变换。使用此工具的结果是，您可以将数据从窄而深的表示转换为浅而宽的表示。</p><p id="0ec0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我发现，当每个项目有许多记录需要预测时，这种技术最有效。例如，如果您预测客户是否会流失，输入可以是每个客户的会话事件的集合。如果每个用户只有一条记录，那么深度特征合成不会非常有效。为了展示这种方法是如何工作的，我将使用 Kaggle 上的<a class="ae lb" href="https://www.kaggle.com/martinellis/nhl-game-data" rel="noopener ugc nofollow" target="_blank"> NHL 数据集</a>。这个数据集包括一个游戏记录表，以及一个更详细地描述每个游戏的游戏记录表。我正在建立的预测模型的目标是根据比赛中的打法来确定哪些比赛是季后赛。在没有应用领域知识的情况下，我能够建立一个逻辑回归分类器，以高准确度(<em class="la"> 94% </em>)预测比赛是季后赛。完整的 Python 笔记本可以在 github <a class="ae lb" href="https://github.com/bgweber/StartupDataScience/blob/master/EDA/NHL_Games.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="3ecb" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这篇文章的剩余部分介绍了笔记本，展示了如何将提供的 Kaggle 表转换成我们可以用于 FeatureTools 库的输入。第一步是加载必要的库。我们将使用 pandas 加载表，使用 framequery 操作数据框，使用 hashlib 将字符串转换为整数，使用特征工具执行深度特征合成，使用 sklearn 进行模型拟合。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="61cc" class="ma mb jf lw b gy mc md l me mf">import pandas as pd<br/>import framequery as fq<br/>import hashlib<br/>import featuretools as ft<br/>from featuretools import Feature <br/>from sklearn.linear_model import LogisticRegression<br/>from sklearn.metrics import roc_auc_score</span></pre><p id="ca51" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接下来，我们将数据加载到 pandas 数据框中，并删除不会用于构建预测的字符串字段。结果是两个数据帧:<em class="la"> game_df </em>指定一场比赛是常规比赛还是季后赛，而<em class="la"> plays_df </em>有关于每场比赛的细节。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="97a4" class="ma mb jf lw b gy mc md l me mf"><strong class="lw jg"># game data<br/></strong>game_df = pd.read_csv("game.csv")</span><span id="76c1" class="ma mb jf lw b gy mg md l me mf"><strong class="lw jg"># play data<br/></strong>plays_df = pd.read_csv("game_plays.csv")</span><span id="1274" class="ma mb jf lw b gy mg md l me mf"><strong class="lw jg"># drop some of the string type fields<br/></strong>plays_df = plays_df.drop(['secondaryType', 'periodType', <br/>                 'dateTime', 'rink_side'], axis=1).fillna(0)</span><span id="c6d8" class="ma mb jf lw b gy mg md l me mf"><strong class="lw jg"># convert the remaining strings to integer types via hashing<br/></strong>plays_df['event'] = plays_df['event'].apply(hash)<br/>plays_df['description'] = plays_df['description'].apply(hash)</span></pre><p id="ff8a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">游戏数据是一种窄而深的格式，这意味着每个游戏都由许多不同的游戏组成，只有几个特征。我们的目标是将这些数据转换成一种浅而宽的格式，其中每个游戏都由具有数百种不同属性的单行来描述。这是输入数据集。</p><figure class="lr ls lt lu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mh"><img src="../Images/daf27b685d85f30dd18a9f8386e9b8a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q8I4EBvVejsJRLEKhwkUoA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">The data frames used as input: plays and games.</figcaption></figure><p id="e50c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下一步是将 pandas 数据框转换为实体集表示，FeatureTools 将实体集表示用作执行深度要素合成的输入。实体集用于描述不同表之间的关系。在这种情况下，plays 事件是基本实体，而 games 是父实体。在描述这种关系之前，我们首先对<em class="la">事件</em>和<em class="la">描述</em>字段使用 1-hot 编码。这些开始是字符串字段，但是在执行编码之前被转换为哈希值。这是第一步，如下面的代码片段所示。第二步是使用带有 1-hot 编码的转换表作为实体集创建的输入数据帧，在实体集创建中，我们将游戏定义为游戏的集合。</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="mi mj l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Creating an entity set with encodings for the event and description fields.</figcaption></figure><p id="cc0d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这一步的输出是一个实体集，我们可以使用它来执行深度特征合成。得到的对象<em class="la"> es </em>具有以下属性。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="dd2c" class="ma mb jf lw b gy mc md l me mf">Entityset: plays<br/>  Entities:<br/>    plays [Rows: 500638, Columns: 37]<br/>    games [Rows: 1529, Columns: 1]<br/>  Relationships:<br/>    plays.game_id -&gt; games.game_id</span></pre><p id="bf26" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦我们将数据帧编码为一个实体集，我们就可以使用 FeatureTools 中的<em class="la"> dfs </em>函数执行深度特征合成，如下所示。结果是<em class="la">特征</em>数据集，它有数百个特征，每个游戏有一行。我们还使用 framequery 为每场比赛分配一个标签，其中季后赛的标签为 1，常规赛的标签为 0。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="36b7" class="ma mb jf lw b gy mc md l me mf"><strong class="lw jg"># generate features for the data set<br/></strong>features,_ =ft.dfs(entityset=es,target_entity="games",max_depth=2)<br/>features.reset_index(inplace=True)</span><span id="3115" class="ma mb jf lw b gy mg md l me mf"><strong class="lw jg"># assign labels to the generated features<br/></strong>features = fq.execute("""<br/>SELECT f.*, case when g.type = 'P' then 1 else 0 end as label<br/>FROM features f <br/>JOIN game_df g<br/>  on f.game_id = g.game_id<br/>""")</span></pre><p id="c02e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这会产生一个浅而宽的数据框，如下所示。我们已经将<em class="la">事件</em>字段从字符串转换为 1-hot 编码字段，现在应用了许多不同的聚合操作。数据现在以一种格式可用，其中单个记录描述每场比赛，我们可以训练一个模型来预测一场比赛是否是季后赛。</p><figure class="lr ls lt lu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mh"><img src="../Images/11c01802d3ecdb16df7c15aea59155d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*06e4fjk3IqMHabIsBpp1aQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">The generated features produced from deep feature synthesis.</figcaption></figure><p id="d9cb" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后一步是训练和测试模型。为了简单起见，我使用了 sklearn 的逻辑回归模型来拟合数据并评估结果。在下面的代码片段中，精度是在不使用维持集的情况下进行评估的。当我在笔记本中添加维持步骤时，模型的准确性为 94.0%，ROC AUC 为 0.984。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="a883" class="ma mb jf lw b gy mc md l me mf"><strong class="lw jg"># create inputs for sklearn<br/></strong>y = features['label']<br/>X = features.drop(['label', 'game_id'], axis=1).fillna(0)</span><span id="3808" class="ma mb jf lw b gy mg md l me mf"><strong class="lw jg"># train a classifier <br/></strong>lr = LogisticRegression()<br/>model = lr.fit(X, y)<br/>model.score(X, y)</span></pre><p id="6a5e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这些结果看起来真的令人印象深刻，因为没有关于曲棍球的领域知识被用来训练模型。我没有手动提出特征并试图对曲棍球知识进行编码，而是使用深度特征合成来创建大量特征，作为模型拟合步骤的输入。自动化特征工程是数据科学向前迈出的一大步，使构建预测模型更加自动化。鲨鱼队加油。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="bb9d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">本·韦伯是 Zynga 的首席数据科学家。我们正在<a class="ae lb" href="https://www.zynga.com/careers/positions/categories" rel="noopener ugc nofollow" target="_blank">招聘</a>！</p></div></div>    
</body>
</html>