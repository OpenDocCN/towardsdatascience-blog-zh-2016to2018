<html>
<head>
<title>Genetic Algorithm Implementation in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">遗传算法在 Python 中的实现</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/genetic-algorithm-implementation-in-python-5ab67bb124a6?source=collection_archive---------0-----------------------#2018-07-15">https://towardsdatascience.com/genetic-algorithm-implementation-in-python-5ab67bb124a6?source=collection_archive---------0-----------------------#2018-07-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="384a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本教程将基于一个简单的例子用 Python 实现遗传算法优化技术，在这个例子中，我们试图最大化一个方程的输出。本教程使用基因的十进制表示、单点交叉和一致变异。</p><p id="31c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2020 年 5 月 5 日注</p><blockquote class="kl km kn"><p id="aa13" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">本教程的 GitHub 项目进行了更新，对项目进行了重大修改，以支持多种功能:【https://github.com/ahmedfgad/GeneticAlgorithmPython】T2。例如，除了能够定制适应度函数来处理任何类型的问题之外，还实现了多种类型的变异和交叉。基于这个项目，一个名为 PyGAD 的库被部署到 PyPI 中，在那里您可以使用 pip 进行安装:【https://pypi.org/project/pygad<a class="ae ks" href="https://pypi.org/project/pygad" rel="noopener ugc nofollow" target="_blank"/></p><p id="8c51" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">本教程的原始代码位于<a class="ae ks" href="https://github.com/ahmedfgad/GeneticAlgorithmPython/tree/master/Tutorial%20Project" rel="noopener ugc nofollow" target="_blank">教程项目</a>目录下，该目录可从以下链接获得:<a class="ae ks" href="https://github.com/ahmedfgad/GeneticAlgorithmPython/tree/master/Tutorial%20Project" rel="noopener ugc nofollow" target="_blank">https://github . com/ahmedfgad/geneticalgorithpython/tree/master/Tutorial % 20 Project</a></p></blockquote><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/e6c874b51d81d67c2f164a2baa7c7a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ak-j8GUP4FwzzR-YPjxclg.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk"><strong class="bd lj">Genetic Algorithm Implementation in Python — By Ahmed F. Gad</strong></figcaption></figure><h1 id="5b72" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><strong class="ak">遗传算法概述</strong></h1><p id="86d6" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">遗传算法(GA)的流程图如图 1 所示。遗传算法中涉及的每一步都有一些变化。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/219ad38979dff544af989e2a53eb9996.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*plKxNWoJ8u19UplCbeN9SQ.png"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk"><strong class="bd lj">Figure 1. Genetic algorithm flowchart</strong></figcaption></figure><p id="19fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，基因有不同类型的表示，如二进制、十进制、整数等。每种类型都有不同的处理方式。有不同类型的突变，如位翻转、交换、逆、均匀、非均匀、高斯、收缩等。此外，交叉有不同的类型，如混合、一点、两点、均匀和其他。本教程不会实现所有这些，而只是实现 GA 中涉及的每个步骤的一种类型。本教程使用基因的十进制表示、单点交叉和一致变异。读者应该了解遗传算法是如何工作的。如果没有，请阅读这篇题为“遗传算法优化简介”的文章，文章链接如下:</p><p id="81c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">LinkedIn:<a class="ae ks" href="https://www.linkedin.com/pulse/introduction-optimization-genetic-algorithm-ahmed-gad/" rel="noopener ugc nofollow" target="_blank">https://www . LinkedIn . com/pulse/introduction-optimization-genetic-algorithm-Ahmed-gad/</a></p><p id="cce5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">KDnuggets:<a class="ae ks" href="https://www.kdnuggets.com/2018/03/introduction-optimization-with-genetic-algorithm.html" rel="noopener ugc nofollow" target="_blank">https://www . kdnugges . com/2018/03/introduction-optimization-with-genetic-algorithm . html</a></p><p id="6487" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">towards data science:<a class="ae ks" rel="noopener" target="_blank" href="/introduction-to-optimization-with-genetic-algorithm-2f5001d9964b">https://towards data science . com/introduction-to-optimization-with-genetic-algorithm-2f 5001d 9964 b</a></p><p id="661c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">slide share:<a class="ae ks" href="https://www.slideshare.net/AhmedGadFCIT/introduction-to-optimization-with-genetic-algorithm-ga" rel="noopener ugc nofollow" target="_blank">https://www . slide share . net/AhmedGadFCIT/introduction-to-optimization-with-genetic-algorithm-ga</a></p><h1 id="c8b8" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><strong class="ak">教程示例</strong></h1><p id="c293" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">本教程首先介绍我们将要实现的等式。该等式如下所示:</p><p id="f654" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">Y = w1x 1+w2x 2+w3x 3+w4x 4+w5x 5+w6x 6</strong></p><p id="4639" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如图所示，该等式具有 6 个输入(x1 至 x6)和 6 个权重(w1 至 w6)，输入值为(x1，x2，x3，x4，x5，x6)=(4，-2，7，5，11，1)。我们正在寻找使该等式最大化的参数(权重)。最大化这个等式的想法似乎很简单。正输入要乘以最大可能的正数，负数要乘以最小可能的负数。但我们希望实现的想法是，如何让 GA 自己去做，以便知道最好是使用正输入的正权重和负输入的负权重。让我们开始实施 GA。</p><p id="71db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们创建一个包含 6 个输入和一个变量的列表来保存权重的数量，如下所示:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="52c8" class="mt ll iq mp b gy mu mv l mw mx"><em class="ko"># Inputs of the equation.<br/> </em>equation_inputs = [4,-2,3.5,5,-11,-4.7]<br/> <em class="ko"># Number of the weights we are looking to optimize.<br/> </em>num_weights = 6</span></pre><p id="4b84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是定义初始群体。基于权重的数量，群体中的每个染色体(解或个体)肯定会有 6 个基因，每个权重一个基因。但问题是每个人有多少解决方案？没有固定的值，我们可以选择适合我们问题的值。但是我们可以让它保持通用，这样就可以在代码中修改它。接下来，我们创建一个保存每个群体的解的数量的变量，另一个保存群体的大小，最后，一个保存实际初始群体的变量:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="0fd6" class="mt ll iq mp b gy mu mv l mw mx"><strong class="mp ir">import </strong>numpy</span><span id="96e5" class="mt ll iq mp b gy my mv l mw mx">sol_per_pop = 8</span><span id="627c" class="mt ll iq mp b gy my mv l mw mx"><em class="ko"># Defining the population size.<br/><br/></em>pop_size = (sol_per_pop,num_weights) <em class="ko"># The population will have sol_per_pop chromosome where each chromosome has num_weights genes.<br/><br/>#Creating the initial population.<br/><br/></em>new_population = numpy.random.uniform(low=-4.0, high=4.0, size=pop_size)</span></pre><p id="c033" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导入 numpy 库后，我们能够使用 numpy.random.uniform 函数随机创建初始群体。根据选定的参数，它的形状将是(8，6)。这是 8 条染色体，每条染色体有 6 个基因，每个基因对应一个体重。运行此代码后，填充如下:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="bf42" class="mt ll iq mp b gy mu mv l mw mx">[[-2.19134006 -2.88907857  2.02365737 -3.97346034  3.45160502  2.05773249]</span><span id="5814" class="mt ll iq mp b gy my mv l mw mx">[ 2.12480298  2.97122243  3.60375452  3.78571392  0.28776565  3.5170347 ]</span><span id="7490" class="mt ll iq mp b gy my mv l mw mx">[ 1.81098962  0.35130155  1.03049548 -0.33163294  3.52586421  2.53845644]</span><span id="ad7a" class="mt ll iq mp b gy my mv l mw mx">[-0.63698911 -2.8638447   2.93392615 -1.40103767 -1.20313655  0.30567304]</span><span id="309a" class="mt ll iq mp b gy my mv l mw mx">[-1.48998583 -1.53845766  1.11905299 -3.67541087  1.33225142  2.86073836]</span><span id="634f" class="mt ll iq mp b gy my mv l mw mx">[ 1.14159503  2.88160332  1.74877772 -3.45854293  0.96125878  2.99178241]</span><span id="469b" class="mt ll iq mp b gy my mv l mw mx">[ 1.96561297  0.51030292  0.52852716 -1.56909315 -2.35855588  2.29682254]</span><span id="718e" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -0.72163167  0.7516408   0.00677938]]</span></pre><p id="4559" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，它是随机生成的，因此在再次运行时肯定会发生变化。</p><p id="4cb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">准备好群体后，接下来要遵循图 1 中的流程图。基于适应度函数，我们将选择当前种群中最好的个体作为交配的亲本。下一步是应用 GA 变体(交叉和变异)来产生下一代的后代，通过附加父母和后代来创建新的群体，并重复这样的步骤若干次迭代/世代。下一段代码应用这些步骤:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="3a8b" class="mt ll iq mp b gy mu mv l mw mx"><strong class="mp ir">import ga</strong></span><span id="bbeb" class="mt ll iq mp b gy my mv l mw mx">num_generations = 5<br/><br/>num_parents_mating = 4<br/><strong class="mp ir">for </strong>generation <strong class="mp ir">in </strong>range(num_generations):<br/>     <em class="ko"># Measuring the fitness of each chromosome in the population.<br/>     </em>fitness = ga.cal_pop_fitness(equation_inputs, new_population)<br/>    <em class="ko"># Selecting the best parents in the population for mating.<br/>     </em>parents = ga.select_mating_pool(new_population, fitness, <br/>                                       num_parents_mating)<br/> <br/>     <em class="ko"># Generating next generation using crossover.<br/>     </em>offspring_crossover = ga.crossover(parents,<br/>                                        offspring_size=(pop_size[0]-parents.shape[0], num_weights))<br/> <br/>     <em class="ko"># Adding some variations to the offsrping using mutation.<br/>     </em>offspring_mutation = ga.mutation(offspring_crossover)</span><span id="acfa" class="mt ll iq mp b gy my mv l mw mx"><em class="ko"># Creating the new population based on the parents and offspring.<br/>     </em>new_population[0:parents.shape[0], :] = parents<br/>     new_population[parents.shape[0]:, :] = offspring_mutation</span></pre><p id="81ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目前的世代数是 5。它被选择为小，用于呈现教程中所有代的结果。有一个名为 GA 的模块保存算法的实现。</p><p id="7c32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一步是使用 ga <code class="fe mz na nb mp b">.cal_pop_fitness</code>函数找到群体中每个解的适应值。该功能在 GA 模块中的实现如下:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="9463" class="mt ll iq mp b gy mu mv l mw mx"><strong class="mp ir">def </strong>cal_pop_fitness(equation_inputs, pop):<br/>     <em class="ko"># Calculating the fitness value of each solution in the current population.<br/>     # The fitness function calculates the sum of products between each input and its corresponding weight.<br/>     </em>fitness = numpy.sum(pop*equation_inputs, axis=1)<br/>     <strong class="mp ir">return </strong>fitness</span></pre><p id="d9f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了总体，适应度函数还接受两个方程输入值(x1 至 x6)。根据我们的函数，将适应值计算为每个输入与其相应基因(权重)之间的乘积之和(SOP)。根据每个群体的解决方案数量，将会有多个 sop。由于我们之前在名为<code class="fe mz na nb mp b">sol_per_pop</code>的变量中将解的数量设置为 8，因此将有 8 个 sop，如下所示:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="7c45" class="mt ll iq mp b gy mu mv l mw mx">[-63.41070188  14.40299221 -42.22532674  18.24112489 -45.44363278 -37.00404311  15.99527402  17.0688537 ]</span></pre><p id="ff03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，适应值越高，解决方案越好。</p><p id="3ca0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在计算出所有解的适应值后，接下来是根据下一个函数<code class="fe mz na nb mp b">ga.select_mating_pool</code>在交配池中选择其中最好的作为亲本。该函数接受人口、适应值和所需的双亲数量。它返回所选的父节点。它在 GA 模块中的实现如下:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="653a" class="mt ll iq mp b gy mu mv l mw mx"><strong class="mp ir">def </strong>select_mating_pool(pop, fitness, num_parents):<br/><br/>    <em class="ko"># Selecting the best individuals in the current generation as parents for producing the offspring of the next generation.<br/><br/>    </em>parents = numpy.empty((num_parents, pop.shape[1]))<br/><br/>    <strong class="mp ir">for </strong>parent_num <strong class="mp ir">in </strong>range(num_parents):<br/><br/>        max_fitness_idx = numpy.where(fitness == numpy.max(fitness))<br/><br/>        max_fitness_idx = max_fitness_idx[0][0]<br/><br/>        parents[parent_num, :] = pop[max_fitness_idx, :]<br/><br/>        fitness[max_fitness_idx] = -99999999999<br/><br/>    <strong class="mp ir">return </strong>parents</span></pre><p id="18ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据变量<code class="fe mz na nb mp b">num_parents_mating</code>中定义的所需父节点的数量，该函数创建一个空数组来保存它们，如下行所示:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="08a1" class="mt ll iq mp b gy mu mv l mw mx">parents = numpy.empty((num_parents, pop.shape[1]))</span></pre><p id="6309" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">循环遍历当前群体，该函数获得最高适应值的索引，因为它是根据该行选择的最佳解决方案:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="80cf" class="mt ll iq mp b gy mu mv l mw mx">max_fitness_idx = numpy.where(fitness == numpy.max(fitness))</span></pre><p id="c053" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该索引用于使用以下代码行检索与此类适应值对应的解决方案:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="296d" class="mt ll iq mp b gy mu mv l mw mx">parents[parent_num, :] = pop[max_fitness_idx, :]</span></pre><p id="1fb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了避免再次选择这样的解决方案，其适应度值被设置为很小的值，该值很可能不会被再次选择，即<strong class="jp ir">-9999999999</strong>。最后返回<strong class="jp ir"> parents </strong>数组，根据我们的例子如下:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="79fe" class="mt ll iq mp b gy mu mv l mw mx">[[-0.63698911 -2.8638447   2.93392615 -1.40103767 -1.20313655  0.30567304]</span><span id="6cda" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -0.72163167  0.7516408   0.00677938]</span><span id="c54a" class="mt ll iq mp b gy my mv l mw mx">[ 1.96561297  0.51030292  0.52852716 -1.56909315 -2.35855588  2.29682254]<br/>[ 2.12480298  2.97122243  3.60375452  3.78571392  0.28776565  3.5170347 ]]</span></pre><p id="28fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，这三个父母是当前群体中的最佳个体，基于他们的适合度值分别为 18.24112489、17.0688537、15.99527402 和 14.40299221。</p><p id="d6eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是使用这样选择的父母交配，以产生后代。根据<code class="fe mz na nb mp b">ga.crossover</code>功能，配对从交叉操作开始。这个函数接受父母和后代的大小。它使用后代大小来知道从这样的父母产生的后代的数量。这种功能在 GA 模块中实现如下:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="0f49" class="mt ll iq mp b gy mu mv l mw mx"><strong class="mp ir">def </strong>crossover(parents, offspring_size):<br/>     offspring = numpy.empty(offspring_size)<br/>     <em class="ko"># The point at which crossover takes place between two parents. Usually, it is at the center.<br/>     </em>crossover_point = numpy.uint8(offspring_size[1]/2)<br/> <br/>     <strong class="mp ir">for </strong>k <strong class="mp ir">in </strong>range(offspring_size[0]):<br/>         <em class="ko"># Index of the first parent to mate.<br/>         </em>parent1_idx = k%parents.shape[0]<br/>         <em class="ko"># Index of the second parent to mate.<br/>         </em>parent2_idx = (k+1)%parents.shape[0]<br/>         <em class="ko"># The new offspring will have its first half of its genes taken from the first parent.<br/>         </em>offspring[k, 0:crossover_point] = parents[parent1_idx, 0:crossover_point]<br/>         <em class="ko"># The new offspring will have its second half of its genes taken from the second parent.<br/>         </em>offspring[k, crossover_point:] = parents[parent2_idx, crossover_point:]<br/>     <strong class="mp ir">return </strong>offspring</span></pre><p id="b975" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该函数首先根据后代大小创建一个空数组，如下所示:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="b1d6" class="mt ll iq mp b gy mu mv l mw mx">offspring = numpy.empty(offspring_size)</span></pre><p id="4508" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们使用单点交叉，我们需要指定交叉发生的点。选择该点，根据这条线将解分成相等的两半:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="44c4" class="mt ll iq mp b gy mu mv l mw mx">crossover_point = numpy.uint8(offspring_size[1]/2)</span></pre><p id="d865" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们需要选择双亲进行杂交。这些亲本的指数是根据这两条线选择的:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="7b67" class="mt ll iq mp b gy mu mv l mw mx">parent1_idx = k%parents.shape[0]<br/>parent2_idx = (k+1)%parents.shape[0]</span></pre><p id="b536" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">双亲以类似于环的方式被选择。首先选择具有索引 0 和 1 的第一个来产生两个后代。如果还有剩余的后代要产生，那么我们选择亲本 1 和亲本 2 来产生另外两个后代。如果我们需要更多的后代，那么我们选择指数为 2 和 3 的下两个父母。通过索引 3，我们到达了最后一个父节点。如果我们需要产生更多的后代，那么我们选择索引为 3 的父代，然后回到索引为 0 的父代，依此类推。</p><p id="14bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将交叉操作应用于双亲后的解存储在<code class="fe mz na nb mp b">offspring </code>变量中，如下所示:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="bf54" class="mt ll iq mp b gy mu mv l mw mx">[[-0.63698911 -2.8638447   2.93392615 -0.72163167  0.7516408   0.00677938]</span><span id="97a4" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.35855588  2.29682254]</span><span id="ead1" class="mt ll iq mp b gy my mv l mw mx">[ 1.96561297  0.51030292  0.52852716  3.78571392  0.28776565  3.5170347 ]</span><span id="e848" class="mt ll iq mp b gy my mv l mw mx">[ 2.12480298  2.97122243  3.60375452 -1.40103767 -1.20313655  0.30567304]]</span></pre><p id="4cff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是使用 GA 模块中的<code class="fe mz na nb mp b">ga.mutation</code>函数将第二个 GA 变体(突变)应用于存储在<code class="fe mz na nb mp b">offspring </code>变量中的交叉结果。该函数接受交叉子代，并在应用统一变异后返回它们。该功能实现如下:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="b85a" class="mt ll iq mp b gy mu mv l mw mx"><strong class="mp ir">def </strong>mutation(offspring_crossover):<br/><br/>    <em class="ko"># Mutation changes a single gene in each offspring randomly.<br/><br/>    </em><strong class="mp ir">for </strong>idx <strong class="mp ir">in </strong>range(offspring_crossover.shape[0]):<br/><br/>        <em class="ko"># The random value to be added to the gene.<br/><br/>        </em>random_value = numpy.random.uniform(-1.0, 1.0, 1)<br/><br/>        offspring_crossover[idx, 4] = offspring_crossover[idx, 4] + random_value<br/><br/>    <strong class="mp ir">return </strong>offspring_crossover</span></pre><p id="4b63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它循环遍历每个后代，并根据下面的代码行添加一个在-1 到 1 范围内统一生成的随机数:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="0fe0" class="mt ll iq mp b gy mu mv l mw mx">random_value = numpy.random.uniform(-1.0, 1.0, 1)</span></pre><p id="964b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样的随机数然后被加到后代的索引为 4 的基因上:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="f400" class="mt ll iq mp b gy mu mv l mw mx">offspring_crossover[idx, 4] = offspring_crossover[idx, 4] + random_value</span></pre><p id="20cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，该索引可以更改为任何其他索引。应用突变后的后代如下:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="4630" class="mt ll iq mp b gy mu mv l mw mx">[[-0.63698911 -2.8638447   2.93392615 -0.72163167  1.66083721  0.00677938]</span><span id="7909" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.56909315 -1.94513681  2.29682254]</span><span id="29c7" class="mt ll iq mp b gy my mv l mw mx">[ 1.96561297  0.51030292  0.52852716  3.78571392  0.45337472  3.5170347 ]</span><span id="548c" class="mt ll iq mp b gy my mv l mw mx">[ 2.12480298  2.97122243  3.60375452 -1.40103767 -1.5781162   0.30567304]]</span></pre><p id="11e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些结果被添加到变量<code class="fe mz na nb mp b">offspring_crossover</code>中，并由函数返回。</p><p id="d20a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一点上，我们成功地从 4 个选择的亲本中产生了 4 个后代，并且我们准备创建下一代的新群体。</p><p id="f0d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，遗传算法是一种基于随机的优化技术。它试图通过对当前解决方案进行一些随机更改来增强它们。因为这样的改变是随机的，我们不确定它们会产生更好的解决方案。因此，最好在新的种群中保留以前的最佳解(父代)。在最坏的情况下，当所有新的后代都比这样的父母更差时，我们将继续使用这样的父母。这样一来，我们保证新一代至少会保留以前的好成绩，不会变得更差。新群体将从以前的父母那里得到它的前 4 个解决方案。最后 4 个解决方案来自应用交叉和变异后产生的后代:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="7b2d" class="mt ll iq mp b gy mu mv l mw mx">new_population[0:parents.shape[0], :] = parents<br/>new_population[parents.shape[0]:, :] = offspring_mutation</span></pre><p id="8e9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过计算第一代所有解(父代和后代)的适应度，它们的适应度如下:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="741f" class="mt ll iq mp b gy mu mv l mw mx">[ 18.24112489  17.0688537   15.99527402  14.40299221  -8.46075629  31.73289712   6.10307563  24.08733441]</span></pre><p id="5a33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之前最高体能是<strong class="jp ir"> 18.24112489 </strong>现在是<strong class="jp ir">31.971158</strong>。这意味着随机变化朝着更好的解决方案发展。这太棒了。但是，这样的结果可以通过更多代来加强。下面是另外 4 代的每个步骤的结果:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="71e8" class="mt ll iq mp b gy mu mv l mw mx"><strong class="mp ir">Generation :  1</strong></span><span id="5edc" class="mt ll iq mp b gy my mv l mw mx"><strong class="mp ir">Fitness values:</strong></span><span id="b079" class="mt ll iq mp b gy my mv l mw mx">[ 18.24112489  17.0688537   15.99527402  14.40299221  -8.46075629  31.73289712   6.10307563  24.08733441]</span><span id="8df9" class="mt ll iq mp b gy my mv l mw mx"><strong class="mp ir">Selected parents:</strong></span><span id="8148" class="mt ll iq mp b gy my mv l mw mx">[[ 3.00912373 -2.745417    3.27131287 -1.56909315 -1.94513681  2.29682254]</span><span id="df23" class="mt ll iq mp b gy my mv l mw mx">[ 2.12480298  2.97122243  3.60375452 -1.40103767 -1.5781162   0.30567304]</span><span id="cbf0" class="mt ll iq mp b gy my mv l mw mx">[-0.63698911 -2.8638447   2.93392615 -1.40103767 -1.20313655  0.30567304]</span><span id="c274" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -0.72163167  0.7516408   0.00677938]]</span><span id="1294" class="mt ll iq mp b gy my mv l mw mx"><strong class="mp ir">Crossover result:</strong></span><span id="ba1f" class="mt ll iq mp b gy my mv l mw mx">[[ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.5781162   0.30567304]</span><span id="5a64" class="mt ll iq mp b gy my mv l mw mx">[ 2.12480298  2.97122243  3.60375452 -1.40103767 -1.20313655  0.30567304]</span><span id="1508" class="mt ll iq mp b gy my mv l mw mx">[-0.63698911 -2.8638447   2.93392615 -0.72163167  0.7516408   0.00677938]</span><span id="2fd5" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.56909315 -1.94513681  2.29682254]]</span><span id="4a9a" class="mt ll iq mp b gy my mv l mw mx"><strong class="mp ir">Mutation result:</strong></span><span id="505f" class="mt ll iq mp b gy my mv l mw mx">[[ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.2392086   0.30567304]</span><span id="56e3" class="mt ll iq mp b gy my mv l mw mx">[ 2.12480298  2.97122243  3.60375452 -1.40103767 -0.38610586  0.30567304]</span><span id="a7c2" class="mt ll iq mp b gy my mv l mw mx">[-0.63698911 -2.8638447   2.93392615 -0.72163167  1.33639943  0.00677938]</span><span id="4d43" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.56909315 -1.13941727  2.29682254]]</span><span id="e7e9" class="mt ll iq mp b gy my mv l mw mx"><strong class="mp ir">Best result after generation 1 :  34.1663669207</strong></span><span id="692d" class="mt ll iq mp b gy my mv l mw mx"><strong class="mp ir">Generation :  2</strong></span><span id="a392" class="mt ll iq mp b gy my mv l mw mx"><strong class="mp ir">Fitness values:</strong></span><span id="7cdc" class="mt ll iq mp b gy my mv l mw mx">[ 31.73289712  24.08733441  18.24112489  17.0688537   34.16636692  10.97522073  -4.89194068  22.86998223]</span><span id="408f" class="mt ll iq mp b gy my mv l mw mx"><strong class="mp ir">Selected Parents:</strong></span><span id="32f1" class="mt ll iq mp b gy my mv l mw mx">[[ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.2392086   0.30567304]</span><span id="c7bb" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.56909315 -1.94513681  2.29682254]</span><span id="fb8d" class="mt ll iq mp b gy my mv l mw mx">[ 2.12480298  2.97122243  3.60375452 -1.40103767 -1.5781162   0.30567304]</span><span id="7267" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.56909315 -1.13941727  2.29682254]]</span><span id="08a2" class="mt ll iq mp b gy my mv l mw mx"><strong class="mp ir">Crossover result:</strong></span><span id="4004" class="mt ll iq mp b gy my mv l mw mx">[[ 3.00912373 -2.745417    3.27131287 -1.56909315 -1.94513681  2.29682254]</span><span id="9f03" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.5781162   0.30567304]</span><span id="81e4" class="mt ll iq mp b gy my mv l mw mx">[ 2.12480298  2.97122243  3.60375452 -1.56909315 -1.13941727  2.29682254]</span><span id="7373" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.2392086   0.30567304]]</span><span id="2556" class="mt ll iq mp b gy my mv l mw mx"><strong class="mp ir">Mutation result:</strong></span><span id="7985" class="mt ll iq mp b gy my mv l mw mx">[[ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.20515009  2.29682254]</span><span id="b136" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.40103767 -0.73543721  0.30567304]</span><span id="a676" class="mt ll iq mp b gy my mv l mw mx">[ 2.12480298  2.97122243  3.60375452 -1.56909315 -0.50581509  2.29682254]</span><span id="e7f3" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.20089639  0.30567304]]</span><span id="6029" class="mt ll iq mp b gy my mv l mw mx"><strong class="mp ir">Best result after generation 2:  34.5930432629</strong></span><span id="cc22" class="mt ll iq mp b gy my mv l mw mx"><strong class="mp ir">Generation :  3</strong></span><span id="d54e" class="mt ll iq mp b gy my mv l mw mx"><strong class="mp ir">Fitness values:</strong></span><span id="69bd" class="mt ll iq mp b gy my mv l mw mx">[ 34.16636692  31.73289712  24.08733441  22.86998223  34.59304326  28.6248816    2.09334217  33.7449326 ]</span><span id="3f2f" class="mt ll iq mp b gy my mv l mw mx"><strong class="mp ir">Selected parents:</strong></span><span id="226a" class="mt ll iq mp b gy my mv l mw mx">[[ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.20515009  2.29682254]</span><span id="e00c" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.2392086   0.30567304]</span><span id="5240" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.20089639  0.30567304]</span><span id="5ff6" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.56909315 -1.94513681  2.29682254]]</span><span id="fc0f" class="mt ll iq mp b gy my mv l mw mx"><strong class="mp ir">Crossover result:</strong></span><span id="a2b6" class="mt ll iq mp b gy my mv l mw mx">[[ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.2392086   0.30567304]</span><span id="5584" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.20089639  0.30567304]</span><span id="b966" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.56909315 -1.94513681  2.29682254]</span><span id="c343" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.20515009  2.29682254]]</span><span id="2858" class="mt ll iq mp b gy my mv l mw mx"><strong class="mp ir">Mutation result:</strong></span><span id="301e" class="mt ll iq mp b gy my mv l mw mx">[[ 3.00912373 -2.745417    3.27131287 -1.40103767 -2.20744102  0.30567304]</span><span id="be62" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.16589294  0.30567304]</span><span id="efe8" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.37553107  2.29682254]</span><span id="9a04" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.44124005  2.29682254]]</span><span id="4848" class="mt ll iq mp b gy my mv l mw mx"><strong class="mp ir">Best result after generation 3:  44.8169235189</strong></span><span id="2b15" class="mt ll iq mp b gy my mv l mw mx"><strong class="mp ir">Generation :  4</strong></span><span id="9531" class="mt ll iq mp b gy my mv l mw mx"><strong class="mp ir">Fitness values</strong></span><span id="ec88" class="mt ll iq mp b gy my mv l mw mx">[ 34.59304326  34.16636692  33.7449326   31.73289712  44.81692352</span><span id="9b8e" class="mt ll iq mp b gy my mv l mw mx">33.35989464  36.46723397  37.19003273]</span><span id="fef7" class="mt ll iq mp b gy my mv l mw mx"><strong class="mp ir">Selected parents:</strong></span><span id="6fd8" class="mt ll iq mp b gy my mv l mw mx">[[ 3.00912373 -2.745417    3.27131287 -1.40103767 -2.20744102  0.30567304]</span><span id="4bb6" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.44124005  2.29682254]</span><span id="9c21" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.37553107  2.29682254]</span><span id="26c7" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.20515009  2.29682254]]</span><span id="f6d3" class="mt ll iq mp b gy my mv l mw mx"><strong class="mp ir">Crossover result:</strong></span><span id="4d3b" class="mt ll iq mp b gy my mv l mw mx">[[ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.37553107  2.29682254]</span><span id="7691" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.20515009  2.29682254]</span><span id="95d8" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.40103767 -2.20744102  0.30567304]]</span><span id="2791" class="mt ll iq mp b gy my mv l mw mx"><strong class="mp ir">Mutation result:</strong></span><span id="e050" class="mt ll iq mp b gy my mv l mw mx">[[ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.13382082  2.29682254]</span><span id="8294" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.98105233  2.29682254]</span><span id="b9a4" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.56909315 -2.27638584  2.29682254]</span><span id="afbb" class="mt ll iq mp b gy my mv l mw mx">[ 3.00912373 -2.745417    3.27131287 -1.40103767 -1.70558545  0.30567304]]</span><span id="e9d4" class="mt ll iq mp b gy my mv l mw mx"><strong class="mp ir">Best result after generation 4:  44.8169235189</strong></span></pre><p id="92ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上述 5 代之后，与第一代之后的最佳结果<strong class="jp ir"> 18.24112489 </strong>相比，最佳结果现在具有等于<strong class="jp ir"> 44.8169235189 </strong>的适应值。</p><p id="2304" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最佳解决方案具有以下权重:</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="a28f" class="mt ll iq mp b gy mu mv l mw mx">[3.00912373 -2.745417    3.27131287 -1.40103767 -2.20744102  0.30567304]</span></pre><h1 id="6f6f" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">完整的 Python 实现</h1><p id="4449" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">完整的代码可以在我的 GitHub 账号这里获得:<a class="ae ks" href="https://github.com/ahmedfgad/GeneticAlgorithmPython/tree/master/Tutorial%20Project" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/ahmedfgad/genetical gorithm python/tree/master/Tutorial % 20 project</a>。它也会在教程中列出。</p><p id="f785" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是该示例的实现:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="50b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">遗传算法模块如下:</strong></p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="nc nd l"/></div></figure></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="010e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原文可在 LinkedIn 本页面获得:<a class="ae ks" href="https://www.linkedin.com/pulse/genetic-algorithm-implementation-python-ahmed-gad/" rel="noopener ugc nofollow" target="_blank">https://www . LinkedIn . com/pulse/genetic-algorithm-implementation-python-Ahmed-gad/</a></p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h2 id="17e8" class="mt ll iq bd lm nl nm dn lq nn no dp lu jy np nq ly kc nr ns mc kg nt nu mg nv bi translated"><strong class="ak">联系作者:</strong></h2><p id="4b67" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">领英:<a class="ae ks" href="https://linkedin.com/in/ahmedfgad" rel="noopener ugc nofollow" target="_blank">https://linkedin.com/in/ahmedfgad</a></p><p id="767a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">电子邮件:ahmed.f.gad@gmail.com</p></div></div>    
</body>
</html>