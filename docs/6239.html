<html>
<head>
<title>A short tutorial on Fuzzy Time Series — Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模糊时间序列的简短教程—第二部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-short-tutorial-on-fuzzy-time-series-part-ii-with-an-case-study-on-solar-energy-bda362ecca6d?source=collection_archive---------4-----------------------#2018-12-03">https://towardsdatascience.com/a-short-tutorial-on-fuzzy-time-series-part-ii-with-an-case-study-on-solar-energy-bda362ecca6d?source=collection_archive---------4-----------------------#2018-12-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a3c3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过对太阳能的案例研究</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/90af1f802405c47b3f3d292b7216a931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wMcuAKgC2qWxBIkvqDsbLA.jpeg"/></div></div></figure><p id="cc7b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi ln translated"><span class="l lo lp lq bm lr ls lt lu lv di">在</span><a class="ae lw" rel="noopener" target="_blank" href="/a-short-tutorial-on-fuzzy-time-series-dcc6d4eb1b15">本教程的第一部分</a>中，我简要解释了时间序列分析、模糊集以及什么是模糊时间序列 pyFTS，并简要介绍了<a class="ae lw" href="https://pyfts.github.io/pyFTS/" rel="noopener ugc nofollow" target="_blank"> pyFTS 库</a>。太棒了！我从世界各地的人们那里得到了反馈，我听到了他们提出的非常好的想法。但是，正如在每个介绍性研究中发生的那样，我们使用了非常简单的方法和数据，目的是促进对这种方法的总体理解。</p><p id="d91f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是现在，假设读者已经知道了所需的背景，我们可以稍微前进一点，玩一些更有用的东西。首先，我们将看到对偏差/方差概念的直观介绍，然后我们将了解一些最重要的 FTS 超参数及其对模型准确性的影响。最后，我们将采用一些 FTS 模型来模拟和预测太阳辐射时间序列，这对光伏能源预测很有用。</p><p id="f951" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本教程的所有例子都可以在谷歌实验室，http://bit.ly/short_tutorial_colab2<a class="ae lw" href="http://bit.ly/short_tutorial_colab2" rel="noopener ugc nofollow" target="_blank">获得。随时联系，给 ou 反馈，提问。现在，让我们开始吧！</a></p><h1 id="1d17" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">信号、噪声、偏差和方差</h1><p id="296a" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi ln translated"><span class="l lo lp lq bm lr ls lt lu lv di"> T </span>机器学习模型的训练是将信号从噪声中分离出来、将一般行为从局部特殊性和随机误差中分离出来的冲突。在每个估计器的训练中，偏差和方差之间，欠拟合和过拟合之间存在冲突。</p><p id="d23d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">给定一个数字时间序列<em class="mu"> Y </em>，它的单个值<em class="mu"> y(t)∈Y </em>，以及 y 的一个估计量，一个函数<em class="mu"> ŷ(t+1) = f( y(t) ) </em>。<em class="mu"> f </em>的<strong class="kt ir">目的</strong>是预测<em class="mu"> Y </em>的最佳可能方式，使实际值<em class="mu"> y(t) </em>与预测值<em class="mu"> ŷ(t) </em>之间的差值<em class="mu"> ε(t) </em>趋于零，或者换句话说对于<em class="mu">ε(t)= y(t)</em><em class="mu">t→∞来说</em></p><p id="624e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">直观地说，有偏估计量是指ε (t)的期望值不为零— E [ε (t)] ≠ 0 的估计量。偏差是正确值的系统“偏差”,请记住，估计值通常会与真实值有偏差，这是意料之中的，但平均而言，这些偏差应该趋于零。这种偏差是典型的欠拟合模型，当模型不能学习信号，我们感兴趣的时间序列的组成部分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/c008ee0957fd645a078651ad48ee9bfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1YsNYT27ZgzmaHf2UsHJzw.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk"><a class="ae lw" rel="noopener" target="_blank" href="/understanding-the-bias-variance-tradeoff-165e6942b229">Source</a></figcaption></figure><p id="b1c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一方面，方差与模型的泛化能力有关，尤其是在训练阶段没有提供的数据。当模型开始学习不能很好地概括测试数据的训练样本的特异性时，高方差与过拟合有关。简而言之:模型学习了数据的噪声。</p><p id="8168" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">众所周知，完全消除偏差和方差的副作用是不可能的，最佳拟合是通过它们之间的平衡来实现的——这是估计模型的挑战。</p><h1 id="9679" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">模糊时间序列参数</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/90de5c3e8bec06fd79f86b7db12c602b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YZ6TJEMg7HQ-H11QobReow.jpeg"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk"><a class="ae lw" href="https://ronenright.co.nz/" rel="noopener ugc nofollow" target="_blank">Fonte</a></figcaption></figure><p id="cefc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">几个参数决定了 FTS 模型的最佳拟合，但主要的参数是分区和顺序。这两个参数占模型准确率的 90%(经验值)。</p><h2 id="a039" class="na ly iq bd lz nb nc dn md nd ne dp mh la nf ng mj le nh ni ml li nj nk mn nl bi translated">1.分割</h2><p id="1862" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">分区由三个参数组成，这里根据它们的重要性列出:</p><p id="d0c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 1a)分区(或模糊集)的数量</strong></p><p id="c498" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是对模型精度影响最大的参数。模糊集越多，对时间序列特征的捕捉就越精确。这里有一个陷阱:</p><ul class=""><li id="f715" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated">由于信号过度简化，太少的模糊集产生欠拟合；</li><li id="1c90" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">过多的模糊集会产生过拟合，使得模型开始学习数据上的噪声；</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/c6cee0146165a23e5d056250ab1abb5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gCt6h1_BVS0eQoGdEm5TxA.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Several numbers of partition for the sine function</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/73113183d0196cfe2ff28391915a9daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UO5Xf5z87JgHvnE6FzWxbw.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Accuracy of several partitionings for sine function</figcaption></figure><p id="8838" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">组数是一个必须进行基准测试的参数。在已经被区分的时间序列中，10 个分区是一个好的开始数字。在其他情况下，35 个分区是一个很好的数字。</p><p id="727c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 1b)分区类型</strong></p><p id="844b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有许多类型的分区，从网格分区(GridPartitioner)到分区器，网格分区中所有集合均匀分布并具有相同的格式，分区器中集合具有不同的大小，如基于熵的分区器和基于簇的分区器。这里我不会深入讨论这个问题，但是出于好奇<a class="ae lw" href="https://github.com/PYFTS/notebooks/blob/master/Partitioners.ipynb" rel="noopener ugc nofollow" target="_blank">在 PYFTS/notebooks 存储库中有几个分区类型的例子</a>。</p><p id="07f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总是从网格划分开始，如果是这样的话，探索其他类型。</p><p id="bb94" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 1c)隶属函数</strong></p><p id="afc2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个对模型的准确性几乎没有实际影响的参数，但是根据具体情况，您可能有很好的理由使用高斯或梯形函数来代替默认的三角函数。</p><p id="68ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">理由之一可能是参数的数量(高斯型使用 2，三角形使用 3，梯形使用 4)，模型的易读性，甚至与过程和数据的性质相关的其他问题。</p><p id="7676" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，我不会在这里深入讨论这个问题，<a class="ae lw" href="https://github.com/PYFTS/notebooks/blob/master/Partitioners.ipynb" rel="noopener ugc nofollow" target="_blank">看看 PYFTS/notebooks 存储库，了解更多细节</a>。</p><h2 id="e302" class="na ly iq bd lz nb nc dn md nd ne dp mh la nf ng mj le nh ni ml li nj nk mn nl bi translated">2.命令</h2><p id="249a" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">模型的阶是 FTS 的第二个最重要的参数，因为它们是自回归模型(使用滞后值来预测下一个模型)。序参数是模型的内存大小，或者说需要多少过去的信息来描述未来的事件。</p><p id="6fc7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了确定这个参数，熟悉自相关函数的概念——ACF 是很重要的。ACF 不仅能够指示最重要滞后的顺序和索引。</p><h2 id="b3d2" class="na ly iq bd lz nb nc dn md nd ne dp mh la nf ng mj le nh ni ml li nj nk mn nl bi translated">2a)滞后(或订单)数量</h2><p id="d84d" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">顺序是模型使用的滞后量(过去的值)。这真的非常重要，并且取决于被建模的时间序列的类型。这里的问题是:我需要多少滞后来让模型学习时间模式、周期、季节性等等？看看 ACF，看看有多少是显著的滞后。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/2a0c90c74d67fbcfe1c42accb62f9b51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EpVI5t99UmpJ1HIg_gQEPA.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Model accuracy by order</figcaption></figure><p id="5cd3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，这里有一个陷阱:当模型使用更多的滞后时(特别是当分区数量很大的时候！)并且模型越大，学习和推理变得越慢。</p><p id="3253" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">根据我的经验，描述一个时间序列行为不超过 3 个滞后。但是当然一切都取决于数据。</p><h2 id="9a41" class="na ly iq bd lz nb nc dn md nd ne dp mh la nf ng mj le nh ni ml li nj nk mn nl bi translated">2b)滞后指数</h2><p id="1514" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">默认情况下，模型会按顺序选择最近的滞后。但是根据时间序列的季节性，这些可能不是最好的滞后。所以看看 ACF，看看哪个滞后指数是最重要的。</p><h1 id="f4da" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">3.方法的类型</h1><p id="2321" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">关于 FTS 方法的文献非常多样化，但有两个特征极其重要:</p><h2 id="8559" class="na ly iq bd lz nb nc dn md nd ne dp mh la nf ng mj le nh ni ml li nj nk mn nl bi translated">3a)有重量与无重量</h2><p id="49e5" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">权重增加了模型的准确性，平衡了模型规则中的哪些设置对预测更有影响。它们稍微降低了模型的可读性，但没什么大不了的。如果你必须选择，总是喜欢加权模型！</p><p id="2303" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在下面的例子中，我们可以比较 HOFTS(无权重)、WHOFTS(规则的结果权重)和 PWFTS(规则的结果权重和先例权重):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/13c0192ad203aa7bdbe725bc726baab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IgpT9VrHN90Oz8iPK_Gy2g.png"/></div></div></figure><h2 id="0e78" class="na ly iq bd lz nb nc dn md nd ne dp mh la nf ng mj le nh ni ml li nj nk mn nl bi translated">3b)单变量与多变量</h2><p id="6a00" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">大多数时候，我们只有一个变量的时间序列——内生变量。其他时候，我们可以利用其他信息(外生变量)来辅助这个变量。</p><p id="83cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，通常与时间序列测量相关的日期，对于季节性数据(如社会、环境等)来说是非常有价值的信息。数据。</p><p id="a97f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你有多变量数据，那么首先要知道变量之间是否存在相关性，所以使用相关矩阵来检查它。相关系数指向简单的线性关系，因此它不应该是您应该使用的唯一工具，交叉熵是一个很好的替代方法。</p><p id="847c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一个提示:如果您有一个单变量时间序列，您可以通过创建一个多变量序列来丰富您的模型，其中其他变量是内生变量的转换。例如，您可以拥有一个包含原始(内生)变量和微分内生变量的多元序列，从而提供有关值的最近波动的额外信息。</p><h1 id="e6d5" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">案例研究:太阳辐射</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/b516980b93268a009347b53c477cdac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B-DoG5WiWxZW7EQHlbrNTg.jpeg"/></div></div></figure><p id="7884" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi ln translated">是时候找点乐子了！请记住:所有代码和结果都可以在 http://bit.ly/short_tutorial_colab2 的 T2 获得。我将使用来自 SONDA<a class="ae lw" href="http://sonda.ccst.inpe.br/" rel="noopener ugc nofollow" target="_blank">——巴西</a>国家环境数据组织系统的太阳辐射数据，特别是来自巴西利亚/DF 站的数据。辐射数据在“glo_avg”变量中，每天 24 小时每分钟采样，从 2013 年到 2014 年用于训练集，从 2015 年用于测试。</p><p id="8598" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如预期的那样，数据有点嘈杂，不太需要每分钟采样。我清理了数据，删除了其他变量(它们与我们的主变量相关性不是很大)，只留下了日期和内生变量。下一步是减少数据量和清除噪音，我通过对系列的每小时平均值进行采样来完成。预处理后的数据可从地址<a class="ae lw" href="https://data.world/petroniocandido/sonda-bsb-averaged-hourly" rel="noopener ugc nofollow" target="_blank">https://data . world/petroniocandido/sonda-BSB-average-hourly</a>获得。</p><p id="f452" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">直观上，太阳辐射有两个主要周期，日周期(太阳自转运动)和年周期(太阳平移运动)。影响这种预测的最大不确定性是天气和天空中是否有云。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/b5d4ef756c145ce3fe2427d663d2d52d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*jsEm6VLiDJubXTliOLI5cQ.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Sample of the yearly cycle</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/73bfd30d6cbb03b1b535092418ad2981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NH-I1VLSTjOo_QMuVH5o-Q.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Sample of the daily cycle</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/78453850041c88d3cd50754fc8fa4887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k71Yybvb8iSibfuN4aHnrg.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Autocorrelation function for the first 24 lags, correspondig for the previous 24 hours</figcaption></figure><h1 id="f982" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">适合各种口味的方法</h1><p id="31ab" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi ln translated"><span class="l lo lp lq bm lr ls lt lu lv di">正如</span>一样，您已经知道 pyFTS 库中的方法在<em class="mu">模型</em>包中。然后我们将分析几个 FTS 模型在这个时间序列建模中的表现。在现实世界中，我们应该通过测试上述所有参数的众多组合来优化模型的超参数。在 pyFTS 中，我们可以使用<em class="mu">超参数</em>包，您可以在其中运行分布式网格搜索，这将在每个超参数的所有可能值之间生成笛卡尔乘积，并测试每个值。你也可以使用遗传算法(<em class="mu">超参数。进化的</em>或使用<a class="ae lw" href="http://hyperopt.github.io/hyperopt/" rel="noopener ugc nofollow" target="_blank">远视库</a>。但让我们简单点，好吗？</p><p id="04f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用具有 35 个分区的网格方案(GridPartitioner)划分我们的内生变量，分为 5 个亚组，VL-非常低，L-低，M-中，H-高和 VH-非常高，每个亚组有 7 个水平。这种命名法将通过生成以下规则使模型更易于解释:</p><p id="7834" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"><em class="mu">L6 L5→L6 M0 M1</em>T3】</strong></p><p id="416e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这条规则可以理解为:</p><p id="81eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">如果</strong> <em class="mu"> y(t-1) </em> <strong class="kt ir">为</strong>低(子级 5) <strong class="kt ir">而</strong> <em class="mu"> y(t) </em> <strong class="kt ir">为</strong>低(子级 6) <strong class="kt ir">那么</strong><em class="mu">【t+1】</em><strong class="kt ir">将为</strong>低(子级 6) <strong class="kt ir">或</strong>中(子级 0) <strong class="kt ir">或</strong></p><p id="7d65" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">根据所选择的规则(由于规则的先例的成员与输入值相关)，去模糊化将把结果转换成数值(一个简单的方法是集合的加权平均)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/3589662d837a0dc67b7ba600bbbd6aae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vmA52aBByq-uLONW8hM-uA.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Grid partitioning of solar radiation time series</figcaption></figure><h2 id="b78a" class="na ly iq bd lz nb nc dn md nd ne dp mh la nf ng mj le nh ni ml li nj nk mn nl bi translated">单变量方法</h2><p id="890a" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">我们已经有了分区方案，所以让我们来研究一下方法。我们选择了带权重和不带权重的高阶方法(阶数&gt; 1 ),所有方法都用 1 到 3 的阶数进行了测试。下面列出了生成规则的方法和示例:</p><ul class=""><li id="29cc" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated"><strong class="kt ir"> <em class="mu">霍夫茨。HighOrderFTS </em> </strong>:高阶失重法</li></ul><pre class="kg kh ki kj gt oj ok ol om aw on bi"><span id="1eba" class="na ly iq ok b gy oo op l oq or">L4,VL0 → VL0,VL1<br/>L5,VL0 → VL0,VL1</span></pre><ul class=""><li id="94e0" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated"><strong class="kt ir"> <em class="mu"> hofts。weightedhigorderfts</em></strong>:高阶加权法，权重只在每个规则的后件上。</li></ul><pre class="kg kh ki kj gt oj ok ol om aw on bi"><span id="5589" class="na ly iq ok b gy oo op l oq or">L4,VL0 → VL0 (0.5), VL1 (0.5)<br/>L5,VL0 → VL0 (0.5), VL1 (0.5)</span></pre><ul class=""><li id="1a28" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated"><strong class="kt ir"> <em class="mu"> pwfts。probabilistic weighted FTS</em></strong>:高阶加权方法，其中概率权重基于每个规则的前件和后件。</li></ul><pre class="kg kh ki kj gt oj ok ol om aw on bi"><span id="24ff" class="na ly iq ok b gy oo op l oq or">(0.003) L0,VL1 → (0.876)VL0, (0.103)VL1, (0.015)VL2, (0.006)VL3, (0.001)VL4</span><span id="9086" class="na ly iq ok b gy os op l oq or">(0.003) L0,VL2 → (0.003)L0, (0.003)L1, (0.003)L2, (0.0)L3, (0.0)L4, (0.787)VL0, (0.164)VL1, (0.03)VL2, (0.002)VL3, (0.002)VL4, (0.005)VL5, (0.001)VL6</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/52cab1e6976de7c2ea66fad2b2021a14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WEOorIMv5ilbvNOnPSzReQ.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Performance sample of univariate models</figcaption></figure><h2 id="11f1" class="na ly iq bd lz nb nc dn md nd ne dp mh la nf ng mj le nh ni ml li nj nk mn nl bi translated">多元方法</h2><p id="e68e" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi ln translated"><span class="l lo lp lq bm lr ls lt lu lv di">在</span>pyft 上，多变量模型使用 Pandas 数据帧作为数据输入(单变量模型使用列表或 Numpy 数组),方法在<em class="mu"> models.multivariate </em>包中。每个变量都有自己的分区方案和其他参数。您必须首先创建一个变量类型的对象，说明变量的名称、数据帧中的数据列和分割器。然后使用<em class="mu">追加变量</em>函数将外生和内生变量合并到模型中。内生变量必须在<em class="mu">目标变量</em>属性中设置。</p><pre class="kg kh ki kj gt oj ok ol om aw on bi"><span id="6765" class="na ly iq ok b gy oo op l oq or">from pyFTS.models.multivariate import common, variable, mvfts<br/>from pyFTS.models.seasonal import partitioner as seasonal<br/>from pyFTS.models.seasonal.common import DateTime</span><span id="b329" class="na ly iq ok b gy os op l oq or">sp = {'seasonality': DateTime.day_of_year , 'names': ['Jan','Feb','Mar','Apr','May','Jun','Jul', 'Aug','Sep','Oct','Nov','Dec']}</span><span id="c961" class="na ly iq ok b gy os op l oq or">month = variable.Variable("Month", data_label="data", partitioner=seasonal.TimeGridPartitioner, npart=12,data=train_mv, partitioner_specific=sp)</span><span id="fac7" class="na ly iq ok b gy os op l oq or">radiation = variable.Variable("Radiation", data_label="glo_avg", alias='rad',partitioner=Grid.GridPartitioner, npart=35, data=train_mv)</span><span id="4ad7" class="na ly iq ok b gy os op l oq or">model = mvfts.MultivariateFTS()<br/>model.append_variable(month)<br/>model.append_variable(radiation)<br/>model.target_variable = radiation<br/>model.fit(train_mv)</span></pre><p id="a9ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除了我们的内生变量“glo_avg ”,我们将只使用“date”列，并从中提取两个外生变量:月份和小时。变量的划分如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/992d6672b57a8ba507dfc83d4e54a84e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QuLaVYzAPxCYzDo6I_Z1GQ.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Partitioning scheme by variable</figcaption></figure><p id="b5fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi ln translated">你可能会问自己:<em class="mu">为什么时间和月份会重叠？毕竟这是非常准确的信息！</em>回答:那是模糊逻辑的家伙！我们假设相邻的事物相互影响并具有相似的行为，因此特定时间的规则也会受到相邻时间和月份的影响。</p><p id="c675" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们来看看多元方法，并看看它们生成的规则示例:</p><ul class=""><li id="bc79" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated"><strong class="kt ir"><em class="mu">mvft。MultivariateFTS </em> </strong>:失重一阶法(order = 1)；</li></ul><pre class="kg kh ki kj gt oj ok ol om aw on bi"><span id="c779" class="na ly iq ok b gy oo op l oq or">Jan,8hs,VL0 → VL1,VL2,VL3,VL4,VL5<br/>Jan,8hs,VL1 → VL1,VL2,VL3,VL4,VL5,L0,L1,L3,L4</span></pre><ul class=""><li id="27ec" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated"><strong class="kt ir"> <em class="mu"> wmvfts。Weighted multivariatedfts</em></strong>:加权一阶法；</li></ul><pre class="kg kh ki kj gt oj ok ol om aw on bi"><span id="82f3" class="na ly iq ok b gy oo op l oq or">Jan,8hs,VL0  → VL2 (0.353), VL1 (0.253), VL4 (0.147), VL3 (0.207), VL5 (0.04)</span><span id="1b78" class="na ly iq ok b gy os op l oq or">Jan,8hs,VL1  → VL2 (0.276), VL3 (0.172), VL1 (0.198), VL5 (0.083), VL4 (0.151), VL6 (0.021), L0 (0.036), L4 (0.005), L1 (0.036), L2 (0.021)</span></pre><ul class=""><li id="638f" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated"><strong class="kt ir">颗粒状。GranularWMVFTS </strong>:加权高阶法；</li></ul><pre class="kg kh ki kj gt oj ok ol om aw on bi"><span id="3889" class="na ly iq ok b gy oo op l oq or">Jan11hsV3,Jan12hsL1  → Jan13hsVL6 (1.0)<br/>Jan12hsL1,Jan13hsVL6  → Jan15hsVL3 (1.0)</span></pre><h1 id="780a" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">对模型进行基准测试</h1><p id="8585" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi ln translated">显然，评估预测模型的主要标准是其准确性。我们将使用均方根误差(RMSE ),该值越低越好。但是另一个重要的标准是简约:简单的模型总是比复杂的模型更受欢迎。所以我们的目标是最小化 RMSE 和模型尺寸。让我们看看五个表现最好的模型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="3e0f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">预计多变量模型比单变量模型表现更好，毕竟，它们有更多的信息可以利用。但是请注意，最节省的模型是 PWFTS！</p><p id="afb5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可能性不止于此。我们现在可以决定集合最好的模型(<a class="ae lw" href="https://pyfts.github.io/pyFTS/build/html/FTS.models.ensemble.html" rel="noopener ugc nofollow" target="_blank"><em class="mu">models . ensemble</em></a>)，或者使用非平稳模糊集(<a class="ae lw" href="https://pyfts.github.io/pyFTS/build/html/pyFTS.models.nonstationary.html" rel="noopener ugc nofollow" target="_blank"><em class="mu">models . non stability</em></a>)。但这是为了另一个机会！</p><h1 id="37ae" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">扩大预测范围</h1><p id="cc54" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi ln translated">当我们采用预测模型时，我们不仅对预测下一个值感兴趣，而且对预测这些值的序列感兴趣。这真的很酷，因为只要有一些滞后的信息，我们就可以对未来的许多步骤做出估计！对于太阳辐射预测的具体情况，我们将我们的预测范围设置为 48 小时。</p><p id="eb3d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于 pyFTS 上的单变量模型，这非常简单，<a class="ae lw" href="https://pyfts.github.io/pyFTS/build/html/pyFTS.common.html#pyFTS.common.fts.FTS.predict" rel="noopener ugc nofollow" target="_blank">只需使用<em class="mu">预测</em>函数</a>的<em class="mu">提前步骤</em>参数。该参数将在下一次<em class="mu"> steps_ahead </em>迭代中反馈输入中的输出值。</p><pre class="kg kh ki kj gt oj ok ol om aw on bi"><span id="09d1" class="na ly iq ok b gy oo op l oq or">forecasts = model.predict(input_data, steps_ahead=48)</span></pre><p id="5c06" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于多元模型，这有点棘手:我们不仅生成内生变量的值，还生成外生变量的值。由于这个值的生成取决于每个变量的性质，除了<em class="mu"> steps_ahead </em>参数之外，<em class="mu">生成器</em>参数也是必需的，它是一个字典，必须包含每个 Pandas DataFrame 列的一个键，其值是 lambda 函数，接收变量的当前值并返回下一个值。在我们的示例中，这非常简单，因为外生变量的值是日期时间，要计算下一个值，我们只需在输入值上加一个小时:</p><pre class="kg kh ki kj gt oj ok ol om aw on bi"><span id="1db8" class="na ly iq ok b gy oo op l oq or">generator = lambda x : pd.to_datetime(x) + pd.to_timedelta(1, unit='h')</span><span id="b7b7" class="na ly iq ok b gy os op l oq or">forecasts = model.predict(input_data, steps_ahead=48, <br/>              generators={'date': generator})</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/70f6c1a25348f8ca8e8868bd2681e73c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v39WrmAbL2_LI62SK3038w.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Forecasts for the next 48 hours, using the two best evaluated models</figcaption></figure><h1 id="eb7c" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">结论</h1><p id="ab25" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">现在，您已经对 FTS 和 pyFTS 库有了足够的了解，可以在您的个人项目中使用它们。当然，还有很多东西要谈！在下一个教程中，我们将讨论区间和概率预测、数据转换、非平稳和增量模型等。</p><p id="7fad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您需要帮助、提出问题或给出反馈，请随时联系我们。回头见，伙计们！</p></div></div>    
</body>
</html>