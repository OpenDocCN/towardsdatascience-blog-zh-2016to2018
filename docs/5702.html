<html>
<head>
<title>Introduction to cleaning data with Pandas (Private Munich Housemarket data set)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫清洗数据介绍(私人慕尼黑 Housemarket 数据集)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-cleaning-data-with-pandas-private-munich-housemarket-data-set-be5fc558c9e3?source=collection_archive---------4-----------------------#2018-11-04">https://towardsdatascience.com/introduction-to-cleaning-data-with-pandas-private-munich-housemarket-data-set-be5fc558c9e3?source=collection_archive---------4-----------------------#2018-11-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3673" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一开始我就开始用 python 做数据分析之外的其他事情。我是一名技术 SEO 顾问，想要使用一个爬虫(或构建一个)，但不知道任何编程语言，python 看起来是开始的完美语言… <br/>现在，我更喜欢 python，因为它的多功能性可以做我刚才提到的事情，还可以轻松实现数据分析。</p><p id="1784" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们能把这两个世界融合在一起会怎么样？当我手腕受伤时，我创作了我的第一个爬虫，它并不漂亮，它是用一只手写的，但是很有效。<br/>现在我正在看数据，我想这将是一个很好的简单的例子，说明如何使用 python(主要是 Pandas)来使用您收集的数据，或者您可以使用的数据。</p><h1 id="84c3" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">慕尼黑的房产市场</h1><p id="7dc0" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我现在住在慕尼黑，我真的很喜欢这个城市，在我职业生涯的初期，我去过很多地方(纽约/旧金山/台湾/巴黎)，我很快想到我需要一些数据来帮助寻找我的家。如果我想在某个地方购买，你需要支付的不是一个小数目，很可能是一大笔钱，所以你需要用一些确凿的数据来支撑你的愿望。</p><p id="dc30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我用我的小爬虫独自收集慕尼黑周围房产市场的数据。它仍然是一个手动程序，因为当我创建它时，我不知道也没有时间让它成为一个全天候运行的云原生应用程序。</p><p id="b99e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我可能会尝试改进它，使它成为云原生的，这样我就可以监控它。如果我成功了，这将是一篇博文。我在<a class="ae lo" href="https://datanalyst.info?camp=rf~medium~pandas-intro-1" rel="noopener ugc nofollow" target="_blank">上的博客数据分析</a>。<br/>与此同时，我一次又一次地运行这个爬虫，有些人可能会说是以一种随机的方式；) .</p><p id="31f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">慕尼黑的房市贵，不是一点点，是真的贵。<br/>所以我在做我的爬虫，以便找到一个符合我预算的家。大部分是公寓(因为房子不在我的预算之内),位于慕尼黑地区。</p><p id="6e77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以从这个分析的偏见开始，这里有一些:</p><ul class=""><li id="e99c" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">我寻找“最多 4 个房间的公寓”</li><li id="6e27" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">我寻找“高达 60 万€”的公寓(大约 69 万美元)</li><li id="31a3" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">我找的是“离慕尼黑中心最多 20 公里”。</li><li id="95aa" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">我看了公寓是在一楼还是在楼上，但我没有看具体的楼层。</li></ul><p id="e7b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将我的数据保存为 csv 格式，你可以在我的 github 账户上找到:<a class="ae lo" href="https://github.com/pitchmuc/munich_housemarket.git" rel="noopener ugc nofollow" target="_blank">https://github.com/pitchmuc/munich_housemarket.git</a></p><h1 id="2365" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">了解熊猫的数据</h1><p id="c539" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">当我有数据集要查看时，我首先做两件事:</p><ol class=""><li id="760b" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk md lv lw lx bi translated">我观察数据集的大小。</li><li id="19e7" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk md lv lw lx bi translated">我看数据集的类型。</li></ol><p id="d315" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对我来说，数据集不是很大(150 kb)，所以我的电脑处理起来没有问题。如果它再大一点，我会把它分割成最大 100MB 的块，这样我就可以轻松地播放和测试我的脚本了。然后我会生成一个健壮的脚本来处理您的所有数据。<br/>当您对您的完整数据集(即:5GB)执行分析时，您希望在花费数小时运行您的分析并发现它没有达到您想要的效果之前，确保这是可行的。</p><p id="3b97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您必须处理的数据类型可以是:</p><ul class=""><li id="4fa2" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">clean:你只需要导入它</li><li id="78d3" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">半干净:您必须导入它，并处理一些丢失的数据。</li><li id="e6f5" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">一点也不干净:你必须清理一下，导入它并处理掉丢失的数据。</li></ul><p id="e89b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，我已经设法获得了相当干净到半干净的数据，但是仍然需要进行一些清理。<br/>在下面的步骤中，你将看到如何用 python 熊猫实现基本的清洁:</p><p id="706c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导入您想要使用的库。在我们的例子中，你想要熊猫和熊猫。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b1d1" class="mn km iq mj b gy mo mp l mq mr">import pandas as pd #naming convention <br/>import numpy as np #naming convention</span></pre><p id="95fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在您的环境中导入数据集。<br/>在我的例子中，我使用的是 ipython(或者叫做 jupyter notebook)。我真的很喜欢这种探索的环境。当事情变得严重时，我通常会去找 Spyder。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="27ed" class="mn km iq mj b gy mo mp l mq mr">df = pd.read_csv('data_immoscout.csv',delimiter='\t') # df is going to be our dataframe. (place where we store all the data). I used tab as delimiter.</span></pre><p id="682c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看你掌握的数据。使用。head()函数将给出你的数据的预览。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e3a2" class="mn km iq mj b gy mo mp l mq mr">df.head() ## use df.head(20) to get 20 lines</span></pre><p id="7f60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在 df.head()之上，您还可以尝试查看数据被处理的确切类型。<br/>为了做到这一点，你可以使用</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="34c6" class="mn km iq mj b gy mo mp l mq mr">df.dtypes ##it will give you something like this : <br/>index0 int64 <br/>terrace object <br/>bedrooms object <br/>construction_year object <br/>date_month int64 <br/>date_year int64 <br/>date_year_month object <br/>floor object <br/>rooms object <br/>price_room object <br/>price_surface object <br/>price object <br/>surface object <br/>zip int64 <br/>dtype: object</span></pre><p id="82c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看您拥有的列的类型非常重要，因为这通常会让您了解数据存储的类型。或者应该存储数据的类型。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="128b" class="mn km iq mj b gy mo mp l mq mr">df.columns # will give you something like : </span><span id="d8d2" class="mn km iq mj b gy ms mp l mq mr">Index(['index0', 'terrace', 'bedrooms', 'construction_year', 'date_month', 'date_year', 'date_year_month', 'floor', 'rooms', 'price_room', 'price_surface', 'price', 'scout_id', 'surface'], dtype='object')</span></pre><p id="095e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由此我可以给你一些关于这些数据的解释，但是通过 dtypes 和 head()来看这些数据实际上应该已经给了你这样的想法:</p><ul class=""><li id="f589" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">index0:这是表格的索引</li><li id="95cf" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">露台:有没有露台</li><li id="ec75" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">卧室:有多少间卧室</li><li id="122c" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">建造年份:什么时候建造的</li><li id="7135" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">date_month:一年中实现爬网的月份</li><li id="a9fc" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">date_year:实现爬网的年份</li><li id="ae19" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">date_year_month:实现爬网的月份和年份</li><li id="c8b2" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">地板:到底是不是底楼？</li><li id="91ad" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">房间:房间数量</li><li id="932d" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">价格 _ 房间数:公寓价格除以房间数</li><li id="7d79" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">价格 _ 表面:公寓价格除以表面</li><li id="9bbd" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">价格:公寓的价格</li><li id="99a0" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">表面:平面的表面</li><li id="bb5b" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">zip:公寓的邮政编码</li></ul><p id="412e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你开始处理这些数据时，你要做的第一件事是确保它们在系统中被正确识别。<br/>什么叫“正确的方式”？<br/>正确的做法是:数字看成数字，字符串看成字符串，日期看成日期，NaN 看成 NaN。</p><p id="a230" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">什么是南？</strong> <br/>南代表“不是一个数”。了解这一点非常重要，因为这是我们在最终处理它们之前想要清理的数据类型。</p><p id="0c8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你可能已经看到的，有几行实际上写的是 NAN。是公认的南吗？为了查看你有多少 NaN，你可以使用这个非常有用的函数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="738b" class="mn km iq mj b gy mo mp l mq mr">df.isna().sum() ## The result will look like this :</span><span id="e89e" class="mn km iq mj b gy ms mp l mq mr">index0               0<br/>terrace              0<br/>bedrooms             0<br/>construction_year    0<br/>date_month           0<br/>date_year            0<br/>date_year_month      0<br/>floor                0<br/>rooms                0<br/>price_room           0<br/>price_surface        0<br/>price                0<br/>surface              0<br/>zip                  0<br/>dtype: int64</span></pre><p id="7353" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着在您当前的数据集(或数据帧)中没有可识别的 NaN。<br/>‘NAN’只是我实际运行爬虫时设置的一个字符串。</p><p id="16ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，您将用 NaN 的正确定义替换“NAN”字符串。为了做到这一点，我们将使用 numpy 库，您只需要这样使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8a00" class="mn km iq mj b gy mo mp l mq mr">df.replace('NAN',np.NaN,inplace=True)</span><span id="aeaa" class="mn km iq mj b gy ms mp l mq mr">When we have done that, we will then see different result on the previous method : </span><span id="e82f" class="mn km iq mj b gy ms mp l mq mr">df.isna().sum() ## The result will look like this :</span><span id="a1f8" class="mn km iq mj b gy ms mp l mq mr">index0                 0<br/>terrace                0<br/>bedrooms             319<br/>construction_year     49<br/>date_month             0<br/>date_year              0<br/>date_year_month        0<br/>floor                113<br/>rooms                 34<br/>price_room            35<br/>price_surface        212<br/>price                  1<br/>surface              211<br/>zip                    0<br/>dtype: int64</span></pre><p id="ec09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们开始了解这些数据的实际情况。<br/>你看，我们缺少很多卧室信息的数据。<br/>在接下来的步骤中，我们的任务是尽可能减少 NaN。<br/>我们将尝试假设一些不同的策略来填充这里的 NaN。</p><p id="5df1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想看到你的数据集的整体质量，你实际上可以使用一些计算。<br/>像这样:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="baa3" class="mn km iq mj b gy mo mp l mq mr">(df.isnull().sum() / len(df))*100 ## result will look like this :</span><span id="c886" class="mn km iq mj b gy ms mp l mq mr">index0                0.000000<br/>terrace               0.000000<br/>bedrooms             36.708861<br/>construction_year     5.638665<br/>date_month            0.000000<br/>date_year             0.000000<br/>date_year_month       0.000000<br/>floor                13.003452<br/>rooms                 3.912543<br/>price_room            4.027618<br/>price_surface        24.395857<br/>price                 0.115075<br/>surface              24.280783<br/>zip                   0.000000<br/>dtype: float64</span></pre><p id="7c7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我提供的数据并不完美，但你可能会看到很多比这更糟糕的数据。<br/>了解数据:36.7%的行没有卧室信息。</p><p id="3a36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">真正令人不安的是，我们遗漏了一个特定数据点的价格信息。<br/>价格真的很难预测，但让我们看看是什么数据，我们可能会有所发现:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1c12" class="mn km iq mj b gy mo mp l mq mr">df[df['price'].isna()].T ##the result will look like this :</span><span id="0424" class="mn km iq mj b gy ms mp l mq mr">367</span><span id="dce7" class="mn km iq mj b gy ms mp l mq mr">index0 4</span><span id="52fc" class="mn km iq mj b gy ms mp l mq mr">terrace yes</span><span id="80f6" class="mn km iq mj b gy ms mp l mq mr">bedrooms NaN</span><span id="7eb9" class="mn km iq mj b gy ms mp l mq mr">construction_year 2016 </span><span id="3be6" class="mn km iq mj b gy ms mp l mq mr">date_month 8</span><span id="bb3b" class="mn km iq mj b gy ms mp l mq mr">date_year 2016</span><span id="9e32" class="mn km iq mj b gy ms mp l mq mr">date_year_month 2016_08</span><span id="6029" class="mn km iq mj b gy ms mp l mq mr">floor NaN</span><span id="8f48" class="mn km iq mj b gy ms mp l mq mr">rooms 5</span><span id="f3a0" class="mn km iq mj b gy ms mp l mq mr">price_room NaN</span><span id="142a" class="mn km iq mj b gy ms mp l mq mr">price_surface NaN</span><span id="a065" class="mn km iq mj b gy ms mp l mq mr">price NaN</span><span id="2852" class="mn km iq mj b gy ms mp l mq mr">surface 209</span><span id="c32b" class="mn km iq mj b gy ms mp l mq mr">zip 81479</span></pre><p id="a245" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你会发现我们遗漏了价格和卧室数量。<br/>我们有两种选择:</p><ul class=""><li id="cf9f" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">用我们掌握的信息预估价格(5 室，209 平米，建造年份:2016 年)</li><li id="fd74" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">从数据集中移除此线</li></ul><p id="5c04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的案例中，2016 年建造的 200 平方米可能会超出我的数据集限制(&lt;600 K€). I will then remove the line from the data set.</p><p id="293a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">From my extract, I saw that the index of that line is 367.<br/>我可以通过以下简单操作删除该线:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2d71" class="mn km iq mj b gy mo mp l mq mr">df.drop(df.index[367],inplace=True)</span></pre><p id="31f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果你有不止一个索引，你怎么管理呢？</p><p id="ba22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你只需要大声说出你的病情指数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ba01" class="mn km iq mj b gy mo mp l mq mr">df.drop(df[df['price'].isna()].index,inplace = True)</span></pre><p id="2be7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们正在删除无用的信息，我们可以借此机会删除 index0 列，因为您可能已经看到 pandas 会自动为您的数据帧生成一个索引。<br/>为了完全删除一列，你需要实现这个动作:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6b62" class="mn km iq mj b gy mo mp l mq mr">df.drop(['index0'],axis=1,inplace=True) #axis = 1 make sure that you are deleting column</span></pre><p id="bf21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们想让熊猫识别正确的数据类型。<br/>拥有正确的数据类型将允许我们实现对数值类型(int 或 float)的数值运算。<br/>如果我们有正确的数据类型集，我们将能够以更好的方式处理 NaN。</p><p id="c5bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我建议总是将数值设置为 int。<br/>为什么<strong class="jp ir"> int </strong>？因为它更容易处理和解释，但你可以试着让一切都浮动起来。<br/>浮点数可以表示整数(2.0 == 2)但整数不能表示某些浮点数(2.1！= 2)</p><p id="eef4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个简单的循环可能是这样的:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="bdb0" class="mn km iq mj b gy mo mp l mq mr">for col in list(df.columns): # for each column<br/>   try:<br/>       df[col] = df[col].astype(int) #try to set it as int<br/>   except:<br/>       df[col] = df[col].astype(str) # if not sucessful try to set it as string</span></pre><p id="f8bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您实现这个操作时，您可以看到并不是所有的列都被更改为数字。<br/>这主要是因为某些列不是整数而是浮点数。(所以一个小数)</p><p id="47b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以实现另一个循环:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5880" class="mn km iq mj b gy mo mp l mq mr">for col in list(df.columns):<br/>    if df[col].dtypes == object:<br/>        try:<br/>            df[col] = df[col].astype(float)<br/>        except:<br/>            df[col] = df[col].astype(str)</span><span id="c75d" class="mn km iq mj b gy ms mp l mq mr">Then by doing a simple overview, your data start to look like something you can work :</span><span id="96e5" class="mn km iq mj b gy ms mp l mq mr">df.dtypes # it will show something like this :</span></pre><p id="1b64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Out[32]:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4876" class="mn km iq mj b gy mo mp l mq mr">terrace               object<br/>bedrooms             float64<br/>construction_year    float64<br/>date_month             int32<br/>date_year              int32<br/>date_year_month        int32<br/>floor                 object<br/>rooms                float64<br/>price_room           float64<br/>price_surface        float64<br/>price                  int32<br/>surface              float64<br/>zip                    int32<br/>dtype: object</span></pre><h1 id="175f" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">填充 NaN</h1><p id="2b58" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">现在我们已经准备好处理不同类型的数据，我们将使用我们的大脑来处理不同的数据类型并填充 NaN 值。<br/>如前所述，在进行任何分析之前，您可能想要感觉缺失值的最大值，以便计算最大值。</p><p id="cdae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">填写楼层栏</strong>T3】你应该还记得，这一栏告诉我们这是不是底层。<br/>通过这个简单的方法，你可以看到不同的值和它们出现的次数。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c9e2" class="mn km iq mj b gy mo mp l mq mr">df['floor'].value_counts() ### Should show something like this :up floor 687 <br/>nan 112 <br/>ground floor 69 <br/>Name: floor, dtype: int64</span></pre><p id="8ef0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您需要做的是计算楼上和楼下之间的分布，并将该分布应用于其余数据。你可以很容易地计算出底层公寓的数量约占本栏的 10%。<br/>因此，我们需要用“底层”值替换 na 的 1/10。</p><p id="c216" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过简单地创建一个函数来实现:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="87aa" class="mn km iq mj b gy mo mp l mq mr">def fill10pct(): <br/>    if np.random.random_integers(0,9) == 0: <br/>        return 'ground floor' <br/>    else: <br/>        return 'up floor'</span></pre><p id="f3dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，您需要将它应用到您的行:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="141b" class="mn km iq mj b gy mo mp l mq mr">for index, value in df.iterrows(): <br/>    if df.loc[index,'floor']=='nan': <br/>        df.loc[index,'floor'] = fill10pct()</span></pre><p id="599b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以运行 df['floor']。value_counts()来检查是否保持了分布。</p><p id="7b5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">填充房间现在我们将尝试填充房间。<br/>我们将在这里尝试一种不同的技术。我们有一些信息可以帮助我们确定总共有多少个房间。<br/>有卧室信息，所以在德国的邮政公寓中，卧室是唯一从房间数中分开统计的房间。<br/>也就是:三室是指两个卧室，一个大房间，一个厨房和一个卫生间。<br/>所以我们可以说房间的数量是卧室的数量+1，但是如果我们没有卧室的数量呢？那么，为了简单起见，我们可以说房间的数量是 2。这是我能拿到的最低工资。为此我们将创造我们的 2 个条件(有或没有若干卧室)</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3262" class="mn km iq mj b gy mo mp l mq mr">conditions = [ (df['rooms'].isnull()) &amp; (df['bedrooms'].isnull()), (df['rooms'].isnull()) &amp; (df['bedrooms'].notnull())] <br/>choices = [2,df['bedrooms']+1]<br/>df['rooms'] = np.select(conditions, choices, default=2)</span></pre><p id="754f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用 numpy select 函数来决定应用哪个选项</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="89cf" class="mn km iq mj b gy mo mp l mq mr">df['rooms'] = np.select(conditions, choices, default=2)</span></pre><p id="559d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你知道怎么做时，这很容易。:)它太简单了，所以我们将把它做得更健壮一点，并在其中集成曲面。我们会说，如果表面大于 75 平方米，我们将设置房间数为 3。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fc2e" class="mn km iq mj b gy mo mp l mq mr">conditions =[ <br/>(df['rooms'].isnull()) &amp; (df['bedrooms'].isnull()) &amp; (df['surface'].isnull()), <br/>(df['rooms'].isnull()) &amp; (df['bedrooms'].isnull()) &amp; (df['surface']&gt;75), <br/>(df['rooms'].isnull()) &amp; (df['bedrooms'].notnull()), ] choices = [2,3,df['bedrooms']+1] <br/>df['rooms'] = np.select(conditions,choices,default=2)</span></pre><p id="8105" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">填充卧室</strong> <br/>填充卧室其实是相反的逻辑。如果你有房间的数量，你实际上可以猜出卧室的数量。<br/>这一次，我们将使用从 numpy 中选择的方法:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7684" class="mn km iq mj b gy mo mp l mq mr">df['bedrooms'] = np.where(df['bedrooms'].isnull(), df['rooms']-1, df['bedrooms'])</span></pre><p id="159e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">填充表面</strong> <br/>对于表面，我们缺少 211 个数据点。我们可以有相同的策略，而不是房间的数量。外推现有公寓的表面以填充表面的缺失值。如果我们能得到 2、3 和 4 房间公寓的平均面积，我们就能给这些房间分配平均值。为了实现这一点，我们将使用熊猫最重要的功能之一。<strong class="jp ir">组由</strong>组成。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="184e" class="mn km iq mj b gy mo mp l mq mr">df.groupby(['rooms'])['surface'].mean() ##it should give you something like :<br/>2.0 89.988924 <br/>3.0 91.100000 <br/>4.0 100.40000</span></pre><p id="f928" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有趣的是，你的 2 室和 3 室公寓的平均面积没有太大差别。很可能我们的数据没有那么干净，一些三室公寓被当成了两室公寓。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="38cb" class="mn km iq mj b gy mo mp l mq mr">conditions = [<br/>(df['rooms']==2 &amp; df['surface'].isnull()), <br/>(df['rooms']==3 &amp; df['surface'].isnull()), <br/>(df['rooms']==4 &amp; df['surface'].isnull()) ] <br/>choices = [90,91.1,100] <br/>df['surface'] = np.select(conditions,choices,default=90.5)#default in between 2 and 3 rooms</span></pre><p id="2960" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">填写建造年份</strong> <br/>在这个例子中，这是相当困难的，因为建造年份可能是随机的。你无法根据之前的数据猜测建造年份。<br/>在这种情况下，为了不虚报数据，我会选择用这个维度的含义来填补空白。<br/>这是另一种你可以在熊猫身上快速使用的方法:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5dc5" class="mn km iq mj b gy mo mp l mq mr">df['construction_year'].fillna(df['construction_year'].mean(),inplace=True)</span></pre><p id="396a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">填充剩余的… </strong> <br/>正如你在做 df.isnull()时可能注意到的。sum()其他一些列有 NaN，但它们实际上是其他列的计算结果。所以你只需要用你的主列重新计算，所有的 NaN 就会消失。</p><p id="7f74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您正在使用 Python 和 Pandas 进行数据分析，我希望这篇关于如何清理数据的教程能够对您有所帮助。<br/>这是处理数据的一个非常重要的部分，如果您计划进行机器学习，清理数据并从 NaN 数据点中创造价值是机器学习最重要的方面之一。</p><p id="cbd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如标题所示，我们将有第二篇文章，在那里我们实际分析数据，我们可能会尝试做一些可视化。</p><p id="00b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要犹豫，评论并给出你的提示来分析这个数据集。<br/>如上所述，数据集(干净的和不干净的)和 Jupyter 笔记本都在我的 Github 账户上:<a class="ae lo" href="https://github.com/pitchmuc/munich_housemarket" rel="noopener ugc nofollow" target="_blank">https://github.com/pitchmuc/munich_housemarket</a></p></div></div>    
</body>
</html>