<html>
<head>
<title>Pandas DataFrame: Playing with CSV files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫数据帧:使用 CSV 文件</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pandas-dataframe-playing-with-csv-files-944225d19ff?source=collection_archive---------0-----------------------#2018-11-02">https://towardsdatascience.com/pandas-dataframe-playing-with-csv-files-944225d19ff?source=collection_archive---------0-----------------------#2018-11-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/b10033776b28aa6a21579300c0cdfcc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RMk5Z0-rgO8SDOqYARxh0A.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Pandas DataFrame: Playing with CSV files</figcaption></figure><div class=""/></div><div class="ab cl kc kd hu ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ij ik il im in"><blockquote class="kj kk kl"><p id="fd8f" class="km kn ko kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">CSV 代表逗号分隔值，这是一种在持久性存储中表示和存储面向表格、列的数据的流行方式</p></blockquote></div><div class="ab cl kc kd hu ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ij ik il im in"><p id="c37d" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">Pandas DataFrames 通常用于表示内存中类似 Excel 的数据。在大多数情况下，我们很可能会从持久存储中加载数据，持久存储可以是数据库或 CSV 文件。</p><p id="5fb0" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">在这篇文章中，我们将会看到如何使用 Pandas DataFrame 加载、存储和播放 CSV 文件</p><h2 id="1f01" class="lo lp jf bd lq lr ls dn lt lu lv dp lw ll lx ly lz lm ma mb mc ln md me mf mg bi translated">概述熊猫数据框架</h2><p id="c585" class="pw-post-body-paragraph km kn jf kp b kq mh ks kt ku mi kw kx ll mj la lb lm mk le lf ln ml li lj lk ij bi translated">我已经写了一篇名为<a class="ae mm" rel="noopener" target="_blank" href="/pandas-dataframe-a-lightweight-intro-680e3a212b96">熊猫数据框架:轻量级介绍</a>的详细文章。如果你对熊猫数据框架不满意，我强烈建议你在继续这篇文章之前先看看这篇文章。</p><p id="3120" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">简而言之，Pandas DataFrame 只不过是 excel 之类的数据在内存中的表示。举个例子，</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mn"><img src="../Images/1b36c5990b6aac4ea79c2b4e66219d0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*btF47oH4wu-DMi6CGQeyhg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Pandas DataFrame → Excel like Data in Memory</figcaption></figure><p id="1b9b" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">该数据也可以使用 Python 字典表示为</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="bbab" class="lo lp jf mt b gy mx my l mz na">my_dict = { 'name' : ["a", "b", "c", "d", "e","f", "g"],<br/>                   'age' : [20,27, 35, 55, 18, 21, 35],<br/>                   'designation': ["VP", "CEO", "CFO", "VP", "VP", "CEO", "MD"]}</span></pre><p id="cc32" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">我们知道我们可以通过调用<code class="fe nb nc nd mt b">DataFrame(...)</code>函数从 python 字典中创建一个熊猫数据帧</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6a12" class="lo lp jf mt b gy mx my l mz na">df = pd.DataFrame(my_dict)</span></pre><p id="8c3d" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">生成的数据帧应如下所示</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/a2a3ae3fb941295413a5696b33cb302b.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*igJHDyn7AXFlMqMolnQ_Hw.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Pandas DataFrame → From Python Dictionary</figcaption></figure></div><div class="ab cl kc kd hu ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ij ik il im in"><h1 id="8e9a" class="nf lp jf bd lq ng nh ni lt nj nk nl lw nm nn no lz np nq nr mc ns nt nu mf nv bi translated">将数据帧保存到 CSV 文件中</h1><p id="9bf8" class="pw-post-body-paragraph km kn jf kp b kq mh ks kt ku mi kw kx ll mj la lb lm mk le lf ln ml li lj lk ij bi translated">一旦我们有了数据帧，我们可以将它保存在本地磁盘上的 CSV 文件中。让我们首先使用数据帧中当前存在的数据创建我们自己的 CSV 文件，我们可以使用 Pandas 数据帧的 API<code class="fe nb nc nd mt b">to_csv(...)</code>以 CSV 格式存储该数据帧的数据</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6577" class="lo lp jf mt b gy mx my l mz na">df.to_csv('csv_example')</span></pre><p id="20c8" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">现在我们有了 CSV 文件，它包含了上面数据帧中的数据。</p><blockquote class="kj kk kl"><p id="f6ac" class="km kn ko kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">正如我们可以将数据帧保存在 CSV 文件中一样，我们也可以从 CSV 文件中加载数据帧。</p></blockquote><p id="12ad" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">让我们继续加载 CSV 文件，并从中创建一个新的数据帧</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f6f4" class="lo lp jf mt b gy mx my l mz na">df_csv = pd.read_csv('csv_example')</span></pre><p id="a4b2" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">生成的数据帧(df_csv)应如下所示</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/e6cd6f12acb4cc1821221d6a019e816b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*DUmyZOddeOoGa0FLuFIcxA.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">df_csv</figcaption></figure><blockquote class="nx"><p id="2834" class="ny nz jf bd oa ob oc od oe of og lk dk translated">你注意到不寻常的事情了吗？</p></blockquote><p id="a48e" class="pw-post-body-paragraph km kn jf kp b kq oh ks kt ku oi kw kx ll oj la lb lm ok le lf ln ol li lj lk ij bi translated">嗯，我们可以看到这个索引生成了两次，第一次是从 CSV 文件加载的，而第二次，也就是<code class="fe nb nc nd mt b">Unnamed</code>是熊猫在加载 CSV 文件时自动生成的。</p><p id="6b6b" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">这个问题可以通过确保 CSV 文件的写入不写索引来避免，因为<code class="fe nb nc nd mt b">DataFrame</code>无论如何都会生成。我们可以通过在<code class="fe nb nc nd mt b">to_csv(...)</code>函数中指定<code class="fe nb nc nd mt b">index = False</code>参数来做同样的事情</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="b7e9" class="lo lp jf mt b gy mx my l mz na">df.to_csv('csv_example', index=False)</span></pre><p id="4f31" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">现在，如果我们把文件读成</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="de30" class="lo lp jf mt b gy mx my l mz na">df_csv = pd.read_csv('csv_example')</span></pre><p id="22a1" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">生成的数据帧应如下所示</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi om"><img src="../Images/d3b0fc28ee3646ca6798fef4d55bb6d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*OMApra8UGerHuJY5YpGfkg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">df_csv</figcaption></figure><p id="e8e1" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">现在，您可以看到输出类似于我们之前从 python 字典创建数据帧时的输出，这是我们所期望的。</p></div><div class="ab cl kc kd hu ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ij ik il im in"><h2 id="d92c" class="lo lp jf bd lq lr ls dn lt lu lv dp lw ll lx ly lz lm ma mb mc ln md me mf mg bi translated">玩弄列标题</h2><p id="4e4e" class="pw-post-body-paragraph km kn jf kp b kq mh ks kt ku mi kw kx ll mj la lb lm mk le lf ln ml li lj lk ij bi translated">正如我们已经看到的，第一行总是被认为是列标题，但是，通过在<code class="fe nb nc nd mt b">read_csv(...)</code>函数中指定一个名为<code class="fe nb nc nd mt b">header=&lt;integer&gt;</code>的参数，可以有多行作为列标题。</p><p id="8679" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">默认情况下，该值被指定为“0”，这意味着第一行将被视为标题。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="070c" class="lo lp jf mt b gy mx my l mz na">df_csv = pd.read_csv('csv_example', header = 0)</span></pre><p id="1b69" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">结果输出将与上面相同。然而，它提供了很多机会来安排头球。例如，我们也可以将多行作为标题</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="2ba4" class="lo lp jf mt b gy mx my l mz na">df_csv = pd.read_csv('csv_example', header=[0,1,2])</span></pre><p id="4805" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">生成的数据帧应如下所示</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div class="gh gi on"><img src="../Images/e7e03c3f6ae918e8f977d95e1544eb82.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*WE2wtw-0TAG7KZmyQGkCqQ.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">df_csv → with 3 rows as Header</figcaption></figure><p id="9bc1" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">正如我们在这里看到的，列 0、1 和 2 现在是标题。</p><blockquote class="kj kk kl"><p id="bbec" class="km kn ko kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">也没有必要将第一行序列作为标题，我们可以跳过前几行，然后从特定的行开始查看表格</p></blockquote><p id="04a7" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">例如</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="44da" class="lo lp jf mt b gy mx my l mz na">df_csv = pd.read_csv('csv_example', header=5)</span></pre><p id="1969" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">这里，产生的数据帧应该看起来像</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/872373f9a44278304c322e5a73e91d6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:460/format:webp/1*fhUD7G6ONxUHTvMYTWSWCg.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">df_csv → After skipping 5 rows</figcaption></figure><p id="5027" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">唯一的缺点是我们必须放弃标题行号之前的可用数据。它不能是结果数据帧的一部分。</p><p id="a193" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">即使在标题为多行的情况下，实际数据帧数据也只能从最后一个标题行之后的行开始。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="c57c" class="lo lp jf mt b gy mx my l mz na">df_csv = pd.read_csv('csv_example', header=[1,2,5])</span></pre><p id="9a71" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">产生的数据帧将从行“6”开始，看起来应该像这样</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div class="gh gi op"><img src="../Images/43494b775a64bfc04425860b034ac3e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*YKYBPtff5qE68JjjRxhCTA.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">df_csv → Multiple Row Headers</figcaption></figure></div><div class="ab cl kc kd hu ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ij ik il im in"><h2 id="ac76" class="lo lp jf bd lq lr ls dn lt lu lv dp lw ll lx ly lz lm ma mb mc ln md me mf mg bi translated">自定义列名</h2><p id="4336" class="pw-post-body-paragraph km kn jf kp b kq mh ks kt ku mi kw kx ll mj la lb lm mk le lf ln ml li lj lk ij bi translated">尽管我们从带有列标题的 CSV 文件中读取数据，但我们仍然可以拥有自己的列名。我们可以通过在<code class="fe nb nc nd mt b">read_csv(...)</code>中添加一个名为<code class="fe nb nc nd mt b">names</code>的参数来达到同样的效果</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="2939" class="lo lp jf mt b gy mx my l mz na">df_csv = pd.read_csv('csv_example', names=['a', 'b', 'c'])</span></pre><p id="24f6" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">生成的数据帧应如下所示</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/fed33753128a1f4e0526c8ad5c35280d.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*fridb28EwIhIYU78IdJiTg.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">df_csv → with our own column names</figcaption></figure><p id="5b35" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">然而，即使我们成功地添加了自己的标题，顶行仍然显示一个不需要的标题。</p><p id="5d26" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">这可以通过使用<code class="fe nb nc nd mt b">read_csv(…)</code>中的<code class="fe nb nc nd mt b">header</code>参数跳过描述标题的行来避免。在这种特殊情况下，我们知道第一行，即第 0 行是标题，所以我们可以跳过它</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="438c" class="lo lp jf mt b gy mx my l mz na">df_csv = pd.read_csv('csv_example', names=['a', 'b', 'c'], header=1)</span></pre><figure class="mo mp mq mr gt is gh gi paragraph-image"><div class="gh gi or"><img src="../Images/9171df983d872362a7af835a8230260f.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*QngwQIxdnpAWBmVtutSH1g.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">df_csv → With Customised Header</figcaption></figure><p id="99bf" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">现在，我们得到了我们想要的带有定制头的输出。</p><p id="4396" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">另一种方法是在将 CSV 文件写成</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="a8aa" class="lo lp jf mt b gy mx my l mz na">df.to_csv('csv_example', index=False, header = False)</span></pre><p id="ec1b" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">阅读时，我们可以不跳过标题</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="5e82" class="lo lp jf mt b gy mx my l mz na">df_csv = pd.read_csv('csv_example', names=['AGE', 'DESIGNATION', 'NAME'])</span></pre><figure class="mo mp mq mr gt is gh gi paragraph-image"><div class="gh gi os"><img src="../Images/b139250005c7a6e6decbd1da904b1f80.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*XBa92CcdCmVkn3dTT4hMFA.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">df_csv → With customised header</figcaption></figure></div><div class="ab cl kc kd hu ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ij ik il im in"><h1 id="0846" class="nf lp jf bd lq ng nh ni lt nj nk nl lw nm nn no lz np nq nr mc ns nt nu mf nv bi translated">CSV 到(任何)分隔值</h1><p id="9f59" class="pw-post-body-paragraph km kn jf kp b kq mh ks kt ku mi kw kx ll mj la lb lm mk le lf ln ml li lj lk ij bi translated">虽然逗号分隔的值是众所周知的，但是<code class="fe nb nc nd mt b">read_csv(...)</code>函数可以识别逗号以外的分隔符。</p><p id="29ce" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">唯一的区别是，我们需要在函数中显式传递分隔符，而默认情况下使用逗号</p><p id="f3e6" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated"><em class="ko">让我们首先使用不同的分隔符创建一个 CSV 文件，即“:”(冒号)</em></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="047c" class="lo lp jf mt b gy mx my l mz na">df.to_csv('csv_example', index=False, sep=":")</span></pre><p id="8e66" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">这将创建一个文件，其中冒号(':')而不是逗号('，')将用作分隔符。我们可以这样阅读文件</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f142" class="lo lp jf mt b gy mx my l mz na">df_csv = pd.read_csv('csv_example', sep=":")</span></pre><p id="94be" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">生成的数据帧应如下所示</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/f26ce5413635e90cff446ad704136e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*8liINhUPJmc9U9JYMXy6Mg.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">df_csv → with “:” as separator</figcaption></figure></div><div class="ab cl kc kd hu ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ij ik il im in"><h1 id="8840" class="nf lp jf bd lq ng nh ni lt nj nk nl lw nm nn no lz np nq nr mc ns nt nu mf nv bi translated">设置行索引</h1><p id="6f58" class="pw-post-body-paragraph km kn jf kp b kq mh ks kt ku mi kw kx ll mj la lb lm mk le lf ln ml li lj lk ij bi translated">默认情况下，Pandas DataFrame 会自动生成一个行索引，我们可以通过将任何列设置为索引来进行更改</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="ab5d" class="lo lp jf mt b gy mx my l mz na">df_csv.set_index('age')</span></pre><p id="53f9" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">下面是结果数据帧的样子</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/f79c0cd5207f1233f6606682c29577a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*SSHaQbA1pschU1kavKpUMg.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">df_csv → Using ‘age’ as row index</figcaption></figure><p id="2bca" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">以这种方式设置索引是一种后期操作。也就是说，我们已经有了一个带有预定义索引的数据框架，但是我们后来又改变了它。</p><p id="45ec" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">我们可以在加载 CSV 文件时通过传递一个名为<code class="fe nb nc nd mt b">index_col</code>的参数来做到这一点，该参数将自动分配由<code class="fe nb nc nd mt b">index_col</code>描述的列作为行索引。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="8bb7" class="lo lp jf mt b gy mx my l mz na">df_csv = pd.read_csv('csv_example', sep=":", index_col=1)</span></pre><p id="0d26" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">同样的输出应该看起来像</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/dabe5a0fef532a162d305a3dffa82f53.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*eA9PbDGnd3_oGj1tQe84Vg.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">df_csv → with index_col = 1</figcaption></figure><p id="6f1e" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">我们甚至可以提供一个以上的<code class="fe nb nc nd mt b">index_col</code>作为索引来对待</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="7a1a" class="lo lp jf mt b gy mx my l mz na">df_csv = pd.read_csv('csv_example', sep=":", index_col=[0,2])</span></pre><p id="8835" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">输出将会是这样的</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/7a9210aa16c1d596585d1eb8b5ce307c.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*ku_hPIsiVdRWnAxG9o50UA.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">df_csv → index_col = [0,2]</figcaption></figure></div><div class="ab cl kc kd hu ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ij ik il im in"><h2 id="6658" class="lo lp jf bd lq lr ls dn lt lu lv dp lw ll lx ly lz lm ma mb mc ln md me mf mg bi translated">如果不需要所有的行…不要加载它们</h2><p id="3862" class="pw-post-body-paragraph km kn jf kp b kq mh ks kt ku mi kw kx ll mj la lb lm mk le lf ln ml li lj lk ij bi translated">大多数情况下，CSV 文件都相当大，加载时可能会遇到内存限制。有一个选项，只从它加载选定的几行。</p><p id="2d91" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">您可以通过在<code class="fe nb nc nd mt b">read_csv(...)</code>中传递一个参数<code class="fe nb nc nd mt b">nrows</code>来指定要加载的行数</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6941" class="lo lp jf mt b gy mx my l mz na"># Load Only 3 Rows<br/>df_csv = pd.read_csv('csv_example', sep=":", nrows=3)</span></pre><p id="f6b5" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">这是它看起来的样子</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/868163a8c89f0f25663e6ea0c8215ac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*pg0xafcvOp9GUAh9dNKFTQ.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">df_csv → Loading only 3 Rows</figcaption></figure></div><div class="ab cl kc kd hu ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ij ik il im in"><h2 id="a64b" class="lo lp jf bd lq lr ls dn lt lu lv dp lw ll lx ly lz lm ma mb mc ln md me mf mg bi translated">跳过 CSV 文件中的空行</h2><blockquote class="kj kk kl"><p id="8a5e" class="km kn ko kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">默认情况下，<code class="fe nb nc nd mt b">read_csv(...)</code>函数跳过空行，即在加载文件和构建数据帧时会忽略空行。</p></blockquote><p id="6911" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">但是，如果您想要加载空行来进行一些显式的计算，比如对空记录进行计数，您应该将跳过的空行标记为<code class="fe nb nc nd mt b">False</code></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="ae25" class="lo lp jf mt b gy mx my l mz na">df_csv = pd.read_csv('csv_example', skip_blank_lines=False, sep=":")</span></pre><p id="2f34" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">这就是这篇文章的全部内容</p><p id="f529" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">感谢阅读…！！！</p><p id="0916" class="pw-post-body-paragraph km kn jf kp b kq kr ks kt ku kv kw kx ll kz la lb lm ld le lf ln lh li lj lk ij bi translated">达克什</p></div></div>    
</body>
</html>