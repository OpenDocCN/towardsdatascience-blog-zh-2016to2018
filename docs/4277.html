<html>
<head>
<title>kMeans Hash Search on Map Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">kMeans 对地图数据进行哈希搜索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/kmeans-hash-search-map-search-in-o-n%C2%B2lgn-33743ece434f?source=collection_archive---------11-----------------------#2018-08-03">https://towardsdatascience.com/kmeans-hash-search-map-search-in-o-n%C2%B2lgn-33743ece434f?source=collection_archive---------11-----------------------#2018-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b057" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">kMeans 聚类算法因其作为“无监督人工智能”学习算法的分类而非常受欢迎。这种聚类的工作原理是将数据集的要素组合在一起，以区分实体。实体可以是地理上的一个地方，例如加利福尼亚的旧金山。</p><p id="312c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你长时间使用谷歌地图 API 处理街道数据时，你会产生一种新的语感。纬度/液化天然气坐标系统是观察庞大社会的一种不可思议的方式。您甚至可以立即认出下图中的 JSON 坐标是在美国还是在英国。</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="552c" class="ku kv iq kq b gy kw kx l ky kz">{ lat: 36.778, lng: -119.4179 }</span></pre><p id="5156" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们试图理解像旧金山湾区这样的大规模道路网络时，(如下图)。我们意识到我们需要开发二维(lat/lng)空间的搜索算法。</p><figure class="kl km kn ko gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi la"><img src="../Images/39a07606a0de6da8554a93c371381ce1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yb_yo-UPO_q-PU45VdWPew.png"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">San Francisco Road Map</figcaption></figure><p id="5d9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">旧金山有很多很酷的地方可以看，初创公司也有很多机会找到很酷的办公场所并招募他们的团队。然而，对于我们当前的算法来说，搜索给定半径内的地点并计算最短路径并不容易。</p><p id="a417" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从计算复杂性的角度来看，使用地图数据和创建地图用户界面的问题在于这些数据的巨大复杂性。以运行在 O(n log n)中的 mergsort 等传统排序算法为例。这个算法只适用于一维向量空间。而使用某种径向基函数将 lat / lng 映射到一维坐标平面可能是一种有效的解决方案。本文将讨论开发一种搜索算法，同时保持更自然的二维 lat/lng 数据集。</p><p id="279b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在现代计算机系统中对道路网络数据建模的标准是图形数据库。图被表示为 n×n 矩阵，其中 n[i][j]处的值包含节点之间的距离。然而，典型的道路数据被编码为一个非常精细的矩阵，lat/lng 十进制值跟踪到 7 位。L1/曼哈顿纬度/液化天然气距离将唐人街(SF)和恩巴卡德罗路(SF)区分为. 000008，这并不罕见。</p><p id="2e52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于这个原因，在将 lat/lng 全部乘以大约 10，000，000 后，在我们的数据集中开始编码可能是有用的。这样，在使用图形数据库搜索道路地图的几何图形之后，我们可以很容易地用“500 英尺”来表示距离。</p><p id="11a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">怎样才能用拓扑几何加速空间查询？</p><p id="8bfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">旅行商问题可以说是计算机科学中最著名的 NP 难问题。此问题计算通过迷宫(如道路网络)并到达最终目的地所需的最短时间。</p><p id="9503" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如许多旅行者所知，在一个大城市的道路网络中导航以计划最终的假期是非常困难的。</p><p id="fd5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以旧金山为例:</p><p id="22cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一天:{观景廊/渔人码头/日本广场/小意大利/唐人街/甲骨文球馆/美国电话电报公司球馆/金门公园}</p><p id="1886" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些令人惊叹的旅游目的地都可以组织成一系列</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="1706" class="ku kv iq kq b gy kw kx l ky kz">{ lat: (float), lng: (float) }</span></pre><p id="2020" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用地图需要大量的数据工程和管道来帮助纠正维度失衡和填充缺失的数据点。</p><p id="3589" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据工程:将 XML 转换成 JSON。我们的大部分处理都是在 csv 文件和 JSON 文件上完成的，前者在 Python 中容易阅读，后者在 JavaScript 中容易阅读。JavaScript 特别有用，因为它可以连接前端、后端和数据库逻辑，构建强大的 web 应用程序。</p><p id="d901" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">研究地理边界数据时，您可能会发现 XML 格式的数据，如下所示:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="bdb9" class="ku kv iq kq b gy kw kx l ky kz">&lt;state name="Minnesota" colour="#0000ff"&gt;<br/>&lt;point lat="43.5008" lng="-96.4517"/&gt;<br/>&lt;point lat="43.5017" lng="-91.2195"/&gt;<br/>&lt;point lat="43.8226" lng="-91.3101"/&gt;<br/>&lt;point lat="43.9651" lng="-91.4914"/&gt;<br/>&lt;point lat="44.1113" lng="-91.7084"/&gt;<br/>&lt;point lat="44.2806" lng="-91.8951"/&gt;<br/>&lt;point lat="44.3710" lng="-91.9556"/&gt;<br/>&lt;point lat="44.4357" lng="-92.2083"/&gt;<br/>&lt;point lat="44.5513" lng="-92.3360"/&gt;</span></pre><p id="46f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要编写一个 python 脚本来将它转换成一个字符串列表，我们可以将它硬编码成 JavaScript 来概括这些状态。</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="f397" class="ku kv iq kq b gy kw kx l ky kz">var MinnesotaCoords = [<br/> {lat: 36.9971, lng: -109.0448 },<br/> {lat: 31.3337, lng: -109.0489 },<br/> {lat: 31.3349, lng: -108.2140 },<br/> {lat: 31.7795, lng: -108.2071 },<br/> {lat: 31.7830, lng: -106.5317 },<br/> {lat: 32.0034, lng: -106.6223 },<br/> {lat: 31.9999, lng: -103.0696 },<br/> {lat: 36.9982, lng: -103.0023 },<br/> {lat: 36.9982, lng: -109.0475 },<br/>];</span></pre><p id="47ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦你有了这些，你将能够使用 kMeans 算法来组织地理信息，比如下面用 Python 写的大量代码块。</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="dcc3" class="ku kv iq kq b gy kw kx l ky kz">pointSet = [["Arizona (AZ)", 34.054455, -111.293573], ["Arkansas (AR)", 35.201050, -91.831833],<br/> ["California (CA)", 36.778261, -119.417932], ["Colorado (CO)", 39.550051, -105.782067], <br/> ["Connecticut (CT)", 41.603221, -73.087749], ["Florida (FL)", 27.664827, -81.515754], <br/> ["Georgia (GA)", 32.165622, -82.900075], ["Illinois (IL)", 40.633125, -89.398528], <br/> ["Maryland (MD)", 39.045755, -76.641271], ["Michigan (MI)", 44.314844, -85.602364] ];<br/>cluster1 = []<br/>cluster2 = []<br/>cluster3 = []<br/>cluster4 = []<br/>cluster5 = []<br/>def calculateDistance(a,b):<br/>    return (abs(a[1] - b[1]) + abs(a[2] - b[2]))<br/>def getMeanValue(pointSet):<br/>    xSum = 0<br/>    ySum = 0<br/>    for i in range(len(pointSet)):<br/>        xSum += pointSet[i][1]<br/>        ySum += pointSet[i][2]<br/>    xAvg = 0<br/>    yAvg = 0<br/>    if (len(pointSet) != 0):<br/>        xAvg = xSum / len(pointSet)<br/>        yAvg = ySum / len(pointSet)<br/>    return ["DimensionFill", xAvg, yAvg]<br/>def initializeCentroids(pointSet):<br/>    mean = getMeanValue(pointSet)<br/>    centroid1 = ["DimensionFill", mean[1] + 10, mean[2] + 10]<br/>    centroid2 = ["DimensionFill", mean[1] + 5, mean[2] - 5]<br/>    centroid3 = ["DimensionFill", mean[1], mean[2]]<br/>    centroid4 = ["DimensionFill", mean[1] - 5, mean[2] - 5]<br/>    centroid5 = ["DimensionFill", mean[1] - 10, mean[2] - 10]<br/>    return [centroid1, centroid2, centroid3, centroid4, centroid5]<br/>    <br/>centroids = initializeCentroids(pointSet)<br/>centroid1 = centroids[0]<br/>centroid2 = centroids[1]<br/>centroid3 = centroids[2]<br/>centroid4 = centroids[3]<br/>centroid5 = centroids[4]<br/>j = 1<br/>for i in range(len(pointSet)):<br/>    dist1 = calculateDistance(pointSet[i], centroid1)<br/>    dist2 = calculateDistance(pointSet[i], centroid2)<br/>    dist3 = calculateDistance(pointSet[i], centroid3)<br/>    dist4 = calculateDistance(pointSet[i], centroid4)<br/>    dist5 = calculateDistance(pointSet[i], centroid5)<br/>    if (dist1 &lt; dist2 and dist1 &lt; dist3 and dist1 &lt; dist4 and dist1 &lt; dist5):<br/>        cluster1.append(pointSet[i])<br/>    elif (dist2 &lt; dist1 and dist2 &lt; dist3 and dist2 &lt; dist4 and dist2 &lt; dist5):<br/>        cluster2.append(pointSet[i])<br/>    elif (dist3 &lt; dist1 and dist3 &lt; dist2 and dist3 &lt; dist4 and dist3 &lt; dist5):<br/>        cluster3.append(pointSet[i])<br/>    elif (dist4 &lt; dist1 and dist4 &lt; dist2 and dist4 &lt; dist3 and dist4 &lt; dist5):<br/>        cluster4.append(pointSet[i])<br/>    else:<br/>        cluster5.append(pointSet[i])<br/># j is number of iterations for kMeans<br/>j = 5<br/>while (j &gt; 0):<br/>    newCluster1 = []<br/>    newCluster2 = []<br/>    newCluster3 = []<br/>    newCluster4 = []<br/>    newCluster5 = []<br/>    for k in range(len(cluster1)):<br/>        dist1 = calculateDistance(cluster1[k], centroid1)<br/>        dist2 = calculateDistance(cluster1[k], centroid2)<br/>        dist3 = calculateDistance(cluster1[k], centroid3)<br/>        dist4 = calculateDistance(cluster1[k], centroid4)<br/>        dist5 = calculateDistance(cluster1[k], centroid5)<br/>        if (dist1 &lt; dist2 and dist1 &lt; dist3 and dist1 &lt; dist4 and dist1 &lt; dist5):<br/>            newCluster1.append(cluster1[k])<br/>        elif (dist2 &lt; dist1 and dist2 &lt; dist3 and dist2 &lt; dist4 and dist2 &lt; dist5):<br/>            newCluster2.append(cluster1[k])<br/>        elif (dist3 &lt; dist1 and dist3 &lt; dist2 and dist3 &lt; dist4 and dist3 &lt; dist5):<br/>            newCluster3.append(cluster1[k])<br/>        elif (dist4 &lt; dist1 and dist4 &lt; dist2 and dist4 &lt; dist3 and dist4 &lt; dist5):<br/>            newCluster4.append(cluster1[k])<br/>        else:<br/>            newCluster5.append(cluster1[k])<br/>    for k in range(len(cluster2)):<br/>        dist1 = calculateDistance(cluster2[k], centroid1)<br/>        dist2 = calculateDistance(cluster2[k], centroid2)<br/>        dist3 = calculateDistance(cluster2[k], centroid3)<br/>        dist4 = calculateDistance(cluster2[k], centroid4)<br/>        dist5 = calculateDistance(cluster2[k], centroid5)<br/>        if (dist1 &lt; dist2 and dist1 &lt; dist3 and dist1 &lt; dist4 and dist1 &lt; dist5):<br/>            newCluster1.append(cluster2[k])<br/>        elif (dist2 &lt; dist1 and dist2 &lt; dist3 and dist2 &lt; dist4 and dist2 &lt; dist5):<br/>            newCluster2.append(cluster2[k])<br/>        elif (dist3 &lt; dist1 and dist3 &lt; dist2 and dist3 &lt; dist4 and dist3 &lt; dist5):<br/>            newCluster3.append(cluster2[k])<br/>        elif (dist4 &lt; dist1 and dist4 &lt; dist2 and dist4 &lt; dist3 and dist4 &lt; dist5):<br/>            newCluster4.append(cluster2[k])<br/>        else:<br/>            newCluster5.append(cluster2[k])<br/>    for k in range(len(cluster3)):<br/>        dist1 = calculateDistance(cluster3[k], centroid1)<br/>        dist2 = calculateDistance(cluster3[k], centroid2)<br/>        dist3 = calculateDistance(cluster3[k], centroid3)<br/>        dist4 = calculateDistance(cluster3[k], centroid4)<br/>        dist5 = calculateDistance(cluster3[k], centroid5)<br/>        if (dist1 &lt; dist2 and dist1 &lt; dist3 and dist1 &lt; dist4 and dist1 &lt; dist5):<br/>            newCluster1.append(cluster3[k])<br/>        elif (dist2 &lt; dist1 and dist2 &lt; dist3 and dist2 &lt; dist4 and dist2 &lt; dist5):<br/>            newCluster2.append(cluster3[k])<br/>        elif (dist3 &lt; dist1 and dist3 &lt; dist2 and dist3 &lt; dist4 and dist3 &lt; dist5):<br/>            newCluster3.append(cluster3[k])<br/>        elif (dist4 &lt; dist1 and dist4 &lt; dist2 and dist4 &lt; dist3 and dist4 &lt; dist5):<br/>            newCluster4.append(cluster3[k])<br/>        else:<br/>            newCluster5.push(cluster3[k])<br/>    for k in range(len(cluster4)):<br/>        dist1 = calculateDistance(cluster4[k], centroid1)<br/>        dist2 = calculateDistance(cluster4[k], centroid2)<br/>        dist3 = calculateDistance(cluster4[k], centroid3)<br/>        dist4 = calculateDistance(cluster4[k], centroid4)<br/>        dist5 = calculateDistance(cluster4[k], centroid5)<br/>        if (dist1 &lt; dist2 and dist1 &lt; dist3 and dist1 &lt; dist4 and dist1 &lt; dist5):<br/>            newCluster1.append(cluster4[k])<br/>        elif (dist2 &lt; dist1 and dist2 &lt; dist3 and dist2 &lt; dist4 and dist2 &lt; dist5):<br/>            newCluster2.append(cluster4[k])<br/>        elif (dist3 &lt; dist1 and dist3 &lt; dist2 and dist3 &lt; dist4 and dist3 &lt; dist5):<br/>            newCluster3.append(cluster4[k])<br/>        elif (dist4 &lt; dist1 and dist4 &lt; dist2 and dist4 &lt; dist3 and dist4 &lt; dist5):<br/>            newCluster4.append(cluster4[k])<br/>        else:<br/>            newCluster5.push(cluster4[k])<br/>    for k in range(len(cluster5)):<br/>        dist1 = calculateDistance(cluster5[k], centroid1)<br/>        dist2 = calculateDistance(cluster5[k], centroid2)<br/>        dist3 = calculateDistance(cluster5[k], centroid3)<br/>        dist4 = calculateDistance(cluster5[k], centroid4)<br/>        dist5 = calculateDistance(cluster5[k], centroid5)<br/>        if (dist1 &lt; dist2 and dist1 &lt; dist3 and dist1 &lt; dist4 and dist1 &lt; dist5):<br/>            newCluster1.append(cluster5[k])<br/>        elif (dist2 &lt; dist1 and dist2 &lt; dist3 and dist2 &lt; dist4 and dist2 &lt; dist5):<br/>            newCluster2.append(cluster5[k])<br/>        elif (dist3 &lt; dist1 and dist3 &lt; dist2 and dist3 &lt; dist4 and dist3 &lt; dist5):<br/>            newCluster3.append(cluster5[k])<br/>        elif (dist4 &lt; dist1 and dist4 &lt; dist2 and dist4 &lt; dist3 and dist4 &lt; dist5):<br/>            newCluster4.append(cluster5[k])<br/>        else:<br/>            newCluster5.append(cluster5[k])<br/>    cluster1 = newCluster1<br/>    cluster2 = newCluster2<br/>    cluster3 = newCluster3<br/>    cluster4 = newCluster4<br/>    cluster5 = newCluster5<br/>    centroid1 = getMeanValue(cluster1)<br/>    centroid2 = getMeanValue(cluster2)<br/>    centroid3 = getMeanValue(cluster3)<br/>    centroid4 = getMeanValue(cluster4)<br/>    centroid5 = getMeanValue(cluster5)<br/>    j -= 1</span><span id="2737" class="ku kv iq kq b gy lm kx l ky kz">print("Cluster1")<br/>print(cluster1)<br/>print("Cluster2")<br/>print(cluster2)<br/>print("Cluster3")<br/>print(cluster3)<br/>print("Cluster4")<br/>print(cluster4)<br/>print("Cluster5")<br/>print(cluster5)<br/>print("Centroid 1")<br/>print(centroid1)<br/>print("Centroid 2")<br/>print(centroid2)<br/>print("Centroid 3")<br/>print(centroid3)<br/>print("Centroid 4")<br/>print(centroid4)<br/>print("Centroid 5")<br/>print(centroid5)</span></pre><p id="93d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你觉得这段代码有用，请查看我的开源 Github 库和我参与的其他代码项目:<a class="ae ln" href="https://github.com/CShorten" rel="noopener ugc nofollow" target="_blank">https://github.com/CShorten</a></p><p id="4bae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另外，请在媒体上关注我，获取更多类似的文章，发表在<a class="ae ln" href="https://blog.usejournal.com/" rel="noopener ugc nofollow" target="_blank">值得关注的</a>。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="85e5" class="lv kv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated"><a class="ae ln" href="https://medium.com/@connorshorten300" rel="noopener"> CShorten </a></h1><p id="5ec7" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">是佛罗里达大西洋大学的计算机科学学生。对软件经济学、深度学习和软件工程感兴趣。请关注我的频道，获取这些领域的更多文章。</p></div></div>    
</body>
</html>