<html>
<head>
<title>Quick dive into Pandas for Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为数据科学快速研究熊猫</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/quick-dive-into-pandas-for-data-science-cc1c1a80d9c4?source=collection_archive---------0-----------------------#2018-04-25">https://towardsdatascience.com/quick-dive-into-pandas-for-data-science-cc1c1a80d9c4?source=collection_archive---------0-----------------------#2018-04-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/98fe25f4dfc29b510dc724a377810b29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*kLeuGv5L3gKKETU01SbbuA.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Pandas — Data Science Fundamentals</figcaption></figure><p id="bd1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Pandas 是一个基于<a class="ae kw" rel="noopener" target="_blank" href="/lets-talk-about-numpy-for-datascience-beginners-b8088722309f"> NumPy </a>构建的开源python库。它允许您进行快速分析以及数据清理和准备。想到熊猫的一个简单方法就是简单地把它看作Python版的微软Excel。</p><p id="13ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我喜欢熊猫的一个很酷的地方是，它可以很好地处理来自各种来源的数据，例如；Excel表格、csv文件、sql文件甚至网页。</p><h2 id="b447" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">安装熊猫</h2><p id="f2be" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">如果您有<a class="ae kw" href="http://anaconda.com/" rel="noopener ugc nofollow" target="_blank"> Anaconda </a>，您可以简单地从您的终端或命令提示符安装Pandas，使用:</p><p id="abd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lv lw lx ly b">conda install pandas</code></p><p id="c0f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您的计算机上没有Anaconda，请使用以下命令从您的终端安装Pandas:</p><p id="04f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lv lw lx ly b">pip install pandas</code></p><h1 id="1ab2" class="lz ky iq bd kz ma mb mc lc md me mf lf mg mh mi li mj mk ml ll mm mn mo lo mp bi translated">熊猫数据结构</h1><h2 id="2803" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">系列</h2><p id="915c" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">Series是一维数组，与NumPy数组非常相似。事实上，Series是建立在NumPy数组对象之上的。series与NumPy数组的不同之处在于Series可以有一个访问标签，使用该标签可以对其进行索引。</p><pre class="mq mr ms mt gt mu ly mv mw aw mx bi"><span id="5e60" class="kx ky iq ly b gy my mz l na nb">import numpy as np<br/>import pandas as pd</span></pre><p id="d0ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是创建熊猫系列的基本语法:</p><pre class="mq mr ms mt gt mu ly mv mw aw mx bi"><span id="9a72" class="kx ky iq ly b gy my mz l na nb">my_series = pd.Series(data, index)</span></pre><p id="92fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从上面可以看出，<code class="fe lv lw lx ly b">data</code>可以是任何对象类型，比如字典、列表，甚至是一个NumPy数组，而<code class="fe lv lw lx ly b">index</code>表示系列将被索引的轴标签。</p><p id="5a4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将从各种对象类型中创建一个系列。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/f2457990fd656dba1b4ebb8148db93b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aZJxzS0mnRRJgAjAeRsgcg.png"/></div></div></figure><p id="7389" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注:需要注意的是，<code class="fe lv lw lx ly b">index</code> <em class="nh"> </em>轴是可选的。意思是，你可以决定不传进去。如果没有索引被传递，Pandas将创建一个默认值<code class="fe lv lw lx ly b">index</code>，其值<code class="fe lv lw lx ly b">[0, ..., len(data) - 1]</code>如下所示:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ni"><img src="../Images/8d677c9cc1c38d45660a568ec37f4e94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A4GQN_s3FM5Sxq7HHNJ_Mg.png"/></div></div></figure><p id="ae42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当从Python字典创建Series时，Pandas将键设置为Series的<code class="fe lv lw lx ly b">index</code>，并将值设置为相应的数据点，如上面的<code class="fe lv lw lx ly b">out[24]</code>所示。</p><blockquote class="nj"><p id="3fe9" class="nk nl iq bd nm nn no np nq nr ns kv dk translated">Pandas系列与NumPy数组的区别在于Pandas系列可以保存各种对象类型。</p></blockquote><p id="4d95" class="pw-post-body-paragraph jy jz iq ka b kb nt kd ke kf nu kh ki kj nv kl km kn nw kp kq kr nx kt ku kv ij bi translated"><strong class="ka ir">从系列中抓取信息</strong></p><p id="f2c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以像使用python字典一样从一个系列中获取信息:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ny"><img src="../Images/57813b8ca4b2dc46c9d59ae5d42f4625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zlZj2w1PjDj4RUt4oy-2Ig.png"/></div></div></figure><p id="a808" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">对数列进行算术运算</strong></p><p id="fc9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基于<code class="fe lv lw lx ly b">index</code>完成系列操作。当我们使用任何数学运算，如-、+、/、*，pandas使用<code class="fe lv lw lx ly b">index</code> <em class="nh">的值进行计算。</em>结果值随后被转换成浮点数，这样你就不会丢失任何信息。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nz"><img src="../Images/7610994ffa57d27d24aaf8de025279f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jZlGPFs6jjeobx20Ya8P4w.png"/></div></div></figure><p id="78f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从上面来看，熊猫在这个系列中找不到匹配的，它给了它一个<code class="fe lv lw lx ly b">NaN</code>值。</p><h2 id="776a" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">数据帧</h2><p id="b3b0" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">数据帧是二维数据结构，其中数据以表格形式排列，即以行和列排列。熊猫数据框使处理你的数据变得容易。您可以选择、替换列和行，甚至重塑您的数据。</p><p id="8285" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是创建数据帧的基本语法:</p><pre class="mq mr ms mt gt mu ly mv mw aw mx bi"><span id="1383" class="kx ky iq ly b gy my mz l na nb">pd.DataFrame(data,index)</span></pre><p id="65ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们创建一个5行4列的随机数数据帧:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oa"><img src="../Images/52445cf7c13ada6529f76a20d8a7f436.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MwPN3OkxVsV1YkGs926QGg.png"/></div></div></figure><p id="d83d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们所见，上面的每个专栏实际上只是一个熊猫系列，它们都有一个共同的<code class="fe lv lw lx ly b">index</code>。因此，可以肯定地说，数据帧是共享相同<code class="fe lv lw lx ly b">index</code>的系列的集合。在下面的示例中，我们将从一个系列中创建一个数据帧:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ob"><img src="../Images/13f15f5ac96580ab03f9d63459a5552c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pu8yTmZShrDaVAoUG9qykg.png"/></div></div></figure><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oc"><img src="../Images/276d10150ac8ab7fab998518e6b9f507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vzmPwGDPh5ZeTJdqvWKZ9g.png"/></div></div></figure><p id="496e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">从数据帧中选择列</strong></p><p id="633b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用括号符号<code class="fe lv lw lx ly b">[]</code>，我们可以很容易地从数据帧中抓取对象，就像处理Series一样。先来抢个专栏<code class="fe lv lw lx ly b">name</code>:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi od"><img src="../Images/ac5e74067365aefb9979fdf296e44eb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4h34sxiZMsxH8fhfG9bc3g.png"/></div></div></figure><p id="9798" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们获取了单个列，所以它返回一个系列。继续使用<code class="fe lv lw lx ly b">type()</code>确认返回的数据类型:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oa"><img src="../Images/7c68e5071f7e63122509aff5a70e7605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iub0Xj_kjPperH0XtpNfmQ.png"/></div></div></figure><p id="883c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们获取多个列，结果将是一个数据帧:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oe"><img src="../Images/4dbf86575550b51815a3f78ebd86901b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ee1Q0iNWqaE79jOx4OqXUA.png"/></div></div></figure><p id="e7bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">向数据框架添加列</strong></p><p id="d6bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当创建一个新列时，您必须像它已经存在一样定义它。有数据框架的:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi of"><img src="../Images/988e39ad14fcaba882a09846e85e85a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TeTAwIZujFs6Cn9aFA6XLA.png"/></div></div></figure><p id="f84f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以通过重新创建新列或从现有列添加新列，如下所示:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oc"><img src="../Images/994d8193fcfb41e12f38e2810b069410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5fRWLZ720zjzotY3EK5teA.png"/></div></div></figure><p id="1a82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">从数据帧中删除行/列</strong></p><p id="a628" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用<code class="fe lv lw lx ly b">.drop()</code>功能删除一行或一列。为此，我们必须为<em class="nh">行</em>指定<code class="fe lv lw lx ly b">axis=0</code> <em class="nh"> </em>，为<em class="nh">列</em>指定<code class="fe lv lw lx ly b">axis=1</code> <em class="nh"> </em>。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi og"><img src="../Images/17cdd55612fb242eefa1c443f77678e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X8CqcnGzTX_6BqTadZ48ag.png"/></div></div></figure><p id="18d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">值得注意的是，无论何时使用<code class="fe lv lw lx ly b">.drop() </code>方法，Pandas都不会永久删除一行/一列，除非您告诉它这样做。这是因为熊猫不希望你意外丢失数据。</p><p id="b4e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打电话<code class="fe lv lw lx ly b">df</code>确认。要永久删除一行/一列，您必须像这样设置<code class="fe lv lw lx ly b">inplace=True</code>:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi og"><img src="../Images/146b93621f5b881b28ba14402dcb55ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VsmqGA9LmqHk96u9t3K-Ow.png"/></div></div></figure><p id="22e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">选择数据帧中的行</strong></p><p id="febc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要选择行，我们必须使用接受标签名的<code class="fe lv lw lx ly b">.loc[]</code>或接受行的索引位置的<code class="fe lv lw lx ly b">.iloc[]</code>来调用行的位置。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oh"><img src="../Images/cb6aa686433d8cb936e5903e29947887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BB4ds99XEzh7OwXyZPYSsw.png"/></div></div></figure><p id="09b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也可以像在<a class="ae kw" rel="noopener" target="_blank" href="/lets-talk-about-numpy-for-datascience-beginners-b8088722309f"> NumPy </a>中那样，通过指定我们想要的行和列，使用列符号<code class="fe lv lw lx ly b">:</code>来选择行和列的子集。假设我们想要第<code class="fe lv lw lx ly b">'c'</code>行的<code class="fe lv lw lx ly b">'Name’</code>:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oi"><img src="../Images/6dc9b0fa1ccea3a3a7785fe72aa356cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T1B_sq8I0B6fCr7xZig-Ew.png"/></div></div></figure><p id="87ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">条件选择</strong></p><p id="b2d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Pandas允许您使用括号符号<code class="fe lv lw lx ly b">[]</code>进行条件选择。下面的示例返回其中<code class="fe lv lw lx ly b">'W'&gt;0</code> <em class="nh"> : </em>的行</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oh"><img src="../Images/8ca5a4c794505d7539fcf9dc07a13811.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1G1r8y7zh7EUXT1IQAKqxQ.png"/></div></div></figure><p id="475d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们只想返回列<code class="fe lv lw lx ly b">'X'</code>的值，其中<code class="fe lv lw lx ly b">'W'&gt;0</code> <em class="nh"> : </em></p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ni"><img src="../Images/b8f72b6e4dcdd485ca6bc75db086afc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c0hmiZ6PrbO7kq9JruGmcw.png"/></div></div></figure><p id="e97a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">继续尝试这个:<code class="fe lv lw lx ly b">df[df['W']&gt;0][['X','Y']] </code>，你应该得到这个:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/d27db3b56d4a62a94450a92eb883866a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*amwS0EmAGovnzpyXhWJoDQ.png"/></div></div></figure><p id="71fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上述一行抽象也可以通过将其分解为多个步骤来实现:</p><pre class="mq mr ms mt gt mu ly mv mw aw mx bi"><span id="6aec" class="kx ky iq ly b gy my mz l na nb">my_series = df['W']&gt;0<br/>result = df[my_series]<br/>my_cols = ['X','Y']<br/>result[<!-- -->my_cols]</span></pre><p id="2724" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用多个条件，我们可以通过使用逻辑操作符&amp; (AND)和| (OR)来获得数据帧中的值。例如，要返回值，其中<code class="fe lv lw lx ly b">'W'&gt;0</code> <em class="nh"> </em>和<code class="fe lv lw lx ly b">'X'&gt;1</code> <em class="nh">，</em>使用:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oc"><img src="../Images/c33f8a151f305cc75607cc2726cad697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OcIJPSAVlQ2aEAiA3TDhwQ.png"/></div></div></figure><p id="3b93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">重置数据帧的索引</strong></p><p id="e4bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当你的索引看起来不完全是你想要的样子时，你可以使用<code class="fe lv lw lx ly b">.reset_index()</code>很容易地重置它。这将我们的DataFrame索引重置为名为<code class="fe lv lw lx ly b">index</code> <em class="nh"> </em>的列，Pandas的默认索引值<code class="fe lv lw lx ly b">[0, ..., len(data) - 1]</code>是我们的新索引。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ni"><img src="../Images/6e84af5a8f99f90e37c6903b2973dcc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F08UWkb4l5LWSnEE7LXvTw.png"/></div></div></figure><p id="2667" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不出所料，<code class="fe lv lw lx ly b">.reset_index()</code>不会永久重置索引，直到您指定:<code class="fe lv lw lx ly b">.reset_index(inplace=True)</code></p><p id="d536" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">设置数据帧的索引</strong></p><p id="f6fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">类似地，我们可以通过使用<code class="fe lv lw lx ly b">set_index()</code>函数来指定想要使用哪一列作为我们的索引标签。为此，我们将创建一个名为<code class="fe lv lw lx ly b">"ID'</code>的新列，并将其设置为我们的新索引:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oj"><img src="../Images/d9cc09a8032e7ab5e704394049d85f48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7_vR_Gh3zSbaTXZ-m6fa4A.png"/></div></div></figure><blockquote class="ok ol om"><p id="ec19" class="jy jz nh ka b kb kc kd ke kf kg kh ki on kk kl km oo ko kp kq op ks kt ku kv ij bi translated">不像<code class="fe lv lw lx ly b"><em class="iq">.reset_index()</em></code>重置旧的索引并使用默认的熊猫索引作为我们的新索引，<code class="fe lv lw lx ly b"><em class="iq">.set_index()</em></code>完全覆盖旧的索引。</p></blockquote><p id="8dd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">多级指标(</strong> MultiIndex) <strong class="ka ir">和指标层次</strong></p><p id="23b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">多索引只是一个元组数组，其中每个元组都是唯一的。它可以从一个数组列表(使用<code class="fe lv lw lx ly b">MultiIndex.from_arrays</code>)、一个元组数组(使用<code class="fe lv lw lx ly b">MultiIndex.from_tuples</code>)或一组交叉的可重复项(使用<code class="fe lv lw lx ly b">MultiIndex.from_product</code>)中创建。</p><p id="3169" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从一个turple创建一个MultiIndex:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oq"><img src="../Images/b940583f6d575a0ea744bad6f4d6a84b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8_enhj3Htk5sMJXxqPBfSA.png"/></div></div></figure><p id="4f0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以继续使用<code class="fe lv lw lx ly b">.loc[]</code>从MultiIndex中获取行，如下所示:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ny"><img src="../Images/609171a533cbc4647c84e6cd3e837952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q5pjp4iL1i9C8S1vAmGRcA.png"/></div></div></figure><p id="c4d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们所看到的，我们的数据框架<code class="fe lv lw lx ly b">df</code>的前两列没有名字。我们可以像这样用<code class="fe lv lw lx ly b">.index.names</code>给它们命名:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/bc903dd58dbebc79913c2e16f8d7f5d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tx0Ngl8oG3IAF0-LguHBIQ.png"/></div></div></figure><p id="03b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">横切面的行列</strong></p><p id="9a4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe lv lw lx ly b">.xs</code>方法，我们可以很容易地选择多索引中特定级别的数据。例如，假设我们想要获取所有级别，其中<code class="fe lv lw lx ly b">Num = 22</code>:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oc"><img src="../Images/4165cdd3c7ae52cd6a7b9c28c8a04de0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6BEcDsM9EzJ3E0SxAzVnrQ.png"/></div></div></figure><h2 id="a009" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">缺失数据</h2><p id="2453" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">很多时候，当你使用Pandas读入数据并且有缺失点时，Pandas会自动用一个<code class="fe lv lw lx ly b">NaN or Null</code>值来填充这些缺失点。因此，我们可以使用<code class="fe lv lw lx ly b">.dropna()</code>删除那些自动填充的值，或者使用<code class="fe lv lw lx ly b">.fillna().</code>填充它们</p><p id="6843" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们有一个数据框架:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi og"><img src="../Images/0f0281ce4873ea3a890effbaf859f367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z3wTyF9vNus4dLtU3mytWw.png"/></div></div></figure><p id="08de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe lv lw lx ly b">.dropna()</code>方法，我们告诉Pandas删除任何有一个或多个缺失值的行或列。要删除一行，使用<code class="fe lv lw lx ly b">.dropna(axis=0)</code>和<code class="fe lv lw lx ly b">.dropna(axis=1)</code>删除一列。</p><blockquote class="ok ol om"><p id="6ce6" class="jy jz nh ka b kb kc kd ke kf kg kh ki on kk kl km oo ko kp kq op ks kt ku kv ij bi translated">注意，如果您没有指定轴，Pandas默认假设您正在删除一行。</p></blockquote><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi or"><img src="../Images/902b97a99446412a91b108e18fd67beb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o2etBSJWG-U8vax9wnFESg.png"/></div></div></figure><p id="2ae2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，使用<code class="fe lv lw lx ly b">.fillna()</code>方法，我们可以用我们想要的值替换数据帧中缺失的值。让我们用<code class="fe lv lw lx ly b">10</code>替换所有的<code class="fe lv lw lx ly b">NaN</code>值:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oa"><img src="../Images/117c7e82ec9ce38eb6206dba3094ceb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*afWsuMeeiyh3G64NhhIssA.png"/></div></div></figure><p id="8f06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也可以选择只填充特定列或行中缺少的值。让我们用平均值替换列<code class="fe lv lw lx ly b">'A'</code>中缺失的值:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi os"><img src="../Images/592fe90da7c1ff85c63fb7da19db7221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QXPs9T5_12vkY29bRyMhKg.png"/></div></div></figure><p id="4f2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从上面可以看出，列<code class="fe lv lw lx ly b">'A'</code>的平均值是2.0，因此它用2.0替换了第二行。</p><p id="04c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，<code class="fe lv lw lx ly b">.dropna()</code>和<code class="fe lv lw lx ly b">.fillna()</code>不会永久出现，直到您设置了<code class="fe lv lw lx ly b">inplace=True</code></p><p id="d303" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">分组依据</strong></p><p id="15e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Grouby允许您根据列对行进行分组，以便您可以对它们执行聚合函数(如求和、均值、中值、标准差等)。</p><p id="d54c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe lv lw lx ly b">.groupby()</code>方法，我们可以根据<code class="fe lv lw lx ly b">'Company' </code>列对行进行分组，并对其调用聚合函数<code class="fe lv lw lx ly b">.mean()</code>:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ot"><img src="../Images/06c493353e56aadb928ed62e7d0cd41c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GJ3JnoR621FjDGFF5hZH4g.png"/></div></div></figure><p id="41d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，我们的结果是每个公司的平均值。</p><p id="dcec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">计数</strong></p><p id="65e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe lv lw lx ly b">count() </code>方法，我们可以获得一个项目在数据帧中出现的次数。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ou"><img src="../Images/76ec009d17d67631ec67fa2bb3873480.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QV0uEpR-eIYIxUE9F_6RpA.png"/></div></div></figure><p id="43c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">形容</strong></p><p id="092b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lv lw lx ly b">.describe()</code>方法用于获得数据帧的概貌。它为我们提供了每个数据帧索引的摘要。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ov"><img src="../Images/6d064d83241896e36c1321cdba388e5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2j7CFFeTCy7L3Imj2gpkkw.png"/></div></div></figure><p id="d4a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你不喜欢这个布局，你可以使用<code class="fe lv lw lx ly b">.transpose()</code>方法得到一个不同的布局。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ow"><img src="../Images/01e15a8e19c9bf4a51e623048eb08e8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EgnKu0W_CQQYolTM5TxQNw.png"/></div></div></figure><p id="7d99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">连接、合并和连接数据帧</strong></p><p id="0346" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">串联</strong></p><p id="d88a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">串联基本上将数据帧粘合在一起。当连接数据帧时，请记住，维度应该沿着要连接的轴匹配。拥有，数据帧列表:</p><pre class="mq mr ms mt gt mu ly mv mw aw mx bi"><span id="1741" class="kx ky iq ly b gy my mz l na nb">df1 = pd.DataFrame({'A': ['A0', 'A1', 'A2', 'A3'],<br/>                        'B': ['B0', 'B1', 'B2', 'B3'],<br/>                        'C': ['C0', 'C1', 'C2', 'C3'],<br/>                        'D': ['D0', 'D1', 'D2', 'D3']},<br/>                        index=[0, 1, 2, 3])</span><span id="4974" class="kx ky iq ly b gy ox mz l na nb">df2 = pd.DataFrame({'A': ['A4', 'A5', 'A6', 'A7'],<br/>                        'B': ['B4', 'B5', 'B6', 'B7'],<br/>                        'C': ['C4', 'C5', 'C6', 'C7'],<br/>                        'D': ['D4', 'D5', 'D6', 'D7']},<br/>                         index=[4, 5, 6, 7]) </span><span id="8177" class="kx ky iq ly b gy ox mz l na nb">df3 = pd.DataFrame({'A': ['A8', 'A9', 'A10', 'A11'],<br/>                        'B': ['B8', 'B9', 'B10', 'B11'],<br/>                        'C': ['C8', 'C9', 'C10', 'C11'],<br/>                        'D': ['D8', 'D9', 'D10', 'D11']},<br/>                        index=[8, 9, 10, 11])</span></pre><p id="0aa4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用<code class="fe lv lw lx ly b">pd.concat()</code>方法连接它们:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oy"><img src="../Images/e19d86873c6afa7b8295485f1b0d05f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vhKmlGT7FDrXVvE2twTVXA.png"/></div></div></figure><p id="14ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们没有指定希望在哪个轴上发生串联，所以默认情况下，Pandas使用行轴。它把两行连接在一起。如果我们希望沿着列进行连接，我们必须设置<code class="fe lv lw lx ly b">axis=1</code>:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oc"><img src="../Images/299da0fe39104d309f834019406fa241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fg5zTpjNaePlmuCRe5bsCg.png"/></div></div></figure><p id="393d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意这里我们有一堆缺失的值。这是因为DataFrame没有包含我们希望它连接的所有索引的值。因此，当使用<code class="fe lv lw lx ly b">pd.concat()</code>时，确保您的数据正确包含轴上的所有信息。</p><p id="6a77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">合并</strong></p><p id="0fbb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe lv lw lx ly b">pd.merge()</code>函数，Pandas允许您像合并SQL表一样合并数据帧。合并数据帧的语法是<code class="fe lv lw lx ly b">pd.merge(left, right, how='inner', on='Key'</code>。<code class="fe lv lw lx ly b">left</code>表示应该出现在左侧的数据帧，<code class="fe lv lw lx ly b">right</code>表示应该出现在右侧的数据帧，<code class="fe lv lw lx ly b">how='inner'</code>表示合并操作应该作为交集<code class="fe lv lw lx ly b">inner</code>还是并集<code class="fe lv lw lx ly b">Outer</code>来处理。最后，<code class="fe lv lw lx ly b">on='Key'</code>表示发生合并的键列。在合并功能发生之前，该键列在所有数据帧中必须是相似的。</p><p id="60a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有两个数据帧都有一个<code class="fe lv lw lx ly b">key</code>列，我们可以这样合并它们:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oz"><img src="../Images/01874326fbdc227cb1300a1756b7013a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9oIKH0SL7OoUSjJ7iNFrYQ.png"/></div></div></figure><p id="1f1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还可以通过简单地传递键来合并多个键:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oj"><img src="../Images/f94085b8bc3b729ee2f3fb95722698c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-cjgPxA7FWQHQGFhp8NqGw.png"/></div></div></figure><p id="1a34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">加入</strong></p><p id="5f17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于将两个可能索引不同的数据帧的列组合成单个数据帧，联接是一种更方便的方法。联接类似于合并，但不同之处在于联接方法发生在索引键而不是列上。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi pa"><img src="../Images/5080678a771611c65ac5b8fcb177698c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JBpL4TxLolP_1HRNPM8LRg.png"/></div></div></figure><h2 id="b52c" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">在数据帧中查找唯一值</h2><p id="e064" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">唯一值就是数据帧中的不同值。在数据帧中查找唯一值有三种主要的有用方法。</p><p id="22be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe lv lw lx ly b">.unique()</code>，我们可以找到以下数据帧的<code class="fe lv lw lx ly b">col2</code>中的所有唯一值:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi pb"><img src="../Images/d50753087c559028970b0b22d3014390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Swm4HrKYOiNDKMq7SCWqw.png"/></div></div></figure><p id="1c97" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以选择使用<code class="fe lv lw lx ly b">.nunique()</code>来计算数据帧中唯一值的数量，而不是显示唯一值:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oj"><img src="../Images/cbbb8022c9a1c1aa9ff792c251054c2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OQfYJkyHtaLLoICbgfDWDA.png"/></div></div></figure><p id="5890" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们可以决定使用<code class="fe lv lw lx ly b">.value_counts()</code>只返回一个惟一值在一列中出现的次数:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ny"><img src="../Images/9b77083baef0b4704fb2d83fe17e1194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZVCr1hvVMMGMHdA5Eis2xg.png"/></div></div></figure><p id="be76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">apply()方法</strong></p><p id="0f3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lv lw lx ly b">.apply()</code>方法用于调用数据帧上的自定义函数。想象我们有一个函数:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ow"><img src="../Images/566f14136908be73bdad507ec4be8217.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vIKcj2ZmnFGiwrafKGhZhA.png"/></div></div></figure><p id="e425" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们将函数传播给列中的每个元素。我们还可以将内置函数应用于数据帧。假设我们想要得到<code class="fe lv lw lx ly b">col3</code>中字符串的长度:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oe"><img src="../Images/a74a77ebf8632a4434166eee67c2da22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hqb4z69M-hx3EQiMQmEW4A.png"/></div></div></figure><p id="9bc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有时，您可能会定义一个最终只使用一次的函数。不用在几行代码中定义这样的函数，您可以简单地使用lambda表达式，这是该函数的简化版本。例如，我们可以用lambda表达式来表示上面<code class="fe lv lw lx ly b">ln[47]</code>中的平方函数:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/8040ec965f3dcca395f9fbfda4c65c0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fff4yd-sXMBkqT8Tb4YRTQ.png"/></div></div></figure><p id="f5c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">获取数据帧属性</strong></p><p id="135b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">属性是数据帧的列名和索引名。假设我们不确定数据帧中的列名是否包含空格字符，我们可以简单地获得它们的属性:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nz"><img src="../Images/22c73e0f6e8b8f1050c8d693babad469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f97I3UyWBh1NOQypyxEjWw.png"/></div></div></figure><p id="2ee1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">对数据帧进行排序和排序</strong></p><p id="9e48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们想要显示数据帧，其中某一列以升序显示，我们可以使用<code class="fe lv lw lx ly b">.sort_values():</code>很容易地对其进行排序</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oa"><img src="../Images/9c19626bef82d00c7e59e1f91a58ba92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UAJAb8AVNKy5aw5ZvNZlsA.png"/></div></div></figure><p id="757e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，<code class="fe lv lw lx ly b">col2</code>中的值是从最低到最高显示的。还要注意<code class="fe lv lw lx ly b">index</code>是如何连接到每一行的，这样信息就不会丢失。</p><p id="b3f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">查找空值</strong></p><p id="e8cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设您有一个大型数据集，Pandas使用<code class="fe lv lw lx ly b">.isnull():</code>使得定位空值变得非常容易</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi od"><img src="../Images/75dd143875bf8efefed2701dd4beb696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5tWoovdMuw9v2JXKlVsnPg.png"/></div></div></figure><p id="acd9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">透视表</strong></p><p id="35db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能已经熟悉Excel中的数据透视表。数据透视表是汇总另一个表中数据的表。它使您能够自动对存储在一个表中的数据进行分组、切片、筛选、排序、计数、合计或平均。有数据框架的:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi or"><img src="../Images/954c5035e6be7a4e5ec945e682a1a02b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ltv5egenU4W4323jTNVzBA.png"/></div></div></figure><p id="779c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用语法从它创建一个数据透视表:<code class="fe lv lw lx ly b">.pivot_table(data, values='', index=[''], columns=['']).</code>其中<code class="fe lv lw lx ly b">values</code>表示我们想要组成数据点的列，<code class="fe lv lw lx ly b">index</code>是您想要对数据进行分组的列，<code class="fe lv lw lx ly b">columns</code>表示应该定义数据帧的列。你可以在这里阅读更多关于数据透视表<a class="ae kw" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.pivot_table.html" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi pa"><img src="../Images/7a9ca36b4c81b6b3841d34636158c212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nnF1ETFgu7booDVjjLG0_g.png"/></div></div></figure><p id="57ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们得到了一些<code class="fe lv lw lx ly b">NaN</code>值，因为对于那些特定的点没有匹配的值。</p><h2 id="9582" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">数据输入和输出</h2><p id="c428" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">使用<code class="fe lv lw lx ly b">pd.read_</code>方法，Pandas允许您从各种来源访问数据，例如:excel表、csv、sql或html。</p><p id="d49f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要引用任何文件，你必须确保它与你的jupyter笔记本在同一个目录下。</p><p id="7b74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">读取CSV文件</strong></p><p id="b777" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe lv lw lx ly b">pd.read_csv()</code>我们可以将. csv文件的内容输出为数据帧，如下所示:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi pc"><img src="../Images/d02b58768909db49841e5e37eaba9b70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nBW5XziQFlFlP-gm6_u-oA.png"/></div></div></figure><p id="d097" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">写入CSV文件</strong></p><p id="ea6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以创建一个数据帧，并使用<code class="fe lv lw lx ly b">.to_csv()</code>将其存储在一个<code class="fe lv lw lx ly b">.csv</code>文件中，如下所示:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi os"><img src="../Images/b5c5d5b770a361df24794100f1270cd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1lGK3-Bm2LGcSB5nNnStsg.png"/></div></div></figure><p id="214d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要确认数据已保存，请继续阅读您刚刚使用<code class="fe lv lw lx ly b">pd.read_csv('New_dataframe')</code>创建的csv文件。</p><p id="ece9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">从Excel文件中读取</strong></p><p id="a64f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Excel文件是很好的数据来源。使用<code class="fe lv lw lx ly b">pd.read_excel()</code>我们可以从excel文件导入数据。请记住，Pandas只能导入excel文件中的数据，而不能导入宏、图像或公式。excel文件中有宏、图像或公式会导致<code class="fe lv lw lx ly b">pd.read_excel() </code>方法崩溃。</p><p id="1ad8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们有一个excel文件<code class="fe lv lw lx ly b">'excel_output.xlsx'</code>，让我们继续输出它的内容:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ou"><img src="../Images/81061de0ffc51193a993f7686fce808a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yEtUUjSEvD5PENr9BCsSVg.png"/></div></div></figure><p id="4dc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请记住，每个excel文件都包含一个或多个工作表。在我们的例子中，<code class="fe lv lw lx ly b">Sheet1</code>指的是我们想要读取的<code class="fe lv lw lx ly b">'excel_output.xlsx'</code>中的特定工作表。</p><p id="2577" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">写入Excel文件</strong></p><p id="5051" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就像我们对csv所做的那样，我们可以创建一个数据帧，并使用<code class="fe lv lw lx ly b">.to_excel()</code>将其存储在一个<code class="fe lv lw lx ly b">.xlsx</code>文件中，如下所示:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi pc"><img src="../Images/51801288c04d44375b6be9f9af275e62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7qm78oM8MQrk_f_IBiXlRQ.png"/></div></div></figure><p id="dc99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">从HTML中读取</strong></p><p id="0ec6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要从HTML文件中读取数据，需要安装htmllib5、lxml和BeautifulSoup4。在您的终端运行中:</p><pre class="mq mr ms mt gt mu ly mv mw aw mx bi"><span id="3f4c" class="kx ky iq ly b gy my mz l na nb">conda install lxml<br/>conda install html5lib<br/>conda install BeautifulSoup4</span></pre><p id="c3fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe lv lw lx ly b">.read_html()</code>让我们告诉熊猫从这个<a class="ae kw" href="https://en.wikipedia.org/wiki/List_of_banks_in_the_United_Kingdom" rel="noopener ugc nofollow" target="_blank"> html页面</a>读取表格。由于该页面中有不同的表，我们可以使用索引号<code class="fe lv lw lx ly b">[0, ..., len(tables) - 1]</code>来访问我们想要的特定表。对于本例，我们将返回该页面中的第二个表。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ov"><img src="../Images/656c50fdc1a67a02c65f9e49a97980c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i2aRf6Cc0KbouyDyt57SVg.png"/></div></div></figure><p id="9bdc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本教程到此结束，恭喜！</p><p id="8361" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您完成了本课，您应该对什么是Pandas以及如何使用它进行数据准备有很好的了解。你现在需要做的就是练习！练习！练习！。</p><p id="df1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有问题，遇到困难或者只是想打个招呼？请使用评论框。如果这个教程在某些方面对你有帮助，给我看一些👏。</p></div></div>    
</body>
</html>