<html>
<head>
<title>Web Scraping Apartment Listings in Stockholm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">斯德哥尔摩的网络搜集公寓列表</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/web-scraping-apartment-listings-in-stockholm-3fcebacf8be6?source=collection_archive---------9-----------------------#2018-12-25">https://towardsdatascience.com/web-scraping-apartment-listings-in-stockholm-3fcebacf8be6?source=collection_archive---------9-----------------------#2018-12-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9d6a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用 Python 进行抓取，使用 MS SQL server 进行存储</h2></div><p id="f2b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我和我的合伙人已经卖掉了我们的公寓，正在寻找一个新的。因为大多数人在寻找新公寓时，都要手动穿过 https://www.hemnet.se/，这对我来说似乎既乏味又累人。所以我想——为什么不利用我的 Python 知识，通过编程找到最合适的公寓呢？这就是我所做的，我做了一个非常简单的网页抓取器来找到待售的物品。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/26ab7e96c9bf4d2b190bcbb4bc360717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GEPzPLKLmJr1BKKd"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Photo by <a class="ae lb" href="https://unsplash.com/@gavlak?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Adam Gavlák</a> on <a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="3230" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">目录</h2><ul class=""><li id="9a00" class="ml mm iq kh b ki mn kl mo ko mp ks mq kw mr la ms mt mu mv bi translated"><a class="ae lb" href="https://medium.com/p/3fcebacf8be6#935a" rel="noopener">网页抓取部分</a></li><li id="4aaf" class="ml mm iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated"><a class="ae lb" href="https://medium.com/p/3fcebacf8be6#7798" rel="noopener">刮削功能</a></li><li id="fa9c" class="ml mm iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated"><a class="ae lb" href="https://medium.com/p/3fcebacf8be6#f7a6" rel="noopener">数据库存储部</a></li><li id="02a8" class="ml mm iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated"><a class="ae lb" href="https://medium.com/p/3fcebacf8be6#beba" rel="noopener">可视化销售对象的数据</a></li><li id="b622" class="ml mm iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated"><a class="ae lb" href="https://medium.com/p/3fcebacf8be6#9709" rel="noopener">备注</a></li><li id="17ca" class="ml mm iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated"><a class="ae lb" href="https://medium.com/p/3fcebacf8be6#8932" rel="noopener">进一步工作</a></li></ul><h1 id="935a" class="nb lt iq bd lu nc nd ne lx nf ng nh ma jw ni jx md jz nj ka mg kc nk kd mj nl bi translated">1.刮网部分</h1><p id="02fe" class="pw-post-body-paragraph kf kg iq kh b ki mn jr kk kl mo ju kn ko nm kq kr ks nn ku kv kw no ky kz la ij bi translated">下面是一对通过库 BeautifulSoup 处理 HTML 对象的函数。请记住，这些功能可以用更专业和最佳的方式编写，但这个项目的范围确实是快速获得数据，以便完成一个“最佳”公寓交易。</p><h1 id="7798" class="nb lt iq bd lu nc nd ne lx nf ng nh ma jw ni jx md jz nj ka mg kc nk kd mj nl bi translated">1.1 刮削功能</h1><p id="c420" class="pw-post-body-paragraph kf kg iq kh b ki mn jr kk kl mo ju kn ko nm kq kr ks nn ku kv kw no ky kz la ij bi translated">首先，我们需要处理 BeautifulSoup 对象，我们在一个标准的 Python 函数中处理这个对象，我选择将这个函数命名为“Booli_ScrapeObjects”。该函数有两个输入参数(page 和 object_info ),其中<strong class="kh ir"> page </strong>是 URL,<strong class="kh ir">object _ info</strong>是一个 Pandas 数据帧，用于存储每个对象的所有有趣信息。该函数的工作前提是网站的 HTML 对象保持静态。该函数如下:</p><pre class="ld le lf lg gt np nq nr ns aw nt bi"><span id="3abb" class="ls lt iq nq b gy nu nv l nw nx"><strong class="nq ir">def</strong> <em class="ny">Booli_ScrapeObjects</em>(page, object_info):<br/> request = requests.get(page)<br/> soup = BeautifulSoup(request.text,'lxml')<br/> links = soup.select("a[href*=/annons/]")<br/> <br/> <strong class="nq ir">for</strong> <em class="ny">j, row</em> in enumerate(links):<br/>  info = row.contents[5].text.split("\n")<br/>  <strong class="nq ir">while</strong> '' in info:<br/>   info.remove('')<br/>  info[0] = info[0].strip(" kr")<br/>  info[1] = info[1].strip(" kr/m²")<br/>  info[2] = info[2].strip(" kr/mån")<br/>  object_info.append(info)<br/>  <strong class="nq ir">try:</strong><br/>   info.insert(0,"https://www.booli.se" + links[j]["href"])<br/>  #FETCHING ADDRESS, # ROOMS AND M2<br/>  request_apartment = requests.get(info[0])<br/>  soup_apartment = BeautifulSoup(request_apartment.text, 'lxml')<br/>  address = soup_apartment.findAll('span',<br/>   class_ = 'property__header__street-address')<br/>  address = address[0].contents[0].strip("\n\t\t")<br/>  info.append(address)<br/>  size = soup_apartment.findAll('span',<br/>   class_ = 'property__base-info__title__size')<br/>  size = size[0].contents[0].strip("\n\t").split(",")<br/>  rooms = size[0].strip(" rum")<br/>  m2 = size[1].strip(" m²")<br/>  info.append(rooms)<br/>  info.append(m2)<br/>  <strong class="nq ir">except:</strong><br/>   info.insert(0, "Unknown")   #Link<br/>   info.append("Unknown")      #Address<br/>   info.append("Unknown")      #Rooms<br/>   info.append("Unknown")      #m2<br/>   info.append("Unknown")      #Estimate<br/>   continue<br/><strong class="nq ir">return</strong> object_info</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nz"><img src="../Images/e6ee9817674d05c7b6989b608943d97d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kIvtHwm0dyBmWlUIpZTkEQ.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Print Screen from Boolis webpage - showing number of objects per page.</figcaption></figure><p id="e631" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的函数抓取可以在给定页面上找到的对象。如果找到的对象数量大于 38 个，对象将被分割成多个页面(见左图)。这个问题在下面的函数中解决了，它采用相同的 URL 参数来计算我们有多少个页面，前提是每个页面最多包含 38 个对象。</p><pre class="ld le lf lg gt np nq nr ns aw nt bi"><span id="c849" class="ls lt iq nq b gy nu nv l nw nx"><strong class="nq ir">def</strong> <em class="ny">Booli_findNumberOfPagesData</em>(url):<br/> request = requests.get(url)<br/> soup = BeautifulSoup(request.text,'lxml')<br/> data = soup.findAll('div',<br/>		class_ = 'search-list__pagination-summary')<br/> numberOfObjectsPerPage = 38<br/> try:<br/>  numberOfObjects = int(data[0].text[<br/>		-(len(data[0].text)-3 - data[0].text.rfind("av")):])</span><span id="600e" class="ls lt iq nq b gy oa nv l nw nx">except:<br/>  numberOfObjects = 0<br/>  numberOfPages = int(<br/>		np.ceil(numberOfObjects/numberOfObjectsPerPage))</span><span id="ef74" class="ls lt iq nq b gy oa nv l nw nx"><strong class="nq ir">return</strong> numberOfPages, numberOfObjects</span></pre><p id="0eee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了上面的两个函数，我们可以编写一个新的函数，循环遍历每个 URL，并将信息存储在 Pandas 数据帧中。该函数如下:</p><pre class="ld le lf lg gt np nq nr ns aw nt bi"><span id="0647" class="ls lt iq nq b gy nu nv l nw nx"><strong class="nq ir">def</strong> <em class="ny">loopThroughRegions</em>(data_url, <br/>			m2_max, <br/>			m2_min, <br/>			maxListPrice, <br/>			minListPrice):<br/> object_info = []<br/> region = []<br/> length = [0]<br/> <strong class="nq ir">for</strong> <em class="ny">index, row</em> in data_url.iterrows():<br/>  #Base URL<br/>  url = "https://www.booli.se/{}/{}/?<br/>			maxListPrice={}&amp;<br/>			maxLivingArea={}&amp;<br/>			minListPrice={}&amp;<br/>			minLivingArea={}&amp;<br/>			objectType=L%C3%A4genhet&amp;<br/>			page=1&amp;<br/>			upcomingSale=<br/>				".format(row["Region"],<br/>					row["RegionID"],<br/>					maxListPrice, <br/>					m2_max, <br/>					minListPrice, <br/>					m2_min)<br/>  object_info = <strong class="nq ir">Booli_ScrapeObjects</strong>(<em class="ny">url, object_info</em>)<br/>  numberOfPages, numberOfObjects = <strong class="nq ir">Booli_findNumberOfPagesData</strong>(<em class="ny">url)<br/>  </em><strong class="nq ir">for</strong> <em class="ny">page</em> in range(2, numberOfPages):<br/>   url = "https://www.booli.se/{}/{}/?<br/>		maxListPrice={}&amp;<br/>		maxLivingArea={}&amp;<br/>		minListPrice={}&amp;<br/>		minLivingArea={}&amp;<br/>		objectType=L%C3%A4genhet&amp;<br/>		page={}&amp;<br/>		upcomingSale=<br/>			".format(row["Region"],<br/>				row["RegionID"],<br/>				maxListPrice,<br/>				m2_max,<br/>				minListPrice,<br/>				m2_min,<br/>				page)<br/>  object_info = <strong class="nq ir">Booli_ScrapeObjects</strong>(<em class="ny">url, object_info</em>)<br/> length.append(len(object_info))</span><span id="04e7" class="ls lt iq nq b gy oa nv l nw nx">#Creating a simple vector containing duplicates of regions up to number of object stored for each region<br/> <strong class="nq ir">for</strong> <em class="ny">i</em> in range(0, length[len(length)-1] - length[len(length) - 2]):<br/>  region.append(row["Region"])</span><span id="c96a" class="ls lt iq nq b gy oa nv l nw nx"><strong class="nq ir">return</strong> object_info, region</span></pre><p id="f808" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了在常规的 Microsoft SQL Server 数据库中存储 Pandas 数据框，我们需要清理数据。例如，我们想要两个重写对象，从 1 个房间到 1.5 个房间，依此类推。执行这一简单清洁过程的简单函数如下:</p><pre class="ld le lf lg gt np nq nr ns aw nt bi"><span id="f1a6" class="ls lt iq nq b gy nu nv l nw nx"><strong class="nq ir">def</strong> <em class="ny">cleaningData</em>(object_info):<br/> <strong class="nq ir">for</strong> <em class="ny">index, row</em> in object_info.iterrows():</span><span id="2215" class="ls lt iq nq b gy oa nv l nw nx"><strong class="nq ir">if</strong> row["m2"].find("+") != -1:<br/>   m2s = row["m2"].split("+")<br/>   newM2 = int(m2s[0]) + int(m2s[1])<br/>   object_info.set_value(index, "m2", newM2)</span><span id="7f0f" class="ls lt iq nq b gy oa nv l nw nx"><strong class="nq ir">if</strong> row["Number of rooms"].find("½") != -1:<br/>    rooms = row["Number of rooms"].split("½")</span><span id="0bd8" class="ls lt iq nq b gy oa nv l nw nx"><strong class="nq ir">if</strong> rooms[0] == "":<br/>     newRooms = 0.5<br/>    <strong class="nq ir">else:<br/>     </strong>newRooms = float(0.5) + float(rooms[0])</span><span id="8919" class="ls lt iq nq b gy oa nv l nw nx">object_info.set_value(index, "Number of rooms", newRooms)</span><span id="8573" class="ls lt iq nq b gy oa nv l nw nx"><strong class="nq ir">if</strong> row["Rent"].find("—") != -1:<br/>     newRent = 0<br/>     object_info.set_value(index, "Rent", newRent)<br/>    <strong class="nq ir">else:<br/>     </strong>newRent = "".join(row["Rent"].split())<br/>     object_info.set_value(index, "Rent", newRent)</span><span id="e402" class="ls lt iq nq b gy oa nv l nw nx"><strong class="nq ir">return</strong> object_info</span></pre><h1 id="f7a6" class="nb lt iq bd lu nc nd ne lx nf ng nh ma jw ni jx md jz nj ka mg kc nk kd mj nl bi translated">1.2 数据库存储部分</h1><p id="4126" class="pw-post-body-paragraph kf kg iq kh b ki mn jr kk kl mo ju kn ko nm kq kr ks nn ku kv kw no ky kz la ij bi translated">最后，我们有了结构化格式的所有数据——所以现在是时候以一种方便的方式存储它了，即存储在数据库中。我们将所有数据存储在熊猫数据框中，如下所示:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ob"><img src="../Images/f59470c84929680b4e8260e3e8cc7d3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PWfLAqjH__-ySZRp_14Smg.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Pandas Data Frame containing apartment data.</figcaption></figure><p id="0e14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们需要构建一个可以存储每一列的数据库表。这可以通过下面的 SQL 代码轻松完成(假设您使用的是 MS SQL server，尽管语法与其他数据库类似):</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi oc"><img src="../Images/61283b4e1d694852b6ccf05f829b2255.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*7kgDN52ikWJnUk6BkLXmZw.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Query for creating the table “UpcomingSales”.</figcaption></figure><p id="a044" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们编写一个简单的函数，它可以使用 pyodbc-package 连接到我的本地“本地”数据库。该函数如下:</p><pre class="ld le lf lg gt np nq nr ns aw nt bi"><span id="5389" class="ls lt iq nq b gy nu nv l nw nx"><strong class="nq ir">def</strong> <em class="ny">mssql_connect</em>(server, database, driver):<br/>    cnxn = pyodbc.connect('DRIVER='+driver+ \<br/>                          ';SERVER='+server+ \<br/>                          ';DATABASE='+database + \<br/>                          ';Trusted_Connection=yes')<br/>    cursor = cnxn.cursor()<br/>    <strong class="nq ir">return</strong> cnxn, cursor</span></pre><p id="0426" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这个函数结合一个按行插入数据的查询，我们最终达到了我们的目标<strong class="kh ir"> <em class="ny">(这个查询最好使用一个简单的 merge 语句来编写):</em> </strong></p><pre class="ld le lf lg gt np nq nr ns aw nt bi"><span id="3513" class="ls lt iq nq b gy nu nv l nw nx">#SQL INPUT PARAMETERS<br/>pyodbc.pooling = False<br/>server = 'server'<br/>database = 'database'<br/>username = 'username'<br/>password = 'password'<br/>driver= '{ODBC Driver 13 for SQL Server}'</span><span id="0ffc" class="ls lt iq nq b gy oa nv l nw nx">cnxn, cursor = mssql_connect(	server, <br/>				database, <br/>				username, <br/>				password, <br/>				driver)<br/>data = result.values.tolist()<br/><strong class="nq ir">for</strong> <em class="ny">i, item</em> in enumerate(data):<br/> insert_query = "IF NOT EXISTS ( \<br/>			SELECT \<br/>				* \<br/>			FROM \<br/>				[Booli].[UpcomingSales] \<br/>			WHERE \<br/>				[Link] = '" + str(item[0]) + "' AND<br/>				[DateInserted] = '" + <br/>				str(date.today()) +"') \<br/>			BEGIN \<br/>			INSERT INTO [Booli].[UpcomingSales] \<br/>			VALUES ('" + str(item[0]) + \<br/>				"'," + str(item[1]) + \<br/>				"," + str(item[2]) + \<br/>				"," + str(item[3]) + \<br/>				",'" + str(item[4]) + \<br/>				"'," + str(item[5]) + \<br/>				"," + str(item[6]) + \<br/>				",'" + str(item[7]) + \<br/>				"','" + str(date.today()) +"') \<br/>			END"</span><span id="7e20" class="ls lt iq nq b gy oa nv l nw nx">cursor.execute(insert_query)</span><span id="f95d" class="ls lt iq nq b gy oa nv l nw nx">#Cleanup<br/>cnxn.commit()<br/>cursor.close()<br/>cnxn.close()</span></pre><p id="116b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以通过一个简单的 select-query 与数据库对话来获得结果:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi od"><img src="../Images/4f161588c1691866d0e728d24a8c8aea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8AbkyF34avctVyDIlfaRxg.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Select-query to the table that holds the object data.</figcaption></figure><h1 id="beba" class="nb lt iq bd lu nc nd ne lx nf ng nh ma jw ni jx md jz nj ka mg kc nk kd mj nl bi translated">2.可视化销售对象的数据</h1><p id="dfde" class="pw-post-body-paragraph kf kg iq kh b ki mn jr kk kl mo ju kn ko nm kq kr ks nn ku kv kw no ky kz la ij bi translated">很容易调整代码，以抓取售出的对象，而不是待售的对象，我不会介绍如何做到这一点，而是我会显示一些简单的可视化从售出的对象抓取数据。首先，我们通过 SQL 查询调用数据库来获取数据。生成的数据将存储在名为“数据”的熊猫数据框中。获取数据的 Python 代码如下所示:</p><pre class="ld le lf lg gt np nq nr ns aw nt bi"><span id="ddc9" class="ls lt iq nq b gy nu nv l nw nx">query = "SELECT <br/>             * \<br/>         FROM \ <br/>             [Booli].[SoldObjects]"<br/>data = pd.read_sql(query, cnxn)</span></pre><p id="590b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出如下所示:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi oe"><img src="../Images/04847ea3e803f0bcdf99cd9e7e711671.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ptSEmPkbM2nyJbrIdcOdOQ.png"/></div></div></figure><p id="3c04" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们使用内置的 pandas 功能“cut”将租金成本分成不同的价格部分:</p><pre class="ld le lf lg gt np nq nr ns aw nt bi"><span id="8736" class="ls lt iq nq b gy nu nv l nw nx">bins = [0, 500, 1000, 1500, 2000, 2500, 3000, 3500, 4000, 10000]<br/>labels = ['-500', '500-1000', '1000-1500', '1500-2000', '2000-2500', 	'2500-3000', '3000-3500', '3500-4000', '4000-10000'])</span><span id="5fe7" class="ls lt iq nq b gy oa nv l nw nx">data["Rent categories"] = pd.cut(<br/>				data['Rent'], <br/>				bins = bins, 	<br/>				include_lowest = True, <br/>				labels = labels<br/>				)</span></pre><p id="b7c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以绘制数据，以了解不同租金类别的价格随时间的变化情况</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi of"><img src="../Images/79524d47294a778cf849366ed60a5d4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hg_ve1DpSxTQ8lYcIpL57g.png"/></div></div></figure><p id="2a85" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">直觉告诉你——租金越低，价格越高。现在让我们仔细看看斯德哥尔摩不同地区的价格差异</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi og"><img src="../Images/d33943b9543ef48ee0c56939f788135a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pCfAzaDfPNG8oH7QukJJAw.png"/></div></div></figure><p id="8d7f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于那些住在斯德哥尔摩的人来说，结果可能不会令人惊讶，因为奥斯特马尔姆的平均售价最高，远远高于整体平均水平。</p><p id="01b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们来看看每个地区[价格/平方米]的分布及其各自的平均值</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi oh"><img src="../Images/10ac3d5b4e053f9d5e5c72504e923b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hUfrrD25rhzsi0PZ83ctbw.png"/></div></div></figure><p id="ac77" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以及整个样本的[价格/平方米]的分布:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi of"><img src="../Images/6233537b6d52d96c2eb43388391a6cf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*esCWGJJINReGsDVcs6zgjQ.png"/></div></div></figure><p id="7d14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所见，整个样本的平均价格为 85000 SEK。</p><p id="48fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们来看看每个地区的平均[价格/平方米]以及这些物品的房间数量。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi oi"><img src="../Images/b8cff21887d4805ebd0a63797868aaa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hbrS31KA-bDZFAr2m4_UTg.png"/></div></div></figure><p id="fc93" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如前所述，该样本缺乏较高“#房间数”范围内公寓的数据，因此平均值不能代表实际市场价格。为了让我的观点更清楚，让我们计算每个区域的对象数和“房间数”</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi oj"><img src="../Images/8eeffe407a3c0c1d1f3c41b445b34aed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GjRVULySuqPCDWujCT3vJw.png"/></div></div></figure><p id="019e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如图所示，在最好的情况下，我们可以说“# rooms”= 1、2、3 和 4 具有代表性平均值，而“# rooms”&gt; 4 的平均值由于数据点较少而具有高度失真的平均值。</p></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><h1 id="9709" class="nb lt iq bd lu nc or ne lx nf os nh ma jw ot jx md jz ou ka mg kc ov kd mj nl bi translated">3.评论</h1><p id="0994" class="pw-post-body-paragraph kf kg iq kh b ki mn jr kk kl mo ju kn ko nm kq kr ks nn ku kv kw no ky kz la ij bi translated">首先，Python 代码肯定可以写得更有效率，但正如我指出的，这个项目的目的不是为抓取组件编写生产就绪代码，这只是一个用于特定目的的一次性项目。如上所述，刮擦部分的一个明显的优化是搜索多个区域而不是一个区域。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ow"><img src="../Images/d253f02c07c59fdca0cc5cd8879464df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FyPv7voIbx-dDbazIg53pg.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">URL-structure for multiple areas.</figcaption></figure><h1 id="8932" class="nb lt iq bd lu nc nd ne lx nf ng nh ma jw ni jx md jz nj ka mg kc nk kd mj nl bi translated">4.进一步的工作</h1><p id="cd43" class="pw-post-body-paragraph kf kg iq kh b ki mn jr kk kl mo ju kn ko nm kq kr ks nn ku kv kw no ky kz la ij bi translated">我们可以使用“每平方米价格”的响应变量 Y 实现一个简单的回归模型，以找出每个独立变量 x 的贡献。在给定一组独立变量值的情况下，该模型也可以用作价格估计器。</p></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><p id="c6d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的阅读。如果您有任何问题，请通过<strong class="kh ir"> cfuru@kth.se </strong>联系我，也可以在<a class="ae lb" href="https://www.linkedin.com/in/christopher-furu-402b33a4/" rel="noopener ugc nofollow" target="_blank"> linkedin </a>加我。</p></div></div>    
</body>
</html>