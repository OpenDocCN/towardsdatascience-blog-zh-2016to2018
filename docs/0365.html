<html>
<head>
<title>Course 2 — Data structure — Part 1: The Basic data structures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">课程2 —数据结构—第1部分:基本数据结构</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/course-2-data-structure-part-1-the-basic-data-structures-4f4b5bd380c1?source=collection_archive---------1-----------------------#2017-04-23">https://towardsdatascience.com/course-2-data-structure-part-1-the-basic-data-structures-4f4b5bd380c1?source=collection_archive---------1-----------------------#2017-04-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9124a772ad68e0e4235f080ff969b91c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wqry7BT9cmfVivkOAimfVQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">algorithms + data structures version 2017</figcaption></figure><p id="a9a7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一句名言:<strong class="ke ir">程序=算法+数据结构</strong>。<a class="ae la" href="https://medium.com/towards-data-science/course-1-algorithmic-toolbox-part-1-introduction-c29b8175430f" rel="noopener">在上一个系列</a>中，我们讲了3种算法<a class="ae la" href="https://medium.com/towards-data-science/course-1-algorithmic-toolbox-part-2-big-o-and-greedy-6265d9065f05" rel="noopener">贪婪</a>、<a class="ae la" href="https://medium.com/towards-data-science/course-1-algorithmic-toolbox-part-3-divide-and-conquer-dd9022bfa2c0" rel="noopener">分而治之</a>、<a class="ae la" href="https://medium.com/towards-data-science/course-1-algorithmic-toolbox-part-4-dynamic-programming-223ffc01984a" rel="noopener">动态规划</a>来接近一个问题。在下一个系列中，我们将看看数据结构，以帮助我们解决更复杂的问题。让我们从最基本的数据结构开始:数组、链表。看看队列、栈是如何建立在这些数据结构之上的。什么是树？如何不用递归计算树的高度？</p><h1 id="e301" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">数组</strong></h1><p id="3d93" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">数组是由相同大小的元素组成的连续内存区域，这些元素由连续的整数索引。</p><p id="b33c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在内存中，我们只是将指针地址保存到数组中，因为所有元素在内存中是大小相等且连续的，所以要得到第I个元素的地址，我们只需计算:<strong class="ke ir">pointer _ address+element _ size * I .</strong></p><p id="59ab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">基于此定义，我们可以很容易地看到阵列上的操作成本:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/336ee2716851315674573126f503a8f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*eEHAAJFWuXT0OmXWiF0IMw.png"/></div></figure><h1 id="fe4f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">单链表</h1><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/fdddbed3af62bf718c4ed34bc5898f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YY7HbHECz5FopprPLU6FgQ.png"/></div></div></figure><p id="b9df" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">单链表有许多节点，每个节点包含键(数据)和指向下一个元素的指针。第一个节点叫头，最后一个节点叫尾。基于这个定义，我们可以很容易地实现单链表:</p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="a969" class="mp lc iq ml b gy mq mr l ms mt">def push_front(key): <br/>    node &lt;- new node<br/>    node.key &lt;- key<br/>    node.next = head<br/>    head &lt;- node<br/>    if tail == nil:<br/>        tail &lt;- head</span><span id="9bb3" class="mp lc iq ml b gy mu mr l ms mt">def pop_front():<br/>    if head == nil:<br/>        ERROR: empty list<br/>    head &lt;- head.next<br/>    if head = nil:<br/>        tail &lt;- nil</span><span id="d523" class="mp lc iq ml b gy mu mr l ms mt">def push_back(key):<br/>    node &lt;- new node<br/>    node.key &lt;- key<br/>    node.next = nil<br/>    if tail = nil:<br/>        head &lt;- tail &lt;- node<br/>    else:<br/>        tail.next &lt;- node<br/>        tail &lt;- node</span><span id="a2dc" class="mp lc iq ml b gy mu mr l ms mt">def pop_back():<br/>    if head == nil: ERROR: empty list<br/>    if head == tail:<br/>        head &lt;- tail &lt;- nil<br/>    else:<br/>        p &lt;- head<br/>        while p.next.next != nil:<br/>            p &lt;- p.next<br/>        p.next &lt;- nil; tail &lt;- p</span><span id="a397" class="mp lc iq ml b gy mu mr l ms mt">def add_after(node, key):<br/>    node2 &lt;- new node<br/>    node2.key &lt;- key<br/>    node2.next = node.next<br/>    node.next = node2<br/>    if tail == node:<br/>        tail &lt;- node2</span></pre><h1 id="bf8a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">双向链表</h1><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/d27d3a8f4bbeb2b6703b914114a6fb9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m1k94FUj3ayN_3FSldiG6A.png"/></div></div></figure><p id="6942" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在单链表中，我们只有一个节点指向下一个元素，像PopBack和AddBefore这样的操作需要O(n)来运行。有了双向链表，我们可以用O(1)来运行这些操作。我们有两个节点指向下一个元素和前一个元素。</p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="c03d" class="mp lc iq ml b gy mq mr l ms mt">def push_back(key):<br/>    node &lt;- new node<br/>    node.key &lt;- key; node.next = nil<br/>    if tail = nil:<br/>        head &lt;- tail &lt;- node<br/>        node.prev &lt;- nil<br/>    else:<br/>        tail.next &lt;- node<br/>        node.prev &lt;- tail<br/>        tail &lt;- node</span><span id="3dd2" class="mp lc iq ml b gy mu mr l ms mt">def pop_back():<br/>    if head = nil: ERROR: empty list<br/>    if head = tail:<br/>        head &lt;- tail &lt;- nil<br/>    else:<br/>        tail &lt;- tail.prev<br/>        tail.next &lt;- nil</span><span id="7451" class="mp lc iq ml b gy mu mr l ms mt">def add_after(node, key):<br/>    node2 &lt;- new node<br/>    node2.key &lt;- key<br/>    node2.next &lt;- node.next<br/>    node2.prev &lt;- node<br/>    node.next &lt; node2<br/>    if node2.next != nil:<br/>        node2.next.prev &lt;- node2<br/>    if tail = node:<br/>        tail &lt;- node2</span><span id="7fee" class="mp lc iq ml b gy mu mr l ms mt">def add_before(node, key):<br/>    node2 &lt;- new node<br/>    node2.key &lt;- key<br/>    node2.next &lt;- node<br/>    node2.prev &lt;- node.prev<br/>    node.prev &lt;- node2<br/>    if node2.prev != nill:<br/>        node2.prev.next &lt;- node2<br/>    if head = node:<br/>        head &lt;- node2</span></pre><h1 id="36e1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">堆</h1><p id="6338" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">堆栈是具有以下操作的抽象数据类型。</p><p id="0e1a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Push(键):将键添加到集合中。</p><p id="c136" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Top():返回最近添加的<strong class="ke ir">键。</strong></p><p id="ea5e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Pop():删除并返回最近添加的<strong class="ke ir">键</strong></p><p id="5380" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Empty():有没有元素？</p><p id="f152" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">堆栈，也称为LIFO队列，可以用数组或链表来实现，对于Push、Pop、Top、Empty操作有O(1)。</p><h2 id="ea9c" class="mp lc iq bd ld mw mx dn lh my mz dp ll kn na nb lp kr nc nd lt kv ne nf lx ng bi translated">平衡支架问题:</h2><p id="b1d6" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">比方说，我们想要一个文本编辑器的检查器。我们要检查文本输入是平衡的括号如下:</p><p id="e78b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">平衡的:</p><ul class=""><li id="6815" class="nh ni iq ke b kf kg kj kk kn nj kr nk kv nl kz nm nn no np bi">([]) [] ()</li><li id="59ad" class="nh ni iq ke b kf nq kj nr kn ns kr nt kv nu kz nm nn no np bi">((([([])]))())</li></ul><p id="e976" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">不平衡:</p><ul class=""><li id="8394" class="nh ni iq ke b kf kg kj kk kn nj kr nk kv nl kz nm nn no np bi">([]]()</li><li id="436f" class="nh ni iq ke b kf nq kj nr kn ns kr nt kv nu kz nm nn no np bi">][</li></ul><p id="d059" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有了堆栈数据结构，我们可以很容易地解决这个问题:</p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="cd07" class="mp lc iq ml b gy mq mr l ms mt">def is_balanced(str):<br/>    Stack stack<br/>    for char in str:<br/>        if char in [ '(', '[' ]:<br/>            stack.push(char)<br/>        else:<br/>            if stack.empty(): return False<br/>            top &lt;- stack.pop()<br/>            if (top = '[' and char != ']') or<br/>                (top = '(' and char != ')'):<br/>                    return False<br/>    return stack.empty()</span></pre><h1 id="3c27" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">队列:</h1><p id="4b7e" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">队列是具有以下操作的抽象数据类型:</p><p id="7e1a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Enqueue(key):将关键字添加到集合中。</p><p id="5e86" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Dequeue():移除并返回<strong class="ke ir">最近最少添加的</strong>键。</p><p id="b77b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Empty():有没有元素？</p><p id="f38c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">队列，也称为FIFO(先进先出)，可以用链表(带尾指针)或数组来实现，并有O(1)用于入队、出队和空操作。</p><p id="5e01" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">看这些可视化:<a class="ae la" href="http://www.cs.usfca.edu/~galles/visualization/StackArray.html" rel="noopener ugc nofollow" target="_blank">基于数组的栈</a>，<a class="ae la" href="http://www.cs.usfca.edu/~galles/visualization/StackLL.html" rel="noopener ugc nofollow" target="_blank">基于列表的栈</a>，<a class="ae la" href="http://www.cs.usfca.edu/~galles/visualization/QueueArray.html" rel="noopener ugc nofollow" target="_blank">基于数组的队列</a>，<a class="ae la" href="http://www.cs.usfca.edu/~galles/visualization/QueueLL.html" rel="noopener ugc nofollow" target="_blank">基于列表的队列</a>。</p><h1 id="59cb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">树</h1><p id="e2e8" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">树有一个根节点和许多其他节点，每个节点包含:键、子节点、父节点(可选)。对于二叉树，一个节点包含:key，left，right，parent(可选)。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/dfbbf4bdd3e66d69902e62213bc0b1c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*y-MN1kxUzSSpPxDsO6t-Dg.png"/></div></figure><p id="30d4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是一个二叉树的例子，我们有Les作为根和许多其他节点，每个节点有左和右像:Cathy(左)，Sam(右)为根节点。</p><p id="0aa4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要计算树的高度，我们可以使用递归:</p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="246a" class="mp lc iq ml b gy mq mr l ms mt">def height(tree):<br/>  if tree = nil:<br/>    return 0<br/>  return 1 + Max(height(tree.left), height(tree.right))</span></pre><p id="6e2a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们有两种方法来按特定顺序访问树的节点:</p><ul class=""><li id="429f" class="nh ni iq ke b kf kg kj kk kn nj kr nk kv nl kz nm nn no np bi translated"><strong class="ke ir">深度优先:</strong>在探索兄弟子树之前，我们完全遍历子树。</li></ul><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="91a2" class="mp lc iq ml b gy mq mr l ms mt">def post_order_traversal(tree):<br/>  if tree = nil:<br/>    return<br/>  post_order_traversal(tree.left)<br/>  post_order_traversal(tree.right)<br/>  print(tree.key)</span></pre><ul class=""><li id="7669" class="nh ni iq ke b kf kg kj kk kn nj kr nk kv nl kz nm nn no np bi translated"><strong class="ke ir">广度优先:</strong>在前进到下一层之前，我们遍历一层的所有节点。</li></ul><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="b5ee" class="mp lc iq ml b gy mq mr l ms mt">def level_traversal(tree):<br/>  if tree = nil: return<br/>  Queue q<br/>  q.Enqueue(tree)<br/>  while not q.empty():<br/>    node &lt;- q.dequeue()<br/>    print(node)<br/>    if node.left != nil:<br/>      q.enqueue(node.left)<br/>    if node.left != nil:<br/>      q.enqueue(node.right)</span></pre><h1 id="96b2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">问题1:检查代码中的括号</h1><p id="fbf6" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">在这个问题中，您将为文本编辑器实现一个功能，以查找代码中括号用法中的错误。</p><p id="c29b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">问题描述</strong></p><p id="b1ad" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">任务。你的朋友正在为程序员制作一个文本编辑器。他目前正在开发一个功能，可以发现不同类型括号使用中的错误。代码可以包含集合[]{}()中的任何中括号，其中左中括号是[、{、和(对应的右中括号是]、}、和)。</strong></p><p id="29d0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了方便起见，文本编辑器不仅应该通知用户括号的使用有错误，还应该指出有问题的括号在代码中的确切位置。首要任务是找到第一个不匹配的右括号，它要么前面没有左括号，如] in ]()，要么结束了错误的左括号，如} in ()[}。如果没有这样的错误，那么它应该会找到第一个不匹配的左括号，后面没有对应的右括号，比如{}([]。如果没有错误，文本编辑器应该通知用户括号的用法是正确的。</p><p id="ec55" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">除了括号，代码还可以包含大小拉丁字母、数字和标点符号。更正式的说法是，代码中的所有括号都应该分成匹配的括号对，这样每对括号中的开始括号都在结束括号之前，对于任何两对括号，要么其中一个嵌套在另一个中，如(foo[bar])，要么它们是分开的，如f(a，b)-g[c]。中括号[对应于中括号]，{对应于}，和(对应于)。</p><p id="ac6d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输入格式。</strong>输入包含一个字符串𝑆，它由集合[]{}()中的大小拉丁字母、数字、标点符号和括号组成。</p><p id="6cb4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输出格式。</strong>如果𝑆的代码正确使用了括号，则输出“Success”(不带引号)。否则，输出第一个不匹配的右括号的从1开始的索引，如果没有不匹配的右括号，则输出第一个不匹配的左括号的从1开始的索引。</p><p id="8641" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">样品1。</strong></p><p id="a6da" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输入:</strong></p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="f736" class="mp lc iq ml b gy mq mr l ms mt">{}[] </span></pre><p id="4cd2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输出:</strong></p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="e8df" class="mp lc iq ml b gy mq mr l ms mt">Success</span></pre><p id="c875" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">解释:</strong>括号使用正确:有两对括号——第一对{ and }，第二对[and]——并且这两对不相交。</p><p id="2b93" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">样品2 </strong>。</p><p id="3533" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输入:</strong></p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="7182" class="mp lc iq ml b gy mq mr l ms mt">{ </span></pre><p id="a99b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输出:</strong></p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="1f8c" class="mp lc iq ml b gy mq mr l ms mt">1 </span></pre><p id="3f7a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">解释:</strong>代码{没有正确使用括号，因为括号不能成对(只有一个括号)。没有右括号，第一个不匹配的左括号是{，它的位置是1，所以我们输出1。</p><p id="78fe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">样品3。</strong></p><p id="3bed" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输入:</strong></p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="7449" class="mp lc iq ml b gy mq mr l ms mt">{[} </span></pre><p id="e5c0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输出:</strong></p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="87d8" class="mp lc iq ml b gy mq mr l ms mt">3 </span></pre><p id="f98a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">解释:</strong>括号}不匹配，因为它前面最后一个不匹配的左括号是【and not】。它是第一个不匹配的右括号，我们的首要任务是输出第一个不匹配的右括号，它的位置是3，所以我们输出3。</p><p id="79c2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">样品3。</strong></p><p id="75bc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输入:</strong></p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="949f" class="mp lc iq ml b gy mq mr l ms mt">foo(bar[i); </span></pre><p id="3196" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输出:</strong></p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="0b2b" class="mp lc iq ml b gy mq mr l ms mt">10 </span></pre><p id="1686" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">解释:</strong>)不匹配[，所以)是第一个不匹配的右括号，所以我们输出它的位置，是10。</p><p id="6889" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要解决这个问题，您可以稍微修改讲座中的<strong class="ke ir"> IsBalanced </strong>算法，不仅考虑括号，还考虑代码中的其他字符，并且不仅返回代码是否正确使用括号，还返回代码第一个损坏的位置。</p><h2 id="0ca3" class="mp lc iq bd ld mw mx dn lh my mz dp ll kn na nb lp kr nc nd lt kv ne nf lx ng bi translated"><strong class="ak">解决方案:</strong></h2><p id="b493" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">在讲座中，IsBalanced伪代码为我们提供了括号的解决方案:“()[]”。我们只需要检查“{}”并跟踪我们推入堆栈的每个括号的位置。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="f1fd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">问题2:计算树高</strong></h1><p id="55a9" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">树用于操作分层数据，如零售商的类别层次结构或计算机上的目录结构。它们还用于数据分析和机器学习，用于分层聚类和构建复杂的预测模型，包括一些实践中表现最好的算法，如决策树和随机森林上的梯度提升。在本课程后面的模块中，我们将介绍平衡二分搜索法树(BST)，这是一种特殊的树，可以非常高效地存储、操作和检索数据。因此，平衡BST在数据库中用于高效存储，并且实际上在几乎任何重要的程序中使用，通常是通过手边编程语言的内置数据结构。在这个问题中，你的目标是适应树木。您需要从输入中读取树的描述，实现树数据结构，存储树并计算其高度。</p><p id="ca8c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">问题描述</strong></p><p id="6fc9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">任务。</strong>给你一个有根树的描述。你的任务是计算并输出它的高度。回想一下,(有根的)树的高度是一个节点的最大深度，或者从一片叶子到根的最大距离。给你一棵任意的树，不一定是二叉树。</p><p id="70ec" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输入格式。</strong>第一行包含𝑛.的节点数第二行包含从1到𝑛1的𝑛整数——节点的父节点。如果𝑖-th其中之一(0≤𝑖≤𝑛1)为1，则节点𝑖是根，否则它是𝑖-th节点的父节点的从0开始的索引。保证正好有一个根。保证输入代表一棵树。</p><p id="87ed" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输出格式。</strong>输出树的高度。</p><p id="b014" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">样品1。</strong></p><p id="bf5d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输入:</strong></p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="11bf" class="mp lc iq ml b gy mq mr l ms mt">5 </span><span id="d8ba" class="mp lc iq ml b gy mu mr l ms mt">4 -1 4 1 1 </span></pre><p id="9d46" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输出:</strong></p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="9fa2" class="mp lc iq ml b gy mq mr l ms mt">3</span></pre><p id="42d4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">解释:</strong>输入表示有5个节点，编号从0到4，节点0是节点4的子节点，节点1是根节点，节点2是节点4的子节点，节点3是节点1的子节点，节点4是节点1的子节点。为了看到这一点，让我们在一行中写下从0到4的节点数，并将输入中给出的数字写在下面的第二行中:</p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="047e" class="mp lc iq ml b gy mq mr l ms mt">0 1 2 3 4</span><span id="c17b" class="mp lc iq ml b gy mu mr l ms mt">4 -1 4 1 1</span></pre><p id="fde0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们可以看到，节点号1是根，因为1对应于第二行中的根。此外，我们知道节点3和4是根节点1的子节点。此外，我们知道节点0和2是节点4的子节点。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/1f46dfd8411aff3c588433eaa5ef67b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*xwQX__ExL9gFAiTbOfUXbg.png"/></div></div></figure><p id="5b9a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这棵树的高度是3，因为从根1到叶2的路径上的顶点数是3。</p><p id="5ba7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">样品2。</strong></p><p id="deff" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输入:</strong></p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="5589" class="mp lc iq ml b gy mq mr l ms mt">5 </span><span id="4074" class="mp lc iq ml b gy mu mr l ms mt">-1 0 4 0 3 </span></pre><p id="124c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输出:</strong></p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="b619" class="mp lc iq ml b gy mq mr l ms mt">4 </span></pre><p id="069c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">解释:</strong></p><p id="df95" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">输入意味着有5个节点，编号从0到4，节点0是根，节点1是节点0的子节点，节点2是节点4的子节点，节点3是节点0的子节点，节点4是节点3的子节点。这棵树的高度是4，因为从根0到叶2的路径上的节点数是4。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/89d67b57d5fc576daf97e0c802407241.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*C9W7wRUvZcOo7AtIU6BPGw.png"/></div></figure><p id="cc45" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了解决这个问题，用一个适用于任意树的实现来改变课堂上描述的高度函数。请注意，在这个问题中，树可能非常深，所以如果您使用递归，应该小心避免堆栈溢出问题，并且一定要在具有最大可能高度的树上测试您的解决方案。</p><p id="3b36" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">建议:利用每个树节点的标签都是0范围内的整数这一事实..𝑛−1:你可以将每个节点存储在一个数组中，数组的索引是节点的标签。通过将节点存储在一个数组中，您可以对给定标签的任何节点进行𝑂(1访问。创建一个𝑛节点数组:</p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="1de3" class="mp lc iq ml b gy mq mr l ms mt">allocate 𝑛𝑜𝑑𝑒𝑠[𝑛] <br/>for 𝑖 ← 0 to 𝑛 − 1: <br/>  𝑛𝑜𝑑𝑒𝑠[𝑖] =new 𝑁𝑜𝑑𝑒</span></pre><p id="b947" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，读取每个父索引:</p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="7c93" class="mp lc iq ml b gy mq mr l ms mt">for 𝑐ℎ𝑖𝑙𝑑_𝑖𝑛𝑑𝑒𝑥 ← 0 to 𝑛 − 1: <br/>  read 𝑝𝑎𝑟𝑒𝑛𝑡_𝑖𝑛𝑑𝑒𝑥 <br/>  if 𝑝𝑎𝑟𝑒𝑛𝑡_𝑖𝑛𝑑𝑒𝑥 == −1: <br/>    𝑟𝑜𝑜𝑡 ← 𝑐ℎ𝑖𝑙𝑑_𝑖𝑛𝑑𝑒𝑥 <br/>  else: <br/>    𝑛𝑜𝑑𝑒𝑠[𝑝𝑎𝑟𝑒𝑛𝑡_𝑖𝑛𝑑𝑒𝑥].𝑎𝑑𝑑𝐶ℎ𝑖𝑙𝑑(𝑛𝑜𝑑𝑒𝑠[𝑐ℎ𝑖𝑙𝑑_𝑖𝑛𝑑𝑒𝑥])</span></pre><p id="7909" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦你做好了树，你就需要计算它的高度。如果不使用递归，就不用担心堆栈溢出问题。如果没有递归，你将需要一些辅助数据结构来跟踪当前状态(例如，在讲座的广度优先搜索代码中，我们使用了队列)。</p><h2 id="7a91" class="mp lc iq bd ld mw mx dn lh my mz dp ll kn na nb lp kr nc nd lt kv ne nf lx ng bi translated">解决方案:</h2><p id="42ca" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">在我们构建了树之后，我们可以使用queue来计算树的高度。为了做到这一点，我们将使用广度优先的旅行，对于每一个水平，我们增加高度1多。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="a96f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">进阶问题3:网络封包处理模拟</h1><p id="6981" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">在这个问题中，你将实现一个程序来模拟网络数据包的处理</p><p id="9e8c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">问题描述</strong></p><p id="cf8a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">任务。给你一系列的网络数据包，你的任务是模拟它们的处理过程。数据包以某种顺序到达。对于每个𝑖数据包，你知道它到达𝐴𝑖的时间和处理器处理它𝑃𝑖的时间(都以毫秒计)。只有一个处理器，它按照数据包到达的顺序处理传入的数据包。如果处理器开始处理某个数据包，它不会中断或停止，直到处理完这个数据包，处理数据包𝑖正好需要𝑃𝑖毫秒。</strong></p><p id="7174" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">处理数据包的计算机有一个固定大小的𝑆.网络缓冲区当包到达时，它们在被处理之前被存储在缓冲器中。然而，如果当数据包到达时缓冲区已满(在此数据包之前已有𝑆数据包到达，而计算机尚未处理完其中的任何一个)，它将被丢弃，根本不会被处理。如果几个数据包同时到达，它们首先都被存储在缓冲区中(其中一些可能会因此被丢弃，这些将在后面的输入中描述)。计算机按照信息包到达的顺序处理信息包，一旦处理完前一个信息包，就开始处理缓冲区中的下一个可用信息包。如果在某个时刻计算机不忙，并且缓冲区中没有数据包，计算机就等待下一个数据包到达。请注意，计算机一处理完数据包，它就会离开缓冲区并释放缓冲区中的空间。</p><p id="b917" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输入格式。</strong>输入的第一行包含缓冲区的大小𝑆和传入网络数据包的数量𝑛。接下来的每一条𝑛线都包含两个数字。𝑖-th线包含𝑖-th数据包的到达时间𝐴𝑖和处理时间𝑃𝑖(均以毫秒计)。可以保证到达时间序列是不递减的(但是，它可以包含以毫秒为单位的完全相同的到达时间，在这种情况下，输入中较早的分组被认为较早到达)。</p><p id="1e21" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输出格式。</strong>对于每个数据包，输出处理器开始处理它的时刻(以毫秒为单位),如果数据包被丢弃，则输出1(按照数据包在输入中给出的顺序输出数据包的答案)。</p><p id="b446" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">样品1。</strong></p><p id="f9d6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输入:</strong></p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="4e10" class="mp lc iq ml b gy mq mr l ms mt">1 1 </span><span id="70c2" class="mp lc iq ml b gy mu mr l ms mt">0 0 </span></pre><p id="8881" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输出:</strong></p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="0adc" class="mp lc iq ml b gy mq mr l ms mt">0 </span></pre><p id="edeb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">解释:</strong>唯一的数据包在时间0到达，计算机立即开始处理。</p><p id="06a4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">样品3。</strong></p><p id="66c1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输入:</strong></p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="4b33" class="mp lc iq ml b gy mq mr l ms mt">1 2 </span><span id="1f08" class="mp lc iq ml b gy mu mr l ms mt">0 1 </span><span id="464b" class="mp lc iq ml b gy mu mr l ms mt">0 1 </span></pre><p id="9f9a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输出:</strong></p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="98af" class="mp lc iq ml b gy mq mr l ms mt">0 </span><span id="65a0" class="mp lc iq ml b gy mu mr l ms mt">-1 </span></pre><p id="6082" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">解释:</strong>第一个数据包在时间0到达，第二个数据包也在时间0到达，但是被丢弃，因为网络缓冲区的大小为1，并且它已经被第一个数据包填满。第一个数据包在时间0开始处理，第二个数据包根本没有处理。</p><p id="a8e3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">样品4。</strong></p><p id="d30a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输入:</strong></p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="7ea5" class="mp lc iq ml b gy mq mr l ms mt">1 2 </span><span id="916c" class="mp lc iq ml b gy mu mr l ms mt">0 1 </span><span id="0a12" class="mp lc iq ml b gy mu mr l ms mt">1 1</span></pre><p id="93a2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">输出:</strong></p><pre class="mf mg mh mi gt mk ml mm mn aw mo bi"><span id="7a08" class="mp lc iq ml b gy mq mr l ms mt">0 </span><span id="6ed7" class="mp lc iq ml b gy mu mr l ms mt">1</span></pre><p id="7135" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">解释:</strong>第一个包在时间0到达，计算机立即开始处理，在时间1结束。第二个数据包在时间1到达，计算机立即开始处理它。</p><p id="6331" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要解决这个问题，您可以使用列表或队列(在这种情况下，队列应该允许访问它的最后一个元素，这样的队列通常称为deque)。您可以在自己选择的语言中使用相应的内置数据结构。</p><p id="7801" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一种可能的解决方案是在列表或队列<strong class="ke ir"> finish_time </strong>中以递增的顺序存储计算机将完成处理当前存储在网络缓冲区中的分组的时间。当一个新的包到达时，你首先需要从<strong class="ke ir"> finish_time </strong>的前面弹出所有在新的包到达时已经被处理的包。然后，您尝试在<strong class="ke ir">完成时间</strong>中添加新数据包的完成时间。如果缓冲区已满(在<strong class="ke ir">完成时间</strong>中已经有𝑆完成时间)，则数据包被丢弃。否则，其加工完成时间加到<strong class="ke ir">完成时间</strong>上。</p><p id="867e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果新数据包到达时<strong class="ke ir">完成时间</strong>为空，计算机将在新数据包到达时立即开始处理。否则，计算机将在处理完当前在<strong class="ke ir"> finish_time </strong>中的最后一个数据包后立即开始处理新的数据包(此时您需要访问<strong class="ke ir"> finish_time </strong>的最后一个元素，以确定计算机何时开始处理新的数据包)。您还需要通过将𝑃𝑖加到加工开始时间来计算加工完成时间，并将其推到<strong class="ke ir">完成时间</strong>的后面。</p><p id="560c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您需要记住输出每个数据包的处理开始时间，而不是存储在<strong class="ke ir"> finish_time </strong>中的处理结束时间。</p><h2 id="c454" class="mp lc iq bd ld mw mx dn lh my mz dp ll kn na nb lp kr nc nd lt kv ne nf lx ng bi translated">解决方案:</h2><p id="a9af" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">要解决这个问题，我们需要注意几点:</p><ul class=""><li id="b89c" class="nh ni iq ke b kf kg kj kk kn nj kr nk kv nl kz nm nn no np bi translated">我们只需要记录完成时间。</li><li id="5ef1" class="nh ni iq ke b kf nq kj nr kn ns kr nt kv nu kz nm nn no np bi translated">当前处理时间是每个请求进入的时间。每次请求到达时，我们应该删除所有在<strong class="ke ir">完成时间</strong>队列中已经完成的请求。</li><li id="63a6" class="nh ni iq ke b kf nq kj nr kn ns kr nt kv nu kz nm nn no np bi translated">当<strong class="ke ir">完成时间</strong>为空时，总是排队新请求。</li></ul><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h2 id="5f45" class="mp lc iq bd ld mw mx dn lh my mz dp ll kn na nb lp kr nc nd lt kv ne nf lx ng bi translated">阅读:</h2><p id="c3a2" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">参见第10.2章[CLRS] —数组，链表</p><p id="7f7a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">参见第10.1章[clr]—堆栈和队列</p><p id="c55d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">参见第10.4章[CLRS] —树</p><h2 id="dd57" class="mp lc iq bd ld mw mx dn lh my mz dp ll kn na nb lp kr nc nd lt kv ne nf lx ng bi translated">参考资料:</h2><p id="fa68" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">托马斯·h·科尔曼，查尔斯·e·莱瑟森，罗纳德·L·李维斯特，克利福德·斯坦。算法导论(第三版)。麻省理工学院出版社和麦格劳-希尔。2009.</p></div></div>    
</body>
</html>