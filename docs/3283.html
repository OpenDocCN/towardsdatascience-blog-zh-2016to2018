<html>
<head>
<title>Face Recognition for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向初学者的人脸识别</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/face-recognition-for-beginners-a7a9bd5eb5c2?source=collection_archive---------0-----------------------#2018-04-28">https://towardsdatascience.com/face-recognition-for-beginners-a7a9bd5eb5c2?source=collection_archive---------0-----------------------#2018-04-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9d32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kl translated">ace识别是一种识别技术，用于检测其图像保存在数据集中的个人的面部。尽管其他身份识别方法可能更准确，但人脸识别一直是研究的一个重要焦点，因为它的非干涉性质，因为它是人们进行个人身份识别的简便方法。</p><h1 id="ee46" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">人脸识别方法:-</h1><p id="dcd4" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">人脸识别有以下几种不同的方法</p><h1 id="2818" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak"> <em class="lx"> 1。几何基础/模板基础:- </em> </strong></h1><p id="24ca" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">人脸识别算法分为基于几何或基于模板的算法。基于模板的方法可以使用统计工具来构建，如SVM[支持向量机]、PCA[主成分分析]、LDA[线性判别分析]、核方法或迹变换。基于几何特征的方法分析局部面部特征及其几何关系。它也被称为基于特征的方法。</p><h1 id="9265" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak"> <em class="lx"> 2。零碎/整体:- </em> </strong></h1><p id="465c" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">元素之间的关系或功能的连接与整个面部没有经历到的数量，许多研究人员遵循这种方法，试图推导出最相关的特征。一些方法试图使用眼睛、特征的组合等等。一些隐马尔可夫模型方法也属于这一类，特征处理在人脸识别中非常有名。</p><h1 id="acea" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak"> <em class="lx"> 3。基于外观/基于模型:- </em> </strong></h1><p id="55f6" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">基于外观的方法显示关于几幅图像的人脸。被认为是高维向量的图像。这种技术通常用于从图像分割中导出特征空间。与训练集比较的样本图像。另一方面，基于模型的方法试图对人脸建模。对模型实现的新样本和用于识别图像的模型参数。</p><p id="8920" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于外观的方法可以分为线性或非线性。Ex- PCA、LDA、IDA用于直接方法，而核PCA用于非线性方法。另一方面，在基于模型的方法可以归类为2D或三维弹性束图匹配使用。</p><h1 id="d613" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak"> <em class="lx"> 4。基于模板/统计/神经网络:- </em> </strong></h1><h2 id="216b" class="ly kv iq bd kw lz ma dn la mb mc dp le jy md me li kc mf mg lm kg mh mi lq mj bi translated"><strong class="ak"> <em class="lx"> 4.1 .模板匹配:- </em> </strong></h2><p id="faa7" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">在模板匹配中，模式由样本、模型、像素、纹理等表示。识别函数通常是相关性或距离度量。</p><h2 id="c606" class="ly kv iq bd kw lz ma dn la mb mc dp le jy md me li kc mf mg lm kg mh mi lq mj bi translated"><strong class="ak"> <em class="lx"> 4.2 .统计方法:- </em> </strong></h2><p id="5971" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">在统计学方法中，用特征表示的模式。判别函数中的识别函数。每个图像都代表了三维特征。因此，目标是选择和应用正确的统计工具进行提取和分析。</p><p id="59a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用于人脸识别的统计工具有很多。这些分析工具用在两个或多个组或分类方法中。这些工具如下-</p><h2 id="d77b" class="ly kv iq bd kw lz ma dn la mb mc dp le jy md me li kc mf mg lm kg mh mi lq mj bi translated"><strong class="ak"> <em class="lx"> 4.2.1 .主成分分析【PCA】:-</em></strong></h2><p id="3456" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">使用和引用最多的统计方法之一是主成分分析。数学过程通过提取多维数据的主成分来执行维度缩减。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mk"><img src="../Images/1e7338a8e56415dd3ebfc6e6bf470d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pmnNryskzUB6mx_hSq-8_Q.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Dimension reduction from 3D to 2D image</figcaption></figure><h2 id="82d6" class="ly kv iq bd kw lz ma dn la mb mc dp le jy md me li kc mf mg lm kg mh mi lq mj bi translated"><strong class="ak">T5 4 . 2 . 2 .离散余弦变换【DCT】:-T7】</strong></h2><p id="3f34" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">它表示关于不同振荡频率的余弦函数和的一系列数据点。离散余弦变换基于傅立叶离散变换，因此，通过压缩变化，它可以用于变换图像，并允许有效的维数减少。</p><h2 id="d35f" class="ly kv iq bd kw lz ma dn la mb mc dp le jy md me li kc mf mg lm kg mh mi lq mj bi translated"><strong class="ak"> <em class="lx"> 4.2.3 .线性判别分析【LDA】:-</em></strong></h2><p id="8845" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">LDA广泛用于寻找特征的线性组合，同时保持类的可分性。与PCA不同，LDA试图对级别之间的差异进行建模。对于每个级别，LDA获得多个投影向量的差值。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi na"><img src="../Images/2853dfde864a614d7a9d6e3b42306030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vXQ5sgMF0XmiY4Jc6gJVwA.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">PCA vs LDA</figcaption></figure><h2 id="f9df" class="ly kv iq bd kw lz ma dn la mb mc dp le jy md me li kc mf mg lm kg mh mi lq mj bi translated"><strong class="ak"> <em class="lx"> 4.2.4 .局部保持投影【LPP】:-</em></strong></h2><p id="7927" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">他和代代木介绍了LPP。它是保持局部结构和设计的PCA的最佳替代方案。模式识别算法通常搜索最近的模式或邻居。因此，维护LLP质量的地方可以加快认识。</p><h2 id="5f72" class="ly kv iq bd kw lz ma dn la mb mc dp le jy md me li kc mf mg lm kg mh mi lq mj bi translated"><strong class="ak"> <em class="lx"> 4.2.5.Gabor小波:- </em> </strong></h2><p id="9816" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">在这种算法中，它表明来自哺乳动物大脑视觉皮层的神经生理学数据证据表明，视觉皮层中的简单细胞可以视为一族自相似的2D Gabor小波。Daugman提出的Gabor函数是局部空间带通滤波器，其实现了2D空间和2D傅立叶域中信息的联合分辨率的理论极限。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nb"><img src="../Images/b9a00c4b6eac7383d2edfdfe1deae03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k4sMzl2BQRn57sfkHzOUsQ.jpeg"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Gabor Wavelet in different magnitude</figcaption></figure><h2 id="c6f4" class="ly kv iq bd kw lz ma dn la mb mc dp le jy md me li kc mf mg lm kg mh mi lq mj bi translated"><strong class="ak"> <em class="lx"> 4.2.6 .独立分量分析【ICA】:-</em></strong></h2><p id="a90a" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">ICA旨在将数据转换为统计上独立的数据点的线性组合。因此，其目标是提供独立而非不相关的图像表示。ICA是PCA替代方案，它给出了更强大的数据表示。这是一种判别分析准则，可用于增强PCA。</p><h2 id="5ccf" class="ly kv iq bd kw lz ma dn la mb mc dp le jy md me li kc mf mg lm kg mh mi lq mj bi translated"><strong class="ak"> <em class="lx"> 4.2.7 .内核主成分分析:- </em> </strong></h2><p id="8e3a" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">Scholkopf等人介绍了使用核函数来执行非线性PCA。其基本方法是对输入应用非线性映射，然后在得到的特征子空间中求解线性PCA。</p><h2 id="5f1c" class="ly kv iq bd kw lz ma dn la mb mc dp le jy md me li kc mf mg lm kg mh mi lq mj bi translated"><strong class="ak"> <em class="lx"> 4.3 .神经网络:- </em> </strong></h2><p id="f446" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">神经网络继续使用模式识别和分类。Kohonen是第一个证明神经元网络可以用来识别对齐和标准化的面孔的人。存在使用神经网络执行特征提取的方法。有很多方法可以结合PCA或LCA等工具，组成混合分类器用于人脸识别。这些如具有附加偏差前馈神经网络、具有PCA的自组织映射和具有多层感知的卷积神经网络等。这些可以提高模型的效率。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/4298c101e3dbe1948c05326cfdb7684a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*2Eto0ejUXck1-BLrIaqUOQ.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Deep Neural Network for Face Recognition</figcaption></figure><h2 id="553a" class="ly kv iq bd kw lz ma dn la mb mc dp le jy md me li kc mf mg lm kg mh mi lq mj bi translated"><strong class="ak"> <em class="lx"> 4.3.1 .具有Gabor滤波器的神经网络:- </em> </strong></h2><p id="93a2" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">该算法通过使用反向传播算法实现多层感知器来实现人脸识别。首先，有一个预处理步骤。每幅图像在对比度和光照阶段进行标准化。然后，通过Gabor滤波器处理每幅图像。伽柏滤波器有五个方向参数和三个空间频率，因此有15个伽柏波长。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/ced1ac706488d07ada26c9713d50308d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*cBRgbcqWnVduq8eHQTvEbA.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Neural Networks with Gabor filters</figcaption></figure><h2 id="4c74" class="ly kv iq bd kw lz ma dn la mb mc dp le jy md me li kc mf mg lm kg mh mi lq mj bi translated"><strong class="ak"> <em class="lx"> 4.3.2 .神经网络和隐马尔可夫模型:- </em> </strong></h2><p id="c175" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">隐马尔可夫模型是一种用于人脸识别的统计工具。它们与神经网络一起使用。它在训练伪2D HMM的神经网络中生成。这个2D HMM过程的输入是ANN的输出，它为算法提供适当的维数缩减。</p><h2 id="4aaf" class="ly kv iq bd kw lz ma dn la mb mc dp le jy md me li kc mf mg lm kg mh mi lq mj bi translated"><strong class="ak"> <em class="lx"> 4.3.3 .模糊神经网络:- </em> </strong></h2><p id="9271" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">用于人脸识别的模糊神经网络于2009年推出。这是一个使用多层感知器的人脸识别系统。这种方法背后的概念是捕捉非线性流形中的决策面，这是一个简单的MLP很难完成的任务。使用Gabor波长变换获得特征向量。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/a6cfd2990f2866a6d41a8a7f983506bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*o7uzSZacdvzmcIx3p81MBQ.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Fuzzy Neural Network</figcaption></figure><h1 id="fe3e" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">人脸识别的工作原理</h1><p id="89eb" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">人脸识别有很多种方法。这里我们使用OpenCV进行人脸识别。在人脸识别中，首先对图像进行预处理，然后训练人脸识别器来识别人脸。教完识别器后，我们测试识别器看看结果。OpenCV人脸识别器有以下三种类型</p><h2 id="e585" class="ly kv iq bd kw lz ma dn la mb mc dp le jy md me li kc mf mg lm kg mh mi lq mj bi translated"><strong class="ak"> 1。特征脸人脸识别器</strong></h2><p id="b08d" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">EigenFaces人脸识别器将所有字符的所有训练图像视为一个复合体，并尝试推断其组成部分。这些成分是必要的和有帮助的(抓住最大变化/改变的部分),并丢弃图像的其余部分，这样它不仅从训练数据中提取必要的元素，而且通过拒绝不太重要的片段来节省存储器。</p><h2 id="8e50" class="ly kv iq bd kw lz ma dn la mb mc dp le jy md me li kc mf mg lm kg mh mi lq mj bi translated"><strong class="ak"> 2。鱼脸识别器</strong></h2><p id="9bac" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">Fisherfaces算法不是获得代表所有人的所有面部的有用特征，而是移除区分一个人和其他人的有价值的特征。一个人的这种特征并不支配其他人，你有区别一个人和其他人的特征。</p><h2 id="1e7d" class="ly kv iq bd kw lz ma dn la mb mc dp le jy md me li kc mf mg lm kg mh mi lq mj bi translated"><strong class="ak"> 3。局部二元模式直方图</strong></h2><p id="4a2a" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">我们知道本征脸和鱼脸都受光线影响，在现实生活中也是如此；我们不能保证完美的光线条件。LBPH人脸识别器是克服这一缺点的改进。这个想法不是找到图像的局部特征。LBPH算法试图找到图像的局部结构，它是通过将每个像素与其相邻像素进行比较来实现的。</p><h1 id="0732" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">如何运行人脸识别:-</h1><pre class="ml mm mn mo gt nf ng nh ni aw nj bi"><span id="e839" class="ly kv iq ng b gy nk nl l nm nn"><strong class="ng ir">#import OpenCV module</strong><br/>import cv2<br/>import os<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="72c3" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#function to detect face</strong><br/>def detect_face (img):</span><span id="cf0c" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#convert the test image to gray image</strong><br/>gray = cv2.cvtColor (img, cv2.COLOR_BGR2GRAY)</span><span id="3e56" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#load OpenCV face detector</strong><br/>face_cas = cv2.CascadeClassifier ('-File name.xml-')<br/>faces = face_cas.detectMultiScale (gray, scaleFactor=1.3, minNeighbors=4);</span><span id="15b1" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#if no faces are detected then return image</strong><br/>if (len (faces) == 0):<br/>return None, None</span><span id="bf27" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#extract the face</strong><br/>faces [0]=(x, y, w, h)</span><span id="5821" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#return only the face part</strong><br/>return gray[y: y+w, x: x+h], faces [0]</span><span id="3418" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#this function will read all persons' training images, detect face #from each image<br/>#and will return two lists of exactly same size, one list<br/></strong>def prepare_training_data(data_folder_path):</span><span id="1aa1" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#------STEP-1--------<br/>#get the directories (one directory for each subject) in data folder<br/></strong>dirs = os.listdir(data_folder_path)<br/>faces = []<br/>labels = []<br/>for dir_name in dirs:</span><span id="5559" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#our subject directories start with letter 's' so<br/>#ignore any non-relevant directories if any<br/></strong>if not dir_name.startswith("s"):<br/>continue;</span><span id="984d" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#------STEP-2--------<br/>#extract label number of subject from dir_name<br/>#format of dir name = slabel<br/>#, so removing letter 's' from dir_name will give us label<br/></strong>label = int(dir_name.replace("s", ""))</span><span id="5c0a" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#build path of directory containin images for current subject subject<br/>#sample subject_dir_path = "training-data/s1"<br/></strong>subject_dir_path = data_folder_path + "/" + dir_name</span><span id="eedb" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#get the images names that are inside the given subject directory<br/></strong>subject_images_names = os.listdir(subject_dir_path)</span><span id="8331" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#------STEP-3--------<br/>#go through each image name, read image,<br/>#detect face and add face to list of faces<br/></strong>for image_name in subject_images_names:</span><span id="e3c1" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#ignore system files like .DS_Store<br/></strong>if image_name.startswith("."):<br/>continue;</span><span id="50c6" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#build image path<br/>#sample image path = training-data/s1/1.pgm<br/></strong>image_path = subject_dir_path + "/" + image_name</span><span id="2ccf" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#read image<br/></strong>image = cv2.imread(image_path)</span><span id="cab9" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#display an image window to show the image<br/></strong>cv2.imshow("Training on image...", image)<br/>cv2.waitKey(100)</span><span id="bdfc" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#detect face<br/></strong>face, rect = detect_face(image)</span><span id="d8e9" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#------STEP-4--------<br/>#we will ignore faces that are not detected<br/></strong>if face is not None:</span><span id="5a71" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#add face to list of faces<br/></strong>faces.append(face)</span><span id="c4c1" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#add label for this face<br/></strong>labels.append(label)<br/>cv2.destroyAllWindows()<br/>cv2.waitKey(1)<br/>cv2.destroyAllWindows()<br/>return faces, labels</span><span id="40a4" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#let's first prepare our training data<br/>#data will be in two lists of same size<br/>#one list will contain all the faces<br/>#and other list will contain respective labels for each face<br/></strong>print("Preparing data...")<br/>faces, labels = prepare_training_data("training-data")<br/>print("Data prepared")</span><span id="32e6" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#print total faces and labels<br/></strong>print("Total faces: ", len(faces))<br/>print("Total labels: ", len(labels))</span><span id="ca9f" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#create our LBPH face recognizer<br/></strong>face_recognizer = cv2.face.createLBPHFaceRecognizer()</span><span id="1118" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#train our face recognizer of our training faces<br/></strong>face_recognizer.train(faces, np.array(labels))</span><span id="090e" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#function to draw rectangle on image<br/>#according to given (x, y) coordinates and<br/>#given width and heigh<br/></strong>def draw_rectangle(img, rect):<br/>(x, y, w, h) = rect<br/>cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)</span><span id="ecf4" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#function to draw text on give image starting from<br/>#passed (x, y) coordinates.<br/></strong>def draw_text(img, text, x, y):<br/>cv2.putText(img, text, (x, y), cv2.FONT_HERSHEY_PLAIN, 1.5, (0, 255, 0), 2)</span><span id="eb8c" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#this function recognizes the person in image passed<br/>#and draws a rectangle around detected face with name of the subject<br/></strong>def predict(test_img):</span><span id="c507" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#make a copy of the image as we don't want to chang original image<br/></strong>img = test_img.copy()</span><span id="adb0" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#detect face from the image<br/></strong>face, rect = detect_face(img)</span><span id="4823" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#predict the image using our face recognizer<br/></strong>label= face_recognizer.predict(face)</span><span id="f8b3" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#get name of respective label returned by face recognizer<br/></strong>label_text = subjects[label]</span><span id="0b91" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#draw a rectangle around face detected<br/></strong>draw_rectangle(img, rect)</span><span id="333e" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#draw name of predicted person<br/></strong>draw_text(img, label_text, rect[0], rect[1]-5)<br/>return img</span><span id="339b" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#load test images<br/></strong>test_img1 = cv2.imread("test-data/test1.jpg")<br/>test_img2 = cv2.imread("test-data/test2.jpg")</span><span id="3b6c" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#perform a prediction<br/></strong>predicted_img1 = predict(test_img1)<br/>predicted_img2 = predict(test_img2)<br/>print("Prediction complete")</span><span id="d1a0" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#create a figure of 2 plots (one for each test image)<br/></strong>f, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))</span><span id="a822" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#display test image1 result<br/></strong>ax1.imshow(cv2.cvtColor(predicted_img1, cv2.COLOR_BGR2RGB))</span><span id="a1ce" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#display test image2 result<br/></strong>ax2.imshow(cv2.cvtColor(predicted_img2, cv2.COLOR_BGR2RGB))</span><span id="efeb" class="ly kv iq ng b gy no nl l nm nn"><strong class="ng ir">#display both images<br/></strong>cv2.imshow("Tom cruise test", predicted_img1)<br/>cv2.imshow("Shahrukh Khan test", predicted_img2)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()<br/>cv2.waitKey(1)<br/>cv2.destroyAllWindows()</span></pre><blockquote class="np nq nr"><p id="0995" class="jn jo ns jp b jq jr js jt ju jv jw jx nt jz ka kb nu kd ke kf nv kh ki kj kk ij bi translated">这个博客是为那些想通过学习什么是人脸识别，它的类型以及它是如何工作的来开始他们在计算机视觉或人工智能领域的载体的初学者而写的。</p></blockquote></div></div>    
</body>
</html>