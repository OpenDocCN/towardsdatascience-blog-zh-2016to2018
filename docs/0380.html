<html>
<head>
<title>How I used machine learning to classify emails and turn them into insights (part 1).</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何使用机器学习对电子邮件进行分类，并将其转化为见解(第1部分)。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-i-used-machine-learning-to-classify-emails-and-turn-them-into-insights-efed37c1e66?source=collection_archive---------0-----------------------#2017-04-25">https://towardsdatascience.com/how-i-used-machine-learning-to-classify-emails-and-turn-them-into-insights-efed37c1e66?source=collection_archive---------0-----------------------#2017-04-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="aa44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天，我想知道如果我抓起一堆没有标签的电子邮件，把它们放在一个黑盒子里，然后让一台机器来处理它们，会发生什么。知道会发生什么吗？我没有。</p><p id="261d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我做的第一件事是寻找一个包含各种电子邮件的数据集。在查看了几个数据集之后，我想出了安然语料库。这个数据集有超过500，000封电子邮件是由安然公司的员工生成的，如果你问我的话，这足够了。</p><p id="62c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为编程语言，我使用了Python及其强大的库:scikit-learn、pandas、numpy和matplotlib。</p><h1 id="4bbd" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">无监督机器学习</h1><p id="30af" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">为了对未标记的邮件进行聚类，我使用了<strong class="jp ir">无监督机器学习。</strong>什么，怎么？是的，无监督的，因为我的训练数据只有输入，也称为特征，不包含结果。在有监督的机器学习中，我们处理输入及其已知的结果。在这种情况下，我想根据邮件正文对邮件进行分类，这绝对是一项无人监管的机器学习任务。</p><h1 id="ae8b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">载入数据</h1><p id="db89" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我没有加载所有+500k的电子邮件，而是将数据集分成几个文件，每个文件包含10k的电子邮件。相信我，你不会想在内存中加载完整的安然数据集并用它进行复杂的计算。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="d9cc" class="ly kn iq lu b gy lz ma l mb mc">import pandas as pd</span><span id="8169" class="ly kn iq lu b gy md ma l mb mc">emails = pd.read_csv('split_emails_1.csv')<br/>print emails.shape # (10000, 3)</span></pre><p id="11c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我的数据集中有10k封电子邮件，分为3列(索引、message_id和原始邮件)。在处理这些数据之前，我将原始消息解析成键值对。</p><p id="2a7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个原始电子邮件的例子。</p><blockquote class="me mf mg"><p id="8f39" class="jn jo mh jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated"><em class="iq">消息-id:❤0965995.1075863688265.javamail.evans@thyme&gt;<br/>日期:2000年8月31日星期四04:17:00 -0700 (PDT) <br/>发件人:</em><a class="ae kl" href="mailto:phillip.allen@enron.com" rel="noopener ugc nofollow" target="_blank"><em class="iq">phillip.allen@enron.com</em></a><em class="iq"><br/>收件人:</em><a class="ae kl" href="mailto:greg.piper@enron.com" rel="noopener ugc nofollow" target="_blank"><em class="iq">greg.piper@enron.com</em></a><em class="iq"><br/>主题:回复:你好<br/>mime-版本:1.0 <br/>内容-类型:文本/普通；charset = us-ascii<br/>Content-Transfer-Encoding:7 bit<br/>X-From:Phillip K Allen<br/>X-To:Greg Piper<br/>X-cc:<br/>X-bcc:<br/>X-Folder:\ Phillip _ Allen _ de c2000 \ Notes Folders \ ' sent mail<br/>X-Origin:Allen-P<br/>X-FileName:pallen . NSF</em></p><p id="5e55" class="jn jo mh jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated"><em class="iq">格雷格，</em></p><p id="3f76" class="jn jo mh jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated">下周二或周四怎么样？</p><p id="13ef" class="jn jo mh jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated">菲利普</p></blockquote><p id="a72d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了只处理发件人、收件人和邮件正文数据，我创建了一个函数，将这些数据提取到键值对中。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="caa4" class="ly kn iq lu b gy lz ma l mb mc">def parse_raw_message(raw_message):<br/>    lines = raw_message.split('\n')<br/>    email = {}<br/>    message = ''<br/>    keys_to_extract = ['from', 'to']<br/>    for line in lines:<br/>        if ':' not in line:<br/>            message += line.strip()<br/>            email['body'] = message<br/>        else:<br/>            pairs = line.split(':')<br/>            key = pairs[0].lower()<br/>            val = pairs[1].strip()<br/>            if key in keys_to_extract:<br/>                email[key] = val<br/>    return email</span><span id="6e17" class="ly kn iq lu b gy md ma l mb mc">def parse_into_emails(messages):<br/>    emails = [parse_raw_message(message) for message in messages]<br/>    return {<br/>        'body': map_to_list(emails, 'body'), <br/>        'to': map_to_list(emails, 'to'), <br/>        'from_': map_to_list(emails, 'from')<br/>    }</span></pre><p id="ecc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行该函数后，我创建了一个新的数据帧，如下所示:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="fff3" class="ly kn iq lu b gy lz ma l mb mc">email_df = pd.DataFrame(parse_into_emails(emails.message))</span><span id="6b2d" class="ly kn iq lu b gy md ma l mb mc">index   body           from_             to<br/>0       After some...  <a class="ae kl" href="mailto:phillip.allen@enron.com" rel="noopener ugc nofollow" target="_blank">phillip.allen@</a>..  <a class="ae kl" href="mailto:tim.belden@enron.com" rel="noopener ugc nofollow" target="_blank">tim.belden@</a>..</span></pre><p id="6f58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要100%确定没有空列:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="b881" class="ly kn iq lu b gy lz ma l mb mc">mail_df.drop(email_df.query(<br/>    "body == '' | to == '' | from_ == ''"<br/>).index, inplace=True)</span></pre><h1 id="d41a" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用TF-IDF分析文本</h1><p id="b889" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">是<strong class="jp ir">术语</strong> <strong class="jp ir"> <em class="mh">频率的简称——逆文档频率</em> </strong>和<strong class="jp ir"> <em class="mh"> </em> </strong>是一种数字统计，旨在反映一个词对集合或语料库中的文档有多重要。我需要给机器输入一些它能理解的东西，机器不擅长处理文本，但它们会处理数字。这就是为什么我把邮件正文转换成一个文档术语矩阵:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="fcfe" class="ly kn iq lu b gy lz ma l mb mc">vect = TfidfVectorizer(stop_words='english', max_df=0.50, min_df=2)<br/>X = vect.fit_transform(email_df.body)</span></pre><p id="e8b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我做了一个快速的图表来显示这个矩阵。为此，我首先需要制作一个DTM的2d表示(文档术语矩阵)。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="3aca" class="ly kn iq lu b gy lz ma l mb mc">X_dense = X.todense()<br/>coords = PCA(n_components=2).fit_transform(X_dense)</span><span id="4026" class="ly kn iq lu b gy md ma l mb mc">plt.scatter(coords[:, 0], coords[:, 1], c='m')<br/>plt.show()</span></pre><figure class="lp lq lr ls gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ml"><img src="../Images/39bd387188cc5b18c67d90a7433106d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*45EzzhI26h5nH1WfxVU0wQ.png"/></div></div></figure><p id="0a14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">做完这些后，我想找出那些邮件中最热门的关键词是什么。我创建这个函数的目的就是:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="1c22" class="ly kn iq lu b gy lz ma l mb mc">def top_tfidf_feats(row, features, top_n=20):<br/>    topn_ids = np.argsort(row)[::-1][:top_n]<br/>    top_feats = [(features[i], row[i]) for i in topn_ids]<br/>    df = pd.DataFrame(top_feats, columns=['features', 'score'])<br/>    return df</span><span id="eb16" class="ly kn iq lu b gy md ma l mb mc">def top_feats_in_doc(X, features, row_id, top_n=25):<br/>    row = np.squeeze(X[row_id].toarray())<br/>    return top_tfidf_feats(row, features, top_n)</span></pre><p id="2bfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在对一个文档运行这个函数之后，它得到了下面的结果。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="81e8" class="ly kn iq lu b gy lz ma l mb mc">features = vect.get_feature_names()<br/>print top_feats_in_doc(X, features, 1, 10)</span><span id="3a06" class="ly kn iq lu b gy md ma l mb mc"> features     score<br/>0     meetings  0.383128<br/>1         trip  0.324351<br/>2          ski  0.280451<br/>3     business  0.276205<br/>4        takes  0.204126<br/>5          try  0.161225<br/>6    presenter  0.158455<br/>7    stimulate  0.155878<br/>8        quiet  0.148051<br/>9       speaks  0.148051<br/>10  productive  0.145076<br/>11      honest  0.140225<br/>12      flying  0.139182<br/>13     desired  0.133885<br/>14        boat  0.130366<br/>15        golf  0.126318<br/>16   traveling  0.125302<br/>17         jet  0.124813<br/>18  suggestion  0.124336<br/>19     holding  0.120896<br/>20    opinions  0.116045<br/>21     prepare  0.112680<br/>22     suggest  0.111434<br/>23       round  0.108736<br/>24      formal  0.106745</span></pre><p id="fa69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你查看相应的电子邮件，这一切都说得通。</p><blockquote class="me mf mg"><p id="76f6" class="jn jo mh jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated">出差去参加商务会议会让旅行变得无趣。尤其是如果你要准备一个演示的话。我建议在这里举行<strong class="jp ir">商务</strong>计划<strong class="jp ir">会议</strong>然后进行<strong class="jp ir">旅行</strong>没有任何正式的商务<strong class="jp ir">会议</strong>。我甚至会试着获得一些诚实的意见，看看是否需要或有必要进行一次旅行。就商业会议而言，我认为在不同的小组中尝试和激发讨论什么是可行的，什么是不可行的会更有成效。主持人发言，其他人安静地等着轮到自己，这种情况太常见了。如果以圆桌讨论的形式举行，会议可能会更好。我建议去奥斯汀。打高尔夫球，租一艘滑雪船和水上摩托。飞到某个地方太花时间了。</p></blockquote><p id="a213" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是编写一个函数来获取所有电子邮件中的热门词汇。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="bfb5" class="ly kn iq lu b gy lz ma l mb mc">def top_mean_feats(X, features,<br/> grp_ids=None, min_tfidf=0.1, top_n=25):<br/>    if grp_ids:<br/>        D = X[grp_ids].toarray()<br/>    else:<br/>        D = X.toarray()</span><span id="3d7f" class="ly kn iq lu b gy md ma l mb mc">D[D &lt; min_tfidf] = 0<br/>    tfidf_means = np.mean(D, axis=0)<br/>    return top_tfidf_feats(tfidf_means, features, top_n)</span></pre><p id="8b7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">返回所有电子邮件中的热门词汇。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="90d8" class="ly kn iq lu b gy lz ma l mb mc">print top_mean_feats(X, features, top_n=10)</span><span id="bcd0" class="ly kn iq lu b gy md ma l mb mc"> features     score<br/>0     enron  0.044036<br/>1       com  0.033229<br/>2       ect  0.027058<br/>3       hou  0.017350<br/>4   message  0.016722<br/>5  original  0.014824<br/>6   phillip  0.012118<br/>7     image  0.009894<br/>8       gas  0.009022<br/>9      john  0.008551</span></pre><p id="0b41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，我得到的很有趣，但我想看到更多，并找出机器还能从这组数据中学习到什么。</p><h1 id="126e" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用k均值聚类</h1><p id="1f50" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">KMeans是机器学习中使用的一种流行的聚类算法，其中K代表聚类的数量。我创建了一个具有3个聚类和100次迭代的KMeans分类器。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="56d4" class="ly kn iq lu b gy lz ma l mb mc">n_clusters = 3<br/>clf = KMeans(n_clusters=n_clusters, max_iter=100, init='k-means++', n_init=1)<br/>labels = clf.fit_predict(X)</span></pre><p id="05af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在训练分类器之后，它出现了以下3个集群。</p><figure class="lp lq lr ls gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mt"><img src="../Images/72d2cabad18954beecffc97b58c4d6f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*inrQ950SGea9A2jRU8OfeA.png"/></div></div></figure><p id="d57f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我现在知道了机器将哪些电子邮件分配给了每个聚类，所以我能够编写一个函数来提取每个聚类的最高术语。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="51b5" class="ly kn iq lu b gy lz ma l mb mc">def top_feats_per_cluster(X, y, features, min_tfidf=0.1, top_n=25):<br/>    dfs = []</span><span id="1181" class="ly kn iq lu b gy md ma l mb mc">    labels = np.unique(y)<br/>    for label in labels:<br/>        ids = np.where(y==label) <br/>        feats_df = top_mean_feats(X, features, ids,    min_tfidf=min_tfidf, top_n=top_n)<br/>        feats_df.label = label<br/>        dfs.append(feats_df)<br/>    return dfs</span></pre><p id="0b2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我没有打印出这些术语，而是找到了一个关于如何用matlibplot绘制这个图形的很好的例子。所以我复制了函数，做了一些调整，想出了这个情节:</p><figure class="lp lq lr ls gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mu"><img src="../Images/4bb1fbf8740f1c6cc52e4912e7f13350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qx5M-yZpIzmYX_0huE4M1w.png"/></div></div></figure><p id="79eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我立刻注意到<strong class="jp ir">集群1 </strong>，有奇怪的术语，如“后”和“等”。为了获得更多关于为什么像“后”和“等”这样的术语如此受欢迎的见解，我基本上需要获得整个数据集的更多见解，这意味着一种不同的方法..</p><p id="9c8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要知道我是如何想出这种不同的方法以及我是如何发现新的有趣见解的，可以在<a class="ae kl" href="https://medium.com/@anthonydm/how-i-used-machine-learning-to-classify-emails-and-turn-them-into-insights-part-2-6a8f26477c86" rel="noopener"> <strong class="jp ir">第二部分</strong> </a> <strong class="jp ir">中阅读。</strong></p><p id="64e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/anthdm/ml-email-clustering" rel="noopener ugc nofollow" target="_blank">Github上提供的代码</a></p></div></div>    
</body>
</html>