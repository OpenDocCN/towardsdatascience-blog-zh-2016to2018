<html>
<head>
<title>Serving TensorFlow model in Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala中的服务张量流模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/serving-tensorflow-model-in-scala-6caeadbb2d55?source=collection_archive---------0-----------------------#2017-11-01">https://towardsdatascience.com/serving-tensorflow-model-in-scala-6caeadbb2d55?source=collection_archive---------0-----------------------#2017-11-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/51c4e3892d72968f2a0e32b7ee8a7c8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*oMiycW_q7XlXfxFQrABN9A.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk">Taken from <a class="ae kb" href="http://blog.kubernetes.io/2016/03/scaling-neural-network-image-classification-using-Kubernetes-with-TensorFlow-Serving.html" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><figure class="kd ke kf kg gt ju gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/60b64c7c64889cc2d73213f663bc611f.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/1*49Ren7rr6rdt6orqBB9ErQ.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk">Taken from <a class="ae kb" href="https://eng.trueaccord.com/2014/02/24/why-we-chose-scala/" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><h2 id="3c7d" class="kh ki it bd kj kk kl dn km kn ko dp kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">问题</h2><p id="4327" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln kq lo lp lq ku lr ls lt ky lu lv lw lx im bi translated">训练机器学习模型的过程只是将其投入生产的第一步。在一天结束时，数据科学团队签署模型，数据工程团队必须找出如何在生产环境中部署、使用、更新和维护模型。关于如何做到这一点，有两种可能的方法:</p><ul class=""><li id="a944" class="ly lz it lf b lg ma lk mb kq mc ku md ky me lx mf mg mh mi bi translated">通过RPC/REST API公开一个模型。在这种情况下，优势在于用于构建模型的语言/基础设施也可以用于服务RPC/REST API。缺点是对模型的每个请求都是单独的RPC或HTTP调用，有自己的延迟。延迟对查询模型所用的平均时间设置了上限。</li><li id="73b0" class="ly lz it lf b lg mj lk mk kq ml ku mm ky mn lx mf mg mh mi bi translated">在生产环境中已经可用的数据工程管道中直接使用该模型。在这种情况下，不存在额外延迟的问题，但是，最好的数据处理引擎/框架似乎不支持用于模型训练的同一组语言。例如，典型的场景是当数据科学团队使用Python/TensorFlow构建模型时，数据工程团队必须将其集成到Spark/Scala/Java堆栈中。</li></ul><p id="0098" class="pw-post-body-paragraph ld le it lf b lg ma li lj lk mb lm ln kq mo lp lq ku mp ls lt ky mq lv lw lx im bi translated">我将关注第二个选项，并描述如何在Scala中使用预先训练好的TensorFlow模型构建一个库。TensorFlow已经提供了<a class="ae kb" href="https://www.tensorflow.org/api_docs/java/reference/org/tensorflow/package-summary" rel="noopener ugc nofollow" target="_blank"> Java API </a>，可以在Scala中直接引用和使用，但是非常低级和繁琐。</p><blockquote class="mr ms mt"><p id="f490" class="ld le mu lf b lg ma li lj lk mb lm ln mv mo lp lq mw mp ls lt mx mq lv lw lx im bi translated">在<a class="ae kb" href="https://github.com/stormy-ua/tfModelServing4s" rel="noopener ugc nofollow" target="_blank">tfmodelserving 4s GitHub repo</a>中可以找到包含这里描述的示例的结果库。</p></blockquote><h2 id="11c6" class="kh ki it bd kj kk kl dn km kn ko dp kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">API代数</h2><p id="a9ea" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln kq lo lp lq ku lr ls lt ky lu lv lw lx im bi translated">无标签的最终方法是用来建立图书馆。更多细节可以在<a class="ae kb" href="https://blog.scalac.io/exploring-tagless-final.html" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae kb" href="https://pchiusano.github.io/2014-05-20/scala-gadts.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。这个想法是创建一个代数，它抽象了一个具体实现/解释器中使用的效果和类型。这个特征定义了API公开的一组操作:</p><figure class="kd ke kf kg gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="a0d7" class="pw-post-body-paragraph ld le it lf b lg ma li lj lk mb lm ln kq mo lp lq ku mp ls lt ky mq lv lw lx im bi translated">F[_]是高级类型，表示具体实现使用的效果。这可能是未来的Scalaz任务，甚至是简单的尝试。trait还定义了两种类型TModel和TTensor。前者是一个模型类型，表示一个加载到内存中的模型，后者是一个张量类型。两种类型都必须由解释器来定义。此外，trait定义了使用模型的几个基本操作:</p><ul class=""><li id="1809" class="ly lz it lf b lg ma lk mb kq mc ku md ky me lx mf mg mh mi bi translated">load用于从某个源(例如，从文件系统)加载模型。模型源是定义模型源的联产品类型:</li></ul><figure class="kd ke kf kg gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><ul class=""><li id="3220" class="ly lz it lf b lg ma lk mb kq mc ku md ky me lx mf mg mh mi bi translated">元数据从加载的模型中查询模型元数据。它返回ModelMetadata，依次枚举此图可用的签名列表。签名的概念是从TensorFlow借用的，它定义了一个由模型公开的函数。例如，预测模型可能会公开由其输入和输出张量定义的签名。当给定一个输入张量时，该函数产生一个输出张量，该输出张量根据输入属于特定类别的概率。如果一个图支持多个任务，它可能会公开多个签名。以下是ModelMetadata、SignatureMetadata和TensorMetadata事例类的定义:</li></ul><figure class="kd ke kf kg gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><ul class=""><li id="adda" class="ly lz it lf b lg ma lk mb kq mc ku md ky me lx mf mg mh mi bi translated">张量函数从兼容的数据结构(如数组或列表)创建一个张量对象。如果为数据结构定义了隐式TensorEncoder类型类，则该数据结构是兼容的:</li></ul><figure class="kd ke kf kg gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="13d4" class="pw-post-body-paragraph ld le it lf b lg ma li lj lk mb lm ln kq mo lp lq ku mp ls lt ky mq lv lw lx im bi translated">以下是TensorEncoder将二维数组转换为TensorFlow API张量对象的示例:</p><figure class="kd ke kf kg gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><ul class=""><li id="1e62" class="ly lz it lf b lg ma lk mb kq mc ku md ky me lx mf mg mh mi bi translated">eval是实际执行图形计算的函数。它需要一个模型对象、一个输出元数据和一个映射，输入张量元数据作为键，输入张量本身作为值。它返回包装成效果F[_]的结果张量对象。该函数还需要TensorDecoder和Tensor type的Closeable类型类。TensorDecoder将一个张量对象转换成数组、列表等数据结构形式的表示。：</li></ul><figure class="kd ke kf kg gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="d58f" class="pw-post-body-paragraph ld le it lf b lg ma li lj lk mb lm ln kq mo lp lq ku mp ls lt ky mq lv lw lx im bi translated">需要可关闭的类型类来释放非托管对象。例如，TensorFlow API对非托管对象tensors进行操作，当不再需要它们时，必须显式关闭它们，否则，它们将留在内存中，这可能会导致应用程序中的内存泄漏:</p><figure class="kd ke kf kg gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="4727" class="pw-post-body-paragraph ld le it lf b lg ma li lj lk mb lm ln kq mo lp lq ku mp ls lt ky mq lv lw lx im bi translated">就是这样。API已定义。下一步是为TensorFlow实现一个“解释器”。</p><h2 id="3776" class="kh ki it bd kj kk kl dn km kn ko dp kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">张量流解释程序</h2><p id="5d49" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln kq lo lp lq ku lr ls lt ky lu lv lw lx im bi translated">TensorFlow的解释器必须实现模型服务特性。我选择了<a class="ae kb" href="http://www.scala-lang.org/api/2.9.3/scala/util/Try.html" rel="noopener ugc nofollow" target="_blank"> scala.util.Try </a>作为一个效果，这样所有的API函数都将返回打包到Try中的结果，并且为了便于理解，可以使用scala来编写API操作。下面是解释器的实现。它完成了与TensorFlow Java API交互的所有脏活:</p><figure class="kd ke kf kg gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="8912" class="pw-post-body-paragraph ld le it lf b lg ma li lj lk mb lm ln kq mo lp lq ku mp ls lt ky mq lv lw lx im bi translated">此外，我们必须定义TensorEncoder、TensorDecoder和Closeable类型类:</p><figure class="kd ke kf kg gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="5724" class="pw-post-body-paragraph ld le it lf b lg ma li lj lk mb lm ln kq mo lp lq ku mp ls lt ky mq lv lw lx im bi translated">只有一个字符串、一维和二维数组才有编码器和解码器。这是我执行几个示例并查看它是否有效所需的基本最小值。这可以扩展到任何其他兼容的数据类型。</p><h2 id="217e" class="kh ki it bd kj kk kl dn km kn ko dp kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">使用示例#1</h2><p id="259f" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln kq lo lp lq ku lr ls lt ky lu lv lw lx im bi translated">是时候用一个简单的例子来试试这个库了。首先，必须准备一个TensorFlow保存模型。对于这个例子，我使用了一个计算图，它简单地将一个矩阵乘以单位矩阵。根据单位矩阵的性质，输出矩阵应该等于输入矩阵。以下是构建图表并将其保存为TensorFlow SavedModel格式的Python代码:</p><figure class="kd ke kf kg gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="e60f" class="pw-post-body-paragraph ld le it lf b lg ma li lj lk mb lm ln kq mo lp lq ku mp ls lt ky mq lv lw lx im bi translated">它用单输入(' x ')和单输出(' y ')定义签名。生成的模型目录包含序列化图形以及变量快照:</p><figure class="kd ke kf kg gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="e3ff" class="pw-post-body-paragraph ld le it lf b lg ma li lj lk mb lm ln kq mo lp lq ku mp ls lt ky mq lv lw lx im bi translated">Scala代码将输入矩阵输入到模型中并获得结果矩阵:</p><figure class="kd ke kf kg gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="92b9" class="pw-post-body-paragraph ld le it lf b lg ma li lj lk mb lm ln kq mo lp lq ku mp ls lt ky mq lv lw lx im bi translated">下面是上面的应用程序产生的输出:</p><figure class="kd ke kf kg gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="acb4" class="kh ki it bd kj kk kl dn km kn ko dp kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">使用示例#2</h2><p id="2474" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln kq lo lp lq ku lr ls lt ky lu lv lw lx im bi translated">第二个使用示例基于我在这里描述的如何构建<a class="ae kb" href="https://medium.com/towards-data-science/dog-breed-classification-hands-on-approach-b5e4f88c333e" rel="noopener">的狗品种分类模型</a>。它拍摄了一张狗的图像，并产生了前5个品种的概率:</p><figure class="kd ke kf kg gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="c41b" class="pw-post-body-paragraph ld le it lf b lg ma li lj lk mb lm ln kq mo lp lq ku mp ls lt ky mq lv lw lx im bi translated">为样本狗图像生成的输出:</p><figure class="kd ke kf kg gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="766d" class="kh ki it bd kj kk kl dn km kn ko dp kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">结论</h2><p id="c869" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln kq lo lp lq ku lr ls lt ky lu lv lw lx im bi translated">构建了一个合理的Scala库来处理TensorFlow模型。它可以用于在任何Scala/Java应用程序(例如Apache Spark)中使用预训练的张量流模型来执行分类、预测等。</p></div></div>    
</body>
</html>