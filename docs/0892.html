<html>
<head>
<title>Making a Handwritten Digit Recogniser program using nearest neighbour classifier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用最近邻分类器制作手写数字识别程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/making-a-handwritten-digit-recogniser-program-using-nearest-neighbour-classifier-d33e76aa17b6?source=collection_archive---------2-----------------------#2017-07-06">https://towardsdatascience.com/making-a-handwritten-digit-recogniser-program-using-nearest-neighbour-classifier-d33e76aa17b6?source=collection_archive---------2-----------------------#2017-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/89b7744965670e1f69fd70a24135c475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UN4Dq1T3-PnJfkAaK8o5TQ.png"/></div></div></figure><div class=""/><p id="216d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近邻分类器是机器学习中最基本的算法之一。本教程描述了一个非常基本的方法，使一个数字识别程序。这里我们不会使用任何 python 机器学习库。所以让我们开始吧</p><h1 id="ed85" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">导入所需的库</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="27fd" class="md kx jb lz b gy me mf l mg mh">from sklearn import datasets<br/>import matplotlib.pyplot as plt<br/>import numpy as np</span></pre><p id="f7c3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">sklearn 的数字数据将用于本教程。</p><h1 id="9845" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">加载数据集</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="3fd7" class="md kx jb lz b gy me mf l mg mh">digits = datasets.load_digits()</span></pre><h1 id="a8a9" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">将数据可视化</h1><p id="7441" class="pw-post-body-paragraph jy jz jb ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated"><code class="fe mn mo mp lz b">digits.data</code>包含线性阵列中的图像(本例中为 64 x 1 ),而<code class="fe mn mo mp lz b">digits.images</code>将它们存储在 8 x 8 阵列中。让我们展示一个数字</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="a5cd" class="md kx jb lz b gy me mf l mg mh">fig = plt.figure()<br/>plt.imshow(digits.images[23],cmap = plt.cm.gray_r)<br/>txt = "This is %d"%digits.target[23]<br/>fig.text(0.1,0.1,txt)<br/>plt.show()</span></pre><p id="c62f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将给我们展示索引 23 处的图像</p><figure class="lu lv lw lx gt is gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/e2565670263a98733be103c172bb2039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*GbRwW5IQ5adWrOx9-VUSoQ.png"/></div></figure><p id="5338" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看看这个图像作为一个数组是什么样子的。</p><p id="7edd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mn mo mp lz b">digits.images[23]</code></p><p id="8d18" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将给出如下输出</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="8f02" class="md kx jb lz b gy me mf l mg mh">array([[  0.,   1.,   8.,  12.,  15.,  14.,   4.,   0.],<br/>       [  0.,   3.,  11.,   8.,   8.,  12.,  12.,   0.],<br/>       [  0.,   0.,   0.,   0.,   2.,  13.,   7.,   0.],<br/>       [  0.,   0.,   0.,   2.,  15.,  12.,   1.,   0.],<br/>       [  0.,   0.,   0.,   0.,  13.,   5.,   0.,   0.],<br/>       [  0.,   0.,   0.,   0.,   9.,  13.,   0.,   0.],<br/>       [  0.,   0.,   7.,   8.,  14.,  15.,   0.,   0.],<br/>       [  0.,   0.,  14.,  15.,  11.,   2.,   0.,   0.]])</span></pre><p id="dd4f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像素越暗，数字越大。如果您将光标移动到阵列上更大的数字上，您可以看到它正在生成一个<strong class="ka jc"> 3。</strong></p><figure class="lu lv lw lx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mr"><img src="../Images/04924750d1364dafbea309ddef6b1d08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*vV-15-pGqBklfkw3Uvp_lw.png"/></div></div></figure><h1 id="b310" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">训练和测试数据集</h1><p id="91cc" class="pw-post-body-paragraph jy jz jb ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">我们将选择前 100 幅图像作为我们的训练数据集。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="0c3d" class="md kx jb lz b gy me mf l mg mh">x = 100 #length of training data set</span><span id="489c" class="md kx jb lz b gy ms mf l mg mh">X_train = digits.data[0:x]<br/>Y_train = digits.target[0:x]</span></pre><p id="9037" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试数据集</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="c4d5" class="md kx jb lz b gy me mf l mg mh">pred = 813<br/>X_test = digits.data[pred]<br/>print "X_test's real value is %d"%digits.target[pred]</span></pre><p id="30cc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的程序，我们将找到测试图像与每个训练图像的<em class="mt">距离</em>，距离最小的图像就是预测值。我说的距离是 64 维中的欧几里德距离。要计算欧几里得距离，我们只需找到每个索引的数字之间的差异，对它们求平方，将它们相加，然后求平方根。所以，让我们定义<code class="fe mn mo mp lz b">dist</code>函数。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="bcea" class="md kx jb lz b gy me mf l mg mh">def dist(x,y):<br/> return np.sqrt(np.sum((x-y)**2))</span></pre><p id="5573" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只要 x 和 y 有相同的维数，这个函数对任何维数的数组都有效。(我爱 python 的原因之一:P)。</p><p id="8c28" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们使用<code class="fe mn mo mp lz b">dist</code>函数来预测测试数据。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="ec66" class="md kx jb lz b gy me mf l mg mh">l = len(X_train)<br/>distance = np.zeros(l) <br/>for i in range(l):<br/> distance[i] = dist(X_train[i],X_test)<br/>min_index = np.argmin(distance)<br/>print "Preditcted value is ",<br/>print(Y_train[min_index])</span></pre><p id="0ae8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将打印预测值，在本例中为 9。</p><h1 id="1ba8" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">我们模型的准确性</h1><p id="f723" class="pw-post-body-paragraph jy jz jb ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">现在，让我们看看我们的模型预测得有多好。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="55dd" class="md kx jb lz b gy me mf l mg mh">l = len(X_train)<br/>no_err = 0<br/>distance = np.zeros(l)<br/>for j in range(1697,1797):<br/> X_test = digits.data[j]<br/> for i in range(l):<br/>  distance[i] = dist(X_train[i],X_test)<br/> min_index = np.argmin(distance)<br/> if Y_train[min_index] != digits.target[j]:<br/>  no_err+=1<br/>print "Total errors for train length = %d is %d"%(x,no_err)</span></pre><p id="d663" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的测试数据集有 100 个例子。在 for 循环中，它预测 j 索引处的图像数，并将其与实际值进行比较，然后打印错误总数。当<code class="fe mn mo mp lz b">x = 100</code> <strong class="ka jc"> 14/100 </strong>值预测错误，且<code class="fe mn mo mp lz b">x = 1696</code> <strong class="ka jc"> 2/100 </strong>值预测错误时。所以我们的模型预测图像有 98%的准确率。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="b9ca" class="kw kx jb bd ky kz nb lb lc ld nc lf lg lh nd lj lk ll ne ln lo lp nf lr ls lt bi translated">预测自定义输入(如果您想向某人展示:P)</h1><p id="22ce" class="pw-post-body-paragraph jy jz jb ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">这是本教程的第 2 部分，我们将对自定义输入进行预测。您可以使用任何图像编辑器，这里我们将使用<strong class="ka jc"> G.I.M.P. </strong></p><p id="85bf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">遵循以下步骤</p><ol class=""><li id="b7a4" class="ng nh jb ka b kb kc kf kg kj ni kn nj kr nk kv nl nm nn no bi translated">打开 GIMP</li><li id="18b1" class="ng nh jb ka b kb np kf nq kj nr kn ns kr nt kv nl nm nn no bi translated">Ctrl + N</li><li id="5ded" class="ng nh jb ka b kb np kf nq kj nr kn ns kr nt kv nl nm nn no bi translated">在下一个窗口中，将高度和宽度都设为 8。由于工作表非常小，您可能需要放大</li><li id="5b9a" class="ng nh jb ka b kb np kf nq kj nr kn ns kr nt kv nl nm nn no bi translated">现在滚动。如果指针的大小正在改变，则进入下一步，否则按照<a class="ae nu" href="https://docs.gimp.org/en/gimp-using-variable-size-brush.html" rel="noopener ugc nofollow" target="_blank">这个</a>来改变指针的大小。</li><li id="8b71" class="ng nh jb ka b kb np kf nq kj nr kn ns kr nt kv nl nm nn no bi translated">将指针的大小减小到最小。</li><li id="54c7" class="ng nh jb ka b kb np kf nq kj nr kn ns kr nt kv nl nm nn no bi translated">转到工具→绘画工具→画笔或按<strong class="ka jc"> P. </strong></li><li id="c67b" class="ng nh jb ka b kb np kf nq kj nr kn ns kr nt kv nl nm nn no bi translated">告诉那个人在文件里画一个数字。</li><li id="aeef" class="ng nh jb ka b kb np kf nq kj nr kn ns kr nt kv nl nm nn no bi translated">进入文件→导出并保存你的图像为 test.png。</li></ol><figure class="lu lv lw lx gt is gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/276e00f55129311802a0f2a90034b77e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*Xj-tvdaQcJblOh2MRn7CXQ.png"/></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk">This is test.png</figcaption></figure><p id="6146" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">访问图像 test.png 的 Python 代码</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="1963" class="md kx jb lz b gy me mf l mg mh">from scipy import misc<br/>image = misc.imread("/path_to_test.png/test.png",flatten = 1)</span></pre><p id="8a0a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果你打印<code class="fe mn mo mp lz b">digits.images[0]</code>，你会看到白色像素相当于<code class="fe mn mo mp lz b">0</code>，值越大，像素越暗，但是如果你打印标准形式的<code class="fe mn mo mp lz b">image</code>，<code class="fe mn mo mp lz b">255</code>代表白色，<code class="fe mn mo mp lz b">0</code>代表全黑。因此，我们必须转换它，使白色对应于<code class="fe mn mo mp lz b">0</code>，然后我们将重塑图像从 8 x 8 到 64 x 1</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="9a82" class="md kx jb lz b gy me mf l mg mh">image1 = 255 - image<br/>image2 = np.reshape(image1,64)</span></pre><p id="7f32" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您查看任何 digits.images 示例，您将会看到最黑的像素对应于~15，但是您自定义输入中任何像素的最大值可以是 255，因此为了避免由于这种影响而导致的任何错误，我们将对数据进行标准化(即在 0 和 1 之间重新调整)。为此，我们将找到数组的最大数目，并将每个元素除以该最大数目。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="84f4" class="md kx jb lz b gy me mf l mg mh"># Training data<br/>for i in xrange(len(X_train)):<br/> maximum = np.amax(X_train[i])<br/> X_train[i]/=maximum</span><span id="093c" class="md kx jb lz b gy ms mf l mg mh">#Testing data<br/>maximum = np.amax(X_test)<br/>X_test/=maximum</span></pre><p id="1dd3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以走了。我们来预测一下:)</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="d933" class="md kx jb lz b gy me mf l mg mh">l = len(X_train)<br/>distance = np.zeros(l) #This will store the distance of test from every training value<br/>for i in range(l):<br/> distance[i] = dist(X_train[i],X_test)<br/>min_index = np.argmin(distance)<br/># print X_test<br/>print "Preditcted value is "<br/>print(Y_train[min_index])</span></pre><p id="0c92" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这会打印出来</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="dd31" class="md kx jb lz b gy me mf l mg mh">Predicted value is 2</span></pre><p id="bfb7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以制作更多的图像并预测它们。</p><p id="fc22" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有的代码都可以在这里<a class="ae nu" href="https://github.com/Salil-Jain/DigitRecognizer" rel="noopener ugc nofollow" target="_blank">找到</a><a class="ae nu" href="https://github.com/Salil-Jain/DigitRecognizer" rel="noopener ugc nofollow" target="_blank">https://github.com/Salil-Jain/DigitRecognizer</a></p><p id="33ee" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">谢谢你。</p></div></div>    
</body>
</html>