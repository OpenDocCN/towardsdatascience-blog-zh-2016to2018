<html>
<head>
<title>Easy way to read comics on your cellphone : Python 3.6 and Pillow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在手机上阅读漫画的简单方法:Python 3.6和枕头</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/easy-way-to-read-comics-on-your-cellphone-python-3-6-and-pillow-104e0d38afbf?source=collection_archive---------8-----------------------#2018-03-05">https://towardsdatascience.com/easy-way-to-read-comics-on-your-cellphone-python-3-6-and-pillow-104e0d38afbf?source=collection_archive---------8-----------------------#2018-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d826" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">漫威还是DC？超人还是蝙蝠侠？鸣人还是漂白剂？</p><p id="329c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有这些都只与一件事有关…漫画！！！</p><p id="db13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们还是孩子的时候，总是有一种对漫画书的巨大热爱，翻开书页看到我们的英雄在行动是一种幸福。关于谁是最好的超级英雄的多次辩论，关于他们家族历史的严肃讨论，或者梦想自己拯救哥谭市，我们很多人都在童年创造了如此难忘的时刻。</p><p id="50e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">时代过去了，但我们中的一些人仍然在寻找越来越多的漫画。在这个数字时代，人们可以轻松接入超高速互联网，随时随地阅读/下载自己喜欢的漫画书。然而，每当我们试图在手机上阅读漫画时，我们都会面临这样的问题:压缩页面中的每一帧，以便我们可以阅读帧中所写的内容。</p><p id="0810" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每次你不得不这样做的时候，你不觉得有一种强烈的冲动，有能力削减每一帧，使其清晰和舒缓的眼睛吗？如果你的答案是“是”，并且你渴望学习Python中的新知识，那么这篇文章将帮助你在手机/平板电脑上轻松阅读漫画。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/bdf7f0b54e40d0e3d1c153993fb23109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6qnFKiN0iSdI14pj2ox7_A.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Spongebob Squarepants Comic(White parts have been labelled as “”GUTTER”)</figcaption></figure><p id="ae24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们来看看上面的《海绵宝宝》漫画。这张图片有7帧，如果我们将它们切片，我们将得到7张漫画的图片，可以在我们的手机上轻松阅读。输出在期望的位置保存为单独的图像，</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lb"><img src="../Images/e49af3c84c2c7bc13466c00befecf6a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sFzrlqePqfx8YtMoCI8K2Q.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Output: Individual frames images saved at desired location</figcaption></figure><p id="ce53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们将采取从上到下扫描图像的每一行的方法，然后绘制一幅黑白行的图片，白色用于装订线，黑色用于任何其他颜色。我们将再次从左和右列扫描图像，并绘制一张黑白图片。</p><p id="1320" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法将帮助我们获得每个帧的尺寸，然后将每个帧分别保存到我们的硬盘驱动器中。</p><p id="2aca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用Python v3.6版和PIL/Pillow(Python图像库)包开发Spyder v3.2版。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="251e" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">软件要求</h2><p id="0f50" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated"><strong class="jp ir">Anaconda v 5.1<br/>T3】点击以下链接下载并安装Anaconda for Windows、Mac <br/>或Linux。</strong></p><div class="mh mi gp gr mj mk"><a href="https://www.anaconda.com/download/" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ir gy z fp mp fr fs mq fu fw ip bi translated">下载</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">下载1，000多个Python和R数据科学包的Anaconda发行版，一个包、环境和依赖项…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">www.anaconda.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my kv mk"/></div></div></a></div><p id="f51b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Python 3.6 <br/> </strong>点击以下链接下载并安装Python for Windows、Mac、<br/> Linux或其他。</p><div class="mh mi gp gr mj mk"><a href="https://www.python.org/downloads/" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ir gy z fp mp fr fs mq fu fw ip bi translated">下载Python</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">Python编程语言的官方主页</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">www.python.org</p></div></div><div class="mt l"><div class="mz l mv mw mx mt my kv mk"/></div></div></a></div><p id="94b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Python映像库(PIL/Pillow) <br/> </strong>使用下面的<br/>链接下载并安装用于Windows、Mac、Linux或其他系统的PIL/Pillow:</p><div class="mh mi gp gr mj mk"><a href="https://wp.stolaf.edu/it/installing-pil-pillow-cimage-on-windows-and-mac/" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ir gy z fp mp fr fs mq fu fw ip bi translated">在Windows和Mac上为Python安装PIL/Pillow/cImage</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">Python是什么？Python是一种广泛使用的编程语言，在这里的许多计算机科学课程中都有使用</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">wp.stolaf.edu</p></div></div></div></a></div></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="76f4" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">Python代码:</h2><p id="0471" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">点击下面的链接获得完整的代码，</p><p id="51de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"><em class="na">Python 2<br/></em></strong>Python 2和包<em class="na"> PIL </em> (Python映像库)。<strong class="jp ir"><em class="na"><br/></em></strong><a class="ae nb" href="https://github.com/mozillamonks/comicstrip/blob/master/comicstrip" rel="noopener ugc nofollow" target="_blank">https://github . com/Mozilla monks/comicstrip/blob/master/comicstrip</a></p><p id="670f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="na"> Python 3 <br/> </em> </strong>在这个版本的代码中，我们实现了使用<em class="na">枕头</em>包代替<em class="na">PIL</em>(Python 3中不支持)。<br/> <em class="na"> Pillow </em>是<em class="na"> PIL </em>的一个分支，在Python 3中增加了一些用户友好的特性。<strong class="jp ir"><em class="na"><br/></em></strong><a class="ae nb" href="https://github.com/sohamsil/comicstrip/blob/master/comicstrip_Python3.6" rel="noopener ugc nofollow" target="_blank">https://github . com/sohamsil/comicstrip/blob/master/comicstrip _ python 3.6</a></p><p id="1887" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从第一步开始，导入必要的库！</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="f5e0" class="lj lk iq nd b gy nh ni l nj nk">  import sys<br/> <!-- --> import inspect<br/> <!-- --> import zipfile<br/> <!-- --> import os<br/> <!-- --> import PIL<br/> <!-- --> import fnmatch<br/> <!-- --> from math import log<br/> <!-- --> from PIL import Image<br/> <!-- --> from PIL.ImageFile import Parser<br/> <!-- --> from PIL.ImageEnhance import Contrast<br/> <!-- --> from PIL.ImageFilter import BLUR<br/> <!-- --> from optparse import OptionParser<br/> <!-- --> from PIL.ImageOps import autocontrast</span></pre><p id="819e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于大多数漫画都有白色的装订线空间，让我们创建一个名为<em class="na"> gcolor </em>的变量，并将值指定为255(RGB)。此外，每个槽框的尺寸为<em class="na"> gwidth </em> = 10和<em class="na"> gheight </em> = 10。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="e8c8" class="lj lk iq nd b gy nh ni l nj nk"># gutter color<br/>   gcolor = 255</span><span id="b8cf" class="lj lk iq nd b gy nl ni l nj nk"># gutter width and height<br/>   gwidth, gheight = 10, 10</span></pre><p id="a11f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要从水槽中去除噪声并数字化图像，让我们通过创建一个变量<em class="na">对比度</em>并赋值0.8来改变对比度。(您可以根据需要更改该值)</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="ebe2" class="lj lk iq nd b gy nh ni l nj nk">contrast = 0.8</span></pre><p id="8c66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们继续我们的方法之前，创建一个名为<em class="na"> barrier </em>的变量，它将帮助我们区分装订线和漫画其余部分的颜色。</p><p id="1213" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="na">关卡</em> </strong>(以1到255的刻度来表示)。如果颜色的值小于屏障的值，颜色将转换为黑色，否则将转换为白色。在我们的例子中，我们选择值为210。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="f9e6" class="lj lk iq nd b gy nh ni l nj nk">barrier = 210</span><span id="42b5" class="lj lk iq nd b gy nl ni l nj nk"># debug method<br/>  def debug(switch, *args):<br/>   if switch:<br/>    callerframe = inspect.getouterframes(inspect.currentframe())[1]<br/>    line, caller = callerframe[2], callerframe[3]<br/>    context = "%s:%d" % (caller, line)<br/>    print("%-20s:" % (context), " ".join(map(str, args)))</span><span id="a54c" class="lj lk iq nd b gy nl ni l nj nk">def nopfn(*args):<br/>   pass</span><span id="5bfe" class="lj lk iq nd b gy nl ni l nj nk"># We will now create our class called “page”,<br/>  class page(object):<br/>  """A page of the book"""</span></pre><p id="5029" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们来看看我们的方法。定义一个方法<strong class="jp ir"><em class="na">_ isGutterRow()</em></strong>来判断一行是否为装订线，并返回值TRUE或FALSE。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="2bb1" class="lj lk iq nd b gy nh ni l nj nk">def _isGutterRow(self, left, row, right):<br/>  """Is the row from [left, right) a gutter?"""<br/>   nongutter = [x for x in range(left, right) if gcolor !=<br/>   self.img.getpixel((x,row))]<br/>   return len(nongutter) == 0</span></pre><p id="e23b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，我们为列定义了另一种方法。<strong class="jp ir"><em class="na">_ isGutterCol()</em></strong>检查一列是否为装订线，并返回值TRUE或FALSE。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="6720" class="lj lk iq nd b gy nh ni l nj nk">def _isGutterCol(self, col, top, bot):<br/>  “””Is the column from [top, bot) a gutter?”””<br/>   nongutter = [r for r in range(top, bot) if gcolor != <br/>   self.img.getpixel((col,r))]<br/>   return len(nongutter) == 0</span></pre><p id="f07c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每遇到一行，我们都会通过<strong class="jp ir"> <em class="na"> _getRow() </em> </strong>方法传递，进一步细化一帧的上下边界。确定一个帧的上限值和下限值后，该方法返回这两个值。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="43a6" class="lj lk iq nd b gy nh ni l nj nk">def _getRow(self, l, startRow, r, b):<br/> <!-- -->  debug(self.debug, "startRow:", startRow)<!-- --> <br/>  <!-- -->  if startRow &gt;= b:<br/> <!-- -->    return (-1,-1)</span><span id="9177" class="lj lk iq nd b gy nl ni l nj nk"># move down as long as the rows are gutter<br/> <!-- -->  row1 = startRow<br/> <!-- -->  while row1 &lt; b and self._isGutterRow(l, row1, r):<br/> <!-- -->    row1 += 1</span><span id="b114" class="lj lk iq nd b gy nl ni l nj nk">debug(self.debug, "row1:", row1)<br/> <!-- -->  if row1 == b:<br/> <!-- -->    return (-1, -1)</span><span id="a9f4" class="lj lk iq nd b gy nl ni l nj nk"># There are no more rows , we have finished the image<br/># We assume a frame height of at least fheight(minimum frame height)<br/># pixels and add it to the value of row1 as those rows can be<br/># skipped. Next we check if we have reached the bottom of the frame,<br/># else we check more columns until we reach the bottom of the frame</span><span id="6e93" class="lj lk iq nd b gy nl ni l nj nk">row2 = row1 + self.fheight</span><span id="c2a6" class="lj lk iq nd b gy nl ni l nj nk">debug(self.debug, "row2 starting with:", row2)<br/> <!-- -->  if row2 &gt; b:<br/> <!-- -->   return (-1, -1)</span><span id="c4a7" class="lj lk iq nd b gy nl ni l nj nk"># probably looking at the area after the last row (e.g. pagenum)<br/> <!-- -->  while row2 &lt; b and not self._isGutterRow(l, row2, r):<br/> <!-- -->   row2 += 1</span><span id="ae73" class="lj lk iq nd b gy nl ni l nj nk">debug(self.debug, "row2:", row2)<br/> <!-- -->  if row2 - row1 &lt; self.fheight:<br/> <!-- -->   return (-1, -1) # Not a proper frame</span><span id="8a13" class="lj lk iq nd b gy nl ni l nj nk">return (row1, row2)</span><span id="9d07" class="lj lk iq nd b gy nl ni l nj nk">def _prnfn(self, symbol):<br/> <!-- -->  print(symbol),<br/> <!-- -->  sys.stdout.flush()</span><span id="fffa" class="lj lk iq nd b gy nl ni l nj nk">def _nlfn(self):<br/> <!-- -->  print</span></pre><p id="16a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="na"> _getRows() </em> </strong>帮助我们跟踪图像中的所有行，并让我们确定这些行的帧边界。该方法有两个参数，self和startRow。</p><p id="1c4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="na"> _isGutterRow() </em> </strong>和<strong class="jp ir"> <em class="na"> _getRow() </em> </strong>被调用，第一个检查一行是否为装订线，第二个返回一帧的顶行和底行。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="2bbe" class="lj lk iq nd b gy nh ni l nj nk">def _getRows(self, startRow):<br/> <!-- -->  top, rows = startRow, []<br/> <!-- -->  count = 0<br/> <!-- -->  l,r,b = <br/>   self.lignore,self.img.size[0]- self.rignore,self.img.size[1]-1</span><span id="116f" class="lj lk iq nd b gy nl ni l nj nk">while True:<br/> <!-- -->   top, bot = self._getRow(l, top, r, b)<br/> <!-- -->   if top != -1:<br/> <!-- -->    debug(self.debug, "got row:", top, bot)<br/> <!-- -->    rows.append((0, top, self.img.size[0]-1, bot))<br/> <!-- -->    top = bot + (gheight//2)<br/> <!-- -->    count += 1</span><span id="7201" class="lj lk iq nd b gy nl ni l nj nk">else:<br/> <!-- -->    debug(self.debug, "No more rows")<br/> <!-- -->    break<br/> <!-- -->  debug(self.debug, "rows:", rows)<br/> <!-- -->  return rows</span></pre><p id="6d72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似于行，我们每遇到一列都会通过<strong class="jp ir"> <em class="na"> _getCol() </em> </strong>的方法来传递，进一步细化一帧的边界。在确定一个帧的最左边和最右边的值之后，该方法返回这两个值。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="5fbd" class="lj lk iq nd b gy nh ni l nj nk">def _getCol(self, startCol, t, b):<br/> <!-- -->  debug(self.debug, "startCol, t, b:", startCol, t, b)<br/> <!-- -->  r = self.img.size[0] - 1<br/> <!-- -->  if startCol &gt;= r:<br/> <!-- -->    return (-1,-1)</span><span id="4960" class="lj lk iq nd b gy nl ni l nj nk"># move right as long as the columns are gutter<br/> <!-- -->  col1 = startCol<br/> <!-- -->  while col1 &lt; r and self._isGutterCol(col1, t, b):<br/> <!-- -->    col1 += 1<br/> <!-- -->  if col1 == r:<br/>  <!-- --> return (-1, -1) <br/># There are no more columns, we have finished the image</span><span id="3ad2" class="lj lk iq nd b gy nl ni l nj nk"># We assume a frame width of at least fwidth(min.frame width)pixels <br/># and add it to the value of col1 as those columns can be <br/># skipped.Next we check if we have reached the right most column of # the frame, else we check more columns until we reach the right <br/># most column of the frame</span><span id="018b" class="lj lk iq nd b gy nl ni l nj nk">col2 = col1 + self.fwidth<br/> <!-- --> debug(self.debug, "Starting with column:", col2)<br/> <!-- --> if col2 &gt; r:<br/> <!-- -->   return (-1, -1) # no frame here - just gutter area on the right</span><span id="3bbd" class="lj lk iq nd b gy nl ni l nj nk">while col2 &lt; r and not self._isGutterCol(col2, t, b):<br/> <!-- --> col2 += 1<br/> <!-- --> debug(self.debug, "col2:", col2)<br/> <!-- --> if col2 - col1 &lt; self.fwidth:<br/> <!-- -->   return (-1, -1) # not a proper frame<br/> <!-- --> return (col1, col2)</span></pre><p id="2752" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="na"> _getCols() </em> </strong>帮助我们跟踪图像中的所有列，并让我们确定帧的边界。该方法采用三个参数:图像文件、单个帧的顶行和底行。</p><p id="5543" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"><em class="na">_ isGutterCol()</em></strong>和<strong class="jp ir"> <em class="na"> _getCol() </em> </strong>得到调用。第一个函数检查一列是否是装订线，第二个函数返回单个框架的左列和右列。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="1d97" class="lj lk iq nd b gy nh ni l nj nk">def _getCols(self, rt, rb): <br/> <!-- -->  left, cols = 0, [] <br/> <!-- -->  while True:<br/> <!-- -->    left, right = self._getCol(left, rt, rb)<br/> <!-- -->    if left != -1:<br/> <!-- -->     debug(self.debug, "got column:", left, right)<br/> <!-- -->     cols.append((left, rt, right, rb))<br/> <!-- -->     left = right + (gwidth//2)<br/> <!-- -->    else:<br/> <!-- -->     debug(self.debug, "No more columns")<br/> <!-- -->     break<br/> <!-- -->   debug(self.debug, "cols:", cols)<br/> <!-- -->   return cols</span></pre><p id="e1c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="na"> _getFrames() </em> </strong>整体获取一个页面，返回页面中的所有框架。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="8898" class="lj lk iq nd b gy nh ni l nj nk">def _getFrames(self):</span><span id="8f87" class="lj lk iq nd b gy nl ni l nj nk"># Get all the rows, traversing the entire height of the image<br/> <!-- -->  rows = self._getRows(self.startRow)<br/> <!-- -->  debug(self.debug, "Got rows:", rows)</span><span id="b9ec" class="lj lk iq nd b gy nl ni l nj nk"># Determine the left and right columns for each row<br/> <!-- -->  frames = []<br/> <!-- -->  for rl, rt, rr, rb in rows:<br/> <!-- -->    debug(self.debug, "Row:", rl, rt, rr, rb)<br/> <!-- -->    cols = self._getCols(rt, rb)<br/> <!-- -->    debug(self.debug, "Got Columns:", cols)<br/> <!-- -->    frames.extend(cols)</span><span id="d664" class="lj lk iq nd b gy nl ni l nj nk">debug(self.debug, "=== Frames:", frames)</span><span id="670e" class="lj lk iq nd b gy nl ni l nj nk"># Now try to further trim the top and bottom gutters of each <br/># frame (left and right gutters would already be as tight as <br/># possible) and then extract the area from the original image</span><span id="b152" class="lj lk iq nd b gy nl ni l nj nk">fimgs = []<br/> <!-- --> for (fl, ft, fr, fb) in frames:<br/> <!-- -->   debug(self.debug, "Refining:", fl, ft, fr, fb)<br/> <!-- -->   newt, newb = self._getRow(fl, ft, fr, fb)<br/> <!-- -->   if newt == -1 # The frame is already as tight as possible<br/> <!-- -->     debug(self.debug, "Cannot reduce any further")<br/> <!-- -->     newt, newb = ft, fb</span><span id="15d0" class="lj lk iq nd b gy nl ni l nj nk">else:<br/> <!-- -->     debug(self.debug, "Got:", newt, newb)</span><span id="4a11" class="lj lk iq nd b gy nl ni l nj nk">fimg = Image.new("RGB", (fr - fl, newb - newt))<br/> <!-- -->   fimg = Image.new("RGB", (fr - fl, newb - newt))<br/> <!-- -->   fimg.paste(self.orig.crop((fl, newt, fr, newb)), (0, 0))<br/> <!-- -->   fimgs.append(fimg)<br/> <!-- --> return fimgs</span></pre><p id="45ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用以下两种方法数字化和准备页面。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="39af" class="lj lk iq nd b gy nh ni l nj nk">def _digitize(self, color):<br/> <!-- -->  if color // barrier == 0:<br/> <!-- -->    result = 0<br/> <!-- -->  else:<br/> <!-- -->    result = 255<br/> <!-- -->  return result</span><span id="9d2b" class="lj lk iq nd b gy nl ni l nj nk">def _prepare(self):<br/> <!-- -->  bwimg = self.orig.convert("L")<br/> <!-- -->  return Contrast(autocontrast(bwimg,10)).enhance(contrast)<br/>          .point(self._digitize)</span><span id="88b2" class="lj lk iq nd b gy nl ni l nj nk">keys = ["startRow", "lignore", "rignore", "contents", "infile",<br/> <!-- -->       "pgNum","quiet","debug", "fwidth", "fheight"]</span></pre><p id="ae1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将为类<em class="na"> page </em>定义一个构造函数为<strong class="jp ir"> <em class="na"> __init__() </em> </strong>，并根据我们将要处理的漫画页面的类型传递一个类的实例和其他参数。构造函数的参数如下:</p><p id="9f53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="na"> startRow(默认值:0) </em> </strong>:从哪一行开始分析。这通常是<br/>用于分析漫画的第一页，其中页面的某个顶部<br/>包含标题(我们需要跳过)<br/> <br/> <strong class="jp ir"> <em class="na"> lignore，rignore(默认值:两者均为0)</em></strong>:扫描的页面可能在一侧或两侧有一些非白色的颜色，这会干扰装订线检测。当定位装订线时，这些参数告诉装订线检测算法通过<em class="na"> lignore </em>调整左边界，通过<em class="na"> rignore </em>调整右边界</p><p id="e343" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="na">内容(默认值:True)</em></strong>:<br/>True =&gt;<em class="na">infile</em>是由页面内容组成的字符串<br/> False = &gt; <em class="na"> infile </em>是保存要打开的页面文件名称的字符串</p><p id="b753" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="na"> infile </em> </strong>:保存页面内容或页面文件名的字符串(取决于<br/> contents参数)</p><p id="c2e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="na">安静</em> </strong>:不打印任何状态信息</p><p id="d1fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="na">调试</em> </strong>:启用调试打印<em class="na">宽度</em>，f <em class="na">高度</em>(一帧的最小宽度和高度)</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="a76f" class="lj lk iq nd b gy nh ni l nj nk">def __init__(self, **kw):<br/> <!-- -->  object.__init__(self)<br/> <!-- -->  [self.__setattr__(k, kw[k]) for k in page.keys]<br/> <!-- -->  quietFns = {False:(self._prnfn, self._nlfn), True:(nopfn, nopfn)}<br/> <!-- -->  self.prnfn, self.nlfn = quietFns[self.quiet]<br/> <!-- -->  if self.contents:<br/> <!-- -->    parser = Parser()<br/> <!-- -->    parser.feed(kw["infile"])<br/> <!-- -->    self.orig = parser.close()<br/> <!-- -->  else:<br/> <!-- -->    self.orig = Image.open(self.infile)<br/> <!-- -->  self.img = self._prepare()<br/> <!-- -->  self.frames = self._getFrames()</span></pre><p id="8b4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将每个帧作为图像文件导出到指定的目的位置，同时为每个帧的名称添加前缀和计数器。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="7e07" class="lj lk iq nd b gy nh ni l nj nk">def getargs(parser):<br/>  (options, args) = parser.parse_args()<br/> <!-- --> kw = {}<br/> <!-- --> kw["infile"] = options.infile<br/> <!-- --> if kw["infile"] is None:<br/> <!-- -->   raise ValueError("Input File Not Specified")<br/> <!-- --> kw["prefix"] = options.prefix<br/> <!-- --> kw["startRow"] = options.startRow<br/> <!-- --> kw["lignore"] = options.lignore<br/> <!-- --> kw["rignore"] = options.rignore<br/> <!-- --> kw["filePat"] = options.filePat<br/> <!-- --> kw["quiet"] = options.quiet<br/> <!-- --> kw["gwidth"] = options.gwidth<br/> <!-- --> kw["fwidth"] = options.fwidth<br/> <!-- --> kw["fheight"] = options.fheight<br/> <!-- --> kw["debug"] = options.debug<br/> <!-- --> kw["fileList"] = args<br/> <!-- --> return kw</span><span id="981e" class="lj lk iq nd b gy nl ni l nj nk">parser = OptionParser(usage="%prog [options]", version="%%prog %s<br/> <!-- -->(_version),description="Split a comic page into individual frames")</span><span id="5d47" class="lj lk iq nd b gy nl ni l nj nk">parser.add_option("-q", "--quiet", action="store_true",dest="quiet",<br/> help="Don't print progress messages to stdout [default:%default]")</span><span id="feda" class="lj lk iq nd b gy nl ni l nj nk">parser.add_option("-d", "--debug", dest="debug",action="store_true",<br/> help="Enable debug prints [default:%default]")</span><span id="e15b" class="lj lk iq nd b gy nl ni l nj nk">parser.add_option("-f", "--file", dest="infile",type="string",<br/> metavar="FILE",help="Name of the input file")</span><span id="553f" class="lj lk iq nd b gy nl ni l nj nk">parser.add_option("", "--prefix", dest="prefix",<br/> help="Prefix for outputfiles")</span><span id="f12c" class="lj lk iq nd b gy nl ni l nj nk">parser.add_option("", "--left-ignore", type="int",dest="lignore",<br/> metavar="PIXELS",help="How much of the left <br/> margin to ignore when detecting rows [default:%default]")</span><span id="2fb5" class="lj lk iq nd b gy nl ni l nj nk">parser.add_option("", "--right-ignore", type="int", dest="rignore",<br/> <!-- -->  metavar="PIXELS",help="How much of the right margin to <br/>   ignore when detecting rows [default:%default]")</span><span id="4878" class="lj lk iq nd b gy nl ni l nj nk">parser.add_option("", "--startrow", type="int", dest="startRow",<br/> <!-- -->  metavar="PIXELS",help="From which line of the each page <br/>   (other than the first page) should the processing start  <br/>   [default:%default]")</span><span id="0f81" class="lj lk iq nd b gy nl ni l nj nk">parser.add_option("", "--gutter-width", dest="gwidth",<br/>   metavar="WIDTH",help="Minimum width of the gutter  <br/>   [default:%default]")</span><span id="b794" class="lj lk iq nd b gy nl ni l nj nk">parser.add_option("", "--min-width", dest="fwidth", metavar="WIDTH",<br/> <!-- -->  type="int",help="Minimum width of a frame [default:%default]")</span><span id="97e0" class="lj lk iq nd b gy nl ni l nj nk">parser.add_option("", "--min-height", dest="fheight",  <br/>   metavar="HEIGHT",<br/>type="int",help="Minimum height of a frame [default:%default]")</span><span id="52b4" class="lj lk iq nd b gy nl ni l nj nk">parser.set_defaults(quiet=False,prefix="cstrip-",lignore=0,rignore=0,<br/> <!-- -->  startRow=0,gwidth=15,fwidth=50,fheight=50,debug=True)</span><span id="0a68" class="lj lk iq nd b gy nl ni l nj nk">kw = getargs(parser)</span></pre></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="3d8e" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">终端中的调用:</h2><p id="1bc2" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated"><code class="fe nm nn no nd b">$ comic.py [options]</code></p><p id="19fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有效选项有:<br/> <strong class="jp ir"> <em class="na"> —版本</em> </strong>:显示程序的版本号并退出。<br/> <strong class="jp ir"> <em class="na"> -h，—帮助</em> </strong>:显示简短的帮助信息并退出。</p><p id="ddaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="na"> -q，— quiet </em> </strong>:不将进度消息打印到stdout【默认:False】。</p><p id="96cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="na"> -d，—调试:</em> </strong>启用调试打印【默认:假】。仅用于调试<br/>普通用户不需要启用此功能。使用-d选项时启用'-q' <br/>会有所帮助，这样常规进度显示就不会<br/>干扰调试输出(反之亦然)。</p><p id="1615" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="na"> -f文件，— file=FILE : </em> </strong>输入文件的名称<strong class="jp ir">(必选参数)。</strong>这个<br/>可能是一个图像文件的名称。</p><p id="f2dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="na"> —前缀=前缀</em> </strong>:输出文件的前缀。<strong class="jp ir">(强制参数)</strong></p><p id="6f25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">单个帧以下列格式的名称保存到文件中:<br/> <em class="na"> &lt;前缀&gt;00.jpg、<br/> &lt;前缀&gt;01.jpg<br/>&lt;前缀&gt;02.jpg<br/>…<br/></em>前导零的数量根据输出帧的数量自动调整。如果您想将输出文件保存到一个特定的目录，只需将目录前缀添加到文件前缀<br/>(例如:前缀/tmp/foo-)</p><p id="60cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"><em class="na">—left-ignore = PIXELS</em></strong>:当<br/>检测行时，忽略多少左边距。<br/>【默认值:0】有时(尤其是扫描的漫画)页面中间的<br/><br/>边缘会一直有阴影，使得装订线“非白色”。该<br/>会干扰沟槽检测算法，并阻止<br/>成功检测到沟槽。此参数告诉应用程序在检测装订线时应该忽略左侧多少像素。</p><p id="c3da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:这并不意味着页边距左边的像素在<br/>最终输出中被丢弃——这只是意味着它们在装订线<br/>检测期间不被考虑。</p><p id="b05f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"><em class="na">—right-ignore = PIXELS</em></strong>:<strong class="jp ir"><em class="na"/></strong><br/>检测行数时忽略多少右边距【默认:0】。与“-左-忽略”相同，除了这是用于<br/>右侧。</p><p id="c30c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"><em class="na">—startrow = PIXELS</em></strong>:<strong class="jp ir"><em class="na"/></strong>从每一页(除第一页<br/>外)的哪一行开始处理【默认:0】。对于扫描的漫画，页面顶部的装订线<br/>可能会有阴影，从而干扰<br/>装订线处理算法。该参数告诉应用程序在检测页面中的行时要跳过多少个<br/>像素，从而允许算法<br/>跳过阴影。</p><p id="a71a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"><em class="na">—gutter-WIDTH = WIDTH</em></strong>:<strong class="jp ir"><em class="na"/></strong>最小的装订线宽度[默认值:15]</p><p id="08fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="na"> —最小宽度=宽度</em> : </strong>一帧的最小宽度【默认:100】。更精确的值加速了帧提取算法</p><p id="e91c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="na"> —最小高度=高度:</em> </strong>一个框架的最小高度【默认:100】。更精确的值加速了帧提取算法</p><p id="9175" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谢谢你Sohini Ghosh。</p></div></div>    
</body>
</html>