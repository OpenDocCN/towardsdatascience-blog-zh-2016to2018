<html>
<head>
<title>Python Basics: Iteration, Iterables, Iterators, and Looping</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 基础:迭代、可迭代对象、迭代器和循环</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-basics-iteration-and-looping-6ca63b30835c?source=collection_archive---------0-----------------------#2018-11-22">https://towardsdatascience.com/python-basics-iteration-and-looping-6ca63b30835c?source=collection_archive---------0-----------------------#2018-11-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7e6444611b6eb54b9172b1e14c82929c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WWrXceae4H_klzpPU6h7Hg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Source: <a class="ae kc" href="https://www.quora.com/Can-you-suggest-some-good-books-websites-for-learning-Python-for-a-layman" rel="noopener ugc nofollow" target="_blank">https://www.quora.com/Can-you-suggest-some-good-books-websites-for-learning-Python-for-a-layman</a></figcaption></figure><p id="c0a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看完这篇博文，你就知道了:</p><ul class=""><li id="1cd8" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">Python 中的<strong class="kf ir">迭代</strong>如何工作<strong class="kf ir">幕后</strong></li><li id="dd70" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">什么是<strong class="kf ir">迭代器</strong>和<strong class="kf ir">迭代器</strong>以及如何创建它们</li><li id="0fda" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">什么是<strong class="kf ir">迭代器协议</strong></li><li id="cabe" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">什么是<strong class="kf ir">懒评</strong></li><li id="999d" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">什么是<strong class="kf ir">发生器函数</strong>和<strong class="kf ir">发生器表达式</strong></li></ul><h1 id="5a79" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">Python 的 for 循环</h1><p id="cb92" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">Python 没有传统的<code class="fe ms mt mu mv b">for</code>循环。让我们来看一段伪代码，看看传统的 for 循环在许多其他编程语言中是什么样子的。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A Pseudocode of for loop</figcaption></figure><ul class=""><li id="f384" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">在进入循环之前，<strong class="kf ir">初始化器部分</strong>只执行一次。</li><li id="f52e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">条件段</strong>必须是一个<strong class="kf ir">布尔表达式</strong>。如果该表达式的计算结果为 True，则执行下一次循环迭代。</li><li id="9dfe" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">迭代器部分定义了每次迭代后发生的事情。</li></ul><p id="0fa3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们看看如何用 JavaScript 编写传统的 for 循环。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Simple For Loop in JavaScript</figcaption></figure><p id="8017" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="a6d0" class="ng lq iq mv b gy nh ni l nj nk">10<br/>12<br/>15<br/>18<br/>20</span></pre><p id="16ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">许多其他编程语言都有这种 for 循环，但是 Python 没有。不过，<strong class="kf ir"> Python </strong>有个叫<code class="fe ms mt mu mv b"><strong class="kf ir">for</strong></code> <strong class="kf ir">循环</strong>的东西，但是它<strong class="kf ir">的工作方式就像是</strong> <a class="ae kc" href="https://en.wikipedia.org/wiki/Foreach_loop" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> foreach 循环</strong> </a>。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Simple For Loop in Python</figcaption></figure><p id="f231" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="5bb3" class="ng lq iq mv b gy nh ni l nj nk">10<br/>12<br/>15<br/>18<br/>20</span></pre><p id="5ab7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从上面的例子中，我们可以看到在 Python 的<code class="fe ms mt mu mv b">for</code>循环中，我们没有任何我们之前见过的部分。没有初始化、条件或迭代器部分。</p><h1 id="15e6" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">可重复的</h1><p id="28df" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">iterable 是一个能够让<strong class="kf ir">逐个返回</strong>其<strong class="kf ir">成员</strong> <strong class="kf ir">的对象。换句话说，iterable 是可以用 Python 中的<code class="fe ms mt mu mv b">for</code>循环遍历的任何东西。</strong></p><h2 id="14ae" class="ng lq iq bd lr nl nm dn lv nn no dp lz ko np nq md ks nr ns mh kw nt nu ml nv bi translated">顺序</h2><p id="4e81" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">序列是非常常见的<strong class="kf ir">类型</strong>的<strong class="kf ir">可迭代</strong>。内置序列类型的一些示例有<a class="ae kc" href="https://docs.python.org/3.3/library/stdtypes.html#list" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">列表</strong> </a>、<a class="ae kc" href="https://docs.python.org/3.3/library/stdtypes.html#str" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">字符串</strong> </a>和<a class="ae kc" href="https://docs.python.org/3.3/library/stdtypes.html#tuple" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">元组</strong> </a>。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Lists, Tuples, and Strings in Python</figcaption></figure><p id="dc95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们通过<code class="fe ms mt mu mv b">__getitem()__</code>特殊方法(索引)使用整数<strong class="kf ir">索引</strong>支持高效的<strong class="kf ir">元素访问</strong>，并定义一个返回序列的<strong class="kf ir">长度</strong>的<code class="fe ms mt mu mv b">__length()__</code>方法。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Element access using indices.</figcaption></figure><p id="8f38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="ec10" class="ng lq iq mv b gy nh ni l nj nk">10<br/>blueberry<br/>❤</span></pre><p id="a7dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以对它们使用<strong class="kf ir">切片</strong>技术。如果你不知道什么是切片，可以在我讲解的时候查一下我之前文章的<a class="ae kc" rel="noopener" target="_blank" href="/python-basics-for-data-science-6a6c987f2755">一篇</a>。切片技术的解释在“子集列表”一节中。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Slicing Sequences.</figcaption></figure><p id="9d05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="bf2d" class="ng lq iq mv b gy nh ni l nj nk">[10, 12]<br/>('pineapple', 'blueberry')<br/>love Python ❤️</span></pre><h2 id="4372" class="ng lq iq bd lr nl nm dn lv nn no dp lz ko np nq md ks nr ns mh kw nt nu ml nv bi translated">其他可重复项目</h2><p id="fed6" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">Python 中的很多东西都是可迭代的，但并不都是序列。<strong class="kf ir">字典</strong>、<strong class="kf ir">文件对象</strong>、<strong class="kf ir">集合</strong>、<strong class="kf ir">生成器</strong>都是可迭代的，但没有一个是序列。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Sets, Dictionaries, Files, and Generators.</figcaption></figure><h1 id="b100" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">Python 的 for 循环不使用索引</h1><p id="7a42" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">让我们考虑一下如何在不使用 Python 中的<code class="fe ms mt mu mv b">for</code>循环的情况下循环遍历一个 iterable。我们中的一些人可能认为我们可以使用一个<code class="fe ms mt mu mv b">while</code>循环并生成索引来实现这一点。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="57f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="a890" class="ng lq iq mv b gy nh ni l nj nk">1<br/>2<br/>3<br/>4<br/>5</span></pre><p id="71ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法似乎对列表和其他序列对象非常有效。<strong class="kf ir">非序列</strong>对象呢？他们<strong class="kf ir">不支持索引</strong>，所以这种方法对他们不适用。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="208d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="baef" class="ng lq iq mv b gy nh ni l nj nk"><strong class="mv ir">--------------------------------------------------------------------</strong><br/><strong class="mv ir">TypeError</strong>                          Traceback (most recent call last)<br/><strong class="mv ir">&lt;ipython-input-22-af1fab82d68f&gt;</strong> in &lt;module&gt;<strong class="mv ir">()</strong><br/>      2 numbers <strong class="mv ir">=</strong> <strong class="mv ir">{1,</strong> <strong class="mv ir">2,</strong> <strong class="mv ir">3,</strong> <strong class="mv ir">4,</strong> <strong class="mv ir">5,</strong> <strong class="mv ir">6,</strong> <strong class="mv ir">7,</strong> <strong class="mv ir">8,</strong> <strong class="mv ir">9,</strong> <strong class="mv ir">10}</strong><br/>      3 <strong class="mv ir">while</strong> index <strong class="mv ir">&lt;</strong> len<strong class="mv ir">(</strong>numbers<strong class="mv ir">):</strong><br/><strong class="mv ir">----&gt; 4     </strong>print<strong class="mv ir">(</strong>numbers<strong class="mv ir">[</strong>index<strong class="mv ir">])</strong><br/>      5     index <strong class="mv ir">+=</strong> <strong class="mv ir">1</strong><br/><br/><strong class="mv ir">TypeError</strong>: 'set' object does not support indexing</span></pre><p id="b3e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯，但是 Python 的 for 循环是如何处理这些可重复项的呢？我们可以看到它适用于集合。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Iterate over a set.</figcaption></figure><p id="fd41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="63d4" class="ng lq iq mv b gy nh ni l nj nk">1<br/>2<br/>3<br/>4<br/>5</span></pre><h1 id="d639" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">迭代器</h1><p id="2ef0" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">迭代器是一个表示数据流的对象。您可以通过将<code class="fe ms mt mu mv b">iter()</code>内置函数应用于<strong class="kf ir">可迭代对象</strong>来创建迭代器对象。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="d28d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="0a39" class="ng lq iq mv b gy nh ni l nj nk">&lt;list_iterator object at 0x000001DBCEC33B70&gt;<br/>&lt;tuple_iterator object at 0x000001DBCEC33B00&gt;<br/>&lt;str_iterator object at 0x000001DBCEC33C18&gt;</span></pre><p id="26f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以使用一个迭代器来手动循环<strong class="kf ir">到</strong>它来自的<strong class="kf ir">可迭代</strong>。迭代器向内置函数<code class="fe ms mt mu mv b">next()</code>的重复传递会返回<strong class="kf ir">流</strong>中的<strong class="kf ir">连续项</strong>。一旦你消费了迭代器中的一个条目，它就消失了。当没有更多的数据可用时，产生一个<code class="fe ms mt mu mv b">StopIteration</code>异常。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="53fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="478e" class="ng lq iq mv b gy nh ni l nj nk">10<br/>20<br/>30</span><span id="9f27" class="ng lq iq mv b gy nw ni l nj nk"><strong class="mv ir">--------------------------------------------------------------------</strong><br/><strong class="mv ir">StopIteration</strong>                      Traceback (most recent call last)<br/><strong class="mv ir">&lt;ipython-input-14-fd36f9d8809f&gt;</strong> in &lt;module&gt;<strong class="mv ir">()</strong><br/>      4 print<strong class="mv ir">(</strong>next<strong class="mv ir">(</strong>iterator<strong class="mv ir">))</strong><br/>      5 print<strong class="mv ir">(</strong>next<strong class="mv ir">(</strong>iterator<strong class="mv ir">))</strong><br/><strong class="mv ir">----&gt; 6 </strong>print<strong class="mv ir">(</strong>next<strong class="mv ir">(</strong>iterator<strong class="mv ir">))</strong><br/><br/><strong class="mv ir">StopIteration</strong>:</span></pre><p id="e254" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在幕后，Python 的<code class="fe ms mt mu mv b">for</code>循环正在使用迭代器。</p><h1 id="fbbc" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">理解 Python 的 for 循环是如何工作的</h1><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/3f5ecda8d888f0e997ac97dd9a264b61.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*W7CL4sUwOzE5xDDkCJakMg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Source: <a class="ae kc" href="https://www.incredible-web.com/blog/performance-of-for-loops-with-javascript/" rel="noopener ugc nofollow" target="_blank">https://www.incredible-web.com/blog/performance-of-for-loops-with-javascript/</a></figcaption></figure><p id="23ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们知道了什么是 iterables 和迭代器，以及如何使用它们。我们可以尝试定义一个循环遍历 iterable 的函数，而不使用<code class="fe ms mt mu mv b">for</code>循环。</p><p id="e925" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们需要:</p><ul class=""><li id="20a7" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">从给定的可迭代对象创建一个迭代器</li><li id="1896" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">从迭代器中反复获取下一个项目</li><li id="1df4" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">执行</strong>想要的<strong class="kf ir">动作</strong></li><li id="3931" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">停止循环</strong>，如果我们在尝试获取下一个项目时遇到了<strong class="kf ir">Stop iteration</strong>T13】异常</li></ul><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Custom For Loop in Python. Source: <a class="ae kc" href="https://opensource.com/article/18/3/loop-better-deeper-look-iteration-python" rel="noopener ugc nofollow" target="_blank">https://opensource.com/article/18/3/loop-better-deeper-look-iteration-python</a></figcaption></figure><p id="99f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们试着用一组<strong class="kf ir">数字和<code class="fe ms mt mu mv b">print</code>内置函数来使用这个函数。</strong></p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Custom For Loop in Python - Usage.</figcaption></figure><p id="48dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="b5d8" class="ng lq iq mv b gy nh ni l nj nk">1<br/>2<br/>3<br/>4<br/>5</span></pre><p id="a3ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，我们定义的函数非常适合集合，集合不是序列。这一次我们可以通过<strong class="kf ir">任何可迭代的</strong>并且它将工作。在幕后，Python 中所有形式的<strong class="kf ir">循环遍历 iterables </strong>都是这样工作的。</p><h1 id="00da" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">迭代器协议</h1><p id="87d0" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">迭代器对象需要支持以下<strong class="kf ir">两种方法</strong>，它们共同构成<strong class="kf ir">迭代器协议</strong>:</p><ul class=""><li id="f42d" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">迭代器。__iter__() <br/>返回<strong class="kf ir">迭代器对象本身</strong>。这是允许容器(也称为集合)和迭代器与<code class="fe ms mt mu mv b">for</code>和<code class="fe ms mt mu mv b">in</code>语句一起使用所必需的。</li><li id="115b" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">迭代器。__next__() <br/>从容器中返回<strong class="kf ir">下一个项目</strong>。如果没有更多的项目，引发<strong class="kf ir"> StopIteration </strong>异常。</li></ul><p id="d161" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从上面的方法描述中，我们看到我们可以在迭代器上循环。所以迭代器也是可迭代的。</p><p id="c720" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记住，当我们将<code class="fe ms mt mu mv b">iter()</code>函数应用于一个可迭代对象时，我们得到了一个迭代器。如果我们在迭代器上调用<code class="fe ms mt mu mv b">iter()</code>函数<strong class="kf ir">，它总是<strong class="kf ir">返回给我们自己</strong>。</strong></p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="3457" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="6f65" class="ng lq iq mv b gy nh ni l nj nk">True<br/>100<br/>200<br/>300</span></pre><h1 id="c2bd" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">关于迭代器的附加注释</h1><p id="f955" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">这听起来可能有点令人困惑。但是，如果第一次的事情没有全部理解，也不用担心。让我们回顾一下！</p><ul class=""><li id="e8b1" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">一个<strong class="kf ir">可迭代的</strong>是你可以<strong class="kf ir">循环遍历</strong>的东西。</li><li id="3f47" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">一个<strong class="kf ir">迭代器</strong>是一个代表<strong class="kf ir">数据流</strong>的对象。它在一个 iterable 上进行<strong class="kf ir">迭代</strong>。</li></ul><p id="504c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，在 Python 中，<strong class="kf ir">迭代器也是可迭代的</strong>，充当它们自己的<strong class="kf ir">迭代器</strong>。</p><p id="4227" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，区别在于迭代器没有一些可迭代的特性。它们<strong class="kf ir">没有长度</strong>并且<strong class="kf ir">不能被转位</strong>。</p><p id="22cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例子</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Iterators No Length Error</figcaption></figure><p id="c4da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="f0c1" class="ng lq iq mv b gy nh ni l nj nk"><strong class="mv ir">--------------------------------------------------------------------</strong><br/><strong class="mv ir">TypeError</strong>                          Traceback (most recent call last)<br/><strong class="mv ir">&lt;ipython-input-15-778b5f9befc3&gt;</strong> in &lt;module&gt;<strong class="mv ir">()</strong><br/>      1 numbers <strong class="mv ir">=</strong> <strong class="mv ir">[100,</strong> <strong class="mv ir">200,</strong> <strong class="mv ir">300]</strong><br/>      2 iterator <strong class="mv ir">=</strong> iter<strong class="mv ir">(</strong>numbers<strong class="mv ir">)</strong><br/><strong class="mv ir">----&gt; 3 </strong>print<strong class="mv ir">(</strong>len<strong class="mv ir">(</strong>iterator<strong class="mv ir">))</strong><br/><br/><strong class="mv ir">TypeError</strong>: object of type 'list_iterator' has no len()</span></pre><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Indexing Iterators Error</figcaption></figure><p id="d594" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="1e81" class="ng lq iq mv b gy nh ni l nj nk"><strong class="mv ir">--------------------------------------------------------------------</strong><br/><strong class="mv ir">TypeError</strong>                          Traceback (most recent call last)<br/><strong class="mv ir">&lt;ipython-input-16-64c378cb8a99&gt;</strong> in &lt;module&gt;<strong class="mv ir">()</strong><br/>      1 numbers <strong class="mv ir">=</strong> <strong class="mv ir">[100,</strong> <strong class="mv ir">200,</strong> <strong class="mv ir">300]</strong><br/>      2 iterator <strong class="mv ir">=</strong> iter<strong class="mv ir">(</strong>numbers<strong class="mv ir">)</strong><br/><strong class="mv ir">----&gt; 3 </strong>print<strong class="mv ir">(</strong>iterator<strong class="mv ir">[0])</strong><br/><br/><strong class="mv ir">TypeError</strong>: 'list_iterator' object is not subscriptable</span></pre><h1 id="6afe" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">迭代器很懒</h1><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="ny nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Source: <a class="ae kc" href="https://giphy.com/gifs/animal-lazy-spirit-gdUxfKtxSxqtq" rel="noopener ugc nofollow" target="_blank">https://giphy.com/gifs/animal-lazy-spirit-gdUxfKtxSxqtq</a></figcaption></figure><blockquote class="nz oa ob"><p id="99a5" class="kd ke oc kf b kg kh ki kj kk kl km kn od kp kq kr oe kt ku kv of kx ky kz la ij bi translated">迭代器允许我们使用和创建<strong class="kf ir">惰性可迭代对象</strong>，它们不做任何工作，直到我们向它们请求下一项。</p></blockquote><p id="b774" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来源:<a class="ae kc" href="https://opensource.com/article/18/3/loop-better-deeper-look-iteration-python" rel="noopener ugc nofollow" target="_blank">https://open source . com/article/18/3/loop-better-deep-look-iteration-python</a></p><p id="e66a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于它们的懒惰，迭代器可以帮助我们处理<strong class="kf ir">无限长的迭代器</strong>。在某些情况下，我们甚至不能在内存中存储所有的信息，所以我们可以使用迭代器，它可以在我们每次请求时给出下一项。迭代器可以<strong class="kf ir">为我们</strong>节省大量<strong class="kf ir">内存</strong>和<strong class="kf ir"> CPU 时间</strong>。</p><p id="59af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种做法叫做<a class="ae kc" href="https://en.wikipedia.org/wiki/Lazy_evaluation" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">懒评</strong> </a>。</p><h1 id="a5ca" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">迭代器无处不在</h1><p id="5441" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">我们已经看到了一些迭代器的例子。此外，Python 有许多内置的迭代器类。例如，<code class="fe ms mt mu mv b">enumerate</code>和<code class="fe ms mt mu mv b">reversed</code>对象是迭代器。</p><h2 id="3407" class="ng lq iq bd lr nl nm dn lv nn no dp lz ko np nq md ks nr ns mh kw nt nu ml nv bi translated">列举例子</h2><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="4766" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="8a3c" class="ng lq iq mv b gy nh ni l nj nk">&lt;class 'enumerate'&gt;<br/>(0, 'apple')</span></pre><h2 id="68f3" class="ng lq iq bd lr nl nm dn lv nn no dp lz ko np nq md ks nr ns mh kw nt nu ml nv bi translated">反例</h2><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="780e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="b38d" class="ng lq iq mv b gy nh ni l nj nk">&lt;class 'reversed'&gt;<br/>blueberry</span></pre><p id="7ddc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python 的<code class="fe ms mt mu mv b">zip</code>、<code class="fe ms mt mu mv b">map</code>和<code class="fe ms mt mu mv b">filer</code>对象也是迭代器。</p><h2 id="330b" class="ng lq iq bd lr nl nm dn lv nn no dp lz ko np nq md ks nr ns mh kw nt nu ml nv bi translated">Zip 示例</h2><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="d677" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="277b" class="ng lq iq mv b gy nh ni l nj nk">&lt;class 'zip'&gt;<br/>(1, 1)<br/>(2, 4)</span></pre><h2 id="2cbf" class="ng lq iq bd lr nl nm dn lv nn no dp lz ko np nq md ks nr ns mh kw nt nu ml nv bi translated">地图示例</h2><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="d0fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="44a7" class="ng lq iq mv b gy nh ni l nj nk">&lt;class 'map'&gt;<br/>1<br/>4</span></pre><h2 id="6a47" class="ng lq iq bd lr nl nm dn lv nn no dp lz ko np nq md ks nr ns mh kw nt nu ml nv bi translated">过滤器示例</h2><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="eb8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="febb" class="ng lq iq mv b gy nh ni l nj nk">&lt;class 'filter'&gt;<br/>3</span></pre><p id="66bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而且 Python 中的<strong class="kf ir">文件对象</strong>也是迭代器。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="847b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="2a7d" class="ng lq iq mv b gy nh ni l nj nk">&lt;class '_io.TextIOWrapper'&gt;<br/>This is the first line.<br/><br/>This is the second line.<br/><br/>This is the third line.</span></pre><p id="2949" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以使用<code class="fe ms mt mu mv b">items()</code>方法迭代 Python <strong class="kf ir">字典</strong>的<strong class="kf ir">键值对</strong>。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="7b45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="add8" class="ng lq iq mv b gy nh ni l nj nk">&lt;class 'dict_items'&gt;<br/>name Ventsislav<br/>age 24</span></pre><p id="9d0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很多人用 Python 解决<strong class="kf ir">数据科学</strong>问题。在某些情况下，您处理的数据可能非常大。在这种情况下，我们无法将所有数据加载到内存中。</p><p id="d006" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决方案是<strong class="kf ir">将<strong class="kf ir">数据分块</strong>加载</strong>，然后对每个块执行所需的操作，丢弃该块并加载下一个数据块。换句话说我们需要创建一个迭代器。我们可以通过使用<strong class="kf ir">熊猫</strong>中的<code class="fe ms mt mu mv b">read_csv</code>函数来实现这一点。我们只需要指定<strong class="kf ir">块大小</strong>。</p><h2 id="ed50" class="ng lq iq bd lr nl nm dn lv nn no dp lz ko np nq md ks nr ns mh kw nt nu ml nv bi translated">大型数据集示例</h2><p id="bbfc" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在这个例子中，我们将看到一个名为“<a class="ae kc" href="https://www.kaggle.com/uciml/iris" rel="noopener ugc nofollow" target="_blank">鸢尾物种</a>的小数据集的想法，但同样的概念也适用于非常大的数据集。我已经更改了栏目名称，你可以在这里找到我的版本<a class="ae kc" href="https://gist.github.com/Ventsislav-Yordanov/7aa2e85cd67f95ad33ed26d9f534a792" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="643a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="9c77" class="ng lq iq mv b gy nh ni l nj nk">{'Iris-setosa': 50, 'Iris-versicolor': 50, 'Iris-virginica': 50}</span></pre><p id="9e84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python 标准库中和第三方库中有许多迭代器对象。</p><h1 id="621c" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">通过定义类创建自定义迭代器</h1><p id="d125" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在某些情况下，我们可能想要创建一个<strong class="kf ir">自定义迭代器</strong>。我们可以通过定义一个具有<strong class="kf ir"> __init__ </strong>、<strong class="kf ir"> __next__ </strong>和<strong class="kf ir"> __iter__ </strong>方法的类来做到这一点。</p><p id="152b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们试着创建一个自定义迭代器类，生成最小值和最大值之间的数字。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="29a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="7c2d" class="ng lq iq mv b gy nh ni l nj nk">&lt;class '__main__.generate_numbers'&gt;<br/>40<br/>41<br/>42</span></pre><p id="6766" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到这是可行的。然而，使用<strong class="kf ir">生成器函数</strong>或<strong class="kf ir">生成器表达式</strong>来创建定制迭代器要容易得多。</p><h1 id="9343" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">生成器函数和生成器表达式</h1><p id="7b52" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">通常，当我们想要创建一个自定义迭代器时，我们使用一个<strong class="kf ir">生成器函数</strong>或<strong class="kf ir">生成器表达式</strong>。它们使用起来更简单，并且需要更少的 T21 代码来达到同样的效果。</p><h2 id="96f9" class="ng lq iq bd lr nl nm dn lv nn no dp lz ko np nq md ks nr ns mh kw nt nu ml nv bi translated">发电机功能</h2><p id="ca22" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">让我们从 Python 文档中看看什么是生成器函数。</p><blockquote class="nz oa ob"><p id="195f" class="kd ke oc kf b kg kh ki kj kk kl km kn od kp kq kr oe kt ku kv of kx ky kz la ij bi translated">返回一个<a class="ae kc" href="https://docs.python.org/3.7/glossary.html#term-generator-iterator" rel="noopener ugc nofollow" target="_blank">生成器迭代器</a>的函数。它看起来像一个普通的函数，除了它包含用于产生一系列值<strong class="kf ir">的<code class="fe ms mt mu mv b"><a class="ae kc" href="https://docs.python.org/3.7/reference/simple_stmts.html#yield" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">yield</strong></a></code> <strong class="kf ir">表达式</strong>，这些值</strong>可在 for 循环中使用，或者可以用<code class="fe ms mt mu mv b"><a class="ae kc" href="https://docs.python.org/3.7/library/functions.html#next" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">next(</strong></a><strong class="kf ir">)</strong></code> <strong class="kf ir">函数</strong>一次检索<strong class="kf ir">一个。</strong></p></blockquote><p id="1860" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来源:<a class="ae kc" href="https://docs.python.org/3.7/glossary.html#term-generator" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3.7/glossary.html#term-generator</a></p><p id="08e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以尝试使用生成器函数来重新创建我们的自定义迭代器。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="3355" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="1198" class="ng lq iq mv b gy nh ni l nj nk">&lt;class 'generator'&gt;<br/>10<br/>11<br/>12</span></pre><p id="0977" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">产量表达式</strong>是将<strong class="kf ir">生成函数</strong>与普通函数分开的东西。这个表达式帮助我们利用迭代器的<strong class="kf ir">惰性</strong>。</p><blockquote class="nz oa ob"><p id="649e" class="kd ke oc kf b kg kh ki kj kk kl km kn od kp kq kr oe kt ku kv of kx ky kz la ij bi translated">每个<code class="fe ms mt mu mv b"><a class="ae kc" href="https://docs.python.org/3.7/reference/simple_stmts.html#yield" rel="noopener ugc nofollow" target="_blank">yield</a></code>会暂时挂起处理，记住位置执行状态(包括局部变量和挂起的 try 语句)。当<em class="iq">生成器迭代器</em>恢复时，它从停止的地方继续(与每次调用都从头开始的函数相反)。</p></blockquote><p id="07e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来源:<a class="ae kc" href="https://docs.python.org/3.7/glossary.html#term-generator-iterator" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3.7/glossary . html # term-generator-iterator</a></p><h2 id="9ad4" class="ng lq iq bd lr nl nm dn lv nn no dp lz ko np nq md ks nr ns mh kw nt nu ml nv bi translated">生成器表达式</h2><p id="bbf6" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">生成器表达式<strong class="kf ir">非常类似于</strong><strong class="kf ir">列表理解</strong>。就像列表理解一样，一般表达都是<strong class="kf ir">简洁</strong>。在大多数情况下，它们是用一行代码编写的。</p><blockquote class="nz oa ob"><p id="0621" class="kd ke oc kf b kg kh ki kj kk kl km kn od kp kq kr oe kt ku kv of kx ky kz la ij bi translated">返回迭代器的表达式。它看起来像一个普通表达式，后跟一个定义循环变量、范围的<code class="fe ms mt mu mv b"><a class="ae kc" href="https://docs.python.org/3.7/reference/compound_stmts.html#for" rel="noopener ugc nofollow" target="_blank">for</a></code>表达式和一个可选的<code class="fe ms mt mu mv b"><a class="ae kc" href="https://docs.python.org/3.7/reference/compound_stmts.html#if" rel="noopener ugc nofollow" target="_blank">if</a></code>表达式。</p></blockquote><p id="2c6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来源:<a class="ae kc" href="https://docs.python.org/3.7/glossary.html#term-generator-expression" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3.7/glossary . html # term-generator-expression</a></p><p id="1813" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">通式</strong>为:<strong class="kf ir"><br/>(iterable 中迭代器变量的输出表达式)</strong></p><p id="8f25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看如何定义一个简单的生成器表达式。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="9a9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="82f1" class="ng lq iq mv b gy nh ni l nj nk">&lt;class 'generator'&gt;<br/>1<br/>4<br/>9</span></pre><p id="9ce1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以在的<strong class="kf ir"> iterable </strong>上添加一个<strong class="kf ir">条件表达式。我们可以这样做:</strong></p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="a448" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="5e6b" class="ng lq iq mv b gy nh ni l nj nk">&lt;class 'generator'&gt;<br/>[4, 16]</span></pre><p id="9f0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们可以通过<strong class="kf ir">多个条件表达式</strong> <strong class="kf ir">对</strong><strong class="kf ir">可迭代</strong>进行更复杂的过滤。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="3063" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="8267" class="ng lq iq mv b gy nh ni l nj nk">&lt;class 'generator'&gt;<br/>[16]</span></pre><p id="5b94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以在的<strong class="kf ir">输出表达式</strong>上添加一个<strong class="kf ir"> if-else 子句</strong> <strong class="kf ir">，如下所示:</strong></p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="0a38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="mw mx my mz gt nc mv nd ne aw nf bi"><span id="8baa" class="ng lq iq mv b gy nh ni l nj nk">&lt;class 'generator'&gt;<br/>['odd', 'even', 'odd', 'even', 'odd']</span></pre><h1 id="cbf6" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">要点/总结</h1><ul class=""><li id="29cb" class="lb lc iq kf b kg mn kk mo ko og ks oh kw oi la lg lh li lj bi translated">一个<strong class="kf ir">可迭代的</strong>是你可以<strong class="kf ir">循环遍历</strong>的东西。</li><li id="77eb" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">序列</strong>是<strong class="kf ir">可迭代</strong>的一种非常常见的类型。</li><li id="bca2" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">Python 中的很多东西都是可迭代的，但并不都是序列。</li><li id="4eeb" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">一个<strong class="kf ir">迭代器</strong>是一个代表<strong class="kf ir">数据流</strong>的对象。它对一个 iterable 进行迭代。您可以使用迭代器来获取<strong class="kf ir">的下一个值</strong>或对其进行<strong class="kf ir">循环。<strong class="kf ir">一旦</strong>，你在一个迭代器上循环，就没有流值了。</strong></li><li id="3742" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">迭代器使用<strong class="kf ir">惰性评估</strong>方法。</li><li id="a89f" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">Python 中很多内置的</strong>类都是<strong class="kf ir">迭代器</strong>。</li><li id="8726" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">生成器函数</strong>是返回<strong class="kf ir">迭代器</strong>的函数。</li><li id="31c0" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">一个<strong class="kf ir">生成器表达式</strong>是返回一个<strong class="kf ir">迭代器</strong>的表达式。</li></ul><h1 id="f50c" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">接下来读什么？</h1><ul class=""><li id="91d7" class="lb lc iq kf b kg mn kk mo ko og ks oh kw oi la lg lh li lj bi translated">你可以看看<a class="ae kc" href="https://docs.python.org/3/library/itertools.html#module-itertools" rel="noopener ugc nofollow" target="_blank"> itertools </a>库。这个库包括创建迭代器的函数，用于有效的循环。</li><li id="4bc0" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">你也可以阅读<a class="ae kc" href="https://docs.python.org/3/howto/functional.html?#iterators" rel="noopener ugc nofollow" target="_blank">文档</a>或者阅读/观看下面的一些资源。</li><li id="c526" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">我的下一篇文章是关于 Python 中的列表理解。</li></ul><h1 id="895d" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">资源</h1><ul class=""><li id="d355" class="lb lc iq kf b kg mn kk mo ko og ks oh kw oi la lg lh li lj bi translated"><a class="ae kc" href="https://opensource.com/article/18/3/loop-better-deeper-look-iteration-python" rel="noopener ugc nofollow" target="_blank">https://open source . com/article/18/3/loop-better-deep-look-iteration-python</a></li><li id="dcd3" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://www.youtube.com/watch?v=V2PkkMS2Ack" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=V2PkkMS2Ack</a></li><li id="065e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://www.datacamp.com/community/tutorials/python-iterator-tutorial" rel="noopener ugc nofollow" target="_blank">https://www . data camp . com/community/tutorials/python-iterator-tutorial</a></li><li id="3b34" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://www.datacamp.com/courses/python-data-science-toolbox-part-2" rel="noopener ugc nofollow" target="_blank">https://www . data camp . com/courses/python-data-science-toolbox-part-2</a></li><li id="2393" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://en.wikipedia.org/wiki/Foreach_loop" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Foreach_loop</a></li><li id="51f6" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://docs.python.org/3.7/glossary.html#term-sequence" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3.7/glossary.html#term-sequence</a></li><li id="6c6b" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://docs.python.org/3.7/glossary.html#term-generator" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3.7/glossary.html#term-generator</a></li><li id="1453" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://docs.python.org/3.7/library/stdtypes.html#iterator-types" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3.7/library/STD types . html # iterator-types</a></li><li id="5860" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://docs.python.org/3/howto/functional.html?#iterators" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/howto/functional.html?#iterators</a></li></ul><h1 id="a4a0" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">我的其他博客文章</h1><p id="9803" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">你也可以看看我以前的博文。</p><ul class=""><li id="0b50" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><a class="ae kc" href="https://medium.com/@ventsislav94/jypyter-notebook-shortcuts-bf0101a98330" rel="noopener"> Jupyter 笔记本快捷键</a></li><li id="4c37" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" rel="noopener" target="_blank" href="/python-basics-for-data-science-6a6c987f2755">面向数据科学的 Python 基础知识</a></li><li id="6951" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" rel="noopener" target="_blank" href="/python-basics-list-comprehensions-631278f22c40"> Python 基础:列表理解</a></li><li id="9664" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" rel="noopener" target="_blank" href="/data-science-with-python-intro-to-data-visualization-and-matplotlib-5f799b7c6d82">Python 数据科学:Matplotlib 数据可视化简介</a></li><li id="1ad2" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" rel="noopener" target="_blank" href="/data-science-with-python-intro-to-loading-and-subsetting-data-with-pandas-9f26895ddd7f">使用 Python 的数据科学:使用 pandas 加载、子集化和过滤数据简介</a></li><li id="1833" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="http://Introduction to Natural Language Processing for Text" rel="noopener ugc nofollow" target="_blank">文本自然语言处理导论</a></li></ul><h1 id="6884" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">时事通讯</h1><p id="eb95" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">如果你想在我发表新的博客文章时得到通知，你可以订阅<a class="ae kc" href="https://buttondown.email/Ventsislav" rel="noopener ugc nofollow" target="_blank">我的简讯</a>。</p><h1 id="6d42" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">商务化人际关系网</h1><p id="517f" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">这是我在 LinkedIn 上的简介，如果你想和我联系的话。我将很高兴与你联系在一起。</p><h1 id="f04d" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">最后的话</h1><p id="a0da" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">谢谢你的阅读。我希望你喜欢这篇文章。如果你喜欢，请按住拍手键，分享给你的朋友。我很高兴听到你的反馈。如果你有什么问题，尽管问。😉</p></div></div>    
</body>
</html>