<html>
<head>
<title>Application of RNN for customer review sentiment analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RNN 在顾客评论情感分析中的应用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/application-of-rnn-for-customer-review-sentiment-analysis-178fa82e9aaf?source=collection_archive---------8-----------------------#2018-09-26">https://towardsdatascience.com/application-of-rnn-for-customer-review-sentiment-analysis-178fa82e9aaf?source=collection_archive---------8-----------------------#2018-09-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="489a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我之前的博客文章中，我写了关于使用 BeautifulSoup 收集两千多条 Flixbus 客户评论，并通过执行 NLP 分析来识别公司的优势和劣势。</p><p id="74f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于之前的故事，我决定使用收集的文本数据来训练一个递归神经网络模型来预测客户的情绪，这被证明是非常高效的，在测试集上达到 95.93%的准确率。</p><p id="ff20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">什么是情感分析？维基百科提供了一个很好的解释:</p><blockquote class="km kn ko"><p id="91eb" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">“……情感分析旨在确定发言人、作者或其他主体对某个主题的态度，或对某个文档、互动或事件的整体上下文极性或情感反应。”——<a class="ae kl" href="https://en.wikipedia.org/wiki/Sentiment_analysis" rel="noopener ugc nofollow" target="_blank">来源</a></p></blockquote><p id="5e5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事不宜迟，让我们开始实施吧。</p><h2 id="fa1e" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">加载和准备数据</h2><p id="8d49" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">首先，我加载了一个 csv 文件，其中包含 1，780 条英文客户评论，相应的评分从 1 到 5，其中 1 是最低(负面)评分，5 是最高(正面)评分。以下是对数据框的快速浏览:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/fd6d03346610c5defbeb785b36d7033c.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*yEihhgmjt1rPTMso0p4lrg.png"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Data frame with customer reviews and rating</figcaption></figure><p id="2e4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！现在我们有了可以处理的数据。然而，由于我们的目标是预测情绪——无论评论是正面的还是负面的，我们必须为这项任务选择适当的数据。</p><p id="f6ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用计数器功能，我注意到每个评分的评论分布相当不平衡:</p><pre class="ls lt lu lv gt md me mf mg aw mh bi"><span id="9ac0" class="kt ku iq me b gy mi mj l mk ml"># Count of reviews per rating<br/>Counter({5: 728, 4: 416, 1: 507, 3: 86, 2: 43})</span></pre><p id="6113" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了平衡它，并确保情绪类的良好表现，我决定保留“积极”的 5 星评论，而“消极”的 1 星和 2 星评论。结果，我得到了总共 1278 条评论的样本量。不多，但让我们看看能从中得到什么。</p><p id="d011" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在处理评论之前，应该使用列表理解对情感进行二进制编码，1 表示积极情感，0 表示消极情感。</p><pre class="ls lt lu lv gt md me mf mg aw mh bi"><span id="1ef1" class="kt ku iq me b gy mi mj l mk ml">data['Sentiment'] = [1 if x &gt; 4 else 0 for x in data.Rating]</span></pre><p id="cd36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了一个基本的设置，是时候继续进行数据预处理了。</p><h2 id="71b2" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">数据预处理</h2><p id="aa28" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">RNN 输入需要数组数据类型，因此，我们将“评论”转换为<strong class="jp ir"> X </strong>数组，并将“情绪”转换为<strong class="jp ir"> y </strong>数组。</p><pre class="ls lt lu lv gt md me mf mg aw mh bi"><span id="8cfa" class="kt ku iq me b gy mi mj l mk ml">X, y = (data['Review'].values, data['Sentiment'].values)</span></pre><p id="f4c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">文本数据在输入 RNN 模型之前必须进行整数编码。这可以通过使用 Keras 库中的基本工具轻松实现，只需几行代码:</p><pre class="ls lt lu lv gt md me mf mg aw mh bi"><span id="2029" class="kt ku iq me b gy mi mj l mk ml">from keras.preprocessing.text import Tokenizer<br/>from keras.preprocessing.sequence import pad_sequences</span><span id="e1d2" class="kt ku iq me b gy mm mj l mk ml">tk = Tokenizer(lower = True)<br/>tk.fit_on_texts(X)<br/>X_seq = tk.texts_to_sequences(X)<br/>X_pad = pad_sequences(X_seq, maxlen=100, padding='post')</span></pre><p id="f0e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，应该通过在数据集上安装标记器类来标记文本。如你所见，我使用“lower = True”参数将文本转换成小写，以确保数据的一致性。然后，我们应该使用 texts_to_sequences 类将单词(标记)列表映射到每个唯一单词的唯一整数列表。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/980487b4e3093b0a590f432dbb5d3068.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*PdYr3JQNtud5n4EkLAI5Pw.png"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Dictionary</figcaption></figure><p id="79db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为一个例子，下面您可以看到在应用预处理后，原始评论是如何变成一个整数序列的。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mo"><img src="../Images/92b9c0331f182c298ebd3d5df54cf74d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5eDro3xIimdhzfny6TplXg.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Original reviews vs after tokenization and sequencing</figcaption></figure><p id="f450" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们使用整数列表上的 pad_sequences 类来确保所有评论的长度相同，这是为 RNN 模型准备数据的非常重要的一步。应用这个类要么将评论缩短到 100 个整数，要么在它们更短的情况下用 0 填充它们。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mt"><img src="../Images/ac09b16722b153048d741dc48e37138b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yz-eal_RSMnrIEBcRqjZCg.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Reviews after padding</figcaption></figure><p id="4617" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们使用 sklearn 的 train_test_split 将数据集分为训练集和测试集，并保留 25%的原始数据作为保留集:</p><pre class="ls lt lu lv gt md me mf mg aw mh bi"><span id="8005" class="kt ku iq me b gy mi mj l mk ml">from sklearn.model_selection import train_test_split</span><span id="8fae" class="kt ku iq me b gy mm mj l mk ml">X_train, X_test, y_train, y_test = train_test_split(X_pad, y, test_size = 0.25, random_state = 1)</span></pre><p id="bfa9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，训练集可以分为训练集和验证集:</p><pre class="ls lt lu lv gt md me mf mg aw mh bi"><span id="c146" class="kt ku iq me b gy mi mj l mk ml">batch_size = 64<br/>X_train1 = X_train[batch_size:]<br/>y_train1 = y_train[batch_size:]</span><span id="4e7a" class="kt ku iq me b gy mm mj l mk ml">X_valid = X_train[:batch_size]<br/>y_valid = y_train[:batch_size]</span></pre><p id="7f63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是时候使用 Keras 构建模型并使其符合训练数据了:</p><pre class="ls lt lu lv gt md me mf mg aw mh bi"><span id="f532" class="kt ku iq me b gy mi mj l mk ml">from keras.models import Sequential<br/>from keras.layers import Embedding, LSTM, Dense, Dropout</span><span id="f55a" class="kt ku iq me b gy mm mj l mk ml">vocabulary_size = len(tk.word_counts.keys())+1<br/>max_words = 100</span><span id="1f65" class="kt ku iq me b gy mm mj l mk ml">embedding_size = 32<br/>model = Sequential()<br/>model.add(Embedding(vocabulary_size, embedding_size, input_length=max_words))<br/>model.add(LSTM(200))<br/>model.add(Dense(1, activation='sigmoid'))</span><span id="8606" class="kt ku iq me b gy mm mj l mk ml">model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])</span></pre><p id="2469" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于嵌入需要词汇的大小和输入序列的长度，我们将词汇大小设置为 Tokenizer 字典中的单词数+ 1，将输入长度设置为 100 (max_words)，其中后一个参数的值必须与填充(！idspnonenote)的值相同。).嵌入大小参数指定将使用多少维度来表示每个单词。通常使用值 50、100 和 300 作为该参数的输入，但在这种情况下，调整模型值 32 可获得最佳结果。</p><p id="6066" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们添加一个隐藏的 200 个内存单元的 LSTM 层。潜在地，添加更多的层和单元可以导致更好的结果。</p><p id="1eaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们添加带有 sigmoid 激活函数的输出层来预测评论为正面的概率。</p><p id="df26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在对模型进行 10 个时期的训练后，我们在验证集和测试集上分别获得了 98.44%和 95.93%的准确率。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mu"><img src="../Images/8c56b50770a3aa3f6cf430496b94acaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vwdmn-Y_v0p86y3DQGn3gA.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Training and testing accuracy results</figcaption></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/341d5fd64b304f9e74fafb1af6aee2e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*bpotyXNmV1R2hmRlx_wwHg.png"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Confusion matrix of hold out set prediction</figcaption></figure><p id="5b29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是不是很牛逼？为了安全起见，我们再检查一下吧！</p><h2 id="0372" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">最终验证</h2><p id="fb03" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">为了进一步验证模型的准确性，我另外从 Trustpilot 搜集了 100 条 Flixbus 的最新客户评论，当然这些评论不包括在原始数据集中。新抓取的评论包括 1、4 和 5 星级评论，计数如下:</p><pre class="ls lt lu lv gt md me mf mg aw mh bi"><span id="3025" class="kt ku iq me b gy mi mj l mk ml"># Count of reviews per rating<br/>Counter({1: 83, 4: 13, 5: 4})</span></pre><p id="08eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了准备用于预测的评论，在将它们传递到训练模型之前，必须对文本应用相同的预处理步骤。</p><pre class="ls lt lu lv gt md me mf mg aw mh bi"><span id="a2e4" class="kt ku iq me b gy mi mj l mk ml"># Prepare reviews for check<br/>Check_set = df.Review.values<br/>Check_seq = tk.texts_to_sequences(Check_set)<br/>Check_pad = pad_sequences(Check_seq, maxlen = 100, padding = 'post')</span><span id="6160" class="kt ku iq me b gy mm mj l mk ml"># Predict sentiment<br/>check_predict = model.predict_classes(Check_pad, verbose = 0)</span><span id="4af5" class="kt ku iq me b gy mm mj l mk ml"># Prepare data frame<br/>check_df = pd.DataFrame(list(zip(df.Review.values, df.Rating.values, check_predict)), columns = ['Review','Rating','Sentiment'])<br/>check_df.Sentiment = ['Pos' if x == [1] else 'Neg' for x in check_df.Sentiment]<br/>check_df</span></pre><p id="5392" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们得到以下结果:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/8937c8baa02f4f359ebf2513bd963cea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*PqnGKYypJ6IdcBD7O2hpDw.png"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Final check results</figcaption></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/628aa3ecc475e51671fcbca1c936be7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*Tm4kLHeJJwB6G53eiVQl2g.png"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Confusion matrix of validation prediction</figcaption></figure><p id="8c8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上面的截图中，您可以立即发现一些错误分类的情况。在 100 个预测案例中，只有 16 个实际评级为 1 星的评论被错误地归类为“Pos”(具有正面情绪)。然而，如果我们深入挖掘，我们会发现问题实际上并没有看起来那么大:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/4752c35505604aba6965ec05259fae9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*68Outb7eBHDOglDSpzyLEw.png"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Misclassifications</figcaption></figure><p id="3c26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">16 个案例中，只有 3 个独特的评论！一个评论重复 14 次(不公平💩).与此同时，所有评级为 4 和 5 的其他人都被正确分类为阳性。</p><h2 id="b6ab" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">就是这样！</h2><p id="6929" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">呜哇！我们已经成功地训练和验证了 RNN 的情感预测性能。总的来说，这是一个相对简单和容易的任务，交付出色的结果。希望你喜欢这篇文章，并努力实现你自己！</p></div></div>    
</body>
</html>