<html>
<head>
<title>Deep inside: Autoencoders</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">内心深处:自动编码器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deep-inside-autoencoders-7e41f319999f?source=collection_archive---------0-----------------------#2018-02-25">https://towardsdatascience.com/deep-inside-autoencoders-7e41f319999f?source=collection_archive---------0-----------------------#2018-02-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c82f3189ab7042b2ae24a5b5d25ee618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JpSmkJ8Yj-vtM1uUJwKypw.jpeg"/></div></div></figure><p id="30df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated">自动编码器(AE)是神经网络，旨在将它们的输入复制到它们的输出。他们通过将输入压缩到一个<strong class="ka ir">潜在空间</strong> <strong class="ka ir">表示</strong>中，然后从这个表示中重建输出。这种网络由两部分组成:</p><ol class=""><li id="ecfc" class="lf lg iq ka b kb kc kf kg kj lh kn li kr lj kv lk ll lm ln bi translated">编码器:这是网络的一部分，它将输入压缩成潜在空间表示。可以用编码函数<em class="lo"> h=f(x) </em>来表示。</li><li id="2ef1" class="lf lg iq ka b kb lp kf lq kj lr kn ls kr lt kv lk ll lm ln bi translated"><strong class="ka ir">解码器:</strong>该部分旨在从潜在空间表示中重建输入。可以用解码函数<em class="lo"> r=g(h) </em>来表示。</li></ol><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/9b3dca93c16b5fce3dfbff398a420327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V_YtxTFUqDrmmu2JqMZ-rA.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Architecture of an Autoencoder</figcaption></figure><p id="a1e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，自动编码器作为一个整体可以由函数<em class="lo"> g(f(x)) = r </em>来描述，其中您希望<strong class="ka ir"><em class="lo">【r</em></strong>与原始输入<strong class="ka ir"> <em class="lo"> x </em> </strong>一样接近。</p><blockquote class="md me mf"><p id="278f" class="jy jz lo ka b kb kc kd ke kf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku kv ij bi translated">为什么要将输入复制到输出？</p></blockquote><p id="348a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果自动编码器的唯一目的是将输入复制到输出，那么它们将毫无用处。事实上，我们希望通过训练自动编码器将输入复制到输出，潜在表示<strong class="ka ir"><em class="lo"/></strong>将呈现有用的属性。</p><p id="3b13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可以通过对复制任务创建约束来实现。从自动编码器获得有用特征的一种方式是约束<strong class="ka ir"><em class="lo"/></strong>使其尺寸小于<strong class="ka ir"> <em class="lo"> x </em> </strong>，在这种情况下，自动编码器被称为<strong class="ka ir">欠完成。</strong>通过训练欠完整表示，我们迫使自动编码器学习训练数据的最显著特征。如果给自动编码器太多的容量，它可以学习执行复制任务，而不提取任何关于数据分布的有用信息。如果潜在表示的尺寸与输入相同，以及在<strong class="ka ir">过完全</strong>的情况下，潜在表示的尺寸大于输入，也会发生这种情况。在这些情况下，即使线性编码器和线性解码器也可以学习将输入复制到输出，而无需学习任何关于数据分布的有用信息。理想情况下，可以成功地训练自动编码器的任何体系结构，根据要建模的分布的复杂性选择编码维数以及编码器和解码器的容量。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="f4be" class="mq mr iq bd ms mt mu dn mv mw mx dp my kj mz na nb kn nc nd ne kr nf ng nh ni bi translated">自动编码器的用途是什么？</h2><p id="19a4" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">今天<strong class="ka ir">数据去噪</strong>和用于数据可视化的<strong class="ka ir">降维</strong>被认为是自动编码器的两个主要有趣的实际应用。通过适当的维度和稀疏性约束，自动编码器可以学习比 PCA 或其他基本技术更有趣的数据投影。</p><p id="b4be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">自动编码器是从数据示例中自动学习的。这意味着很容易训练将在特定类型的输入上表现良好的算法的专门实例，并且它不需要任何新的工程，只需要适当的训练数据。</p><p id="61e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，自动编码器在图像压缩方面表现不佳。当自动编码器在给定的数据集上被训练时，它将在与所使用的训练集相似的数据上实现合理的压缩结果，但是将是较差的通用图像压缩器。像 JPEG 这样的压缩技术会好得多。</p><p id="a526" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">自动编码器被训练为当输入通过编码器然后通过解码器时尽可能多地保留信息，但是也被训练为使新的表示具有各种良好的属性。不同种类的自动编码器旨在实现不同种类的属性。我们将重点讨论四种类型的自动编码器。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="d0e5" class="mq mr iq bd ms mt mu dn mv mw mx dp my kj mz na nb kn nc nd ne kr nf ng nh ni bi translated">自动编码器的类型:</h2><p id="4672" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">在本文中，将描述以下四种类型的自动编码器:</p><ol class=""><li id="c075" class="lf lg iq ka b kb kc kf kg kj lh kn li kr lj kv lk ll lm ln bi translated">标准自动编码器</li><li id="dc71" class="lf lg iq ka b kb lp kf lq kj lr kn ls kr lt kv lk ll lm ln bi translated">多层自动编码器</li><li id="af4a" class="lf lg iq ka b kb lp kf lq kj lr kn ls kr lt kv lk ll lm ln bi translated">卷积自动编码器</li><li id="cdcd" class="lf lg iq ka b kb lp kf lq kj lr kn ls kr lt kv lk ll lm ln bi translated">正则化自动编码器</li></ol></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><p id="afc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了说明不同类型的自动编码器，我们使用 Keras 框架和 MNIST 数据集创建了一个示例。每种自动编码器的代码都可以在我的<a class="ae no" href="https://github.com/Yaka12/Autoencoders" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><h2 id="d924" class="mq mr iq bd ms mt mu dn mv mw mx dp my kj mz na nb kn nc nd ne kr nf ng nh ni bi translated">标准自动编码器</h2><p id="c0dc" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">在其最简单的形式中，自动编码器是三层网络，即具有一个隐藏层的神经网络。输入和输出是相同的，我们学习如何重建输入，例如使用<strong class="ka ir"> adam 优化器</strong>和<strong class="ka ir">均方误差损失函数</strong>。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0843" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我们看到我们有一个<strong class="ka ir">欠完成</strong>自动编码器，因为隐藏层尺寸(64)小于输入(784)。这种约束将迫使我们的神经网络学习数据的压缩表示。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="7209" class="mq mr iq bd ms mt mu dn mv mw mx dp my kj mz na nb kn nc nd ne kr nf ng nh ni bi translated">多层自动编码器</h2><p id="c610" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">如果一个隐藏层不够，我们显然可以将自动编码器扩展到更多的隐藏层。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1665" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们的实现使用 3 个隐藏层，而不是只有一个。可以选择任何隐藏图层作为要素制图表达，但我们将使网络对称，并使用最中间的图层。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="3d3f" class="mq mr iq bd ms mt mu dn mv mw mx dp my kj mz na nb kn nc nd ne kr nf ng nh ni bi translated">卷积自动编码器</h2><p id="da2c" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">我们也可以问自己:自动编码器可以用于卷积而不是全连接层吗？</p><p id="b27f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">答案是肯定的，原理是相同的，但是使用图像(3D 矢量)而不是扁平的 1D 矢量。对输入图像进行下采样，以给出较小尺寸的潜在表示，并迫使自动编码器学习图像的压缩版本。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="8bc7" class="mq mr iq bd ms mt mu dn mv mw mx dp my kj mz na nb kn nc nd ne kr nf ng nh ni bi translated">正则化自动编码器</h2><p id="4bae" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">除了施加比输入维度更小的隐藏层之外，还有其他方法可以约束自动编码器的重构。<strong class="ka ir">正则化的</strong>自动编码器不是通过保持编码器和解码器浅和代码大小小来限制模型容量，而是使用损失函数来鼓励模型具有除了将其输入复制到其输出的能力之外的其他属性。在实践中，我们通常会发现两种类型的正则化自动编码器:稀疏的 T2 自动编码器和去噪的 T4 自动编码器。</p><p id="16f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">稀疏自动编码器:</strong>稀疏自动编码器通常用于学习另一个任务的特征，例如分类。已经被正则化为稀疏的自动编码器必须响应它已经被训练的数据集的独特统计特征，而不是简单地充当身份函数。通过这种方式，以稀疏性为代价执行复制任务的训练可以产生一个附带学到有用特征的模型。</p><p id="b647" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以约束自动编码器的重构的另一种方式是对其损耗施加约束。例如，我们可以在损失函数中加入一个正则项。这样做将使我们的自动编码器学习数据的稀疏表示。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="828d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，在我们的隐藏层中，我们添加了一个<em class="lo"> l1 </em>活动正则化器，它将在优化阶段对损失函数应用惩罚。因此，与普通的自动编码器相比，这种表示更加稀疏。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="3235" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">去噪自动编码器:</strong>通过改变损失函数的重建误差项，我们可以获得一个自动编码器，它可以学习一些有用的东西，而不是向损失函数添加惩罚。这可以通过在输入图像中添加一些噪声，并让自动编码器学习去除噪声来实现。通过这种方式，编码器将提取最重要的特征，并学习数据的鲁棒表示。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="ceb7" class="mq mr iq bd ms mt mu dn mv mw mx dp my kj mz na nb kn nc nd ne kr nf ng nh ni bi translated">摘要</h2><p id="ba72" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">在本文中，我们介绍了自动编码器的基本架构。我们还研究了许多不同类型的自动编码器:普通的、多层的、卷积的和正则化的。每一种都有不同的属性，这取决于所施加的约束:要么是隐藏层的维度减少，要么是另一种惩罚。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="2d86" class="mq mr iq bd ms mt mu dn mv mw mx dp my kj mz na nb kn nc nd ne kr nf ng nh ni bi translated">我希望这篇文章对新的深度学习实践者来说是清晰和有用的，并且它让你对什么是自动编码器有了很好的了解！如果有不清楚的地方，请随时给我反馈或问我问题。</h2><div class="nr ns gp gr nt nu"><a href="https://github.com/nathanhubens/Autoencoders" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">nathan hubens/自动编码器</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">在 GitHub 上创建一个帐户，为 Autoencoders 的开发做出贡献。</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">github.com</p></div></div><div class="od l"><div class="oe l of og oh od oi jw nu"/></div></div></a></div></div></div>    
</body>
</html>