<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://towardsdatascience.com/creating-your-own-kotlin-detector-in-tensorflow-a425efcdc68b?source=collection_archive---------10-----------------------#2018-06-24">https://towardsdatascience.com/creating-your-own-kotlin-detector-in-tensorflow-a425efcdc68b?source=collection_archive---------10-----------------------#2018-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/de5d6c9340432ee5e578e7bfa8273adf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*zmJ0TV-6v0lGmO3SR7O2tA.png"/></div></figure><p id="b99c" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">在 TensorFlow 中创建您自己的 Kotlin 检测器</p><p id="684a" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">在本文中，我将展示如何为一种特定的产品——一种<strong class="iy ju"> Kotlin </strong>温和番茄酱——创建一个移动物体检测器:</p><figure class="jw jx jy jz gt is gh gi paragraph-image"><div class="gh gi jv"><img src="../Images/8b835c7c572a602ce36d1aebc09e1efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*r5jT4j0CExXvJicmV1UGrw.jpeg"/></div></figure><p id="5739" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">不久前，我在一个项目中使用<a class="ae ka" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank"> OpenCV </a>及其<a class="ae ka" href="https://github.com/bytedeco/javacv" rel="noopener ugc nofollow" target="_blank"> Java 接口</a>进行对象检测。我正在为不同类型的产品实现基于特征的级联分类器。这种分类器的生成包括以下 3 个步骤:</p><ul class=""><li id="ee2c" class="kb kc ix iy b iz ja jd je jh kd jl ke jp kf jt kg kh ki kj bi translated">样品收集</li><li id="f140" class="kb kc ix iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated">培养</li><li id="6221" class="kb kc ix iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated">侦查</li></ul><p id="998f" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">为了收集样本，我尽可能多地生成已识别产品的失真图像。为了从单个图像生成大量样本(100 个)，我使用了<strong class="iy ju"> opencv_createsamples </strong>实用程序脚本:</p><pre class="jw jx jy jz gt kp kq kr ks aw kt bi"><span id="e710" class="ku kv ix kq b gy kw kx l ky kz">opencv_createsamples -img [image_name.jpg] -num 100 -bg negatives.dat -vec samples.vec -maxxangle 0.6 -maxyangle 0 -maxzangle 0.3 -maxidev 100 -bgcolor 0 -bgthresh 0 -w 24 -h 24</span></pre><p id="d430" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">其中<em class="la"> negatives.dat </em>只是一个不包含给定检测对象的图像路径列表。</p><p id="556b" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">对于培训，我使用了<strong class="iy ju">opencv _ HAART training</strong>:</p><pre class="jw jx jy jz gt kp kq kr ks aw kt bi"><span id="3ab1" class="ku kv ix kq b gy kw kx l ky kz">opencv_haartraining -data [classifier_dir_object_name] -vec samples.vec -bg negatives.dat -nstages 10 -precalcValBufSize 1024 -precalcIdxBufSize 1024 -minhitrate 0.995 -maxfalsealarm 0.5 -npos 100 -nneg 100 -w 24 -h 24 -mode ALL</span></pre><p id="dd3b" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">这里的<strong class="iy ju"> samples.dat </strong>是一个包含指向给定对象的图像路径和坐标列表的文件。其格式如下:</p><pre class="jw jx jy jz gt kp kq kr ks aw kt bi"><span id="3845" class="ku kv ix kq b gy kw kx l ky kz">[filename] [# of objects] [[x y width height] [… 2nd object] …]</span></pre><p id="d388" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">例如:</p><pre class="jw jx jy jz gt kp kq kr ks aw kt bi"><span id="c804" class="ku kv ix kq b gy kw kx l ky kz">picture001.jpg 1 140 100 45 45 <br/>picture002.jpg 2 100 200 50 50 50 30 25 25</span></pre><p id="07ca" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">应用程序运行在服务器上。缺点是生成有效分类器的成本，以及我无法在移动设备上轻松部署我的解决方案的事实。</p><p id="40f1" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">在<strong class="iy ju"/><a class="ae ka" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"><strong class="iy ju">tensor flow</strong></a>发布后，我决定使用它的<a class="ae ka" href="https://github.com/tensorflow/models/tree/master/research/object_detection" rel="noopener ugc nofollow" target="_blank">对象检测 API </a>。生成一个正常工作的模型的成本仍然很高，但是<strong class="iy ju"> TensorFlow </strong>提供了许多方便的脚本和样本，这使得生成一个具有对象检测的移动应用程序相对容易。</p><p id="9df2" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">首先，我们需要下载并<a class="ae ka" href="https://www.tensorflow.org/install/" rel="noopener ugc nofollow" target="_blank">设置</a> TensorFlow 环境，并克隆适当的存储库:</p><pre class="jw jx jy jz gt kp kq kr ks aw kt bi"><span id="2762" class="ku kv ix kq b gy kw kx l ky kz">git clone - recursive <a class="ae ka" href="https://github.com/tensorflow/tensorflow" rel="noopener ugc nofollow" target="_blank">https://github.com/tensorflow/tensorflow</a><br/>git clone - recursive <a class="ae ka" href="https://github.com/tensorflow/model" rel="noopener ugc nofollow" target="_blank">https://github.com/tensorflow/model</a></span></pre><p id="9eb6" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">然后我们需要收集一些 Kotlin 番茄酱图像。将它们缩小到一些低分辨率会很好，例如 415 像素 x 553px 像素，因为我注意到当使用原始的大图片时，我经常在训练阶段出现内存不足的错误。即使只有 60 张训练图像(每张 3456 x 4608px ),我也得到了 OoME(在我的笔记本电脑上，配有 16GB RAM，i7–4720 HQ，在 Google ML Engine Cloud 上，配有 Standard_GPU)。</p><p id="69af" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">我们可以使用<a class="ae ka" href="https://www.imagemagick.org/script/mogrify.php" rel="noopener ugc nofollow" target="_blank"> mogrify </a>一步缩小一组图像:</p><pre class="jw jx jy jz gt kp kq kr ks aw kt bi"><span id="fd10" class="ku kv ix kq b gy kw kx l ky kz">find . -name “*.jpg” | xargs mogrify -resize 15%</span></pre><p id="e2ad" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">我还使用 Gimp 从大图片中提取较小的对象，特别是当一个目标多次可见时:</p><figure class="jw jx jy jz gt is gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/8bbba836496ed0bff0323f2a2c0f915e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*Yg9Y0SjOKe0TVRT0eKcjUw.jpeg"/></div></figure><p id="a32e" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">我使用了一个优秀的免费工具<a class="ae ka" href="https://github.com/tzutalin/labelImg" rel="noopener ugc nofollow" target="_blank"> labelImg </a>来生成 XML 格式的产品边框。</p><figure class="jw jx jy jz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi lc"><img src="../Images/3d4b8400b62cba66765aeaff2b003092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-m0EuajLsstF33sGnDbFg.png"/></div></div></figure><p id="d0f3" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">然后我把得到的一堆 JPG 和 XML 文件分成了<em class="la">训练</em> (277 个 img)和<em class="la">测试</em> (87)套</p><p id="9d93" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">然后，我从<a class="ae ka" href="https://github.com/datitran/raccoon_dataset/blob/master/xml_to_csv.py" rel="noopener ugc nofollow" target="_blank"> Racoon 数据集</a>运行 xml_to_csv.py 脚本的稍加修改的版本，为我的<strong class="iy ju"> <em class="la">训练</em> </strong>和<strong class="iy ju"> <em class="la">测试</em> </strong>数据集生成 csv 描述。</p><pre class="jw jx jy jz gt kp kq kr ks aw kt bi"><span id="1db8" class="ku kv ix kq b gy kw kx l ky kz">python3 xml_to_csv.py train</span><span id="4d57" class="ku kv ix kq b gy lh kx l ky kz">python3 xml_to_csv.py test</span></pre><p id="fdd5" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">接下来，我使用修改过的<a class="ae ka" href="https://github.com/datitran/raccoon_dataset/blob/master/generate_tfrecord.py" rel="noopener ugc nofollow" target="_blank"> generate_tfrecord.py </a>脚本(我添加了从文件中读取标签的功能)来生成 Tensorflow 学习阶段所需的 tfrecord。</p><pre class="jw jx jy jz gt kp kq kr ks aw kt bi"><span id="704f" class="ku kv ix kq b gy kw kx l ky kz">python3 generate_tfrecord.py -t train — labels_path=labels.txt — csv_input=train_labels.csv — output_path=train.record</span></pre><p id="feaf" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">在下一步中，我创建了。只包含一个检测到的标签条目的 pbtxt 文件:</p><pre class="jw jx jy jz gt kp kq kr ks aw kt bi"><span id="9fd5" class="ku kv ix kq b gy kw kx l ky kz">item {</span><span id="7299" class="ku kv ix kq b gy lh kx l ky kz">   id: 1</span><span id="aeab" class="ku kv ix kq b gy lh kx l ky kz">   name: ‘kotlin’</span><span id="f4b3" class="ku kv ix kq b gy lh kx l ky kz">},</span></pre><p id="b779" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">培训开始前的最后一件事是配置文件。这很复杂，我基于 Coco 数据集(因为我使用了迁移学习)。我已经改变了<strong class="iy ju"> num_classes: 1 </strong>(我们只检测到一个‘kot Lin’番茄酱对象)并且我使用了<strong class="iy ju">‘SSD _ mobilenet _ v2’</strong>特征提取器。</p><p id="bf69" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">在匹配器部分，我增加了<strong class="iy ju">匹配阈值</strong>的值(至 0.75)，并降低了<strong class="iy ju">不匹配阈值</strong>(至 0.25)。我已经把<strong class="iy ju"> fixed_shape_resizer </strong>改成了 500 x 500。如果没有这一步，我会得到许多误报。</p><p id="bea3" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">然后，为了避免经常发生的内存不足错误，我将<strong class="iy ju"> training_config </strong>部分中的<strong class="iy ju"> batch_size </strong>减少到 4。然后，我将<strong class="iy ju"> fine_tune_checkpoint </strong>调整到 Coco 数据集，并将<strong class="iy ju"> num_steps </strong>减少到 10000(以显著减少学习时间)。</p><p id="3e46" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">在<strong class="iy ju"> training_input_reader </strong>中我减少了:</p><pre class="jw jx jy jz gt kp kq kr ks aw kt bi"><span id="ce6a" class="ku kv ix kq b gy kw kx l ky kz">queue_capacity: 100</span><span id="5753" class="ku kv ix kq b gy lh kx l ky kz">min_after_dequeue: 50</span></pre><p id="410a" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">再说一次，为了避免 OoME。</p><p id="ce4f" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">我将步数设置为 10 000(以前是 200 000)。如此显著的下降会影响训练模型的准确性。然而，我注意到，在 9 000 和 10 000 之间，损失没有显著下降(总是在 0.5-1.5 之间波动)，所以我决定不增加这个值。然后在训练和评估部分调整<strong class="iy ju">输入 _ 路径</strong>和<strong class="iy ju">标签 _ 地图 _ 路径</strong>。</p><p id="51e1" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">现在让我们从培训阶段开始:</p><pre class="jw jx jy jz gt kp kq kr ks aw kt bi"><span id="63ca" class="ku kv ix kq b gy kw kx l ky kz">cd tensorflow/models/reasearch</span><span id="2ba5" class="ku kv ix kq b gy lh kx l ky kz">export PYTHONPATH=$PYTHONPATH:`pwd`:`pwd`/slim (we have to set this path each time we open a new terminal)</span><span id="88a1" class="ku kv ix kq b gy lh kx l ky kz">python3 object_detection/train.py — logtostderr — pipeline_config_path=product.config –train_dir=~/training</span></pre><p id="6054" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">这将在<strong class="iy ju"> training </strong>目录下生成一堆文件。</p><p id="c5fa" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">在特定的检查点记录学习步骤(参见“步骤记录总结”)在命令输出中)—其中一个检查点将在稍后生成 Protobuf 模型时使用。如果训练由于某种原因失败，我们可以稍后重新开始训练，并且(假设<strong class="iy ju">from _ detection _ check point = true)</strong>它将从最近记录的检查点开始处理。当学习结束时(给定的配置甚至可以持续 8 小时)，我们需要将生成的图形导出到可以在手机上使用的文件中。我们将使用 Tensorflow 模型项目中的<strong class="iy ju">object _ detection/export _ inference _ graph . py</strong>:</p><pre class="jw jx jy jz gt kp kq kr ks aw kt bi"><span id="b12f" class="ku kv ix kq b gy kw kx l ky kz">python3 object_detection/export_inference_graph.py — input_type image_tensor — pipeline_config_path=products.config — trained_checkpoint_prefix=model.ckpt-10000 — output_directory=~/products/out</span></pre><p id="cd40" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">因此，在<strong class="iy ju"> products/out </strong>目录中，我们将获得一个模型文件，我们需要将它复制到移动应用程序的<strong class="iy ju"> assets </strong>目录中(我将在下一段中描述它):</p><pre class="jw jx jy jz gt kp kq kr ks aw kt bi"><span id="f7aa" class="ku kv ix kq b gy kw kx l ky kz">cp /products/out/frozen_inference_graph.pb ~/AndroidStudioProjects/KotlinDetector/assets/frozen_inference_graph.pb</span></pre><p id="b63a" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">现在，剩下的就是手机 app 了。我调整了一个样本<a class="ae ka" href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/examples/android" rel="noopener ugc nofollow" target="_blank"> TensorFlow 对象检测应用</a>——提取并翻译成 Kotlin(好吧，还能用什么语言实现呢？:)).该应用程序使用 TensorFlowObjectDetectionAPIModel，它是冻结检测模型的包装器。它反过来使用 TensorFlowInferenceInterface，它是 TensorFlow API 的包装器。</p><p id="8d3e" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">如果你想拥有自己的检测器，你需要用你自己的文件替换<strong class="iy ju">frozen _ interference _ graph . Pb</strong>，并修改<strong class="iy ju">frozen _ inference _ labels . txt</strong>中的标签名称。</p><p id="cd36" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated">就是这样！瞧——这是运行中的 Kotlin 检测器:</p><figure class="jw jx jy jz gt is gh gi paragraph-image"><div class="gh gi li"><img src="../Images/fb7ec6d27ac9b574b59e347ec0128ce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*raEqISVzmlXw8ejtxQjJew.jpeg"/></div></figure><figure class="jw jx jy jz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi lj"><img src="../Images/36d424b4939915ec5328af18a3aa6e7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jcapDN1vGupP_zlWqXxE6Q.jpeg"/></div></div></figure><p id="283b" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated"><a class="ae ka" href="https://github.com/perkoren/KotlinDetector" rel="noopener ugc nofollow" target="_blank">在这里</a>你会找到手机 app 的代码。</p><p id="230c" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated"><a class="ae ka" href="https://github.com/perkoren/object-detection-scripts" rel="noopener ugc nofollow" target="_blank">这里的</a>是我在物体检测中使用的 Python 脚本。</p><p id="0be3" class="pw-post-body-paragraph iv iw ix iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ij bi translated"><a class="ae ka" href="https://www.dropbox.com/s/h1jvxorhy1ku7xi/KotlinDetector.apk?dl=0" rel="noopener ugc nofollow" target="_blank">这里的</a>是一个准备安装的。用于应用评估的 apk 文件。</p></div></div>    
</body>
</html>