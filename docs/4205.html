<html>
<head>
<title>Brewing up custom ML models on AWS SageMaker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 AWS SageMaker 上酝酿定制 ML 模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/brewing-up-custom-ml-models-on-aws-sagemaker-e09b64627722?source=collection_archive---------1-----------------------#2018-07-29">https://towardsdatascience.com/brewing-up-custom-ml-models-on-aws-sagemaker-e09b64627722?source=collection_archive---------1-----------------------#2018-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/637c9492de582dab3385b394a024809e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*x3M6R_9VuM7Ud-03X3l4ew.jpeg"/></div></figure><p id="ac04" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最近爱上了 SageMaker。仅仅是因为它太方便了！我真的很喜欢他们的方法，向客户隐藏所有的基础设施需求，让他们专注于解决方案中更重要的 ML 方面。只需在这里或那里点击几下并输入，瞧，您就有了一个准备好生产的模型，每天可以处理 1000 个(如果不是数百万个)请求。如果你需要一个关于 SageMaker 的好的介绍，看看下面这个非亚马逊公司的视频吧！</p><figure class="kv kw kx ky gt ju"><div class="bz fp l di"><div class="kz la l"/></div></figure><h1 id="047e" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">那么可能会出什么问题呢？</h1><p id="3ab9" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">但是当您试图在自己的 docker 容器中设置和创建自己的模型来执行定制操作时，麻烦就来了！这不像一开始就用 SageMaker 构建一切那样简单流畅。</p><h1 id="edf7" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为什么您需要定制模型？</h1><p id="628f" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">您需要自己的定制模型的原因有很多。你可能是:</p><ul class=""><li id="9336" class="me mf it jz b ka kb ke kf ki mg km mh kq mi ku mj mk ml mm bi translated">使用一些特定的 python 库版本，而不是最新的版本(例如 TensorFlow)</li><li id="27fb" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">使用 SageMaker 上不可用的库</li></ul><h1 id="6bb2" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">继续之前…</h1><p id="b192" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">在继续之前，请确保您具备以下条件。</p><ul class=""><li id="fe2c" class="me mf it jz b ka kb ke kf ki mg km mh kq mi ku mj mk ml mm bi translated">Docker 安装并运行在您的操作系统中</li><li id="e930" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">Docker 工作原理的基本知识</li></ul><h1 id="ac6c" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我们如何做到这一点？</h1><p id="577f" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">现在有了一个好的背景，让我们深入了解为 SageMaker 做准备的细节。教程将有三个不同的部分。</p><ul class=""><li id="f9bf" class="me mf it jz b ka kb ke kf ki mg km mh kq mi ku mj mk ml mm bi translated">用你的代码创建一个 docker 图像</li><li id="e8c0" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">在本地测试 docker 容器</li><li id="9c82" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">在 Amazon ECR(弹性容器存储库)上部署映像</li></ul><p id="0634" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我在这里把这些观点具体化。首先，您创建一个 docker 映像，其中包含库和代码以及其他需求(例如对端口的访问)。然后，从该映像创建一个容器并运行该容器。然后，您用容器中的一小块数据测试代码/模型。成功测试后，您将 docker 映像上传到 ECR。然后，您可以将该图像指定为 ML 模型，并通过 Amazon SageMaker 将其用于训练/预测。</p><p id="e348" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">此外，我将使用这个<a class="ae ms" href="https://github.com/awslabs/amazon-sagemaker-examples/blob/master/advanced_functionality/scikit_bring_your_own/scikit_bring_your_own.ipynb" rel="noopener ugc nofollow" target="_blank">教程/指南</a>作为这个博客的参考框架。真的是很好的教程。我想重新创作这篇博文的原因很少:</p><ul class=""><li id="6c4f" class="me mf it jz b ka kb ke kf ki mg km mh kq mi ku mj mk ml mm bi translated">如果你只依赖 scikit-learn，这是一个很好的教程。我想到用<a class="ae ms" href="https://github.com/dmlc/xgboost/tree/master/python-package" rel="noopener ugc nofollow" target="_blank"> XGBoost </a>创建一个容器，所以我们必须对 Docker 容器做一些修改。</li><li id="82ad" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">我想要 Python 3 而不是 Python 2，原因<a class="ae ms" href="https://pythonclock.org/" rel="noopener ugc nofollow" target="_blank">显而易见</a>。</li><li id="9a80" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">我还觉得这里和那里缺少一些细节(尤其是在本地测试时)。</li></ul><p id="a676" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了演示这个过程，我将在<a class="ae ms" href="https://archive.ics.uci.edu/ml/datasets/iris" rel="noopener ugc nofollow" target="_blank">虹膜数据集</a>上训练一个 XGBoost 分类器。你可以在这里 找到所有代码<a class="ae ms" href="https://github.com/thushv89/xgboost-aws-container" rel="noopener ugc nofollow" target="_blank"> <strong class="jz iu">的 Github 库。</strong></a></p><h1 id="f4df" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Docker 概述</h1><p id="a9f2" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">你知道还有什么比 SageMaker 更神奇吗？码头工人。Docker 极其强大，便携，快速。但这不是讨论原因的地方。所以让我们直接开始设置吧。使用 Docker 时，您有一套清晰的步骤:</p><ul class=""><li id="1cb9" class="me mf it jz b ka kb ke kf ki mg km mh kq mi ku mj mk ml mm bi translated">创建一个包含代码/模型的文件夹和一个名为<code class="fe mt mu mv mw b">Dockerfile</code>的特殊文件，该文件包含用于创建 docker 图像的<strong class="jz iu">配方</strong></li><li id="4dee" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">运行<code class="fe mt mu mv mw b">docker build -t &lt;image-tag&gt;</code>创建一个 docker 映像</li><li id="6286" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">通过运行<code class="fe mt mu mv mw b">docker run &lt;image&gt;</code>来运行图像</li><li id="4558" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">使用<code class="fe mt mu mv mw b">docker push &lt;image-tag&gt;</code>将 docker 映像推送到将存储该映像的某个存储库(例如 dockerhub 或 AWS ECR 存储库)</li></ul><h1 id="f309" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">SageMaker 兼容 Docker 容器概述</h1><p id="5646" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">注意，SageMaker 要求图像有一个特定的文件夹结构。SageMaker 寻找的文件夹结构如下。主要有两个父文件夹<code class="fe mt mu mv mw b">/opt/program</code>存放代码，和<code class="fe mt mu mv mw b">/opt/ml</code>存放工件。请注意，我已经模糊掉了一些您可能不需要编辑的文件(至少对于本练习来说是这样)，它们超出了本教程的范围。</p><figure class="kv kw kx ky gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi my"><img src="../Images/6f105ff2edc3194750e40fb91983d934.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uiIG6KJsJ2P-DQEoCF8vrA.jpeg"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">Adapted from of awslabs/ <a class="ae ms" href="https://github.com/awslabs/amazon-sagemaker-examples" rel="noopener ugc nofollow" target="_blank">amazon-sagemaker-examples</a> Github</figcaption></figure><figure class="kv kw kx ky gt ju gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/250d0a851e1b9c038cfada131a1ebc8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*GFdEE9KWH8qazLFQdmoB8Q.jpeg"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">Program structure in the Docker container</figcaption></figure><p id="3096" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在让我们详细讨论一下这些实体中的每一个。首先，<code class="fe mt mu mv mw b">opt/ml</code>是所有人工制品将要存放的地方。现在让我们来谈谈每个子目录。</p><h2 id="735a" class="ni lc it bd ld nj nk dn lh nl nm dp ll ki nn no lp km np nq lt kq nr ns lx nt bi translated">目录:/opt/ml</h2><p id="55e9" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated"><code class="fe mt mu mv mw b">input/data</code>是存储模型数据的目录。它可以是任何与数据相关的文件(假设您的 python 代码可以读取数据，并且容器具有这样做所需的库)。这里的<code class="fe mt mu mv mw b">&lt;channel_name&gt;</code>是模型将要使用的一些消耗性输入源的名称。</p><p id="32ba" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe mt mu mv mw b">model</code>是模型将要驻留的地方。您可以将模型放在它自己的容器中，您可以指定一个 URL (S3 桶位置),模型工件以一个<code class="fe mt mu mv mw b">tar.gz</code>文件的形式保存在那里。例如，如果您有亚马逊 S3 桶中的模型工件，您可以在 SageMaker 上的模型设置期间指向那个 S3 桶。然后，当您的模型启动并运行时，这些模型工件将被复制到<code class="fe mt mu mv mw b">model</code>目录中。</p><p id="93a4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最后，<code class="fe mt mu mv mw b">output</code>是控制器，如果失败，它将存储请求/任务失败的原因。</p><h2 id="8f09" class="ni lc it bd ld nj nk dn lh nl nm dp ll ki nn no lp km np nq lt kq nr ns lx nt bi translated">目录:/opt/program</h2><p id="6c45" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">现在让我们深入研究我们模型的精华部分；算法。这应该可以在我们 Docker 容器的<code class="fe mt mu mv mw b">/opt/program</code>目录中找到。关于<code class="fe mt mu mv mw b">train</code>、<code class="fe mt mu mv mw b">serve</code>和<code class="fe mt mu mv mw b">predictor.py</code>，我们需要小心的主要有三个文件。</p><p id="23f9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe mt mu mv mw b">train</code>保存用于训练模型和存储训练模型的逻辑。如果<code class="fe mt mu mv mw b">train</code>文件运行无故障，它将保存一个模型(即 pickle 文件)到<code class="fe mt mu mv mw b">/opt/ml/model</code>目录。</p><p id="6950" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe mt mu mv mw b">serve</code> essential 使用<em class="mx"> Flask </em>将<code class="fe mt mu mv mw b">predictor.py</code>中编写的逻辑作为 web 服务运行，它将监听任何传入的请求，调用模型，做出预测，并返回带有预测的响应。</p><h2 id="dbd8" class="ni lc it bd ld nj nk dn lh nl nm dp ll ki nn no lp km np nq lt kq nr ns lx nt bi translated">Dockerfile 文件</h2><p id="7b56" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">这是支持 Docker 容器中可用内容的文件。这意味着这个文件极其重要。所以让我们来看看里面。如果您已经熟悉如何编写 Dockerfile 文件，这是非常简单的。不过，还是让我带你简单参观一下吧。</p><ul class=""><li id="679b" class="me mf it jz b ka kb ke kf ki mg km mh kq mi ku mj mk ml mm bi translated"><code class="fe mt mu mv mw b">FROM</code>指令指定一个基本图像。所以这里我们使用一个已经构建好的 Ubuntu 映像作为我们的基础映像。</li><li id="2394" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">接下来使用<code class="fe mt mu mv mw b">RUN</code>命令，我们使用<code class="fe mt mu mv mw b">apt-get install</code>安装几个包(包括 Python 3.5)</li><li id="53b7" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">然后再次使用<code class="fe mt mu mv mw b">RUN</code>命令，我们安装 pip，接着是<code class="fe mt mu mv mw b">numpy</code>、<code class="fe mt mu mv mw b">scipy</code>、<code class="fe mt mu mv mw b">scikit-learn</code>、<code class="fe mt mu mv mw b">pandas</code>、<code class="fe mt mu mv mw b">flask</code>等。</li><li id="9c02" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">随后，我们使用<code class="fe mt mu mv mw b">ENV</code>命令在 Docker 容器中设置了几个环境变量。我们需要将我们的<code class="fe mt mu mv mw b">/opt/program</code>目录添加到<code class="fe mt mu mv mw b">path</code>变量中，这样，当我们调用容器时，它会知道我们的算法相关文件在哪里。</li><li id="2803" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">最后但同样重要的是，我们将包含算法相关文件的文件夹<code class="fe mt mu mv mw b">COPY</code>到<code class="fe mt mu mv mw b">/opt/program</code>目录，然后将其设置为<code class="fe mt mu mv mw b">WORKDIR</code></li></ul><h1 id="73b3" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建我们自己的 Docker 容器</h1><p id="8dd2" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">首先，我将使用<a class="ae ms" href="https://github.com/awslabs/amazon-sagemaker-examples/tree/master/advanced_functionality/scikit_bring_your_own/container" rel="noopener ugc nofollow" target="_blank">aw slaps Github 库</a>提供的惊人包的修改版本(链接<a class="ae ms" href="https://github.com/thushv89/xgboost-aws-container" rel="noopener ugc nofollow" target="_blank">此处为</a>)。这个原始存储库包含了我们运行 SageMaker 模型所需的所有文件，因此只需编辑这些文件，使其符合我们的需求。将原始链接中的内容下载到一个名为<code class="fe mt mu mv mw b">xgboost-aws-container</code>的文件夹中，如果你想从头开始，或者，你可以摆弄我的版本。</p><blockquote class="nu nv nw"><p id="bf48" class="jx jy mx jz b ka kb kc kd ke kf kg kh nx kj kk kl ny kn ko kp nz kr ks kt ku im bi translated"><strong class="jz iu">注意</strong>:如果你是 Windows 用户，并且你是那些运行过时的<a class="ae ms" href="https://docs.docker.com/toolbox/toolbox_install_windows/" rel="noopener ugc nofollow" target="_blank"> Docker 工具箱</a>的不幸者之一，确保你使用了<code class="fe mt mu mv mw b">C:\Users</code>目录中的某个目录作为你的项目主文件夹。否则，将文件夹挂载到容器时，您会遇到非常糟糕的体验。</p></blockquote><h2 id="d015" class="ni lc it bd ld nj nk dn lh nl nm dp ll ki nn no lp km np nq lt kq nr ns lx nt bi translated">对现有文件的更改</h2><ol class=""><li id="315e" class="me mf it jz b ka lz ke ma ki oa km ob kq oc ku od mk ml mm bi translated">将<code class="fe mt mu mv mw b">decision-trees</code>文件夹重命名为<code class="fe mt mu mv mw b">xgboost</code></li><li id="3152" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku od mk ml mm bi translated">编辑存储库中提供的<code class="fe mt mu mv mw b">train</code>文件。我本质上所做的是，我导入了<code class="fe mt mu mv mw b">xgboost</code>并将决策树模型替换为<code class="fe mt mu mv mw b">XGBClassifier</code>模型。<em class="mx">注意，一旦出现异常，就会被写入</em> <code class="fe mt mu mv mw b"><em class="mx">/opt/ml/output</em></code> <em class="mx">文件夹中的故障文件。因此，您可以自由地包含尽可能多的描述性异常，以确保您知道程序失败时哪里出错了。</em></li><li id="fe54" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku od mk ml mm bi translated">编辑存储库中提供的<code class="fe mt mu mv mw b">predictor.py</code>文件。本质上，我所做的类似于在<code class="fe mt mu mv mw b">train</code>上所做的改变。我导入了<code class="fe mt mu mv mw b">xgboost</code>，把分类器改成了<code class="fe mt mu mv mw b">XGBClassifier</code>。</li><li id="cf59" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku od mk ml mm bi translated">打开你的<code class="fe mt mu mv mw b">Dockerfile</code>进行以下编辑。</li></ol><p id="e913" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们使用<code class="fe mt mu mv mw b">python3.5</code>而不是<code class="fe mt mu mv mw b">python</code>，并根据 xgboost 的要求添加了<code class="fe mt mu mv mw b">libgcc-5-dev</code>。</p><pre class="kv kw kx ky gt oe mw of og aw oh bi"><span id="fb43" class="ni lc it mw b gy oi oj l ok ol">RUN apt-get -y update &amp;&amp; apt-get install -y — no-install-recommends \<br/> wget \<br/> python3.5 \<br/> nginx \<br/> ca-certificates \<br/> libgcc-5-dev \<br/> &amp;&amp; rm -rf /var/lib/apt/lists/*</span></pre><p id="492b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们将询问<code class="fe mt mu mv mw b">numpy</code>、<code class="fe mt mu mv mw b">scikit-learn</code>、<code class="fe mt mu mv mw b">pandas</code>、<code class="fe mt mu mv mw b">xgboost</code>的具体版本，以确保它们相互兼容。指定您想要使用的库的版本的另一个好处是，您知道<strong class="jz iu">它不会仅仅因为某个库的新版本与您的代码不兼容而中断</strong>。</p><pre class="kv kw kx ky gt oe mw of og aw oh bi"><span id="90c1" class="ni lc it mw b gy oi oj l ok ol">RUN wget <a class="ae ms" href="https://bootstrap.pypa.io/3.3/get-pip.py" rel="noopener ugc nofollow" target="_blank">https://bootstrap.pypa.io/3.3/get-pip.py</a> &amp;&amp; python3.5 get-pip.py &amp;&amp; \<br/> pip3 install numpy==1.14.3 scipy scikit-learn==0.19.1 xgboost==0.72.1 pandas==0.22.0 flask gevent gunicorn &amp;&amp; \<br/> (cd /usr/local/lib/python3.5/dist-packages/scipy/.libs; rm *; ln ../../numpy/.libs/* .) &amp;&amp; \<br/> rm -rf /root/.cache</span></pre><p id="119f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后，我们将拷贝命令更改为以下内容</p><pre class="kv kw kx ky gt oe mw of og aw oh bi"><span id="bf43" class="ni lc it mw b gy oi oj l ok ol">COPY xgboost /opt/program</span></pre><h1 id="d0a5" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">建立码头工人形象</h1><p id="f9dc" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">现在打开您的 Docker 终端(如果在 Windows 上，否则是 OS 终端)并转到包的父目录。然后运行以下命令。</p><pre class="kv kw kx ky gt oe mw of og aw oh bi"><span id="065e" class="ni lc it mw b gy oi oj l ok ol">docker build -t xgboost-tut .</span></pre><p id="f284" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这应该建立我们需要的一切形象。确保映像是通过运行，</p><pre class="kv kw kx ky gt oe mw of og aw oh bi"><span id="0629" class="ni lc it mw b gy oi oj l ok ol">docker images</span></pre><p id="2981" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您应该会看到如下所示的内容。</p><figure class="kv kw kx ky gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi om"><img src="../Images/63f2f32fc6129c907809202cadd7fa83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n-WtNC_32uXAumNY5EImcA.png"/></div></div></figure><h1 id="e392" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">运行 Docker 容器来训练模型</h1><p id="172b" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">现在是运行容器的时候了，开始执行下面的命令。</p><pre class="kv kw kx ky gt oe mw of og aw oh bi"><span id="f886" class="ni lc it mw b gy oi oj l ok ol">docker run --rm -v $(pwd)/local_test/test_dir:/opt/ml xgboost-tut train</span></pre><p id="42f9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们来分解这个命令。</p><p id="49f4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe mt mu mv mw b">--rm</code>:表示当你离开集装箱时，集装箱将被销毁</p><p id="ee39" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe mt mu mv mw b">-v &lt;host location&gt;:&lt;container location&gt;</code>:将卷安装到容器中的所需位置。<strong class="jz iu">警告</strong> : Windows 用户，如果你选择<code class="fe mt mu mv mw b">C:\Users</code>之外的任何东西，你都会有麻烦。</p><p id="b040" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe mt mu mv mw b">xgboost-tut</code>:图像的名称</p><p id="925b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe mt mu mv mw b">train</code>:随着容器的启动，将自动开始运行<code class="fe mt mu mv mw b">/opt/program</code>目录下的火车文件。这就是为什么指定<code class="fe mt mu mv mw b">/opt/program</code>作为<code class="fe mt mu mv mw b">PATH</code>变量的一部分很重要。</p><p id="0b4e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">事情应该运行良好，您应该会看到类似下面的输出。</p><pre class="kv kw kx ky gt oe mw of og aw oh bi"><span id="94aa" class="ni lc it mw b gy oi oj l ok ol">Starting the training.<br/>Training complete.</span></pre><p id="f1cf" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您还应该在您的<code class="fe mt mu mv mw b">&lt;project_home&gt;/local_test/test_dir/model</code>目录中看到<code class="fe mt mu mv mw b">xgboost-model.pkl</code>文件。这是因为我们将<code class="fe mt mu mv mw b">local_test/test_dir</code>目录挂载到了容器的<code class="fe mt mu mv mw b">/opt/ml</code>中，所以无论<code class="fe mt mu mv mw b">/opt/ml</code>发生什么都将反映在<code class="fe mt mu mv mw b">test_dir</code>中。</p><h1 id="a259" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在本地测试容器以供食用</h1><p id="c2f2" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">接下来，我们要看看服务(推理)逻辑是否正常工作。现在让我在这里再次警告，如果你错过了以上！如果您是 Windows 用户，请注意正确安装宗卷。为了避免任何不必要的问题，确保您在<code class="fe mt mu mv mw b">C:\Users</code>文件夹中选择一个文件夹，作为您的项目主目录。</p><pre class="kv kw kx ky gt oe mw of og aw oh bi"><span id="b853" class="ni lc it mw b gy oi oj l ok ol">docker run --rm --network=host -v $(pwd)/local_test/test_dir:/opt/ml xgboost-tut serve</span></pre><p id="28b6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我指出我们在 Docker run 命令中指定的一个特殊选项。</p><p id="cdcd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe mt mu mv mw b">--network=host</code>:表示主机的网络栈将被复制到容器中。所以这就像在本地机器上运行一些东西。这是检查 API 调用是否正常工作所必需的。</p><blockquote class="nu nv nw"><p id="88d5" class="jx jy mx jz b ka kb kc kd ke kf kg kh nx kj kk kl ny kn ko kp nz kr ks kt ku im bi translated"><strong class="jz iu">注意</strong>:我用的是<code class="fe mt mu mv mw b">--network=host</code>，因为<code class="fe mt mu mv mw b">-p &lt;host_ip&gt;:&lt;host_port&gt;:&lt;container_port&gt;</code>不工作(至少在 Windows 上)。我推荐使用-p 选项(如果有效的话)，如下所示。<strong class="jz iu">警告:仅使用其中一个命令，不要同时使用两个</strong>。但我将假设<code class="fe mt mu mv mw b">--network=host</code>选项继续前进。</p></blockquote><pre class="kv kw kx ky gt oe mw of og aw oh bi"><span id="456a" class="ni lc it mw b gy oi oj l ok ol">docker run --rm -p 127.0.0.1:8080:8080 -v $(pwd)/local_test/test_dir:/opt/ml xgboost-tut serve</span></pre><p id="e1ac" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe mt mu mv mw b">serve</code>:这是调用推理逻辑的文件</p><p id="e71b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这将向您显示类似下面的输出。</p><figure class="kv kw kx ky gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi on"><img src="../Images/8442e452c1a986e0f1a3184da5cb3b62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vx7wSJ2CQaaqq7GQoYZSDA.png"/></div></div></figure><p id="7428" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，为了测试我们是否能成功 ping 通服务，运行以下命令(在单独的终端窗口中)。</p><pre class="kv kw kx ky gt oe mw of og aw oh bi"><span id="9ab5" class="ni lc it mw b gy oi oj l ok ol">curl http://&lt;docker_ip&gt;:8080/ping</span></pre><p id="6245" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您可以通过以下方式找到 Docker 机器的 IP</p><pre class="kv kw kx ky gt oe mw of og aw oh bi"><span id="bf19" class="ni lc it mw b gy oi oj l ok ol">docker-machine ip default</span></pre><p id="52a2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个 ping 命令应该在主机端和服务器端产生两条消息。类似下面的东西。</p><figure class="kv kw kx ky gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oo"><img src="../Images/b6718649b56a4ff239a46ca75f9737ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TTdM1hJ5K10kUZfZryNwkA.png"/></div></div></figure><p id="ea60" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果这一切进展顺利(我非常希望如此)，直到这一点。恭喜你！您几乎已经建立了一个 SageMaker 兼容的 Docker 映像。直播前我们还需要做一件事。</p><p id="8cab" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在让我们试试更刺激的东西。让我们试着通过我们的 web 服务做一个预测。为此，我们将使用位于<code class="fe mt mu mv mw b">local_test</code>文件夹中的<code class="fe mt mu mv mw b">predict.sh</code>文件。请注意，我已经对它进行了修改，以适应我的需求，这意味着它不同于原始 awslabs 存储库中提供的那个。确切地说，我引入了一个新的用户提示参数，除了原始文件中的 IP 地址和端口之外，它还会接受这些参数。我们使用下面的命令调用修改后的<code class="fe mt mu mv mw b"><a class="ae ms" href="https://github.com/thushv89/xgboost-aws-container/blob/master/local_test/predict.sh" rel="noopener ugc nofollow" target="_blank">predict.sh</a></code>文件。</p><pre class="kv kw kx ky gt oe mw of og aw oh bi"><span id="060d" class="ni lc it mw b gy oi oj l ok ol">./predict.sh <a class="ae ms" href="http://192.168.99.100:8080" rel="noopener ugc nofollow" target="_blank">&lt;container_ip&gt;:&lt;</a>port&gt; payload.csv text/csv</span></pre><p id="1f2e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里我们使用<code class="fe mt mu mv mw b">payload.csv</code>中的数据调用推理 web 服务，并说它是一个 csv 文件。它应该会返回以下内容。它将其中的数据点标识为属于类<code class="fe mt mu mv mw b">setosa</code>。</p><pre class="kv kw kx ky gt oe mw of og aw oh bi"><span id="8a4a" class="ni lc it mw b gy oi oj l ok ol">* timeout on name lookup is not supported<br/>* Trying &lt;container_ip&gt;…<br/>* TCP_NODELAY set<br/>* Connected to &lt;container_ip&gt; (&lt;container_ip&gt;) port &lt;port&gt; (#0)<br/>&gt; POST /invocations HTTP/1.1<br/>&gt; Host: &lt;container_ip&gt;:&lt;port&gt;<br/>&gt; User-Agent: curl/7.55.0<br/>&gt; Accept: */*<br/>&gt; Content-Type: text/csv<br/>&gt; Content-Length: 23<br/>&gt;<br/>* upload completely sent off: 23 out of 23 bytes<br/>&lt; HTTP/1.1 200 OK<br/>&lt; Server: nginx/1.10.3 (Ubuntu)<br/>&lt; Date: &lt;date and time&gt; GMT<br/>&lt; Content-Type: text/csv; charset=utf-8<br/>&lt; Content-Length: 7<br/>&lt; Connection: keep-alive<br/>&lt;<br/>setosa<br/>* Connection #0 to host &lt;container_ip&gt; left intact</span></pre><h1 id="5be5" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">把它推到控制室</h1><p id="093e" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">好吧。所以努力终于有了回报。是时候将我们的图像推送到亚马逊弹性容器库(ECR)了。在此之前，请确保您在 ECR 中创建了一个存储库，以便将图像推送到其中。如果你有一个 AWS 账户，这很简单。</p><p id="2db8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">从 AWS 仪表板转到 ECR 服务，然后单击“创建存储库”</p><figure class="kv kw kx ky gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi op"><img src="../Images/f3627ee2fdcba597d8b0f691671bc1e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NHC3sxevRxZMfWOH73m0Ug.png"/></div></div></figure><p id="4811" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">创建存储库后，在存储库中，您应该能够看到完成推送 ECR 的指令。</p><p id="1377" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意:您也可以使用存储库中提供的 build_and_push.sh。但是我个人觉得自己做事情更舒服。推动存储库其实没有那么多步骤。</p><p id="0ec1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">首先，您需要获得登录 ECR 的凭证</p><pre class="kv kw kx ky gt oe mw of og aw oh bi"><span id="f144" class="ni lc it mw b gy oi oj l ok ol">aws ecr get-login — no-include-email — region &lt;region&gt;</span></pre><p id="0fa7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">它应该会返回一个输出，</p><pre class="kv kw kx ky gt oe mw of og aw oh bi"><span id="64f4" class="ni lc it mw b gy oi oj l ok ol">docker login …</span></pre><p id="ac5d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">复制粘贴该命令，现在您应该登录到 ECR。接下来，您需要重新标记您的图像，以便能够正确地推送至 ECR。</p><pre class="kv kw kx ky gt oe mw of og aw oh bi"><span id="58f9" class="ni lc it mw b gy oi oj l ok ol">docker tag xgboost-tut:latest &lt;account&gt;.dkr.ecr.&lt;region&gt;.amazonaws.com/xgboost-tut:latest</span></pre><p id="3c10" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在是时候将图像推送到您的存储库了。</p><pre class="kv kw kx ky gt oe mw of og aw oh bi"><span id="1a99" class="ni lc it mw b gy oi oj l ok ol">docker push &lt;account&gt;.dkr.ecr.&lt;region&gt;.amazonaws.com/xgboost-tut:latest</span></pre><p id="dfdb" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在图像应该出现在您的 ECR 存储库中，标签为<code class="fe mt mu mv mw b">latest</code>。困难的部分已经完成，接下来您需要创建一个 SageMaker 模型并指向图像，这就像用 SageMaker 本身创建一个模型一样简单。所以我不会在博文中详述这些细节。</p><p id="b191" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你可以在这里 找到所有代码<a class="ae ms" href="https://github.com/thushv89/xgboost-aws-container" rel="noopener ugc nofollow" target="_blank"> <strong class="jz iu">的 Github 库。</strong></a></p><h1 id="88ea" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="c6cb" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">这是一次漫长的旅行，但(在我看来)很有收获。所以我们在本教程中做了以下工作。</p><ul class=""><li id="3d8f" class="me mf it jz b ka kb ke kf ki mg km mh kq mi ku mj mk ml mm bi translated">首先，我们理解了为什么我们可能需要制作我们自己的定制模型</li><li id="cf44" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">然后我们检查了 SageMaker 运行容器所需的 Docker 容器的结构。</li><li id="b96e" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">然后，我们讨论了如何创建容器的 Docker 映像</li><li id="385c" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">接下来是如何构建映像和运行容器</li><li id="ac7b" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">接下来，我们讨论了在推出之前，如何在本地计算机上测试容器</li><li id="c5c5" class="me mf it jz b ka mn ke mo ki mp km mq kq mr ku mj mk ml mm bi translated">最后，我们讨论了如何将图像推送到 ECR，以便通过 SageMaker 使用。</li></ul><p id="39c9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">特别感谢做出<a class="ae ms" href="https://github.com/awslabs/amazon-sagemaker-examples/tree/master/advanced_functionality/scikit_bring_your_own" rel="noopener ugc nofollow" target="_blank">原始 Github 库</a>的贡献者给了我一个令人敬畏的起点！最后但重要的是，如果你喜欢这篇文章，请留下一些掌声:)</p><h1 id="f246" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">想在深度网络和 TensorFlow 上做得更好？</h1><p id="241a" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">检查我在这个课题上的工作。</p><figure class="kv kw kx ky gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oq"><img src="../Images/c902b07566ddcbe9ec0bc8a9c98954cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WVW0Dql9IQhFYMY7JLG7YA.png"/></div></div></figure><p id="c3f0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">[1] <a class="ae ms" href="https://www.manning.com/books/tensorflow-in-action" rel="noopener ugc nofollow" target="_blank">(书)TensorFlow 2 在行动——曼宁</a></p><p id="f769" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">[2] <a class="ae ms" href="https://www.datacamp.com/courses/machine-translation-in-python" rel="noopener ugc nofollow" target="_blank">(视频教程)Python 中的机器翻译</a> — DataCamp</p><p id="ddfc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">[3] <a class="ae ms" href="https://www.amazon.com.au/Natural-Language-Processing-TensorFlow-Ganegedara/dp/1788478312/ref=sr_1_25?dchild=1&amp;keywords=nlp+with+tensorflow&amp;qid=1603009947&amp;sr=8-25" rel="noopener ugc nofollow" target="_blank">(书)TensorFlow 中的自然语言处理 1 </a> — Packt</p></div><div class="ab cl or os hx ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="im in io ip iq"><h1 id="1979" class="lb lc it bd ld le oy lg lh li oz lk ll lm pa lo lp lq pb ls lt lu pc lw lx ly bi translated">新的！加入我的新 YouTube 频道</h1><figure class="kv kw kx ky gt ju gh gi paragraph-image"><a href="https://www.youtube.com/channel/UC1HkxV8PtmWRyQ39MfzmtGA/"><div class="gh gi pd"><img src="../Images/96ccda3d5f824c4032d99f325c1c2ec3.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/0*A-NxyeeJNchVSygd.png"/></div></a></figure><p id="2aa6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你渴望看到我关于各种机器学习/深度学习主题的视频，请确保加入<a class="ae ms" href="https://www.youtube.com/channel/UC1HkxV8PtmWRyQ39MfzmtGA/" rel="noopener ugc nofollow" target="_blank"> DeepLearningHero </a>。</p></div></div>    
</body>
</html>