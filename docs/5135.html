<html>
<head>
<title>Understanding Compilers — For Humans (Version 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解编译器——面向人类(第 2 版)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-compilers-for-humans-version-2-157f0edb02dd?source=collection_archive---------6-----------------------#2018-09-29">https://towardsdatascience.com/understanding-compilers-for-humans-version-2-157f0edb02dd?source=collection_archive---------6-----------------------#2018-09-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/61dfb26b18f84424519871b8dcf5a1d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V5BFrMTfgA1GVPmVgQozBQ.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="b3cc" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">编程语言如何工作</h2></div><p id="a6fd" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">从内部理解你的编译器可以让你有效地使用它。在这个按时间顺序排列的大纲中，浏览编程语言和编译器是如何工作的。许多链接、示例代码和图表有助于您的理解。</p></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h2 id="1e54" class="lt lu jb bd lv lw lx dn ly lz ma dp mb kz mc md me ld mf mg mh lh mi mj mk ml bi translated">作者说明</h2><p id="f023" class="pw-post-body-paragraph kq kr jb ks b kt mm kc kv kw mn kf ky kz mo lb lc ld mp lf lg lh mq lj lk ll ij bi translated"><em class="mr">理解编译器——人类版(第 2 版)</em>是我第二篇关于 Medium 的文章的后续，有超过 21，000 的浏览量。我很高兴我能对人们的教育产生积极的影响，并且我很高兴能根据我从最初的文章中得到的信息给<strong class="ks jc">带来一个完整的重写。</strong></p><div class="ip iq gp gr ir ms"><a href="https://medium.com/@CanHasCommunism/understanding-compilers-for-humans-ba970e045877" rel="noopener follow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd jc gy z fp mx fr fs my fu fw ja bi translated">理解编译器——为了人类</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">你是否点击了绿色的运行按钮，但并不真正知道引擎下面发生了什么？你想知道一个…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">medium.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng ix ms"/></div></div></a></div><p id="0ae5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我选择了铁锈作为这部作品的主要语言。它冗长、高效、现代，而且从设计上看，对于编译器来说非常简单。我喜欢使用它。【https://www.rust-lang.org/ T4】</p><p id="b384" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这篇文章的目的是保持读者的注意力，而不是有 20 页令人麻木的阅读。文本中有许多链接，将引导您找到更深入了解您感兴趣的主题的资源。大多数链接会将你引向维基百科。</p><p id="ae01" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">欢迎在底部的评论区提出任何问题或建议。感谢您的关注，希望您喜欢。</p></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h1 id="ae84" class="ni lu jb bd lv nj nk nl ly nm nn no mb kh np ki me kk nq kl mh kn nr ko mk ns bi translated">介绍</h1><h2 id="c600" class="lt lu jb bd lv lw lx dn ly lz ma dp mb kz mc md me ld mf mg mh lh mi mj mk ml bi translated">什么是编译器</h2><p id="e1b9" class="pw-post-body-paragraph kq kr jb ks b kt mm kc kv kw mn kf ky kz mo lb lc ld mp lf lg lh mq lj lk ll ij bi translated">总之，你所谓的编程语言实际上只是一种叫做编译器的软件，它可以读取文本文件，对其进行大量处理，并生成二进制文件。由于计算机只能读取 1 和 0，而人类比二进制写得更好，编译器被设计成将人类可读的文本转换成计算机可读的机器码。</p><p id="fb79" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">编译器可以是将一种文本翻译成另一种文本的任何程序。例如，这里有一个用 Rust 编写的编译器，它把 0 变成 1，把 1 变成 0:</p><figure class="nt nu nv nw gt is"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">While this compiler doesn’t read a file, doesn’t generate an AST, and doesn’t produce binary, it is still considered a compiler for the simple reason that it translates an input.</figcaption></figure><h2 id="bfa4" class="lt lu jb bd lv lw lx dn ly lz ma dp mb kz mc md me ld mf mg mh lh mi mj mk ml bi translated">编译器做什么</h2><p id="b723" class="pw-post-body-paragraph kq kr jb ks b kt mm kc kv kw mn kf ky kz mo lb lc ld mp lf lg lh mq lj lk ll ij bi translated">简而言之，编译器获取源代码并生成二进制代码。因为从复杂的、人类可读的代码直接转换成 1 和 0 是相当复杂的，所以编译器在程序运行之前有几个处理步骤要做:</p><ol class=""><li id="2154" class="od oe jb ks b kt ku kw kx kz of ld og lh oh ll oi oj ok ol bi translated">读取你给它的源代码的单个字符。</li><li id="212c" class="od oe jb ks b kt om kw on kz oo ld op lh oq ll oi oj ok ol bi translated">将字符分类为单词、数字、符号和运算符。</li><li id="532f" class="od oe jb ks b kt om kw on kz oo ld op lh oq ll oi oj ok ol bi translated">获取排序后的字符，通过将它们与模式进行匹配来确定它们试图执行的操作，并生成操作树。</li><li id="0a7b" class="od oe jb ks b kt om kw on kz oo ld op lh oq ll oi oj ok ol bi translated">迭代上一步中在树中进行的每个操作，并生成等效的二进制文件。</li></ol><p id="c3b6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="mr">虽然我说编译器立即从操作树进入二进制，但它实际上生成汇编代码，然后汇编/编译成二进制。汇编就像一个更高级的、人类可读的二进制文件。更多了解什么是</em> <a class="ae nh" href="https://en.wikipedia.org/wiki/Assembly_language" rel="noopener ugc nofollow" target="_blank"> <em class="mr">这里是</em> </a> <em class="mr">。</em></p><figure class="nt nu nv nw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi or"><img src="../Images/eac032bb2a47d97baf35675a5426e186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ttOYPPL-XJIf4zVZQUBzsQ.jpeg"/></div></div></figure><h2 id="b54e" class="lt lu jb bd lv lw lx dn ly lz ma dp mb kz mc md me ld mf mg mh lh mi mj mk ml bi translated">什么是口译员</h2><p id="0c83" class="pw-post-body-paragraph kq kr jb ks b kt mm kc kv kw mn kf ky kz mo lb lc ld mp lf lg lh mq lj lk ll ij bi translated">解释器很像编译器，因为它们阅读并处理语言。不过，<strong class="ks jc">解释器跳过代码生成，执行 AST </strong> <a class="ae nh" href="https://en.wikipedia.org/wiki/Just-in-time_compilation" rel="noopener ugc nofollow" target="_blank"> <strong class="ks jc">实时</strong> </a> <strong class="ks jc">。对解释器来说，最大的好处是在调试期间开始运行程序所花费的时间。编译器在程序执行前可能要花几秒到几分钟的时间来编译程序，而解释器不编译就立即开始执行。解释器最大的缺点是它需要安装在用户的计算机上，然后程序才能执行。</strong></p><figure class="nt nu nv nw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi os"><img src="../Images/13e804ed87314fd045c6297446c38de1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QFH7Zl7s3vQJjBNjhTO1kg.jpeg"/></div></div></figure><p id="26b6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="mr">本文主要指的是编译器，但是应该清楚它们之间的区别以及编译器之间的关系。</em></p><h1 id="7d90" class="ni lu jb bd lv nj ot nl ly nm ou no mb kh ov ki me kk ow kl mh kn ox ko mk ns bi translated">1.词汇分析</h1><p id="1c5e" class="pw-post-body-paragraph kq kr jb ks b kt mm kc kv kw mn kf ky kz mo lb lc ld mp lf lg lh mq lj lk ll ij bi translated">第一步是一个字符一个字符地分割输入。这一步被称为<a class="ae nh" href="https://en.wikipedia.org/wiki/Lexical_analysis" rel="noopener ugc nofollow" target="_blank">词法分析</a>，或标记化。主要的想法是，我们将字符组合在一起，形成我们的单词、标识符、符号等等。词法分析大多不处理像求解<code class="fe oy oz pa pb b">2+2</code>这样的逻辑问题——它只会说有三个<a class="ae nh" href="https://en.wikipedia.org/wiki/Lexical_analysis#Token" rel="noopener ugc nofollow" target="_blank">记号</a>:一个数字:<code class="fe oy oz pa pb b">2</code>，一个加号，然后是另一个数字:<code class="fe oy oz pa pb b">2</code>。</p><p id="a683" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">假设您正在编写一个类似于<code class="fe oy oz pa pb b">12+3</code>的字符串:它将读取字符<code class="fe oy oz pa pb b">1</code>、<code class="fe oy oz pa pb b">2</code>、<code class="fe oy oz pa pb b">+</code>和<code class="fe oy oz pa pb b">3</code>。我们有各自独立的角色，但我们必须把它们组合在一起；分词器的主要任务之一。例如，我们将<code class="fe oy oz pa pb b">1</code>和<code class="fe oy oz pa pb b">2</code>作为单独的字母，但是我们需要将它们放在一起，并作为单个整数进行解析。<code class="fe oy oz pa pb b">+</code>也需要被识别为加号，而不是它的文字字符值——字符代码<a class="ae nh" href="http://www.asciitable.com/" rel="noopener ugc nofollow" target="_blank">43。</a></p><figure class="nt nu nv nw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pc"><img src="../Images/54033e65d99f65a6798980fc6c7a398f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D9FGqfO5JjSX9ZYERX9M5A.jpeg"/></div></div></figure><p id="6ae1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果您可以看到代码，并以这种方式使其更有意义，那么下面的 Rust tokenizer 可以将数字分组为 32 位整数，并将加号作为<code class="fe oy oz pa pb b">Token</code>值<code class="fe oy oz pa pb b">Plus</code>。</p><div class="ip iq gp gr ir ms"><a href="https://play.rust-lang.org/?gist=070c3b6b985098a306c62881d7f2f82c&amp;version=stable&amp;mode=debug&amp;edition=2015" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd jc gy z fp mx fr fs my fu fw ja bi translated">铁锈操场</h2><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">play.rust-lang.org</p></div></div></div></a></div><p id="a2d2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="mr">您可以点击 Rust Playground 左上角的“运行”按钮，在您的浏览器中编译并执行代码。</em></p><p id="4730" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在编程语言的编译器中，词法分析器可能需要几种不同类型的标记。例如:符号、数字、标识符、字符串、运算符等。知道需要从源代码中提取哪种单独的标记完全取决于语言本身。</p><figure class="nt nu nv nw gt is"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">Example of C source code that has been lexically analyzed, and its tokens printed.</figcaption></figure><h1 id="6a45" class="ni lu jb bd lv nj ot nl ly nm ou no mb kh ov ki me kk ow kl mh kn ox ko mk ns bi translated">2.从语法上分析</h1><p id="dc70" class="pw-post-body-paragraph kq kr jb ks b kt mm kc kv kw mn kf ky kz mo lb lc ld mp lf lg lh mq lj lk ll ij bi translated">解析器确实是语法的核心。<strong class="ks jc">解析器获取由词法分析器生成的标记，尝试查看它们是否符合特定的模式，然后将这些模式与像调用函数、调用变量或数学运算这样的表达式相关联。</strong>解析器是真正定义语言语法的东西。</p><p id="6aa8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">说<code class="fe oy oz pa pb b">int a = 3</code>和<code class="fe oy oz pa pb b">a: int = 3</code>的区别在于解析器。解析器决定语法应该是什么样子。它确保括号和花括号是平衡的，每个语句都以分号结束，并且每个函数都有一个名称。当标记不符合预期模式时，解析器知道什么时候事情没有按照正确的顺序进行。</p><p id="db3a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="mr">你可以编写几种不同类型的</em> <a class="ae nh" href="https://en.wikipedia.org/wiki/Parsing#Types_of_parsers" rel="noopener ugc nofollow" target="_blank"> <em class="mr">解析器</em> </a> <em class="mr">。其中最常见的是自上而下，</em><a class="ae nh" href="https://en.wikipedia.org/wiki/Recursive_descent_parser" rel="noopener ugc nofollow" target="_blank"><em class="mr"/></a><em class="mr">递归下降解析器。递归下降解析是最容易使用和理解的解析之一。我创建的所有解析器例子都是基于递归下降的。</em></p><p id="8bb9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">解析器解析的语法可以用<a class="ae nh" href="https://en.wikipedia.org/wiki/Formal_grammar" rel="noopener ugc nofollow" target="_blank">语法</a>来概括。像<a class="ae nh" href="https://en.wikipedia.org/wiki/Extended_Backus-Naur_form" rel="noopener ugc nofollow" target="_blank"> EBNF </a>这样的语法可以描述像<code class="fe oy oz pa pb b">12+3</code>这样的简单数学运算的解析器:</p><figure class="nt nu nv nw gt is"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">EBNF grammar for simple addition and subtraction expressions.</figcaption></figure><p id="d5cc" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="mr">记住语法文件是</em> <strong class="ks jc"> <em class="mr">而不是</em> </strong> <em class="mr">解析器，而是解析器工作的概要。你可以围绕这样的语法构建一个解析器。它将由人类使用，比直接查看解析器的代码更容易阅读和理解。</em></p><p id="dca0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">该语法的解析器将是<code class="fe oy oz pa pb b">expr</code>解析器，因为它是基本上所有内容都与之相关的顶级项目。唯一有效的输入必须是任何数字，加或减，任何数字。<code class="fe oy oz pa pb b">expr</code>期待一个<code class="fe oy oz pa pb b">additive_expr</code>，这是大加减法出现的地方。<code class="fe oy oz pa pb b">additive_expr</code>先预计一个<code class="fe oy oz pa pb b">term</code>(一个数字)，然后加减，再一个<code class="fe oy oz pa pb b">term</code>。</p><figure class="nt nu nv nw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pd"><img src="../Images/385783cee996137606458f593911b3e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p6qemn-x4-KqbQMHa15qPQ.jpeg"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">Example AST generated for parsing 12+3.</figcaption></figure><p id="8456" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc">解析器在解析时生成的树称为</strong> <a class="ae nh" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank"> <strong class="ks jc">抽象语法树</strong> </a> <strong class="ks jc">，简称 AST。</strong>AST 包含所有的操作。解析器不计算操作，它只是按照正确的顺序收集它们。</p><p id="e57d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我添加了之前的 lexer 代码，这样它就能匹配我们的语法，并能生成如图所示的 ASTs。我用注释<code class="fe oy oz pa pb b">// BEGIN PARSER //</code>和<code class="fe oy oz pa pb b">// END PARSER //</code>标记了新解析器代码的开头和结尾。</p><div class="ip iq gp gr ir ms"><a href="https://play.rust-lang.org/?gist=205deadb23dbc814912185cec8148fcf&amp;version=stable&amp;mode=debug&amp;edition=2015" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd jc gy z fp mx fr fs my fu fw ja bi translated">铁锈操场</h2><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">play.rust-lang.org</p></div></div></div></a></div><p id="8349" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们实际上可以走得更远。比方说，我们希望支持没有运算的数字输入，或者添加乘法和除法，甚至添加优先级。通过快速修改语法文件，并在解析器代码中反映出来，这一切都是可能的。</p><figure class="nt nu nv nw gt is"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">The new grammar.</figcaption></figure><div class="ip iq gp gr ir ms"><a href="https://play.rust-lang.org/?gist=1587a5dd6109f70cafe68818a8c1a883&amp;version=nightly&amp;mode=debug&amp;edition=2018" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd jc gy z fp mx fr fs my fu fw ja bi translated">铁锈操场</h2><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">play.rust-lang.org</p></div></div></div></a></div><figure class="nt nu nv nw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pe"><img src="../Images/c00c0f3818039f0f5ac03373ab7f9912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OGlmE7PLYnK0H_apbU0kcg.gif"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk">Scanner (a.k.a. lexer) and parser example for C. Starting from the sequence of characters "<code class="fe oy oz pa pb b">if(net&gt;0.0)total+=net*(1.0+tax/100.0);"</code>, the scanner composes a sequence of tokens, and categorizes each of them, e.g. as identifier, reserved word, number literal, or operator. The latter sequence is transformed by the parser into a syntax tree, which is then treated by the remaining compiler phases. The scanner and parser handles the regular and properly context-free parts of the grammar for C, respectively. Credit: Jochen Burghardt. <a class="ae nh" href="https://commons.wikimedia.org/wiki/File:Xxx_Scanner_and_parser_example_for_C.gif" rel="noopener ugc nofollow" target="_blank">Original</a>.</figcaption></figure><h1 id="984a" class="ni lu jb bd lv nj ot nl ly nm ou no mb kh ov ki me kk ow kl mh kn ox ko mk ns bi translated">3.生成代码</h1><p id="9086" class="pw-post-body-paragraph kq kr jb ks b kt mm kc kv kw mn kf ky kz mo lb lc ld mp lf lg lh mq lj lk ll ij bi translated">代码生成器接受一个 AST 并发出代码或汇编中的等价代码。<strong class="ks jc">代码生成器必须以递归下降的顺序遍历 AST 中的每一项——很像解析器的工作方式——然后发出等价的代码。</strong></p><div class="ip iq gp gr ir ms"><a href="https://godbolt.org/z/K8416_" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd jc gy z fp mx fr fs my fu fw ja bi translated">编译器资源管理器- Rust (rustc 1.29.0)</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">pub fn main(){ let a = 10 * 3；}</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">godbolt.org</p></div></div><div class="nb l"><div class="pf l nd ne nf nb ng ix ms"/></div></div></a></div><p id="c50f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果打开上面的链接，可以看到左边的示例代码生成的程序集。汇编代码的第 3 行和第 4 行显示了编译器在 AST 中遇到常量时是如何为它们生成代码的。</p><p id="763b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="mr">god bolt 编译器资源管理器是一款优秀的工具，允许你用高级编程语言编写代码，并查看其生成的汇编代码。您可以用它来看看应该生成什么样的代码，但是不要忘记在您的语言的编译器中添加优化标志，看看它有多聪明。(</em> <code class="fe oy oz pa pb b"><em class="mr">-O</em></code> <em class="mr">为铁锈)</em></p><p id="8f38" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果您对编译器如何将局部变量保存到 ASM 的内存中感兴趣，本文(“代码生成”一节)将详细解释<a class="ae nh" href="https://stackoverflow.com/a/80113" rel="noopener ugc nofollow" target="_blank">堆栈</a>。大多数情况下，当变量不在本地时，高级编译器会在堆上为变量分配内存，并将它们存储在堆上，而不是堆栈上。你可以在<a class="ae nh" href="https://stackoverflow.com/a/18446414" rel="noopener ugc nofollow" target="_blank">这个 StackOverflow 回答</a>中阅读更多关于存储变量的内容。</p><p id="795c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因为组装是一个完全不同的复杂的主题，所以我不会详细讨论它。我只想强调代码生成器的重要性和作用。此外，代码生成器不仅仅可以生成汇编。<a class="ae nh" href="https://haxe.org/" rel="noopener ugc nofollow" target="_blank"> Haxe </a>编译器有一个<a class="ae nh" href="https://en.wikipedia.org/wiki/Compiler#Back_end" rel="noopener ugc nofollow" target="_blank"> <em class="mr">后端</em> </a>可以生成超过六种不同的编程语言；包括 C++、Java 和 Python。</p><p id="5704" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="mr">后端指编译器的代码生成器或评估器；因此，前端是词法分析器和语法分析器。还有一个中间端，它主要与优化和 IRs 有关，这将在本节后面解释。后端大多与前端无关，只关心自己收到的 AST。这意味着一个人可以为几个不同的前端或语言重用同一个后端。臭名昭著的</em> <a class="ae nh" href="https://gcc.gnu.org/" rel="noopener ugc nofollow" target="_blank"> <em class="mr"> GNU 编译器合集</em> </a> <em class="mr">就是如此。</em></p><p id="2abe" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我没有比我的 C 编译器后端更好的代码生成器的例子了；你可以在这里找到<a class="ae nh" href="https://github.com/asmoaesl/ox/blob/master/src/generator.rs" rel="noopener ugc nofollow" target="_blank"><em class="mr"/></a><em class="mr">。</em></p><p id="5393" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">生成汇编后，它将被写入一个新的汇编文件(<code class="fe oy oz pa pb b">.s</code>或<code class="fe oy oz pa pb b">.asm</code>)。然后，该文件将通过汇编器传递，汇编器是用于汇编的编译器，它将生成等价的二进制文件。然后，二进制代码将被写入一个名为目标文件的新文件中(<code class="fe oy oz pa pb b">.o</code>)。</p><p id="cf0c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc">目标文件是机器代码，但不可执行。为了使它们成为可执行的，目标文件需要被链接在一起。链接器获取这个通用机器码，并使其成为可执行文件，一个<a class="ae nh" href="https://en.wikipedia.org/wiki/Library_(computing)#Shared_libraries" rel="noopener ugc nofollow" target="_blank">共享库</a>，或者一个<a class="ae nh" href="https://en.wikipedia.org/wiki/Library_(computing)#Static_libraries" rel="noopener ugc nofollow" target="_blank">静态库</a>。<em class="mr">更多关于联系人</em> <a class="ae nh" href="https://en.wikipedia.org/wiki/Linker_(computing)#Overview" rel="noopener ugc nofollow" target="_blank"> <em class="mr">这里</em> </a> <em class="mr">。</em></strong></p><p id="eb4d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="mr">链接程序是根据操作系统而变化的实用程序。一个单独的第三方链接器应该能够编译后端生成的目标代码。在制作编译器时，应该不需要创建自己的链接器。</em></p><figure class="nt nu nv nw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pg"><img src="../Images/9260a3f81b31e3b877af7e5ab3c25272.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*PP9A2JnhqTov_jCgqPCLxw.png"/></div></div></figure><p id="2912" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一个编译器可能有一个<a class="ae nh" href="https://en.wikipedia.org/wiki/Intermediate_representation" rel="noopener ugc nofollow" target="_blank">中间表示</a>，或者 IR。<strong class="ks jc">IR 是为了优化或翻译成另一种语言而无损地表示原始指令。</strong>IR 不是原始源代码；IR 是为了在代码中找到潜在的优化而进行的无损简化。<a class="ae nh" href="https://en.wikipedia.org/wiki/Loop_unrolling" rel="noopener ugc nofollow" target="_blank">循环展开</a>和<a class="ae nh" href="https://en.wikipedia.org/wiki/Automatic_vectorization" rel="noopener ugc nofollow" target="_blank">矢量化</a>使用 IR 完成。更多与 IR 相关的优化示例可以在<a class="ae nh" href="http://www.keithschwarz.com/cs143/WWW/sum2011/lectures/140_IR_Optimization.pdf" rel="noopener ugc nofollow" target="_blank">本 PDF </a>中找到。</p><h1 id="fc33" class="ni lu jb bd lv nj ot nl ly nm ou no mb kh ov ki me kk ow kl mh kn ox ko mk ns bi translated">结论</h1><p id="353b" class="pw-post-body-paragraph kq kr jb ks b kt mm kc kv kw mn kf ky kz mo lb lc ld mp lf lg lh mq lj lk ll ij bi translated">当你理解了编译器，你就能更有效地使用你的编程语言。也许有一天你会对制作自己的编程语言感兴趣？我希望这对你有帮助。</p><h1 id="438a" class="ni lu jb bd lv nj ot nl ly nm ou no mb kh ov ki me kk ow kl mh kn ox ko mk ns bi translated">资源和延伸阅读</h1><ul class=""><li id="864b" class="od oe jb ks b kt mm kw mn kz ph ld pi lh pj ll pk oj ok ol bi translated"><a class="ae nh" href="http://craftinginterpreters.com/" rel="noopener ugc nofollow" target="_blank">http://craftinginterpreters.com/</a>—指导你用 C 和 Java 创建一个解释器。</li><li id="3cb8" class="od oe jb ks b kt om kw on kz oo ld op lh oq ll pk oj ok ol bi translated"><a class="ae nh" href="https://norasandler.com/2017/11/29/Write-a-Compiler.html" rel="noopener ugc nofollow" target="_blank">https://norasandler.com/2017/11/29/Write-a-Compiler.html</a>——可能是对我最有益的“编写编译器”教程。</li><li id="49a2" class="od oe jb ks b kt om kw on kz oo ld op lh oq ll pk oj ok ol bi translated">我的 C 编译器和科学计算器解析器可以在<a class="ae nh" href="https://github.com/asmoaesl/ox" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae nh" href="https://github.com/asmoaesl/rsc" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</li><li id="fad2" class="od oe jb ks b kt om kw on kz oo ld op lh oq ll pk oj ok ol bi translated">另一种类型的解析器的例子，称为优先攀爬解析器，可以在<a class="ae nh" href="https://play.rust-lang.org/?gist=d9db7cfad2bb3efb0a635cddcc513839&amp;version=stable&amp;mode=debug&amp;edition=2015" rel="noopener ugc nofollow" target="_blank">这里</a>找到。致谢:韦斯利·诺里斯。</li></ul></div></div>    
</body>
</html>