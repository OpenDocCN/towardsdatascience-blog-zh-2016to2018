<html>
<head>
<title>Custom Keras Generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">定制 Keras 生成器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/writing-custom-keras-generators-fe815d992c5a?source=collection_archive---------0-----------------------#2018-02-07">https://towardsdatascience.com/writing-custom-keras-generators-fe815d992c5a?source=collection_archive---------0-----------------------#2018-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f13a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">定制您的数据生成器，加快培训速度</h2></div><p id="c7f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<em class="le"> Keras </em>生成器的想法是在训练过程中即时获得成批的输入和相应的输出，例如读入 100 幅图像，获得相应的 100 个标签向量，然后将这组输入馈送到 gpu 进行训练步骤。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/d324547e180a0cbd017336237ff3240b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wwnExqe720PPHykHhs5Hqw.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk"><strong class="bd lv">Keras</strong> : keras.io</figcaption></figure><p id="49de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我面临的问题是标准的 Keras 生成器的内存需求。内存生成器创建原始数据的副本，并且必须将<code class="fe lw lx ly lz b">dtype</code>从<code class="fe lw lx ly lz b">uint8</code>转换为<code class="fe lw lx ly lz b">float64</code>。另一方面，从目录中读取的<em class="le"> Keras </em>生成器期望每个类中的图像都在一个独立的目录中(在多标签问题、分割问题等中是不可能的)。)</p><p id="6264" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我喜欢将批处理生成器分为 4 个步骤:</p><pre class="lg lh li lj gt ma lz mb mc aw md bi"><span id="902c" class="me mf it lz b gy mg mh l mi mj">1. Get input            : input_path -&gt; image<br/>2. Get output           : input_path -&gt; label<br/>3. Pre-process input    : image -&gt; pre-processing step -&gt; image<br/>4. Get generator output : <em class="le">( </em><em class="le">batch_input, batch_labels )</em></span></pre><p id="4402" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le">步骤 1 : </em> </strong>定义一个函数来获取输入(可以是子集化一个 numpy 数组，pandas dataframe，从磁盘读入等等。) :</p><pre class="lg lh li lj gt ma lz mb mc aw md bi"><span id="6a9e" class="me mf it lz b gy mg mh l mi mj">from skimage.io import imread</span><span id="1696" class="me mf it lz b gy mk mh l mi mj">def get_input(path):<br/>    <br/>    img = imread( path )<br/>    <br/>    return( img )</span></pre><p id="620e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le">第二步:</em> </strong>定义一个函数来获取输出:</p><pre class="lg lh li lj gt ma lz mb mc aw md bi"><span id="bfd1" class="me mf it lz b gy mg mh l mi mj">import numpy as np<br/>import pandas as pd</span><span id="34d3" class="me mf it lz b gy mk mh l mi mj">def get_output( path, label_file = None ):<br/>    <br/>    img_id = path.split('/')[-1].split('.')[0]<br/>    labels = label_file.loc[img_id].values<br/>    <br/>    return(labels)</span></pre><p id="0700" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le">第三步:</em> </strong>定义一个函数对输入进行预处理:</p><pre class="lg lh li lj gt ma lz mb mc aw md bi"><span id="9f1d" class="me mf it lz b gy mg mh l mi mj">def preprocess_input( image ):<br/>    <br/>    --- Rescale Image<br/>    --- Rotate Image<br/>    --- Resize Image<br/>    --- Flip Image<br/>    --- PCA etc.<br/>    <br/>    return( image )</span></pre><p id="790d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le">第四步:</em> </strong>把所有的东西放在一起定义你的生成器:</p><pre class="lg lh li lj gt ma lz mb mc aw md bi"><span id="9bca" class="me mf it lz b gy mg mh l mi mj">def image_generator(files, label_file, batch_size = 64):<br/>    <br/>    while True:</span><span id="417b" class="me mf it lz b gy mk mh l mi mj">          # Select files (paths/indices) for the batch<br/>          batch_paths  = np.random.choice(a    = files, <br/>                                          size = batch_size)<br/>          batch_input  = []<br/>          batch_output = [] <br/>          <br/>          # Read in each input, perform preprocessing and get labels</span><span id="7d3b" class="me mf it lz b gy mk mh l mi mj">          for input_path in batch_paths:</span><span id="24e3" class="me mf it lz b gy mk mh l mi mj">              input = get_input(input_path )<br/>              output = get_output(input_path,label_file=label_file )<br/>            <br/>              input = preprocess_input(image=input)<br/>              batch_input += [ input ]<br/>              batch_output += [ output ]</span><span id="1305" class="me mf it lz b gy mk mh l mi mj">          # Return a tuple of (input, output) to feed the network</span><span id="4b8b" class="me mf it lz b gy mk mh l mi mj">          batch_x = np.array( batch_input )<br/>          batch_y = np.array( batch_output )<br/>        <br/>          yield( batch_x, batch_y )</span></pre><p id="ab40" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，您可以添加特定数据集定义的预处理功能，将输出作为图像掩模(分割问题、定位问题等)。).</p><p id="ba1f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这之后，使用这个定制生成器与使用一个预定义的<em class="le">Keras</em>imagedata generator 并简单地将生成器对象传递给<code class="fe lw lx ly lz b">model.fit_generator().</code>是一样的</p></div></div>    
</body>
</html>