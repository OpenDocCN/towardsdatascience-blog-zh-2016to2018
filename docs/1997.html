<html>
<head>
<title>R Formula Tutorial For Beginner</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者 r 公式教程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/r-formula-tutorial-for-beginners-1a6d88e2d0bb?source=collection_archive---------5-----------------------#2017-11-30">https://towardsdatascience.com/r-formula-tutorial-for-beginners-1a6d88e2d0bb?source=collection_archive---------5-----------------------#2017-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/7bacd7cb916a6d033df8d6f4d32fa7da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*iYXY7GBS3RGdEkPrOAfP5Q.jpeg"/></div></figure><p id="5089" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">想一想，R 中的很多函数都利用了公式:像<code class="fe ks kt ku kv b">ggplot2</code>、<code class="fe ks kt ku kv b">stats</code>、<code class="fe ks kt ku kv b">lattice</code>、<code class="fe ks kt ku kv b">dplyr</code>等包都在用！使用这些 R 对象的常见函数示例有<code class="fe ks kt ku kv b">glm()</code>、<code class="fe ks kt ku kv b">lm()</code>、<code class="fe ks kt ku kv b">facet_wrap()</code>等。但是这些公式到底是什么，为什么要用呢？</p><p id="6968" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这些只是本教程希望回答的一些问题:</p><p id="557a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">提示</strong>:您有兴趣在统计建模的背景下学习更多的公式吗？看看 DataCamp 的<a class="ae kw" href="https://www.datacamp.com/courses/multiple-and-logistic-regression" rel="noopener ugc nofollow" target="_blank">多元与 Logistic 回归</a>课程。</p><h1 id="d616" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">R 中的数据结构</h1><p id="0229" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">因为公式是 R 编程语言中的一个特殊类，所以简单地修改一下这种编程语言中可用的数据类型和数据结构是一个好主意。</p><p id="8f37" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">记住 R 是一种面向对象的编程语言:这种语言是围绕对象来组织的。R 中的一切都是对象。</p><p id="720b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们从头开始:在编程中，你使用数据结构存储数据，函数处理数据。数据结构是组织在计算机内存中的数据的接口。正如 R 语言定义所说，R 并不提供对计算机内存的直接访问，而是提供一些你可以称为“对象”的特殊数据结构。每个数据结构都是为优化存储、访问或处理的某个方面而设计的。</p><p id="ceac" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">R 中的五种主要数据结构是:</p><ul class=""><li id="712c" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated">原子向量，</li><li id="84ed" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">列表，</li><li id="1d54" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">矩阵，</li><li id="ce43" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">数据帧，以及</li><li id="8630" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">排列</li></ul><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="c9ca" class="mw ky iq kv b gy mx my l mz na"># Create variables <br/>a &lt;- c(1,2,3,4,5,6,7,8,9) <br/>b &lt;- list(x = LifeCycleSavings[,1], y = LifeCycleSavings[,2])</span></pre><p id="f749" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">提示</strong>:你可以使用<code class="fe ks kt ku kv b">typeof()</code>函数返回一个 R 对象的类型。对象的类型告诉您关于任何对象的(R 内部)类型或存储模式的更多信息:</p><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="3101" class="mw ky iq kv b gy mx my l mz na"># Retrieve the types of `a` and `b` <br/>typeof(a) <br/>typeof(b)</span></pre><p id="ec45" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">双份</p><p id="b9fa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">'列表'</p><p id="e454" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在上面定义变量<code class="fe ks kt ku kv b">a</code>和<code class="fe ks kt ku kv b">b</code>的例子中，您可以看到数据结构包含数据元素序列。这些元素可以是相同或不同的数据类型。您可以在 R 中找到以下 6 种原子数据类型:</p><ul class=""><li id="ebfa" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated">数字，如<code class="fe ks kt ku kv b">100</code>、<code class="fe ks kt ku kv b">5</code>、<code class="fe ks kt ku kv b">4</code>，包含整数。</li><li id="c1eb" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">字符，如<code class="fe ks kt ku kv b">"Hello"</code>、<code class="fe ks kt ku kv b">"True"</code>或<code class="fe ks kt ku kv b">"23.4"</code>，由键盘字符串组成。；</li><li id="6dc4" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">逻辑的，如<code class="fe ks kt ku kv b">TRUE</code>或<code class="fe ks kt ku kv b">FALSE</code>，由“真值”组成；</li><li id="2394" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">raw，如<code class="fe ks kt ku kv b">48 65 6c 6c 6f</code>，由比特组成；</li><li id="a23a" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">复数，如<code class="fe ks kt ku kv b">2+5i</code>，包含复数；最后一点，</li><li id="b06c" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">double，如<code class="fe ks kt ku kv b">3.14</code>，包含十进制数。</li></ul><p id="91cf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在 r 中，几乎所有的对象都有属性。例如，您可能已经知道矩阵和数组只是简单的向量，属性<code class="fe ks kt ku kv b">dim</code>和可选的<code class="fe ks kt ku kv b">dimnames</code>被附加到向量上。属性用于实现 r 中使用的类结构。作为一种面向对象的编程语言，类的概念以及方法是它的核心。类是对象的定义。它定义了对象包含的信息以及如何使用该对象。</p><p id="aa7f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">看看下面的例子:</p><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="eb9e" class="mw ky iq kv b gy mx my l mz na"># Retrieve the classes of `a` and `b` <br/>class(a) <br/>class(b)</span></pre><p id="86ed" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">'数字'</p><p id="cdaa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">'列表'</p><p id="3e44" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">注意</strong>如果一个对象没有<code class="fe ks kt ku kv b">class</code>属性，它有一个隐式类，“矩阵”、“数组”或<code class="fe ks kt ku kv b">mode()</code>函数的结果。</p><p id="52fb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可能遇到的一些特殊类是日期和公式；而这最后一个就是今天教程的题目！</p><h1 id="d603" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">R 中的公式是什么？</h1><p id="523e" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">当你阅读本教程的介绍时，你可能已经看到了在使用像<code class="fe ks kt ku kv b">ggplot2</code>这样的包或者像<code class="fe ks kt ku kv b">lm()</code>这样的函数时出现的公式。因为您通常在这些函数调用中使用公式来表达统计模型的思想，所以在建模函数和一些图形函数中经常使用这些 R 对象是合乎逻辑的。</p><p id="eb6f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对吗？</p><p id="7d96" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，公式并不局限于模型。它们是一个强大的通用工具，允许您捕获两件事情:</p><ul class=""><li id="c461" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated">未赋值的表达式，以及</li><li id="dbcc" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">创建表达式的上下文或环境。</li></ul><p id="e64b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这解释了为什么在函数调用中使用公式来生成“特殊行为”:它们允许您捕获变量的值，而无需对它们求值，以便它们可以被函数解释。</p><p id="3550" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">记住数据结构后，您就可以将这些 R 对象描述为“语言”对象或未赋值的表达式，它们具有一个“公式”类和一个存储环境的属性。</p><p id="ef5d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在上一节中，您看到了对象具有某些(R internal)类型，这些类型指示对象是如何存储的。在这种情况下，公式是“语言”类型的对象。</p><p id="1599" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是这到底意味着什么呢？</p><p id="eaf3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">嗯，当你处理 R 语言本身时，你通常会遇到这种类型的对象。为了更好地理解这一点，请看下面的例子:</p><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="26fa" class="mw ky iq kv b gy mx my l mz na"># Retrieve the object type <br/>typeof(quote(x * 10)) </span><span id="c0be" class="mw ky iq kv b gy nb my l mz na"># Retrieve the class <br/>class(quote(x * 10))</span></pre><p id="249d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">“语言”</p><p id="d6b9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">“呼叫”</p><p id="a5b7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在上面的例子中，你要求 R 返回<code class="fe ks kt ku kv b">quote(x*10)</code>的类型和类。结果你看到<code class="fe ks kt ku kv b">quote(x*10)</code>的类型是<code class="fe ks kt ku kv b">'language'</code>，而<code class="fe ks kt ku kv b">class</code>是<code class="fe ks kt ku kv b">'call'</code>。</p><p id="4fb1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这绝对不是一个公式，因为你需要用<code class="fe ks kt ku kv b">class()</code>来返回<code class="fe ks kt ku kv b">'formula'</code>！</p><p id="060e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但那是什么呢？</p><p id="1fa7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">R 中的公式的特征是波浪号操作符<code class="fe ks kt ku kv b">~</code>。有了这个操作符，您实际上可以说:“捕捉这段代码的含义，而不用马上对它进行评估”。这也解释了为什么你可以把 R 中的公式看作一个“引用”操作符。</p><p id="d336" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是公式到底是什么样子的呢？仔细看看下面一行代码:</p><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="b5e3" class="mw ky iq kv b gy mx my l mz na"># A formula <br/>c &lt;- y ~ x <br/>d &lt;- y ~ x + b </span><span id="5222" class="mw ky iq kv b gy nb my l mz na"># Double check the class of `c` <br/>class(c)</span></pre><p id="3bd0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">公式</p><p id="14bb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">波浪号(<code class="fe ks kt ku kv b">~</code>)左侧的变量称为“因变量”，而右侧的变量称为“自变量”，由加号<code class="fe ks kt ku kv b">+</code>连接。</p><p id="c46f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">很高兴知道这些变量的名称会根据上下文而变化。你可能已经看到自变量以“预测值(变量)”、“受控变量”、“特征”等形式出现。同样，你可能会遇到因变量，如“反应变量”、“结果变量”或“标签”。</p><p id="e931" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">注意</strong>尽管您在上面的代码块中定义的公式<code class="fe ks kt ku kv b">d</code>包含几个变量，但公式的基本结构实际上只是波浪号<code class="fe ks kt ku kv b">~</code>和至少一个独立或右侧变量。</p><p id="1279" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">记住</strong>公式实际上是具有存储环境属性的语言对象:</p><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="bd0a" class="mw ky iq kv b gy mx my l mz na"># Return the type of `d` <br/>typeof(d) </span><span id="4410" class="mw ky iq kv b gy nb my l mz na"># Retrieve the attributes of `d` <br/>attributes(d)</span></pre><p id="6d71" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">“语言”</p><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="fbd2" class="mw ky iq kv b gy mx my l mz na">$class [1] "formula" <br/>$.Environment &lt;environment: R_GlobalEnv&gt;</span></pre><p id="5a12" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如你在上面的例子中看到的，公式中包含的变量可以是向量。但是，您经常会看到公式中包含的变量来自数据框，就像下面的示例一样:</p><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="5057" class="mw ky iq kv b gy mx my l mz na">Sepal.Width ~ Petal.Width + log(Petal.Length) + Species</span></pre><p id="57fe" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">注意</strong>当创建公式本身时，不会访问任何已分配给公式中符号的数据值。</p><p id="9f78" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在你已经知道了 R 中的公式是什么样子，它们是什么，最好提一下底层的公式对象是不同的，这取决于你有一个单边还是双边的公式。你可以通过观察左边的变量来识别前者。如果没有，就像<code class="fe ks kt ku kv b">~ x</code>中一样，你有一个片面的公式。</p><p id="b27c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这也意味着单侧公式的长度为 2，而双侧公式的长度为 3。</p><p id="5cda" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">不完全信服？看看下面的代码块。您可以借助方括号:<code class="fe ks kt ku kv b">[[</code>和<code class="fe ks kt ku kv b">]]</code>来访问公式的元素。</p><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="9b8a" class="mw ky iq kv b gy mx my l mz na">e &lt;- ~ x + y + z <br/>f &lt;- y ~ x + b </span><span id="06d2" class="mw ky iq kv b gy nb my l mz na"># Return the length of `g` <br/>length(e) <br/>length(f) </span><span id="732f" class="mw ky iq kv b gy nb my l mz na"># Retrieve the elements at index 1 and 2 <br/>e[[1]] <br/>e[[2]] <br/>f[[3]]</span></pre><p id="8149" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi">2</p><p id="86c2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi">3</p><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="57ff" class="mw ky iq kv b gy mx my l mz na">`~` x + y + z <br/>x + b</span></pre><h1 id="1c94" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">为什么在 R 中使用公式？</h1><p id="d07c" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">如您所见，公式是功能强大的通用工具，允许您捕获变量的值，而无需对它们求值，以便它们可以被函数解释。这已经是为什么应该在 r 中使用公式的答案的一部分了。</p><p id="7e6a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此外，您使用这些 R 对象来表达变量之间的关系。</p><p id="be39" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">比如下面代码块中的第一行代码，你用第一行代码说“y 是 x，a，b 的函数”；当然，你也可以遇到更复杂的公式，比如在第二行代码中，你的意思是“萼片宽度是花瓣宽度的函数，取决于物种”。</p><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="6854" class="mw ky iq kv b gy mx my l mz na">y ~ x + a + b <br/>Sepal.Width ~ Petal.Width | Species</span></pre><h1 id="43b7" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">在 R 中使用公式</h1><p id="69e7" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">现在，您已经了解了这些特殊 R 对象的“是什么”和“为什么”,是时候了解如何使用基本公式以及更复杂的公式了！在本节中，您不仅会看到如何创建和连接基本公式，还会发现如何在运算符的帮助下构建更复杂的公式。</p><p id="8ec1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> <em class="nc">如果您想了解更多关于如何在 R 中创建公式、连接公式、使用公式运算符以及如何在 R 中检查公式的信息，请访问</em> </strong> <a class="ae kw" href="https://www.datacamp.com/community/tutorials/r-formula-tutorial" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> <em class="nc">原始教程</em> </strong> </a> <strong class="jw ir"> <em class="nc">。</em> </strong></p><h1 id="9bcb" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">何时使用公式</h1><p id="a2f4" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">到目前为止，您已经了解到 R 公式是通用工具，并不局限于建模，并且您已经看到了一些可以使用公式的例子。在本节中，您将更深入地了解最后一个主题:您将看到一些可以利用这些工具的案例。当然，您将会涉及到诸如<code class="fe ks kt ku kv b">lattice</code>和<code class="fe ks kt ku kv b">stats</code>之类的软件包的建模和图形功能，但是您也将会涉及到<code class="fe ks kt ku kv b">dplyr</code>中的非标准评估。</p><p id="0219" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> <em class="nc">转到</em> </strong> <a class="ae kw" href="https://www.datacamp.com/community/tutorials/r-formula-tutorial" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> <em class="nc">原创教程</em> </strong> </a> <strong class="jw ir"> <em class="nc">阅读全节。</em> </strong></p><h1 id="62f0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">r 配方奶粉包</h1><p id="a3d1" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">之前，您已经看到您可以使用<code class="fe ks kt ku kv b">as.formula</code>、<code class="fe ks kt ku kv b">update()</code>、<code class="fe ks kt ku kv b">all.vars</code>等函数来创建和检查您的公式。...这些都是简单的操作和处理，但是高级的公式处理呢？也许下面这些套餐会让你有些兴趣！</p><h1 id="9fb9" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><code class="fe ks kt ku kv b">Formula</code>套餐</h1><p id="f93b" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">最近，这个包发表在 CRAN 上。这款套装非常适合那些想让配方更上一层楼的人。这个包扩展了基类<code class="fe ks kt ku kv b">formula</code>。</p><p id="1f4a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">更具体地说，<code class="fe ks kt ku kv b">Formula</code>对象扩展了基本的公式对象:使用这个包，您实际上可以定义公式，这些公式接受一个附加的公式操作符<code class="fe ks kt ku kv b">|</code>来分隔多个部分，或者可以在左侧包含所有的公式操作符(包括管道字符)来支持多个响应。</p><p id="3219" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您将能够创建的公式示例如下:</p><ul class=""><li id="6871" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated">多部分公式，如<code class="fe ks kt ku kv b">y ~ x1 + x2 | u1 + u2 + u3 | v1 + v2</code></li><li id="ae3f" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">多响应公式，如<code class="fe ks kt ku kv b">y1 + y2 ~ x1 + x2 + x3</code></li><li id="12f3" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">多部分响应，如<code class="fe ks kt ku kv b">y1 | y2 + y3 ~ x</code>，以及</li><li id="51d7" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">以上三者的组合。</li></ul><pre class="mo mp mq mr gt ms kv mt mu aw mv bi"><span id="aa78" class="mw ky iq kv b gy mx my l mz na"># Load package <br/>library(Formula) </span><span id="5a56" class="mw ky iq kv b gy nb my l mz na"># Create formulas <br/>f1 &lt;- y ~ x1 + x2 | z1 + z2 + z3 <br/>F1 &lt;- Formula(f1) </span><span id="704a" class="mw ky iq kv b gy nb my l mz na"># Retrieve the class of `F1` <br/>class(F1)</span></pre><p id="3ab3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">注意</strong>功能<code class="fe ks kt ku kv b">as.formula()</code>和<code class="fe ks kt ku kv b">is.formula()</code>在这个包中也被更新:你将使用<code class="fe ks kt ku kv b">is.Formula()</code>和<code class="fe ks kt ku kv b">as.Formula()</code>来代替！</p><p id="be47" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这里阅读更多<a class="ae kw" href="https://www.rdocumentation.org/packages/Formula/versions/1.2-2" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="08df" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae kw" href="https://www.rdocumentation.org/packages/formula.tools/versions/1.5.4" rel="noopener ugc nofollow" target="_blank">这个包</a>是最近发布的，它为你提供了“操作公式、表达式、调用、赋值和其他 R 对象的编程工具”。这是一大堆，但本质上，这一切都归结为:您可以使用这个包来访问和修改公式结构，以及提取和替换那些 R 对象的名称和符号。这个包裹是克里斯托弗·布朗写的。</p><p id="a6f9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在使用这个包时，您可能会发现以下一些有用的东西:</p><ul class=""><li id="45d3" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated"><code class="fe ks kt ku kv b">get.vars()</code>:代替<code class="fe ks kt ku kv b">all.vars()</code>，这个函数会从各种 R 对象中提取变量名，但是所有符号等。将被插入到变量的名称中。</li><li id="b0c0" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated"><code class="fe ks kt ku kv b">invert()</code>:您可以使用此功能反转对象中的运算符，如公式。</li><li id="585e" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated"><code class="fe ks kt ku kv b">is.one.sided()</code>:这个函数可以很方便的判断一个函数是单边的还是双边的。</li></ul><p id="975b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">记住</strong>一个公式如果长这样就是片面的:<code class="fe ks kt ku kv b">~x</code>；当表述为<code class="fe ks kt ku kv b">x~y</code>时，它将是双面的。</p><p id="a179" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> <em class="nc">有兴趣了解更多套餐？查看</em> </strong> <a class="ae kw" href="https://www.datacamp.com/community/tutorials/r-formula-tutorial" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> <em class="nc">原教程</em> </strong> </a> <strong class="jw ir"> <em class="nc">。</em> </strong></p><h1 id="16e4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">还有更多的发现！</h1><p id="cca5" class="pw-post-body-paragraph ju jv iq jw b jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ij bi translated">万岁！你已经完成了 R 公式的教程。如果你想了解更多，一定要看看 Hadley Wickham 的数据科学 书籍<a class="ae kw" href="http://r4ds.had.co.nz/" rel="noopener ugc nofollow" target="_blank"> <em class="nc"> R，其中有一章专门介绍 R 中的公式和模型族</em></a></p><p id="1299" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您能想出更多可以找到公式或更多可以用来操作公式的包的例子吗？随时在推特上告诉我:<a class="ae kw" href="https://twitter.com/willems_karlijn" rel="noopener ugc nofollow" target="_blank"> @willems_karlijn </a>。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="9deb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="nc">原载于</em><a class="ae kw" href="https://www.datacamp.com/community/tutorials/r-formula-tutorial" rel="noopener ugc nofollow" target="_blank"><em class="nc">www.datacamp.com</em></a><em class="nc">。</em></p></div></div>    
</body>
</html>