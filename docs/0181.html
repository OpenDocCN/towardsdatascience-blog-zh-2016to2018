<html>
<head>
<title>Linear Time vs. Logarithmic Time — Big O Notation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">线性时间与对数时间——大O符号</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/linear-time-vs-logarithmic-time-big-o-notation-6ef4227051fb?source=collection_archive---------2-----------------------#2017-03-23">https://towardsdatascience.com/linear-time-vs-logarithmic-time-big-o-notation-6ef4227051fb?source=collection_archive---------2-----------------------#2017-03-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ec31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你好。在两个多月不写/不碰代码之后，我终于回来了。我被所有的婚礼准备和计划所困扰。没有婚礼策划人，很难举办一场海外婚礼。但是这一切都是值得的，因为我们的婚礼是值得的！结婚热已经过去了，现在是时候回忆我的想法，回到编码上来了。</p><p id="272c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我开始找工作之前，很难决定先复习什么。我想我应该从经典开始——算法和数据结构，编程的核心。在任何系统中，随着数据的增长，如果使用了正确的算法，性能应该不是问题。</p><p id="845e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天，我写了一篇关于两种大O符号的博客，线性和对数算法。</p><p id="0146" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">先介绍一下大O符号的背景。</p><h2 id="f764" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">渐近分析</h2><p id="51a9" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">渐近分析是基于数学计算的，基本上是随着输入数据集的增长来衡量算法的效率(感谢维基百科！).根据应用场合的不同，还有其他类型的渐近分析，但在计算机科学中，它通常被格式化为<strong class="jp ir">大O符号</strong>。</p><h2 id="efdc" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">线性与对数</h2><p id="e9c8" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">为了容易理解大O记数法，我们来比较一下这两种算法:<strong class="jp ir">线性</strong> — O(n)和<strong class="jp ir">对数</strong> — O(log n)。</p><p id="3f64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为一个例子，我们将尝试在一个排序的数组中寻找一个数字。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="e04a" class="kl km iq lo b gy ls lt l lu lv">let numberList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></pre><h2 id="d7ed" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">线性O(n) —随着数据的增长，性能变得越来越低效。</h2><p id="8205" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">在<strong class="jp ir">线性</strong>或“强力”技术中，性能取决于输入大小。对于我们的例子，我们将通读数组中的每一项，并搜索我们需要的数字。很简单！</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="08ca" class="kl km iq lo b gy ls lt l lu lv"><em class="lw">//Logarithmic Time - O(n)</em></span><span id="2fa0" class="kl km iq lo b gy lx lt l lu lv">func linear(key: Int) {<br/>for (index, number) in numberList.enumerated() {<br/>     if number == key { <br/>        print("Value found in index \(index)")<br/>        break<br/>  }<br/> }<br/>}</span></pre><p id="f52e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，这对于我们的小数据集是可行的，但是一旦你有了成千上万甚至数百万的数据，这就不是很有效了。</p><h2 id="771d" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated"><strong class="ak">对数O(log N)-通过重复将数据集减半直到找到目标值来缩小搜索范围。</strong></h2><p id="83b8" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">使用二分搜索法-这是一种对数算法，查找数组中的中值并将其与目标值进行比较。根据目标值高于、低于或等于中值，算法将向上或向下遍历。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="c167" class="kl km iq lo b gy ls lt l lu lv">func binarySearch(key: Int, iminIndex: Int, imaxIndex: Int) {</span><span id="d9fa" class="kl km iq lo b gy lx lt l lu lv">let midIndex = round(Double(iminIndex + imaxIndex)/2)<br/>let midNumber = numberList[Int(midIndex)]<br/>var result = ""</span><span id="3d24" class="kl km iq lo b gy lx lt l lu lv"><strong class="lo ir"><em class="lw">//using recursion, we can go up or down the array and reduce the </em></strong>range<br/>if midNumber &gt; key { <strong class="lo ir"><em class="lw">//target is less than the median so traverse downwards</em></strong></span><span id="d98b" class="kl km iq lo b gy lx lt l lu lv">   binarySearch(key: key, iminIndex: iminIndex, imaxIndex:   Int(midIndex) - 1) } </span><span id="d561" class="kl km iq lo b gy lx lt l lu lv">else if midNumber &lt; key { <strong class="lo ir"><em class="lw">//target is greater than the median so traverse upwards</em></strong></span><span id="cff5" class="kl km iq lo b gy lx lt l lu lv">   binarySearch(key: key, iminIndex: Int(midIndex) + 1, imaxIndex: imaxIndex) } </span><span id="7c8a" class="kl km iq lo b gy lx lt l lu lv">else if midNumber == key { <strong class="lo ir"><em class="lw">//Found it!</em></strong><br/> <br/> print("Found it at index \(midIndex)")</span><span id="020b" class="kl km iq lo b gy lx lt l lu lv">} else { <br/>  <br/>  print("Value \(key) not found")<br/>}<br/>}</span></pre><p id="fe8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该算法的大部分是在开始，但是随着我们从数组中丢弃不相关的范围并继续减半直到我们找到目标值，它慢慢变平。</p><p id="d4fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过下面的图表，我们可以很容易地比较大多数算法如何在较小的数据集上具有相似的性能，但随着数据的增长而不断变化。</p><figure class="lj lk ll lm gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi ly"><img src="../Images/b365bdf6fd7b07c4e3ad2c86304af6a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U4dZWeXgNNrYaedRCuzTIg.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Excerpt from Swift Algorithms and Data Structures by Wayne Bishop</figcaption></figure><p id="55eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，还有其他类型的大O符号，我将在接下来的几天里讨论。再见了。</p><p id="f868" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lw">参考文献:</em></p><p id="1eff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lw">Wayne Bishop的Swift算法和数据结构</em></p><p id="ed24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae mk" href="https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/" rel="noopener ugc nofollow" target="_blank"> <em class="lw">大O批注入门</em> </a></p><p id="f1df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">维基百科:)</p></div></div>    
</body>
</html>