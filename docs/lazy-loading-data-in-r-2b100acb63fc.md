# 延迟加载 R 中的数据

> 原文：<https://towardsdatascience.com/lazy-loading-data-in-r-2b100acb63fc?source=collection_archive---------5----------------------->

最近，我发现自己需要加载和处理大型数据文件以显示在闪亮的仪表板上，但是一次性加载和处理整个文件需要很长时间。这将迫使用户在显示结果之前盯着空白屏幕看一段时间。我想出了一个粗略的解决方案来“延迟加载”数据，并根据需要处理它们。当我说延迟加载时，我的意思是只加载/处理用户当前需要的部分并缓存它们。想象一下 YouTube，一边看一边加载部分视频。

我觉得有两个关键的 R 概念值得解释，因为它们真正塑造了延迟加载技术:环境和方法调度。

# 环境和方法分派

在高层次上，我创建了一个定制的环境对象，并在需要时基于索引重写了`[`方法调度进程。

## 环境

r 不支持引用调用。在像`C++`这样的语言中，引用(指针)可以作为参数传递给函数。不过有一个解决方法，使用[环境](http://adv-r.had.co.nz/Environments.html)。环境是 R 的秘密“引用调用”。在这里，我使用它们来缓存我的使用环境的结果。当一个环境被传递给一个函数时，它被自动地通过引用传递，因为环境是**而不是**复制到 R 中的(更多[在这里](https://www.stat.berkeley.edu/~paciorek/computingTips/Pointers_passing_reference_.html))。让我们看一个例子

A `human` can have only one age. And celebrating birthdays globally increments age by one, no matter where you are.

## 数组和方法分派

下一块是[法派](http://adv-r.had.co.nz/S3.html)，具体是`[`上的法派。这非常类似于 Java 中的运算符重载。

A demonstration of method dispatch

第 11 行的输出并不是我们所期望的数组类对象的输出。定义一个`[`方法调度是将对象伪装成数组的简单方法。另请注意第 32 行，其中方法分派是用函数中的一些操作定义的，以支持返回结果之前的处理。

为什么要关心定义`[`方法调度呢？老实说，没关系。有了这种语法糖，代码读起来就简单多了。我喜欢让我的代码尽可能的干净和简单。

# 惰性装载

正如我之前提到的，我将延迟加载称为一种仅在需要时加载或处理数据的技术。想象一下 YouTube 或网飞，视频分部分加载，而且只加载用户想看的部分。如果任何一方要求用户等待完整视频下载后再播放，那将是一场灾难。从磁盘加载和处理大文件也是类似的概念。

Very generic lazy loader

这里我创建了一个接受`inputs`和`FUN`的构造函数。`inputs`可能是一个数组，一个列表，或者另一个对象，基于你的用例。这里我做了一个数组。而`FUN`是一个函数，你可以用它来处理`inputs`中的每个元素。为了启用缓存，我还定义了一个`returns`数组。同样，这可以是任何东西，而不仅仅是一个数组。在第 8 行定义自定义类对于以后创建方法分派很重要。例如，如果我想延迟处理(平方一个数)一个数的数组，这将是理想的。

```
inputs <- 1:10
FUN <- function(x) x * x
```

我们期望的`returns`是

```
returns <- c(1, 4, 9, 16, 25, 36, 49, 64, 81, 100)
```

对于 lazy process，当我从新对象`lazy.object[idx]`请求任何项目时，我希望它会返回该索引的结果。为了帮助索引，我定义了`[`方法分派。

你会注意到我所做的就是调用`FUN`并传递我想要处理的项目。如果您正在处理数组，那么您可以跳过 sapply，但是对于其他类型，这是合适的。对于列表，我会使用`lapply`。

现在，为了缓存结果以备将来使用，我们对方法 dispatch 做了一点小小的修改。

Notice no processing message for code in line 25

第 3–7 行检查`returns[i]`是否为 NA，只有当它为 NA 时才进行计算。为了演示，我修改了函数，以便在调用它时打印消息。

为了更清楚地了解情况，我还为对象定义了一个`print`方法分派。

Notice line 24, with populated values in positions 3:8

如您所见，当创建对象时，`ll`有一个空的`returns`数组。当`ll[3:8]`被计算时，结果被缓存。同样，虽然我使用了数组和一个简单的函数，但是可以很容易地修改它来支持复杂的对象和函数。

# 趣味中的多重争论

有时你需要做的不仅仅是计算平方，也许是两个数的和。因此，您的函数需要两个(或者可能更多)输入。有两种方法可以实现这一点:

1.  为环境中的第二个输入定义一个新的`inputs`,并将两个值传递给该函数
2.  使用带有多个参数的 R 的`[`

我将在下面介绍这两种方法，并说明我认为每种方法的最佳用途。

## 定义另一个`input`

我发现这种方法在两个输入相差很大或者依赖于索引时最有用。您将定义输入并更新方法分派。

对于更多的输入，这变得有些费力，但仍然比让用户等待要高一步。

## 传递带切片索引的参数

方法分派就像 r 中的任何其他函数一样，因此，像任何其他函数一样，可以向它传递多个参数。这个方法实际上要求你把`...`放在两个地方，这样你就完成了！当我对一些指数有相同的输入集时，我会使用这种方法。比如每个数字加 5。

Notice line 26

两种方法都很棒，但我个人更喜欢第二种。只是工作量更少:P

# 缓存失效

我想说这是一个高级主题，大多数普通读者可以跳过这一部分。如果输入有可能在运行时改变，那么我们需要一种方式通知加载器缓存的结果不再有效，需要重新计算。您可以创建一个新的对象，并重新计算或复制有效的结果，但有一个更简单的方法。为每个索引使用一个标志。

Cache invalidation

通过向每个索引添加一个有效的标志，加载程序只需检查是否设置了标志，并在需要时重新计算。我将`[<-`方法分派定义为语法糖。但要点是通过将有效标志设置为内部的`FALSE`来使索引无效。之后每个命令的输出有助于更好地理解该过程。

# 最后的话

当输入很大并且需要某种耗时的预处理时，这种技术非常有用。可以把这想象成一种有助于简化某些流程的设计模式。如有任何问题，请随时与我联系！

附:这是我的第一篇博客。请务必分享和评论！:D