<html>
<head>
<title>Blind Spot problem in PixelCNN</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PixelCNN 中的盲点问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/blind-spot-problem-in-pixelcnn-8c71592a14a?source=collection_archive---------2-----------------------#2017-06-15">https://towardsdatascience.com/blind-spot-problem-in-pixelcnn-8c71592a14a?source=collection_archive---------2-----------------------#2017-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7ad4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上一篇关于 PixelRNN 研究论文<a class="ae kl" href="https://medium.com/@nehamuthiyan/summary-of-pixelrnn-by-google-deepmind-7-min-read-938d9871d6d9" rel="noopener">摘要的帖子中，我们了解了 PixelCNN。</a></p><h1 id="29f5" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">PixelCNN 概述-</h1><p id="b7d3" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">行和对角线 LSTM 层覆盖了图像中像素之间的长程相关性。由于 LSTM 层的复杂性质，学习长程相关性需要计算成本。标准卷积层可以捕捉一个有界感受域，并同时计算所有像素位置的特征。PixelCNN 减少了行 LSTM 和对角线 BLSTM 中所需的计算成本，但是存在盲点问题。</p><p id="7a90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi lp translated"><span class="l lq lr ls bm lt lu lv lw lx di"> B </span> lind spot 问题基本上是，不包括上下文/历史中所有以前的像素用来计算一个像素的隐藏状态。根据 PixelRNN 的研究论文，一个像素的值取决于所有先前预测的像素。因此，盲点可以被定义为广义的信息丢失。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/67455b16e64793e2344b6bfddeea82b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:276/format:webp/1*pHQUO_2QQYQ3QCmxBI-FXQ.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Figure 1: 3x3 filter (each element is a weight)</figcaption></figure><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/a08a6e0a2c122fdea03a5c142a9b2126.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*eC3S1y8eHBwiP2GBNEevDQ.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Figure 2: 5x5 zero padded image(pink portion is the zero padding)</figcaption></figure><p id="db3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在图 2 中，红框表示要预测的值/像素。要预测的像素总是在滤波器的中心。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/e40319b730153079a2b04991ed2a61f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:284/format:webp/1*qtNJ1Dgk85uNXL_ytJEPJA.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Figure 3: filter to predict the value ‘a’ in image</figcaption></figure><p id="de05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:不为零的过滤器元素是零填充的一部分。(过滤器(绿色)中的深灰色方框表示“归零”的未来值。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/c4bb65412e2fda5dc907484a81f8ba61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*FtZ_5_jcIbMctJ4z8nodoA.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Figure 4: Filter(in green) to predict the value ‘b’</figcaption></figure><p id="2c0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值“b”(红色)表示要预测的值，青色表示先前预测的值。这里，已经预测了“a ”,并且过滤器(图 4 中的左图)包括先前预测的像素值“a ”,并且不包括未来的像素。因此,“红色”像素的值取决于先前的像素。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/4e2824fe3a85636574b1a637191da5c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*klnQNsXg2sjr-42hgM4FAw.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Figure 5: Filter(in green) to predict the value ‘e’</figcaption></figure><p id="2998" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在图 5 中，要预测的像素(“e”)在其滤波器中包括像素“d”。‘d’依赖于‘c’；c 依赖于 b，b 依赖于 a。因此，“e”直接或间接地依赖于“a”，“b”，“c”，“d”。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/a42aa6e1d6c7e53903bb129d27d04502.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*EwGsD7G2vhiXS960ulttMg.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Figure 6: Filter to predict the value ‘q’</figcaption></figure><p id="f3f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如图 6 所示，值为“q”的像素位于过滤器的中心。未来值/像素(包括“q”)已经通过将那些像素的权重设为 0 而被置零。“q”处像素的预测值取决于“k”、“l”、“m”、“p”。k '，' l '，' m '，' p '依次依赖于 f，g，h，I，它们依次依赖于 a，b，c，d，e</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/79d1ca7d4910e00992f3ffe61d30cbd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/format:webp/1*AaEYnQ8KVopx00I88KnIUg.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Figure 7: Blind Spot in predicting the pixel ‘q’</figcaption></figure><p id="054e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如图 7 所示，“q”处的像素依赖于除“j”、“n”、“o”之外的所有先前预测的像素。青色的像素不用于“q”的预测。</p><p id="e78a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是所谓的‘盲点’。使用 PixelCNN 预测的像素不依赖于所有先前的像素，这是不可取的。</p><p id="ab0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi lp translated"><span class="l lq lr ls bm lt lu lv lw lx di">为了</span>解决盲点问题，引入了“门控像素 CNN ”,这将在后面介绍。</p></div></div>    
</body>
</html>