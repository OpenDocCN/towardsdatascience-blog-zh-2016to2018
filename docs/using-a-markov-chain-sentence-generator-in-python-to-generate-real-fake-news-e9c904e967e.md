# 用 Python 中的马尔可夫链语句生成器生成‘真假新闻’。

> 原文：<https://towardsdatascience.com/using-a-markov-chain-sentence-generator-in-python-to-generate-real-fake-news-e9c904e967e?source=collection_archive---------8----------------------->

![](img/b522405b86fc7ce43793fe290b719a23.png)

Photo by [rawpixel](https://unsplash.com/@rawpixel?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

实话实说:今天的新闻头条都很疯狂。如果他们关注唐纳德·特朗普，那他们就特别疯狂。有时疯狂到你会问自己它们是否真实！你所读到的是真实发生的事情，还是仅仅是随机收集的单词被做成新闻标题？
需要一个例子？

> **川普禁止朝鲜进口独角兽**

很疯狂，对吧？当然，这个标题是基于女演员艾莉莎·米兰诺的小孩说的话。没有一个成年人会想出如此荒谬的事情…

> **“根据肖恩·斯派塞**的说法，唐纳德·川普是“骑在彩虹之上的独角兽”

哦天啊。对我来说，这听起来像是由一个随机的句子生成器生成的。可惜事实并非如此，我想知道随机生成的新闻标题会有多疯狂(或者是否会如此)。所以我决定构建一个 Python 脚本，自己看看。

该脚本由一个快速的 web scraper 组成，可以获取尽可能多的新闻标题，并在马尔可夫模型句子生成器中使用它们来创建我自己的“真正的假新闻”标题。尽管 Python dictionary 数据类型看起来最初很适合马尔可夫模型，但我想为它使用数据框和熊猫。仅仅是因为我想练习一些熊猫的功能，在这种情况下，我最终对最“优雅”的方式不感兴趣，但我想快速得到结果，并在过程中学习一些东西。首先，我设置了一个脚本，该脚本使用关键字“Donald Trump”访问一个流行的新闻网站。然后，我分离出包含标题的文本，并将它们写入一个文本文件。我发现这个网站对设置我的小代码非常有帮助:

[https://real python . com/python-web-scraping-practical-introduction/](https://realpython.com/python-web-scraping-practical-introduction/)

在任何一天，这都会给我带来大约 100 到 120 条新闻标题。不错，但是当然这样做一次只能产生很少种类的单词，我的马尔可夫链有陷入一个独特的单词链的风险——在最坏的情况下——只是重复已经存在的新闻标题。谢天谢地，在 Windows 中设置一个任务调度程序很容易，它会每天在后台执行我的文件，让我的文本文件不断增长。我现在要做的就是耐心等待，直到积累了大量的头条新闻。大约一周半后，我有了 1000 多个头条新闻。我认为对于这样一个高度不科学和荒谬的项目来说，这已经足够了。在加载了我的文本文件，并做了一些粗略的清理，消除了一些重复出现的新闻出口签名和双标点符号等。，我终于可以开始把文本放进我的马尔可夫模型了。我决定使用一个单词的前缀或“引导”。我不想详细讨论马尔可夫链，但简单来说，我会总结如下:
对于每个单词，我们收集任何句子中的每个后续单词。基于一个跟随单词与其“对手”相比的频率，我们将分配一个单词跟随某个引导单词的可能性。然后，我们可以从文本中的整个单词列表中随机选择一个单词，然后根据我们指定的可能性随机选择句子中的下一个单词。我们将逐字逐句地创建**一个新句子**，它基于我们用作输入的文本的**属性。真新闻进→真假新闻出。**

在将文本文件分割成单个单词并将它们存储在变量`‘words’`中之后，我定义了一个包含三列的 pandas 数据帧:一列`‘lead’`定义了前导单词。对于每个引导词，都有一个“跟随”的词，并在我们的第二列`‘follow’`中被捕获。第三列- `‘freq’` -将显示我们可以在文本中观察到多少次“引导”和“跟随”的特定组合。我们将在这些列中填充什么？嗯，第一列很简单——简单地说，我们文本中的每个单词都将在这一列中写成一行。对于文本中每个索引为 *i* 的单词，接下来的单词就是索引为 *i + 1* 的单词。我们简单地从再次用我们的文本填充“follow”列开始，但是这次从文本中的第二个单词开始。对于最初 *n* 行的文本，这填充了 *n-1* “跟随”字。我们文本中的最后一个单词没有自动的追随者，所以我们将使用一个合成的字符串变量来填补空白。我称之为“结束词”(请不要把它与总统在某个神秘的学徒磁带上说的类似的话混淆)。

```
import pandas as pd
dict_df = pd.DataFrame(columns = [‘lead’, ‘follow’, ‘freq’])
dict_df['lead']=words
follow = words[1:]
follow.append('EndWord')
```

在继续之前，我将创建一个单独的单词数组，包含每个句子的所有最后的单词。在我后面的代码中，我将使用这些结束词来“自然地”结束我随机生成的句子。这有一个很好的副作用，我不必担心我的马尔可夫链会“穿过”标题，这意味着一个标题的最后一个词不应该被认为是下一个标题的第一个词的线索。毕竟，我不是在处理一个连续的文本，而是在处理一个个独立的句子。通过在我的句子生成器到达这样一个`end_word`之后对我的句子进行删减，这不应该是一个问题。

```
end_words = []
for word in words:
    if word[-1] in ['.','!','?'] and word != '.':
        end_words.append(word)
print(end_words)
```

到目前为止一切顺利。现在，我统计引导词和跟随词的每个组合的出现次数，并使用 *group_by* 和 *transform* 将结果分配给 frequency 列。

```
dict_df['freq']= dict_df.groupby(by=['lead','follow'])['lead','follow'].transform('count').copy()
```

这些行仍然不是惟一的，所以在使用 Python 中的 pivot 功能创建一个大矩阵之前，我删除了重复的行，其中每个引导词作为行索引，每个跟随词作为列。然后，行 *i* 中的引导词和列 *j* 中的跟随词的组合的频率是该矩阵中的元素 *a_ij* 。

```
dict_df = dict_df.drop_duplicates()
pivot_df = dict_df.pivot(index = 'lead', columns= 'follow', values='freq')
```

对于每一行，我将所有的频率相加，并将行 *i* 中的每个元素除以行 *i* 的总和。这导致百分比总和为 1，当我的句子生成器为某个引导词选择跟随词时，它将用作概率分布。例如，如果在单词“fake”之后，我们观察到 7 次随后的单词“news”和 3 次单词“tan ”,则最终被选择的概率将分别是 0.7 和 0.3。

```
sum_words = pivot_df.sum(axis=1)
pivot_df = pivot_df.apply(lambda x: x/sum_words)
```

有了这些，我就可以为句子生成器定义我的函数了。我用一个起始词来初始化句子生成器。这个单词可以是从所有单词的集合中随机选择的单词。但由于我的文本只包含唐纳德·特朗普的标题，我认为确保他的名字也出现在我们的假新闻标题中是有意义的。因此，在我的例子中，我从“唐纳德”开始。从这个单词开始，生成器根据我们设置的概率矩阵选择一个后续单词。它将继续使用所选的跟随单词作为新的引导单词，一个单词接一个单词地添加到我们的句子中。如果句子生成器找到了我们的结束词数组中的一个词，句子将把这个词作为最后一个词并返回我们的句子。如果生成器到达我们之前定义的合成“EndWord ”,它将简单地为引导我们走上这条死胡同的引导词绘制一个新的跟随词。如果我们看到一个结束词，而我们的句子只有两个词长，这同样适用(我有几个例句，上面只有“唐纳德·特朗普”。。就像《唐纳德·特朗普》里那样。—努夫说)。

```
from numpy.random import choice
def make_a_sentence(start):
    word= start
    sentence=[word]
    while len(sentence) < 30:
        next_word = choice(a = list(pivot_df.columns), p = (pivot_df.iloc[pivot_df.index ==word].fillna(0).values)[0])
        if next_word == 'EndWord':
                continue
        elif next_word in end_words:
            if len(sentence) > 2:    
                sentence.append(next_word)
                break
            else :
                continue
        else :
            sentence.append(next_word)
        word=next_word
    sentence = ' '.join(sentence)
    return sentence
sentence = make_a_sentence('Donald')
```

仅此而已。

我肯定不会用这段代码赢得(特朗普主持的)选美比赛，但它快速、肮脏、Python-noob 友好，并且完成了工作。诚然，文本越大，分配概率的整个过程将变得越慢，但对于我的示例，它仍然只花了几秒钟，所以我认为还没有必要进行耗时的优化。让我们来看看一些“真正的假新闻”的标题:

> **唐纳德·特朗普批评特朗普痴迷星战燃烧。** *-(听起来似乎有理)*
> 
> **唐纳德·特朗普打破了真正的唐纳德·特朗普忠诚度测试。***——(如果发生那种事该有多酷？)*
> 
> **唐纳德·特朗普的团队投诉白人。***——(耶…大概不会)*
> 
> 唐纳德胜过最会吹牛的人。 *——【他最差也是)*
> 
> 唐纳德·特朗普的助手们觉得他今年秋天会当选总统。 *——(我们都做……我们都做)*
> 
> 唐纳德·特朗普、罗莎和其他个人，包括第 45 任总统是造币厂的青年。 *-(新鲜？)*
> 
> **唐纳德·特朗普，你到此为止。** *——(对我的口味来说可能有点太远)*

当然这些都是一些成功的例子。很多句子出来绝对是胡言乱语(不值得 covfefe，但仍然是胡言乱语):

> **唐纳德·特朗普知道谁是阿撒·富兰克林为尤塔工作的前助手罗莎·马尼高尔特·纽曼。** *-(？？？)*

那么，我们从这件事中学到了什么？你作为一个读者，可能不多。但是我对我的代码感到很开心，并且开始用一种我通常不会遇到的结构来处理数据。如果您有反馈或建议，请随时联系我们。谢谢！

附言:

如果你想要一个更复杂的特朗普马尔可夫链，看看这个由更聪明的人制作的随机特朗普推特生成器:

[https://filiph.github.io/markov/](https://filiph.github.io/markov/)