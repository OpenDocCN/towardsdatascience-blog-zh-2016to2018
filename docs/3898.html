<html>
<head>
<title>Receiver Operating Characteristic Curves Demystified (in Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">接收器工作特性曲线解密(Python 语言)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/receiver-operating-characteristic-curves-demystified-in-python-bd531a4364d0?source=collection_archive---------1-----------------------#2018-06-29">https://towardsdatascience.com/receiver-operating-characteristic-curves-demystified-in-python-bd531a4364d0?source=collection_archive---------1-----------------------#2018-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bda27d98a05b49b3b6e6ad59b4f5ab85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k65OKy7TOhBWRIfx0u6JqA.png"/></div></div></figure><p id="8e76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在数据科学中，评估模型性能非常重要，最常用的性能指标是分类得分。然而，在处理具有严重类别不平衡的欺诈数据集时，一个分类分数没有太大意义。相反，接收机工作特性或 ROC 曲线提供了一个更好的选择。ROC 是信号(真阳性率)对噪声(假阳性率)的图。通过查看 ROC 曲线下的面积(或 AUC)来确定模型性能。最好的 AUC 可能是 1，而最差的是 0.5(45 度随机线)。任何小于 0.5 的值都意味着我们可以简单地做与模型建议完全相反的事情，以使值回到 0.5 以上。</p><p id="2463" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然 ROC 曲线很常见，但并没有太多的教学资源解释它是如何计算或得出的。在这篇博客中，我将逐步展示如何使用 Python 绘制 ROC 曲线。之后，我将解释基本 ROC 曲线的特征。</p><h1 id="c746" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">类别的概率分布</h1><p id="17ca" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">首先，让我们假设我们的假设模型为预测每个记录的类别产生了一些概率。与大多数二元欺诈模型一样，让我们假设我们的类别是“好”和“坏”，并且该模型产生 P(X=“坏”)的概率。为了创建这个概率分布，我们绘制了一个高斯分布图，每个类别有不同的平均值。想了解更多关于高斯分布的信息，请阅读这篇博客。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="0b9f" class="mj kx iq mf b gy mk ml l mm mn">import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="9112" class="mj kx iq mf b gy mo ml l mm mn">def pdf(x, std, mean):<br/>    cons = 1.0 / np.sqrt(2*np.pi*(std**2))<br/>    pdf_normal_dist = const*np.exp(-((x-mean)**2)/(2.0*(std**2)))<br/>    return pdf_normal_dist</span><span id="d84b" class="mj kx iq mf b gy mo ml l mm mn">x = np.linspace(0, 1, num=100)<br/>good_pdf = pdf(x,0.1,0.4)<br/>bad_pdf = pdf(x,0.1,0.6)</span></pre><p id="d502" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了分布，让我们创建一个函数来绘制分布。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="318b" class="mj kx iq mf b gy mk ml l mm mn">def plot_pdf(good_pdf, bad_pdf, ax):<br/>    ax.fill(x, good_pdf, "g", alpha=0.5)<br/>    ax.fill(x, bad_pdf,"r", alpha=0.5)<br/>    ax.set_xlim([0,1])<br/>    ax.set_ylim([0,5])<br/>    ax.set_title("Probability Distribution", fontsize=14)<br/>    ax.set_ylabel('Counts', fontsize=12)<br/>    ax.set_xlabel('P(X="bad")', fontsize=12)<br/>    ax.legend(["good","bad"])</span></pre><p id="978a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们使用这个<strong class="ka ir"> plot_pdf </strong>函数来生成绘图:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="0baa" class="mj kx iq mf b gy mk ml l mm mn">fig, ax = plt.subplots(1,1, figsize=(10,5))<br/>plot_pdf(good_pdf, bad_pdf, ax)</span></pre><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/4ca41684810b585caf965f36a6cb5f19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*qLDlIbU26FY_PNRTdqRboQ.png"/></div></figure><p id="bd9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了二元类的概率分布，我们可以用这个分布来推导 ROC 曲线。</p><h1 id="6bb8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">推导 ROC 曲线</h1><p id="1c87" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">为了从概率分布得出 ROC 曲线，我们需要计算真阳性率(TPR)和假阳性率(FPR)。举个简单的例子，假设阈值在 P(X='bad')=0.6。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/894a7024f1077360bd3c66a25ecdf6fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hf2fRUKfD-hCSw1ifUOCpg.png"/></div></div></figure><p id="f611" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">真阳性是阈值右侧指定为“坏”的区域。假阳性表示阈值右侧指定为“好”的区域。总正值是“差”曲线下的总面积，而总负值是“好”曲线下的总面积。我们将图中所示的值相除，得出 TPR 和 FPR。我们推导出不同阈值下的 TPR 和 FPR，得到 ROC 曲线。利用这些知识，我们创建了 ROC 绘图函数:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="b69a" class="mj kx iq mf b gy mk ml l mm mn">def plot_roc(good_pdf, bad_pdf, ax):<br/>    #Total<br/>    total_bad = np.sum(bad_pdf)<br/>    total_good = np.sum(good_pdf)<br/>    #Cumulative sum<br/>    cum_TP = 0<br/>    cum_FP = 0<br/>    #TPR and FPR list initialization<br/>    TPR_list=[]<br/>    FPR_list=[]<br/>    #Iteratre through all values of x<br/>    for i in range(len(x)):<br/>        #We are only interested in non-zero values of bad<br/>        if bad_pdf[i]&gt;0:<br/>            cum_TP+=bad_pdf[len(x)-1-i]<br/>            cum_FP+=good_pdf[len(x)-1-i]<br/>        FPR=cum_FP/total_good<br/>        TPR=cum_TP/total_bad<br/>        TPR_list.append(TPR)<br/>        FPR_list.append(FPR)<br/>    #Calculating AUC, taking the 100 timesteps into account<br/>    auc=np.sum(TPR_list)/100<br/>    #Plotting final ROC curve<br/>    ax.plot(FPR_list, TPR_list)<br/>    ax.plot(x,x, "--")<br/>    ax.set_xlim([0,1])<br/>    ax.set_ylim([0,1])<br/>    ax.set_title("ROC Curve", fontsize=14)<br/>    ax.set_ylabel('TPR', fontsize=12)<br/>    ax.set_xlabel('FPR', fontsize=12)<br/>    ax.grid()<br/>    ax.legend(["AUC=%.3f"%auc])</span></pre><p id="6e17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们使用这个<strong class="ka ir"> plot_roc </strong>函数来生成绘图:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="921f" class="mj kx iq mf b gy mk ml l mm mn">fig, ax = plt.subplots(1,1, figsize=(10,5))<br/>plot_roc(good_pdf, bad_pdf, ax)</span></pre><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/08507530459405711a991d2fb882ddf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*d0U_sTGJ40CKHYxEyG3A8w.png"/></div></figure><p id="94f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在绘制概率分布图和 ROC 图，以便直观比较:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="596f" class="mj kx iq mf b gy mk ml l mm mn">fig, ax = plt.subplots(1,2, figsize=(10,5))<br/>plot_pdf(good_pdf, bad_pdf, ax[0])<br/>plot_roc(good_pdf, bad_pdf, ax[1])<br/>plt.tight_layout()</span></pre><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bda27d98a05b49b3b6e6ad59b4f5ab85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k65OKy7TOhBWRIfx0u6JqA.png"/></div></div></figure><h1 id="b292" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">阶级分离的影响</h1><p id="50c7" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">既然我们可以得到两个图，让我们看看 ROC 曲线如何随着类别分离(即模型性能)的改善而变化。我们通过改变概率分布中高斯分布的平均值来做到这一点。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="5ef4" class="mj kx iq mf b gy mk ml l mm mn">x = np.linspace(0, 1, num=100)<br/>fig, ax = plt.subplots(3,2, figsize=(10,12))<br/>means_tuples = [(0.5,0.5),(0.4,0.6),(0.3,0.7)]<br/>i=0<br/>for good_mean, bad_mean in means_tuples:<br/>    good_pdf = pdf(x, 0.1, good_mean)<br/>    bad_pdf  = pdf(x, 0.1, bad_mean)<br/>    plot_pdf(good_pdf, bad_pdf, ax[i,0])<br/>    plot_roc(good_pdf, bad_pdf, ax[i,1])<br/>    i+=1<br/>plt.tight_layout()</span></pre><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f0f981ab5b183c4b06cf080168810ed9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OBZ6Z1_i_iF9qj4R6I4eUA.png"/></div></div></figure><p id="4384" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，AUC 随着我们增加类别之间的间隔而增加。</p><h1 id="6b52" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">放眼 AUC 之外</h1><p id="f95c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">除了 AUC，ROC 曲线也可以帮助调试模型。通过观察 ROC 曲线的形状，我们可以评估模型的错误分类。例如，如果曲线的左下角更接近随机线，则暗示模型在 X=0 处分类错误。然而，如果右上角是随机的，则意味着误差发生在 X=1 处。此外，如果曲线上有尖峰(而不是平滑的)，这意味着模型不稳定。</p><h1 id="6698" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">附加说明</h1><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/data-science-interview-guide-4ee9f5dc778"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">数据科学面试指南</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">数据科学是一个相当大且多样化的领域。因此，做一个万事通真的很难…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj jw mv"/></div></div></a></div><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/fraud-detection-under-extreme-class-imbalance-c241854e60c"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">极端类别不平衡下的欺诈检测</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">数据科学中的一个热门领域是欺诈分析。这可能包括信用卡/借记卡欺诈、反洗钱…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="nk l ng nh ni ne nj jw mv"/></div></div></a></div></div></div>    
</body>
</html>