<html>
<head>
<title>Software Architecture Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件架构模式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/software-architecture-patterns-98043af8028?source=collection_archive---------0-----------------------#2017-08-29">https://towardsdatascience.com/software-architecture-patterns-98043af8028?source=collection_archive---------0-----------------------#2017-08-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="971c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">分层架构</h2></div><p id="d131" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是大多数企业级应用程序中最常见的架构模式。假设层数为<strong class="kh ir"> n </strong>，这也被称为<strong class="kh ir"> n层</strong>模式。这是JAVA EE应用程序的事实模式。</p><h1 id="06e3" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">层的示例场景</h1><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/faaf5bbbf21984053d656aa20f0dbd38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DPWDR7j5lMdgXWjspe-LpA.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">Source: <a class="ae mj" href="https://www.oreilly.com/ideas/software-architecture-patterns/page/2/layered-architecture" rel="noopener ugc nofollow" target="_blank">https://www.oreilly.com/ideas/software-architecture-patterns/page/2/layered-architecture</a></figcaption></figure><h2 id="d47e" class="mk lc iq bd ld ml mm dn lh mn mo dp ll ko mp mq ln ks mr ms lp kw mt mu lr mv bi translated"><strong class="ak">表示层</strong></h2><p id="fc62" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">网页、UI表单和最终用户交互API的呈现</p><h2 id="a1f4" class="mk lc iq bd ld ml mm dn lh mn mo dp ll ko mp mq ln ks mr ms lp kw mt mu lr mv bi translated">业务层</h2><p id="7cf2" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">可访问性、安全性和身份验证背后的逻辑发生在这一层。这包括ESB(企业服务总线)、中间件和其他各种请求拦截器来执行验证。</p><h2 id="5014" class="mk lc iq bd ld ml mm dn lh mn mo dp ll ko mp mq ln ks mr ms lp kw mt mu lr mv bi translated">持久层</h2><p id="4969" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">这是数据的表示层。这包括DAO(数据访问对象)表示、ORM(对象关系映射)和其他在应用程序级别表示持久数据的模式。换句话说，这展示了RAM中的持久数据。它通常位于下层的磁盘中。</p><h2 id="f52e" class="mk lc iq bd ld ml mm dn lh mn mo dp ll ko mp mq ln ks mr ms lp kw mt mu lr mv bi translated">数据库层</h2><p id="5074" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">简单的数据库扩展到San(存储区域网络)</p><h1 id="75d1" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">层的组成</h1><p id="af13" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">层由组件组成。这些组件比对象类和包更抽象。一个组件可以演示一组执行单一任务的包。</p><blockquote class="nb"><p id="f910" class="nc nd iq bd ne nf ng nh ni nj nk la dk translated">“组件加强了关注点的分离”</p></blockquote><h1 id="096c" class="lb lc iq bd ld le lf lg lh li lj lk ll jw nl jx ln jz nm ka lp kc nn kd lr ls bi translated">关键概念</h1><h2 id="b545" class="mk lc iq bd ld ml mm dn lh mn mo dp ll ko mp mq ln ks mr ms lp kw mt mu lr mv bi translated">封闭层</h2><p id="8d91" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">这展示了<strong class="kh ir"> <em class="no">隔离层</em> </strong>的概念，它以更严格的方式分隔每一层，只允许顺序通过各层，而不允许旁路。如图所示，这加强了层的更好的解耦，使得整个系统对于变化更加可行。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi np"><img src="../Images/c61445fa21e345aa596469975bb434ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TQZuobIrJzCsMCCVSiyUTg.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">Source: <a class="ae mj" href="https://www.oreilly.com/ideas/software-architecture-patterns/page/2/layered-architecture" rel="noopener ugc nofollow" target="_blank">https://www.oreilly.com/ideas/software-architecture-patterns/page/2/layered-architecture</a></figcaption></figure><h2 id="6108" class="mk lc iq bd ld ml mm dn lh mn mo dp ll ko mp mq ln ks mr ms lp kw mt mu lr mv bi translated">打开图层</h2><p id="5e1b" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">开放层允许系统绕过层并触及下面的层。这是在任务关键型系统中完成的，在这些系统中，延迟会造成很大的损失。通常这些层意味着通信开销。因此，有时绕过层并直接从正确的层寻找数据是合理的。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nq"><img src="../Images/e014a849b5f7ab7da3c1b217da734e5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TyTlKWViyoNrzzoWaQQfCA.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">Source: <a class="ae mj" href="https://www.oreilly.com/ideas/software-architecture-patterns/page/2/layered-architecture" rel="noopener ugc nofollow" target="_blank">https://www.oreilly.com/ideas/software-architecture-patterns/page/2/layered-architecture</a></figcaption></figure><h1 id="9122" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">模式分析</h1><p id="6118" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">采用分层模式可能会误导并导致一种称为<strong class="kh ir"> <em class="no">“架构陷坑反模式”</em> </strong>的反模式，这种反模式展示了具有不执行任何逻辑的层，但增加了通信开销。因此，这些层必须以执行特定任务的方式进行设计，以补偿整个系统的通信开销和可维护性。</p><h2 id="bb96" class="mk lc iq bd ld ml mm dn lh mn mo dp ll ko mp mq ln ks mr ms lp kw mt mu lr mv bi translated">模式可测试性</h2><p id="a399" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">由于分层的性质，这个值更高。通过传递虚拟消息并使用虚拟接口来演示直接层，可以单独测试每一层。</p><h2 id="4d6a" class="mk lc iq bd ld ml mm dn lh mn mo dp ll ko mp mq ln ks mr ms lp kw mt mu lr mv bi translated">性能和可扩展性</h2><p id="94b0" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">由于有通信开销，这可能很低。这可能需要转换消息类型等。就可伸缩性而言，添加更多层不是一个选择。该模式不会无限扩展。</p><blockquote class="nr ns nt"><p id="f55f" class="kf kg no kh b ki kj jr kk kl km ju kn nu kp kq kr nv kt ku kv nw kx ky kz la ij bi translated">尽管有起有落，开发工作还是少了很多，因为一旦确定了通信协议，不同的团队就可以在不同的层上工作，并在每个团队的成员之间分配组件。</p></blockquote></div></div>    
</body>
</html>