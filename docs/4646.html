<html>
<head>
<title>Make working with large DataFrames easier, at least for your memory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使处理大型数据帧变得更容易，至少对您的内存来说是这样</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/make-working-with-large-dataframes-easier-at-least-for-your-memory-6f52b5f4b5c4?source=collection_archive---------4-----------------------#2018-08-28">https://towardsdatascience.com/make-working-with-large-dataframes-easier-at-least-for-your-memory-6f52b5f4b5c4?source=collection_archive---------4-----------------------#2018-08-28</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><figure class="iu iv gp gr iw ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi it"><img src="../Images/c7ba03b4977c7e721cce8e75aba51ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IaSJ_ib1hsaeNzJQtcnYpg.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="eae6" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">将数据帧的大小减少多达 90%！</h2></div><p id="8fd8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq io bi translated">如今，在大数据世界中，我们经常使用大型数据集。虽然有某些工具可以促进对大量数据的处理(如 Spark)，但我们仍然在本地做大量工作，例如，我们希望建立一个原型模型(MVP，最小可行产品)。因此，我认为花点时间优化我们处理数据的方式可能是值得的——通过这样做——将其大小减少 90%。是的，可以那么多…</p><h1 id="ffc9" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">引擎盖下发生了什么？</h1><p id="7892" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq io bi translated">不会有太多的理论，但还是有必要说几句。在幕后，pandas 将 DataFrame 的相同变量类型(如整数、浮点、对象)的列存储在块中。在表示数值(整数和浮点数)的块的情况下，这些列被组合并以 NumPy 的<code class="fe mo mp mq mr b">ndarray</code>的形式存储，这使得访问它们非常快。</p><p id="dbab" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq io bi translated">因此，让我们看看在 pandas 上可用的数据类型以及它们实际上代表了什么。下表概述了可用的类型及其用途。</p><figure class="mt mu mv mw gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi ms"><img src="../Images/04f5d35b7950394d44b45a5ee30d57e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j9CH_6m1XrvuPz2DUGf5tQ.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Source: <a class="ae nb" href="http://pbpython.com/pandas_dtypes.html" rel="noopener ugc nofollow" target="_blank">http://pbpython.com/pandas_dtypes.html</a></figcaption></figure><p id="3d64" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq io bi translated">还值得一提的是表中可见的子类型。举个例子，我们有<code class="fe mo mp mq mr b">int8</code>、<code class="fe mo mp mq mr b">int16</code>、<code class="fe mo mp mq mr b">int32</code>和<code class="fe mo mp mq mr b">int64</code>。该数字表示该子类型使用多少位来表示特定值，这些位分别使用 1、2、4 和 8 字节的内存。下表可能更能说明我们实际上可以在这些数字数据类型中存储哪些值。</p><figure class="mt mu mv mw gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi nc"><img src="../Images/6d670501ac4ad4b3e804a2a595171d8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f7kTFcscHI7dstMHZ1_eFg.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Source: <a class="ae nb" href="https://docs.scipy.org/doc/numpy-1.13.0/user/basics.types.html" rel="noopener ugc nofollow" target="_blank">https://docs.scipy.org/doc/numpy-1.13.0/user/basics.types.html</a></figcaption></figure><p id="b094" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq io bi translated">知道<code class="fe mo mp mq mr b">uint</code>(无符号整数)和<code class="fe mo mp mq mr b">int</code>(有符号整数)之间的区别可能会很方便。两者的存储容量相等，但是无符号整数只允许存储正值。因此，在某些情况下，我们绝对可以利用这一点！</p><h1 id="b64b" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">实际例子</h1><p id="c7b8" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq io bi translated">在本文中，我将生成一个示例数据框架，用几种不同的数据类型来说明如何优化存储。<code class="fe mo mp mq mr b">Pandas</code>通常在检测数据类型时做得很好，但是，有时，例如，当使用<code class="fe mo mp mq mr b">read_csv()</code>或<code class="fe mo mp mq mr b">read_sql()</code>时，数据类型没有以最佳方式分配。我创建数据帧如下:</p><figure class="mt mu mv mw gt ix"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="47df" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq io bi translated">我人为地将<code class="fe mo mp mq mr b">user_id</code>和<code class="fe mo mp mq mr b">order_id</code>等变量的类型设置为 string，因为这是实践中经常发生的情况。您还会遇到类型为<code class="fe mo mp mq mr b">id123456789</code>的 id，其中删除字符串部分<code class="fe mo mp mq mr b">id</code>不会产生任何影响，但会导致所需内存的显著减少。</p><p id="30a0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq io bi translated">作为第一步，我检查样本数据帧中存储的变量类型。一切都在意料之中。</p><pre class="mt mu mv mw gt nf mr ng nh aw ni bi"><span id="23c2" class="nj ls jg mr b gy nk nl l nm nn">&gt;&gt;&gt; df.dtypes</span><span id="2c0b" class="nj ls jg mr b gy no nl l nm nn">user_id                object<br/>order_id               object<br/>order_date             object<br/>number_of_products      int64<br/>total_amount          float64<br/>day_of_week            object<br/>dtype: object</span></pre><p id="f6ce" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq io bi translated">要查看每列占用多少内存，我们可以使用如下的<code class="fe mo mp mq mr b">memory_usage</code>:</p><pre class="mt mu mv mw gt nf mr ng nh aw ni bi"><span id="8459" class="nj ls jg mr b gy nk nl l nm nn">&gt;&gt;&gt; df.memory_usage(deep=True) / 1024 ** 2</span><span id="cda7" class="nj ls jg mr b gy no nl l nm nn">Index                  0.000076<br/>user_id               61.988831<br/>order_id              61.035156<br/>order_date            38.146973<br/>number_of_products     7.629395<br/>total_amount           7.629395<br/>day_of_week           61.171283<br/>dtype: float64</span></pre><p id="443a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq io bi translated">通过设置<code class="fe mo mp mq mr b">deep=True</code>,我们获得了确切的内存大小(Mb ),保留默认选项<code class="fe mo mp mq mr b">False</code>将提供一个近似值。乍一看很清楚，大部分内存用于存储字符串，这也是我们可以从优化中获得最大收益的地方。为了方便起见，我定义了一个助手函数来评估整个数据帧的大小(以 Mb 为单位)。</p><pre class="mt mu mv mw gt nf mr ng nh aw ni bi"><span id="bf2d" class="nj ls jg mr b gy nk nl l nm nn">def memory_usage(df):<br/>    return(round(df.memory_usage(deep=True).sum() / 1024 ** 2, 2))</span></pre><p id="52ca" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq io bi translated">让我们看看数据帧总共占用了多少空间:</p><pre class="mt mu mv mw gt nf mr ng nh aw ni bi"><span id="47c3" class="nj ls jg mr b gy nk nl l nm nn">&gt;&gt;&gt; print('Memory used:', memory_usage(df), 'Mb')</span><span id="918a" class="nj ls jg mr b gy no nl l nm nn">Memory used: 237.6 Mb</span></pre><p id="6c00" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq io bi translated"><em class="np">优化数值变量</em></p><p id="7be9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq io bi translated">首先，检查变量并找出我们正在处理的东西是有好处的。</p><pre class="mt mu mv mw gt nf mr ng nh aw ni bi"><span id="1763" class="nj ls jg mr b gy nk nl l nm nn">&gt;&gt;&gt; df.describe()</span></pre><figure class="mt mu mv mw gt ix gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/9d703c61aa8c455c903a42e3dca41149.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*seTcKsExgD2IDXcTro6r8Q.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Summary statistics of numeric variables</figcaption></figure><p id="feb9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq io bi translated">结果并不令人惊讶，因为这正是初始化随机数据帧时定义变量的方式。检查完带有子类型的表后，我们可以手动将<code class="fe mo mp mq mr b">number_of_products</code>的类型更改为<code class="fe mo mp mq mr b">uint8</code>，因为这是适用于该变量的最小数据子类型(只有最大值为&lt; 20 的正值)。当我们在这里处理一个浮动时，我也向下转换了<code class="fe mo mp mq mr b">total_amount</code>。由于变量仍然具有很高的精度，在这种情况下我不需要(之前四舍五入到 2 位小数)，保持这种方式没有意义，所以我进一步将类型改为<code class="fe mo mp mq mr b">float16.</code></p><pre class="mt mu mv mw gt nf mr ng nh aw ni bi"><span id="b8f4" class="nj ls jg mr b gy nk nl l nm nn">&gt;&gt;&gt; df.number_of_products = df.number_of_products.astype('uint8')<br/>&gt;&gt;&gt; df.total_amount = df.total_amount.apply(pd.to_numeric, downcast='float')<br/>&gt;&gt;&gt; print('Memory used:', memory_usage(df_copy), 'Mb')</span><span id="c597" class="nj ls jg mr b gy no nl l nm nn">Memory used: 230.93 Mb</span><span id="6224" class="nj ls jg mr b gy no nl l nm nn">&gt;&gt;&gt; type(df.total_amount[0])</span><span id="d790" class="nj ls jg mr b gy no nl l nm nn">numpy.float64</span><span id="1eeb" class="nj ls jg mr b gy no nl l nm nn">&gt;&gt;&gt; df.total_amount = df.total_amount.astype('float16')<br/>&gt;&gt;&gt; print('Memory used:', memory_usage(df), 'Mb')</span><span id="bdd2" class="nj ls jg mr b gy no nl l nm nn">Memory used: 225.21 Mb</span></pre><p id="a90c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq io bi translated">通过所有这些操作，我们设法将数据帧的大小减少了 10Mb 多一点，这并不是我所承诺的。但还是继续吧！</p><p id="e05f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq io bi translated"><em class="np">优化对象变量</em></p><figure class="mt mu mv mw gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi nr"><img src="../Images/0607db1a9f2e6d417b01ae44d027003f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vARkfB3lrK_5V_WHsmo-1A.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Overview of ‘object’ type variables</figcaption></figure><p id="aed4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq io bi translated">通过检查类型为<code class="fe mo mp mq mr b">object</code>的变量，我们可以看到一些东西。首先，正如所料，id 是唯一的。第二，日期没有太多不同的值。然而，我们希望保持它们的<code class="fe mo mp mq mr b">datetime</code>格式，因为这有助于更容易的 EDA。所以我们不会转换它们(这当然是可能的)。最后是<code class="fe mo mp mq mr b">day_of_week</code>，它在逻辑上只能接受几个不同的值。我们在这里可以做的是将它转换成不同的变量类型——<code class="fe mo mp mq mr b">category.</code>对于任何熟悉 R 的人来说，这将相当于一个<code class="fe mo mp mq mr b">factor.</code>。这个想法非常简单，字符串变量被编码为整数，通过使用一个特殊的映射字典可以解码回它们的原始形式。当我们处理有限数量的不同字符串值时(例如重复的星期几、月份等),这是很有用的。).一个有用的经验法则是考虑对唯一值与观察总数的比率低于 50%的变量使用分类数据类型。否则，我们可能会比一开始使用更多的内存。</p><pre class="mt mu mv mw gt nf mr ng nh aw ni bi"><span id="b556" class="nj ls jg mr b gy nk nl l nm nn">&gt;&gt;&gt; df.day_of_week = df.day_of_week.astype('category')<br/>&gt;&gt;&gt; df.user_id = df.user_id.astype('uint32')<br/>&gt;&gt;&gt; df.order_id = df.order_id.astype('uint32')</span><span id="4034" class="nj ls jg mr b gy no nl l nm nn">&gt;&gt;&gt; print('Memory used:', memory_usage(df_copy), 'Mb')</span><span id="6a59" class="nj ls jg mr b gy no nl l nm nn">Memory used: 49.59 Mb</span><span id="fae4" class="nj ls jg mr b gy no nl l nm nn">&gt;&gt;&gt; df_copy.memory_usage(deep=True) / 1024 ** 2</span><span id="458d" class="nj ls jg mr b gy no nl l nm nn">Index                  0.000076<br/>user_id                3.814697<br/>order_id               3.814697<br/>order_date            38.146973<br/>number_of_products     0.953674<br/>total_amount           1.907349<br/>day_of_week            0.954408<br/>dtype: float64</span></pre><p id="de08" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq io bi translated">我们将数据帧的大小从 237.6 Mb 减少到 49.59 Mb，减少了大约 80%。但是当我们只考虑被修改的变量时，那么结果实际上是 94%！我会说这是一项出色的工作:)</p><p id="ccd9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq io bi translated">另一个技巧是在通过<code class="fe mo mp mq mr b">pandas.read_csv().</code>将数据加载到 Python 时考虑数据的类型。假设我创建的样本数据帧在一个 CSV 文件中，我们可以创建一个包含数据类型信息的字典，并将其传递给函数。</p><pre class="mt mu mv mw gt nf mr ng nh aw ni bi"><span id="f290" class="nj ls jg mr b gy nk nl l nm nn">column_dtypes = <!-- -->{'<!-- -->day_of_week<!-- -->': 'category',<br/>                 '<!-- -->user_id<!-- -->': '<!-- -->uint32<!-- -->',<br/>                 '<!-- -->order_id<!-- -->': '<!-- -->uint32<!-- -->',<br/>                 '<!-- -->total_amount<!-- -->': 'float16',<br/>                 '<!-- -->number_of_products<!-- -->': 'uint8'}</span><span id="7399" class="nj ls jg mr b gy no nl l nm nn">df = pd.read_csv('sample_dataframe.csv', dtype = column_dtypes)</span></pre><p id="fc80" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq io bi translated">一如既往，我们欢迎任何建设性的反馈。你可以在推特上或者评论里联系我。我希望你喜欢这篇文章，并会发现这些技巧在你的项目中很方便！</p></div></div>    
</body>
</html>