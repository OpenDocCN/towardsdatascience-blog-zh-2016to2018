<html>
<head>
<title>Beads — append only data structure optimised for memory footprint</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Beads —仅附加针对内存占用优化的数据结构</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/beads-append-only-data-structure-optimised-for-memory-footprint-78d241426756?source=collection_archive---------8-----------------------#2018-07-03">https://towardsdatascience.com/beads-append-only-data-structure-optimised-for-memory-footprint-78d241426756?source=collection_archive---------8-----------------------#2018-07-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/13aea698b4451f1002f9a75d250809e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aSKD_BDClH1dzMWOKPytlw.jpeg"/></div></div></figure><p id="c54f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我必须承认，我对数据表示产生了一种不健康的迷恋。我认为它是基本的构建模块，在计算机科学中没有得到足够的重视。</p><p id="576f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇博文中，我想介绍一种数据结构，它主要专注于以非常紧凑的方式表示数据，因此提供了最小的内存占用和良好的<a class="ae kw" href="https://en.wikipedia.org/wiki/Locality_of_reference" rel="noopener ugc nofollow" target="_blank">数据局部性</a>。</p><blockquote class="kx ky kz"><p id="b3fe" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">小免责声明:beads 数据结构的参考实现是用 Swift 编写的，所以简短的代码片段会在 Swift 中，但不用担心，我让它对于不熟悉 Swift 编程语言的人来说是易于理解的。</p></blockquote></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><p id="b44c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们谈论<a class="ae kw" href="https://en.wikipedia.org/wiki/Data_structure" rel="noopener ugc nofollow" target="_blank">数据结构</a>时，我们关注运行时特征和大 O 符号。然而，我没有看到很多关于内存占用的讨论。比如:<a class="ae kw" href="https://en.wikipedia.org/wiki/Linked_list" rel="noopener ugc nofollow" target="_blank">链表</a>是一种广为人知的数据结构，以 O(1) prepend 特性而闻名。然而，我从来没有读到过这样的讨论——一个 64 位架构上的指针如何有 8 字节宽，这意味着一个布尔值列表将为每个列表元素占用 16 字节。与<a class="ae kw" href="https://en.wikipedia.org/wiki/Bit_array" rel="noopener ugc nofollow" target="_blank">位数组</a>相比，布尔值链表需要<strong class="ka ir"> 128x </strong>更多的空间。不要让我从<a class="ae kw" href="https://en.wikipedia.org/wiki/Locality_of_reference" rel="noopener ugc nofollow" target="_blank">数据位置</a>开始。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><p id="b2f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi ll translated">eads 被设计成一个序列，它在追加时压缩值。Append 是在常数时间内执行的，它涉及一些计算，但是这些并不是很昂贵，并且基于复杂性理论，我们可以假设运行时间特性为 O(1)。</p><p id="6613" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们举一个实际的例子。假设我们有一个数字序列<code class="fe lu lv lw lx b">[1, 5, 6, 7]</code>，我们希望将它存储在一个数据结构中。最简单的就是把它存储在一个数组里。如果数字是正数并且小于 256，我们可以将它们存储在一个<code class="fe lu lv lw lx b"><a class="ae kw" href="https://developer.apple.com/documentation/swift/uint8" rel="noopener ugc nofollow" target="_blank">UInt8</a></code>数组中。这意味着每个条目将只占用 1 个字节。</p><p id="c0e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们需要在数组中存储一个负数或者更大的数，会发生什么呢？在这种情况下，我们需要确定最大的可能值，并根据这种特殊情况选择一个数字类型。然而，预测潜在价值的大小非常困难，甚至是不可能的。这就是为什么我们通常不麻烦，我们定义一个整数数组<code class="fe lu lv lw lx b">[Int]</code>，其中<code class="fe lu lv lw lx b"><a class="ae kw" href="https://developer.apple.com/documentation/swift/int" rel="noopener ugc nofollow" target="_blank">Int</a></code>在 64 位架构上是 64 位宽。这意味着我们每个条目占用 8 个字节，尽管这是完全不必要的。</p><p id="8585" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">珠子做了一些不同的事情。Beads 不仅存储值，还存储类型。一个类型存储在 4 位中，这意味着我们可以在一个字节中存储 2 个类型标签。让我们把我们的数字系列<code class="fe lu lv lw lx b">[1, 5, 6, 7]</code>储存在珠子里:</p><p id="b5d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lu lv lw lx b">[{u8/u8}, 1, 5, {u8/u8}, 6, 7]</code></p><p id="0118" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们为每两个条目引入一个标签条目<code class="fe lu lv lw lx b">{/}</code>，这意味着条目的数量增长到 150%。因此，如果我们可以将我们的数字序列存储为一个<code class="fe lu lv lw lx b">[UInt8]</code>，我们就是在浪费空间。然而，如果我们将序列存储为<code class="fe lu lv lw lx b">[Int]</code>。该序列如下所示:</p><p id="5cac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lu lv lw lx b">[1, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0,]</code></p><p id="4188" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个数字占用 8 个字节。我们假设我们在一个小端架构上。不需要的字节等于<code class="fe lu lv lw lx b">0</code>。如果我们比较珠子和一组<code class="fe lu lv lw lx b">Int</code>——珠子只占大约 19%的空间。</p><p id="0cbe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果序列是稀疏的，这种影响会变得更大——意味着我们有很多<code class="fe lu lv lw lx b">nil</code>值。</p><p id="ace7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如:<code class="fe lu lv lw lx b">[5, nil, nil, nil, nil, 2]</code>=&gt;6 字节</p><p id="67c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">变成:<code class="fe lu lv lw lx b">[{u8/nil}, 5, {nil/nil}, {nil/u8}, 2]</code>=&gt;5 字节</p><p id="bb91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当一个<code class="fe lu lv lw lx b">nil</code>值被附加到珠子上时，只有标签被添加，因为标签只占用一半的字节，我们有 50%的好处。所以在<code class="fe lu lv lw lx b">[UInt8]</code>的情况下，我们<em class="la">损失</em> 50%，<code class="fe lu lv lw lx b">[UInt8?]</code> <em class="la">随着每个<code class="fe lu lv lw lx b">nil</code>值获得</em> 50%。也就是说，如果我们有相同数量的数字和<code class="fe lu lv lw lx b">nil</code>值，我们就是 100%。如果<code class="fe lu lv lw lx b">nil</code>值的数量更大，我们向 50%收敛。如果更小，我们就向 150%收敛。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h2 id="3c95" class="ly lz iq bd ma mb mc dn md me mf dp mg kj mh mi mj kn mk ml mm kr mn mo mp mq bi translated">追加是如何工作的？</h2><p id="4b02" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">珠子公开了各种数字类型的附加方法。当使用类型为<code class="fe lu lv lw lx b">Int</code>的数字调用 append 时，我们检查这个数字是否可以用更小的类型来表示。最简单但不一定是最有效的解决方案是双重造型和比较:</p><pre class="mw mx my mz gt na lx nb nc aw nd bi"><span id="e6bb" class="ly lz iq lx b gy ne nf l ng nh">let value: Int = 42<br/>let u8Value = UInt8(value)<br/>if value = Int(u8Value) {<br/>  // store value as u8<br/>}</span></pre><p id="6f76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们把初始值转换成一个更小的数字表示，然后再把它转换回来，看看它是否等于初始值。在这种情况下，我们可以采用较小的表示，并将其存储在底层缓冲区中。</p><p id="26d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该解决方案甚至适用于<a class="ae kw" href="https://en.wikipedia.org/wiki/Floating-point_arithmetic" rel="noopener ugc nofollow" target="_blank">浮点数</a>。浮点通常以 4 字节(单精度)或 8 字节(双精度)存储。如果传递给 append 的值是一个<code class="fe lu lv lw lx b"><a class="ae kw" href="https://developer.apple.com/documentation/swift/double" rel="noopener ugc nofollow" target="_blank">Double</a></code>，但实际上是一个小整数(例如<code class="fe lu lv lw lx b">42.0</code>)，我们可以节省高达 81%的空间。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h2 id="cf9d" class="ly lz iq bd ma mb mc dn md me mf dp mg kj mh mi mj kn mk ml mm kr mn mo mp mq bi translated">弦乐呢？</h2><p id="264a" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">如果我们有一个只和数字一起工作的数据结构，这将是非常有限的。存储一个字符串序列是一个非常普通和重要的任务。</p><p id="1bfd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们考虑一下，字符串只是一系列数字，它们对应于特定的字符编码。如今最流行的字符编码是<a class="ae kw" href="https://en.wikipedia.org/wiki/UTF-8" rel="noopener ugc nofollow" target="_blank"> UTF-8 </a>。它将文本转换成一系列的<code class="fe lu lv lw lx b">UInt8</code>数字，或者如果你愿意的话，转换成<code class="fe lu lv lw lx b"><a class="ae kw" href="https://developer.apple.com/documentation/foundation/data" rel="noopener ugc nofollow" target="_blank">Data</a></code>。珠子可以附加一系列的<code class="fe lu lv lw lx b">UInt8</code>数字，或者<code class="fe lu lv lw lx b">Data</code>作为一个带有一对类型标签的珠子。这里有一个例子:</p><p id="9b90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lu lv lw lx b">"Maxim" =&gt; [{data/u8}, 5, [77, 97, 120, 105, 109]]</code></p><p id="1a5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">字符串<code class="fe lu lv lw lx b">"Maxim"</code>用下面的标签对<code class="fe lu lv lw lx b">{data/u8}</code>表示。它表示下一个条目是以 u8 类型的大小为前缀的数据。这样，迭代器能够将下一个条目解释为大小<code class="fe lu lv lw lx b">5</code>，并且知道接下来的 5 个条目<code class="fe lu lv lw lx b">[77, 97, 120, 105, 109]</code>属于一起。数据内部的 5 个条目形成字符串<code class="fe lu lv lw lx b">"Maxim"</code>的<a class="ae kw" href="https://en.wikipedia.org/wiki/ASCII" rel="noopener ugc nofollow" target="_blank"> ASCII </a> /UTF-8 表示的信息没有存储在任何地方，并且被认为是隐含的知识。</p><p id="7bc6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个更复杂的例子，我们存储了一个带有<code class="fe lu lv lw lx b">nil</code>值的字符串序列:</p><pre class="mw mx my mz gt na lx nb nc aw nd bi"><span id="b247" class="ly lz iq lx b gy ne nf l ng nh">["Max", "Maxim", "", nil, "Alex"]<br/>=&gt;<br/>[{data/u8}, 3, [77, 97, 120], {data/u8}, 5, <!-- -->[77, 97, 120, 105, 109], {data/u8}, 0, {nil/data}, {u8/-}, 4, [65, 108, 101, 120]<!-- -->]</span></pre><p id="c204" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们把这个例子分解一下。</p><p id="2b39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lu lv lw lx b">"Max"</code>和<code class="fe lu lv lw lx b">"Maxim"</code>并不奇怪，它们存储在<code class="fe lu lv lw lx b">{data\u8}</code>标签中，后面是代表字符串的大小和数字。</p><p id="3ea5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">空字符串(<code class="fe lu lv lw lx b">""</code>)却很有趣。标签字节仍然是<code class="fe lu lv lw lx b">{data/u8}</code>，但是后面只跟着<code class="fe lu lv lw lx b">0</code>。这些信息足以存储一个空字符串。</p><p id="80e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来是<code class="fe lu lv lw lx b">nil</code>，在这种情况下，我们甚至不需要标签对。一个<code class="fe lu lv lw lx b">nil</code>是一个<code class="fe lu lv lw lx b">nil</code>，可以用一个标签来表示，只占用标签字节的一半。</p><p id="031b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一个条目是<code class="fe lu lv lw lx b">"Alex"</code>，不出所料，它必须由一个<code class="fe lu lv lw lx b">{data/u8}</code>标签对来表示，但是由于我们在前面的字节中仍有空间仅被<code class="fe lu lv lw lx b">nil</code>占用，因此该标签对将分布在两个字节中。这就是导致<code class="fe lu lv lw lx b">{nil/data}, {u8/-}, 4, [65, 108, 101, 120]</code>的原因。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h2 id="b52d" class="ly lz iq bd ma mb mc dn md me mf dp mg kj mh mi mj kn mk ml mm kr mn mo mp mq bi translated">零重量表示的压缩数据</h2><p id="e6a4" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">如你所见，beads 非常努力地尽可能少地浪费内存。这是实现这个目标的另一个窍门。</p><p id="b904" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们将字符串存储在<a class="ae kw" href="https://en.wikipedia.org/wiki/UTF-16" rel="noopener ugc nofollow" target="_blank"> UTF-16 </a>中，让我们看看我们的字符串序列会是什么样子。这种格式也很普遍，但是特别是对于简单的 ASCII 字符来说更浪费。这是我们之前在 UTF-16 中的例子:</p><pre class="mw mx my mz gt na lx nb nc aw nd bi"><span id="e6dc" class="ly lz iq lx b gy ne nf l ng nh">["Max", "Maxim", "", nil, "Alex"]<br/>=&gt;<br/>[{data/u8}, 8, [255, 254, 77, 0, 97, 0, 120, 0], {data/u8}, 12, <!-- -->[<!-- -->255, 254, <!-- -->77, 0, 97, 0, 120, 0, 105, 0, 109, 0], {data/u8}, 0, {nil/data}, {u8/-}, 10, [<!-- -->255, 254, <!-- -->65, 0, 108, 0, 101, 0, 120, 0]<!-- -->]</span></pre><p id="f110" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在<code class="fe lu lv lw lx b">"Max"</code>表示为<code class="fe lu lv lw lx b">{data/u8}, 8, [255, 254, 77, 0, 97, 0, 120, 0]</code>。标签字节是相同的，但是代表字符串的数字序列的长度是 8，而不是 UTF-8 中的 3。这是因为在 UTF-16 编码中，我们将每个字符存储在 2 个字节中，我们需要在序列前加上所谓的<a class="ae kw" href="https://en.wikipedia.org/wiki/Byte_order_mark" rel="noopener ugc nofollow" target="_blank"> BOM </a>，它可以识别数字是根据<a class="ae kw" href="https://en.wikipedia.org/wiki/Endianness" rel="noopener ugc nofollow" target="_blank">大端还是小端</a>存储的。</p><p id="22ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们存储使用许多简单 ASCII 字符的语言(如英语)编写的文本时，我们最终会有许多<code class="fe lu lv lw lx b">0</code>值。这就是我所说的“<strong class="ka ir"> <em class="la">零重表象</em> </strong>”。在这种情况下，珠子提供一种特殊的珠子类型，称为紧凑数据(简称为<code class="fe lu lv lw lx b">c_data</code>)。让我们直接看看它的运行情况:</p><pre class="mw mx my mz gt na lx nb nc aw nd bi"><span id="3afc" class="ly lz iq lx b gy ne nf l ng nh">["Max", "Maxim", "", nil, "Alex"]<br/>=&gt;<br/>[{c_data/u8}, 6, [{01010111}, 255, 254, 77, 97, 120], {c_data/u8}, 9, <!-- -->[<!-- -->{01010111}, 255, 254, <!-- -->77, 97, 120, {00000101}, 105, 109], {c_data/u8}, 0, {nil/c_data}, {u8/-}, 8, [<!-- -->{01010111}, 255, 254, <!-- -->65, 108, 101, <!-- -->{00000001}, <!-- -->120]<!-- -->]</span></pre><p id="a7e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe lu lv lw lx b">c_data</code>,我们能够将<code class="fe lu lv lw lx b">"Max"</code>减少到 75%——从 8 字节减少到 6 字节。</p><p id="642c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是通过以下技术实现的:</p><p id="09c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们创造了一串珠子。如果你仔细想想，<code class="fe lu lv lw lx b">[255, 254, 77, 0, 97, 0, 120, 0]</code>可以被看作是一个 beed 本身。不过我们知道数字都是<code class="fe lu lv lw lx b">UInt8</code>，所以可以用标志字节来存放别的东西。我们使用标志字节来存储下一个字节是否等于<code class="fe lu lv lw lx b">0</code>。这样我们减少了:</p><p id="11f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lu lv lw lx b">[255, 254, 77, 0, 97, 0, 120, 0]</code></p><p id="948c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">to ( <em class="la">位屏蔽应从右向左读</em>)</p><p id="a583" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lu lv lw lx b">[{01010111}, 255, 254, 77, 97, 120]</code></p><p id="ffb0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使序列缩短两个字节。</p><p id="3c9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，记住我们将<code class="fe lu lv lw lx b">[1, 5, 6, 7]</code>存储为<code class="fe lu lv lw lx b">[Int]</code>的例子</p><pre class="mw mx my mz gt na lx nb nc aw nd bi"><span id="0411" class="ly lz iq lx b gy ne nf l ng nh">[1, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0,]</span></pre><p id="0f2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这也是一个<strong class="ka ir"> <em class="la">零重的表象。</em> </strong>如果我们将其存储为<strong class="ka ir"> <em class="la"> </em> </strong> <code class="fe lu lv lw lx b">c_data</code>会怎么样？</p><pre class="mw mx my mz gt na lx nb nc aw nd bi"><span id="350f" class="ly lz iq lx b gy ne nf l ng nh">[{c_data/u8}, 8, [{00000001}, 1, {00000001}, 5, {00000001}, 6,{00000001}, 7]]</span></pre><p id="1fc6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们以(8 + 2)字节结束，这比 32 字节好，但仍然比 6 字节差，我们能够通过直接珠子追加来实现。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h2 id="d776" class="ly lz iq bd ma mb mc dn md me mf dp mg kj mh mi mj kn mk ml mm kr mn mo mp mq bi translated">让我们进一步了解珠子的想法</h2><p id="7244" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">我们讨论了添加数字和字符串，但是对于更复杂的数据类型呢？这一次，如果一个数据类型可以转换成<code class="fe lu lv lw lx b">Data</code>或<code class="fe lu lv lw lx b">[UInt8]</code>，我们可以像附加字符串一样附加它。然而，我们可以做得更好。假设我们想要创建一个三维向量的珠子:</p><pre class="mw mx my mz gt na lx nb nc aw nd bi"><span id="9c99" class="ly lz iq lx b gy ne nf l ng nh">struct Vector3 {<br/>  let x: Double<br/>  let y: Double<br/>  ley z: Double<br/>}</span></pre><p id="352d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以说，我们可以将每一个<code class="fe lu lv lw lx b">Vector3</code>转换成它自己的珠子数据结构，然后将它们连接在一起。</p><p id="6704" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看:</p><p id="5972" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lu lv lw lx b">Vector(x:2, y: 4, z:0)</code>可转换为<code class="fe lu lv lw lx b">[{u8/u8}, 2, 4, {u8/-}, 0]</code></p><p id="c7be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以及<code class="fe lu lv lw lx b">Vector(x:5, y: 8, z:257)</code>至<code class="fe lu lv lw lx b">[{u8/u8}, 5, 8, {u16/-}, 1, 1]</code></p><p id="9674" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以如果我们有多个向量</p><pre class="mw mx my mz gt na lx nb nc aw nd bi"><span id="5667" class="ly lz iq lx b gy ne nf l ng nh">[<br/>  Vector(x:2, y: 4, z:0), Vector(x:5, y: 8, z:257)<br/>]</span></pre><p id="4ac6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以把它们连接到下面的珠子上</p><pre class="mw mx my mz gt na lx nb nc aw nd bi"><span id="390d" class="ly lz iq lx b gy ne nf l ng nh">[{<!-- -->u8/u8}, 2, 4, {u8/-}, 0, {u8/u8}, 5, 8, {u16/-}, 1, 1<!-- -->]</span></pre><p id="0428" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个有趣的小细节。<code class="fe lu lv lw lx b">Vector3</code>有 3 个属性，这意味着第二个标签的第二部分是一个<strong class="ka ir"> <em class="la">跳过</em> </strong>标记<code class="fe lu lv lw lx b">-</code>。如果我们想快速连接两颗珠子。我们保留 skip 标记，并用第二个珠子扩展第一个珠子的底层缓冲区。然而，如果我们不想浪费内存，我们可以将第二个珠子的成员一次附加到第一个值上，从而产生以下珠子:</p><pre class="mw mx my mz gt na lx nb nc aw nd bi"><span id="3f29" class="ly lz iq lx b gy ne nf l ng nh">[{<!-- -->u8/u8}, 2, 4, {u8/u8}, 0, 5, {u8/u16}, 8, 1, 1<!-- -->]</span></pre><p id="330a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">意思是——如果我们想为每秒连接的珠子节省一个字节，我们可以做到！<em class="la">(我不确定我们是否应该这样做)</em></p><p id="fae2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一点上，我想强调一下，beads 是一个短暂的数据结构，也就是说，它不是持久的。这是一个有意识的选择，因为目标是拥有一个最小内存占用的数据结构。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h2 id="ca5f" class="ly lz iq bd ma mb mc dn md me mf dp mg kj mh mi mj kn mk ml mm kr mn mo mp mq bi translated">我们如何从珠子中读取数据？</h2><p id="1e91" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">正如我之前提到的，珠子基本上是一个序列。在 Swift 中有一个叫做<code class="fe lu lv lw lx b"><a class="ae kw" href="https://developer.apple.com/documentation/swift/sequence" rel="noopener ugc nofollow" target="_blank">Sequence</a></code>的协议，它对实现类型强加了一个要求:<strong class="ka ir">它必须提供一个迭代器</strong>。</p><p id="eac8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大多数其他语言都提供了类似的协议:</p><ul class=""><li id="5be7" class="ni nj iq ka b kb kc kf kg kj nk kn nl kr nm kv nn no np nq bi translated"><code class="fe lu lv lw lx b"><a class="ae kw" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html" rel="noopener ugc nofollow" target="_blank">Iterable</a></code>在 Java 中</li><li id="7719" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated"><code class="fe lu lv lw lx b"><a class="ae kw" href="https://msdn.microsoft.com/en-us/library/system.collections.ienumerable(v=vs.110).aspx" rel="noopener ugc nofollow" target="_blank">IEnumerable</a></code>在 C#中</li><li id="3eed" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated"><code class="fe lu lv lw lx b"><a class="ae kw" href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html" rel="noopener ugc nofollow" target="_blank">IntoIterator</a></code>在生锈</li><li id="8ce1" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated">等等…</li></ul><p id="968f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Beads 是一个<code class="fe lu lv lw lx b">Sequence</code>，迭代器提供对下一个 beads 的访问。那么作为用户，我们可以检查这个珠子是否是一个<code class="fe lu lv lw lx b">nil</code>值，或者要求将珠子解释为<code class="fe lu lv lw lx b">int</code>、<code class="fe lu lv lw lx b">uint</code>、<code class="fe lu lv lw lx b">double</code>或<code class="fe lu lv lw lx b">data</code>。如果给定的珠子不能按要求解释，我们得到一个<code class="fe lu lv lw lx b">nil</code>值。因为我们可以明确地检查一个值不是<code class="fe lu lv lw lx b">nil</code>，所以我们可以识别一个问题。</p><p id="d6aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个简单的单元测试，我们将值附加到珠子上，然后将珠子映射到一个新的数组中，并检查它是否等于初始值:</p><pre class="mw mx my mz gt na lx nb nc aw nd bi"><span id="cb50" class="ly lz iq lx b gy ne nf l ng nh">func testSequenceU8AndI8ToInt() {<br/>  var beads = BeadsSequence()<br/>  let values = [<br/>    1, 0, nil, 250, nil, 5, -5, -127<br/>  ]<br/>  for v in values {<br/>    beads.append(v)<br/>  }<br/>  XCTAssertEqual(beads.map { $0.int }, values)<br/>}</span></pre></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h2 id="497c" class="ly lz iq bd ma mb mc dn md me mf dp mg kj mh mi mj kn mk ml mm kr mn mo mp mq bi translated">复杂数据类型呢？</h2><p id="b1dd" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">为了让处理复杂数据类型变得愉快，我们引入了一个<code class="fe lu lv lw lx b">BeadsConvertible</code>协议:</p><pre class="mw mx my mz gt na lx nb nc aw nd bi"><span id="64bd" class="ly lz iq lx b gy ne nf l ng nh">public protocol BeadsConvertible {<br/>  static func from(<br/>    sequenceIterator: BeadsSequence.BeadsIterator<br/>  ) -&gt; BeadsSequence.FailableResult&lt;Self&gt;?<br/>  var numberOfBeads: Int { get }<br/>  func toBeads() -&gt; BeadsSequence<br/>}</span></pre><p id="d6eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当一个类型实现这个协议时，它允许我们将这个类型的实例转换成珠子，反之亦然。</p><p id="7fec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个单元测试，它执行从<code class="fe lu lv lw lx b"><a class="ae kw" href="https://developer.apple.com/documentation/coregraphics/cgpoint" rel="noopener ugc nofollow" target="_blank">CGPoint</a></code>阵列到珠子的往返行程:</p><pre class="mw mx my mz gt na lx nb nc aw nd bi"><span id="4089" class="ly lz iq lx b gy ne nf l ng nh">func testCGPoint() {<br/>  var sequence = BeadsSequence()<br/>  let points = [<br/>    CGPoint(x: 2, y: 4),<br/>    CGPoint(x: 2.5, y: 4.5),<br/>    CGPoint(x: 2.1, y: 4.1)<br/>  ]<br/>  for point in points {<br/>    sequence.append(point.toBeads())<br/>  }</span><span id="ce62" class="ly lz iq lx b gy nw nf l ng nh">  let pointsArray = sequence.beadsConvertibleSequence(<br/>      for: CGPoint.self<br/>  ).map { try?$0.get() }</span><span id="0075" class="ly lz iq lx b gy nw nf l ng nh">  XCTAssertEqual(points, pointsArray)<br/>}</span></pre></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h2 id="95ce" class="ly lz iq bd ma mb mc dn md me mf dp mg kj mh mi mj kn mk ml mm kr mn mo mp mq bi translated">观点</h2><p id="3ffb" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">Beads 是一种专门的数据结构，在内存占用和数据局部性很重要的用例中非常有用。它还被设计成数据序列化格式的平台。它有它的局限性，例如，它只能附加，但这也是它能做好一件事的原因。</p><p id="c9e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我很想听听你们的想法、关切和建议。</p><p id="2cc5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我会尽快把链接添加到 github 库。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h2 id="c878" class="ly lz iq bd ma mb mc dn md me mf dp mg kj mh mi mj kn mk ml mm kr mn mo mp mq bi translated">2018 年 8 月 26 日更新:</h2><p id="120e" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">我很高兴地宣布，珠数据结构是在 Github:</p><div class="nx ny gp gr nz oa"><a href="https://github.com/beads-data-structure" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">珠子数据结构</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">GitHub 是人们构建软件的地方。超过 2800 万人使用 GitHub 来发现、分享和贡献超过…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo jw oa"/></div></div></a></div></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h2 id="cc31" class="ly lz iq bd ma mb mc dn md me mf dp mg kj mh mi mj kn mk ml mm kr mn mo mp mq bi translated">2019 年 5 月 31 日更新:</h2><p id="05af" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">由于珠子用于 Dart，我们引入了另一种(最后一种可能的)珠子类型— <strong class="ka ir"> TinyData。</strong></p><p id="5e96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当存储的字节数组小于 16 字节时，使用微小数据。在这种情况下，数据的长度可以存储为一个标签(4 位):</p><p id="4be9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lu lv lw lx b">"Maxim" =&gt; [{t_data/5}, [77, 97, 120, 105, 109]]</code></p><p id="f945" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，我们为每个项目节省了一个字节。</p><p id="7138" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目前只能在 dart 存储库中找到微小数据的实现:</p><div class="nx ny gp gr nz oa"><a href="https://github.com/beads-data-structure/beads_dart" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">珠子-数据-结构/珠子 _ 镖</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">Dart 的珠子数据结构。通过在…上创建帐户，为 beads-data-structure/beads _ dart 开发做出贡献</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="op l ol om on oj oo jw oa"/></div></div></a></div><p id="9279" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其他实现也将随之而来。</p></div></div>    
</body>
</html>