# Python 的 Lambda 表达式、映射和过滤器

> 原文：<https://towardsdatascience.com/understanding-the-use-of-lambda-expressions-map-and-filter-in-python-5e03e4b18d09?source=collection_archive---------8----------------------->

## 函数式编程值得吗？

![](img/93d53d8a0b17c4297ab3331dcd57ad69.png)

Welcome to the Functional Church, where [laziness](https://en.wikipedia.org/wiki/Lazy_evaluation) is not a sin. Source: [Pixabay](https://pixabay.com/en/church-christianity-cathedral-3481187/)

Python 的 Lambda 表达式，使用 *lambda* 运算符，是[颇有争议的](https://www.quora.com/Why-did-Guido-van-Rossum-want-to-remove-lambda-from-Python-3)。有人说它们笨重，有人说它们优雅。

作为一个喜欢函数式编程范例的人，我喜欢不时地在我的代码中加入一些表达式，只要是少量的。
然而，我确实看到了如何将一个有点长的关键字放在一行的中间，并在假设它不会在程序的其余部分中使用的情况下匿名定义一个函数，这可能最终会成为一个问题。

但是，不要急于求成，让我们从定义相关术语开始:

![](img/f3d8215f6df6c0d05d0a4ef402b51500.png)

Lambdas are Anonymous. They never forgive, they never forget. Expect them. Source: P[ixabay](https://pixabay.com/en/vendetta-mask-guy-fawkes-face-man-157703/)

## 什么是 Lambda 表达式？

表达式是一个函数的匿名内联声明，通常作为参数传递。它可以做常规函数能做的任何事情，除了它不能在定义它的行之外被调用，因为它是匿名的:它没有名字。

上面的代码片段显示了使用一个定期定义的函数(或强制定义的，对于那些在角落里感觉被我的命令式特权谈话歧视的功能人员来说)、一个由 *lambda* 定义并分配给变量的函数(这是可以做到的，但通常被视为一种不好的做法)和一个对 *lambda* 函数的内联调用之间的比较(我甚至不需要告诉你为什么这不应该做得太多)。

这三段代码最终返回相同的值，但是每一段在作用域和内存方面都有不同的效果:两段代码为程序的其余部分定义了一个可调用的对象，而最后一段代码创建了一个不会在任何其他行中调用的匿名函数。

如果你还不能流利地理解列表，这里有一个常规的、命令式的 *for 循环*示例:

你可能会同意 *map* 比常规的 *for-loops* 不那么笨拙，占用的空间也更少，但是可能比 List Comprehensions 稍欠直观。

我们已经谈论了太多的批评(代码更难阅读，一个笨拙的关键字)，让我们谈谈实际的一面。

## 映射和过滤:利用 lambda 表达式

下面我们再介绍两个 Python 的原生关键词:*贴图*和*滤镜。*

对于不熟悉函数式编程的人来说，map 函数是一个高阶函数，即至少接受一个函数作为输入，或者产生一个函数作为输出。

在它的正式定义中，它的参数是一个函数和一个序列(任何可迭代对象)，它的输出是另一个序列，包含将给定函数应用于所提供序列中每个元素的结果，顺序相同。

听起来熟悉吗？那是因为在一个列表上调用一个函数的映射几乎等同于使用一个[列表理解！](http://www.datastuff.tech/programming/pythons-list-comprehensions-uses-and-advantages/)不过，这种说法有一些注意事项，我会尽快解决。

以下等价关系几乎成立:

注意，在最后两行中，我传递了三次和三次函数作为参数，这要感谢 *map* 是一个高阶函数。

如果你迭代这五个变量中的每一个，它们都会产生相同的值。然而*在 Python 3+中，*在打印它们时，你会看到一些是列表，而另一些是*地图对象*。没错，在一个列表上应用*映射*会返回一个[生成器](/pythons-list-generators-what-when-how-and-why-2a560abd3879)！这基本上意味着它将生成一个延迟求值的序列，可以迭代，并且必须转换到一个列表中才能切片或索引。另一方面，在 Python 2.7 中， *map* 返回一个普通的*列表*。

这就是图和图产生协同作用的地方:就像用图和 T21 写一条线一样流畅，如果你能即时发明你的小功能，它会变得更加流畅。一旦你掌握了它，你将开始考虑映射，并欣赏这个特性。但是请注意，如果*地图*无人看管，不可读的代码会很快溃烂。

作为补充，我还将向您介绍*滤镜。*在序列中调用*过滤器*与在列表理解的末尾添加一个 *if* 是一样的，除了它留下了功能性的余味。以下代码片段是等效的:

与*映射一样，过滤器*返回一个生成器(在这种情况下是一个*过滤器对象*)，但是将它转换成一个*列表*表明它相当于在一个列表理解中使用一个*。*

## 地图比列表理解更快吗？滤镜呢？

我运行了几个基准测试，比较普通的 *for-loops* ，List Comprehensions 和 *map* 。我不确定结果会是什么，但是有一些关于它们的理论。

以下是我在进行实验之前定义的一些东西:

这是我运行的基准测试的代码:

我比较了一个使用*追加*调用的常规命令式*列表*声明，一个使用列表理解，最后一个调用*映射。*

在 Python 2.7 中，我的结果如下:

*   列表 a 为 6.00 秒
*   名单 b 为 4.12 秒
*   列表 c 的 3.53 秒(使用*映射*的列表)

关于 Python 2.7 中的优化 *map* 用了什么，我其实不知道也没有什么理论，但是出来的速度比列表理解还快！因此，在后者的清晰度和前者的速度之间做出选择时，需要做出权衡。需要注意的是，我多次运行这个实验，并且得到了一致的结果。

在 Python 3 中，我得到了令人惊讶的结果:map*测试用了不到一毫秒，而 list comprehension 测试用了 5 秒！这时，我记得将结果转换成一个列表*以使操场公平，因为生成器当然会加载得更快，这要感谢不必初始化它的值。这些是结果:**

*   列表 a 为 7.08 秒
*   列表 b 为 5.1 秒
*   列表 c 为 5.1 秒

我不得不多次运行这个程序来检查，但是它们基本上花费相同的时间。很明显，他们都在做非常相似的事情，于是他们之间的选择就变成了清晰和懒惰是否有用。

综上所述， *lambdas* 可能很笨重，但是它们也为你的代码增加了很多表达能力。 *Filter* 和 *map* 对某些人来说可以是优雅的，但在性能方面不会给表格增加很多(并且被一些人视为不如 List Comprehensions 那么 Pythonic 化)。

我个人的观点是，我喜欢 Python 有这些特性，因为它们让一些代码行更漂亮，但通常不像列表理解那样喜欢它们。如果没有[尾部调用消除](https://stackoverflow.com/questions/1240539/what-is-tail-recursion-elimination)和其他优化，除了风格和懒惰(*好的那种)之外，要举出在 Python 中使用函数式编程的好理由可能有点困难(尽管我们实际上可以从在 Haskell 中使用函数式编程中获得很多好处)!*)。

你的观点是什么？你还想让我讨论其他功能性话题吗？我不提*减*或*折*你生气吗？你希望 Python 中引入哪些其他功能性的东西？哪些是你不喜欢的？我相信你对此有自己的看法，我也很想了解更多。我也很想知道是否有一些非平凡的例子，在这些例子中, *map* 实际上比 List Comprehensions 更快，但我没有看到它们。

这是我对 Python 中函数式编程特性的介绍，我希望您发现它很有用，或者至少在阅读它的过程中获得了一些乐趣。

*你可以在我的* [*个人网站*](http://strikingloo.github.io/wiki) *中看到我正在做的事情以及我最近的文章和笔记。*