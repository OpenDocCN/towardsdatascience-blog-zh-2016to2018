<html>
<head>
<title>AddressNet: How to build a robust street address parser using a Recurrent Neural Network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AddressNet:如何使用递归神经网络构建一个健壮的街道地址解析器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/addressnet-how-to-build-a-robust-street-address-parser-using-a-recurrent-neural-network-518d97b9aebd?source=collection_archive---------5-----------------------#2018-12-05">https://towardsdatascience.com/addressnet-how-to-build-a-robust-street-address-parser-using-a-recurrent-neural-network-518d97b9aebd?source=collection_archive---------5-----------------------#2018-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bd45b83e14cc33a5a18b680baa4190e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T6Lvt-haiByXrrlA_GYKmw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Australian Postage stamps, image by author</figcaption></figure><p id="acde" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">街道地址是复杂的野兽；它们被设计成对我们人类来说是系统的和明确的，但对机器来说却是一场灾难。事实上，你将为谷歌的每 1000 次地址查询支付<a class="ae la" href="https://developers.google.com/maps/billing/understanding-cost-of-use" rel="noopener ugc nofollow" target="_blank">5 美元，澳大利亚邮政将为你提供</a><a class="ae la" href="https://auspost.com.au/business/marketing-and-communications/access-data-and-insights/address-data/address-validation" rel="noopener ugc nofollow" target="_blank">一批经过认证的“解决方案提供商”</a>，同时还为那些预先分拣邮件并为其贴上条形码的人(即做艰苦工作的人)提供折扣。</p><p id="f974" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">维护结构化地址数据的价值超出了过去的邮资。将地址简化为地理坐标(地理编码)的能力可以为一些看似简单的问题提供答案，比如“我在哪里的销售额最高？”，但不需要太多的想象力就能看出如何从一个人的位置得出各种各样的关联，例如公共卫生部门的<a class="ae la" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4718356/" rel="noopener ugc nofollow" target="_blank"/>(我目前工作的行业)。</p><p id="f611" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当然，从一开始就以结构化的方式收集这些信息是有意义的，但是如果您有一个手动输入且未经验证的地址记录的遗留数据集，该怎么办呢？如果你在 StackOverflow 上问…的<a class="ae la" href="https://stackoverflow.com/questions/2355597/java-parse-australian-street-addresses" rel="noopener ugc nofollow" target="_blank">无辜的问题</a></p><blockquote class="lb lc ld"><p id="3bf4" class="kc kd le ke b kf kg kh ki kj kk kl km lf ko kp kq lg ks kt ku lh kw kx ky kz ij bi translated">寻找一种快速而简单的方法将澳大利亚的街道地址解析成各个部分:<br/> <code class="fe li lj lk ll b">3A/45 Jindabyne Rd, Oakleigh, VIC 3166</code></p></blockquote><p id="7c6e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">…您将很快被告知"<a class="ae la" href="https://stackoverflow.com/a/2359806" rel="noopener ugc nofollow" target="_blank">您将获得完全无用的数据</a>"，然后您将看到一个类似于的<a class="ae la" href="https://stackoverflow.com/a/43840487" rel="noopener ugc nofollow" target="_blank">正则表达式:</a></p><pre class="lm ln lo lp gt lq ll lr ls aw lt bi"><span id="072f" class="lu lv iq ll b gy lw lx l ly lz">(?P&lt;Unit_Number&gt;\d*)\s*[\/,\,]\s*(?P&lt;Street_Number&gt;\d*)\s*(?P&lt;Street_Name&gt;[a-zA-Z\s]*),?\s*(?P&lt;State&gt;NSW|ACT|NT|QLD|SA|TAS|VIC|WA)\s*(?P&lt;Post_Code&gt;\d{4})| (?P&lt;street_number&gt;\d*)\s*(?P&lt;street_name&gt;[a-zA-Z\s]*),?\s*(?P&lt;state&gt;NSW|ACT|NT|QLD|SA|TAS|VIC|WA)\s*(?P&lt;post_code&gt;\d{4})</span></pre><p id="60b4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对复杂和无情的正则表达式感到沮丧和悲伤，你会偷偷溜走，在 instagram 上查找#ferrets，因为这才是互联网的真正目的。</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="5fbf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我是来告诉你不要难过的。我的意思是，观察雪貂；毕竟他们很可爱…我不想剥夺你的可爱。但是一旦你完成了，回来。我将向您展示如何构建自己的地址解析机器。</p><p id="8097" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">遵循传统的神经网络命名法[Thing]+Net 的 address Net 是一个漂亮的模型，它通过给地址的位标上<a class="ae la" href="https://github.com/jasonrig/address-net/blob/master/README.md#model-output" rel="noopener ugc nofollow" target="_blank">22 个可能组成部分</a>中的任何一个来整理它们，并且基于<a class="ae la" href="https://data.gov.au/dataset/geocoded-national-address-file-g-naf" rel="noopener ugc nofollow" target="_blank">GNAF 数据库</a>。这是我在 TensorFlow 上花了大约一周时间研究的成果(也让我自己从机器学习的间隙中解脱出来)——我确信一个更有才华的人可以在更短的时间内完成这个(现在的孩子们)。</p><p id="3db3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">TL；dr:如果你想要一个 Python API 来分割你的澳大利亚街道地址，试试吧。</strong></p><pre class="lm ln lo lp gt lq ll lr ls aw lt bi"><span id="70b1" class="lu lv iq ll b gy lw lx l ly lz">&gt;&gt;&gt; from addressnet.predict import predict_one<br/>&gt;&gt;&gt; print(predict_one("3A/45 Jindabyne Rd, Oakleigh, VIC 3166"))<br/>{'flat_number': '3', 'flat_number_suffix': 'A', 'number_first': '45', 'street_name': 'JINDABYNE', 'street_type': 'ROAD', 'locality_name': 'OAKLEIGH', 'state': 'VICTORIA', 'postcode': '3166'}</span></pre><p id="819e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">嘣。</p><p id="55c6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">那么这个诡计是如何运作的呢？很抱歉，我不能公正地对待这个理论；许多比我更聪明的人在这些话题上写了很多。因此，我将从较高的层面解释 AddressNet 中使用的过程，并链接到我最喜欢的作者，他们优雅的解释不值得在此复制。</p><p id="a5c9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">address net 模型的核心是一个递归神经网络</strong> (RNN)，它们非常擅长模拟序列数据(在这种情况下，是一系列字母)。这种神经网络通常用图表表示为:</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mc"><img src="../Images/b4afc2c64bd2ce6edfe3567006c29056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mlz9kXp4iwXwfxnmxw4bNw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A typical representation of RNNs (left and right are equivalent)</figcaption></figure><p id="b732" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在上图中，<em class="le"> x </em>是输入数据序列中的一项，<em class="le"> y </em>是某个目标的估计或输出。左边的环形箭头，以及右边同样标有“<em class="le"> h </em>”的水平箭头，代表一种“隐藏状态”每个输入都有下标(<em class="le"> t </em> -1、<em class="le"> t </em>、<em class="le"> t </em> +1 等)。)指示特定序列元素起源的点，这通常被称为“时间步长”(尽管这通常不是字面意义上的时间，而是通过元素的“定向行进”)。中间的大 ol’圆形斑点包含产生<em class="le"> y </em> s 和<em class="le"> h </em> s 的所有矩阵运算，但是一定要注意每个斑点都是<em class="le">相同的</em>；完全相同的内部参数被应用于每个输入的<em class="le"> h </em>和<em class="le"> x </em>，从而使它们<em class="le">重复</em>。</p><p id="741d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">【推荐阅读:<a class="ae la" href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/" rel="noopener ugc nofollow" target="_blank">递归神经网络的不合理有效性</a></p><p id="0048" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">RNNs 的工作方式可以简单地解释如下:对于序列中的每一项数据，使用前一步的隐藏状态以某种方式对其进行转换，以估计目标输出，同时更新隐藏状态以移交给下一步。这种神秘的隐藏状态可以被认为是“扫描序列时收集的知识”，它的功能是一种记忆。RNN 体系结构的许多变体都围绕着如何管理隐藏状态，最常见的类型是 LSTM 和 GRU 类型的 rnn(address net 使用 GRU 类型的 RNN)。</p><p id="9ed4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">【推荐阅读:<a class="ae la" href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" rel="noopener ugc nofollow" target="_blank">了解 LSTM 网络</a>；<a class="ae la" rel="noopener" target="_blank" href="/understanding-gru-networks-2ef37df6c9be">了解 GRU 网络</a></p><p id="05f6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">能够将序列中较早的信息向前传递是 RNNs 的关键优势。例如，在自然语言处理中，诸如复数和性别之类的语法概念以及相应的词的变化经常是远距离链接的。想象一下，一个 RNN 被设计用来识别不恰当的动词形式；一个简单的语法检查器，如果你愿意:</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi md"><img src="../Images/7897df089b1f8a7a9fc15a319dcd2b87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jZfSwp88axzXjVA2PQkXBA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A hypothetical NLP RNN to detect grammar issues. Long distance dependencies highlight the importance of “memory”</figcaption></figure><p id="d892" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">每个<em class="le"> x </em>代表句子的一个单词，如果没有错误，每个<em class="le"> y </em>产生 0，如果有错误，产生 1。这里，动词“is”实际上应该是“are ”,因为名词“diagrams”是复数。保留先前元素的一些记忆的能力允许这个假设的网络生成被框定为“<em class="le">的结果鉴于我到目前为止所看到的</em>，当前元素是错误的概率是多少？”</p><p id="262c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">RNN 可以扩展为多层(每一步的输出作为另一个 RNN 的输入输入)，它们也可以与一个等效的 RNN 配对，其中水平箭头处于相反的方向，向后传递隐藏状态，有效地查看“未来”以了解“过去”后者被称为双向 RNN。</p><p id="1186" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">【推荐阅读:<a class="ae la" href="https://ieeexplore.ieee.org/abstract/document/650093" rel="noopener ugc nofollow" target="_blank">双向递归神经网络</a> / <a class="ae la" href="https://maxwell.ict.griffith.edu.au/spl/publications/papers/ieeesp97_schuster.pdf" rel="noopener ugc nofollow" target="_blank"> PDF </a></p><p id="b57f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">AddressNet 基于每个字符使用多层双向 RNN。双向性是特别重要的:考虑一下地址“10 24–26 高街路，芒特韦弗利”给每个角色分配一个类别，而对于第一个角色来说，仅仅向前看几乎是不可能的！<em class="le">是的</em>，可能单位/平号是最常出现的第一个字，<em class="le">可能</em>整体来说单位比单机多，所以我们<em class="le">可能</em>统计上有机会，但真的只是瞎猜。类似地，在没有任何预见未来的能力的情况下，“街道”很可能是指街道的类型…但是当我们遇到“道路”时，才发现我们犯了一个错误，这个名称实际上是“道路”类型的“高街”在 AddressNet 实现中，与上面的图表不同的一点是，AddressNet RNN 的输出不是直接的预测，而是向前和向后传递连接在一起，并通过最终的“完全连接”神经网络-这些是标准的教科书网络，在谷歌图像搜索中排名第一。如果你想了解这个网络的具体实现，请查看这部分代码。</p><p id="74bc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">但是人物首先是怎么表现出来的呢？</strong>什么<em class="le">是</em>的‘A’？我们如何将字母“A”塞进这个神奇的数学包中呢？在神经网络中有两种主要的方法可以表示文本数据:“一键”向量方法和密集的“嵌入向量”方法。前者由一个和我们的词汇一样长的向量组成(可以是一系列单词、字符，甚至是表情符号🤷‍♀️),在对应于我们的字典中的项目的索引处包含“1 ”,在其他地方包含“0 ”,而嵌入向量方法是通过任意长(但通常比词汇表短得多)的向量来实现的，该向量具有由模型学习的参数；也就是说，即使是表象本身也随着我们的训练而优化。历史上，嵌入向量已经被用于<a class="ae la" href="https://arxiv.org/abs/1711.00331" rel="noopener ugc nofollow" target="_blank">导出语义单词关系</a>，但是这里我只是将它们用于降维(并且我通常喜欢优化输入参数的想法)。AddressNet 使用嵌入方法，每个字符有八个单位的短向量。</p><p id="8b12" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">【推荐阅读:<a class="ae la" href="https://www.tensorflow.org/guide/embedding" rel="noopener ugc nofollow" target="_blank"> TensorFlow docs </a>，以及任何关于单词嵌入的东西(例如米科洛夫<a class="ae la" href="https://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf" rel="noopener ugc nofollow" target="_blank">的 word2vec 论文</a>)】</p><p id="3155" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">我们来谈谈训练数据。</strong>唉，我过去没有——现在也没有——任何标记过的、精选过的真实地址数据。相反，我的方法是综合生成尽可能多的随机排列(在某些情况下几乎无法理解),这些排列仍然在合理的范围内。有<a class="ae la" href="https://github.com/jasonrig/address-net/blob/2e17b38b2fbf0de08aeb51cce7de6dc824301438/addressnet/dataset.py#L238" rel="noopener ugc nofollow" target="_blank">代码</a>的大杂烩，可以被破译以理解我屠杀 GNAF 数据集的精确方式，但本质上代码为 GNAF 数据集中的每条记录做出以下决定:</p><ol class=""><li id="0607" class="me mf iq ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated">保留还是放弃郊区？</li><li id="ef9b" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">保持还是放弃状态？</li><li id="bf98" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">缩写州名？(例如将“维多利亚”改为“维克”)</li><li id="0aea" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">保留还是删除邮政编码？</li><li id="f1bd" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">保留还是放弃街道号码？</li><li id="f748" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">简称街道类型？(例如将“道路”改为“道路”)</li><li id="9f0f" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">保留还是删除单位类型？</li><li id="c9d6" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">把等级数转换成序数或基数词？(例如，将“1”更改为“1st”或“first”)</li></ol><p id="2665" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，这些组件以一种特殊的方式被打乱(例如，将州和邮政编码之类的东西放在靠近末尾的地方)，然后每个组件都<a class="ae la" href="https://github.com/jasonrig/address-net/blob/2e17b38b2fbf0de08aeb51cce7de6dc824301438/addressnet/typo.py#L45" rel="noopener ugc nofollow" target="_blank">受到一些随机破坏</a>，这有点像人类可能犯的错别字。错别字包括:</p><ol class=""><li id="b8b5" class="me mf iq ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated">字符替换(使用键盘上邻近的字符)</li><li id="1fac" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">删除</li><li id="cd62" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">调换</li><li id="fc5e" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">复制</li></ol><p id="3f1c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，使用一些随机分隔符将每个组件缝合在一起。这些可能是空格、破折号、斜线或句号(取决于地址的部分)。</p><p id="e90d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是为什么呢？有两个原因:首先，这些很可能会在现实世界中发生，模型应该足够健壮来处理这些。其次，这种额外的噪声旨在作为一种正则化的形式，正则化是一个术语，指的是降低模型过度拟合可能性的方法。</p><p id="3703" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正确地改变和破坏数据是当务之急！在开发这个模型的时候，我敏锐地意识到我没有测试数据；我无法通过<em class="le">先验</em>的方式知道这个模型在现实世界中的表现如何。理想情况下，我会有一个从手动输入的地址完全标记的测试集，但我只是一个人在业余项目工作。因此，对我来说，关键是要确保输入数据中有如此多的可变性，以至于模型复杂性不能开始“学习噪音”训练有素的模型的经验表明，我击中了目标，但我会喜欢你，读者，给它一个机会，让我知道它如何进行。我知道，我知道，没有测试数据是我的耻辱😔。</p><p id="8049" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">准备好试试了吗？</strong>我敢肯定你说是。只是皮普安装它，看看你怎么想:<a class="ae la" href="https://github.com/jasonrig/address-net" rel="noopener ugc nofollow" target="_blank">https://github.com/jasonrig/address-net</a></p><p id="ff5d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">欢迎投稿、反馈、指正和建议。如果你在自己的项目中使用 AddressNet，或者对其进行修改，请告诉我。希望您的地址数据永远不需要正则表达式。🙏</p></div></div>    
</body>
</html>