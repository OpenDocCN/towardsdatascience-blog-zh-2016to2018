<html>
<head>
<title>How to build an image duplicate finder for your dataset</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为数据集构建图像重复查找器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-an-image-duplicate-finder-f8714ddca9d2?source=collection_archive---------12-----------------------#2018-11-25">https://towardsdatascience.com/how-to-build-an-image-duplicate-finder-f8714ddca9d2?source=collection_archive---------12-----------------------#2018-11-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ff2e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">借助神经网络隐藏层执行图像相似性分析</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/08f7d39a1e09d4b681d6581385e436a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*-7Ck_gNu5GpLU7qhHfgqyg.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">This is a duplicate found by the algorithm</figcaption></figure><p id="0fe8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当你从网上下载图片时，你通常会发现有噪音的数据。此外，流行的图片到处都是。一个接一个地查看它们并试图找到重复项来清理数据集是很乏味的。</p><p id="e9e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">考虑到这个问题，我构建了一个重复查找器来为您查找重复项，因此您只需选择是否要删除它们。你可以在<a class="ae ln" href="https://github.com/fastai/fastai" rel="noopener ugc nofollow" target="_blank"> fastai </a>库中找到代码。在这篇文章中，我将解释我是如何构建这个工具的。</p><h2 id="b0bb" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">步骤 1:获取激活</h2><p id="aed8" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">我们通常使用 CNN 对图像进行分类，我们只对网络末端 softmax 的输出感兴趣，它会告诉我们网络认为我们图像的标签是什么。在这种情况下，我们将比较网络的内层，希望网络学习的一些特征有助于找到相似的图像。为了实现这一点，我利用了 fastai 库中强大的<a class="ae ln" href="https://docs.fast.ai/callbacks.hooks.html" rel="noopener ugc nofollow" target="_blank"> <em class="mm">钩子</em> </a> <em class="mm"> </em>功能，它允许我们保存网络中任何子层的激活。</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="a358" class="lo lp iq mo b gy ms mt l mu mv">hook = hook_output(learn.model[0][7][2])</span></pre><p id="6444" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我使用的激活是 Resnet 架构的最后一个卷积块的输出，因为我注意到它们在经验上工作得更好。</p><h2 id="aa92" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated"><strong class="ak">第二步:合并</strong></h2><p id="bbe1" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">您可能知道，CNN 中的隐藏层有四个维度:批量大小、特征数量、高度和宽度。让我们假设我们正在谈论一个特定的图像，或者 bs=1。例如，在 Resnet 50 的情况下，最后一层的输出将具有维度(<em class="mm"> 1，512，7，7)。</em>由于这里的维数非常高，计算相似度将非常耗时，这对用户来说是一种痛苦。这个问题的答案是用<a class="ae ln" href="http://deeplearning.stanford.edu/tutorial/supervised/Pooling/" rel="noopener ugc nofollow" target="_blank">池</a>。我们将汇集每一个<em class="mm"> 7x7 </em>矩阵，从而得到一个维度为<em class="mm">的张量(1，512，pool_dim，pool_dim)。</em></p><p id="12fb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我使用的池函数是 AdaptiveConcatPooling(自适应平均池和自适应最大池连接在一起),我使用的池维数是 4，因为我发现它是速度和性能的良好组合。</p><h2 id="3979" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">第三步:展平</h2><p id="fda6" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">我们用一个四维张量结束了最后一步。然而，为了计算不同例子之间的相似性，我们需要一维张量(向量)。我们将展平每个图像的激活，以获得大小为<em class="mm"> pool_dim x pool_dim x 512 </em>的向量，并将每个图像的向量连接成一个具有维度的矩阵(<em class="mm"> n_exs，vector_dim </em>)。现在我们有了每个<em class="mm"> n_exs </em>图像的特征向量。是时候计算相似度了！</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="1640" class="lo lp iq mo b gy ms mt l mu mv">def get_actns(learn:Learner, dl:DataLoader, hook:Hook, pool=AdaptiveConcatPool2d, pool_dim:int=4, train:bool=True):<br/>"""Gets the activations at the layer specified by `hook`, <br/>   applies `pool` of dim `pool_dim` and concatenates."""</span><span id="14e5" class="lo lp iq mo b gy mw mt l mu mv">    pool = pool(pool_dim) <br/>    <br/>    actns = []<br/>    learn.model.eval()<br/>    with torch.no_grad():<br/>        for i,(xb,yb) in enumerate(dl):<br/>            learn.model(xb)<br/>            actns.append((hook.stored).cpu())<br/>                                    <br/>    return pool(torch.cat(actns)).view(len(dl.x), -1)</span></pre><h2 id="b920" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">第四步:计算相似度</h2><p id="ead0" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">为了计算每个特征向量之间的相似度，我们将使用<a class="ae ln" href="https://en.wikipedia.org/wiki/Cosine_similarity" rel="noopener ugc nofollow" target="_blank">余弦相似度函数</a>。请注意，如果我们将每个向量与其他向量相结合，所有的相似性都会被计算两次。还要注意，如果我们计算一个向量与其自身的相似性，相似性的度量显然是最高的。因此，对于我们的相似性矩阵，我们将用零替换对角线和右上部分。</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="0e27" class="lo lp iq mo b gy ms mt l mu mv">def comb_similarity(t1: torch.Tensor, t2: torch.Tensor, sim_func=nn.CosineSimilarity(dim=0)):<br/>    """Computes the similarity function `sim_func` between each embedding<br/>       of `t1` and `t2` matrices.<br/>       t1` and `t2` should have dimensions [n_embeddings, n_features]."""<br/>    <br/>    self_sim = False<br/>    if torch.equal(t1, t2): self_sim = True<br/>        <br/>    sims = np.zeros((t1.shape[0], t2.shape[0]))<br/>    for idx1 in range(t1.shape[0]):<br/>        for idx2 in range(t2.shape[0]):<br/>            if not self_sim or idx1&gt;idx2:<br/>                ex1 = t1[idx1,:]<br/>                ex2 = t2[idx2,:]<br/>                sims[idx1][idx2] = sim_func(ex1,ex2)<br/>                <br/>    return sims</span></pre><h2 id="fdcb" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">第五步:结果</h2><p id="3c16" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">看看我们的方法行不行！让我们看看我们数据集中最相似的图像，看看我们是否能找出一些重复的(我在这里贴了一些截图，更多请访问我的<a class="ae ln" href="https://github.com/fpingham/duplicate-finder/blob/master/duplicates_v5.ipynb" rel="noopener ugc nofollow" target="_blank"> repo </a>)。我用来测试算法的数据集是牛津-IIIT 宠物数据集，有 37 种狗和猫。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/79e2c994de59508e771428f9f8818606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h8lyZSDQo08m-99Q6TbDvQ.png"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Perfect duplicates. This image was included 5 times in the dataset.</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/80c4da480868551fe49d92dc774068f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*0mXAMjHMNsz-JBGDZIWrNw.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Duplicates (one has a signature)</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nd"><img src="../Images/17bb5cfeda4e9d1518c332c6bbd66241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QmkyWL6W6kFCXUWfjmwL3w.png"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Similar but not duplicates</figcaption></figure><p id="5034" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我还用 CIFAR10 测试了该算法，cifar 10 是计算机视觉中一个著名的数据集，看我能否找到一些重复的数据。这些是我发现的一些例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ne"><img src="../Images/4aa3ef7901d39eb718679d91ae3ce5ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BpFZyOVKUPVoLiIb3qt94g.png"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Perfect duplicate</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nf"><img src="../Images/c3288ac2b8131e8c783400b7ca6b93a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1fB5CXzPsu8SVqfjM1pToQ.png"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Nearly a duplicate truck but with different logos</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nf"><img src="../Images/53ffaae9c7b962b9e13b7eafe54b635d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JPc1BSkxN3xHSjugs1fpyw.png"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Not a duplicate, more like data augmentation</figcaption></figure><p id="27c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我还运行了 relabeler 小部件，这里有一个额外的有趣发现:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/3454a38ea9e4fdcc671d08a9cb481d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*kcGzoFXhPag8emrsIcx3Mw.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Not a truck</figcaption></figure><p id="09ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦我们有了网络对复制品的建议，我们该怎么处理它们呢？嗯，我们应该选择那些实际上是重复的，并从我们的数据集中删除它们，因为有重复会导致网络对这些图像给予太多的重视。怎样才能轻松删除重复？有了 fastai 的互动小工具就非常容易了！您可以通过运行以下命令来尝试一下:</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="cfae" class="lo lp iq mo b gy ms mt l mu mv">from fastai.widgets import *</span><span id="68eb" class="lo lp iq mo b gy mw mt l mu mv">ds, fns_idxs = DatasetFormatter.from_similars('learner')<br/>ImageCleaner(ds, fns_idxs, path, duplicates=True)</span></pre><p id="ba0f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">想用吗？用 CIFAR 查看我的<a class="ae ln" href="https://github.com/fpingham/dataset-cleaner" rel="noopener ugc nofollow" target="_blank">教程笔记本</a>。</p></div></div>    
</body>
</html>