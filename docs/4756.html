<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://towardsdatascience.com/nba-data-science-93e0314bb45e?source=collection_archive---------4-----------------------#2018-09-05">https://towardsdatascience.com/nba-data-science-93e0314bb45e?source=collection_archive---------4-----------------------#2018-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><p id="5082" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">几年前，科比·布莱恩特退役后不久，<a class="ae jn" href="https://www.kaggle.com/c/kobe-bryant-shot-selection" rel="noopener ugc nofollow" target="_blank"> Kaggle 发布了一个数据集，其中包含了他 20 年的照片。这是一个很大的挑战，我在想:篮球和数据科学……你还能问什么？</a></p><p id="e0bc" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">所以这里有一篇关于如何建立一个简单的分类模型来预测它是在 in 还是 rim 的文章。目的是讨论从数据探索到模型调整以及最终评估，人们可以利用的直觉和实践<em class="jo">端到端</em>、<em class="jo">逐步</em>。也强调<em class="jo">简单。</em>决策树(这就是我们正在构建的)不会让你赢得比赛，但构建一个简单模型的过程也可能是现实世界中整个工作的 80%。</p><figure class="jp jq jr js gt jt"><div class="bz fp l di"><div class="ju jv l"/></div><figcaption class="jw jx gj gh gi jy jz bd b be z dk">Bryant was one of the most important players in the history of NBA. He played for a full 20 years with L.A. Lakers. He is the all time top scorer of the team and he is considered by many to be the <a class="ae jn" href="http://www.espn.co.uk/nba/story/_/page/nbarankSGs/ranking-top-10-shooting-guards-ever" rel="noopener ugc nofollow" target="_blank">second best shooting guard in the history of NBA </a>behind Michael Jordan. Watch ten of his most impossible shots. They are most probably included in the dataset used next.</figcaption></figure><p id="be1a" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">是时候采取一些数据行动了…</p><h1 id="4645" class="ka kb iq bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">1.工具</h1><p id="98db" class="pw-post-body-paragraph io ip iq ir b is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji lc jk jl jm ij bi translated">我将使用<a class="ae jn" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank">熊猫</a>、<a class="ae jn" href="http://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> Jupyter 笔记本</a>和<a class="ae jn" href="http://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> Scikit-Learn </a>。为了可视化，我将使用<a class="ae jn" href="http://seaborn.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Seaborn </a>和<a class="ae jn" href="http://www.graphviz.org/" rel="noopener ugc nofollow" target="_blank"> Graphiz </a>。我还将简单地使用 Tableau 进行快速探索(虽然这绝对不是必需的，您可以使用 Python 的工具来完成同样的工作，我只是碰巧手头有它，所以想尝试一下)。</p><h1 id="3e21" class="ka kb iq bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">2.了解数据集</h1><p id="071e" class="pw-post-body-paragraph io ip iq ir b is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji lc jk jl jm ij bi translated">第一步是探索手头的数据集。本文件由 Kaggle: <code class="fe ld le lf lg b">data.csv</code>提供。我们只知道<code class="fe ld le lf lg b">shot_made_flag</code>字段是目标变量:如果科比投篮得分，它的值是 1；如果他投篮失败，它的值是 0。其他一切还有待调查。</p><p id="d68d" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">将在整个项目中使用的设施的必要进口:</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lh"><img src="../Images/12073d7546091e0266dcb5c990820fb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i4Fw4K1X4tBVsrNX7XKMEg.png"/></div></div></figure><p id="508e" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">让我们从典型的熊猫设施开始探索:<code class="fe ld le lf lg b">info()</code>和<code class="fe ld le lf lg b">describe()</code>。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lh"><img src="../Images/21765c5361ea974fccce86882322389b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vPNwqQMu2shH_af_W_a4Ng.png"/></div></div></figure><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lo"><img src="../Images/86a935f80e369f27d780e8af22bee29c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zRyxYFRvzCiz-B-RAPiAjw.png"/></div></div></figure><p id="5481" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">接下来，让我们删除<code class="fe ld le lf lg b">shot_made_flag</code>具有<code class="fe ld le lf lg b">null</code>值的行，因为它们对训练或测试都没有用。我们将为清理后的数据使用新的数据帧。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lp"><img src="../Images/fc6a99e1161153371f9c64d5a169673c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*71kfUqhDp1WPWcRVdw8zbw.png"/></div></div></figure><p id="05b6" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">在最初的 30697 行中，保留了 25697 行，删除了 5000 行。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lq"><img src="../Images/936bffe2d1648dcb60e3c459b012d41a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4p6Oqx4NTzMPTeo-cERm3A.png"/></div></div></figure><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lr"><img src="../Images/d645f68f639ac35bd4ca9d3719af79f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xIJYVHeaIJBiYIY7"/></div></div><figcaption class="jw jx gj gh gi jy jz bd b be z dk">“photography of empty wet basketball court” by <a class="ae jn" href="https://unsplash.com/@echaparro?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Edgar Chaparro</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ae02" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">我们观察到<code class="fe ld le lf lg b">minutes_remaining</code>取 0 到 11 之间的值，因此我们得出结论，这是四个 12 分钟周期结束前的剩余时间(以分钟为单位)。<code class="fe ld le lf lg b">Seconds_remaining</code>按预期取 0 到 59 的值。</p><p id="1606" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">让我们以秒为单位将两个字段合并到<code class="fe ld le lf lg b">time_remaining</code>中，直到每个周期结束，并将其添加到数据帧中(参见<code class="fe ld le lf lg b">info()</code>列表的底部，行数为 26)。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ls"><img src="../Images/73eb98ea0cd30c9e94d5796df0a3d5ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EjMdviivRT-x73Gb5Zvj4A.png"/></div></div></figure><p id="5ef8" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">现在让我们更仔细地检查分类字段的不同值。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lt"><img src="../Images/4b1649cdda4d7c8b0128443601bb3881.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2F21jYRSeajPHN7FkmaFiw.png"/></div></div></figure><p id="bb2c" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">显然<code class="fe ld le lf lg b">action_type </code>是<code class="fe ld le lf lg b">combined_shot_type</code>的一个更细粒度的分类。</p><p id="060e" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">接下来，让我们检查法院面积变量。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lu"><img src="../Images/08f287a51e8feb6584d315785b5f7bb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vE2bBMHpTANA2cumw4sttw.png"/></div></div></figure><p id="4185" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">前两个字段是区域分类，而最后一个字段是“桶”中的距离。我们将在下一节绘制这些区域的地图。</p><h1 id="a502" class="ka kb iq bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">3.数据可视化</h1><p id="0649" class="pw-post-body-paragraph io ip iq ir b is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji lc jk jl jm ij bi translated">有趣的事情开始了。可视化数据可能是最重要的部分。我会用一堆熊猫的特征。</p><p id="7e25" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">让我们首先检查一下<code class="fe ld le lf lg b">loc_x</code>、<code class="fe ld le lf lg b">loc_y</code>、<code class="fe ld le lf lg b">lon</code>和<code class="fe ld le lf lg b">lat</code>字段是否像怀疑的那样表示每个镜头的坐标，如果有原因，我们有四个参数而不是两个。对于我们其余的分析，蓝色表示成功的击球(<code class="fe ld le lf lg b">shot_made_flag==1</code>)，红色表示不成功的击球。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lv"><img src="../Images/ce3d4be6e1a545cfd271325aed129140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N3TMhA0BH9Uoj44XKlfF0w.png"/></div></div></figure><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lw"><img src="../Images/8547e6163ff67e2f2d08cd9b811251ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pPVYcXcRD5Nb6xcddcyTPA.png"/></div></div></figure><p id="b911" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">注意这两个图看起来像镜像。稍后我将回到这个问题上。</p><p id="5b00" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">接下来，我将检查与区域相关的字段是否表示与坐标相关的球场的不同区域，我将绘制它们。为此，我将使用 Pandas <code class="fe ld le lf lg b"><a class="ae jn" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.groupby.html" rel="noopener ugc nofollow" target="_blank">groupby</a></code>工具。为了清楚起见，我将一步一步地做。因此，在实际使用它们进行进一步可视化之前，让我们先深入了解分组数据帧以及如何使用它们。我们按<code class="fe ld le lf lg b">shot_zone_area</code>分组吧。然后，我们可以通过用来对项目进行分组的列和数据帧的其余部分对 groupby 数据帧进行迭代，如下所示。下面的块将向我们显示我们分组所依据的列的不同值，以及数据帧剩余部分中每个相应分区的长度。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lu"><img src="../Images/a5ec7524cecf40ae8c7d4b568e742906.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OSS0LntXipizdua2I6JZ6Q.png"/></div></div></figure><p id="4acc" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">接下来，我将定义一种方法，该方法将任何区域要素作为输入，并根据给定的要素进行分组。我将得到一个数量为等间距的点，其长度等于由给定特征的 groupby 创建的组。这将用于为每个组的颜色图选择一种颜色。最后，我们将如上迭代 groupby 数据帧，使用 zip 为每个组分配不同的颜色。注意，在 groupby 数据帧中，我们需要[1]来访问数据帧的其余部分，因为[0]是 groupby 特性。你可以从 Matplotlib <a class="ae jn" href="https://matplotlib.org/examples/color/colormaps_reference.html" rel="noopener ugc nofollow" target="_blank">调色板</a>中进行选择。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lx"><img src="../Images/0076cb611f87e324d33f92af813be72a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cpzCJZ98VXpdUBnJw74dTw.png"/></div></div></figure><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ly"><img src="../Images/a8bfdd18e746eeef8f9d90a9a530590b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*of_6h32CVR82Ukpp1NI-jA.png"/></div></div></figure><p id="f69e" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">你会经常在 Kaggle 的论坛上发现这种类型的图表，作为围绕比赛讨论的一部分。</p><p id="87ac" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">在熟悉了数据集的基础知识之后，我现在将使用 Tableau 来加倍数据集，使其尽可能透明。如前所述，您可以使用 Python 获得相同的结果。</p><p id="0abc" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">这里有一个直觉<strong class="ir lz"> : </strong>粗略地说，如果某个特征定义的“桶”中目标变量的分布有“足够”的变化(即该特征的不同值)，这可能是该特征对目标变量有预测性的一个指示。这一点大家多讨论一下吧…</p><p id="a7d5" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">首先，要有所保留:一个相对均匀的目标变量分布并不一定意味着这个特性没有预测性。在数据集的一个子集中，分布可能更加多变(我们目前正在检查整个数据集)。根据建模算法及其在此过程中创建的子集，某个特征可能被证明是具有预测性的。想一想这个问题。</p><p id="d6a6" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">相反，目标变量分布可能会随着某个特性的值而变化，但该特性不会成为一个好的预测模型。什么时候？简单地说，如果它依赖于或关联于另一个特征。在这种情况下，它可能只会增加过度拟合。作为从属特征的一个例子，面积变量是坐标的映射，正如我们前面在 Jupyter 笔记本中所展示的。严格地说,“足够的变异”的经验直觉可以被统计检验。</p><p id="faa5" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">现在，让我们检查一下<code class="fe ld le lf lg b">shot_made_flag</code>是如何针对一些特性进行分布的。你不需要检查每个特征，我只是想展示使数据集完全透明并建立良好直觉的方法。当我稍后构建和评估模型时，我将回顾性地评估这些直觉。</p><p id="76fa" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">在下一张图中，你可以看到<code class="fe ld le lf lg b">shot_zone_range</code>分布。得分的球用蓝色表示，失败的球用红色表示。显然，目标变量在由范围特征定义的子集中分布不均匀。右边的饼图(1b)显示了每个桶中总共有多少张照片。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ma"><img src="../Images/0cccd5e3ee55096c039b6834e9067677.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vYrAzH5kzOAdKQHwYNjWDg.png"/></div></div></figure><p id="2e45" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">在第二张图中，蓝线代表每个<code class="fe ld le lf lg b">shot_distnace</code>的得分球数。距离以英尺为单位，可以看到在 22-23 英尺的极限处急剧增加。三分线所在的位置。红线显示的是失败的投篮次数。3a)显示了 2 分球和 3 分球的成功率。最后，3b)是尝试的 2 分球和 3 分球总数的份额(<code class="fe ld le lf lg b">shot_type</code>)。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi mb"><img src="../Images/aca9bb8bfc6c5e94ba74ef66c9e58789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xEjrUW869YaScq2aFsm2Rg.png"/></div></div></figure><p id="5f4a" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">上述所有特征都是相互关联的，这意味着并非所有特征都符合预测模型。距离和 x/y 坐标是独立变量的不同表示。其余的是距离的映射。</p><p id="8054" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">在图表 4)中，很明显目标变量在<code class="fe ld le lf lg b">combined_shot_types</code>上的分布也不均匀。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi mc"><img src="../Images/f32e49549eaf42ee1a44b5126883a2dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zysiVY1zXgNUekFRK2Etmw.png"/></div></div></figure><p id="d6c1" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">在 5)中，人们可以观察到<code class="fe ld le lf lg b">action_type</code>是<code class="fe ld le lf lg b">combined_shot_type</code>的更精细的分类。同样存在显著的可变性，因此我预计<code class="fe ld le lf lg b">action_type</code>是预测模型的良好候选。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi md"><img src="../Images/3eb8b2f4a966a342c3030bf1bd928891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e4rqMpFa6fBHC6HU_n4_Cg.png"/></div></div></figure><p id="6ad1" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">在 6)中，我总结了游戏的每一个<code class="fe ld le lf lg b">period</code>的表现以及每一个时期的投篮次数。这里我们看到了更均匀的分布。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi me"><img src="../Images/4eec0e471e39f55da82a7cf29ad119a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*duhynKNEya_obCghVzohEA.png"/></div></div><figcaption class="jw jx gj gh gi jy jz bd b be z dk">Success/fail in different periods</figcaption></figure><p id="5a83" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">图表 7)示出了直到周期结束的计算字段<code class="fe ld le lf lg b">remaining_time</code>。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi mf"><img src="../Images/b5b5831cc582f8e35dbc375099fb8db5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cipu4W_Z007aJ9BOH6C2bw.png"/></div></div><figcaption class="jw jx gj gh gi jy jz bd b be z dk">Success/fail vs time remaining</figcaption></figure><p id="5553" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">我想你已经明白了这一点，所以我将跳过其他变量的可视化。至此，我们对数据集有了全面的了解。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi mg"><img src="../Images/8d04952f7b8df64bf621c073d986b666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j0VC_l_yDFa8R0YA"/></div></div><figcaption class="jw jx gj gh gi jy jz bd b be z dk">“aerial view of basketball court with players inside” by <a class="ae jn" href="https://unsplash.com/@jonasjacobsson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jonas Jacobsson</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="ed16" class="ka kb iq bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">4.用决策树建模</h1><p id="dae0" class="pw-post-body-paragraph io ip iq ir b is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji lc jk jl jm ij bi translated">对于实际的建模部分，我将使用决策树有两个原因:</p><ol class=""><li id="c76b" class="mh mi iq ir b is it iw ix ja mj je mk ji ml jm mm mn mo mp bi translated">决策树很容易解释。</li><li id="7ec8" class="mh mi iq ir b is mq iw mr ja ms je mt ji mu jm mm mn mo mp bi translated">它们可以用作性能良好的基线，以便与更高级的模型(如随机森林、神经网络等)进行比较。他们有额外的优势，你可以跳过标准化，规范化，特征提取等。以及其他算法所需的其他预处理步骤(我接下来会解释为什么)。</li></ol><p id="e124" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">决策树通过将样本空间分割成更纯的部分来工作。我们将用于分裂的标准是<a class="ae jn" href="https://en.wikipedia.org/wiki/Entropy_(information_theory" rel="noopener ugc nofollow" target="_blank"> <em class="jo">熵</em> </a>(尽管您也可以使用<a class="ae jn" href="https://en.wikipedia.org/wiki/Decision_tree_learning#Gini_impurity" rel="noopener ugc nofollow" target="_blank"> <em class="jo">基尼</em> </a>)。熵的定义如下:</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi mv"><img src="../Images/cb23c24f64a9ad4fe2b42b941d08882a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*13Wcw6ssi4lujO8xsZD2RA.png"/></div></div></figure><p id="1389" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">其中<em class="jo"> P(c1) </em>是段中类别<em class="jo"> c1 </em>的概率，以此类推。在一个有两个类的问题中，一个纯段(要么只有类<em class="jo"> c1 </em>实例，要么只有类<em class="jo"> c2 </em>)的熵为 0。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/e19d7c9121d8336176e60f206c51a4b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*LUF1o0OGhpjfYCNqx5q1jQ.png"/></div><figcaption class="jw jx gj gh gi jy jz bd b be z dk">Entropy with two classes: (+) and (-). Source: “Data Science for Business”</figcaption></figure><p id="5a08" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">接下来，我将在决策树的上下文中展示以下内容:</p><ul class=""><li id="b006" class="mh mi iq ir b is it iw ix ja mj je mk ji ml jm mx mn mo mp bi translated">预处理，包括数据清洗和分类特征的实体模型化。如前所述，对于其他算法，您可能需要执行额外的预处理步骤。</li><li id="812b" class="mh mi iq ir b is mq iw mr ja ms je mt ji mu jm mx mn mo mp bi translated">预测建模:我将从确定树的复杂性开始，以避免过度拟合。我将使用一种初始方法来缩小范围，然后执行<em class="jo"> k 倍交叉验证</em>来选择最佳复杂度。然后，我将通过最典型的指标来训练、测试和评估该模型，即准确度、精确度、召回率、<em class="jo">f1</em>-得分。</li><li id="ab70" class="mh mi iq ir b is mq iw mr ja ms je mt ji mu jm mx mn mo mp bi translated">可视化:我将可视化偏差/方差最佳点、树本身以及它创建的特征空间划分。</li></ul><h1 id="360f" class="ka kb iq bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">5.预处理</h1><h2 id="cd83" class="my kb iq bd kc mz na dn kg nb nc dp kk ja nd ne ko je nf ng ks ji nh ni kw nj bi translated"><strong class="ak"> 5.1 清理数据集</strong></h2><p id="0cbe" class="pw-post-body-paragraph io ip iq ir b is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji lc jk jl jm ij bi translated">首先，让我们删除所有目标变量为 NaN 的行。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nk"><img src="../Images/9a399d5bf722d13e915acbc1d4efd214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*18zGNo-e_mt39tDdJN3qog.png"/></div></div></figure><p id="b15c" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">让我们从检查时态特征开始。它们的相关性如下:</p><ul class=""><li id="9bd1" class="mh mi iq ir b is it iw ix ja mj je mk ji ml jm mx mn mo mp bi translated"><code class="fe ld le lf lg b">Game_date</code>可以根据一个季节中的时间点(如月份等)来捕捉绩效变化。</li><li id="de77" class="mh mi iq ir b is mq iw mr ja ms je mt ji mu jm mx mn mo mp bi translated">我将把<code class="fe ld le lf lg b">game_date</code>分解成月份和年份。</li><li id="2957" class="mh mi iq ir b is mq iw mr ja ms je mt ji mu jm mx mn mo mp bi translated"><code class="fe ld le lf lg b">Season</code>(以及<code class="fe ld le lf lg b">game_date</code>的年份成分)可能会捕捉到玩家表现中的年龄效应。</li><li id="5715" class="mh mi iq ir b is mq iw mr ja ms je mt ji mu jm mx mn mo mp bi translated">最后，我将使用<code class="fe ld le lf lg b">time_remaining</code>(以秒为单位)并放下<code class="fe ld le lf lg b">seconds</code>和<code class="fe ld le lf lg b">minutes_remaining</code>。</li></ul><p id="2096" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated"><code class="fe ld le lf lg b">shot_id</code>和<code class="fe ld le lf lg b">game_id</code>可能对时间序列分析有用，但现在我们可以放弃它们。永远是洛杉矶湖人队，所以我们也可以放弃。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lt"><img src="../Images/3ceb1f3bbb294e9b6503f783db588c2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vTSsM8et8rDx1LGC8hnDOQ.png"/></div></div></figure><p id="c7d6" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">部分<code class="fe ld le lf lg b">matchup</code>信息在<code class="fe ld le lf lg b">opponent</code>中。然而，我们想夺取主场/客场的财产。我们将创建一个 1 的系列，其中场区有<em class="jo"> 'vs.' </em>(显然对应于主场)，其他地方有 0(<em class="jo">' @ '</em>显然对应于客场)。然后，我将删除<code class="fe ld le lf lg b">matchup</code>并追加二进制序列:</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nl"><img src="../Images/20a80c8ce7bda724359340cb35b70183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FK5Zo9FW2JFZ2y9rupHTGw.png"/></div></div></figure><p id="0fe9" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">现在，有一个之前悬而未决的问题:为什么数据集中有<code class="fe ld le lf lg b">loc_x</code>、<code class="fe ld le lf lg b">loc_y</code>和<code class="fe ld le lf lg b">lon</code>、<code class="fe ld le lf lg b">lat</code>？让我们检查它们是否是冗余的“镜像”数据，就像我们在前面的步骤中假设的那样。一个简单的方法是分别计算变量<code class="fe ld le lf lg b">loc_x</code>和<code class="fe ld le lf lg b">lon</code>以及<code class="fe ld le lf lg b">loc_y</code>和<code class="fe ld le lf lg b">lat</code>之间的相关性。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nm"><img src="../Images/f678fd48754febc8cd6d6e6aa469c704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l9f3zBnQntysZ6Cr4ul2-w.png"/></div></div></figure><p id="b3db" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">显然，变量成对相关 100%,因此两对中的一对是冗余的。<a class="ae jn" href="https://stanford.edu/~mwaskom/software/seaborn/" rel="noopener ugc nofollow" target="_blank"> Seaborn </a>提供了特别方便的成对特征可视化。我们可以用它来直观地确认上述内容。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nn"><img src="../Images/bc5553ea60a30be2ef83639951315b1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uptcjI2aGbv4Mh8ZTYZlnw.png"/></div></div></figure><p id="6d15" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">我们将删除<code class="fe ld le lf lg b">lon</code>和<code class="fe ld le lf lg b">lat</code>，并在继续之前检查数据集的模式。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi no"><img src="../Images/7f88fba046ab6e0d2ad29d709bdc6c22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gp1878gb27mamWGkbe5i1w.png"/></div></div></figure><blockquote class="np nq nr"><p id="2325" class="io ip jo ir b is it iu iv iw ix iy iz ns jb jc jd nt jf jg jh nu jj jk jl jm ij bi translated"><strong class="ir lz">好的数据科学注:</strong>严格来说，我们应该只通过查看训练集来得出这些见解，而不是整个集合。通过查看整个集合，我们有点“作弊”。</p></blockquote><p id="39fd" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">事实上，<code class="fe ld le lf lg b">shot distance</code>和<code class="fe ld le lf lg b">angle</code>特征足以表示镜头的空间属性。角度特征由两对坐标中的一对捕捉；玩家可以从某些角度更好地射击，可以用两只手中的一只更好地射击，等等。当然，保留坐标和距离特征会导致冗余，但是基于熵的算法具有固有的特征选择属性。</p><h2 id="2e47" class="my kb iq bd kc mz na dn kg nb nc dp kk ja nd ne ko je nf ng ks ji nh ni kw nj bi translated">5.2 拆分到训练集和测试集</h2><p id="571c" class="pw-post-body-paragraph io ip iq ir b is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji lc jk jl jm ij bi translated">现在让我们分割数据集。</p><blockquote class="np nq nr"><p id="16cd" class="io ip jo ir b is it iu iv iw ix iy iz ns jb jc jd nt jf jg jh nu jj jk jl jm ij bi translated"><strong class="ir lz">良好的数据科学注意:</strong>对训练集进行的预处理也将应用于测试集，但是是分开的。</p></blockquote><p id="a70c" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">我现在将目标变量向量从特征中分离出来，并将数据集分成 80%的训练集和 20%的测试集。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nv"><img src="../Images/ce1e2449d2de2d9ee3528187ad41301c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ejk3WmYZ1ca9pzfS6-oFgg.png"/></div></div></figure><p id="7a60" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">对于树形分类器来说，不需要特征标准化。这是因为树不与任何距离概念一起工作，而是与类纯度一起工作。此外，我们选择了树分类器作为我们的第一个模型，因为它们的可解释性和特征标准化会损害模型的可解释性。</p><p id="8cb9" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">出于创建角度特征的目的，我们将出现<code class="fe ld le lf lg b">loc_x</code>和<code class="fe ld le lf lg b">loc_y</code>，以避免可能导致被零除的零值。通过标准化，数据围绕一个标准差距离中的零均值重新分布。</p><blockquote class="np nq nr"><p id="8e31" class="io ip jo ir b is it iu iv iw ix iy iz ns jb jc jd nt jf jg jh nu jj jk jl jm ij bi translated"><strong class="ir lz">好的数据科学注:</strong>同样，这个处理必须在训练和测试中分别进行。</p><p id="9025" class="io ip jo ir b is it iu iv iw ix iy iz ns jb jc jd nt jf jg jh nu jj jk jl jm ij bi translated"><strong class="ir lz">技术说明:</strong> Scikit 的<code class="fe ld le lf lg b">StandardScaler</code>提供了持续转变培训和测试的设施。</p></blockquote><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nw"><img src="../Images/5071aff075102156841f8880a3e1d01c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-7BbmMI8qs5GKc8PDrTTkg.png"/></div></div></figure><p id="c2e6" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">接下来，我们通过使用相同的<code class="fe ld le lf lg b">StandardScaler</code>对象，对测试集应用相同的转换。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nx"><img src="../Images/702d6992a9d6f7e92e3da681e3687664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tDUfMenz8ggNRtMLEncHQw.png"/></div></div></figure><p id="764c" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">我们现在可以从两个子集中删除<code class="fe ld le lf lg b">loc_x</code>、<code class="fe ld le lf lg b">loc_y</code>。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ny"><img src="../Images/5cb635857c21b25f2764d00cd5ddab3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QNHuH9TYBh0Wih8V7Jlpsg.png"/></div></div></figure><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nz"><img src="../Images/e5f107c281c8aa3198e860b6378fcef3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8ci0XiGgyKiT4jO9"/></div></div><figcaption class="jw jx gj gh gi jy jz bd b be z dk">“building with basketball court” by <a class="ae jn" href="https://unsplash.com/@bormot?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alexandr Bormotin</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ac88" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">为了使用 Scikit 的分类器，我们需要转换分类字段。这可以通过熊猫的<code class="fe ld le lf lg b">get_dummies()</code>来实现。</p><blockquote class="np nq nr"><p id="6cf8" class="io ip jo ir b is it iu iv iw ix iy iz ns jb jc jd nt jf jg jh nu jj jk jl jm ij bi translated"><strong class="ir lz">技术说明:</strong>也可以使用 Scikit 的<code class="fe ld le lf lg b">OneHotEncoder</code>或<code class="fe ld le lf lg b">LabelBinarizer</code>。</p></blockquote><p id="8413" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">让我们看看熊猫方法是如何工作的。我将首先获取所有分类列的列表(它们属于 object 类型)。这可以用<code class="fe ld le lf lg b">select_dtypes()</code>来完成。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi oa"><img src="../Images/3e9873797ad0b33b22ec7e2b0ed87223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TMo6r6vWSAlpNc91RItssw.png"/></div></div></figure><p id="c156" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">这里有趣的是，在一般情况下，如前所述，我们在预处理时根本不应该查看测试集。因此:</p><ol class=""><li id="bb90" class="mh mi iq ir b is it iw ix ja mj je mk ji ml jm mm mn mo mp bi translated">应该基于训练集对分类数据进行编码。此时，训练集的模式就完成了。</li><li id="df7a" class="mh mi iq ir b is mq iw mr ja ms je mt ji mu jm mm mn mo mp bi translated">然后单独地，就像我们以前对此一无所知一样，我们应该对测试集中的分类数据进行编码。</li><li id="1f61" class="mh mi iq ir b is mq iw mr ja ms je mt ji mu jm mm mn mo mp bi translated">使用 Pandas 的<code class="fe ld le lf lg b">setdiff1d()</code>,我们可以确定与训练集相比，测试集中缺少哪些虚拟化列，并在所有行中添加 0 值。</li><li id="d68a" class="mh mi iq ir b is mq iw mr ja ms je mt ji mu jm mm mn mo mp bi translated">最后，我将按照相同的顺序从训练集中选择测试集中的列。</li></ol><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nx"><img src="../Images/97afbea89faa01c6bbcd12bf3491d8d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kDIXr58xEUlgf6u31EAlQg.png"/></div></div></figure><h1 id="da91" class="ka kb iq bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">6.决策树</h1><h2 id="0df5" class="my kb iq bd kc mz na dn kg nb nc dp kk ja nd ne ko je nf ng ks ji nh ni kw nj bi translated">6.1 高偏差与高方差:最佳点</h2><p id="148b" class="pw-post-body-paragraph io ip iq ir b is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji lc jk jl jm ij bi translated">我现在将检查什么是我们模型的合理复杂度。一个复杂的模型过于适合，而一个简单的模型没有预测性，那么这里的最佳点是什么呢？我将训练各种复杂的树分类器，并在测试和训练集上可视化它们的性能。</p><p id="da53" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">为此，我将使用<code class="fe ld le lf lg b">DecisionTreeClassifier</code>的<code class="fe ld le lf lg b">min_samples_leaf</code>参数，它控制每片叶子上的最小样本数。这个数字越小，<em class="jo">对应的型号越复杂。对于决策树，我将使用平衡采样来防止主导类的偏差。</em></p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ob"><img src="../Images/8a46a060b0158a516ad17d50b29b4706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XL6PKx6zt9PGgUirI8Ubjg.png"/></div></div></figure><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi oc"><img src="../Images/e854d2bf4c2fe219e325880684bc804a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dvGzcug0Jph8kYS-wlNhCg.png"/></div></div></figure><blockquote class="np nq nr"><p id="ff79" class="io ip jo ir b is it iu iv iw ix iy iz ns jb jc jd nt jf jg jh nu jj jk jl jm ij bi translated"><strong class="ir lz">良好的数据科学注意:</strong>在现实中，你永远不应该评估一个模型在训练数据上的表现。在这里，它不是“真实分析”的一部分，它只是为了演示过拟合的影响，以及精度如何随模型的复杂性而变化。见下。</p></blockquote><ul class=""><li id="fdc6" class="mh mi iq ir b is it iw ix ja mj je mk ji ml jm mx mn mo mp bi translated">橙色线代表训练集的性能，蓝色线代表测试集的性能。请注意，对于每片叶子中的少量样本(高复杂性)，模型在训练集上表现非常好，而在测试集上表现非常差(粉红色区域)。这表明过度拟合。</li><li id="4c7e" class="mh mi iq ir b is mq iw mr ja ms je mt ji mu jm mx mn mo mp bi translated">在某一点上，两条线会聚，最佳点似乎在每片叶子中 500 到 1500 个样本的区域内(绿色区域)。</li><li id="f16e" class="mh mi iq ir b is mq iw mr ja ms je mt ji mu jm mx mn mo mp bi translated">然后，随着模型变得过于简单(高偏差)，性能会降低。</li></ul><p id="6186" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">这是预期的行为。这个粗略的过程主要是为了教学目的，但它也有助于缩小一个合理复杂的领域，在其中我们可以执行交叉验证，这是一个更昂贵和准确的过程，以便选择一个最佳值。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi mg"><img src="../Images/0775af426cdc2a098a8da3c9ad001c44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OsQgnt-eB02iOGsb"/></div></div><figcaption class="jw jx gj gh gi jy jz bd b be z dk">“white and black basketball hoop” by <a class="ae jn" href="https://unsplash.com/@mbrunacr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Miguel Bruna</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="6862" class="my kb iq bd kc mz na dn kg nb nc dp kk ja nd ne ko je nf ng ks ji nh ni kw nj bi translated">6.2 K 倍交叉验证</h2><p id="3ce8" class="pw-post-body-paragraph io ip iq ir b is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji lc jk jl jm ij bi translated">我将在 250 到 5000 个最小叶样本值的范围内使用 10 重交叉验证，以便为我们的模型选择一个精确的值。我会得到每次交叉验证运行的平均准确度和方差。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi gj"><img src="../Images/312a8cb26fc3e97b2e1db3cff7853e25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rVqYYMMO8iKknmqwjgRLAw.png"/></div></div></figure><p id="5fdb" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">我将使用<em class="jo"> f1 </em>分数来评估这些模型。</p><blockquote class="np nq nr"><p id="368a" class="io ip jo ir b is it iu iv iw ix iy iz ns jb jc jd nt jf jg jh nu jj jk jl jm ij bi translated"><strong class="ir lz">良好的数据科学注意:</strong> f1 作为模型评估指标优先于准确性。准确度不能提供假阳性率和假阴性率的信息，对于特定应用来说，假阳性率和假阴性率可能不相等，并且在非常不平衡的类别的情况下，准确度可能会产生误导(这里不是这种情况)。</p><p id="15d3" class="io ip jo ir b is it iu iv iw ix iy iz ns jb jc jd nt jf jg jh nu jj jk jl jm ij bi translated"><strong class="ir lz">技术说明:</strong>尽管如此，如果您想使用精度，请在<code class="fe ld le lf lg b">cross_val_score</code>的<code class="fe ld le lf lg b">scoring</code>参数中声明。Scikit learn 为<a class="ae jn" href="http://scikit-learn.org/stable/modules/model_evaluation.html#common-cases-predefined-values" rel="noopener ugc nofollow" target="_blank">提供了一系列替代指标</a>。</p></blockquote><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi od"><img src="../Images/8b4e990b2072b2bdef9f4e69c92dae88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o2YbeOZgiVo74NEBgFk8XA.png"/></div></div></figure><h2 id="52d6" class="my kb iq bd kc mz na dn kg nb nc dp kk ja nd ne ko je nf ng ks ji nh ni kw nj bi translated">6.3 建模和可视化</h2><p id="d294" class="pw-post-body-paragraph io ip iq ir b is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji lc jk jl jm ij bi translated">最少 1750 个样本最大限度地提高了精确度和<em class="jo"> f1 </em>。我现在将用这个值训练一个决策树。同样，采样应该是平衡的，标准将是熵。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ny"><img src="../Images/b40690de1b06c4411e340856e68e2cbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4X5IWTOZB-N6if3q200a2A.png"/></div></div></figure><p id="10e2" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">我现在将可视化我们的决策树模型。在下图中，蓝色表示得分镜头预测，橙色表示未命中镜头预测。较低的熵(对应于较高的纯度)用较暗的颜色表示。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi oe"><img src="../Images/c530d0b56fe4a5f89442aa8cf0023222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PRwqBv5JntZrzTwPVqZ6hQ.png"/></div></div></figure><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi of"><img src="../Images/770e320746b2d431b393a7bd0c6309e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*42dlFmaNSvCdet0eCAkfoQ.png"/></div></div></figure><p id="ad72" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">注意树的根在<code class="fe ld le lf lg b">action type</code> ( <code class="fe ld le lf lg b">jump shot</code>)。如果您向上滚动到表 4 和表 5)，您将会注意到，我们期望将此功能纳入预测模型，因为目标变量会因其而有很大变化。</p><p id="c59e" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">另外，请注意<code class="fe ld le lf lg b">jump_shot</code>是动作的主导类型。这两者结合起来意味着它创造了纯度最大化的部门，因此它自然是模型获得的第一个预测特征。单一特征树(又名决策树<em class="jo">树桩</em>)通常用作基线分类器，<code class="fe ld le lf lg b">action_type_jump shot</code>将是树桩的特征。</p><p id="34df" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">出于类似的原因，<code class="fe ld le lf lg b">shot distance</code>和<code class="fe ld le lf lg b">season</code>(此处为<code class="fe ld le lf lg b">year</code>)也被认为会在模型中排名靠前。另一方面，<code class="fe ld le lf lg b">time remaining</code>不是一个明显的预测特征。</p><p id="3b19" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">看到树如何划分特征空间是很有趣的。典型的可视化是成对特征比较。在这种情况下，我们有许多分类和二元特征，这无助于可视化，所以我只选择两个重要的数字特征，<code class="fe ld le lf lg b">time_remaining</code>和<code class="fe ld le lf lg b">shot_distance</code>，并比较模型复杂性如何影响树创建的区域。</p><p id="0a6b" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">出于可视化目的:</p><ul class=""><li id="d529" class="mh mi iq ir b is it iw ix ja mj je mk ji ml jm mx mn mo mp bi translated">我将像以前一样为各种模型复杂性训练一个树分类器(更具体地说，每片叶子至少有 250-1750 个样本)，只是这次只使用这两个特征。</li><li id="1240" class="mh mi iq ir b is mq iw mr ja ms je mt ji mu jm mx mn mo mp bi translated">我将用等高线绘制预测区域:在蓝色区域，树预测射击将失败，而在黄色区域，射击将进入。</li><li id="6769" class="mh mi iq ir b is mq iw mr ja ms je mt ji mu jm mx mn mo mp bi translated">我还会在上面绘制测试数据集:红点是实际错过的镜头，黑点是进去的。</li><li id="f410" class="mh mi iq ir b is mq iw mr ja ms je mt ji mu jm mx mn mo mp bi translated">支线描绘了逐渐简化的模型。注意边界是如何逐渐变得简单的。对于每片叶子的小的最小数量，树过度拟合。</li></ul><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nx"><img src="../Images/573d0e2ec8208cbb24a6832dc4a99b5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MXo1_SBgHYpo7HXbUtItBQ.png"/></div></div></figure><figure class="jp jq jr js gt jt gh gi paragraph-image"><div class="gh gi og"><img src="../Images/a8d8533fd51432b6fffed5046e79e2c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*dLQL9g5WT0BTmCmLoXVP-g.png"/></div></figure><h2 id="ceb9" class="my kb iq bd kc mz na dn kg nb nc dp kk ja nd ne ko je nf ng ks ji nh ni kw nj bi translated">6.4 模型评估</h2><p id="cbd6" class="pw-post-body-paragraph io ip iq ir b is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji lc jk jl jm ij bi translated">让我们计算一下树的精确度:</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi oa"><img src="../Images/3dc0ff44340b2957e5a0a6e60ae080d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m_4ym5psb50_CI9jPVFDcg.png"/></div></div></figure><p id="7e8f" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">这个准确度得分是否超过基线多数分类器(一个总是预测主导类的“分类器”)，如果是，超过多少？</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nw"><img src="../Images/27ef9de7a0729171ee0db9f4572c77e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jl5TY-ArDmnOtqDGgna88A.png"/></div></div></figure><p id="49b3" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">因此，决策树的预测精度约为 0.66，比精度为 0.55 的基线多数分类器有显著提高。让我们检查混淆矩阵以及精确度、召回率和<em class="jo"> f1 </em>分数。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nx"><img src="../Images/326ece9c269a21ccaa49d0c328977a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BY9gAPnOO-i1m09_Qvse4Q.png"/></div></div></figure><p id="b21f" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">y 轴是真实的类，x 轴是预测的类，并且类按排名顺序出现(所以 0，1)。据此，我们得到大量的假阴性(1006)。为了透明，我们可以绘制混淆矩阵。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ny"><img src="../Images/01a3a19792def68179a37fd04fd44886.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z_gBMDujh7MY1ye7LN-7AQ.png"/></div></div></figure><p id="0bee" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">现在让我们检查一下精确度、召回率和<em class="jo"> f1 </em>分数:</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi oh"><img src="../Images/1589de737ce5c8d8f0c4540728a914dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z9ffORgDs3XB1O8irWC0XA.png"/></div></div></figure><h1 id="8a50" class="ka kb iq bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">7.谢谢！</h1><p id="0976" class="pw-post-body-paragraph io ip iq ir b is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji lc jk jl jm ij bi translated">如果你一路来到这里，感谢你的阅读，我希望你觉得它既有用又有趣。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi oi"><img src="../Images/221dd2818751f7c31bbf346e8649fbb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kTUwszGEA2PUhZXh"/></div></div><figcaption class="jw jx gj gh gi jy jz bd b be z dk">“basketball on basketball ring” by <a class="ae jn" href="https://unsplash.com/@patrickian4?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Patrick Fore</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div></div>    
</body>
</html>