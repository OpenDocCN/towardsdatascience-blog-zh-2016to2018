<html>
<head>
<title>Building Spotify’s “Discover Weekly” with Spark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Spark 打造 Spotify 的“发现周刊”</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-spotifys-discover-weekly-with-spark-4370d5d0df2f?source=collection_archive---------1-----------------------#2017-05-24">https://towardsdatascience.com/building-spotifys-discover-weekly-with-spark-4370d5d0df2f?source=collection_archive---------1-----------------------#2017-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/69809c4e146149523ab30a93cbe065d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zgVG_Hpq5ACRXDrD2nM2TQ.png"/></div></div></figure><div class=""/><div class=""><h2 id="dac4" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">基于协同过滤算法的音频推荐系统的 MLlib &amp; PySpark 实现</h2></div><p id="5ca4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">今天是我在<a class="ae lp" href="https://en.wikipedia.org/wiki/NBCUniversal" rel="noopener ugc nofollow" target="_blank"> NBC Universal </a>实习的第三天，我受到鼓舞要实现一个新的目标:在今年夏天离开<a class="ae lp" href="https://en.wikipedia.org/wiki/30_Rockefeller_Plaza" rel="noopener ugc nofollow" target="_blank">30 Rock</a>&amp;<a class="ae lp" href="https://en.wikipedia.org/wiki/1221_Avenue_of_the_Americas" rel="noopener ugc nofollow" target="_blank">1221 Campus</a>(我将在那里工作大部分时间)之前掌握<a class="ae lp" href="https://spark.apache.org/" rel="noopener ugc nofollow" target="_blank"> Spark </a>。</p><p id="19a8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">作为领先的媒体和娱乐行业，我们公司拥有数百 Pb 来自全国各地和通过国际有线电视的电视广播数据。虽然这听起来令人惊讶和不知所措，但毫无疑问，现在越来越多的公司依靠推荐系统的力量来满足各种个人品味和需求，从而提高客户的满意度和忠诚度。</p><p id="3a5f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在娱乐行业，Spotify 等音乐科技巨头将推荐引擎作为其产品的重要组成部分。涉及用户兴趣的模式检测和分析在提供个性化推荐方面发挥了关键作用。这是因为给用户体验添加另一个维度有助于推荐系统在识别我们不知道自己会喜欢的曲目方面做得非常出色。</p><h1 id="7eaa" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">用什么算法？</h1><p id="a535" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">让我从我们可以用来构建音频推荐系统的两种主要方法开始。第一个是<strong class="kv jf"> <em class="mn">内容过滤</em> </strong>，利用产品和用户的已知信息进行推荐。使用这种方法，我们根据<em class="mn">产品</em>(例如电影信息、价格信息和产品描述)和<em class="mn">用户</em>(例如人口统计和问卷信息)创建档案。</p><p id="de0b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">实施内容过滤的一个广为人知的例子是在线电台 Pandora 的音乐基因组计划。在这里，一个专家根据上百个特征给一首歌打分。用户还提供关于他/她的音乐偏好的信息。基于这两个源的配对提出建议。</p><figure class="mp mq mr ms gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mo"><img src="../Images/9ed1b09ccd09ecb3bdd3eed68090fc0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qkv3n2Wt9xBmvel_Ee9QGA.png"/></div></div></figure><p id="573b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">潘多拉使用内容过滤，Spotify 使用<strong class="kv jf"> <em class="mn">协同过滤</em> </strong>用于他们的<a class="ae lp" href="https://www.spotify.com/us/discoverweekly/" rel="noopener ugc nofollow" target="_blank">发现周刊</a>推荐系统。后一种技术使用先前用户的输入/行为来做出未来的推荐。我们忽略任何先验的用户或对象信息。我们使用相似用户的评分来预测评分。</p><p id="1670" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">进一步理解 Spotify 技术的一种方式是通过一种基于<em class="mn">邻居的</em>方法，在这种方法中，你(1)首先根据我们的重叠评分的一致程度来定义你和其他用户之间的相似性评分，然后(2)让其他人根据这些评分来投票决定你喜欢什么。</p><blockquote class="mt mu mv"><p id="5ddc" class="kt ku mn kv b kw kx kf ky kz la ki lb mw ld le lf mx lh li lj my ll lm ln lo im bi translated">与内容过滤相比，协作过滤的一个主要吸引力在于其不受领域限制的方法，这意味着它不需要知道什么被评级，只需要知道谁对什么进行了评级，以及评级是什么。</p></blockquote><p id="e170" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">注意两种<em class="mn"> </em>方法并不互相排斥。<em class="mn">内容信息</em>也可以内置到<em class="mn">协同过滤</em>系统中，提高性能。现在我们已经了解了算法是如何工作的，让我们来了解一下我们将用来构建推荐系统的技术— <em class="mn"> Spark。</em></p><h1 id="edb7" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">为什么是火花？</h1><p id="7bf8" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">Apache Spark 是一个快速通用的集群计算系统。随着行业开发出更具创意、基于客户的产品和服务，对机器学习算法的需求变得更加重要，以帮助开发个性化、推荐和预测性见解。</p><p id="6feb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">像 R 和 Python 这样的工具长期以来被用来执行各种机器学习活动。然而，随着信息的大量增长，计算效率对于帮助解决高时间和空间复杂性变得非常关键。</p><p id="4609" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">此外，Spark 为数据工程师和数据科学家提供了一个强大的统一引擎，它不仅速度快(<a class="ae lp" href="https://databricks.com/blog/2014/11/05/spark-officially-sets-a-new-record-in-large-scale-sorting.html" rel="noopener ugc nofollow" target="_blank">比 Hadoop 快 100 倍，用于大规模数据处理</a>)且易于使用，而且简单、高度可扩展，并可与其他工具有效集成，如 R、SQL、Python、Scala 和 Java。</p><figure class="mp mq mr ms gt iv gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/a71eb9dea045bf96dcf2ee5486248a9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*eZwX1ueo8k50ycK2r9J_QA.png"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">Source: <em class="ne">Infoworld Analytics</em></figcaption></figure><p id="b0b8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我最喜欢 Spark 的一点是，它能够帮助我们数据科学家解决高度复杂的机器学习问题，涉及图形计算、流和以互动方式在更大规模上进行实时互动查询处理。</p><h1 id="914e" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">使用 PySpark 的逐步实现</h1><p id="7552" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">我们现在将使用<em class="mn"> AudioScribbler 数据集</em>实现协同过滤算法来构建音频推荐系统(在这里下载压缩档案<a class="ae lp" href="http://www-etud.iro.umontreal.ca/~bergstrj/audioscrobbler_data.html" rel="noopener ugc nofollow" target="_blank">)。</a></p><h2 id="f562" class="nf lr je bd ls ng nh dn lw ni nj dp ma lc nk nl mc lg nm nn me lk no np mg nq bi translated">导入库和数据集</h2><p id="8aab" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">一旦数据集中有了三个文件，就可以启动<code class="fe nr ns nt nu b">spark-shell</code>。构建模型的第一步是理解您的数据，并将其解析成对 Spark 中的分析有用的形式。让我们从导入库和初始化您的<code class="fe nr ns nt nu b">SparkContext</code>开始用 PySpark 编码。</p><pre class="mp mq mr ms gt nv nu nw nx aw ny bi"><span id="060b" class="nf lr je nu b gy nz oa l ob oc">import findspark<br/>import pyspark<br/>from pyspark import SparkContext<br/>from pyspark import SparkConf<br/>from pyspark.mllib import recommendation<br/>from pyspark.mllib.recommendation import *</span><span id="7146" class="nf lr je nu b gy od oa l ob oc"><strong class="nu jf">'''initialize spark in VM'''</strong></span><span id="b5e5" class="nf lr je nu b gy od oa l ob oc">findspark.init('/usr/local/bin/spark-1.3.1-bin-hadoop2.6/')<br/>try:<br/>    sc=SparkContext()<br/>except:<br/>    None</span></pre><p id="b0df" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">接下来，将每个文件存储到一个变量中。<em class="mn"> user_artist_data.txt </em>表示一个播放列表数据集，其中文件的每一行都包含一个用户 ID、一个艺术家 ID 和一个播放次数，用空格分隔。<em class="mn"> artist_data.txt </em>包含与艺术家姓名相关联的不透明数字 id。<em class="mn"> artist_alias.txt </em>将可能拼写错误或不标准的艺术家 ID 映射到艺术家规范名称的 ID。它每行包含两个 id，用制表符分隔。</p><pre class="mp mq mr ms gt nv nu nw nx aw ny bi"><span id="d366" class="nf lr je nu b gy nz oa l ob oc"><strong class="nu jf">'''define variables'''</strong></span><span id="e002" class="nf lr je nu b gy od oa l ob oc">rawUserArtistData = sc.textFile("vagrant/user_artist_data.txt")<br/>rawArtistData = sc.textFile("vagrant/artist_data.txt")<br/>rawArtistAlias = sc.textFile("vagrant/artist_alias.txt")</span></pre><h2 id="cb58" class="nf lr je bd ls ng nh dn lw ni nj dp ma lc nk nl mc lg nm nn me lk no np mg nq bi translated">预处理数据</h2><p id="033e" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">我们希望获得原始艺术家数据的列表，每个 ID 和名称都存储在元组中。让我们使用<em class="mn"> artist_data.txt </em>来创建这个列表。</p><pre class="mp mq mr ms gt nv nu nw nx aw ny bi"><span id="4664" class="nf lr je nu b gy nz oa l ob oc">def pairsplit(singlePair):<br/>    splitPair = singlePair.rsplit('\t')<br/>    if len(splitPair) != 2:<br/>        return []<br/>    else:<br/>        try:<br/>            return [(int(splitPair[0]), splitPair[1])]<br/>        except:<br/>            return []<br/>artistByID = dict(rawArtistData.flatMap(lambda x: pairsplit(x)).collect())</span></pre><p id="1e4e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们还使用<em class="mn"> artist_alias.txt </em>将“坏的”艺术家 id 映射到“好的”艺术家 id，而不仅仅是将其用作艺术家 id 的原始数据对。我们使用下面的代码将坏的 id 转换成好的 id。例如，第一个条目将 ID 6803336 映射到 1000010，这意味着它将“Aerosmith(不插电)”映射到“Aerosmith”。</p><pre class="mp mq mr ms gt nv nu nw nx aw ny bi"><span id="25ad" class="nf lr je nu b gy nz oa l ob oc">def aliaslookup(alias):<br/>    splitPair = alias.rsplit('\t')<br/>    if len(splitPair) != 2:<br/>        return []<br/>    else:<br/>        try:<br/>            return [(int(splitPair[0]), int(splitPair[1]))]<br/>        except:<br/>            return []<br/>artistAlias = rawArtistAlias.flatMap(lambda x: aliaslookup(x)).collectAsMap()</span></pre><h2 id="1b6d" class="nf lr je bd ls ng nh dn lw ni nj dp ma lc nk nl mc lg nm nn me lk no np mg nq bi translated">建立一个模型</h2><p id="b2e6" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">然后，我们创建一个查找函数，将数据转换成评级对象。请注意，任何潜在的<em class="mn"> MLlib </em>模型都需要产品作为客观的衡量标准。在我们的模型中，产品是艺术家。因此，我们将使用<em class="mn"> user_artist_data.txt </em>来实现我们的火车数据。</p><pre class="mp mq mr ms gt nv nu nw nx aw ny bi"><span id="5824" class="nf lr je nu b gy nz oa l ob oc">def ratinglookup(x):<br/>    userID, artistID, count = map(lambda line: int(line), x.split())<br/>    finalArtistID = bArtistAlias.value.get(artistID)<br/>    if finalArtistID is None:<br/>        finalArtistID = artistID<br/>    return Rating(userID, finalArtistID, count)</span><span id="4c8a" class="nf lr je nu b gy od oa l ob oc">trainData = rawUserArtistData.map(lambda x: ratinglookup(x))<br/>trainData.cache()</span></pre><p id="c329" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们还为<code class="fe nr ns nt nu b">artistAlias</code>创建了一个名为<code class="fe nr ns nt nu b">bArtistAlias</code>的广播变量。这使得 Spark 只为集群中的每个执行器发送并在内存中保存一个副本。当有数千个任务，并且许多任务在每个执行器上并行执行时，这可以节省大量的网络流量和内存。</p><pre class="mp mq mr ms gt nv nu nw nx aw ny bi"><span id="247b" class="nf lr je nu b gy nz oa l ob oc">bArtistAlias = sc.broadcast(artistAlias)</span></pre><p id="5946" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">最后，我们使用<em class="mn">协同过滤</em>算法建立我们的模型，如下所示。该操作可能需要几分钟或更长时间，具体取决于您的群集。我花了大约 15 分钟来运行这个模型。</p><pre class="mp mq mr ms gt nv nu nw nx aw ny bi"><span id="6f1a" class="nf lr je nu b gy nz oa l ob oc"><strong class="nu jf">'''build model'''</strong></span><span id="fa55" class="nf lr je nu b gy od oa l ob oc">model = ALS.trainImplicit(trainData, 10, 5)</span></pre><p id="181f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们应该首先通过检查一个用户、他或她的戏剧以及对该用户的推荐，来看看艺术家的推荐是否有任何直观的意义。以用户<code class="fe nr ns nt nu b">2093760</code>为例。提取这个用户听过的艺术家的 id 并打印他们的名字。这意味着在输入中搜索该用户的艺术家 id，然后根据这些 id 过滤艺术家集，以便您可以按顺序收集和打印姓名:</p><pre class="mp mq mr ms gt nv nu nw nx aw ny bi"><span id="87f4" class="nf lr je nu b gy nz oa l ob oc"><strong class="nu jf">'''test artist'''</strong></span><span id="ce69" class="nf lr je nu b gy od oa l ob oc">spotcheckingID = 2093760<br/>bArtistByID = sc.broadcast(artistByID)</span><span id="75cf" class="nf lr je nu b gy od oa l ob oc">rawArtistsForUser = (trainData<br/>                  .filter(lambda x: x.user == spotcheckingID)<br/>                  .map(lambda x: bArtistByID.value.get(x.product))<br/>                  .collect())<br/>print(rawArtistsForUser)</span></pre><h2 id="9100" class="nf lr je bd ls ng nh dn lw ni nj dp ma lc nk nl mc lg nm nn me lk no np mg nq bi translated">获得您的推荐</h2><p id="39b9" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">我想根据我的数据模型选出前 10 首歌曲:</p><pre class="mp mq mr ms gt nv nu nw nx aw ny bi"><span id="345a" class="nf lr je nu b gy nz oa l ob oc"><strong class="nu jf">'''output recommendations'''</strong></span><span id="fd51" class="nf lr je nu b gy od oa l ob oc">recommendations = map(lambda x: artistByID.get(x.product), model.call("recommendProducts", spotcheckingID, <strong class="nu jf">10</strong>))<br/>print(recommendations)</span></pre><p id="68d7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在我的<em class="mn"> Spark VM </em>集群上运行这个程序，我得到了以下输出:</p><ul class=""><li id="f9cc" class="oe of je kv b kw kx kz la lc og lg oh lk oi lo oj ok ol om bi translated"><em class="mn"> Jay Z、50 Cent、Snoop Dogg、2Pac、Nas、Kanye West、Outkast、Eminem、德瑞医生和卢达克里斯。</em></li></ul><figure class="mp mq mr ms gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/8cf45757c74f93516f4537e37208858c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s2Ymy8QY1qziAH-bCS8EKw.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">A screenshot of my model output. Note that your top 10 listed songs can be in random order.</figcaption></figure><p id="203e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">是的，这些艺术家看起来像说唱歌手的混合体！请记住，这组艺术家在 2005 年非常受欢迎，这是这个数据集被提取的年份。</p><p id="29f0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">可能的下一步？</strong>我们可以使用另一组可用的歌曲数据提取一组推荐的歌曲，并根据我们的顶级艺术家对它们进行查询。</p><p id="ed89" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">希望你喜欢和快乐的黑客！</p><h1 id="e53d" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">编码参考</h1><p id="7fc9" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">你可以在这里找到我的原始代码:<a class="ae lp" href="https://github.com/moorissa/audiorecommender" rel="noopener ugc nofollow" target="_blank">https://github.com/moorissa/audiorecommender</a></p><figure class="mp mq mr ms gt iv"><div class="bz fp l di"><div class="oo op l"/></div></figure></div><div class="ab cl oq or hx os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="im in io ip iq"><p id="634b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">Moorissa 是一名研究生，目前在哥伦比亚大学学习机器学习，希望有一天她可以利用这些技能让世界变得更好，一次一天。</p></div></div>    
</body>
</html>