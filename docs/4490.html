<html>
<head>
<title>Preprocessing Large Datasets: Online Retail Data with 500k+ Instances</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预处理大型数据集:50 万多个实例的在线零售数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/preprocessing-large-datasets-online-retail-data-with-500k-instances-3f24141f511?source=collection_archive---------12-----------------------#2018-08-19">https://towardsdatascience.com/preprocessing-large-datasets-online-retail-data-with-500k-instances-3f24141f511?source=collection_archive---------12-----------------------#2018-08-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="8622" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">几个月前，我有机会参与一个拥有超过 500，00 0 行的庞大数据集的项目！老实说，这是我第一次不得不处理数量惊人的数据，但我认为玩它并探索新的数据挖掘技术会很有趣。在这篇文章中，我将解释我是如何处理这个问题的，并最终得到了一个干净的、便于使用的数据集。还提供了 R 代码。</p><p id="4d5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正在讨论的数据集在<em class="kp"> UCI 机器学习库</em>的<a class="ae ko" href="http://archive.ics.uci.edu/ml/datasets/online+retail" rel="noopener ugc nofollow" target="_blank">这里</a>可用。这是一个交易数据集，包含 2010 年 1 月 12 日和 2011 年 9 月 12 日之间英国注册的无店铺在线零售的所有交易。该公司主要销售独特的全场合礼品；这家公司的许多客户都是批发商。属性信息可以在提供的链接中找到。我的最终目标是对这些数据进行购物篮分析，并找出关联规则。然而，第一步是清理数据。</p><p id="86d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将数据集保存为一个. csv 文件，并简要查看了所有行。我意识到，由于维度问题，我可能无法注意到最重要的模式和细节。然而，我注意到一些单元格是空的，那些是丢失的值。为了方便起见，它们被重新编码为 NA。我还发现了丢失的值在哪里，以及有多少。</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="0785" class="kz la it kv b gy lb lc l ld le">dataset = read.csv("OnlineRetail.csv", na.strings = c("","NA"))</span><span id="0cbf" class="kz la it kv b gy lf lc l ld le">attach(dataset)</span><span id="4043" class="kz la it kv b gy lf lc l ld le">#checking if there any missing values, where are they missing, and how many of them are missing</span><span id="9e39" class="kz la it kv b gy lf lc l ld le">any(is.na(dataset))</span><span id="d9b5" class="kz la it kv b gy lf lc l ld le">[1] <strong class="kv iu">TRUE</strong></span><span id="6284" class="kz la it kv b gy lf lc l ld le">apply(dataset, 2, function(x) any(is.na(x)))</span><span id="6e93" class="kz la it kv b gy lf lc l ld le">InvoiceNo StockCode Description Quantity InvoiceDate UnitPrice CustomerID Country</span><span id="6f61" class="kz la it kv b gy lf lc l ld le"><strong class="kv iu">FALSE</strong> <strong class="kv iu">FALSE</strong> <strong class="kv iu">TRUE</strong> <strong class="kv iu">FALSE</strong> <strong class="kv iu">FALSE</strong> <strong class="kv iu">FALSE</strong> <strong class="kv iu">TRUE</strong> <strong class="kv iu">FALSE</strong></span><span id="3796" class="kz la it kv b gy lf lc l ld le">sum(is.na(CustomerID))</span><span id="f68a" class="kz la it kv b gy lf lc l ld le">[1] 135080</span><span id="81d6" class="kz la it kv b gy lf lc l ld le">sum(is.na(Description))</span><span id="1fd7" class="kz la it kv b gy lf lc l ld le">[1] 1454</span></pre><p id="9612" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="kp"> InvoiceNo </em>为整数类型；但是，最好是字符类型，这样我们就可以应用字符串函数。在<em class="kp"> InvoiceNo </em>和<em class="kp"> Description </em>中的<em class="kp"> trim </em>功能都删除了前导和尾随空格。</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="8c7e" class="kz la it kv b gy lb lc l ld le">dataset$InvoiceNo = as.character(InvoiceNo)<br/>trim = function (x) gsub("^\\s+|\\s+$", "", x)<br/>dataset$InvoiceNo = trim(InvoiceNo)<br/>dataset$Description = trim(as.character(Description))</span></pre><p id="0443" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以 C 开头的发票号码实际上是取消的，所以我们可能想去掉它们。我引入了一个名为<em class="kp"> is_C </em>的函数，它检查一个字符串是否以 C 开头。我们对原始数据进行子集化，得到<em class="kp"> dataset2 </em>(没有取消)和<em class="kp"> dataset3 </em>(没有空的项目描述)。我们可以看到原始数据集有 541 909 个观察值，现在我们在<em class="kp">数据集 3 </em>中有 531 167 个观察值。我们刚刚剔除了将近 10 000 个无用的观察值。</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="89a2" class="kz la it kv b gy lb lc l ld le">is_C = function (x) startsWith(x,"C")<br/>dataset2 = dataset[which(!is_C(dataset$InvoiceNo)),] #subsetting<br/>dataset3 = subset(dataset2,!is.na(dataset2$Description)) #subsetting</span></pre><p id="dfbf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我又看了一遍这些行，发现许多项目描述没有任何意义。例如，我看到了像“？”这样的符号以及损坏、砸碎、丢失等词语。扔掉这些不需要的东西是个好主意。我想出了一系列有趣的流行语:</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="1f2f" class="kz la it kv b gy lb lc l ld le">buzzwords = c("WRONG","LOST", "CRUSHED", "SMASHED", "DAMAGED", "FOUND", "THROWN", "MISSING", "AWAY", "\\?", "CHECK", "POSTAGE", "MANUAL", "CHARGES", "AMAZON", "FEE", "FAULT", "SALES", "ADJUST", "COUNTED", "LABEL", "INCORRECT", "SOLD", "BROKEN", "BARCODE", "CRACKED", "RETURNED", "MAILOUT", "DELIVERY", "MIX UP", "MOULDY", "PUT ASIDE", "ERROR", "DESTROYED", "RUSTY")</span></pre><p id="3939" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果任何项目包含这些单词中的一个，它将被删除。以下功能<em class="kp">是不合需要的</em>测试一个项目是否“不合需要”。</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="f509" class="kz la it kv b gy lb lc l ld le">library(stringr)   #function str_detect</span><span id="06ed" class="kz la it kv b gy lf lc l ld le">isUndesirable = function(x){</span><span id="29f4" class="kz la it kv b gy lf lc l ld le">c = <strong class="kv iu">FALSE</strong>   <!-- -->#assume that the string is undesirable (FALSE), and perhaps switch to desirable (TRUE)</span><span id="e736" class="kz la it kv b gy lf lc l ld le">for (i <strong class="kv iu">in</strong> <!-- -->1:(length(buzzwords))){<br/>  c = c || ifelse(str_detect(toupper(x),buzzwords[i]),<strong class="kv iu">TRUE</strong>,<strong class="kv iu">FALSE</strong>)<br/>}</span><span id="b3e6" class="kz la it kv b gy lf lc l ld le">#now we know whether or not the string is undesirable</span><span id="0b53" class="kz la it kv b gy lf lc l ld le">return(c)</span><span id="b335" class="kz la it kv b gy lf lc l ld le">}</span></pre><p id="c80f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以子集化<em class="kp"> dataset3 </em>使得<em class="kp">数量</em>大于 0(否则没有意义)，项目名称为“合意”。我们得到<em class="kp">数据集 4 </em>，最后得到<em class="kp">数据集 5 </em>。<em class="kp"> InvoiceDate </em>被转换为<em class="kp"> POSIXct </em>对象，订单的确切时间被排除。<em class="kp">描述</em>列被分解。</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="9097" class="kz la it kv b gy lb lc l ld le">dataset4 = subset(dataset3, dataset3$Quantity &gt; 0)</span><span id="548e" class="kz la it kv b gy lf lc l ld le">dataset5 = dataset4[which(!isUndesirable2(as.character(dataset4$Description))),]</span><span id="ef64" class="kz la it kv b gy lf lc l ld le">Time = format(as.POSIXct(strptime(dataset5$InvoiceDate,"%Y-%m-%d %H:%M",tz="")) ,format = "%H:%M:%S")</span><span id="143c" class="kz la it kv b gy lf lc l ld le">dataset5$InvoiceDate = as.Date(dataset5$InvoiceDate)<br/>dataset5$Description = as.factor(dataset5$Description)</span></pre><p id="1a8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样！现在我们有了包含 530 653 个观察值的<em class="kp">数据集 5 </em>，准备用于购物篮分析。请注意，该数据集在<em class="kp"> CustomerID </em>列中仍然有缺失值。然而，这无关紧要，我们为什么要关心客户的 ID 呢？发票号对于发现关联规则和进一步分析更为重要。然而，如果我们想在另一个分析中使用这个数据，我们可以用不同的方式对它进行预处理。</p><p id="d68d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完整的 R 代码，请访问<a class="ae ko" href="https://github.com/dinajankovic/Market-Basket-Analysis-Online-Retail" rel="noopener ugc nofollow" target="_blank">我的 GitHub 简介。</a></p></div></div>    
</body>
</html>