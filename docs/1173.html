<html>
<head>
<title>Spark Machine Learning in Clojure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Clojure 中的 Spark 机器学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/spark-machine-learning-in-clojure-1d5a2c97924a?source=collection_archive---------6-----------------------#2017-08-05">https://towardsdatascience.com/spark-machine-learning-in-clojure-1d5a2c97924a?source=collection_archive---------6-----------------------#2017-08-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7828" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然 Spark 是在 Scala 中实现的，但是我们可以使用 Spark 平台来完成机器学习任务，这要感谢<a class="ae kl" href="https://github.com/gorillalabs/sparkling" rel="noopener ugc nofollow" target="_blank"> Sparkling 库</a>。</p><p id="fb8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这张工作表中，我们将演示在机器学习的分类任务中使用 Sparkling。让我们首先加载依赖项</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="72bb" class="kv kw iq kr b gy kx ky l kz la">(ns itchy-garden<br/>  (:require [sparkling.conf :as conf]<br/>            [sparkling.core :as s]<br/>            [sparkling.ml.core :as m]<br/>            [sparkling.ml.classification :as cl]<br/>            [sparkling.ml.transform :as xf]<br/>            [sparkling.ml.validation :as v])</span><span id="c184" class="kv kw iq kr b gy lb ky l kz la">  (:import [org.apache.spark.api.java JavaSparkContext]<br/>           [org.apache.spark.sql DataFrame SQLContext]<br/>           [org.apache.spark.ml.classification NaiveBayes LogisticRegression<br/>            DecisionTreeClassifier RandomForestClassifier GBTClassifier ]<br/>           [java.io File]))</span><span id="15b6" class="kv kw iq kr b gy lb ky l kz la"><br/>;;output</span><span id="da96" class="kv kw iq kr b gy lb ky l kz la">nil</span></pre><p id="11ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们加载一个 libsvm 格式的数据集。这包括大约 3k 个实例，其中每个实例都有一个值为 0 或 1 的目标变量，以及多个连续值的特征。</p><p id="fb2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，Spark 的 ML 库实现仅适用于<em class="lc">正标签</em>，标签在 1，-1 范围内的数据集不能开箱即用，标签需要更改为正。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="9b6e" class="kv kw iq kr b gy kx ky l kz la">(defn download-dataset<br/>  []<br/>  (let [svm-dataset-path<br/>        "http://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/binary/svmguide1"<br/>        tmpfile (.getPath (File/createTempFile "svmguide" "svm"))<br/>        _ (spit tmpfile (slurp svm-dataset-path))]<br/>    tmpfile))</span><span id="a7e8" class="kv kw iq kr b gy lb ky l kz la">(def dataset-path (download-dataset))</span></pre><h1 id="9185" class="ld kw iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">交互效度分析</h1><p id="5d34" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们将在这个数据集上训练一个二进制分类器，并在 areaUnderROC 曲线度量上使用交叉验证来评估它的性能。</p><p id="53ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个 API 使用中间件模式(受<a class="ae kl" href="https://github.com/ring-clojure/ring/wiki/Concepts" rel="noopener ugc nofollow" target="_blank">环</a>的启发)来指定这些工件:</p><ul class=""><li id="868c" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">处理函数进行交叉验证</li><li id="abb3" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">add-dataset 函数采用一个函数，该函数返回 Spark 数据帧中的数据集</li><li id="2866" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">估计量是所使用的分类器或回归量的类型。在这种情况下，我们将使用逻辑回归分类器。</li><li id="5712" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">这种情况下的评估器是二元分类评估器。如果我们有一个多类分类问题，一个多类评估将适用。分类的默认度量是 ROC 曲线下的面积。</li></ul><p id="b683" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lc"> run-pipeline </em>函数将执行处理程序并返回交叉验证的 areaUnderROC 指标。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="0db6" class="kv kw iq kr b gy kx ky l kz la">(let [cvhandler (-&gt; m/cv-handler<br/>                    (m/add-dataset (partial m/load-libsvm-dataset dataset-path))<br/>                    (m/add-estimator cl/logistic-regression)<br/>                    (m/add-evaluator v/binary-classification-evaluator))]<br/>  (m/run-pipeline cvhandler))</span><span id="41d4" class="kv kw iq kr b gy lb ky l kz la">;;output: areaUnderROC score</span><span id="3497" class="kv kw iq kr b gy lb ky l kz la">(0.989250155930387)</span></pre><p id="8e14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前面的示例使用了逻辑回归的默认选项以及赋值器。在下一个示例中，我们将指定</p><ul class=""><li id="ee53" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">分类器的超参数(弹性网参数)</li><li id="5e09" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">评估者的不同评估指标(精确召回曲线下的面积)</li></ul><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="41f2" class="kv kw iq kr b gy kx ky l kz la">(let [cvhandler (-&gt; m/cv-handler<br/>                    (m/add-dataset (partial m/load-libsvm-dataset dataset-path))<br/>                    (m/add-estimator cl/logistic-regression {:elastic-net-param 0.01})<br/>                    (m/add-evaluator v/binary-classification-evaluator {:metric-name "areaUnderPR"} ))]<br/>  (m/run-pipeline cvhandler))</span><span id="1338" class="kv kw iq kr b gy lb ky l kz la">;;output: area under Precision Recall</span><span id="7994" class="kv kw iq kr b gy lb ky l kz la">(0.9941958048724657)</span></pre><p id="9de0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以更改交叉验证处理程序本身的参数。让我们将折叠次数更改为 5 次(从默认的 3 次)</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="2a59" class="kv kw iq kr b gy kx ky l kz la">(let [cvhandler (-&gt; (partial m/cv-handler {:num-folds 5})<br/>                    (m/add-dataset (partial m/load-libsvm-dataset dataset-path))<br/>                    (m/add-estimator cl/logistic-regression)<br/>                    (m/add-evaluator v/binary-classification-evaluator))]<br/>  (m/run-pipeline cvhandler))</span><span id="ec58" class="kv kw iq kr b gy lb ky l kz la">;;output</span><span id="f8e3" class="kv kw iq kr b gy lb ky l kz la">(0.9894297378637298)</span></pre><h1 id="2f7f" class="ld kw iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">训练-验证分割</h1><p id="42b3" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">除了使用交叉验证，我们还可以使用单一折叠，并根据百分比分割训练测试集。</p><p id="2430" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用训练验证处理程序，而不是交叉验证处理程序，而其他参数保持不变。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="fed3" class="kv kw iq kr b gy kx ky l kz la">(let [tvhandler (-&gt; m/tv-handler<br/>                    (m/add-dataset (partial m/load-libsvm-dataset dataset-path))<br/>                    (m/add-estimator cl/logistic-regression)<br/>                    (m/add-evaluator v/binary-classification-evaluator))]<br/>  (m/run-pipeline tvhandler))</span><span id="c106" class="kv kw iq kr b gy lb ky l kz la">;;output </span><span id="aec3" class="kv kw iq kr b gy lb ky l kz la">(0.9919497271895795)</span></pre><p id="69c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们指定一个不同的训练与验证比率，其中训练集是 60%，其余的是验证集。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="a468" class="kv kw iq kr b gy kx ky l kz la">(let [tvhandler (-&gt; (partial m/tv-handler {:train-ratio 0.6} )<br/>                    (m/add-dataset (partial m/load-libsvm-dataset dataset-path))<br/>                    (m/add-estimator cl/logistic-regression)<br/>                    (m/add-evaluator v/binary-classification-evaluator))]<br/>  (m/run-pipeline tvhandler))</span><span id="48ea" class="kv kw iq kr b gy lb ky l kz la">;;output</span><span id="d986" class="kv kw iq kr b gy lb ky l kz la">(0.9897219862173144)</span></pre><h1 id="24d9" class="ld kw iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">网格搜索</h1><p id="e73e" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">通常分类器使用多个超参数，我们希望找到给出最佳分类分数的超参数的值。SparkML 为此提供了网格搜索功能。参见<a class="ae kl" href="http://scikit-learn.org/stable/modules/grid_search.html" rel="noopener ugc nofollow" target="_blank">链接</a>了解 Scikit-learn 中的网格搜索</p><p id="bc7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将指定一系列<em class="lc">正则化</em>值，并为每个值找到交叉验证的分数。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="f774" class="kv kw iq kr b gy kx ky l kz la">(defn addregularization<br/>  "sets the regularization parameters to search over"<br/>  [regparam est]<br/>  (v/param-grid [[(.regParam est) (double-array regparam)]]))</span><span id="778b" class="kv kw iq kr b gy lb ky l kz la">(let [cvhandler (-&gt; m/cv-handler<br/>                    ;;search for the best value for the regularization parameter <br/>                    (m/add-grid-search (partial addregularization [0.1 0.05 0.01]))<br/>                    (m/add-evaluator v/binary-classification-evaluator)<br/>                    (m/add-estimator cl/logistic-regression)<br/>                    (m/add-dataset (partial m/load-libsvm-dataset dataset-path)))]<br/>  (m/run-pipeline cvhandler))</span><span id="b627" class="kv kw iq kr b gy lb ky l kz la">;;output</span><span id="2399" class="kv kw iq kr b gy lb ky l kz la">(0.9730089312309409 0.9773629797090069 0.9853807421182689)</span></pre><p id="ffde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这 3 个分数对应于正则化的三个值，我们可以看到最后一个值(0.01)返回了 AucROC 度量上的最佳交叉验证分数。</p></div></div>    
</body>
</html>