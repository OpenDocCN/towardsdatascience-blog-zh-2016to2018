<html>
<head>
<title>Building a Deployable ML Classifier in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python构建可部署的ML分类器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-deployable-ml-classifier-in-python-46ba55e1d720?source=collection_archive---------4-----------------------#2018-03-05">https://towardsdatascience.com/building-a-deployable-ml-classifier-in-python-46ba55e1d720?source=collection_archive---------4-----------------------#2018-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/04ded412ced3c24ae1f323900de64976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sSyxXDyxyozp12SM1qu0lg.jpeg"/></div></div></figure><div class=""/><p id="38be" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如今，由于问题的复杂性和大量的相关数据，机器学习已经完全成为寻找问题解决方案的必要、有效和高效的方法。在大多数资源中，机器学习模型是在结构化数据中开发的，只是为了检查模型的准确性。但是，在开发机器学习模型时，实时的一些主要要求是在构建模型、模型中的参数调整以及将模型保存到文件系统以供以后使用或部署时处理不平衡的数据。在这里，我们将看到如何用python设计一个二进制分类器，同时处理上面指定的所有三个需求。</p><p id="8b21" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在开发机器学习模型时，我们通常会将所有的创新放在标准的工作流程中。涉及的一些步骤是获取数据，对数据进行特征工程，通过迭代训练和测试建立具有适当参数的模型，并在生产中部署建立的模型。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi kw"><img src="../Images/9584a27a02b7b7f2314f887c6bb4c3e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PAqzvCxPjpDN8RC9HQw45w.jpeg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Machine Learning Work Flow</figcaption></figure><p id="8280" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将通过构建一个二元分类器来完成这个工作流程，该分类器根据可用的特征来预测红酒的质量。<a class="ae lf" href="https://archive.ics.uci.edu/ml/datasets/wine+quality" rel="noopener ugc nofollow" target="_blank">数据集在UCI机器学习库中公开。</a> Scikit学习库在这里用于分类器设计。对于源代码，<a class="ae lf" href="https://github.com/sambit9238/Machine-Learning/blob/master/WineQuality.ipynb" rel="noopener ugc nofollow" target="_blank"> github </a>链接是-</p><div class="ip iq gp gr ir lg"><a href="https://github.com/sambit9238/Machine-Learning/blob/master/WineQuality.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab fo"><div class="li ab lj cl cj lk"><h2 class="bd jc gy z fp ll fr fs lm fu fw ja bi translated">sambit 9238/机器学习</h2><div class="ln l"><h3 class="bd b gy z fp ll fr fs lm fu fw dk translated">机器学习——它代表了机器学习在不同场景中的一些实现。</h3></div><div class="lo l"><p class="bd b dl z fp ll fr fs lm fu fw dk translated">github.com</p></div></div><div class="lp l"><div class="lq l lr ls lt lp lu ix lg"/></div></div></a></div><p id="0581" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们需要导入所有必要的依赖项并加载数据集。在任何ml模型设计中，我们总是需要numpy和pandas，因为它们都涉及到数据帧、矩阵和数组操作。</p><pre class="kx ky kz la gt lv lw lx ly aw lz bi"><span id="0e3b" class="ma mb jb lw b gy mc md l me mf">import numpy as np<br/>import pandas as pd<br/>df = pd.read_csv("winequality-red.csv")<br/>df.head()</span></pre><p id="c085" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">数据集看起来像-</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mg"><img src="../Images/b55e8d15af8a63cf50977b40d237cb09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*laSVr3BaVOW-PFvxcCcf1g.png"/></div></div></figure><p id="8c52" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从这里可以看出，质量是用数字3到8来表示的。为了使它成为二进制分类问题，让我们把质量&gt; 5看作是好的，否则就是坏的。</p><pre class="kx ky kz la gt lv lw lx ly aw lz bi"><span id="2b3c" class="ma mb jb lw b gy mc md l me mf">df["quality_bin"] = np.zeros(df.shape[0])<br/>df["quality_bin"] = df["quality_bin"].where(df["quality"]&gt;=6, 1)<br/>#1 means good quality and 0 means bad quality</span></pre><p id="956a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来获得数据描述的摘要—</p><pre class="kx ky kz la gt lv lw lx ly aw lz bi"><span id="9329" class="ma mb jb lw b gy mc md l me mf">df.describe()</span></pre><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mh"><img src="../Images/d23c10070388dd6b4d8ee66bebd3204a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DhXF60AZ7rRN9H_DCU0TRg.png"/></div></div></figure><p id="4191" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从快照中可以看出，数据值在某些属性上有很大偏差。将这些值标准化是一个很好的做法，因为这将使差异达到一个合理的水平。此外，由于大多数算法在背景中使用欧几里德距离，因此在模型建立中具有缩放特征更好。</p><pre class="kx ky kz la gt lv lw lx ly aw lz bi"><span id="b00d" class="ma mb jb lw b gy mc md l me mf">from sklearn.preprocessing import StandardScaler<br/>X_data = df.iloc[:,:11].values<br/>y_data = df.iloc[:,12].values<br/>scaler = StandardScaler()<br/>X_data = scaler.fit_transform(X_data)</span></pre><p id="0cd4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里使用了fit_transform，这样标准缩放器将适合X_data并转换X_data。如果你需要在两个不同的数据集上进行拟合和变换，你也可以分别调用拟合和变换函数。现在，我们总共有1599个数据实例，其中855个质量差，744个质量好。这里的数据显然是不平衡的。因为数据实例的数量较少，所以我们将进行过采样。<strong class="ka jc"> <em class="mi">但是需要注意的是，重采样应该总是只在训练数据上进行，而不是在测试/验证数据上</em>。</strong>现在，让我们将数据集分为训练数据集和测试数据集进行建模。</p><pre class="kx ky kz la gt lv lw lx ly aw lz bi"><span id="f92e" class="ma mb jb lw b gy mc md l me mf">from sklearn.cross_validation import train_test_split<br/>X_train, X_test, y_train, y_test = train_test_split(X_data, y_data, test_size=0.3, random_state=42) <br/>#so that 30% will be selected for testing data randomly</span></pre><p id="ed92" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了训练和测试分割，你还可以采用被认为是更有效的交叉验证方法。现在我们有588个质量差的和531个质量好的实例用于训练。剩下267个质量差的和213个质量好的测试实例。是时候对训练数据进行重新采样，以便平衡数据，使模型不会有偏差。这里我们将使用SMOTE算法进行过采样。</p><pre class="kx ky kz la gt lv lw lx ly aw lz bi"><span id="fc6b" class="ma mb jb lw b gy mc md l me mf">from imblearn.over_sampling import SMOTE<br/>#resampling need to be done on training dataset only<br/>X_train_res, y_train_res = SMOTE().fit_sample(X_train, y_train)</span></pre><p id="0898" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">经过过采样后，在训练集中有588个好的和坏的葡萄酒样本。现在是选择模型的时候了。我在这里采用了随机梯度分类器。但是，你现在可以检查几个模型并比较它们的准确性来选择合适的。</p><pre class="kx ky kz la gt lv lw lx ly aw lz bi"><span id="2d27" class="ma mb jb lw b gy mc md l me mf">from sklearn.linear_model import SGDClassifier<br/>sg = SGDClassifier(random_state=42)<br/>sg.fit(X_train_res,y_train_res)<br/>pred = sg.predict(X_test)<br/>from sklearn.metrics import classification_report,accuracy_score<br/>print(classification_report(y_test, pred))<br/>print(accuracy_score(y_test, pred))</span></pre><p id="789f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果看起来像-</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/891ef9a063484ef4a19299acd8327288.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*KA5ys-dcDunFBRo-TxzttA.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Classification Report</figcaption></figure><p id="a00c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">得到的准确率为65.625%。学习率、损失函数等参数。在模型的性能中起主要作用。使用GridSearchCV可以有效地为模型选择最佳参数。</p><pre class="kx ky kz la gt lv lw lx ly aw lz bi"><span id="12dd" class="ma mb jb lw b gy mc md l me mf">#parameter tuning <br/>from sklearn.model_selection import GridSearchCV<br/>#model<br/>model = SGDClassifier(random_state=42)<br/>#parameters<br/>params = {'loss': ["hinge", "log", "perceptron"],<br/>          'alpha':[0.001, 0.0001, 0.00001]}<br/>#carrying out grid search<br/>clf = GridSearchCV(model, params)<br/>clf.fit(X_train_res, y_train_res)<br/>#the selected parameters by grid search<br/>print(clf.best_estimator_)</span></pre><figure class="kx ky kz la gt is gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/9b8cea2243af95b9c7c1d9ec9d34af57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*4Vfd1c5I798o9KzTtwzLng.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Best Parameters for the Classifier</figcaption></figure><p id="28e3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如这里可以看到的，这里只提供了损失函数和alpha，用于寻找最佳选项。其他参数也可以这样做。损失函数的最佳选项似乎是“铰链”红外线性SVM，α值似乎是0.001。现在，我们将使用网格搜索选择的最佳参数建立一个模型。</p><pre class="kx ky kz la gt lv lw lx ly aw lz bi"><span id="48d5" class="ma mb jb lw b gy mc md l me mf">#final model by taking suitable parameters<br/>clf = SGDClassifier(random_state=42, loss="hinge", alpha=0.001)<br/>clf.fit(X_train_res, y_train_res)<br/>pred = clf.predict(X_test)</span></pre><p id="ba09" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们选择了模型，调整了参数，因此是时候在部署之前验证模型了。</p><pre class="kx ky kz la gt lv lw lx ly aw lz bi"><span id="d9d8" class="ma mb jb lw b gy mc md l me mf">print(classification_report(y_test, pred))<br/>print(accuracy_score(y_test, pred))</span></pre><figure class="kx ky kz la gt is gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/82c505185613cc2a60de7783c2a8379e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*0ZUIOUiRYWMgknKiMN8T9A.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Classification Report</figcaption></figure><p id="ea24" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从这里可以看出，调整参数后，指标值提高了2–3%。准确率也从65.625%提高到了70.625%。如果你仍然对这个模型不满意，你也可以通过一些训练和测试迭代来尝试其他算法。现在，既然模型已经构建好了，就需要将它保存到文件系统中，以便以后使用或部署到其他地方。</p><pre class="kx ky kz la gt lv lw lx ly aw lz bi"><span id="baea" class="ma mb jb lw b gy mc md l me mf">from sklearn.externals import joblib<br/>joblib.dump(clf, "wine_quality_clf.pkl")</span></pre><p id="9f58" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您需要分类器时，可以使用joblib简单地加载它，然后传递特征数组以获得结果。</p><pre class="kx ky kz la gt lv lw lx ly aw lz bi"><span id="cd6d" class="ma mb jb lw b gy mc md l me mf">clf1 = joblib.load("wine_quality_clf.pkl")<br/>clf1.predict([X_test[0]])</span></pre><p id="1842" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">恭喜你。现在你已经准备好设计一个可部署的机器学习模型了。:-D</p><p id="c214" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">参考资料:-</p><div class="ip iq gp gr ir lg"><a href="https://www.cs.cmu.edu/afs/cs/project/jair/pub/volume16/chawla02a-html/node6.html" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab fo"><div class="li ab lj cl cj lk"><h2 class="bd jc gy z fp ll fr fs lm fu fw ja bi translated">重击</h2><div class="ln l"><h3 class="bd b gy z fp ll fr fs lm fu fw dk translated">重击</h3></div><div class="lo l"><p class="bd b dl z fp ll fr fs lm fu fw dk translated">SMOTEwww.cs.cmu.edu</p></div></div><div class="lp l"><div class="mm l lr ls lt lp lu ix lg"/></div></div></a></div><div class="ip iq gp gr ir lg"><a href="http://scikit-learn.org/stable/modules/grid_search.html" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab fo"><div class="li ab lj cl cj lk"><h2 class="bd jc gy z fp ll fr fs lm fu fw ja bi translated">3.2.调整估计器的超参数-sci kit-了解0.19.1文档</h2><div class="ln l"><h3 class="bd b gy z fp ll fr fs lm fu fw dk translated">请注意，这些参数的一个小子集通常会对预测或计算产生很大影响…</h3></div><div class="lo l"><p class="bd b dl z fp ll fr fs lm fu fw dk translated">scikit-learn.org</p></div></div><div class="lp l"><div class="mn l lr ls lt lp lu ix lg"/></div></div></a></div><div class="ip iq gp gr ir lg"><a href="http://scikit-learn.org/stable/auto_examples/preprocessing/plot_scaling_importance.html" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab fo"><div class="li ab lj cl cj lk"><h2 class="bd jc gy z fp ll fr fs lm fu fw ja bi translated">功能缩放的重要性-sci kit-了解0.19.1文档</h2><div class="ln l"><h3 class="bd b gy z fp ll fr fs lm fu fw dk translated">通过标准化(或Z分数标准化)进行特征缩放对于许多应用程序来说是一个重要的预处理步骤</h3></div><div class="lo l"><p class="bd b dl z fp ll fr fs lm fu fw dk translated">scikit-learn.org</p></div></div><div class="lp l"><div class="mo l lr ls lt lp lu ix lg"/></div></div></a></div></div></div>    
</body>
</html>