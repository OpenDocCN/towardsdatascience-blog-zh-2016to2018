<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://towardsdatascience.com/developing-1d-2d-data-container-and-transformers-for-data-analysis-9790bfd75ac7?source=collection_archive---------12-----------------------#2017-12-18">https://towardsdatascience.com/developing-1d-2d-data-container-and-transformers-for-data-analysis-9790bfd75ac7?source=collection_archive---------12-----------------------#2017-12-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/c5d8dc97317d90e8977902b5a8566442.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*tmYRuG75kNb98A_so2LK6g.png"/></div><figcaption class="iv iw gj gh gi ix iy bd b be z dk">Homepage is <a class="ae iz" href="https://alan-turing-institute.github.io/xpandas/" rel="noopener ugc nofollow" target="_blank">https://alan-turing-institute.github.io/xpandas/</a></figcaption></figure><p id="3729" class="pw-post-body-paragraph ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy ij bi translated">开发用于数据分析的 1d/2d 数据容器和转换器</p><h1 id="6fd0" class="jz ka jc bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">介绍</h1><p id="b5f1" class="pw-post-body-paragraph ja jb jc jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy ij bi translated">数据科学中的每个问题都是基于数据的。在分析任何数据之前，这些数据通常需要进行预处理。预处理可以是简单的过滤，也可以是更复杂的处理，比如转换和特征提取。</p><p id="dc25" class="pw-post-body-paragraph ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy ij bi translated">对于 Python 编程语言来说，处理 1d/2d 数据集最流行的库是<strong class="jd lc">熊猫</strong>。对于一维数据如一系列数字<em class="ld">熊猫。系列</em>对象非常合适。对于 2d 数据，这样的对象被称为<em class="ld">熊猫。数据帧</em>。Pandas 对象对于存储和转换内存中的定量和分类数据都非常有用。一般来说<em class="ld">熊猫的每个细胞。数据帧</em>或<em class="ld">熊猫。序列</em>要么是实数，要么是分类字符串。</p><p id="2698" class="pw-post-body-paragraph ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy ij bi translated">如今数据集变得越来越复杂。例如，想象一个医院病人的数据集。医院需要保留这些患者的特征，如年龄(整数)、性别(分类)、一些分析分数(浮点)<em class="ld">和</em>更复杂，如心率(系列)、x 光图像(图像)。在这种情况下，不能在<em class="ld"> pandas 中存储这种数据集。数据帧</em>。</p><p id="4e0e" class="pw-post-body-paragraph ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy ij bi translated">通常，研究人员编写自己的基础设施来处理这些数据类型，或者使用标准的 Python 列表和列表列表(或<a class="ae iz" href="http://www.numpy.org/" rel="noopener ugc nofollow" target="_blank"> numpy </a>)。在存储了这种数据之后，人们希望对不同的列执行特征提取。例如，可能希望从一个序列中提取均值、标准差、分位数；用一些<a class="ae iz" href="https://en.wikipedia.org/wiki/Convolutional_neural_network" rel="noopener ugc nofollow" target="_blank"> CNN </a>从图像中提取特征等等。对于列表数据容器来说，执行这样的操作对用户来说并不友好，通常会导致<a class="ae iz" href="https://en.wikipedia.org/wiki/Spaghetti_code" rel="noopener ugc nofollow" target="_blank">意大利面条代码。</a></p><p id="bb1a" class="pw-post-body-paragraph ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy ij bi translated"><a class="ae iz" href="https://alan-turing-institute.github.io/xpandas/" rel="noopener ugc nofollow" target="_blank"><strong class="jd lc">x Pandas</strong></a>(extended Pandas)提供通用的 1d/2d 数据容器<br/>用于存储任何类型的数据，以及<em class="ld"> Transformers </em>接口用于特征提取和转换。</p><p id="8267" class="pw-post-body-paragraph ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy ij bi translated">下一章描述了一个简单的数学背景和它的 API 设计。</p><h1 id="923d" class="jz ka jc bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">数学设置和 API 设计</h1><h2 id="1ae9" class="le ka jc bd kb lf lg dn kf lh li dp kj jm lj lk kn jq ll lm kr ju ln lo kv lp bi translated">数学定义</h2><p id="d776" class="pw-post-body-paragraph ja jb jc jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy ij bi translated">设ω是任意物体的任意空间。例如，ω可以是<em class="ld"> pandas.Series. </em>的空格<br/></p><blockquote class="lq lr ls"><p id="7d64" class="ja jb ld jd b je jf jg jh ji jj jk jl lt jn jo jp lu jr js jt lv jv jw jx jy ij bi translated"><em class="jc"> X </em>称为<em class="jc"> 1d 抽象数据容器</em>如果<em class="jc">x</em>∈ωⁿ其中<em class="jc"> n </em>是数据容器中对象的数量，称为大小。<strong class="jd lc"> XPandas </strong>中的<br/> <em class="jc"> 1d 抽象数据容器</em>被称为<em class="jc"> XSeries </em>。</p><p id="cbfb" class="ja jb ld jd b je jf jg jh ji jj jk jl lt jn jo jp lu jr js jt lv jv jw jx jy ij bi translated">如果<em class="jc"> DF </em>是一组<br/> <em class="jc"> m </em> 1d 抽象数据容器，则<em class="jc"> DF </em>是一个大小为<em class="jc"> m </em>的<em class="jc"> 2d 抽象数据容器</em>。</p></blockquote><p id="3f95" class="pw-post-body-paragraph ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy ij bi translated">相对于<strong class="jd lc"> XPandas </strong>它被称为<em class="ld"> XDataFrame。<br/> XDataFrame </em>是一组尺寸为<em class="ld"> n </em>的<em class="ld">m</em>T33】x 系列。<br/> <em class="ld"> XSeries </em>和<em class="ld"> XDataFrame </em>是<strong class="jd lc"> XPandas </strong>的核心组件。<br/> <strong class="jd lc"> XPandas </strong>也为变压器提供接口。</p><blockquote class="lq lr ls"><p id="b744" class="ja jb ld jd b je jf jg jh ji jj jk jl lt jn jo jp lu jr js jt lv jv jw jx jy ij bi translated"><em class="jc">系列变压器</em>是一个功能<em class="jc">T</em>:<em class="jc">XSeries</em>→<em class="jc">(XSeries</em>或<em class="jc"> XDataFrame) </em></p><p id="38ee" class="ja jb ld jd b je jf jg jh ji jj jk jl lt jn jo jp lu jr js jt lv jv jw jx jy ij bi translated"><em class="jc">数据帧转换器</em>是封装多个<br/> <em class="jc">系列转换器的功能。</em></p><p id="e94f" class="ja jb ld jd b je jf jg jh ji jj jk jl lt jn jo jp lu jr js jt lv jv jw jx jy ij bi translated"><em class="jc">DFT</em>:{<em class="jc">series transformer</em>}→<em class="jc">xdata frame</em></p></blockquote><p id="d7e3" class="pw-post-body-paragraph ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy ij bi translated">转换器可以对<em class="ld"> XSeries </em>的每个元素执行传统的基于元素的映射操作<br/>以及更复杂的转换，<br/>非基于元素的转换的一个简单例子就是转换</p><blockquote class="lq lr ls"><p id="7b47" class="ja jb ld jd b je jf jg jh ji jj jk jl lt jn jo jp lu jr js jt lv jv jw jx jy ij bi translated"><em class="jc"> T </em> : <em class="jc"> X </em> → ( <em class="jc">总体 _ 均值</em> — <em class="jc"> X .均值())</em></p></blockquote><p id="31d5" class="pw-post-body-paragraph ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy ij bi translated">其中<em class="ld"> X </em>是一只<em class="ld">熊猫。系列</em>和<em class="ld">总体平均值</em>是整个<em class="ld">系列</em>的平均值(是<em class="ld">系列</em>中所有数字的平均值)。因此，转换从每只熊猫的平均值中减去全球平均值。系列。</p><h2 id="e3c1" class="le ka jc bd kb lf lg dn kf lh li dp kj jm lj lk kn jq ll lm kr ju ln lo kv lp bi translated">应用程序接口</h2><p id="2bf1" class="pw-post-body-paragraph ja jb jc jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy ij bi translated"><em class="ld"> XSeries </em>基于<em class="ld">熊猫。系列</em>并且可以存储任何类型的对象。例如，一个人可能想要储存熊猫。<em class="ld"> XSeries </em>内的系列对象。它可以用一个图式来形象化</p><figure class="lx ly lz ma gt is gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/c53566ce47721c15d8cd2041443c42d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*UzTYUjhNmjbc9hx6BsUBJQ.png"/></div></figure><p id="a5a4" class="pw-post-body-paragraph ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy ij bi translated"><em class="ld"> XSeries </em>最重要的属性是同质性。<em class="ld"> XSeries </em>存储相同类型的对象，并具有属性<em class="ld"> data_type </em>，该属性是<em class="ld"> XSeries </em>内的一种对象类型。<em class="ld"> XDataFrame </em>基于<em class="ld">熊猫。数据帧</em>并存储一组<em class="ld"> XSeries </em>。现在让我们回到医院病人的数据集。</p><p id="9453" class="pw-post-body-paragraph ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy ij bi translated">我们已经定义了一些不同类型的健康特征，如数字(年龄、身高、体重等。)、分类(性别、发色等。)、图像(患者 x 光照片)、时间序列(随时间的心跳)以及任何其他。使用<em class="ld"> XDataFrame </em>我们现在可以将所有这些信息存储到一个内存中的 2d 容器中。</p><figure class="lx ly lz ma gt is gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mb"><img src="../Images/9ff81766c27744d39610ace7a763e3ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Wcxu7HfAYUx8tzLz0M0wQ.png"/></div></div></figure><p id="a4c5" class="pw-post-body-paragraph ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy ij bi translated">拥有如此复杂的数据集，人们通常希望使用一些现成的机器学习算法，如<a class="ae iz" href="http://scikit-learn.org" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>提供的算法。为了应用它，数据集应该被转换成定量特征的 2d 矩阵。<br/>因此，下一步是从<em class="ld"> XDataFrame </em>的列中提取特征。在病人数据的例子中，人们可能想要从每只<em class="ld">熊猫中提取统计特征。系列</em>或者使用深度学习模型从每幅图像中提取特征。</p><p id="e2f2" class="pw-post-body-paragraph ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy ij bi translated">那是变形金刚课发生的地方。使用<em class="ld">custom transformer</em><br/>class one 可以为<em class="ld"> XSeries </em>构建自己的转换器，只需对其进行子类化。类似地，可以使用<em class="ld"> DataFrameTransformer </em>类为<em class="ld"> XDataFrame </em>创建一个自定义转换器。<em class="ld"> DataFrameTransformer </em>定义为一组<em class="ld"> XSeries </em>变压器。</p><figure class="lx ly lz ma gt is gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mg"><img src="../Images/833de6015de29733f26164e4ce99bdda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bBKo1AENOWsmwBF-UpuQog.png"/></div></div><figcaption class="iv iw gj gh gi ix iy bd b be z dk">XSeries transformer can map into XSeries or XDataFrame objects</figcaption></figure><p id="8935" class="pw-post-body-paragraph ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy ij bi translated"><strong class="jd lc"> XPandas </strong>还展示了<em class="ld">PipelineChainTransformer</em>，它可以将几个变压器链接成一个变压器链或一系列变压器。例如，一个人可能想要从熊猫的 XSeries 中提取特征。使用<a class="ae iz" href="http://tsfresh.readthedocs.io" rel="noopener ugc nofollow" target="_blank">t 刷新</a>然后应用<a class="ae iz" href="http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html" rel="noopener ugc nofollow" target="_blank"> scikit 的系列对象-学习 PCA </a>。</p><p id="a878" class="pw-post-body-paragraph ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy ij bi translated">评估器(分类器/回归器)对象也可以作为<em class="ld"> PipelineChainTransformer 的最后一步传递。</em>在这种情况下，行为类似于<a class="ae iz" href="http://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html" rel="noopener ugc nofollow" target="_blank"> scikit-learn 管道。</a></p><p id="bb7f" class="pw-post-body-paragraph ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy ij bi translated">完整的用法教程可在<a class="ae iz" href="https://github.com/kiraly-group/XPandas/blob/development/examples/Example%20Usage.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><h1 id="470c" class="jz ka jc bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">参考</h1><p id="ac1f" class="pw-post-body-paragraph ja jb jc jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy ij bi translated">[1]韦斯·麦金尼。pandas:用于数据分析和统计的基础 python 库。</p><p id="dc2a" class="pw-post-body-paragraph ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy ij bi translated">[2]韦斯·麦金尼。python 中统计计算的数据结构。编辑，第九届 Python 科学会议论文集，第 51-56 页，2010。</p><p id="b371" class="pw-post-body-paragraph ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy ij bi translated">[3] F. Pedregosa, G. Varoquaux, A. Gramfort, V. Michel, B. Thirion, O. Grisel, M. Blondel, P. Prettenhofer, R. Weiss, V. Dubourg, J. Vanderplas, A. Passos, D. Cournapeau, M. Brucher, M. Perrot, 和 E. Duchesnay。Scikit-learn: Python 中的机器学习《机器学习研究杂志》,12:2825–2830,2011。</p></div></div>    
</body>
</html>