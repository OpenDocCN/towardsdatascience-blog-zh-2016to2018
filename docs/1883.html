<html>
<head>
<title>Face Recognition: Understanding LBPH Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">人脸识别:理解LBPH算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/face-recognition-how-lbph-works-90ec258c3d6b?source=collection_archive---------0-----------------------#2017-11-10">https://towardsdatascience.com/face-recognition-how-lbph-works-90ec258c3d6b?source=collection_archive---------0-----------------------#2017-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/7752eb6c80137636ef326447eaac6a8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wb6dl0oibAdMa8rlnPlUzQ.jpeg"/></div></div></figure><div class=""/><p id="6bf0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">人类每天都在自动进行人脸识别，几乎不费吹灰之力。</p><p id="9a50" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这听起来对我们来说是一个非常简单的任务，但对计算机来说却是一个复杂的任务，因为它有许多变量会影响方法的准确性，例如:光照变化、低分辨率、遮挡等。</p><p id="5b75" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在计算机科学中，人脸识别基本上是根据人脸图像识别一个人的任务。在过去的二十年里，它变得非常流行，主要是因为新方法的发展和当前视频/摄像机的高质量。</p><p id="e77e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意<strong class="ka jc">人脸识别</strong>不同于<strong class="ka jc">人脸检测</strong>:</p><ul class=""><li id="80e9" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka jc">人脸检测</strong>:它的目的是找到图像中的人脸(位置和大小)，并可能提取它们以供人脸识别算法使用。</li><li id="75ba" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka jc">面部识别</strong>:面部图像已经被提取、裁剪、调整大小并通常转换为灰度，面部识别算法负责寻找最能描述图像的特征。</li></ul><p id="f4f2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">面部识别系统基本上可以在两种模式下运行:</p><ul class=""><li id="b614" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka jc">面部图像的验证或认证</strong>:基本上是将输入的面部图像与要求认证的用户相关的面部图像进行比较。基本上就是1x1的对比。</li><li id="1ea7" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka jc">身份识别或面部识别</strong>:它主要将输入的面部图像与数据集中的所有面部图像进行比较，目的是找到与该面部相匹配的用户。基本上是1xN的对比。</li></ul><p id="43ab" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有不同类型的人脸识别算法，例如:</p><ul class=""><li id="3544" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><a class="ae lk" href="http://www.scholarpedia.org/article/Eigenfaces" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc"/></a><strong class="ka jc">(1991)</strong></li><li id="80a4" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae lk" href="https://en.wikipedia.org/wiki/Local_binary_patterns" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc">【LBPH】</strong></a><strong class="ka jc">(1996)</strong></li><li id="9b78" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae lk" href="http://www.scholarpedia.org/article/Fisherfaces" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc"/></a><strong class="ka jc">(1997)</strong></li><li id="e8d0" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae lk" href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc">【尺度不变特征变换】</strong> </a> <strong class="ka jc"> (1999) </strong></li><li id="0f92" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae lk" href="https://en.wikipedia.org/wiki/Speeded_up_robust_features" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc">【加速健壮特性】 (冲浪)</strong> </a> <strong class="ka jc"> (2006) </strong></li></ul><p id="07ec" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每种方法都有不同的方法来提取图像信息并执行与输入图像的匹配。然而，特征面和鱼面方法以及SIFT和SURF方法具有类似的方法。</p><p id="d702" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天我们要讨论一种最古老(不是最古老)也是最流行的人脸识别算法:<strong class="ka jc">局部二值模式直方图(LBPH) </strong>。</p><h1 id="5cef" class="ll lm jb bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">目标</h1><p id="7e2c" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">这篇文章的目的是尽可能简单地解释<strong class="ka jc"> LBPH </strong>，一步一步地展示这个方法。</p><p id="3463" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于这是一种比较简单的人脸识别算法，我想每个人都可以理解它，没有大的困难。</p><h1 id="2c8f" class="ll lm jb bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">介绍</h1><blockquote class="mo mp mq"><p id="bd79" class="jy jz mr ka b kb kc kd ke kf kg kh ki ms kk kl km mt ko kp kq mu ks kt ku kv ij bi translated"><strong class="ka jc">局部二进制模式</strong> (LBP)是一个简单但非常有效的纹理算子，它通过对每个像素的邻域进行阈值处理来标记图像的像素，并将结果视为二进制数。</p></blockquote><p id="3c88" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它在1994年首次被描述(LBP ),并且已经被发现是纹理分类的强大特征。已经进一步确定，当LBP与方向梯度直方图(HOG)描述符结合时，它在一些数据集上显著提高了检测性能。</p><p id="d18d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用LBP结合直方图，我们可以用简单的数据向量来表示人脸图像。</p><p id="f49a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为LBP是视觉描述符，所以它也可以用于面部识别任务，正如在下面的逐步解释中可以看到的。</p><p id="31de" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">注</strong>:你可以在这里阅读更多关于LBPH:<a class="ae lk" href="http://www.scholarpedia.org/article/Local_Binary_Patterns" rel="noopener ugc nofollow" target="_blank">http://www.scholarpedia.org/article/Local_Binary_Patterns</a></p><h1 id="1f96" class="ll lm jb bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">循序渐进</h1><p id="9f2b" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">现在，我们对人脸识别和LBPH有了更多的了解，让我们更进一步，看看算法的步骤:</p><ol class=""><li id="fe00" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv mv lc ld le bi translated"><strong class="ka jc">参数</strong>:LBPH使用4个参数:</li></ol><ul class=""><li id="cdaa" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka jc">半径</strong>:半径用于构建圆形局部二值模式，代表中心像素周围的半径。它通常设置为1。</li><li id="4c87" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka jc">邻居</strong>:构建圆形局部二值模式的样本点数。请记住:包含的样本点越多，计算成本就越高。通常设置为8。</li><li id="4a8f" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka jc">网格X </strong>:水平方向的单元格个数。单元越多，网格越细，得到的特征向量的维度越高。通常设置为8。</li><li id="6d4f" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka jc">网格Y </strong>:垂直方向的单元格个数。单元越多，网格越细，得到的特征向量的维度越高。通常设置为8。</li></ul><p id="07c0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在不用担心参数，看完后面的步骤你就明白了。</p><p id="cdac" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> 2。</strong> <strong class="ka jc">训练算法</strong>:首先，我们需要训练算法。为此，我们需要使用一个包含我们想要识别的人的面部图像的数据集。我们还需要为每张图像设置一个ID(它可能是一个数字或人名)，因此算法将使用这些信息来识别输入图像并给你一个输出。同一个人的图像必须有相同的ID。训练集已经构建好了，让我们看看LBPH的计算步骤。</p><p id="b74f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> 3。应用LBP操作</strong>:LBPH的第一个计算步骤是创建一个中间图像，通过突出面部特征，以更好的方式描述原始图像。为此，该算法使用滑动窗口的概念，基于参数<strong class="ka jc">半径</strong>和<strong class="ka jc">邻居</strong>。</p><p id="d8df" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下图显示了此过程:</p><figure class="mx my mz na gt is gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/afbd39d176eba35920ba324b5d0802b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*J16_DKuSrnAH3WDdqwKeNA.png"/></div></figure><p id="0e0e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据上面的图片，让我们把它分成几个小步骤，这样我们就可以很容易地理解它:</p><ul class=""><li id="491e" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">假设我们有一张灰度的面部图像。</li><li id="d4da" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">我们可以得到这个图像的一部分，作为一个3x3像素的窗口。</li><li id="3cce" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">也可以表示为包含每个像素(0~255)强度的3x3矩阵。</li><li id="483d" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">然后，我们需要取矩阵的中心值作为阈值。</li><li id="1141" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">该值将用于定义来自8个邻居的新值。</li><li id="7e88" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">对于中心值(阈值)的每个邻居，我们设置一个新的二进制值。我们将等于或高于阈值的值设置为1，将低于阈值的值设置为0。</li><li id="c8d4" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">现在，矩阵将只包含二进制值(忽略中心值)。我们需要将矩阵中每个位置的每个二进制值逐行连接成一个新的二进制值(例如10001101)。注意:一些作者使用其他方法连接二进制值(例如顺时针方向)，但最终结果将是相同的。</li><li id="03ea" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">然后，我们将这个二进制值转换为十进制值，并将其设置为矩阵的中心值，这实际上是原始图像的一个像素。</li><li id="93e7" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">在这个过程(LBP过程)的最后，我们有一个新的图像，它更好地代表了原始图像的特征。</li><li id="0608" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka jc">注</strong>:LBP程序被扩展为使用不同数量的半径和邻居，它被称为圆形LBP。</li></ul><figure class="mx my mz na gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nb"><img src="../Images/cfcf9c2c7f4a0c684327cf8a18933f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lcA9poRiT4KnWDaW-KfKjw.png"/></div></div></figure><p id="f484" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以通过使用<strong class="ka jc">双线性插值</strong>来完成。如果某个数据点在像素之间，它将使用最近的4个像素(2x2)的值来估计新数据点的值。</p><p id="d0ae" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> 4。提取直方图</strong>:现在，使用上一步生成的图像，我们可以使用<strong class="ka jc">网格X </strong>和<strong class="ka jc">网格Y </strong>参数将图像分成多个网格，如下图所示:</p><figure class="mx my mz na gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nc"><img src="../Images/461dfe8e977ed292c6c27d2853f61348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-cyqWPcas3CXp4O2O7xPpg.png"/></div></div></figure><p id="0f66" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据上面的图像，我们可以提取每个区域的直方图如下:</p><ul class=""><li id="888b" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">由于我们有一个灰度图像，每个直方图(来自每个网格)将只包含256个位置(0~255 ),代表每个像素强度的出现。</li><li id="b237" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">然后，我们需要连接每个直方图来创建一个新的更大的直方图。假设我们有8×8的网格，在最终的直方图中我们将有8×8×256 = 16.384个位置。最终的直方图表示图像原始图像的特征。</li></ul><p id="e4b2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">LBPH算法差不多就是这样。</p><p id="e985" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> 5。执行面部识别</strong>:在这个步骤中，算法已经被训练。创建的每个直方图用于表示来自训练数据集的每个图像。因此，给定一个输入图像，我们对这个新图像再次执行这些步骤，并创建一个代表该图像的直方图。</p><ul class=""><li id="d56c" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">因此，要找到与输入图像匹配的图像，我们只需比较两个直方图，并返回直方图最接近的图像。</li><li id="c993" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">我们可以使用各种方法来比较直方图(计算两个直方图之间的距离)，例如:<strong class="ka jc">欧氏距离</strong>、<strong class="ka jc">卡方</strong>、<strong class="ka jc">绝对值</strong>等。在本例中，我们可以根据以下公式使用欧几里德距离(这是众所周知的):</li></ul><figure class="mx my mz na gt is gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/d8e5fbc9c715ff407d53987cda97abee.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/1*ELc7BVm7lD_im8CqYAMFUA.gif"/></div></figure><ul class=""><li id="9933" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">因此，算法输出是直方图最接近的图像的ID。该算法还应返回计算出的距离，该距离可用作'<strong class="ka jc">置信度</strong>'度量。<strong class="ka jc">注意</strong>:不要被“置信度”这个名称所迷惑，因为置信度越低越好，因为这意味着两个直方图之间的距离越近。</li><li id="60e2" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">然后，我们可以使用阈值和“置信度”来自动估计算法是否正确识别了图像。我们可以假设该算法已经成功识别了置信度是否低于定义的阈值。</li></ul><h1 id="3cb1" class="ll lm jb bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><ul class=""><li id="7f43" class="kw kx jb ka b kb mj kf mk kj ne kn nf kr ng kv lb lc ld le bi translated">LBPH是最简单的人脸识别算法之一。</li><li id="4211" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">它可以表示图像中的局部特征。</li><li id="adb2" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">有可能获得很大的成果(主要是在可控的环境下)。</li><li id="bb9c" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">它对单调的灰度变换是鲁棒的。</li><li id="bc20" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">由<a class="ae lk" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank"> OpenCV </a>库(开源计算机视觉库)提供。</li></ul><h1 id="199e" class="ll lm jb bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">LBPH算法</h1><p id="a667" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我正在用<a class="ae lk" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> Go </strong> </a>编程语言实现<strong class="ka jc"> LBPH </strong>算法。<a class="ae lk" href="https://github.com/kelvins/lbph" rel="noopener ugc nofollow" target="_blank">项目</a>可在<a class="ae lk" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> Github </strong> </a>上获得，并在<a class="ae lk" href="https://github.com/kelvins/lbph/blob/master/LICENSE" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> MIT许可</strong> </a>下发布，因此请随意为该项目做出贡献(欢迎任何贡献)。<br/> <strong class="ka jc">链接到项目</strong>:<a class="ae lk" href="https://github.com/kelvins/lbph" rel="noopener ugc nofollow" target="_blank">https://github.com/kelvins/lbph</a></p><p id="9a35" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">注</strong>:结论中提到的<strong class="ka jc"> LBPH </strong>也是由<a class="ae lk" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> OpenCV库</strong> </a>提供的。OpenCV库可以被许多编程语言使用(例如C++、Python、Ruby、Matlab)。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="29bc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢这个故事，请鼓掌。这激励我写更多关于人脸识别的故事。</p><h1 id="e5d2" class="ll lm jb bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">参考</h1><ul class=""><li id="9494" class="kw kx jb ka b kb mj kf mk kj ne kn nf kr ng kv lb lc ld le bi translated">阿霍宁、蒂莫、阿卜杜努尔·哈迪德和马蒂·皮蒂凯宁。<strong class="ka jc">局部二值模式人脸描述:应用于人脸识别</strong>。IEEE模式分析与机器智能汇刊28.12(2006):2037–2041。</li><li id="5f07" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">奥哈拉、提莫、马蒂·皮蒂凯宁和托皮·马恩帕。<strong class="ka jc">多分辨率灰度和旋转不变纹理分类与局部二值模式</strong>。IEEE模式分析与机器智能汇刊24.7(2002):971–987。</li><li id="a853" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">阿霍宁、蒂莫、阿卜杜勒努尔·哈迪德和马蒂·皮蒂凯宁。<strong class="ka jc">用局部二值模式进行人脸识别</strong>。计算机视觉-eccv 2004(2004):469–481。</li><li id="9af0" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">LBPH OpenCV:<a class="ae lk" href="https://docs.opencv.org/2.4/modules/contrib/doc/facerec/facerec_tutorial.html#local-binary-patterns-histograms" rel="noopener ugc nofollow" target="_blank">https://docs . OpenCV . org/2.4/modules/contrib/doc/facerec/facerec _ tutorial . html # local-binary-patterns-histograms</a></li><li id="61e6" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">本地二进制模式:<a class="ae lk" href="http://www.scholarpedia.org/article/Local_Binary_Patterns" rel="noopener ugc nofollow" target="_blank">http://www.scholarpedia.org/article/Local_Binary_Patterns</a></li></ul></div></div>    
</body>
</html>