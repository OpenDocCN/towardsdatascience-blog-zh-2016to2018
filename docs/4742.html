<html>
<head>
<title>Deploying Machine Learning Models with Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Docker 部署机器学习模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploying-machine-learning-models-with-docker-5d22a4dacb5?source=collection_archive---------2-----------------------#2018-09-04">https://towardsdatascience.com/deploying-machine-learning-models-with-docker-5d22a4dacb5?source=collection_archive---------2-----------------------#2018-09-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fae3746ac28b22d14661d97bca1f5960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FcigeCUocGksT_eaQ4JH9w.png"/></div></div></figure><p id="1372" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有很多文章解释了如何将 Flask 包装在你的机器学习模型中，作为一个 RESTful API。本文通过解释如何生产您的 Flask API 并使用 Docker 为部署做好准备，扩展了这一点。</p><h1 id="ebc6" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">动机</h1><p id="b146" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">为什么我们需要对 Flask API 做进一步的工作以使其可部署？</p><ul class=""><li id="7cc7" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated"><a class="ae mi" href="http://flask.pocoo.org/docs/1.0/deploying/#deployment" rel="noopener ugc nofollow" target="_blank"> Flask 内置服务器不适合生产</a></li><li id="822b" class="lz ma iq ka b kb mj kf mk kj ml kn mm kr mn kv me mf mg mh bi translated">与尝试在标准虚拟机上运行 Flask 相比，Docker 允许更平滑的部署和更高的可靠性。</li></ul><p id="26e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我看来，这是为什么需要进一步努力的两个最大的动机。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="11a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种方法中，我们将使用<a class="ae mi" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> nginx </a>、<a class="ae mi" href="https://gunicorn.org/" rel="noopener ugc nofollow" target="_blank"> gunicorn </a>和 Docker Compose 来创建一个可扩展、可重复的模板，以一次又一次地部署您的机器学习模型。</p><p id="98cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看看我们建议的文件夹结构:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="90cc" class="ne kx iq na b gy nf ng l nh ni">.<br/>├── README.md<br/>├── nginx/<br/>|   ├── Dockerfile<br/>|   └── nginx.conf<br/>├── api/<br/>|   ├── Dockerfile<br/>|   ├── app.py<br/>|   ├── __init__.py <br/>|   └── models/<br/>├── docker-compose.yml<br/>└── run_docker.sh</span></pre><p id="b4a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由此，我们最初的 Flask 应用程序位于<code class="fe nj nk nl na b">api/</code>文件夹中，有一个单独的文件夹<code class="fe nj nk nl na b">nginx/</code>存放我们的 nginx Docker 容器和配置。</p><p id="4eca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">nginx、gunicorn 协同工作如下:</p><ol class=""><li id="c30d" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv nm mf mg mh bi translated">客户端导航到您的网址，example.com</li><li id="f387" class="lz ma iq ka b kb mj kf mk kj ml kn mm kr mn kv nm mf mg mh bi translated">nginx 处理这个 http 请求，并将请求传递给 gunicorn</li><li id="1d19" class="lz ma iq ka b kb mj kf mk kj ml kn mm kr mn kv nm mf mg mh bi translated">gunicorn 从 nginx 接收这个请求，并提供相关的内容(gunicorn 运行您的 Flask 应用程序，并处理对它的请求)。</li></ol><p id="60b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，这有点复杂，但是比 Flask 的标准服务器更可靠和可伸缩。</p><p id="0acb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们开始吧。</p><h1 id="e9c3" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">烧瓶+ Gunicorn + Docker</h1><p id="913e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">最合理的起点是我们现有的 Flask 应用程序。本节的目标是支持 gunicorn，并为我们的应用程序创建一个 Docker 容器。</p><p id="bc6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要做的唯一针对 Flask 的更改是确保当我们启动 Flask 时，我们指定一个主机 0.0.0.0，并且我们有<code class="fe nj nk nl na b">debug=False</code>。</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="90b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nj nk nl na b">debug=False</code>很重要，如果用户遇到错误，我们不希望显示回溯。主机只是帮助我们稍后配置 nginx。</p><p id="8cb8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们创建 Dockerfile 之前，我们首先需要通过在您的终端中运行<code class="fe nj nk nl na b">pip install gunicorn</code>来安装 gunicorn。gunicorn 本身将在我们创建 Docker 合成文件时进行配置。</p><p id="d352" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在也是确保 requirements.txt 文件是最新的好时机——通过在终端中运行<code class="fe nj nk nl na b">pip freeze &gt; requirements.txt</code>来实现。</p><p id="0bd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嘣！现在我们继续创建 Docker 容器。要创建 Docker 容器，我们需要创建一个名为<code class="fe nj nk nl na b">Dockerfile</code>的文件。这个文件充当我们运行应用程序所需的一切的“配方”。要了解 Docker 本身的更多信息，请查看 Docker 网站上的<a class="ae mi" href="https://docs.docker.com/get-started/" rel="noopener ugc nofollow" target="_blank">入门页面。</a></p><p id="62ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的文档相对简单。我们利用已经安装了 Python 3.6.2 的现有基础映像，然后创建应用程序文件夹并将其复制到容器中。</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="ef97" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能会注意到，我们没有在 docker 文件中指定<code class="fe nj nk nl na b">flask run</code>或任何等效的命令。这是因为我们想使用 gunicorn 来启动我们的 Flask 应用程序。我们还想让它和我们的 nginx 容器一起启动。因此，我们将在稍后配置 Docker Compose 时这样做。</p><h1 id="0ca5" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">nginx</h1><p id="9aa4" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在我们的例子中，nginx 取代了默认的 Flask web 服务器，并且比 Flask 的内置服务器更具可伸缩性和可靠性。</p><p id="6e37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以通过在项目根目录下创建一个新目录来设置 nginx，并使用以下内容创建一个 docker 文件:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="59aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将下拉<a class="ae mi" href="https://hub.docker.com/_/nginx/" rel="noopener ugc nofollow" target="_blank"> nginx Docker 映像</a>并将<code class="fe nj nk nl na b">nginx.conf</code>复制到 Docker 容器中。</p><p id="4526" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nj nk nl na b">nginx.conf</code>是我们可以配置 nginx 服务器的文件，如下所示:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="ebbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中的主要部分是，我们以秒为单位设置 keepalive_time out，并告诉我们的代理监听端口 80 (http)并返回端口为 8000 的 localhost。</p><h1 id="9ea7" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">将它整合在一起</h1><p id="28ba" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们现在有了一个非常好的 Flask API/网站的材料。真的只有最后一件事要做了。</p><p id="b1a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们有多个 Docker 容器，所以我们需要一种方法来运行它们，并指定它们如何相互交互。这就是<a class="ae mi" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> Docker Compose </a>的用武之地。</p><blockquote class="np nq nr"><p id="34cf" class="jy jz ns ka b kb kc kd ke kf kg kh ki nt kk kl km nu ko kp kq nv ks kt ku kv ij bi translated">Compose 是一个定义和运行多容器 Docker 应用程序的工具。</p></blockquote><p id="461f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从 Docker 的网站上我们可以看到，使用 Docker Compose 有三个步骤:</p><ol class=""><li id="1216" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv nm mf mg mh bi translated">用一个<code class="fe nj nk nl na b">Dockerfile</code>来定义你的应用环境，这样它可以在任何地方被复制。</li><li id="0250" class="lz ma iq ka b kb mj kf mk kj ml kn mm kr mn kv nm mf mg mh bi translated">在<code class="fe nj nk nl na b">docker-compose.yml</code>中定义组成您的应用的服务，以便它们可以在一个隔离的环境中一起运行。</li><li id="536f" class="lz ma iq ka b kb mj kf mk kj ml kn mm kr mn kv nm mf mg mh bi translated">运行<code class="fe nj nk nl na b">docker-compose up</code>，Compose 开始运行你的整个应用。</li></ol><p id="998d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经完成了第一步，所以现在我们可以安全地进入第二步。</p><p id="7dc3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的<code class="fe nj nk nl na b">docker-compose.yml</code>文件看起来像这样:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="bfe9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于这个文件有一些事情需要注意。</p><p id="99fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">服务:</strong>这是我们指定个人 Docker 容器的地方，首先是我们的 API，然后是我们的 nginx。</p><p id="52d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ns"> build: </em>指 Dockerfile 相对于 docker-compose.yml 文件的位置。</p><p id="0838" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ns">命令:</em>允许您指定运行该服务所需的命令。对于我们的 API，我们没有在 docker 文件中运行 Flask 应用程序，所以我们在这里使用 gunicorn 来运行它。</p><p id="8d7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">值得注意的是，我们将端口绑定到 8000，因此它与<code class="fe nj nk nl na b">nginx.conf.</code>中指定的位置相匹配</p><p id="df5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我强烈建议你在这里阅读更多关于 Docker 和 Docker Compose 的内容。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="6304" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们找到了。我们现在已经配置了 nginx，对接了我们的 Flask 应用程序，并使用 Docker Compose 将其整合在一起。</p><p id="1d1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您现在应该能够简单地输入<code class="fe nj nk nl na b">docker-compose up</code>并且您的服务器应该启动了。</p></div></div>    
</body>
</html>