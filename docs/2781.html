<html>
<head>
<title>How to extend a canned TensorFlow Estimator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何扩展固定张量流估计量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-extend-a-canned-tensorflow-estimator-to-add-more-evaluation-metrics-and-to-pass-through-ddf66cd3047d?source=collection_archive---------6-----------------------#2018-03-04">https://towardsdatascience.com/how-to-extend-a-canned-tensorflow-estimator-to-add-more-evaluation-metrics-and-to-pass-through-ddf66cd3047d?source=collection_archive---------6-----------------------#2018-03-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8bea" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">或者在使用固定评估器时，如何添加更多的评估指标并传递实例键</h2></div><p id="bfea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像DNNRegressor和DNNLinearCombinedRegressor这样的预构建的(“封装的”)估算器使编写TensorFlow程序变得简单。例如，下面是一个完整的TensorFlow程序，用于从内存中的Pandas数据帧开始训练TensorFlow模型:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="1729" class="lk ll iq lg b gy lm ln l lo lp">import tensorflow as tf</span><span id="c795" class="lk ll iq lg b gy lq ln l lo lp">featcols = [<br/>  tf.feature_column.numeric_column("sq_footage")<br/>]<br/>model = tf.estimator.LinearRegressor(featcols, './model_trained')</span><span id="1231" class="lk ll iq lg b gy lq ln l lo lp">def train_input_fn(df, num_epochs):  # a Pandas dataframe<br/>  return tf.estimator.inputs.pandas_input_fn(<br/>    x = df,<br/>    y = df['price'],<br/>    num_epochs=num_epochs)</span><span id="c2f7" class="lk ll iq lg b gy lq ln l lo lp">model.train(train_input_fn(df,100), steps=1000)</span></pre><p id="a77d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想像scikit-learn一样使用TensorFlow，代码行数也差不多。</p><h2 id="1108" class="lk ll iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">稳健估计量</h2><p id="bd93" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">然而，实际上，你想要比这更健壮。你想要读取不完全适合内存的分片文件，批处理它们，等等。这涉及到在您的<a class="ae mn" href="https://github.com/GoogleCloudPlatform/training-data-analyst/blob/master/courses/machine_learning/deepdive/03_tensorflow/taxifare/trainer/model.py#L37" rel="noopener ugc nofollow" target="_blank">输入函数</a>中使用TensorFlow中的数据集API的更多代码。当你训练的时候，你需要时不时的检查和评估。所以，你不要只叫train，你要叫<a class="ae mn" href="https://cloud.google.com/blog/big-data/2018/02/easy-distributed-training-with-tensorflow-using-tfestimatortrain-and-evaluate-on-cloud-ml-engine" rel="noopener ugc nofollow" target="_blank"> train_and_evaluate </a>。</p><p id="763d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">预构建的评估者非常简单，但也非常固执——他们选择一种特定的做事方式，并给你一堆现成的东西。如果你想要更大的灵活性？好吧，写一个自定义估算器(<a class="ae mn" href="https://medium.com/google-cloud/how-to-do-time-series-prediction-using-rnns-and-tensorflow-and-cloud-ml-engine-2ad2eeb189e8" rel="noopener">见例</a>)！</p><p id="ff7c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但两者之间存在灰色地带。您可以使用固定的估计器，并且仍然可以获得一定的灵活性。怎么会？使用<a class="ae mn" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/estimator/python/estimator/extenders.py" rel="noopener ugc nofollow" target="_blank"> extenders.py </a>中的功能。在这篇博文中，我将向您展示两种这样的能力(顺便提一下，这是两个非常<a class="ae mn" href="https://github.com/GoogleCloudPlatform/cloudml-samples/issues/67" rel="noopener ugc nofollow" target="_blank">常见的</a>问题)。</p><figure class="lb lc ld le gt mp gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/4db89018f68f40442934184c9a206024.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*wIlFAEJpkAKPIp7iBqWygA.jpeg"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">You can extend a canned estimator too!</figcaption></figure><h2 id="85cc" class="lk ll iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">如何添加额外的评估指标</h2><p id="6329" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">当您使用DNNRegressor时，作为评估循环一部分的度量只有average_loss，在本例中恰好是RMSE。但是如果您想要更多的度量标准呢？简单地用<em class="mw"> add_metrics </em>包装估算器，如下所示:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="2fa7" class="lk ll iq lg b gy lm ln l lo lp">def my_rmse(labels, predictions):<br/>    pred_values = predictions['predictions']<br/>    return {'rmse': tf.metrics.root_mean_squared_error(labels, pred_values)}</span><span id="8e8b" class="lk ll iq lg b gy lq ln l lo lp">def train_and_evaluate(output_dir):<br/>    <br/>    estimator = tf.estimator.DNNLinearCombinedRegressor(<br/>        ...)<br/>    <br/>    estimator = tf.contrib.estimator.add_metrics(estimator, my_rmse)  <br/>    ...</span><span id="24fc" class="lk ll iq lg b gy lq ln l lo lp">    tf.estimator.train_and_evaluate(estimator, train_spec, eval_spec)</span></pre><p id="775e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们稍微解释一下:</p><ol class=""><li id="41bd" class="mx my iq kh b ki kj kl km ko mz ks na kw nb la nc nd ne nf bi translated">编写一个函数，根据标签和预测值计算感兴趣的指标，并返回一个字典。</li><li id="5cad" class="mx my iq kh b ki ng kl nh ko ni ks nj kw nk la nc nd ne nf bi translated">将该函数与您的原始估算器一起传递给add_metrics</li><li id="7df4" class="mx my iq kh b ki ng kl nh ko ni ks nj kw nk la nc nd ne nf bi translated">从该点开始使用返回的估计量</li></ol><p id="6795" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，上面的<em class="mw"> my_rmse </em>方法接收标签和整个预测张量。这样，如果您正在进行分类，并且您的一些指标需要预测的类，而其他指标需要预测的概率，您可以计算您想要的。</p><p id="5930" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里看到一个<a class="ae mn" href="https://github.com/GoogleCloudPlatform/training-data-analyst/blob/master/courses/machine_learning/deepdive/07_structured/babyweight/trainer/model.py#L127" rel="noopener ugc nofollow" target="_blank">完整的例子</a>。</p><h2 id="3ddd" class="lk ll iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">如何将键和输入特征转发到输出</h2><p id="9fa7" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">由固定估计器返回的预测dict中只有预测(咄！).但是，在很多情况下，您希望预测也包含一些输入。例如，您可能有一个与每一行相关联的唯一键，并且您希望该键成为预测的一部分，以便您知道预测对应于哪一行。或者，您可能希望根据特定的输入值来计算评估(例如，根据婴儿是早产还是足月来计算婴儿体重的RMSE)。</p><p id="a6f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，用forward_features包装估计器，如下所示:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="1b52" class="lk ll iq lg b gy lm ln l lo lp">estimator = tf.contrib.estimator.forward_features(estimator, KEY_COLUMN)</span></pre><p id="e0f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以传入一个单独的字符串(就像我上面做的那样)或者一个字符串列表。理想情况下，这就是你所需要的。然而，有两个警告。</p><p id="c657" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个警告是，上面的键列被添加到预测的输出中，但没有添加到导出签名中，因此当模型在内存中时它可以工作，但如果在训练后恢复，它就不能工作(这没有意义:我已经向TensorFlow repo提交了一个pull请求来解决这个问题)。在那之前，你需要这个<a class="ae mn" href="https://github.com/GoogleCloudPlatform/training-data-analyst/blob/master/courses/machine_learning/deepdive/07_structured/babyweight/trainer/model.py#L132" rel="noopener ugc nofollow" target="_blank">解决方案</a>:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="604a" class="lk ll iq lg b gy lm ln l lo lp">def forward_key_to_export(estimator):<br/>    estimator = tf.contrib.estimator.forward_features(estimator, KEY_COLUMN)<br/>    # return estimator</span><span id="56ef" class="lk ll iq lg b gy lq ln l lo lp">## This shouldn't be necessary (I've filed CL/187793590 to update extenders.py with this code)<br/>    config = estimator.config<br/>    def model_fn2(features, labels, mode):<br/>      estimatorSpec = estimator._call_model_fn(features, labels, mode, config=config)<br/>      if estimatorSpec.export_outputs:<br/>        for ekey in ['predict', 'serving_default']:<br/>          estimatorSpec.export_outputs[ekey] = \<br/>            tf.estimator.export.PredictOutput(estimatorSpec.predictions)<br/>      return estimatorSpec<br/>    return tf.estimator.Estimator(model_fn=model_fn2, config=config)<br/>    ##</span></pre><p id="a932" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个警告是，你不能既传递一个特征*又*把它作为模型的输入。要么消费输入，要么传递输入。这里的解决方法是使用tf.identity在输入函数中复制这样的列:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="92d9" class="lk ll iq lg b gy lm ln l lo lp">features['gw'] = tf.identity(features['gestation_weeks'])</span></pre><p id="ebd8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望这有所帮助！</p></div></div>    
</body>
</html>