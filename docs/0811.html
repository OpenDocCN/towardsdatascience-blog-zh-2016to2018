<html>
<head>
<title>How to deploy Machine Learning models with TensorFlow. Part 1 — make your model ready for serving.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用 TensorFlow 部署机器学习模型？第 1 部分—准备好您的模型以供使用。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-deploy-machine-learning-models-with-tensorflow-part-1-make-your-model-ready-for-serving-776a14ec3198?source=collection_archive---------0-----------------------#2017-06-24">https://towardsdatascience.com/how-to-deploy-machine-learning-models-with-tensorflow-part-1-make-your-model-ready-for-serving-776a14ec3198?source=collection_archive---------0-----------------------#2017-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/babf5c6b2ff64fa53d0bc21adfdb3af8.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/format:webp/1*qVY47Qtrl8CLT1aXGRM42Q.jpeg"/></div></figure></div><div class="ab cl ju jv hu jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ij ik il im in"><p id="1de2" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">在完成 Udacity 的深度学习基础课程后，我有一个大问题——我如何部署训练好的模型并对新的数据样本进行预测？幸运的是，TensorFlow 是为生产开发的，它为模型部署提供了解决方案— <a class="ae kz" href="https://tensorflow.github.io/serving/" rel="noopener ugc nofollow" target="_blank"> TensorFlow 服务</a>。基本上，有三个步骤——导出你的服务模型，用你的模型创建一个<a class="ae kz" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>容器，并用<a class="ae kz" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>将其部署到云平台，即谷歌云或亚马逊 AWS。在本文中，我主要关注第一部分——导出服务模型。</p><h1 id="db9a" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">动机和工具</h1><p id="012b" class="pw-post-body-paragraph kb kc iq kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky ij bi translated">在 Udacity 的课程中，我总是问自己——我有我的模型，我可以在 Jupyter 笔记本上运行它并看到结果，但我能用它做什么呢？其他人如何使用它？</p><p id="cc36" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">作为一名软件工程师，我对管道感兴趣:创建模型-&gt;在本地测试它-&gt;创建 web 服务来服务客户端请求-&gt;创建包含我的 web 服务的部署容器-&gt;测试容器-&gt;将其投入生产。我的问题的答案是:</p><ul class=""><li id="1256" class="md me iq kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">用于模型创建的 TensorFlow</li><li id="d459" class="md me iq kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">集装箱码头工人</li><li id="6bd1" class="md me iq kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">为模型托管服务的 TensorFlow</li><li id="e637" class="md me iq kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">用于生产部署的 Kubernetes</li></ul><h2 id="1455" class="mr lb iq bd lc ms mt dn lg mu mv dp lk km mw mx lo kq my mz ls ku na nb lw nc bi translated">张量流</h2><p id="4674" class="pw-post-body-paragraph kb kc iq kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky ij bi translated"><a class="ae kz" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>是一个开源库，用于开发机器学习，尤其是深度学习模型。它是由 Google 创建和支持的，不仅面向学术界，也面向产品开发。</p><h2 id="73fc" class="mr lb iq bd lc ms mt dn lg mu mv dp lk km mw mx lo kq my mz ls ku na nb lw nc bi translated">码头工人</h2><p id="d53f" class="pw-post-body-paragraph kb kc iq kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky ij bi translated">Docker 是一个非常流行的容器化引擎，它提供了一种便捷的方式来将所有依赖项打包在一起，以便部署在本地或云中。<a class="ae kz" href="https://docs.docker.com/" rel="noopener ugc nofollow" target="_blank">文档</a>非常全面，我鼓励你查看它的细节。</p><h2 id="5811" class="mr lb iq bd lc ms mt dn lg mu mv dp lk km mw mx lo kq my mz ls ku na nb lw nc bi translated">张量流服务</h2><p id="e734" class="pw-post-body-paragraph kb kc iq kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky ij bi translated">TensorFlow Serving，顾名思义，托管模型并提供对它的远程访问。TensorFlow Serving 有关于其<a class="ae kz" href="https://tensorflow.github.io/serving/architecture_overview" rel="noopener ugc nofollow" target="_blank">架构</a>的良好文档和有用的教程。不幸的是，他们使用准备好的例子，并得到一点解释，你需要做什么来为你自己的模型服务。</p><h2 id="c0ed" class="mr lb iq bd lc ms mt dn lg mu mv dp lk km mw mx lo kq my mz ls ku na nb lw nc bi translated">库伯内特斯</h2><p id="d76b" class="pw-post-body-paragraph kb kc iq kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky ij bi translated">Kubernetes 是一个开源软件，也是由谷歌开发的，它提供容器编排，允许你自动水平扩展、服务发现、负载平衡等等。简而言之，它自动化了云中 web 服务的管理。</p><h1 id="10e2" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">目的</h1><p id="857a" class="pw-post-body-paragraph kb kc iq kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky ij bi translated">作为一个例子，我采用了一个用于半监督学习的<a class="ae kz" href="https://github.com/udacity/deep-learning/tree/master/semi-supervised" rel="noopener ugc nofollow" target="_blank"> GAN 模型</a>，它在 Udacity 深度学习基础课程中讲授。我的意图是:</p><ul class=""><li id="6cae" class="md me iq kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">在<a class="ae kz" href="http://ufldl.stanford.edu/housenumbers/" rel="noopener ugc nofollow" target="_blank">街景门牌号</a>数据集上训练 GAN 模型进行半监督学习</li><li id="fe82" class="md me iq kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">使用 GAN 鉴别器进行门牌号预测。作为输出，我希望有 10 个分数，对应于从 0 到 9 的数字。</li><li id="c70b" class="md me iq kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">让 TensorFlow 在 Docker 容器中为我的模型提供服务</li><li id="ae84" class="md me iq kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">创建一个客户端来请求数字图像的分数</li><li id="58e3" class="md me iq kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">将模型部署到云中</li></ul><h1 id="138f" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">模型准备</h1><p id="d975" class="pw-post-body-paragraph kb kc iq kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky ij bi translated">基于<a class="ae kz" href="https://github.com/udacity/deep-learning/blob/master/semi-supervised/semi-supervised_learning_2_solution.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter 笔记本</a>，我将功能放入独立的 Python 文件中，测试保存的模型，实现模型导出和服务请求的客户端。一般来说，基本代码保持不变。你可以在我的<a class="ae kz" href="https://github.com/Vetal1977/tf_serving_example" rel="noopener ugc nofollow" target="_blank"> GitHub 库</a>中找到实现细节。</p><p id="5f34" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">主要步骤是:</p><ul class=""><li id="9fb1" class="md me iq kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated"><a class="ae kz" href="https://github.com/Vetal1977/tf_serving_example/blob/master/svnh_semi_supervised_model_train.py" rel="noopener ugc nofollow" target="_blank">训练模型</a>保存磁盘上的检查点</li><li id="ff05" class="md me iq kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated"><a class="ae kz" href="https://github.com/Vetal1977/tf_serving_example/blob/master/svnh_semi_supervised_model_loaded_test.py" rel="noopener ugc nofollow" target="_blank">加载保存的模型</a>并测试其工作是否正常</li><li id="b7fc" class="md me iq kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated"><a class="ae kz" href="https://github.com/Vetal1977/tf_serving_example/blob/master/svnh_semi_supervised_model_saved.py" rel="noopener ugc nofollow" target="_blank">将模型</a>导出为 Protobuf 格式(详情如下)</li><li id="e08f" class="md me iq kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated"><a class="ae kz" href="https://github.com/Vetal1977/tf_serving_example/blob/master/svnh_semi_supervised_client.py" rel="noopener ugc nofollow" target="_blank">创建客户端</a>来发布请求(细节在下一部分)</li></ul><p id="c527" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">对于使用 TensorFlow 创建深度学习模型的任何人来说，前两步都非常容易，我不想在这里详细介绍。但是最后两步对我来说很新，我花了一些时间来理解它是如何工作的以及需要什么。</p><h1 id="93de" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">TensorFlow 服务。这是什么？</h1><p id="f4e9" class="pw-post-body-paragraph kb kc iq kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky ij bi translated">TensorFlow Serving 实现了一个运行机器学习模型的服务器，并提供对它们的远程访问。常见的任务是对提供的数据(例如图像)进行预测和分类。</p><p id="ce35" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">几个技术亮点:</p><ul class=""><li id="0a26" class="md me iq kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">服务器实现了一个<a class="ae kz" href="http://www.grpc.io/" rel="noopener ugc nofollow" target="_blank"> gRPC </a>接口，所以您不能从浏览器发出请求。相反，我们需要创建一个客户机，它可以通过 gRPC 进行通信</li><li id="bd51" class="md me iq kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">TensorFlow Serving 已经提供了对存储为<a class="ae kz" href="https://github.com/google/protobuf" rel="noopener ugc nofollow" target="_blank"> Protobuf </a>的模型的操作</li><li id="57e3" class="md me iq kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">您可以创建自己的实现来处理以其他格式存储的模型</li></ul><p id="d5e7" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">我没有创建自己的实现，所以我需要将我的模型导出到 Protobuf 中。</p><h2 id="2485" class="mr lb iq bd lc ms mt dn lg mu mv dp lk km mw mx lo kq my mz ls ku na nb lw nc bi translated">原蟾蜍</h2><p id="591f" class="pw-post-body-paragraph kb kc iq kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky ij bi translated">协议缓冲区(或 Protobuf)允许高效的数据序列化。它是一个开源软件，是由谷歌开发的</p><h1 id="3451" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">将模型导出到 Protobuf 中</h1><p id="3d71" class="pw-post-body-paragraph kb kc iq kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky ij bi translated">TensorFlow Serving 提供了<a class="ae kz" href="https://www.tensorflow.org/api_docs/python/tf/saved_model/builder/SavedModelBuilder" rel="noopener ugc nofollow" target="_blank"> SavedModelBuild </a>类将模型保存为 Protobuf。这里描述的<a class="ae kz" href="https://tensorflow.github.io/serving/serving_basic.html" rel="noopener ugc nofollow" target="_blank">还不错</a>。</p><p id="fa05" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">我的 GAN 模型接受形状为<em class="nd">【batch _ num，width，height，channels】</em>的图像张量，其中批次数量为 1(您一次只能预测一个图像)，宽度和高度为 32 像素，图像通道数量为 3。输入图像必须缩放，以使每个像素在[-1，1]的范围内，而不是在[0，255]的范围内。</p><p id="6b26" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">另一方面，被服务的模型必须接受 JPEG 图像作为输入，因此为了服务，我需要注入层来将 JPEG 转换成所需的图像张量。</p><p id="0e6f" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">首先，我实现了图像转换。对我来说有点棘手。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="dc21" class="mr lb iq nj b gy nn no l np nq">serialized_tf_example = tf.placeholder(<br/>                            tf.string, name=’input_image’) </span><span id="5260" class="mr lb iq nj b gy nr no l np nq">feature_configs = { ‘image/encoded’: tf.FixedLenFeature(<br/>                                         shape=[], <br/>                                         dtype=tf.string), } </span><span id="ff92" class="mr lb iq nj b gy nr no l np nq">tf_example = tf.parse_example(serialized_tf_example, feature_configs) </span><span id="459c" class="mr lb iq nj b gy nr no l np nq">jpegs = tf_example[‘image/encoded’] </span><span id="bf31" class="mr lb iq nj b gy nr no l np nq">images = tf.map_fn(preprocess_image, jpegs, dtype=tf.float32) </span><span id="c783" class="mr lb iq nj b gy nr no l np nq">images = tf.squeeze(images, [0])<br/># now the image shape is (1, ?, ?, 3)</span></pre><p id="8d4f" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">基本上，您需要一个序列化传入图像的占位符、一个特性配置(字典名称到特性)和特性类型，其中您列出了预期的输入(在我的例子中是 JPEG 的<em class="nd">图像/编码的</em>)。然后解析序列化的示例并从中提取 JPEG。最后一步是将 JPEG 转换成所需的图像张量。实现细节见 my<a class="ae kz" href="https://github.com/Vetal1977/tf_serving_example/blob/master/svnh_semi_supervised_model_saved.py" rel="noopener ugc nofollow" target="_blank">GitHub</a>(<em class="nd">预处理 _ 图像</em>方法)。</p><p id="4232" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">然后，我可以使用该图像张量作为我的 GAN 模型的输入，创建一个会话对象并加载保存的检查点。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="4769" class="mr lb iq nj b gy nn no l np nq">......<br/>net = GAN(images, z_size, learning_rate, drop_rate=0.)<br/>......</span><span id="195d" class="mr lb iq nj b gy nr no l np nq">saver = tf.train.Saver() </span><span id="3333" class="mr lb iq nj b gy nr no l np nq">with tf.Session() as sess: <br/>    # Restore the model from last checkpoints <br/>    ckpt = tf.train.get_checkpoint_state(FLAGS.checkpoint_dir)    <br/>    saver.restore(sess, ckpt.model_checkpoint_path)<br/>......</span></pre><p id="d799" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">对我来说，下一个挑战是理解如何用提供的 SavedModelBuilder 将恢复的模型转换成 Protobuf。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="59e0" class="mr lb iq nj b gy nn no l np nq">builder = tf.saved_model.builder.SavedModelBuilder(export_path)</span></pre><p id="8cff" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">你必须创建一个所谓的带有输入、输出和方法名的签名(例如分类或预测)。TensorFlow 提供了一个方法<em class="nd">TF . saved _ model . utils . build _ tensor _ info</em>来创建张量信息。我用它来定义输入和输出(在我的例子中是分数)。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="8797" class="mr lb iq nj b gy nn no l np nq">predict_tensor_inputs_info = \<br/>    tf.saved_model.utils.build_tensor_info(jpegs) </span><span id="4a8f" class="mr lb iq nj b gy nr no l np nq">predict_tensor_scores_info = \<br/>    tf.saved_model.utils.build_tensor_info(net.discriminator_out)</span></pre><p id="b589" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">现在我准备好创建签名了。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="9917" class="mr lb iq nj b gy nn no l np nq">prediction_signature = (<br/>    tf.saved_model.signature_def_utils.build_signature_def( <br/>        inputs={‘images’: predict_tensor_inputs_info}, <br/>        outputs={‘scores’: predict_tensor_scores_info},<br/>        method_name=\<br/>            tf.saved_model.signature_constants.PREDICT_METHOD_NAME)</span></pre><p id="baea" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated"><em class="nd">【图像】</em>和<em class="nd">【分数】</em>是预定义的名称，您必须在输入和输出词典中使用它们。</p><p id="86bd" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">在<a class="ae kz" href="https://tensorflow.github.io/serving/serving_inception" rel="noopener ugc nofollow" target="_blank">教程</a>中，TensorFlow 团队创建了两个签名——一个用于分类，一个用于预测。我不想要任何分类结果，所以预测签名对我来说就足够了。</p><p id="b02f" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">最后一步—保存模型。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="4ed5" class="mr lb iq nj b gy nn no l np nq">legacy_init_op = tf.group(tf.tables_initializer(), <br/>                          name=’legacy_init_op’) </span><span id="48e0" class="mr lb iq nj b gy nr no l np nq">builder.add_meta_graph_and_variables(<br/>    sess, <br/>    [tf.saved_model.tag_constants.SERVING], <br/>    signature_def_map={ ‘predict_images’: prediction_signature }, <br/>    legacy_init_op=legacy_init_op) </span><span id="d60c" class="mr lb iq nj b gy nr no l np nq">builder.save()</span></pre><p id="ff75" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">这非常简单，现在您已经将模型存储为 Protobuf。导出文件夹的结构应该类似于:</p><ul class=""><li id="c3ec" class="md me iq kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated"><em class="nd"> variables </em>文件夹，带有<em class="nd">variables . data-XXX-of-yyy</em>和<em class="nd"> variables.index </em></li><li id="c955" class="md me iq kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated"><em class="nd"> saved_model.pb </em>文件</li></ul><p id="b26c" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">第一部分工作已经完成——模型被成功导出为 Protobuf。</p><h1 id="8398" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">把它们放在一起</h1><h2 id="eb60" class="mr lb iq bd lc ms mt dn lg mu mv dp lk km mw mx lo kq my mz ls ku na nb lw nc bi translated">环境</h2><p id="85fe" class="pw-post-body-paragraph kb kc iq kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky ij bi translated">我在以下环境中进行了开发和测试:</p><ul class=""><li id="0480" class="md me iq kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">基于 GPU 的电脑(英伟达 GeForce GTX 1060 6 GB)</li><li id="6877" class="md me iq kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">Ubuntu 16.04</li><li id="47f8" class="md me iq kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">蟒蛇</li><li id="66f4" class="md me iq kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">Python 3.5</li><li id="0403" class="md me iq kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">张量流 1.8</li></ul><h2 id="8391" class="mr lb iq bd lc ms mt dn lg mu mv dp lk km mw mx lo kq my mz ls ku na nb lw nc bi translated">你自己试试</h2><p id="4ba9" class="pw-post-body-paragraph kb kc iq kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky ij bi translated">下面是您自己尝试时需要执行的步骤。</p><ul class=""><li id="7a88" class="md me iq kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">克隆源</li></ul><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="4593" class="mr lb iq nj b gy nn no l np nq">cd ~</span><span id="2469" class="mr lb iq nj b gy nr no l np nq">git clone <a class="ae kz" href="https://github.com/Vetal1977/tf_serving_example.git" rel="noopener ugc nofollow" target="_blank">https://github.com/Vetal1977/tf_serving_example.git</a></span><span id="1bc4" class="mr lb iq nj b gy nr no l np nq">cd tf_serving_example</span></pre><ul class=""><li id="a3ff" class="md me iq kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">训练模型</li></ul><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="10f7" class="mr lb iq nj b gy nn no l np nq">python svnh_semi_supervised_model_train.py</span></pre><p id="dcff" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">下载列车和测试街景门牌号码数据集和另一个 ca 大约需要 5-10 分钟。20 分钟训练模型(在我的环境下)。</p><ul class=""><li id="a75a" class="md me iq kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">检查您是否保存了模型</li></ul><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="33cc" class="mr lb iq nj b gy nn no l np nq">ls ./checkpoints</span></pre><p id="f206" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">您应该会看到数据、索引和元数据文件。</p><ul class=""><li id="6c1c" class="md me iq kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">将模型导出到 Protobuf，由 TensorFlow 提供服务</li></ul><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="1f46" class="mr lb iq nj b gy nn no l np nq">python svnh_semi_supervised_model_saved.py --checkpoint-dir=./checkpoints --output_dir=./gan-export --model-version=1</span></pre><p id="b2ef" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">应该打印出以下内容</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="d9dd" class="mr lb iq nj b gy nn no l np nq">Successfully exported GAN model version '1' into './gan-export'</span></pre><p id="c363" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">如果你打字</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="88c9" class="mr lb iq nj b gy nn no l np nq">ls ./gan-export/1</span></pre><p id="3fbf" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">你应该得到<em class="nd">变量</em>文件夹和<em class="nd"> saved_model.pb </em>文件。</p><h1 id="cd94" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">而不是结论</h1><p id="eadd" class="pw-post-body-paragraph kb kc iq kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky ij bi translated">可能这听起来很简单，但我需要几个小时来理解 TensorFlow 如何为模型服务。我有什么输入和输出。我如何注册他们让 TensorFlow 知道，什么和如何服务。</p><p id="fa94" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">在下一部分中，我将创建一个 Docker 容器，将我的模型放入其中，并创建一个客户端来发出请求。</p></div></div>    
</body>
</html>