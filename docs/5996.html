<html>
<head>
<title>How to Train an Image Classifier in PyTorch and use it to Perform Basic Inference on Single Images</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 PyTorch 中训练一个图像分类器，并使用它对单幅图像进行基本推理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-train-an-image-classifier-in-pytorch-and-use-it-to-perform-basic-inference-on-single-images-99465a1e9bf5?source=collection_archive---------2-----------------------#2018-11-20">https://towardsdatascience.com/how-to-train-an-image-classifier-in-pytorch-and-use-it-to-perform-basic-inference-on-single-images-99465a1e9bf5?source=collection_archive---------2-----------------------#2018-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6293" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用自己的图像训练 ResNet 的教程</h2></div><p id="d715" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你刚刚开始使用 PyTorch，并且想学习如何做一些基本的图像分类，你可以遵循这个教程。它将介绍如何组织您的训练数据，使用预训练的神经网络来训练您的模型，然后预测其他图像。</p><p id="27c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我将使用一个由 Google Maps 地图切片组成的数据集，并根据它们包含的地形特征对它们进行分类。我将写另一个关于我如何使用它的故事(简而言之:为了识别无人机飞越或着陆的安全区域)。但是现在，我只想使用一些训练数据来对这些地图分块进行分类。</p><p id="e442" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的代码片段来自 Jupyter 笔记本。你可以将它们组合在一起构建你自己的 Python 脚本，或者从 GitHub 下载笔记本。这些笔记本最初是基于 Udacity 的 PyTorch 课程。如果你使用云虚拟机进行深度学习开发，并且不知道如何远程打开笔记本，请查看<a class="ae lb" href="https://medium.com/@chrisfotache/how-to-connect-to-your-cloud-hosted-ipython-jupyter-notebook-from-your-local-windows-machine-1426f1dafec2" rel="noopener">我的教程</a>。</p><p id="446a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">组织你的训练数据集</strong></p><p id="d91e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">PyTorch 希望数据按文件夹组织，每个类一个文件夹。大多数其他 PyTorch 教程和示例希望您进一步组织它，在顶部有一个 training and validation 文件夹，然后在其中有 class 文件夹。但我认为这非常麻烦，必须从每个类中挑选一定数量的图像，并将它们从训练文件夹移动到验证文件夹。因为大多数人会选择一组连续的文件，所以在选择时可能会有很多偏差。</p><p id="04bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，有一种更好的方法可以将数据集动态拆分为训练集和测试集，就像 Python 开发人员习惯的 SKLearn 一样。但是首先，让我们导入模块:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="d9d1" class="ll lm iq lh b gy ln lo l lp lq">%matplotlib inline<br/>%config InlineBackend.figure_format = 'retina'<br/>import matplotlib.pyplot as plt</span><span id="505c" class="ll lm iq lh b gy lr lo l lp lq">import numpy as np<br/>import torch<br/>from torch import nn<br/>from torch import optim<br/>import torch.nn.functional as F<br/>from torchvision import datasets, transforms, models</span></pre><p id="58f7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将定义训练/验证数据集加载器，使用 SubsetRandomSampler 进行拆分:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="2b83" class="ll lm iq lh b gy ln lo l lp lq">data_dir = '/data/train'</span><span id="2236" class="ll lm iq lh b gy lr lo l lp lq">def load_split_train_test(datadir, valid_size = .2):<br/>    train_transforms = transforms.Compose([transforms.Resize(224),<br/>                                       transforms.ToTensor(),<br/>                                       ])</span><span id="ce50" class="ll lm iq lh b gy lr lo l lp lq">    test_transforms = transforms.Compose([transforms.Resize(224),<br/>                                      transforms.ToTensor(),<br/>                                      ])</span><span id="269a" class="ll lm iq lh b gy lr lo l lp lq">    train_data = datasets.ImageFolder(datadir,       <br/>                    transform=train_transforms)<br/>    test_data = datasets.ImageFolder(datadir,<br/>                    transform=test_transforms)</span><span id="8546" class="ll lm iq lh b gy lr lo l lp lq">    num_train = len(train_data)<br/>    indices = list(range(num_train))<br/>    split = int(np.floor(valid_size * num_train))<br/>    np.random.shuffle(indices)<br/>    from torch.utils.data.sampler import SubsetRandomSampler<br/>    train_idx, test_idx = indices[split:], indices[:split]<br/>    train_sampler = SubsetRandomSampler(train_idx)<br/>    test_sampler = SubsetRandomSampler(test_idx)<br/>    trainloader = torch.utils.data.DataLoader(train_data,<br/>                   sampler=train_sampler, batch_size=64)<br/>    testloader = torch.utils.data.DataLoader(test_data,<br/>                   sampler=test_sampler, batch_size=64)<br/>    return trainloader, testloader</span><span id="7104" class="ll lm iq lh b gy lr lo l lp lq">trainloader, testloader = load_split_train_test(data_dir, .2)<br/>print(trainloader.dataset.classes)</span></pre><p id="8471" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来我们来确定我们有没有 GPU。我假设如果你这样做，你有一个 GPU 驱动的机器，否则代码将至少慢 10 倍。但是概括和检查 GPU 的可用性是一个好主意。</p><p id="8296" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还将加载一个预训练模型。对于这个例子，我选择了 ResNet 50:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="4dac" class="ll lm iq lh b gy ln lo l lp lq">device = torch.device("cuda" if torch.cuda.is_available() <br/>                                  else "cpu")<br/>model = models.resnet50(pretrained=True)<br/>print(model)</span></pre><p id="1d31" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">打印模型将向您展示 ResNet 模型的层架构。这可能超出了你我的理解范围，但看看这些深藏的层里面是什么仍然很有趣。</p><p id="13b6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">选择哪种模型取决于您，并且可能会根据您的特定数据集而有所不同。这里列出了所有的<a class="ae lb" href="https://pytorch.org/docs/stable/torchvision/models.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> PyTorch 型号</strong> </a>。</p><p id="972b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们进入了深层神经网络的有趣部分。首先，我们必须冻结预训练的层，这样我们就不会在训练过程中反向穿透它们。然后，我们重新定义最终的完全连接的层，我们将使用我们的图像进行训练。我们还创建了标准(损失函数)并选择了优化器(在这种情况下是 Adam)和学习率。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="c6c8" class="ll lm iq lh b gy ln lo l lp lq">for param in model.parameters():<br/>    param.requires_grad = False<br/>    <br/>model.fc = nn.Sequential(nn.Linear(2048, 512),<br/>                                 nn.ReLU(),<br/>                                 nn.Dropout(0.2),<br/>                                 nn.Linear(512, 10),<br/>                                 nn.LogSoftmax(dim=1))<br/>criterion = nn.NLLLoss()<br/>optimizer = optim.Adam(model.fc.parameters(), lr=0.003)<br/>model.to(device)</span></pre><p id="07ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在最后，让我们训练我们的模型！在这个例子中只有一个纪元，但是在大多数情况下你需要更多。从代码来看，基本过程非常直观:加载成批图像并进行前馈循环。然后计算损失函数，并使用优化器在反向传播中应用梯度下降。</p><p id="7e11" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">PyTorch 就是这么简单。下面的大部分代码用于显示每 10 个批次的损失和计算准确度，因此您可以在训练过程中获得更新。在验证过程中，不要忘记将模型设置为 eval()模式，完成后再返回到 train()。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="5864" class="ll lm iq lh b gy ln lo l lp lq">epochs = 1<br/>steps = 0<br/>running_loss = 0<br/>print_every = 10<br/>train_losses, test_losses = [], []</span><span id="45ea" class="ll lm iq lh b gy lr lo l lp lq">for epoch in range(epochs):<br/>    for inputs, labels in trainloader:<br/>        steps += 1<br/>        inputs, labels = inputs.to(device), labels.to(device)<br/>        optimizer.zero_grad()<br/>        logps = model.forward(inputs)<br/>        loss = criterion(logps, labels)<br/>        loss.backward()<br/>        optimizer.step()<br/>        running_loss += loss.item()<br/>        <br/>        if steps % print_every == 0:<br/>            test_loss = 0<br/>            accuracy = 0<br/>            model.eval()<br/>            with torch.no_grad():<br/>                for inputs, labels in testloader:<br/>                    inputs, labels = inputs.to(device),<br/>                                      labels.to(device)<br/>                    logps = model.forward(inputs)<br/>                    batch_loss = criterion(logps, labels)<br/>                    test_loss += batch_loss.item()<br/>                    <br/>                    ps = torch.exp(logps)<br/>                    top_p, top_class = ps.topk(1, dim=1)<br/>                    equals = <br/>                        top_class == labels.view(*top_class.shape)<br/>                    accuracy +=<br/>                   torch.mean(equals.type(torch.FloatTensor)).item()<br/>            train_losses.append(running_loss/len(trainloader))<br/>            test_losses.append(test_loss/len(testloader))                    <br/>            print(f"Epoch {epoch+1}/{epochs}.. "<br/>                  f"Train loss: {running_loss/print_every:.3f}.. "<br/>                  f"Test loss: {test_loss/len(testloader):.3f}.. "<br/>                  f"Test accuracy: {accuracy/len(testloader):.3f}")<br/>            running_loss = 0<br/>            model.train()<br/>torch.save(model, 'aerialmodel.pth')</span></pre><p id="6499" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后…在您等待几分钟(或更长时间，取决于数据集的大小和历元数)后，训练完成，模型被保存以供以后的预测使用！</p><p id="90d0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在还有一件事你可以做，那就是绘制训练和验证损失图:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="a113" class="ll lm iq lh b gy ln lo l lp lq">plt.plot(train_losses, label='Training loss')<br/>plt.plot(test_losses, label='Validation loss')<br/>plt.legend(frameon=False)<br/>plt.show()</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ls"><img src="../Images/d00b2d1555224f83ac205b10dfd6b7d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u6TqKxB345fU4MpLTDGzOw.png"/></div></div></figure><p id="b4d7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，在我的一个时期的特定示例中，验证损失(这是我们感兴趣的)在第一个时期结束时趋于平缓，甚至开始上升趋势，因此 1 个时期可能就足够了。培训损失，正如预期的那样，非常低。</p><p id="302b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在进入第二部分。因此，您训练了您的模型，保存了它，并需要在应用程序中使用它。为此，您需要能够对图像进行简单的推断。您也可以在<a class="ae lb" href="https://github.com/cfotache/pytorch_imageclassifier" rel="noopener ugc nofollow" target="_blank">我们的资源库</a>中找到这款演示笔记本。我们导入与培训笔记本中相同的模块，然后再次定义转换。我只再次声明图像文件夹，这样我就可以使用其中的一些示例:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="e56e" class="ll lm iq lh b gy ln lo l lp lq">data_dir = '/datadrive/FastAI/data/aerial_photos/train'</span><span id="d591" class="ll lm iq lh b gy lr lo l lp lq">test_transforms = transforms.Compose([transforms.Resize(224),<br/>                                      transforms.ToTensor(),<br/>                                     ])</span></pre><p id="298a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们再次检查 GPU 可用性，加载模型并将其置于评估模式(因此参数不会改变):</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="cf83" class="ll lm iq lh b gy ln lo l lp lq">device = torch.device("cuda" if torch.cuda.is_available() else "cpu")<br/>model=torch.load('aerialmodel.pth')<br/>model.eval()</span></pre><p id="ad46" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">预测特定图像的类别的函数非常简单。注意，它需要一个枕头图像，而不是一个文件路径。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="6664" class="ll lm iq lh b gy ln lo l lp lq">def predict_image(image):<br/>    image_tensor = test_transforms(image).float()<br/>    image_tensor = image_tensor.unsqueeze_(0)<br/>    input = Variable(image_tensor)<br/>    input = input.to(device)<br/>    output = model(input)<br/>    index = output.data.cpu().numpy().argmax()<br/>    return index</span></pre><p id="45dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在为了更容易测试，我还创建了一个函数，它将从数据集文件夹中随机选取一些图像:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="43b6" class="ll lm iq lh b gy ln lo l lp lq">def get_random_images(num):<br/>    data = datasets.ImageFolder(data_dir, transform=test_transforms)<br/>    classes = data.classes<br/>    indices = list(range(len(data)))<br/>    np.random.shuffle(indices)<br/>    idx = indices[:num]<br/>    from torch.utils.data.sampler import SubsetRandomSampler<br/>    sampler = SubsetRandomSampler(idx)<br/>    loader = torch.utils.data.DataLoader(data, <br/>                   sampler=sampler, batch_size=num)<br/>    dataiter = iter(loader)<br/>    images, labels = dataiter.next()<br/>    return images, labels</span></pre><p id="62f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，为了演示预测功能，我获取随机图像样本，预测它们并显示结果:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="ac4d" class="ll lm iq lh b gy ln lo l lp lq">to_pil = transforms.ToPILImage()<br/>images, labels = get_random_images(5)<br/>fig=plt.figure(figsize=(10,10))<br/>for ii in range(len(images)):<br/>    image = to_pil(images[ii])<br/>    index = predict_image(image)<br/>    sub = fig.add_subplot(1, len(images), ii+1)<br/>    res = int(labels[ii]) == index<br/>    sub.set_title(str(classes[index]) + ":" + str(res))<br/>    plt.axis('off')<br/>    plt.imshow(image)<br/>plt.show()</span></pre><p id="4f2f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个在谷歌地图上预测的例子。标签是预测的类，我也显示它是否是一个正确的预测。</p><figure class="lc ld le lf gt lt gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/fa5207b76bfffa55e286000dfe4822a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*IxE51eVf2dZnsl0eW6nzWA.png"/></div></figure><p id="591e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">差不多就是这样了。继续在您的数据集上尝试。只要您正确地组织了您的图像，这段代码应该可以正常工作。很快我会有更多关于你可以用神经网络和 PyTorch 做的其他酷事情的故事。</p><p id="c2d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">克里斯·福塔什(Chris Fotache)是一名人工智能研究员，他在新泽西的 <a class="ae lb" href="http://www.cynet.ai" rel="noopener ugc nofollow" target="_blank"> <em class="mb"> CYNET.ai </em> </a> <em class="mb">工作。他涵盖了与我们生活中的人工智能、Python 编程、机器学习、计算机视觉、自然语言处理等相关的主题。</em></p></div></div>    
</body>
</html>