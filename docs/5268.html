<html>
<head>
<title>GenerativeAdversarialNetwork(GAN) in Android — tictactoe.ai (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android 中的生成对手网络(GAN)——TIC tactoe . ai(第二部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/generativeadversarialnetwork-gan-in-android-tictactoe-ai-part-2-70155c5ca55b?source=collection_archive---------9-----------------------#2018-10-07">https://towardsdatascience.com/generativeadversarialnetwork-gan-in-android-tictactoe-ai-part-2-70155c5ca55b?source=collection_archive---------9-----------------------#2018-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="031f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">生成对抗网络是一种深度网络，用于从随机数据生成图像。它包括两个不同的网络:发生器和鉴别器。鉴别器网络是一个标准的卷积神经网络，可以对输入的图像进行分类，类似于二项式分类器对图像进行真假分类的方式。生成器是一个逆卷积网络，它对随机噪声向量进行上采样以产生图像。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/5e1d4a2e81a46401dabbf5155998808e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cxnqsjXYP-lx-3afYsuxXQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">source: <a class="ae lb" href="https://skymind.ai/images/wiki/gan_schema.png" rel="noopener ugc nofollow" target="_blank">https://skymind.ai/images/wiki/gan_schema.png</a></figcaption></figure><p id="c4d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为鉴别者，你帮助生成者创建类似真实的图像。它有助于 GAN 的训练，因为它具有最小-最大损失函数。发生器使 log(1- D(G(z))) (z 是一个随机数据向量)最小，而鉴别器使输出 log(D(x)最大。(x 是一个真实的图像，你可以称之为地面真相，以生成一个图像)</p><p id="8b7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">训练 GAN 是一项艰巨的任务，因为两个网络都在努力减少其损耗。它们成反比；如果一个减少，另一个增加。我们必须适当地训练 GAN，给它们相等的迭代次数来训练。此外，检查生成的图像的输出，看看它是否正确。</p><h1 id="100a" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">GAN 在 tictactoe.ai 中有什么用？</h1><p id="6751" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">想到把这个游戏拿到单人玩，应该会有人为电脑端画图，于是想到引入两个不同的 gan 来生成 X 和 o。</p><h1 id="4c50" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">生成对抗网络</h1><p id="d832" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们只需要网络的发电机部分。</p><p id="be49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">定义输入和输出节点，并给它们指定名称。</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="2ea6" class="mk ld iq mg b gy ml mm l mn mo"><strong class="mg ir">input_node_name </strong>= 'noise_input_x'<br/><strong class="mg ir">output_node_name </strong>= 'gen_x'</span><span id="af2c" class="mk ld iq mg b gy mp mm l mn mo">gen_inp = tf.placeholder(tf.float32,shape=[None, noise_dim],name=<strong class="mg ir">input_node_name</strong>)<br/>disc_inp = tf.placeholder(tf.float32,shape= [None, img_dim])</span><span id="5af4" class="mk ld iq mg b gy mp mm l mn mo">def gen_fun(x,output_node_name):<br/>    h1 = tf.matmul(x,W["w1"])<br/>    h1 = tf.add(h1,b["b1"])<br/>    h1 = tf.nn.relu(h1)<br/>    <br/>    h1 = tf.matmul(h1,W["w2"])<br/>    h1 = tf.add(h1,b["b2"])<br/>    h1 = tf.nn.sigmoid(h1, name=<strong class="mg ir">output_node_name</strong>)<br/>    <br/>    return h1</span><span id="12e0" class="mk ld iq mg b gy mp mm l mn mo">def disc_fun(x):<br/>    h2 = tf.matmul(x,W["w3"])<br/>    h2 = tf.add(h2,b["b3"])<br/>    h2 = tf.nn.relu(h2)<br/>    <br/>    h2 = tf.matmul(h2,W["w4"])<br/>    h2 = tf.add(h2,b["b4"])<br/>    h2 = tf.nn.sigmoid(h2)<br/>    <br/>    return h2</span></pre><h1 id="6d1e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">培训产出</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/c66661ad6f3d5db74296965c2851254b.png" data-original-src="https://miro.medium.com/v2/resize:fit:418/format:webp/1*zdC4o6ZJuliO5dP4VAEpGA.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">generated image</figcaption></figure><h1 id="44c3" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">从图形中提取生成器</strong></h1><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="c524" class="mk ld iq mg b gy ml mm l mn mo">freeze_graph.freeze_graph('out/' + <strong class="mg ir">MODEL_NAME </strong>+ '.pbtxt', None, False,<br/>    'out/' + <strong class="mg ir">MODEL_NAME </strong>+ '.chkp', <strong class="mg ir">output_node_name</strong>, "save/restore_all",<br/>    "save/Const:0", 'out/frozen_' + <strong class="mg ir">MODEL_NAME </strong>+ '.pb', True, "")</span><span id="ca1f" class="mk ld iq mg b gy mp mm l mn mo">input_graph_def = tf.GraphDef()<br/>with tf.gfile.Open('out/frozen_' + <strong class="mg ir">MODEL_NAME </strong>+ '.pb', "rb") as f:<br/>    input_graph_def.ParseFromString(f.read())</span><span id="f957" class="mk ld iq mg b gy mp mm l mn mo"><strong class="mg ir">input_node_names = ['noise_input_x']</strong><br/>    <br/>output_graph_def = optimize_for_inference_lib.optimize_for_inference(<br/>        input_graph_def, <strong class="mg ir">input_node_names</strong>, [<strong class="mg ir">output_node_name</strong>],<br/>        tf.float32.as_datatype_enum)</span><span id="8e60" class="mk ld iq mg b gy mp mm l mn mo">with tf.gfile.FastGFile('out/opt_' + <strong class="mg ir">MODEL_NAME </strong>+ '.pb', "wb") as f:<br/>    f.write(output_graph_def.SerializeToString())</span></pre><p id="082b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于上面的代码，您将得到一个优化的发电机网络图</p><h1 id="ba1d" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">放在安卓系统里</h1><p id="5aa7" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">首先，在 Android 的资产文件夹中复制你的发电机优化图</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="436e" class="mk ld iq mg b gy ml mm l mn mo">private String MODEL_GAN_O = "file:///android_asset/opt_gan_O.pb";<br/>private String MODEL_GAN_X = "file:///android_asset/opt_gan_X.pb";</span><span id="60f0" class="mk ld iq mg b gy mp mm l mn mo">private void loadGANs(){<br/>        inferenceInterface_GAN_O = new TensorFlowInferenceInterface(getAssets(),MODEL_GAN_O);<br/>        inferenceInterface_GAN_X = new TensorFlowInferenceInterface(getAssets(),MODEL_GAN_X);<br/>}</span></pre><p id="dc24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要生成 O，我们必须将随机噪声向量传递给图</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="fa4a" class="mk ld iq mg b gy ml mm l mn mo">public int[] getGAN_O(){</span><span id="7006" class="mk ld iq mg b gy mp mm l mn mo"><strong class="mg ir">        // random noise input vector</strong>    <br/>        <strong class="mg ir">float [] noise_input = new float [100];<br/>        for(int i =0 ; i&lt;noise_input.length; i++){<br/>            float value = rand.nextFloat();<br/>            noise_input[i] = (value*2)-1;<br/>        }</strong><br/>        inferenceInterface_GAN_O.feed(INPUT_NODE_GAN_O, noise_input,1,100);<br/>        inferenceInterface_GAN_O.run(new String[]{OUTPUT_NODE_GAN_O},false);</span><span id="91d5" class="mk ld iq mg b gy mp mm l mn mo">        float [] image = new float[784];<br/>        int [] int_image = new int[784];<br/>        //get the output<br/>        inferenceInterface_GAN_O.fetch(OUTPUT_NODE_GAN_O,image);</span><span id="c2f5" class="mk ld iq mg b gy mp mm l mn mo">       <strong class="mg ir"> //output image</strong><br/>        <strong class="mg ir">for(int i =0 ; i&lt;image.length; i++){<br/>            int_image[i] = (int)(image[i]*255);<br/>        }<br/>        return int_image;</strong><br/>}</span></pre><p id="3f87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，为了生成 X，我们必须将随机噪声向量传递给图形</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="dd11" class="mk ld iq mg b gy ml mm l mn mo">public int[] getGAN_X(){</span><span id="9b5c" class="mk ld iq mg b gy mp mm l mn mo"><strong class="mg ir">        // random noise input vector</strong>    <br/>        <strong class="mg ir">float [] noise_input = new float [100];<br/>        for(int i =0 ; i&lt;noise_input.length; i++){<br/>            float value = rand.nextFloat();<br/>            noise_input[i] = (value*2)-1;<br/>        }</strong><br/>        inferenceInterface_GAN_X.feed(INPUT_NODE_GAN_X, noise_input,1,100);<br/>        inferenceInterface_GAN_X.run(new String[]{OUTPUT_NODE_GAN_X},false);</span><span id="e655" class="mk ld iq mg b gy mp mm l mn mo">float [] image = new float[784];<br/>        int [] int_image = new int[784];<br/>        //get the output<br/>        inferenceInterface_GAN_X.fetch(OUTPUT_NODE_GAN_X,image);</span><span id="3fdb" class="mk ld iq mg b gy mp mm l mn mo"><strong class="mg ir">        //output image</strong><br/>        <strong class="mg ir">for(int i =0 ; i&lt;image.length; i++){<br/>            int_image[i] = (int)(image[i]*255);<br/>        }<br/>        return int_image;</strong><br/>}</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/ce64d2555a63b75ae7e71041a480d0f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/1*gRqKR2KdHr0820RekqVEDA.gif"/></div></figure><p id="80a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是 CNN 和 GAN 整合后的结果。完成应用程序的所有逻辑。</p><p id="fbb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在 play store 上试用它上传的应用:【https://play.google.com/store/apps/details?id=com.harsh.xo T2】</p><p id="d928" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">未来作品</strong>:可能在做条件 GAN，帮我从同一个网络生成 X 和 O。</p><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/android-with-tensorflow-part-1-6897ba617b1e"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">Android 中的 ConvolutionNeuralNetwork(CNN)——TIC tactoe . ai(第 1 部分)</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">Google Tensorflow 现在已经在 Android 中用于集成机器学习模型。</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj kv mv"/></div></div></a></div><div class="ms mt gp gr mu mv"><a href="https://play.google.com/store/apps/details?id=com.harsh.xo" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">tictactoe . ai-Google Play 上的应用程序</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">我正致力于在安卓系统中集成卷积神经网络，因为我在…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">play.google.com</p></div></div><div class="ne l"><div class="nk l ng nh ni ne nj kv mv"/></div></div></a></div></div></div>    
</body>
</html>