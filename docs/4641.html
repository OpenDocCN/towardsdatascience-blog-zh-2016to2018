<html>
<head>
<title>Committing to Sanity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">致力于健全</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/committing-to-sanity-67eddaa8eb35?source=collection_archive---------15-----------------------#2018-08-27">https://towardsdatascience.com/committing-to-sanity-67eddaa8eb35?source=collection_archive---------15-----------------------#2018-08-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/eea1dc225c4c2bae1ac501fb6c0fd5d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mZqaU6ExlXPx7V_C408uzg.jpeg"/></div></div></figure><p id="4c19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">【blog.zakjost.com】本文原载于<a class="ae kx" href="https://blog.zakjost.com/post/git-in-data-science/" rel="noopener ugc nofollow" target="_blank"><em class="kw"/></a></p><h1 id="f004" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h1><p id="c0e2" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">你成功地完成了一个建模项目，三个月过去了。您已经学到了一些东西，需要回去进行更改并重建模型。所以，你开始浏览你的项目目录。嗯，最终的模型训练代码是在<code class="fe mb mc md me b">test_90_new_features-Copy4.py</code>还是<code class="fe mb mc md me b">prod_90_add_attrs-Copy2.py</code>？你是用<code class="fe mb mc md me b">data_prep-Copy2_with_ohe.py</code>还是<code class="fe mb mc md me b">full_data_pipe-Copy4.py</code>生成训练数据的？</p><p id="5933" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果这听起来很熟悉，那么您没有使用版本控制作为您工作的基本方式，这对您不利。在这篇文章中，我将讨论为什么 git 应该被数据科学家所接受。在<a class="ae kx" href="https://blog.zakjost.com/post/implementing-git" rel="noopener ugc nofollow" target="_blank">第 2 部分</a>中，我将提供一些关于我如何构建项目的实现细节来帮助你开始。</p><h1 id="1525" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">饭桶</h1><p id="9bc6" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">如果你不熟悉的话，<a class="ae kx" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> git </a>是一种版本控制技术，它本质上是拍摄你的项目的快照。如果您更改了某个文件，它会知道，并且会记录对所有跟踪文件所做的所有更改。当你完成一件事，你告诉 git 做一个快照。因为它知道所有的变化，它可以很容易地撤销它们。</p><p id="10f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们这些已经听了磁带音乐的人来说，你应该记得需要倒带或快进来排队等候某首歌曲的麻烦。按下按钮，等待几秒钟，停止，播放，意识到你过了或还没有到达那里，重复。有了 CD 就有了检查点，这样你就可以快速导航到歌曲的开头。现在很难想象<em class="kw">没有</em>有这种选择。同样，您会想知道在没有可以轻松导航和恢复的逻辑检查点的情况下，您是如何管理建模实验的。</p><p id="08d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查点的可用性带来三个主要好处:安全性、清晰性和可重复性。让我们更深入地了解每一项。</p><h1 id="3a40" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">安全</h1><p id="f7b3" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">很明显，有了常规的检查点，你的工作会更安全，因为当你走进死胡同时，你可以点击“撤销”按钮。但是有一些相关的好处可能不那么明显。首先，你可能还会与一个远程 git 服务器同步，比如 GitHub，所以你的工作会被备份到另一台机器上。通过使用版本控制，您已经自动获得了备份工作的好处。当一切运行良好时，这可能无关紧要，但当您将咖啡洒在笔记本电脑上时，这就非常重要了。</p><p id="183f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二，额外的安全性导致更大的实验意愿。有多少次不是直接修改一个函数，而是复制/粘贴它，在名字前加“_v2”，然后<em class="kw">再</em>修改，以防万一你可能想还原回来？这是可怜人的版本控制，结果一塌糊涂。有了检查点，您可以放心大胆地进行更改，因为您可以随时恢复。死角可以删除，突破可以合并，潜在有用的切线可以束之高阁。</p><h1 id="e5aa" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">清楚</h1><p id="8118" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">当您可以自由地删除与手头特定任务无关的代码时，您的代码会变得更加集中和清晰。如果你正在测试的新模型没有使用那个死端特征工程代码块，那么就删除它。这避免了在最终结果不确定的环境中，从实验中出现的难以理解的代码的大网络的增长。</p><h1 id="a16b" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">可重复性</h1><p id="764c" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">当您的代码分布在 Jupyter 笔记本的多个副本上，需要以非常特殊的顺序运行来生成模型时，就会出现可重复性问题。虽然除了早期试验之外，使用 Jupyter 笔记本做任何事情都可能<a class="ae kx" href="https://docs.google.com/presentation/d/1n2RlMdmv1p25Xy5thJUhkKGvjtV-dkAIsUXP-AL4ffI/edit#slide=id.g362da58057_0_1" rel="noopener ugc nofollow" target="_blank">不是一个好主意</a>，但是使用版本控制来保持代码简洁/干净降低了风险，并使其更容易移植到适当的模块中。未来的你或未来的队友将会非常高兴，因为只有一个数据管道和一个模型构建。</p><h1 id="62c5" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">履行</h1><p id="1ba8" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">Git 通常在软件工程领域被考虑，在那里你可能有一个团队所有人都在相同的代码基础上工作。这带来了许多挑战，在这种背景下出现了一些最佳实践。虽然肯定有很多重叠，但这与个人进行数据科学实验并不完全相同。查看<a class="ae kx" href="https://blog.zakjost.com/post/implementing-git" rel="noopener ugc nofollow" target="_blank">第 2 部分</a>，获得关于这些差异的更详细的讨论，以及作为数据科学家如何有效地使用版本控制的一些想法。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><p id="4632" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">你可以在</em><a class="ae kx" href="http://blog.zakjost.com" rel="noopener ugc nofollow" target="_blank"><em class="kw">blog.zakjost.com</em></a>找到我所有的内容并订阅</p></div></div>    
</body>
</html>