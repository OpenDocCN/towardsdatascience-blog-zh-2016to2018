<html>
<head>
<title>Beating Datadriven’s DengAI competition Benchmark in 5 minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 5 分钟内击败 Datadriven 的邓艾竞赛基准</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/beating-datadrivens-dengai-competition-benchmark-in-5-minutes-c12e86c4331c?source=collection_archive---------7-----------------------#2018-11-04">https://towardsdatascience.com/beating-datadrivens-dengai-competition-benchmark-in-5-minutes-c12e86c4331c?source=collection_archive---------7-----------------------#2018-11-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="8d7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">持续时间最长、最有趣的数据科学和机器学习竞赛之一毫无疑问是邓艾竞赛。参赛者被要求根据环境信息预测两个南美城市的登革热病例数。</p><p id="915d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们试图通过仅使用<strong class="js iu">一个特征</strong>和<strong class="js iu">时间序列预测</strong>来击败竞争对手的<a class="ae ko" href="http://drivendata.co/blog/dengue-benchmark/" rel="noopener ugc nofollow" target="_blank">基准分数</a>。在<strong class="js iu">脸书的先知库</strong>，一个 Jupyter 笔记本和总共<strong class="js iu">二十行代码</strong>的帮助下，我们学会了如何在几分钟内打破基准分数。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/c036ea5666fff2ffba0772c6c0d18085.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WfmAxy1lBi7kV-Wxc51bOw.png"/></div></div></figure><h1 id="15f0" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">邓加伊</h1><p id="6bcd" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">比赛要求你<strong class="js iu">利用美国联邦政府各机构收集的环境数据，预测圣胡安(波多黎各)和伊基托斯(秘鲁)每周报告的登革热病例数</strong>。所提供的数据具有诸如每周最高温度、湿度和降雨量<strong class="js iu">的特征。</strong></p><p id="e95a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">平均绝对误差</strong> (MAE)用于评分。看看排行榜上的最高分，很明显挑战并不容易:最高分的人只有 13 分多一点，而排名在第 100 位左右的人只有 17 分。如果你知道在 Iquitos 提供的数据中，每周的平均病例数只有 8 例左右，这意味着即使是顶级模型也几乎没有预测能力。</p><p id="b93a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，比赛组织者提供了一个基准分数，包括一个完整的笔记本来帮助你开始。在这个例子中，他们只使用了负二项式广义线性模型中的几个特征，结果得分为 25.81。这篇文章的目标是通过使用时间序列预测技术，尽可能快地打破这个记录<strong class="js iu">。为了帮助我们完成这项任务，我们将使用<strong class="js iu">脸书的 Python 先知库</strong>。</strong></p><h1 id="4fec" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是脸书先知</h1><p id="631b" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">2017 年初<em class="me">脸书</em>开源<em class="me"> Prophet </em>、<strong class="js iu">Python 和 R. Prophet 中可用的预测工具</strong>特别适合预测季节性强、历史趋势变化和遵循非线性增长曲线的趋势的时间序列。使用 Prophet 的其他好理由是<a class="ae ko" href="https://facebook.github.io/prophet/docs/quick_start.html#python-api" rel="noopener ugc nofollow" target="_blank">提供的优秀文档</a>和整体易用性。</p><p id="3142" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Prophet for Python 可以像任何其他库一样使用，可以在命令行安装或更新。因为我使用 Python 的<em class="me"> Anaconda </em>发行版，所以我使用了一个简单的<em class="me"> conda </em>安装。</p><p id="970d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mf mg mh mi b">conda install -c conda-forge fbprophet</code></p><p id="4b3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你在安装 Prophet 时遇到任何麻烦或错误，看看 Github 的<a class="ae ko" href="https://github.com/facebook/prophet/issues" rel="noopener ugc nofollow" target="_blank"><em class="me"/>问题</a>或者在谷歌搜索中抛出你的错误。</p><h1 id="078a" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">准备数据</h1><p id="eb21" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">在开始预测之前，我们需要掌握数据。进入<a class="ae ko" href="https://www.drivendata.org/competitions/44/dengai-predicting-disease-spread/data/" rel="noopener ugc nofollow" target="_blank">邓艾竞赛页面</a>下载列车功能、列车标签和测试功能。然后打开一个 Jupyter 笔记本，导入<em class="me">熊猫</em>、<em class="me"> numpy </em>、<em class="me"> matplotlib </em>和<em class="me"> fbprophet </em>(全库或者只<em class="me"> Prophet </em>类)。</p><pre class="kq kr ks kt gt mj mi mk ml aw mm bi"><span id="46cc" class="mn lc it mi b gy mo mp l mq mr">import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>from fbprophet import Prophet</span></pre><p id="94a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将数据载入你的笔记本。</p><pre class="kq kr ks kt gt mj mi mk ml aw mm bi"><span id="b533" class="mn lc it mi b gy mo mp l mq mr">train = pd.read_csv('dengue_features_train.csv')<br/>test = pd.read_csv('dengue_features_test.csv')<br/>labels = pd.read_csv('dengue_labels_train.csv')</span></pre><p id="8d53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于我们将尝试纯粹基于时间数据进行预测，因此我们可以从数据框架中去掉<em class="me">城市</em>、<em class="me">周 _ 开始 _ 日期</em>和<em class="me">总 _ 例数</em>。注意，我们选择<em class="me"> week_start_date </em>作为时间数据，因为这个特性已经被表示为一个<em class="me">标准日期时间字符串</em>，并且不需要任何转换。</p><pre class="kq kr ks kt gt mj mi mk ml aw mm bi"><span id="f282" class="mn lc it mi b gy mo mp l mq mr">train['total_cases'] = labels['total_cases']</span><span id="612f" class="mn lc it mi b gy ms mp l mq mr">prophet_data = train[['city', 'week_start_date', 'total_cases']]</span></pre><p id="77c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，拆分伊基托斯和圣胡安的数据，删除<em class="me">城市</em>列，因为我们的预测不需要这个。</p><pre class="kq kr ks kt gt mj mi mk ml aw mm bi"><span id="44ef" class="mn lc it mi b gy mo mp l mq mr">prophet_data_sj = prophet_data[prophet_data['city'] == 'sj']\<br/>                .drop('city', axis=1)<br/>prophet_data_iq = prophet_data[prophet_data['city'] == 'iq']\<br/>                .drop('city', axis=1)</span></pre><p id="3655" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，对您的测试数据进行同样的操作，但是只保留<em class="me"> week_start_date </em>列。</p><pre class="kq kr ks kt gt mj mi mk ml aw mm bi"><span id="24f3" class="mn lc it mi b gy mo mp l mq mr">test_sj = test[test['city'] == 'sj']['week_start_date']<br/>test_iq = test[test['city'] == 'iq']['week_start_date']</span></pre><p id="4e74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了使 Prophet 库正常运行，必须将时间特性命名为<em class="me"> ds </em>以及预测值为<em class="me"> y </em>。对两个数据帧都这样做。</p><pre class="kq kr ks kt gt mj mi mk ml aw mm bi"><span id="3b7f" class="mn lc it mi b gy mo mp l mq mr">prophet_data_sj.columns, prophet_data_iq.columns = <br/>                                           ['ds', 'y'], ['ds', 'y']</span></pre><p id="01b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们的数据已经准备好进行一些先知魔法了！</p><h1 id="359a" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">先知魔法</h1><p id="c959" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">我们可以开始使用<em class="me"> fbprophet </em>库来预测我们测试数据的值。为了方便起见，我们将创建一个函数，将训练数据、测试数据和两个预测参数作为输入。</p><p id="54dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">建立先知预测的第一步是创建一个<em class="me">先知</em>类的新实例。在初始化该类时，您可以设置一大堆参数(例如<em class="me">周 _ 季节性</em>或<em class="me">日 _ 季节性</em>)，但我们将只设置<em class="me">变点 _ 先验 _ 标度(默认为 0.05) </em>和<em class="me">年 _ 季节性(默认为 10) </em>。</p><p id="8828" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了理解第一个参数的含义，你需要知道时间序列的趋势经常发生突变。这些变化被称为<strong class="js iu">变点。</strong> Prophet 将自动检测这些变化点，并允许趋势适当调整。</p><p id="62d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Prophet 通过首先指定大量潜在的变点来检测变点，然后对速率变化的幅度进行稀疏先验。这实质上意味着，Prophet 有大量可能改变速率的地方，但将尽可能少地使用它们。</p><p id="ba70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">调整稀疏先验的强度将改变模型的灵活性，并且可以使用<em class="me"> changepoint_prior_scale </em>参数进行调整。通过向上调整该参数，将使用更多的变点，因此模型将更好地拟合训练数据。</p><p id="e421" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为这个参数被用来改变模型的灵活性，并对抗过拟合或欠拟合，我们在函数中称这个参数为<em class="me"> flex </em>。</p><p id="8dfa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二个参数<em class="me">yearly _ 季节性</em>，是使用<em class="me">部分傅立叶和</em>估算的。看看<a class="ae ko" href="https://peerj.com/preprints/3190/" rel="noopener ugc nofollow" target="_blank">这篇论文</a>了解更多关于部分傅里叶和与周期信号的信息。本质上，季节性论点决定了季节性变化的速度。</p><p id="fbea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的案例中，我们最有可能更好地应对较低的季节性，因为我们的数据与似乎不会改变的年度天气模式密切相关(看看气候训练和测试数据)。</p><p id="4aee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们函数的下一步是通过调用<em class="me"> fit() </em>函数使我们的训练数据符合我们的<em class="me"> Prophet </em>。然后，我们希望创建一个数据帧，表示我们希望预测的未来日期。这可以通过调用我们的<em class="me"> Prophet </em>上的<em class="me">make _ future _ data frame()</em>函数来轻松完成。</p><p id="d70d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该函数有两个参数:<em class="me">周期</em>和<em class="me">频率</em>。在我们的例子中，周期的数量应该正好是我们测试数据的长度，频率应该设置为每周一次(<em class="me">‘W’</em>)，因为我们每周都有数据点。</p><p id="a4ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，终于到了用预测值填充我们未来数据框架的时候了。我们通过调用<em class="me"> Prophet </em>上的<em class="me"> predict() </em>来实现这一点，并将未来数据帧作为输入。我们还在<em class="me"> Prophet </em>上运行<em class="me"> plot() </em>来获得我们预测的可视化。</p><pre class="kq kr ks kt gt mj mi mk ml aw mm bi"><span id="6adb" class="mn lc it mi b gy mo mp l mq mr">def create_forecast(train_data, test_data, flex, seas):<br/>    <br/>    prophet = Prophet(changepoint_prior_scale=flex, <br/>                      yearly_seasonality=seas) <br/>    <br/>    prophet.fit(train_data)<br/>    <br/>    future_frame = prophet.make_future_dataframe(<br/>        periods=len(test_data), <br/>        freq='W')<br/>    <br/>    forecast = prophet.predict(future_frame)<br/>    <br/>    prophet.plot(forecast)<br/>    <br/>    forecast = forecast[['ds', 'yhat']].yhat\<br/>        .apply(lambda x : int(x))</span><span id="9274" class="mn lc it mi b gy ms mp l mq mr">return forecast[len(train_data):]</span></pre><p id="db02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您看一下预测数据帧，您应该看到它有一大堆变量，包括时间戳(<em class="me"> ds </em>)和预测值(<em class="me"> yhat </em>)。切掉这两个值，并将预测转换为整数(竞赛只接受整数作为预测)。</p><p id="47df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">数据帧还包括来自我们的训练和测试数据的所有数据。我们只需要对测试数据的预测。截取测试数据并返回这个数据帧作为我们函数的输出。现在，我们的功能已经完成，我们可以开始使用它来预测我们的登革热数据。</p><p id="fdde" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">制作两个预测，一个针对伊基托斯，一个针对圣何塞，并将它们存储在一个变量中。这里，我们使用季节性(10)和灵活性(0.05)的默认值。</p><pre class="kq kr ks kt gt mj mi mk ml aw mm bi"><span id="160a" class="mn lc it mi b gy mo mp l mq mr">forecast_sj = create_forecast(prophet_data_sj, test_sj, 0.05, 10)<br/>forecast_iq = create_forecast(prophet_data_iq, test_iq, 0.05, 10)</span></pre><p id="1a1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">查看预测，我们可以看到我们确实创建了两个熊猫系列，并对我们的测试数据进行了预测。除了这个系列，还应该弹出一个图表，其中原始数据是分散的，预测是连续的线。摆弄一下季节性和灵活性参数，看看它们如何影响<strong class="js iu">预测</strong>(蓝线)<strong class="js iu">信心</strong>(浅蓝色)<strong class="js iu">趋势</strong>(红线)和<strong class="js iu">转折点</strong>(垂直红色虚线)。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mt"><img src="../Images/4e9b32a8b403cac4d9d1e1e482895cee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7wWOwU1mmFErF3PNOjqAnA.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">Predictions for San Juan with respectively high flexibility and high seasonality</figcaption></figure><h1 id="60ac" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">提交结果</h1><p id="f90f" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">可以说是整个流程中最简单的一步，就是准备好提交的结果并上传到<em class="me"> DrivenData </em>上。要了解提交要求，看一下提交格式(<a class="ae ko" href="https://www.drivendata.org/competitions/44/dengai-predicting-disease-spread/data/" rel="noopener ugc nofollow" target="_blank">在这里找到</a>)。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi my"><img src="../Images/f50dcc81381488bbfa65f72db0aa02ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*VmSvaBggU51NXGIqiBdlmQ.png"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">DengAI submission format</figcaption></figure><p id="62b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总之，比赛需要一个<em class="me">。csv </em>文件，有四列，分别命名为<em class="me">城市</em>、<em class="me">年份</em>、<em class="me">星期几</em>和<em class="me">总 _ 例数</em>(我们的预测)。我们再次创建一个函数，将两个城市的预测和一个提交名称作为输入。</p><p id="09ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们连接预测，将它们与索引列合并，给所有列指定所需的名称，并将结果数据帧保存为<em class="me">。csv </em>文件。确保为您的 csv 提供适当的名称，以便您记住用于预测的参数(例如<em class="me"> prophetflex05seas10 </em>)。</p><pre class="kq kr ks kt gt mj mi mk ml aw mm bi"><span id="adb3" class="mn lc it mi b gy mo mp l mq mr">def create_submission(forecast_sj, forecast_iq, sub_name):<br/>    <br/>    test_index = test[['city', 'year', 'weekofyear']]<br/>    <br/>    output = pd.concat([forecast_sj, forecast_iq])\<br/>        .reset_index().drop(['index'], axis=1)<br/>        <br/>    output.columns = ['total_cases']<br/>    <br/>    pd.concat([test_index, output], axis=1)\<br/>        .set_index(['city']).to_csv(sub_name + '.csv')</span></pre><p id="d407" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，用默认的预测参数创建一个新的提交，并给它起一个合适的名字。</p><pre class="kq kr ks kt gt mj mi mk ml aw mm bi"><span id="317a" class="mn lc it mi b gy mo mp l mq mr">create_submission(forecast_sj, forecast_iq, 'prophetflex05seas10')</span></pre><p id="88c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">前往竞赛<a class="ae ko" href="https://www.drivendata.org/competitions/44/dengai-predicting-disease-spread/submissions/" rel="noopener ugc nofollow" target="_blank">提交页面</a>并上传您刚刚创建的 csv 文件以获得分数。您应该得到 26.76 的结果，这不是我们所希望的，比基准测试还要差。请记住，这个分数是我们测试数据集中每个预测日期的平均误差。</p><p id="9e74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看看您的代码生成的图表，您会发现两种预测多一点灵活性可能不会有什么坏处(增加灵活性)。此外，伊基托斯的季节性非常多变，我们的预测会更好，季节性趋势会稍微平稳一些(减少季节性)。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mz"><img src="../Images/64991c64e1d6ba5a56601e3e31e307c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*njhnqjwAzyCNBur2YRa-4A.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">Forecast for San Juan and Iquitos with default Prophet parameters</figcaption></figure><p id="8a50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用这些新信息做一个新的预测。例如，将两个城市的弹性设置为 0.10，并将伊基托斯的季节性降低为 5。</p><pre class="kq kr ks kt gt mj mi mk ml aw mm bi"><span id="52cd" class="mn lc it mi b gy mo mp l mq mr">forecast_sj = create_forecast(prophet_data_sj, test_sj, 0.1, 10)<br/>forecast_iq = create_forecast(prophet_data_iq, test_iq, 0.1, 5)</span><span id="38c0" class="mn lc it mi b gy ms mp l mq mr">create_submission(forecast_sj, forecast_iq, 'prophsjf10s10iqf10s5')</span></pre><p id="a272" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">再次提交结果，并得出结论，我们仅用几行代码和一个特性(<em class="me"> week_start_date </em>)就击败了竞争基准。请注意，没有使用机器学习来进行预测。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi na"><img src="../Images/e277f093b98e26cebef78c7e846fb9c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LGa0-0XC6phCj2sBWERPZg.png"/></div></div></figure><h1 id="0f2d" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">下一步是什么？</h1><ul class=""><li id="3676" class="nb nc it js b jt lz jx ma kb nd kf ne kj nf kn ng nh ni nj bi translated"><strong class="js iu">用剩下的数据！</strong>利用环境数据根据天气特征进行预测。将这些结果与我们在这里建立的时间序列预测模型结合起来。</li><li id="9b98" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated"><strong class="js iu">调整参数</strong>。尝试通过改变参数来提高模型的得分，不仅是这里讨论的参数，还有这里没有讨论的所有其他参数(<a class="ae ko" href="https://facebook.github.io/prophet/docs/quick_start.html#python-api" rel="noopener ugc nofollow" target="_blank">参见文档</a>)。</li><li id="9f04" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated"><strong class="js iu">寻找新的数据源</strong>。看看你能否在新闻网站或博客上找到任何关于圣胡安和/或伊基托斯登革热疫情(或没有疫情)的信息。了解年度趋势会给你带来巨大的优势。</li></ul><p id="b839" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">—请随时在评论中或私信中向我指出任何不一致或错误。—</p></div></div>    
</body>
</html>