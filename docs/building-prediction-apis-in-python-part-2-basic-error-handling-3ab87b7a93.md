# 用 Python 构建预测 API(第 2 部分):基本错误处理

> 原文：<https://towardsdatascience.com/building-prediction-apis-in-python-part-2-basic-error-handling-3ab87b7a93?source=collection_archive---------11----------------------->

![](img/70c0af8165b61f4de47716caf4bbee99.png)

在[初始系列文章](https://medium.com/@chris.moradi/building-prediction-apis-in-python-part-1-series-introduction-basic-example-fe89e12ffbd3)中，我们创建了一个简单的 API 来对建立在 iris 数据集上的 Scikit-Learn 随机森林分类器进行评分。在本帖中，我们将探讨如何处理评分过程中出现的错误，以及定义何时应该使用模型这一更广泛的主题。

[](https://medium.com/@chris.moradi/building-prediction-apis-in-python-part-1-series-introduction-basic-example-fe89e12ffbd3) [## 用 Python 构建预测 API(第 1 部分):系列介绍&基本示例

### 好吧，你已经训练了一个模型，但是现在呢？如果没有人会使用，所有的工作都是没有意义的。在某些应用中…

medium.com](https://medium.com/@chris.moradi/building-prediction-apis-in-python-part-1-series-introduction-basic-example-fe89e12ffbd3) 

# 一个简短的激励话题

我们可以从测试一个简单的 Python 函数开始。没有模型，没有 API，只是一个将两个数相加的函数。

当我们考虑如何测试这个函数时，我们应该考虑所有可能出错的地方，并假设它会在某个时候出错。这个例子非常简单，我们只需要担心`a`和`b`的错误输入参数。以下是一些例子:

通过这一小组示例，我们可以看到基于“可接受的？”的三个不同类别专栏:商品、商品和不确定因素。“商品”是我们预期的输入，即我们可以加在一起的`int`或`float`值。“坏的”是引发异常的那些；Python 不知道如何添加的输入。Python 已经为我们抛出了一个异常，但是我们看到基于输入参数抛出的异常类型(`TypeError`或`ValueError`)有些不一致。我们可以捕捉这些异常并定制一个一致的异常，或者我们可以返回`None`。

最后一类，即“不确定性”，可能是最有趣的。这些产生了有效的结果，但是它们没有反映我们最初打算支持的内容。在这里，我们可以选择如何解决我们的意图和实现之间的不一致。在 Python 中，我们通常不想强制类型，所以我们可以让代码保持原样。我们应该在 docstring 中或通过类型提示来表示预期的类型，以便用户理解我们正式支持什么，以防将来的变化破坏当前的功能。但是，可能有些情况下，我们希望拒绝返回值，除非满足某些条件。在这些情况下，我们可以显式地检查输入的类型，甚至将它们限制在某个可接受的值范围内(例如，只添加小整数)。

# 模型特征的错误

既然我们已经看了一个简单的例子，让我们回到第一部分[的原始预测 API:](https://medium.com/@chris.moradi/building-prediction-apis-in-python-part-1-series-introduction-basic-example-fe89e12ffbd3)

从我们上一节介绍的内容开始，我们将考虑通过`request.args`传递的错误输入参数。对于其中的每一个，我们都期待一个可以转换成`float`的值。然而，使用上面的方法，我们将获得每个的字符串值。Flask 通过向`request.args.get()`方法提供`type`参数，使得转换查询参数变得容易:

`request.args.get('sepal_length', default=None, type=float)`

这将尝试将`sepal_length`的值转换为`float`，如果转换失败，将返回由`default`关键字参数指定的默认值。*注意:* `default` *关键字参数的缺省值是* `None` *，所以我们可以省去这个参数。*

除了原始版本(没有指定`type`)，我们还处理请求中缺少查询参数的情况。在这两个版本中，相应的变量将被赋予默认值`None`。

我们可以以类似的方式更改检索`sepal_width`、`pedal_length`和`pedal_width`的`request.args.get()`调用。然而，当我们重启服务器并测试一个带有错误值或丢失参数的请求时，我们会遇到另一个问题:**我们的模型不能处理丢失的值**。提出这样的请求会导致`ValueError: Input contains NaN, infinity or a value too large for dtype('float32')`。

# 我们应该得分多少？

使用我们的`adder`函数，来自“不确定”类别的输入值会产生一个结果(没有引发异常),但也许不应该。在我们的模型评分中，我们发现了一个以相反方式处理的类似组。我们当前的实现是拒绝缺少值的请求(引发一个`ValueError`)，但是也许我们应该找到一种方法返回一个预测。

在任何模型部署中，确定哪些请求应该被评分，哪些应该导致错误或警告是一个关键的考虑因素。这通常是一个微妙的决策，涉及模型开发人员、业务合作伙伴和产品所有者，并寻求平衡预测的好处和错误的代价。作为一个利益相关者，我有意忽略了软件开发的角色。这是因为如果有足够的时间和资源，他们通常能够实现预期的意图。从长远来看，**模型的使用应该由数据科学、业务和产品需求驱动，而不是由评分平台实现的便利性驱动**。虽然我已经分别列出了这些角色，但是同一个人可能会满足他们中的许多人或所有人——这使得我们在做出这些决定时采取哪种观点更加重要。

这里有几个场景来帮助说明为什么我们需要慎重决定对哪些请求进行评分:

*   在线广告:假设我们已经建立了一个模型来预测在一组可能的广告中，我们应该向我们网站的特定访问者显示哪个广告。通过用户跟踪，我们知道大多数访问者的参考页面或网站，但对于一些人来说，这是缺失的。在这种情况下，做出次优甚至差的预测可能是好的，因为错误的成本很低。一个担忧可能是次优预测会如何影响我们对广告进行的任何 A/B 测试——特别是如果这些低质量的预测偏向某个特定的广告——但访问者不太可能因为看到了“错误”的广告而逃离我们的网站。
*   扩大贷款/信用:高成本决策的一个例子是信用贷款；我们的模型将预测某人的信用度或风险。贷款机构通常会将模型的许多关键特征建立在信用局数据的基础上。例如，如果客户正在申请贷款，我们想知道他们是否在另一笔贷款上违约，或者在最近几年申请破产。信用局的数据对贷款决策至关重要，如果没有这些数据，我们不会对客户的申请进行评分。
*   欺诈检测:创建欺诈防御通常是阻止可疑活动和激怒好客户之间的平衡行为。虽然与合法使用相比，欺诈在事件发生率上通常很少，但它会给公司带来巨大的财务和声誉成本。本能反应可能是积极使用任何可以减少损失的欺诈模式。然而，欺诈也是对抗性的，欺诈者会调整他们的方法来规避现有的防御。由于这些原因，对欺诈行为进行强大而一致的防御通常非常具有挑战性。此外，标记为欺诈的事件可能会导致交易被拒绝、帐户被限制或申请被拒绝。这些处理方法在正确应用时非常有效，但假阳性会导致糟糕的客户体验，并可能导致有价值客户的参与度降低或流失。由于这些因素，基于预测模型的决策可能仅适用于可疑事件总数中的一小部分。

# 缺失和不良输入的不同处理方式

现在，让我们回到我们的 API 示例来展示我们如何实现这些模型使用策略。

## 拒绝请求

我们可以从拒绝对任何有坏值或缺失值的请求评分开始。最简单的方法是捕捉评分过程中引发的异常。

这里，我们在`MODEL.predict()`周围添加了一个`try/except`块，这样我们就可以捕捉到任何引发的异常。大部分代码只是准备一个错误响应。现在，如果用错误的或缺失的值调用 API，调用者将会收到这样的消息:*未能对模型进行评分。异常:输入包含 NaN、infinity 或对 dtype 来说太大的值(“float32”)。*

我们还使用适当的 [HTTP 状态代码](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)来为我们的用户提供额外的反馈，这不仅是一个阻止我们对请求评分的错误，而且是他们的错误。这是通过在对“400 错误请求”的响应上设置`status_code`来完成的。在我们之前版本的 API 中，当出现未处理的异常时，Flask 仍然会为我们发送响应，但`status_code`是“500 内部服务器错误”。虽然这提供了支持，但是“500”错误仅仅意味着 API 服务器端出了问题。它不会通知呼叫者他们的请求是原因，所以他们可能会尝试重复呼叫。请注意，当我们返回一个成功处理的请求时，我们不需要设置`status_code`，因为该响应将自动具有“200 OK”的`status_code`。

虽然这种方法是成功的，并且这个错误消息是相关的，但是这不是处理输入错误的理想方法。我们正在捕捉一个基本异常。虽然我们没有遇到任何其他异常，但这并不意味着它们不会发生。我们应该努力将输入错误与其他错误隔离开来。此外，我们正在发回异常的内容。如果此错误消息中包含敏感信息，我们会将其发送给呼叫者。这可能是一个安全问题。

## 直白

一个改进可能是显式地捕捉最初测试中出现的`ValueError`异常。但是，不清楚这是否是值错误或丢失时引发的唯一异常。此外，`ValueError`也可能发生在与调用者提供的错误/丢失数据无关的其他地方。由于这些因素，最好的方法是显式地检查和处理输入值。

我们添加了`if`块来检查我们的任何特征值是否为`None`。如果请求中缺少它们或者它们的值不能被转换成`float`，就会出现这种情况。

有几件事可以改进:

*   我们只解决缺失的功能或那些不能转换成`float`的功能。在实际场景中，我们还想识别超出可接受范围的值。例如，所有四个特征都是花瓣和萼片长度的测量值，因此它们必须是正数。这些测量值也有一个上限。一万厘米的花瓣是不可能的。
*   我们应该跟踪一个请求是被成功评分还是被拒绝。这可以使用 Python 的`logging`模块来完成，但这是我们将在另一篇文章中更深入探讨的内容。

## 让我们给每样东西打分

我们用来建立模型的虹膜数据集已经非常干净了。在大多数真实场景中，这种清理和准备过程是模型构建的一大部分。特别是，我们在构建数据集中没有遇到任何缺失值。这是一个很大的话题，超出了本文的范围。你可以通过搜索“处理机器学习中的缺失数据”或“插补机器学习”找到大量的优秀资源。

这里我们将使用一种简单的方法来处理缺失值:使用特征的平均值。这叫做*均值插补*。

我们可以通过使用:`X_train.mean(axis=0)`获得每个特征的平均值。查看[原帖](https://medium.com/@chris.moradi/building-prediction-apis-in-python-part-1-series-introduction-basic-example-fe89e12ffbd3)看看我们的训练集是如何构建的。这可能会根据构建训练数据集时使用的`random_state`而有所不同，但它应该与以下内容非常相似(为清晰起见，四舍五入):

实现这一点就像在我们获得请求参数时更改默认值一样简单:

我们可以测试这个迭代，并验证它是否正常工作。事实上，我们可以看到，即使没有提供参数，它也会对请求进行评分。

## 在灰色地带得分

我们将跳过一个微妙情况的实现，在这种情况下，我们拒绝缺少重要特征的请求，但如果其他特征缺失，我们将使用均值插补。这可以通过将上述技术与一些定制逻辑仔细混合来实现。作为练习，您可以实现一个 API，该 API 将只对同时满足这两个条件的请求进行评分:

1.  `sepal_length`必须有效。
2.  其余 3 个特征中只能有一个缺失。

# 后续步骤

关于这些实现，我们有几个地方需要改进。首先，我们将模型和 API 耦合得比最初的例子更紧密。除了检索特定的查询参数，我们现在检查它们的值是否是`None`或者用特定的值来输入它们。比方说，我们需要根据新数据重新调整模型。对于均值插补，我们需要检查并更新 API 代码库中每个特征的默认值。最终，我们希望构建一个 API，它可以对多个模型进行评分，包括具有不同特性的模型。理想情况下，我们希望模型本身检索它们需要的特性，准备它们，如果它们不应该获得记录，可能会引发异常或返回错误。然后，API 将只负责向模型传递数据，并根据模型预测的结果准备响应——这是一种明确的职责分离。

第二个改进是存储与发生的请求和错误相关的数据。如果我们有不能得分的请求，我们至少想知道这种情况多长时间发生一次，也许可以将这些拒绝分类。因为我们没有保存任何与我们正在处理的请求相关的数据，所以我们没有办法回答这些问题。

虽然这些都很重要，但在下一篇文章[中，我们将重点关注如何测试我们的 API 对请求评分的能力。](/building-prediction-apis-in-python-part-3-automated-testing-a7cfa1fa7e9d)

[](/building-prediction-apis-in-python-part-3-automated-testing-a7cfa1fa7e9d) [## 用 Python 构建预测 API(第 3 部分):自动化测试

### 在上一篇文章中，我们改进了预测 API 的错误处理，并考虑了关于哪个…

towardsdatascience.com](/building-prediction-apis-in-python-part-3-automated-testing-a7cfa1fa7e9d) 

## 脚注

1.  返回`None`而不是引发异常在函数式编程中很有帮助。例如，如果我们正在使用`df.apply(my_funct, axis=1)` 计算熊猫数据帧的新列，并且我们预计某些行的计算会失败，我们可以让`my_funct`返回`None`或`numpy.nan`。结果列将包含计算成功的正确值，并将失败的计算视为缺失。这类似于也许单子模式。
2.  我们收到这个错误是因为我们的模型会自动将我们的嵌套列表转换成包含数据类型为`float32`的元素的`numpy.ndarray`。在此转换过程中，`None`元素将变成`numpy.nan`。