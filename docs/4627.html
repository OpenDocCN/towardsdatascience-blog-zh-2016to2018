<html>
<head>
<title>Word embeddings for sentiment analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于情感分析的词嵌入</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/word-embeddings-for-sentiment-analysis-65f42ea5d26e?source=collection_archive---------1-----------------------#2018-08-27">https://towardsdatascience.com/word-embeddings-for-sentiment-analysis-65f42ea5d26e?source=collection_archive---------1-----------------------#2018-08-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="gh gi ju"><img src="../Images/6f7dbe09c09a1aaaa443b17905fc073a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u9pwb9JShvDIU7j1G9iszQ.jpeg"/></div></div></figure><p id="c45c" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">当对单词应用一键编码时，我们最终得到高维度的稀疏(包含许多零)向量。在大型数据集上，这可能会导致性能问题。此外，独热编码没有考虑单词的语义。所以像<em class="le">飞机</em>和<em class="le">飞机</em>这样的词被认为是两种不同的特征。虽然我们知道它们有非常相似的意思。单词嵌入解决了这两个问题。</p><p id="ab79" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">单词嵌入是具有低得多的维度的密集向量。其次，词与词之间的语义关系反映在向量的距离和方向上。</p><p id="5985" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">我们将使用 Kaggle 上的<a class="ae lf" href="https://www.kaggle.com/crowdflower/twitter-airline-sentiment" rel="noopener ugc nofollow" target="_blank">推特在线感知数据集。该数据集包含大约 15K 条推文，具有 3 种可能的情绪类别(积极、消极和中立)。在我之前的帖子中，我们试图通过对单词进行标记和应用两个分类器来对推文进行分类。让我们看看单词嵌入是否能胜过它。</a></p><p id="27e6" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">阅读完本教程后，你将知道如何使用<strong class="ki ir"> Keras </strong>的嵌入层计算特定任务的单词嵌入。其次，我们将研究在更大的语料库上训练的单词嵌入是否可以提高我们的模型的准确性。</p><p id="3f7d" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">本教程的结构是:</p><ul class=""><li id="3a2c" class="lg lh iq ki b kj kk kn ko kr li kv lj kz lk ld ll lm ln lo bi translated">单词嵌入背后的直觉</li><li id="1523" class="lg lh iq ki b kj lp kn lq kr lr kv ls kz lt ld ll lm ln lo bi translated">项目设置</li><li id="9e68" class="lg lh iq ki b kj lp kn lq kr lr kv ls kz lt ld ll lm ln lo bi translated">数据准备</li><li id="6685" class="lg lh iq ki b kj lp kn lq kr lr kv ls kz lt ld ll lm ln lo bi translated">Keras 及其嵌入层</li><li id="c40b" class="lg lh iq ki b kj lp kn lq kr lr kv ls kz lt ld ll lm ln lo bi translated">预训练单词嵌入—手套</li><li id="8626" class="lg lh iq ki b kj lp kn lq kr lr kv ls kz lt ld ll lm ln lo bi translated">多维度训练词嵌入</li></ul><h1 id="67f1" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">单词嵌入背后的直觉</h1><p id="a70d" class="pw-post-body-paragraph kg kh iq ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld ij bi translated">在我们可以在分类器中使用单词之前，我们需要将它们转换成数字。一种方法是简单地将单词映射成整数。另一种方法是一键编码单词。然后，每条 tweet 可以表示为一个向量，其维数等于语料库中的单词(有限的一组)。tweet 中出现的单词在向量中的值为 1。所有其他向量值等于零。</p><p id="527c" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">单词嵌入的计算方式不同。每个单词被定位到一个<strong class="ki ir"> <em class="le">多维空间</em> </strong>。这个空间中的维度数量由数据科学家选择。您可以尝试不同的维度，看看什么能提供最好的结果。</p><p id="f443" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">单词的<strong class="ki ir"> <em class="le">向量值表示其在该嵌入空间中的位置</em> </strong>。同义词之间的距离很近，而意思相反的词之间的距离很大。您还可以对向量应用数学运算，这会产生语义上正确的结果。一个典型的例子就是<em class="le">王</em>和<em class="le">女</em>的单词嵌入之和产生了<em class="le">皇后</em>的单词嵌入。</p><h1 id="e987" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">项目设置</h1><p id="8b43" class="pw-post-body-paragraph kg kh iq ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld ij bi translated">让我们从导入这个项目的所有包开始。</p><pre class="jv jw jx jy gt mx my mz na aw nb bi"><span id="51d2" class="nc lv iq my b gy nd ne l nf ng">import pandas as pd<br/>import numpy as np<br/>import re<br/>import collections<br/>import matplotlib.pyplot as plt<br/>from pathlib import Path<br/>from sklearn.model_selection import train_test_split<br/>from nltk.corpus import stopwords<br/>from keras.preprocessing.text import Tokenizer<br/>from keras.preprocessing.sequence import pad_sequences<br/>from keras.utils.np_utils import to_categorical<br/>from sklearn.preprocessing import LabelEncoder<br/>from keras import models<br/>from keras import layers</span></pre><p id="acd1" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">我们定义了在整个项目中使用的一些参数和路径。大部分都是不言自明的。但是其他的将在代码中进一步解释。</p><pre class="jv jw jx jy gt mx my mz na aw nb bi"><span id="38f9" class="nc lv iq my b gy nd ne l nf ng">NB_WORDS = 10000  # Parameter indicating the number of words we'll put in the dictionary<br/>VAL_SIZE = 1000  # Size of the validation set<br/>NB_START_EPOCHS = 10  # Number of epochs we usually start to train with<br/>BATCH_SIZE = 512  # Size of the batches used in the mini-batch gradient descent<br/>MAX_LEN = 24  # Maximum number of words in a sequence<br/>GLOVE_DIM = 100  # Number of dimensions of the GloVe word embeddings<br/>root = Path('../')<br/>input_path = root / 'input/'<br/>ouput_path = root / 'output/'<br/>source_path = root / 'source/'</span></pre><p id="d6b9" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">在这段代码中，我们还将使用一些帮助函数进行数据准备、建模和可视化。这里没有显示这些函数定义，以避免博客文章混乱。你可以随时参考 Github 里的<a class="ae lf" href="https://github.com/bertcarremans/TwitterUSAirlineSentiment/blob/master/source/Using%20Word%20Embeddings%20for%20Sentiment%20Analysis.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本看代码。</a></p><h1 id="a875" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">数据准备</h1><h2 id="a278" class="nc lv iq bd lw nh ni dn ma nj nk dp me kr nl nm mi kv nn no mm kz np nq mq nr bi translated">读取数据和清理</h2><p id="9d45" class="pw-post-body-paragraph kg kh iq ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld ij bi translated">我们读入包含 tweets 的 CSV 文件，并对其索引进行随机排序。之后，我们删除停用词和@提及。分离出 10%的测试集，以根据新数据评估模型。</p><pre class="jv jw jx jy gt mx my mz na aw nb bi"><span id="1d88" class="nc lv iq my b gy nd ne l nf ng">df = pd.read_csv(input_path / 'Tweets.csv')<br/>df = df.reindex(np.random.permutation(df.index))<br/>df = df[['text', 'airline_sentiment']]<br/>df.text = df.text.apply(remove_stopwords).apply(remove_mentions)<br/>X_train, X_test, y_train, y_test = train_test_split(df.text, df.airline_sentiment, test_size=0.1, random_state=37)</span></pre><h2 id="ddb4" class="nc lv iq bd lw nh ni dn ma nj nk dp me kr nl nm mi kv nn no mm kz np nq mq nr bi translated">将单词转换成整数</h2><p id="6b0a" class="pw-post-body-paragraph kg kh iq ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld ij bi translated">使用 Keras 的<strong class="ki ir"> <em class="le">标记器</em> </strong>，我们将推文转换成整数序列。我们把单词的数量限制在<strong class="ki ir"> <em class="le"> NB_WORDS </em> </strong>最常用的单词。此外，tweets 被一些过滤器清理，设置为小写，并在空格上分割。</p><pre class="jv jw jx jy gt mx my mz na aw nb bi"><span id="ece5" class="nc lv iq my b gy nd ne l nf ng">tk = Tokenizer(num_words=NB_WORDS,<br/>filters='!"#$%&amp;()*+,-./:;&lt;=&gt;?@[\]^_`{"}~\t\n',lower=True, split=" ")<br/>tk.fit_on_texts(X_train)<br/>X_train_seq = tk.texts_to_sequences(X_train)<br/>X_test_seq = tk.texts_to_sequences(X_test)</span></pre><h2 id="e0c9" class="nc lv iq bd lw nh ni dn ma nj nk dp me kr nl nm mi kv nn no mm kz np nq mq nr bi translated">等长序列</h2><p id="4548" class="pw-post-body-paragraph kg kh iq ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld ij bi translated">每批都需要提供等长的序列。我们用<strong class="ki ir"><em class="le">pad _ sequences</em></strong>方法实现了这一点。通过指定<strong class="ki ir"><em class="le">【maxlen】</em></strong>，序列或用零填充或截断。</p><pre class="jv jw jx jy gt mx my mz na aw nb bi"><span id="3e8d" class="nc lv iq my b gy nd ne l nf ng">X_train_seq_trunc = pad_sequences(X_train_seq, maxlen=MAX_LEN)<br/>X_test_seq_trunc = pad_sequences(X_test_seq, maxlen=MAX_LEN)</span></pre><h2 id="295d" class="nc lv iq bd lw nh ni dn ma nj nk dp me kr nl nm mi kv nn no mm kz np nq mq nr bi translated">编码目标变量</h2><p id="40a6" class="pw-post-body-paragraph kg kh iq ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld ij bi translated">目标类是需要转换成数字向量的字符串。这是通过 Sklearn 的<strong class="ki ir"> <em class="le"> LabelEncoder </em> </strong>和 Keras 的<strong class="ki ir"><em class="le">to _ categorial</em></strong>方法完成的。</p><pre class="jv jw jx jy gt mx my mz na aw nb bi"><span id="798f" class="nc lv iq my b gy nd ne l nf ng">le = LabelEncoder()<br/>y_train_le = le.fit_transform(y_train)<br/>y_test_le = le.transform(y_test)<br/>y_train_oh = to_categorical(y_train_le)<br/>y_test_oh = to_categorical(y_test_le)</span></pre><h2 id="628f" class="nc lv iq bd lw nh ni dn ma nj nk dp me kr nl nm mi kv nn no mm kz np nq mq nr bi translated">分离验证集</h2><p id="8d67" class="pw-post-body-paragraph kg kh iq ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld ij bi translated">从训练数据中，我们分离出 10%的验证集用于训练。</p><pre class="jv jw jx jy gt mx my mz na aw nb bi"><span id="05ae" class="nc lv iq my b gy nd ne l nf ng">X_train_emb, X_valid_emb, y_train_emb, y_valid_emb = train_test_split(X_train_seq_trunc, y_train_oh, test_size=0.1, random_state=37)</span></pre><h1 id="b234" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">建模</h1><h2 id="d618" class="nc lv iq bd lw nh ni dn ma nj nk dp me kr nl nm mi kv nn no mm kz np nq mq nr bi translated">Keras 和嵌入层</h2><p id="e995" class="pw-post-body-paragraph kg kh iq ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld ij bi translated">Keras 提供了一种将每个单词转换成多维向量的便捷方法。这可以用<strong class="ki ir"> <em class="le">嵌入</em> </strong>层来完成。它将计算单词嵌入(或使用预先训练的嵌入)并在字典中查找每个单词以找到其矢量表示。这里我们将训练 8 维的单词嵌入。</p><pre class="jv jw jx jy gt mx my mz na aw nb bi"><span id="57aa" class="nc lv iq my b gy nd ne l nf ng">emb_model = models.Sequential()<br/>emb_model.add(layers.Embedding(NB_WORDS, 8, input_length=MAX_LEN))<br/>emb_model.add(layers.Flatten())<br/>emb_model.add(layers.Dense(3, activation='softmax'))<br/>emb_history = deep_model(emb_model, X_train_emb, y_train_emb, X_valid_emb, y_valid_emb)</span></pre><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="gh gi ns"><img src="../Images/44d6cac8f275ef50ee1a17ad67f7670e.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/0*-XjJ4DTQ5RQ8jZOF"/></div></div></figure><p id="5121" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">我们有大约 74%的验证准确率。推文字数比较低，所以这个结果还是比较不错的。通过比较训练和验证损失，我们看到模型从时期 6 开始<strong class="ki ir">过度拟合</strong>。</p><p id="4630" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">在之前的一篇文章中，我讨论了我们如何避免过度拟合。如果你想深入研究这个话题，你可能想读一下。</p><p id="c712" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">当我们在所有数据(包括验证数据，但不包括测试数据)上训练模型并将时期数设置为 6 时，我们得到 78%的测试准确度。这个测试结果相当好，但是让我们看看我们是否可以通过预先训练的单词嵌入来改进。</p><pre class="jv jw jx jy gt mx my mz na aw nb bi"><span id="f1a3" class="nc lv iq my b gy nd ne l nf ng">emb_results = test_model(emb_model, X_train_seq_trunc, y_train_oh, X_test_seq_trunc, y_test_oh, 6)<br/>print('/n')<br/>print('Test accuracy of word embeddings model: {0:.2f}%'.format(emb_results[1]*100))</span></pre><h2 id="c850" class="nc lv iq bd lw nh ni dn ma nj nk dp me kr nl nm mi kv nn no mm kz np nq mq nr bi translated">预训练单词嵌入—手套</h2><p id="dccb" class="pw-post-body-paragraph kg kh iq ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld ij bi translated">因为训练数据不是很大，所以模型可能无法学习用于情感分析的良好嵌入。或者，我们可以加载建立在更大的训练数据上的预训练单词嵌入。</p><p id="9209" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated"><a class="ae lf" href="https://nlp.stanford.edu/projects/glove/" rel="noopener ugc nofollow" target="_blank">手套数据库</a>包含多个预训练的单词嵌入，以及在推文 上训练的更具体的<strong class="ki ir"> <em class="le">嵌入。所以这可能对手头的任务有用。</em></strong></p><p id="7b3d" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">首先，我们将单词嵌入放在字典中，其中键是单词，值是单词嵌入。</p><pre class="jv jw jx jy gt mx my mz na aw nb bi"><span id="360c" class="nc lv iq my b gy nd ne l nf ng">glove_file = 'glove.twitter.27B.' + str(GLOVE_DIM) + 'd.txt'<br/>emb_dict = {}<br/>glove = open(input_path / glove_file)<br/>for line in glove:<br/>    values = line.split()<br/>    word = values[0]<br/>    vector = np.asarray(values[1:], dtype='float32')<br/>    emb_dict[word] = vector<br/>glove.close()</span></pre><p id="f6df" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">通过将手套嵌入加载到字典中，我们可以在航空公司 tweets 的语料库中查找每个单词的嵌入。这些将被存储在一个形状为<strong class="ki ir"> <em class="le"> NB_WORDS </em> </strong>和<strong class="ki ir"> <em class="le"> GLOVE_DIM </em> </strong>的矩阵中。如果在手套字典中找不到某个单词，则该单词的单词嵌入值为零。</p><pre class="jv jw jx jy gt mx my mz na aw nb bi"><span id="146b" class="nc lv iq my b gy nd ne l nf ng">emb_matrix = np.zeros((NB_WORDS, GLOVE_DIM))<br/>for w, i in tk.word_index.items():<br/>    if i &lt; NB_WORDS:<br/>        vect = emb_dict.get(w)<br/>        if vect is not None:<br/>        emb_matrix[i] = vect<br/>    else:<br/>        break</span></pre><p id="10e6" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">然后，我们指定模型，就像我们对上面的模型所做的那样。</p><pre class="jv jw jx jy gt mx my mz na aw nb bi"><span id="82bb" class="nc lv iq my b gy nd ne l nf ng">glove_model = models.Sequential()<br/>glove_model.add(layers.Embedding(NB_WORDS, GLOVE_DIM, input_length=MAX_LEN))<br/>glove_model.add(layers.Flatten())<br/>glove_model.add(layers.Dense(3, activation='softmax'))</span></pre><p id="c506" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">在嵌入层(这里是第 0 层)中，我们<strong class="ki ir"> <em class="le">将单词的权重</em> </strong>设置为在手套单词嵌入中找到的权重。通过将<strong class="ki ir"> <em class="le">可训练</em> </strong>设置为假，我们确保手套单词嵌入不能被改变。之后，我们运行模型。</p><pre class="jv jw jx jy gt mx my mz na aw nb bi"><span id="3f35" class="nc lv iq my b gy nd ne l nf ng">glove_model.layers[0].set_weights([emb_matrix])<br/>glove_model.layers[0].trainable = False<br/>glove_history = deep_model(glove_model, X_train_emb, y_train_emb, X_valid_emb, y_valid_emb)</span></pre><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/b71b9d7cbc15bb412a616cb0164cbb74.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/0*uhsGcl8UG_JYUycb"/></div></figure><p id="c221" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">在 3 个时期之后，模型过拟合得很快。此外，与在训练数据上训练的嵌入相比，验证准确度较低。</p><pre class="jv jw jx jy gt mx my mz na aw nb bi"><span id="3800" class="nc lv iq my b gy nd ne l nf ng">glove_results = test_model(glove_model, X_train_seq_trunc, y_train_oh, X_test_seq_trunc, y_test_oh, 3)<br/>print('/n')<br/>print('Test accuracy of word glove model: {0:.2f}%'.format(glove_results[1]*100))</span></pre><p id="72bd" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">作为最后一个练习，让我们看看当我们用与手套数据相同的维数训练嵌入时会得到什么结果。</p><h2 id="abf2" class="nc lv iq bd lw nh ni dn ma nj nk dp me kr nl nm mi kv nn no mm kz np nq mq nr bi translated">多维度训练单词嵌入</h2><p id="bd55" class="pw-post-body-paragraph kg kh iq ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld ij bi translated">我们将用与手套嵌入相同的维数训练单词嵌入(即 GLOVE_DIM)。</p><pre class="jv jw jx jy gt mx my mz na aw nb bi"><span id="9811" class="nc lv iq my b gy nd ne l nf ng">emb_model2 = models.Sequential()<br/>emb_model2.add(layers.Embedding(NB_WORDS, GLOVE_DIM, input_length=MAX_LEN))<br/>emb_model2.add(layers.Flatten())<br/>emb_model2.add(layers.Dense(3, activation='softmax'))<br/>emb_history2 = deep_model(emb_model2, X_train_emb, y_train_emb, X_valid_emb, y_valid_emb)</span></pre><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="gh gi ns"><img src="../Images/1d6785d5f1e73f68003d525c0d67bede.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/0*boJxTu7msbxWzexm"/></div></div></figure><pre class="jv jw jx jy gt mx my mz na aw nb bi"><span id="ffc9" class="nc lv iq my b gy nd ne l nf ng">emb_results2 = test_model(emb_model2, X_train_seq_trunc, y_train_oh, X_test_seq_trunc, y_test_oh, 3)<br/>print('/n')<br/>print('Test accuracy of word embedding model 2: {0:.2f}%'.format(emb_results2[1]*100))</span></pre><p id="609c" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">在测试数据上，我们得到了很好的结果，但我们并没有优于使用 CountVectorizer 的 LogisticRegression。所以还是有提升的空间。</p><h1 id="499e" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">结论</h1><p id="d884" class="pw-post-body-paragraph kg kh iq ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld ij bi translated">最好的结果是利用在可用数据上训练的 100 维单词嵌入来实现的。这甚至超过了在更大的 Twitter 语料库上训练的单词嵌入的使用。</p><p id="2f2b" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">到目前为止，我们只是在展平的嵌入物上加了一个致密层。通过这样做，<strong class="ki ir"> <em class="le">我们不考虑 tweet 中单词</em> </strong>之间的关系。这可以用递归神经网络或 1D 卷积网络来实现。但这是未来文章的内容。</p></div></div>    
</body>
</html>