<html>
<head>
<title>Introduction to Neural Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">神经网络导论</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-neural-networks-ead8ec1dc4dd?source=collection_archive---------2-----------------------#2017-07-01">https://towardsdatascience.com/introduction-to-neural-networks-ead8ec1dc4dd?source=collection_archive---------2-----------------------#2017-07-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dc9d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">神经网络基础</h2></div><h2 id="0c11" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">什么是神经网络</h2><p id="a41e" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">神经网络，通常称为人工神经网络(ANN ),是机器学习(ML)问题中对人脑功能的模拟。人工神经网络不能解决所有出现的问题，但可以和其他技术一起为各种 ML 任务提供更好的结果。人工神经网络最常见的用途是聚类和分类，它们也可用于回归任务，但在这方面还有更好的方法。</p><h1 id="5716" class="lu kg iq bd kh lv lw lx kk ly lz ma kn jw mb jx kr jz mc ka kv kc md kd kz me bi translated">人工神经网络的构建模块和功能</h1><h2 id="84ba" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">神经元</h2><p id="75df" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">这是神经网络的构建单元，它模仿人类神经元的功能。典型的神经网络使用 sigmoid 函数，如下所示。使用这个函数主要是因为它能够根据<em class="mf"> f(x) </em>本身写出导数，这在最小化误差时很方便。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/45c4c15571fff0f8161fc2ad0ff57acd.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*rOCQW475Dw95DqaVUoYjiw.png"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">sigmoid function</figcaption></figure></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mz"><img src="../Images/229d01e4fc175a31db63f3d6ba21213e.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*bThdYdLA8xdnVnO4V773Ig.jpeg"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Neuron</figcaption></figure><pre class="mh mi mj mk gt ne nf ng nh aw ni bi"><span id="72e1" class="kf kg iq nf b gy nj nk l nl nm"><em class="mf">z</em> =  ∑ <em class="mf">w</em>×<em class="mf">x<br/>y = sigmoid(z)</em></span><span id="5295" class="kf kg iq nf b gy nn nk l nl nm"><em class="mf">w</em> = weights<br/><em class="mf">x</em> = inputs</span></pre><p id="0225" class="pw-post-body-paragraph lb lc iq ld b le no jr lg lh np ju lj ko nq ll lm ks nr lo lp kw ns lr ls lt ij bi translated">神经元按层连接，因此一层可以与其他层通信，形成神经网络。除了输入和输出层之外的内层称为隐藏层。一层的输出被馈送到另一层的输入。</p><h2 id="f23a" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">调整重量</h2><p id="de9a" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">人工神经网络的学习任务是调整权重以最小化误差。这是通过误差反向传播实现的。对于使用 Sigmoid 函数作为激活函数的简单神经元，误差可以如下所示。让我们考虑一种一般情况，其中权重称为向量 W，输入称为向量 x。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nt"><img src="../Images/5a55875ddf505578d526e0c0a1665921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2t1op17QI-UcIjcpRBxwcA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Error calculation and weight adjustment</figcaption></figure><p id="9491" class="pw-post-body-paragraph lb lc iq ld b le no jr lg lh np ju lj ko nq ll lm ks nr lo lp kw ns lr ls lt ij bi translated">从上面的等式中，我们可以概括出权重调整，令人惊讶的是，您会注意到这仅需要相邻神经元级别的细节。因此，这是一种稳健的学习机制，称为反向传播算法。从输出节点开始反向传播，更新前一个神经元的权重。</p><h1 id="54f9" class="lu kg iq bd kh lv lw lx kk ly lz ma kn jw mb jx kr jz mc ka kv kc md kd kz me bi translated">带有简单 javascript 库的演示应用程序</h1><p id="9bae" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">让我们编写一个简单的应用程序，它将使用两个图像进行训练，并对给定的图像应用过滤器。以下是训练过程的源图像和目标图像。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nu"><img src="../Images/e9077f5c36107eba29d26eb093f9821c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LnMT9fz-kTD0i1j76Wmcbg.jpeg"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Source image(left) and target image(right)</figcaption></figure><p id="7246" class="pw-post-body-paragraph lb lc iq ld b le no jr lg lh np ju lj ko nq ll lm ks nr lo lp kw ns lr ls lt ij bi translated">我使用了一个人工神经网络，它使用反向传播来调整误差。训练的意图是找到一个函数<em class="mf"> f(红、绿、蓝、阿尔法)</em>来匹配目标颜色变换。使用源图像的几种颜色调整来制作目标图像。让我们看看代码。</p><h2 id="7f17" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Package.json</h2><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="7e89" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Index.ts</h2><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="nv nw l"/></div></figure><pre class="mh mi mj mk gt ne nf ng nh aw ni bi"><span id="186a" class="kf kg iq nf b gy nj nk l nl nm">$ npm install<br/>$ npm start</span></pre><p id="0e4e" class="pw-post-body-paragraph lb lc iq ld b le no jr lg lh np ju lj ko nq ll lm ks nr lo lp kw ns lr ls lt ij bi translated">源图像应为<code class="fe nx ny nz nf b">input_image_train.jpg</code>，目标图像名称应为<code class="fe nx ny nz nf b">output_image_train.jpg</code>。要应用滤镜的图像文件应该是<code class="fe nx ny nz nf b">test.jpg</code>，新的图像文件将保存为<code class="fe nx ny nz nf b">out.jpg</code>。以下是我用训练好的模型过滤的一些示例图像。</p><h2 id="5706" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">样本输出</h2><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi oa"><img src="../Images/d4f2a50fea917cdd6e3082931d550c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QD1gkFs-TQWJ9X8TJN1nlg.jpeg"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Input images (left) and output images(right)</figcaption></figure><blockquote class="ob oc od"><p id="4ff6" class="lb lc mf ld b le no jr lg lh np ju lj oe nq ll lm of nr lo lp og ns lr ls lt ij bi translated">酷吧？训练需要几秒钟，但过滤是即时的。如果需要，您可以保存模型以供将来使用。这在现实世界的应用中是非常智能的。</p></blockquote></div></div>    
</body>
</html>