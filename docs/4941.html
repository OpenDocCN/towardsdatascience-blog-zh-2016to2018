<html>
<head>
<title>Logistic Regression: A Simplified Approach Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逻辑回归:使用 Python 的简化方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/logistic-regression-a-simplified-approach-using-python-c4bc81a87c31?source=collection_archive---------3-----------------------#2018-09-17">https://towardsdatascience.com/logistic-regression-a-simplified-approach-using-python-c4bc81a87c31?source=collection_archive---------3-----------------------#2018-09-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c20d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">逻辑回归的目的是什么？</h2></div><p id="24e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在逻辑回归中，我们希望用一个或多个自变量(X)来模拟因变量(Y)。是<strong class="kh ir">分类</strong>的方法。该算法用于<strong class="kh ir">分类</strong>的因变量。使用一个函数对 y 进行建模，该函数为 x 的所有值提供介于 0 和 1 之间的输出。在逻辑回归中，使用了<strong class="kh ir"> Sigmoid </strong>(也称为逻辑)函数。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/2de6f536180b8f1a4b8913d59a2d297d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zfH9946AssCx4vzjaizWeg.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">The Sigmoid Function</figcaption></figure><h2 id="1788" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">使用混淆矩阵的模型评估</h2><p id="2076" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在我们对一些训练数据训练了逻辑回归模型之后，我们将评估模型对一些测试数据的性能。为此，我们使用<strong class="kh ir">混淆矩阵</strong>。<strong class="kh ir"> </strong>混淆矩阵是一个表格，通常用于描述分类模型对一组真实值已知的测试数据的性能。下面给出了一个混淆矩阵。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/14906553dd1b9724ae80078fc865973c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*9m6vNp6hLpWXNpPXF0kykQ.png"/></div></figure><p id="cfb3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，TP 代表真正值，这是我们预测为是，而实际值为真的情况。TN 代表 True Negative，这是我们预测为 no 而实际值为 false 的情况。FP 代表假阳性，即我们预测为是而实际值为假的情况。FN 代表假阴性，即我们预测为否而实际值为真的情况。</p><h2 id="d463" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">我们从混淆矩阵中推断出什么？</h2><p id="7381" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">混淆矩阵帮助我们确定模型预测正确的频率，或者换句话说，模型的准确性。根据上表，它由下式给出:</p><p id="4e87" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(TP + TN ) /总计= 100 + 50 / 165 = 0.91</p><p id="5c10" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着该模型 91%是正确的。混淆矩阵也用于测量误差率，误差率由下式给出:</p><p id="f331" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(FP + FN ) /总计= 15 /165 = 0.09</p><p id="6d97" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模型有 9%的误差。</p><p id="e29f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将处理 python 中建模逻辑回归的非常简单的步骤。</p><h2 id="b6e4" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">带详细解释的 Python 代码</h2><p id="6eed" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们将观察数据、分析数据、可视化数据、清理数据、构建逻辑回归模型、拆分成训练和测试数据、进行预测并最终对其进行评估。这些都会一步一步来。我们将要处理的数据是在 kaggle.com<a class="ae mq" href="http://kaggle.com" rel="noopener ugc nofollow" target="_blank">可用的‘泰坦尼克号数据集’。这是一个非常著名的数据集，通常是学生学习基于分类的机器学习的第一步。我们试图预测分类:生存或死亡</a></p><p id="903f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们将导入 numpy 和 pandas 库:</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="e331" class="lr ls iq ms b gy mw mx l my mz">import numpy as np<br/>import pandas as pd</span></pre><p id="69e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们进行可视化导入:</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="fec4" class="lr ls iq ms b gy mw mx l my mz">import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>%matplotlib inline</span></pre><p id="ec1f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将继续把泰坦尼克号的数据集导入熊猫的数据框架。之后，我们将检查数据帧的头部，以便清楚地了解数据帧中的所有列。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="a5a4" class="lr ls iq ms b gy mw mx l my mz">train=pd.read_csv('titanic_train.csv')<br/>train.head()</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi na"><img src="../Images/ecd895cbeb35ec34479da25ac8e1e1c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0dL2N-z448pFUPGT40zigQ.png"/></div></div></figure><p id="1d1d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们遇到的大多数数据都有缺失数据。我们将检查丢失的数据，也将它们可视化以获得更好的想法并删除它们。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="1d3a" class="lr ls iq ms b gy mw mx l my mz">train.isnull()</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nb"><img src="../Images/283aab0af66cc7d85f62125bed284c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1lM3ONJ1m-DUVpL50rWedw.png"/></div></div></figure><p id="18fe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我们找到了布尔值。True 表示值为 null，False 表示值为 False，反之亦然。由于有大量的数据，我们使用 seaborn 库来可视化空值。那样的话，我们的任务就容易多了。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="18d4" class="lr ls iq ms b gy mw mx l my mz">sns.heatmap(train.isnull())</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/1f8352e67129e78beeec7323eb17af28.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*dnGwQ0X9zD0MMaJvHQ3iGw.png"/></div></figure><p id="13bb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">年龄和客舱列具有空值。我在之前的<a class="ae mq" href="https://code.likeagirl.io/how-to-deal-with-na-values-in-a-dataframe-using-python-afb96d19936b" rel="noopener ugc nofollow" target="_blank">博客</a>中已经处理过 NA 值的处理问题。请看看它。</p><p id="c3b6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">摆弄数据并充分利用可视化库来享受数据带来的乐趣总是一个好习惯。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="8bed" class="lr ls iq ms b gy mw mx l my mz">sns.countplot(x='Survived',data=train)</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/d0986aba0a126a24dcd6845d7233f2db.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*6BNOLKWJQCjzyCHiqgS8Cw.png"/></div></figure><p id="320d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个计数图，显示了幸存的人数，这是我们的目标变量。此外，我们可以根据性别和乘客等级绘制计数图。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="2a1c" class="lr ls iq ms b gy mw mx l my mz">sns.countplot(x='Survived',hue='Sex',data=train)</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/871d319afbb2bf67b93c20ff02b71e01.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*A66B0xB6gfZ9Nb9hTwtMiA.png"/></div></figure><p id="5927" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我们看到一种趋势，即女性比男性存活的更多。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="3734" class="lr ls iq ms b gy mw mx l my mz">sns.countplot(x='Survived',hue='Pclass',data=train)</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/157fbeea24bf1451a5c466c6f4b9e28b.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*CXx5sqNsg2VaIWtqH9w7yQ.png"/></div></figure><p id="2330" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从上面的情节可以推断，属于 3 班的乘客死的最多。</p><p id="e9fe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用更多的方式来可视化数据。然而，我不在这里讨论它们，因为我们需要到达模型构建的步骤。</p><h2 id="c864" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">数据清理</h2><p id="1ad0" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们希望填充缺失的年龄数据，而不是仅仅删除缺失的年龄数据行。一种方法是填写所有乘客的平均年龄(插补)。然而，我们可以更聪明地处理这个问题，按乘客级别检查平均年龄。例如:</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="a3ba" class="lr ls iq ms b gy mw mx l my mz">plt.figure(figsize=(12, 7))<br/>sns.boxplot(x='Pclass',y='Age',data=train,palette='winter')</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ng"><img src="../Images/dce19158bc16a659c9e45af903088861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GTo6FKa5_M3M0FBdApRpIQ.png"/></div></div></figure><p id="af7b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，在较高的阶层中，较富裕的乘客往往年龄较大，这是有道理的。我们将根据年龄的 Pclass 使用这些平均年龄值进行估算。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="b898" class="lr ls iq ms b gy mw mx l my mz">def impute_age(cols):<br/>    Age = cols[0]<br/>    Pclass = cols[1]<br/>    <br/>    if pd.isnull(Age):</span><span id="b788" class="lr ls iq ms b gy nh mx l my mz">if Pclass == 1:<br/>            return 37</span><span id="4e5d" class="lr ls iq ms b gy nh mx l my mz">elif Pclass == 2:<br/>            return 29</span><span id="1bbe" class="lr ls iq ms b gy nh mx l my mz">else:<br/>            return 24</span><span id="b02a" class="lr ls iq ms b gy nh mx l my mz">else:<br/>        return Age</span></pre><p id="94be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在应用那个函数！</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="84cd" class="lr ls iq ms b gy mw mx l my mz">train['Age'] = train[['Age','Pclass']].apply(impute_age,axis=1)</span></pre><p id="33d0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们再检查一下热图。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="7c7e" class="lr ls iq ms b gy mw mx l my mz">sns.heatmap(train.isnull(),yticklabels=False,cbar=False)</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/3e8149cc3f350339ef3f4bd22ecc7d7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*du9VrCPuRYJncGS8Q56JHw.png"/></div></figure><p id="318c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了！让我们继续下去，并放弃机舱柱。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="7548" class="lr ls iq ms b gy mw mx l my mz">train.drop('Cabin',axis=1,inplace=True)</span></pre><h2 id="20d1" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">转换分类特征</h2><p id="7722" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们需要使用 pandas 将分类特征转换为虚拟变量！否则，我们的机器学习算法将无法直接将这些特征作为输入。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="5970" class="lr ls iq ms b gy mw mx l my mz">train.info()</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/1f2e2daa3e959d387516120682356710.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*TEOhJVpjQF74n8ny-6WtMg.png"/></div></figure><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="89fc" class="lr ls iq ms b gy mw mx l my mz">sex = pd.get_dummies(train['Sex'],drop_first=True)<br/>embark = pd.get_dummies(train['Embarked'],drop_first=True)</span></pre><p id="4a4f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我们正在模拟性别和登上专栏。在虚拟化之后，我们将删除剩余的不需要的列。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="608a" class="lr ls iq ms b gy mw mx l my mz">train.drop(['Sex','Embarked','Name','Ticket'],axis=1,inplace=True)</span></pre><p id="eb2c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将把新的 sex 和 apolloed 列连接到 dataframe。</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="d7da" class="lr ls iq ms b gy mw mx l my mz">train = pd.concat([train,sex,embark],axis=1)</span></pre><p id="2c7b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，数据帧看起来像这样:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/c07a7b2b59508128792a7c99dfcae0fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*ZW85b4rHYhxy5rpFXDQ4rQ.png"/></div></figure><h2 id="c254" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">测试列车分离</h2><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="a38b" class="lr ls iq ms b gy mw mx l my mz">from sklearn.model_selection import train_test_split</span><span id="03b3" class="lr ls iq ms b gy nh mx l my mz">X_train, X_test, y_train, y_test = train_test_split(train.drop('Survived',axis=1), <br/>                                                    train['Survived'], test_size=0.30, <br/>                                                    random_state=101)</span></pre><h2 id="f091" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">训练和预测</h2><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="9ad5" class="lr ls iq ms b gy mw mx l my mz">from sklearn.linear_model import LogisticRegression<br/>logmodel = LogisticRegression()<br/>logmodel.fit(X_train,y_train)<br/>predictions = logmodel.predict(X_test)</span></pre><h2 id="7c18" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">估价</h2><p id="2e78" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们可以使用分类报告来检查精确度、召回率、f1 分数</p><pre class="lc ld le lf gt mr ms mt mu aw mv bi"><span id="4ec9" class="lr ls iq ms b gy mw mx l my mz">from sklearn.metrics import classification_report<br/>print(classification_report(y_test,predictions))</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/06dd404b56e5339db739ee795b8d278c.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*MIJRmKd2wQ3uIaAt2ZF_7w.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">The Classification Report</figcaption></figure></div></div>    
</body>
</html>