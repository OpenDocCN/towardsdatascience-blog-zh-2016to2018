<html>
<head>
<title>Pandas tips and tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫的提示和技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pandas-tips-and-tricks-33bcc8a40bb9?source=collection_archive---------0-----------------------#2017-08-13">https://towardsdatascience.com/pandas-tips-and-tricks-33bcc8a40bb9?source=collection_archive---------0-----------------------#2017-08-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1fe7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章包括一些有用的提示，告诉你如何使用Pandas对大型数据集进行有效的预处理和特征工程。</p><h1 id="6206" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">熊猫<a class="ae lj" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html" rel="noopener ugc nofollow" target="_blank"> Ufuncs </a>以及为什么它们比应用命令好得多</h1><p id="7eb4" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">Pandas有一个<strong class="jp ir">应用</strong>函数，可以让你对一列中的所有值应用任何函数。注意，<strong class="jp ir">应用</strong>比循环的<strong class="jp ir"> python快一点点！这就是为什么最推荐使用pandas built<a class="ae lj" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">ufuncs</strong></a><strong class="jp ir"/>对列应用预处理任务(如果有合适的<strong class="jp ir"> ufunc </strong>可用于您的任务)<strong class="jp ir">。</strong><a class="ae lj" href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">Ufuncs</strong></a><strong class="jp ir">，</strong>是用C实现的特殊函数(基于numpy库)，这也是它们高效的原因。我们将提到的有用的ufuncs有:。<strong class="jp ir">差异，。移位，。累计。累计，。str命令</strong>(作用于字符串)<strong class="jp ir">，。dt命令</strong>(作用于日期)<strong class="jp ir"> </strong>等等。</strong></p><h1 id="001e" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">示例数据集—夏季活动</h1><p id="49cf" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我将用不同的人名、它们的夏季活动和它们相应的时间戳来演示熊猫的把戏。一个人可以在不同的时间戳中进行多个活动。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/67b149a2e4af05143e4db562afe77ff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*PN5dXOhrBXTOloUzHjdF5g.png"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Randomly generated data with summer activities</figcaption></figure><p id="52cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们的目标是预测，基于给定的数据集，谁是数据集中最有趣的人:)。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/1e1fb0220ba8ec8ef52eda407f01f7c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*l_sCB-FYi0gYAaBZRjQZlg.png"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Fun Fun Fun!</figcaption></figure><h1 id="d5ce" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">1.字符串命令</h1><p id="9294" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">对于字符串操作，最推荐使用Pandas <strong class="jp ir">字符串</strong> <strong class="jp ir">命令</strong>(它们是<strong class="jp ir">ufunc)。</strong></p><p id="b4d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，您可以使用<strong class="jp ir"> .str.split </strong>和expand=True将包含一个人的全名的列拆分为包含名和姓的两列。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/36117a98190567ee6450141853bb1641.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*aSssK11cIb-CZPf_bz8SoA.png"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Name column before split</figcaption></figure><pre class="lq lr ls lt gt md me mf mg aw mh bi"><span id="5253" class="mi km iq me b gy mj mk l ml mm">df[‘name’] = df.name.str.split(" ", expand=True)</span></pre><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/a3a56adf0a3f1dee82d290a6b8789030.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*EjErygqNrK450e3qtj5RMA.png"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Name column after split</figcaption></figure><p id="713f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，您可以使用<strong class="jp ir"> .str.replace </strong>和合适的<strong class="jp ir"> regex </strong>有效清洁任何管柱<a class="ae lj" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.str.replace.html" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="10bc" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">2.分组依据和值计数</h1><p id="5421" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated"><strong class="jp ir"> Groupby </strong>是一个非常强大的熊猫方法。您可以按一列分组，并使用<strong class="jp ir"> value_counts </strong>对另一列的值进行计数。使用<strong class="jp ir"> groupby </strong>和<strong class="jp ir"> value_counts </strong>我们可以计算每个人做了多少活动。</p><pre class="lq lr ls lt gt md me mf mg aw mh bi"><span id="7941" class="mi km iq me b gy mj mk l ml mm">df.groupby('name')['activity'].value_counts()</span></pre><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/61942ed92910c2005bab65eaa690419f.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*Ohu20DT3UliQe2T3PfoKlQ.png"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Group by person name and value counts for activities</figcaption></figure><p id="2c55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是<a class="ae lj" href="https://pandas.pydata.org/pandas-docs/stable/advanced.html" rel="noopener ugc nofollow" target="_blank">多索引，</a>pandas数据框架中的一个有价值的技巧，它允许我们在数据框架中有几级索引层次。在这种情况下，人名是索引的第0层，而活动在第1层。</p><h1 id="78b3" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak"> 3。拆垛</strong></h1><p id="4e79" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们还可以通过在上面的代码中应用unstack来为每个人的夏季活动计数创建特性。<strong class="jp ir">取消堆叠</strong>将行切换到列，以获取活动计数作为特征。通过执行<strong class="jp ir"> unstack </strong>，我们将索引的最后一级转换为列。所有的活动值现在将成为数据帧的列，当一个人没有进行某项活动时，该功能将获得一个值。<strong class="jp ir"> Fillna </strong>用0填充所有这些缺失的值(人员没有访问的活动)。</p><pre class="lq lr ls lt gt md me mf mg aw mh bi"><span id="2c48" class="mi km iq me b gy mj mk l ml mm">df.groupby('name')['activity'].value_counts().unstack().fillna(0)</span></pre><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/044ed48a7b9d230ae49e8fd5fdd77177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*Z8P5qCNaUpSlFFJ1EAEAgg.png"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Activity count in columns</figcaption></figure><h1 id="5585" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">3.groupby、diff、shift和loc +提高效率的绝佳技巧</h1><p id="aa31" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">了解个人活动之间的时差对于预测谁是最有趣的人来说是非常有趣的。一个人在聚会上混了多久？他/她在海滩逗留了多长时间？这可能对我们有用，取决于活动。</p><p id="e47d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">计算时差的最直接的方法是通过人名对<strong class="jp ir">分组，然后使用<strong class="jp ir"> diff </strong>计算时间戳字段的时差():</strong></p><pre class="lq lr ls lt gt md me mf mg aw mh bi"><span id="961e" class="mi km iq me b gy mj mk l ml mm">df = df.sort_values(by=['name','timestamp'])<br/>df['time_diff'] = df.groupby('name')['timestamp'].diff()</span></pre><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mq"><img src="../Images/f918f49bddd7cc61828a8a2129680f4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jgZy5t49JORxmV9JgyGxRQ.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Calculating the time difference between person activities to get the duration of each activity</figcaption></figure><p id="4ed0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你有很多数据，并且你想节省一些时间(根据你的数据大小，这可以快10倍左右)，你可以跳过<strong class="jp ir"> groupby </strong>，在对数据排序后只做<strong class="jp ir"> diff </strong>，然后删除不相关的每个人的第一行。</p><pre class="lq lr ls lt gt md me mf mg aw mh bi"><span id="7f80" class="mi km iq me b gy mj mk l ml mm">df = df.sort_values(by=['name','timestamp'])<br/>df['time_diff'] = df['timestamp'].diff()<br/>df.loc[df.name != df.name.shift(), 'time_diff'] = None</span></pre><p id="337e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">BTW —有用的<strong class="jp ir">。Shift </strong>命令将所有列向下移动一个空格，这样我们就可以看到该列在哪一行发生了变化:df.name！=df.name.shift()。</p><p id="c895" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有<strong class="jp ir">。loc </strong>命令是为特定索引设置列值的最推荐方法。</p><p id="fdf7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要将time_diff更改为秒单位:</p><pre class="lq lr ls lt gt md me mf mg aw mh bi"><span id="7acb" class="mi km iq me b gy mj mk l ml mm">df['time_diff'] = df.time_diff.dt.total_seconds()</span></pre><p id="6e93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要获得每行的持续时间:</p><pre class="lq lr ls lt gt md me mf mg aw mh bi"><span id="7d14" class="mi km iq me b gy mj mk l ml mm">df[‘row_duration’] = df.time_diff.shift(-1)</span></pre><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mv"><img src="../Images/1805f42f078d87b2ea63f3c2599e99a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9j5rZ4hqlo9pyiPDXQr-3g.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Added duration per row</figcaption></figure><h1 id="77a9" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">4.累计和累计</h1><p id="fd6e" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">这是两个非常酷的Ufuncs，可以帮助你做很多事情。累计计数创建累计计数。例如，我们可以通过按人名分组，然后应用累计，只对每个人进行第二项活动。这将只是按顺序对活动进行计数。然后，我们可以通过do = = 1(或通过do = = 2的第三个活动)并在原始排序的数据帧上应用索引，为每个人仅获取第二个活动。</p><pre class="lq lr ls lt gt md me mf mg aw mh bi"><span id="e5fc" class="mi km iq me b gy mj mk l ml mm">df = df.sort_values(by=['name','timestamp'])</span><span id="97f6" class="mi km iq me b gy mw mk l ml mm">df2 = df[df.groupby(‘name’).cumcount()==1]</span></pre><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mx"><img src="../Images/42e1035b00f0408cad360e9d00ba7c6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9vTVpwe1R7ZzUTJxS2yd9Q.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">The second activity of each person</figcaption></figure><pre class="lq lr ls lt gt md me mf mg aw mh bi"><span id="d1e2" class="mi km iq me b gy mj mk l ml mm">df = df.sort_values(by=[‘name’,’timestamp’])</span><span id="71c2" class="mi km iq me b gy mw mk l ml mm">df2 = df[df.groupby(‘name’).cumcount()==2]</span></pre><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi my"><img src="../Images/223d520dbf322f181b257826fa6aacca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xOH2t1J9boWEthGqCb4-SA.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">The third activity of each person</figcaption></figure><p id="ffb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">累计只是一个数值单元格的累计汇总。例如，您可以将一个人在每项活动中花费的钱添加为附加单元格，然后使用以下公式汇总一个人在一天中每个时间花费的钱:</p><pre class="lq lr ls lt gt md me mf mg aw mh bi"><span id="0fbf" class="mi km iq me b gy mj mk l ml mm">df = df.sort_values(by=[‘name’,’timestamp’])</span><span id="171b" class="mi km iq me b gy mw mk l ml mm">df['money_spent_so_far'] = df.groupby(‘name’)['money_spent'].cumsum()</span></pre><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mz"><img src="../Images/df51e687bf51686b0de3f675596d0fcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x7n7NkS1uID9plfU7q9P8Q.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Money spent so far</figcaption></figure><h1 id="8e0a" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">5.用于测量活动持续时间的groupby、max、min</h1><p id="6694" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在第3部分，我们想知道每个人在每项活动中花费了多少时间。但是我们忽略了有时我们会得到一个活动的多个记录，而这个活动实际上是相同活动的继续。因此，为了获得实际的活动持续时间，我们应该测量从第一个连续活动出现到最后一个活动出现的时间。为此，我们需要标记活动的变化，并用活动编号标记每一行。我们将使用<strong class="jp ir">来做这件事。换档</strong>命令和<strong class="jp ir">。我们之前看到的cumsum </strong>命令。新活动是指活动发生变化<strong class="jp ir">或</strong>时，人员发生变化。</p><pre class="lq lr ls lt gt md me mf mg aw mh bi"><span id="ece5" class="mi km iq me b gy mj mk l ml mm">df['activity_change'] = (df.activity!=df.activity.shift()) | (df.name!=df.name.shift())</span></pre><p id="4176" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们将通过对每个用户进行分组并应用glorious来计算每行的活动数量。<strong class="jp ir">累计值</strong>:</p><pre class="lq lr ls lt gt md me mf mg aw mh bi"><span id="aea3" class="mi km iq me b gy mj mk l ml mm">df['activity_num'] = df.groupby('name')['activity_change'].cumsum()</span></pre><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi na"><img src="../Images/5fc9c32508c1f7e37fee710c56763bb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P_6Z_rQFoN32ivIovEEJ9g.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Add activity num for the activities which continues between rows</figcaption></figure><p id="c06a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以按如下方式计算每个活动的持续时间:按名称和活动编号(以及活动—这并不真正改变分组，但我们需要它具有活动名称)分组，并计算每行活动持续时间的总和:</p><pre class="lq lr ls lt gt md me mf mg aw mh bi"><span id="8a6e" class="mi km iq me b gy mj mk l ml mm">activity_duration = df.groupby(['name','activity_num','activity'])['activity_duration'].sum()</span></pre><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nb"><img src="../Images/69b4328df42374c544314eceacb17841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XktDjUTcGJWmVkM8lk_Bww.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">activity duration</figcaption></figure><p id="2632" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将返回某种timedelta类型的活动持续时间。您可以使用. dt.total_seconds获得以秒为单位的会话活动持续时间:</p><pre class="lq lr ls lt gt md me mf mg aw mh bi"><span id="5822" class="mi km iq me b gy mj mk l ml mm">activity_duration = activity_duration.dt.total_seconds()</span></pre><p id="e443" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，您可以使用如下命令计算每个人的最大/最小活动持续时间(或中位数或平均值):</p><pre class="lq lr ls lt gt md me mf mg aw mh bi"><span id="d681" class="mi km iq me b gy mj mk l ml mm">activity_duration = activity_duration.reset_index().groupby('name').max()</span></pre><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/1a4205cf67ad7513a0eefbd12fce4284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*hEoLdZ6xy30DbNvTK9WXHw.png"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Maximal activity duration per user</figcaption></figure><h1 id="d0d3" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">摘要</h1><p id="517b" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">这是一个短期的熊猫旅行，使用了一个夏季活动的数据集。希望你已经学会并喜欢它。祝你的下一个熊猫项目好运，享受这个夏天！</p></div></div>    
</body>
</html>