<html>
<head>
<title>The tale of missing values in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中缺失值的故事</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-tale-of-missing-values-in-python-c96beb0e8a9d?source=collection_archive---------1-----------------------#2018-01-06">https://towardsdatascience.com/the-tale-of-missing-values-in-python-c96beb0e8a9d?source=collection_archive---------1-----------------------#2018-01-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jw jx jy jz gh gi paragraph-image"><div class="gh gi jv"><img src="../Images/510e68c7bbf4ee2a60dcbfe2bccf7679.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*Z99d-xdvovtgao_ElVZDrA.png"/></div></figure><p id="5e5b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">想象一下，买一个装有 60 个巧克力样品的巧克力盒，里面有 15 种不同的独特形状的巧克力。不幸的是，打开巧克力盒子，你会发现两块空巧克力。你能准确地找到处理丢失的巧克力块的方法吗？我们应该假装丢失的巧克力并没有丢失。？应该把巧克力盒子还给卖家吗？是否应该去买另外两块巧克力来填补缺失的部分。或者，人们可以根据以前盒子中巧克力的排列和形状的经验来预测丢失的巧克力的形状，然后购买这种预测形状的巧克力。</p><figure class="lb lc ld le gt jz gh gi paragraph-image"><div class="gh gi la"><img src="../Images/03ff1bdeded0a4f2d37bb10b1eed8596.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*y-Gpt3EVnIWYp5D6dHKEJw.png"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk"><a class="ae lj" href="http://www.alphabetastats.com" rel="noopener ugc nofollow" target="_blank">http://www.alphabetastats.com</a></figcaption></figure><p id="c294" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了正确处理丢失的数据，数据科学家需要回答上面和其他一些令人头疼的问题。因此，这篇文章旨在阐明在我们的数据探索之旅中处理缺失值的几种方法。</p><p id="7bdf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现实世界中的数据很少是干净的和同质的。数据可能在数据提取或收集过程中丢失。缺少的值需要被处理，因为它们降低了我们的任何性能指标的质量。它还会导致错误的预测或分类，并且还会对所使用的任何给定模型造成高偏差。</p><p id="0a18" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">根据数据源的不同，丢失的数据会有不同的标识。熊猫总是把缺失的值识别为 NaN。但是，除非数据经过一定程度的预处理，否则分析师会遇到 NaN 这样的缺失值。缺失值可以显示为问号(？)或零(0)或负一(-1)或空白。因此，在编写任何机器学习算法之前，数据科学家总是首先执行探索性数据分析(EDA)是非常重要的。EDA 只是理解和了解我们的数据行为的试金石。</p><blockquote class="lk ll lm"><p id="a187" class="kc kd ln ke b kf kg kh ki kj kk kl km lo ko kp kq lp ks kt ku lq kw kx ky kz ij bi translated">探索性的数据分析永远不可能是故事的全部，但其他任何东西都不能作为基石。约翰·图基</p></blockquote><p id="a019" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">例如，如果我们有一个数据集，该数据集应该用来根据多年的经验预测平均工资，而在我们的经验年数列中，不加选择地发现值为-1，那么我们可以将该值标记为缺失值。否则，可能我们有一个身高/体重/年龄的连续变量特征(观察变量或独立变量),我们的 EDA 显示我们某个观察值为 0 或-1 或小于 1 的值；那么人们可以断定这样的值是丢失的值。缺失值也可能为空。当被调查者或用于获取此类数据的仪器没有对此类特征进行测量时，通常会出现这种情况。</p><figure class="lb lc ld le gt jz gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/a2660a3ef1efc15b4cfd2c136627730e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*eXYpcHLuhePdtJ3POgTSCg.jpeg"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">Source: DataCamp Supervised Learning Course</figcaption></figure><h2 id="5bc3" class="ls lt iq bd lu lv lw dn lx ly lz dp ma kn mb mc md kr me mf mg kv mh mi mj mk bi translated"><strong class="ak">我们如何处理丢失的值</strong></h2><p id="c80e" class="pw-post-body-paragraph kc kd iq ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated">有几种处理缺失值的方法，每种方法都有自己的优点和 CONS。然而，应该做什么的选择在很大程度上取决于我们的数据和缺失值的性质。下面是我们处理缺失值的几个选项的概要。</p><ol class=""><li id="a1bd" class="mq mr iq ke b kf kg kj kk kn ms kr mt kv mu kz mv mw mx my bi translated">删除缺少的值</li><li id="acbe" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">用测试统计填充缺失值</li><li id="bbd5" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">用机器学习算法预测缺失值</li></ol><p id="d34a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是一些用 EDA 检测缺失值的命令列表。</p><pre class="lb lc ld le gt ne nf ng nh aw ni bi"><span id="a806" class="ls lt iq nf b gy nj nk l nl nm">data_name.info() </span></pre><p id="dd65" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将告诉我们存在的非空观察的总数，包括条目的总数。一旦条目的数量不等于非空观察值的数量，我们就可以开始怀疑丢失的值。</p><pre class="lb lc ld le gt ne nf ng nh aw ni bi"><span id="5694" class="ls lt iq nf b gy nj nk l nl nm">data_name.describe()</span></pre><p id="3efb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将显示所有观察到的要素和标签的汇总统计数据。这里最需要注意的是最小值。一旦我们在年龄/身高/体重这样的观察中看到-1/0，那么我们就能够检测出缺失的值。</p><pre class="lb lc ld le gt ne nf ng nh aw ni bi"><span id="d91b" class="ls lt iq nf b gy nj nk l nl nm">data_name.head(x)</span></pre><p id="1772" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将输出我们数据的前 x 行。看到这个会让你对 NaN/-1/0/blank/？除其他外。</p><pre class="lb lc ld le gt ne nf ng nh aw ni bi"><span id="a27d" class="ls lt iq nf b gy nj nk l nl nm">data_name.isnull().sum()</span></pre><p id="50b5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将告诉我们在 or 数据中 NaN 的总数。</p><p id="13fe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果缺少的值没有被标识为 NaN，那么我们必须首先用 NaN 转换或替换这样的非 NaN 条目。</p><pre class="lb lc ld le gt ne nf ng nh aw ni bi"><span id="ce3b" class="ls lt iq nf b gy nj nk l nl nm">data_name[‘column_name’].replace(0, np.nan, inplace= True)</span></pre><p id="27f2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将在我们的 data_name 的名为 column_name 的列中用 NaN 替换零值。</p><h2 id="728d" class="ls lt iq bd lu lv lw dn lx ly lz dp ma kn mb mc md kr me mf mg kv mh mi mj mk bi translated"><strong class="ak"> 1)删除空值或缺失值</strong></h2><p id="cd0d" class="pw-post-body-paragraph kc kd iq ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated">这是处理缺失值的最快和最容易的步骤。不过一般不建议。这种方法降低了我们模型的质量，因为它减少了样本量，因为它通过删除任何变量缺失的所有其他观察值来工作。该过程可以通过以下方式完成:</p><pre class="lb lc ld le gt ne nf ng nh aw ni bi"><span id="fd35" class="ls lt iq nf b gy nj nk l nl nm">data_name.dropna()</span></pre><p id="cb20" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">代码片段显示了丢失值的危险。</p><figure class="lb lc ld le gt jz gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/3e71f5c535754250955b578cd57f0a00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*M7vQtHaEKs1v3mChbX7zCw.jpeg"/></div></figure><figure class="lb lc ld le gt jz gh gi paragraph-image"><div class="gh gi no"><img src="../Images/ea32863dda2db3c94e3380fee91f4dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*63CWQRLUwrPDuAd2d53B0A.jpeg"/></div></figure><p id="c5c4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将观察到，仅通过丢弃 NaN 值，891 个条目中的将减少到 183 个。！！！只有在缺失值很少的情况下(比如我们数据的 0.01–0.5%)，才建议使用丢弃法。百分比只是一个经验法则。</p><h2 id="ad76" class="ls lt iq bd lu lv lw dn lx ly lz dp ma kn mb mc md kr me mf mg kv mh mi mj mk bi translated"><strong class="ak"> 2)填充缺失值</strong></h2><p id="e2cf" class="pw-post-body-paragraph kc kd iq ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated">这是处理缺失值的最常见方法。在此过程中，缺失值将被测试统计数据(如缺失值所属的特定特征的平均值、中值或众数)替换。还可以指定向前填充或向后填充，以向后传播下一个值或向前传播前一个值。</p><p id="e37b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="ln">用测试统计填充缺失值</em></p><pre class="lb lc ld le gt ne nf ng nh aw ni bi"><span id="c58a" class="ls lt iq nf b gy nj nk l nl nm">#Age is a column name for our train data</span><span id="d4c0" class="ls lt iq nf b gy np nk l nl nm">mean_value=train['Age'].mean()<br/>train['Age']=train['Age'].fillna(mean_value)</span><span id="a0fa" class="ls lt iq nf b gy np nk l nl nm">#this will replace all NaN values with the mean of the non null values</span><span id="c751" class="ls lt iq nf b gy np nk l nl nm">#For Median</span><span id="cb25" class="ls lt iq nf b gy np nk l nl nm">meadian_value=train['Age'].median()<br/>train['Age']=train['Age'].fillna(median_value)</span></pre><p id="71c1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="ln">用测试统计填充缺失值的另一种方法是使用 sklearn.preprocessing 中的估算方法。</em></p><pre class="lb lc ld le gt ne nf ng nh aw ni bi"><span id="d1cc" class="ls lt iq nf b gy nj nk l nl nm">In [1]: from sklearn.preprocessing import Imputer<br/>In [2]: imp = Imputer(missing_values='NaN', strategy='mean', axis=0)<br/>In [3]: imp.fit(train)<br/>In [4]: train= imp.transform(train)<br/>#This will look for all columns where we have NaN value and replace the NaN value with specified test statistic.</span><span id="6f0c" class="ls lt iq nf b gy np nk l nl nm">#for mode we specify strategy='most_frequent'</span></pre><p id="ccf8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="ln">对于回填或前填，分别传播下一个或前一个值:</em></p><pre class="lb lc ld le gt ne nf ng nh aw ni bi"><span id="0f41" class="ls lt iq nf b gy nj nk l nl nm">#for back fill </span><span id="16df" class="ls lt iq nf b gy np nk l nl nm">train.fillna(method='bfill')<br/>#for forward-fill</span><span id="4ba0" class="ls lt iq nf b gy np nk l nl nm">train.fillna(method=''ffill)</span><span id="856e" class="ls lt iq nf b gy np nk l nl nm">#one can also specify an axis to propagate (1 is for rows and 0 is for columns)</span><span id="015f" class="ls lt iq nf b gy np nk l nl nm">train.fillna(method='bfill', axis=1)<br/></span></pre><p id="4173" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请注意，如果上一个或下一个值不可用，或者如果它也是一个 NaN 值，则即使在回填或前填后，NaN 仍然存在。</p><p id="4d4e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此外，使用平均值的缺点是平均值会受到数据中异常值的很大影响。因此，如果异常值出现在我们的数据中，那么中位数将是最好的现成工具。</p><h2 id="2771" class="ls lt iq bd lu lv lw dn lx ly lz dp ma kn mb mc md kr me mf mg kv mh mi mj mk bi translated">在管道中输入测试统计数据</h2><p id="4666" class="pw-post-body-paragraph kc kd iq ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated">数据管道允许通过一系列步骤将数据从一种表示转换为另一种表示。管道允许对我们的数据应用和链接转换的中间步骤。例如，可以填充缺失值，将输出传递给交叉验证和网格搜索，然后通过一系列链接在一起的步骤来拟合模型，其中一个步骤的输出是另一个步骤的输入。</p><p id="0292" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以在这里了解更多关于管道的信息。</p><p id="596a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是一个管道示例，它用每一列中最常见的值来估算数据，然后拟合到逻辑回归中。</p><pre class="lb lc ld le gt ne nf ng nh aw ni bi"><span id="8ebc" class="ls lt iq nf b gy nj nk l nl nm">from sklearn.pipeline import Pipeline<br/>from sklearn.preprocessing import Imputer<br/>imp = Imputer(missing_values='NaN', strategy='mean', axis=0)<br/>logreg = LogisticRegression()<br/>steps = [('imputation', imp),('logistic_regression', logreg)]<br/>pipeline = Pipeline(steps)<br/>X_train, X_test, y_train, y_test = train_test_split(X, y,<br/>                                 test_size=0.3, random_state=42)<br/>pipeline.fit(X_train, y_train)<br/>y_pred = pipeline.predict(X_test)<br/>pipeline.score(X_test, y_test)</span></pre><h2 id="f6e2" class="ls lt iq bd lu lv lw dn lx ly lz dp ma kn mb mc md kr me mf mg kv mh mi mj mk bi translated">3)处理缺失数据的预测模型</h2><p id="6212" class="pw-post-body-paragraph kc kd iq ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated">这是迄今为止处理缺失数据的最好和最有效的方法之一。根据缺失数据的类别，可以使用回归模型或分类来预测缺失数据。其工作原理是将缺失的要素转换为标签本身，现在使用没有缺失值的列来预测有缺失值的列</p><p id="d71c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">过程是这样的:</p><p id="3fc5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="ln">将缺少值的变量称为 y。</em></p><p id="cb27" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="ln">将数据分成有缺失值和无缺失值的集合，将缺失集合命名为 X_text，将无缺失值的集合命名为 X_train，将 y(有缺失值的变量或特征)从第二个集合中去掉，命名为 y_train。</em></p><p id="aaf7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="ln">使用其中一种分类方法预测 y_pred。</em></p><p id="3340" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="ln">添加到 X_test 作为你的 y_test 列。然后将集合组合在一起。</em></p><p id="04b3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于机器学习的初学者或新手来说，这种方法似乎更困难。这种方法的唯一缺点是，如果缺失数据的属性与数据集中的其他属性之间没有相关性，那么模型在预测缺失值时会有偏差。</p><h2 id="4d06" class="ls lt iq bd lu lv lw dn lx ly lz dp ma kn mb mc md kr me mf mg kv mh mi mj mk bi translated">用断言结束</h2><p id="720a" class="pw-post-body-paragraph kc kd iq ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated">除了如上所述使用 isnull()检查缺失值之外，还可以使用 assert 以编程方式检查是否存在缺失或意外的“0”值。这让人确信代码运行正常。</p><p id="1c93" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">可以在 assert 上执行以下和其他一些布尔运算。如果 Assert 语句为真，assert 将返回 nothing，如果语句为假，将返回 AssertionError。</p><pre class="lb lc ld le gt ne nf ng nh aw ni bi"><span id="a6b0" class="ls lt iq nf b gy nj nk l nl nm">#fill null values with 0</span><span id="5461" class="ls lt iq nf b gy np nk l nl nm">df=train.fillna(value=0)</span><span id="c1cd" class="ls lt iq nf b gy np nk l nl nm">#assert that there are no missing values</span><span id="3ceb" class="ls lt iq nf b gy np nk l nl nm">assert pd.notnull(df).all().all()</span><span id="5ad7" class="ls lt iq nf b gy np nk l nl nm">#or for a particular column in df</span><span id="f265" class="ls lt iq nf b gy np nk l nl nm">assert df.column_name.notall().all()</span><span id="b1b3" class="ls lt iq nf b gy np nk l nl nm">#assert all values are greater than 0</span><span id="08cc" class="ls lt iq nf b gy np nk l nl nm">assert (df &gt;=0).all().all()</span><span id="285c" class="ls lt iq nf b gy np nk l nl nm">#assert no entry in a column is equal to 0</span><span id="a2a4" class="ls lt iq nf b gy np nk l nl nm">assert (df['column_name']!=0).all().all()</span></pre><p id="e632" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">总之，处理缺失值的方法在很大程度上取决于此类数据的性质。因此，您处理的不同类型的数据越多，您对不同数据类的不同解决方案的体验就越好。</p><p id="2e65" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">感谢您的阅读，请留下您的评论，不要忘记分享。</p><p id="d0da" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">页（page 的缩写）请关注我的下一篇文章，讨论处理分类变量的各种选择</p><ul class=""><li id="19d4" class="mq mr iq ke b kf kg kj kk kn ms kr mt kv mu kz nq mw mx my bi translated">*所有图片均来自网络**</li></ul></div></div>    
</body>
</html>