<html>
<head>
<title>Implementing Git in Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在数据科学中实现 Git</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-git-in-data-science-11528f0fb4a7?source=collection_archive---------7-----------------------#2018-09-06">https://towardsdatascience.com/implementing-git-in-data-science-11528f0fb4a7?source=collection_archive---------7-----------------------#2018-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4c24b583f02818adc7339b8a73c5a801.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NDMr2p0Zn9eNquC7xsOcyg.jpeg"/></div></div></figure><p id="8b08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">本文原载于</em>【blog.zakjost.com】<em class="kw"/></p><h1 id="d79e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h1><p id="39f8" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我希望<a class="ae kx" href="https://blog.zakjost.com/post/git-in-data-science" rel="noopener ugc nofollow" target="_blank">第 1 部分</a>让您明白了版本控制是管理数据科学实验的重要工具。但是魔鬼在细节中，所以我们来谈谈如何在一个数据科学项目中实现版本控制。</p><p id="1d87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有几种使用 git 的范例，但是为了数据科学实验的目的，我基本上采用了“<a class="ae kx" href="https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow" rel="noopener ugc nofollow" target="_blank">特性分支</a>”。简而言之，特性分支意味着有一个“主”分支，您可以将其用作基线，通过从“主”分支，进行实现该特性所需的所有更改，然后在成功后将新分支合并回主分支，可以将新特性添加到代码库中。</p><h1 id="234e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">实施策略</h1><p id="4b16" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在我的例子中，我为一个新的实验或者一个我想尝试的新的建模想法创建一个新的分支。在这一点上，你需要有意识地做出决定:<em class="kw">你是修改代码，使它只在这个实验中有效，还是希望以一种既能在这个实验中又能在之前的实验中有效的方式来修改它？</em>这个问题的另一种表述方式是:<em class="kw">你是想替换你已经做的，还是想增加？</em>答案将决定你能否将新分支合并回 master，或者它是否会永远保持自己的东西。</p><p id="7dc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我的建议是额外努力将关键组件提取到一个库中，然后在多个实验中重复使用。</strong>这比拥有相同(或者更糟，稍微不同)代码的多个副本要好得多，这些副本需要单独维护。这种代码差异很可能是错误的来源。俗话说:最好的代码就是没有代码。通过将关键组件提取到共享库中，您可以进行增量改进，并最终得到一个内聚的代码库，该代码库可以重复运行一系列实验。如果您继续引入向后不兼容的变更，您会发现自己经常在分支之间跳跃，复制/粘贴有用的代码部分，但是随后需要进行修改，因为组件不是为协同工作而设计的。对于大型实验，这可能会变得难以处理。</p><p id="7342" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">特性分支方法的优点是，您可以将您的实验分支合并回 master，然后运行任何实验。这样做的代价是，当您对核心库进行更改时，您可能还需要更改其他实验的实现。所以，像所有事情一样，这是一个权衡的决定。以我的经验来看，它是有机发展的，每当我想复制和粘贴时，我就会想到提取公共代码。</p><h1 id="d3b5" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">示例实现</h1><p id="8cf2" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我发现一个有用的目录结构示例如下:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="a17b" class="mk kz iq mg b gy ml mm l mn mo">|-- core/<br/>    |-- tests/<br/>        |-- test_pull_data.py<br/>        |-- test_prepare_data.py<br/>        |-- test_model.py<br/>        |-- test_deploy.py<br/>        |-- test_utils.py<br/>    |-- pull_data.py<br/>    |-- prepare_data.py<br/>    |-- model.py<br/>    |-- deploy.py<br/>    |-- utils.py<br/>|-- experiment_1/<br/>    |-- data/<br/>        |-- training.csv<br/>        |-- validation.csv<br/>        |-- test.csv<br/>    |-- output/<br/>        |-- results.json<br/>        |-- models/<br/>            |-- model1<br/>            |-- model2<br/>    |-- job_config.py<br/>    |-- build_data.py<br/>    |-- train.py<br/>    |-- evaluate.py<br/>    |-- prod.py<br/>|-- experiment_2/<br/>    |-- data/<br/>        |-- training.csv<br/>        |-- validation.csv<br/>        |-- test.csv<br/>    |-- output/<br/>        |-- results.json<br/>        |-- models/<br/>            |-- model1<br/>            |-- model2<br/>    |-- job_config.py<br/>    |-- build_data.py<br/>    |-- train.py<br/>    |-- evaluate.py<br/>    |-- prod.py</span></pre><p id="57b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，主逻辑在<code class="fe mp mq mr mg b">core/</code>目录中。然后，实验被组织在目录中，目录包含执行实验的核心逻辑的代码和运行它所产生的输入/输出资产。实现代码应该非常简单，并且只做特定于这个特定实验的事情。例如，如果它比较方法 A 和 B，那么它将导入 A 和 B 的配置，从核心实例化相关代码，并为每个调用“run”。</p><p id="17fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，这种结构为实现单元/功能/集成测试提供了一个自然的位置。此外，将通用组件提取到一个多用户库中的行为有助于提高代码的可测试性。因为这段代码可能是参数化的，而不是依赖于硬编码的实验细节，所以为测试创建玩具示例变得更加容易。未来的一篇文章将更深入地探讨为数据科学项目编写测试。</p><h1 id="2679" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">技巧</h1><p id="8257" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">这里有一些我发现很有帮助的简单做法。</p><h2 id="e6d3" class="mk kz iq bd la ms mt dn le mu mv dp li kj mw mx lm kn my mz lq kr na nb lu nc bi translated">1.<code class="fe mp mq mr mg b">.gitignore</code></h2><p id="f29f" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">这告诉 git 要忽略哪些文件。在一个新项目中，这应该是首要任务，因为一旦你犯了愚蠢的错误，除非你采取特别的行动，否则它将永远存在。</p><p id="8f92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最重要的是排除敏感信息，如密码和 API 密钥。如果您很早就提交了包含敏感信息的文件，这很快就会变成一场噩梦。从当前快照中删除它是不够的——您需要从所有以前的提交中删除它。帮你自己一个忙，不要去学怎么做。</p><p id="72d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步是忽略非常大的数据文件和不需要跟踪的不重要的文件(即 ipython 笔记本检查点、来自 IDE 的设置文件、__pycache__，)。pyc 等)。在上面的例子中，所有的输入/输出工件也应该被忽略，因为它们完全由代码本身决定，并且如果需要的话可以重新生成。</p><h2 id="ff5b" class="mk kz iq bd la ms mt dn le mu mv dp li kj mw mx lm kn my mz lq kr na nb lu nc bi translated">2.频繁提交</h2><p id="e1bb" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">如果你完成了一大块合理的工作，提交一份。没有必要吝啬，这可能会让你摆脱困境。</p><h2 id="5dfc" class="mk kz iq bd la ms mt dn le mu mv dp li kj mw mx lm kn my mz lq kr na nb lu nc bi translated">3.清除提交消息</h2><p id="b553" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">如果你提交得足够频繁，那么你的大块工作可能会非常集中。这应该能够清除提交消息。没有什么比试图追溯一个不期望的变更并因为一个适当注释的提交历史而快速找到它更令人满意的了。如果对你所做的事情的描述是这样的:“实现了 3 个新特性，添加了 dropout，构建了一个交叉验证组件，重构了训练逻辑”，那么你没有足够频繁地提交。</p><h1 id="9982" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">你呢？</h1><p id="3870" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">当我尝试不同的策略时，这些想法正在进行中。如果你已经开发了一种你认为有用的不同方法，我很乐意听听它！</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="0d53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">您可以在</em><a class="ae kx" href="http://blog.zakjost.com" rel="noopener ugc nofollow" target="_blank"><em class="kw">【blog.zakjost.com】</em></a>找到我所有的内容并订阅</p></div></div>    
</body>
</html>