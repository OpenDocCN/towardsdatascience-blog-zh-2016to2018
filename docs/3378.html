<html>
<head>
<title>PREDICTION in Autonomous Vehicle - All You Need To Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动驾驶汽车中的预测——你需要知道的一切</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/prediction-in-autonomous-vehicle-all-you-need-to-know-d8811795fcdc?source=collection_archive---------7-----------------------#2018-05-07">https://towardsdatascience.com/prediction-in-autonomous-vehicle-all-you-need-to-know-d8811795fcdc?source=collection_archive---------7-----------------------#2018-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="899e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想象一个场景，你在一条双车道的路上驾驶一辆车，向前行驶，你想右转，但是第二车道上有一辆车从相反的方向驶来，现在你会怎么做？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/8b3e8fc5e17b8efc3b3ac43f6dd4511f.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*FFO-BFFLy-bx25o-Rf2yKg.png"/></div></figure><p id="9e2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自动驾驶汽车的预测是关于我们的自动驾驶汽车如何预测另一辆汽车的轨迹或路径，并采取行动避免碰撞。</p><p id="d1b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我是 Udacity 自动驾驶汽车纳米学位项目的第三期学生，在这里我将分享我在预测方面的知识，这是自动驾驶汽车轨迹规划的一个重要部分。</p><h1 id="6a36" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">这是怎么做到的？</strong></h1><p id="fa6e" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">预测的输入来自传感器融合和定位。传感器融合就是结合来自多个传感器(如雷达、激光雷达等)的数据(使用<a class="ae kt" rel="noopener" target="_blank" href="/an-intro-to-kalman-filters-for-autonomous-vehicles-f43dd2e2004b">卡尔曼滤波器</a>)。)让我们的汽车了解它的环境，而汽车使用定位来精确地知道它在哪里。</p><p id="a640" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们有了输入，就可以通过以下方法来预测车辆的轨迹:</p><p id="66fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.<strong class="jp ir">基于模型的方法</strong></p><p id="ba5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<strong class="jp ir">数据驱动方法</strong></p><p id="869b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些方法可以单独使用，也可以混合使用，以做出更好的预测。</p><p id="a0f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们一次看一种方法</p><h2 id="0b58" class="lx kv iq bd kw ly lz dn la ma mb dp le jy mc md li kc me mf lm kg mg mh lq mi bi translated"><strong class="ak"> 1。基于模型的方法:</strong></h2><p id="e6ae" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">这种方法识别车辆的常见行为(变道、左转、右转、确定最大转弯速度等。) .</p><p id="d251" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种方法中，我们为车辆可能行驶的每个可能轨迹创建一个模型，并将其与汽车的行为一起发送给<strong class="jp ir">多模态估计算法</strong> <em class="mj">(现在假设它是一个黑盒)</em>。该算法将概率分配给轨迹模型，最终选择概率最高的模型。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/ff57c645573b6b7e1aa86e65ff1c6a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q_Zys3JWoGs9OwdNA7PDqw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Modal Based Approach</figcaption></figure><p id="d001" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们深入研究基于模型的方法之前，让我们先来看看<em class="mj"> Frenet 坐标系。</em></p><p id="79e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">弗雷诺坐标系</strong></p><p id="910c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在 FCS 中，我们使用<strong class="jp ir">s’</strong>和<strong class="jp ir">d’</strong>符号来确定物体的位置，其中<strong class="jp ir">s’是道路上的距离</strong>，而<strong class="jp ir"> d 确定距离车道中心的距离</strong>，这与我们使用 x，y 坐标来表示道路上的位置的笛卡尔坐标系不同。FCS 是表示道路上物体位置的更好的方法，因为使用笛卡尔坐标实现曲线道路的方程会困难得多。</p><blockquote class="mt mu mv"><p id="cda3" class="jn jo mj jp b jq jr js jt ju jv jw jx mw jz ka kb mx kd ke kf my kh ki kj kk ij bi translated"><strong class="jp ir">基于模型的方法中使用的步骤:</strong></p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mz"><img src="../Images/5f0cdb1f6b3a0bec2a376e377f62ccbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*PButCbB7fORFHwgjHS12tw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Steps used in Model Based Approach</figcaption></figure><p id="2306" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mj">第一步:</em>确定汽车的共同行为</p><p id="c6c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mj">步骤 2: </em>为每个被识别的行为创建过程模型</p><p id="2e7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mj">第三步:</em>计算每个过程模型的概率</p><p id="df54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们通过一个简单的例子来理解每个步骤:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi na"><img src="../Images/14ce4d6cde9f9306477da5d5ad04d184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZWWh7JsBIm3dbeoZtUzj9Q.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Image Source: Udacity Nano Degree Program</figcaption></figure><p id="5ba5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们的自动驾驶汽车(绿色汽车)必须在高速公路上行驶。为此，它必须预测蓝色汽车的行为。</p><p id="9dc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第一步:</strong></p><p id="c20f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">蓝色汽车的行为如下:</p><ul class=""><li id="8027" class="nb nc iq jp b jq jr ju jv jy nd kc ne kg nf kk ng nh ni nj bi translated">它会忽略我们</li><li id="ba24" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">它会减速，让我们的车先行，这是一个礼貌的司机</li><li id="757a" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">它会加速并超过我们的车</li><li id="2d6c" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">它会变道并以同样的速度继续行驶</li></ul><p id="ed89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">等等..</p><p id="6d9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们必须用数学描述来描述这些行为。为此，我们将转到步骤 2。</p><p id="25ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第二步:</strong></p><p id="6399" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">过程模型为确定的行为提供了数学描述。</p><p id="4c40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些模型的复杂程度可以从非常简单的数学描述到非常复杂的数学描述不等</p><ul class=""><li id="da43" class="nb nc iq jp b jq jr ju jv jy nd kc ne kg nf kk ng nh ni nj bi translated"><em class="mj">请注意，流程模型数量取决于所识别行为的数量。它可能随着行为的数量而变化。</em></li></ul><p id="a18c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">预测状态 x 在时间 k </strong>的过程模型的一般状态形式如下:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi np"><img src="../Images/3e309c3b11b21f7c7c91685c9a4d0e79.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*IjMtWvy8_9sMY9f9Gn908Q.png"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/73570a621cc3df3151498b1e5c10888e.png" data-original-src="https://miro.medium.com/v2/resize:fit:242/format:webp/1*r-8pUlDzD3JlKJ_L0LemxA.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">state vector</figcaption></figure><p id="5aee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第三步:</strong></p><p id="51a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一步中，我们将通过为每个行为创建的流程模型分配概率，来确定汽车中的驾驶员将执行什么操作。这是通过<strong class="jp ir">多模态估计算法完成的。</strong>该算法最简单的方法是<strong class="jp ir">自主多模态(AMM)算法。</strong></p><h2 id="28b5" class="lx kv iq bd kw ly lz dn la ma mb dp le jy mc md li kc me mf lm kg mg mh lq mi bi translated"><strong class="ak">自主多模态(AMM)算法。</strong></h2><p id="5cfb" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">在 AMM，我们首先观察车辆在时间 k-1 和时间 k 的状态</p><p id="0f8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们计算 k-1 时刻的流程模型，并得到 k 时刻的预期状态。</p><p id="cb72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后将比较期望状态和观察状态的可能性。并使用以下公式获得模型在时间 k 的概率:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/b52704ca520115f8fa38bfaef67e8818.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*GchegYmj3_SwbhJP-vs0RA.png"/></div></figure><p id="7594" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模型(I)在时间 k 的概率</p><blockquote class="mt mu mv"><p id="a094" class="jn jo mj jp b jq jr js jt ju jv jw jx mw jz ka kb mx kd ke kf my kh ki kj kk ij bi translated">其中:</p><p id="339e" class="jn jo mj jp b jq jr js jt ju jv jw jx mw jz ka kb mx kd ke kf my kh ki kj kk ij bi translated"><strong class="jp ir"> M: </strong>多个不同的流程模型</p><p id="b85a" class="jn jo mj jp b jq jr js jt ju jv jw jx mw jz ka kb mx kd ke kf my kh ki kj kk ij bi translated"><strong class="jp ir"> U: </strong>模型的概率。</p><p id="713e" class="jn jo mj jp b jq jr js jt ju jv jw jx mw jz ka kb mx kd ke kf my kh ki kj kk ij bi translated"><strong class="jp ir"> L: </strong>模型的观测的可能性</p><p id="155b" class="jn jo mj jp b jq jr js jt ju jv jw jx mw jz ka kb mx kd ke kf my kh ki kj kk ij bi translated">k: 时间戳</p></blockquote><p id="9bf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后选择概率最高的模型。</p><h2 id="f151" class="lx kv iq bd kw ly lz dn la ma mb dp le jy mc md li kc me mf lm kg mg mh lq mi bi translated"><strong class="ak"> 2。数据驱动方法</strong></h2><p id="dec9" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">在数据驱动方法中，我们将采用一个黑盒，并使用大量训练数据对其进行训练。一旦它得到训练，我们将符合观察到的行为，并得到预测。</p><p id="0488" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这有助于确定车辆的具体模式，否则可能会被遗漏。</p><p id="ad12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据驱动方法分两个阶段完成:</p><ol class=""><li id="7fcb" class="nb nc iq jp b jq jr ju jv jy nd kc ne kg nf kk ns nh ni nj bi translated">离线培训(模型培训)</li><li id="d05d" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ns nh ni nj bi translated">在线预测(使用模型预测轨迹)</li></ol><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nt"><img src="../Images/47e1d2590125e7453d91c8b36270a498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cOmvnAAESe7hKWk97s8YuA.jpeg"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Data Based Approach</figcaption></figure><blockquote class="mt mu mv"><p id="8abc" class="jn jo mj jp b jq jr js jt ju jv jw jx mw jz ka kb mx kd ke kf my kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">离线培训</em> </strong></p></blockquote><p id="436b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">数据驱动方法中使用的步骤:</strong></p><p id="b304" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mj">第一步:</em>获取大量轨迹数据</p><p id="14b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mj">第二步:</em>清除数据</p><p id="e9fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mj">步骤 3: </em>选择一个度量来执行相似性</p><p id="c352" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mj">步骤 4: </em>使用机器学习算法执行轨迹的无监督聚类，如<a class="ae kt" href="https://en.wikipedia.org/wiki/Spectral_clustering" rel="noopener ugc nofollow" target="_blank">谱聚类</a>或<a class="ae kt" href="https://en.wikipedia.org/wiki/Hierarchical_clustering" rel="noopener ugc nofollow" target="_blank">凝聚聚类</a></p><p id="40c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mj">步骤 5 </em>:为每个集群定义一个轨迹模式</p><p id="3a78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按照这些步骤，我们将得到<strong class="jp ir">模式和轨迹群</strong></p><blockquote class="mt mu mv"><p id="b950" class="jn jo mj jp b jq jr js jt ju jv jw jx mw jz ka kb mx kd ke kf my kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">在线预测</em> </strong></p></blockquote><p id="2178" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mj">步骤 1: </em>观察车辆局部轨迹</p><p id="08a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二步:将它与原型轨迹进行比较</p><p id="eef2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mj">第三步:</em>预测轨迹</p><p id="c236" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重复在线预测步骤，直到我们找到原型轨迹之一与车辆轨迹相似的最大可能性。</p><p id="c7a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以到现在为止，你们一定对预测轨迹的两种不同方法有很好的理解。</p><p id="0c9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">混合方法</strong></p><p id="00c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以现在的问题是使用哪种方法..？</p><p id="206f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么不利用这两种方法的优点呢？这就是混合方法发挥作用的地方。:)</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/72eaf2d4ba94fb3e36011091291d397d.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*hS2eJZUWVOO4YDJQdBZvHQ.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Hybrid Approach</figcaption></figure><p id="50f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现混合方法，我们将用机器学习代替基于运动的方法的多重运动估计器。为此，我们需要一个分类器。一个这样的分类器是<em class="mj">朴素贝叶斯分类器</em></p><p id="c635" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">朴素贝叶斯分类器:</strong></p><p id="23e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">处理连续数据时的一个典型假设是，与每个类相关联的连续值按照高斯分布分布。</p><p id="51b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，假设训练数据包含一个连续属性 x。我们首先按类对该数据进行分段，然后计算每个类的平均值和标准偏差。假设我们有类的第 k 段，即 x 的 C_k，u_k 是平均值，_ square _ k 是标准偏差，那么给定一个类 C_k，v 的概率分布可以通过将 v 代入方程来计算</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/fdfe7bb491e23058f8c83bd807dae554.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*Fz5FN37yypojprH9OZ3a6g.png"/></div></figure></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="d8a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们需要知道的关于我们的自动驾驶车辆如何预测其他车辆的轨迹。请记住，在这篇博客中，我们已经通过一次一个对象的方式介绍了预测，而在现实世界的场景中，可能会有许多对象必须同时进行预测，这使得预测过程更加复杂。幸运的是，我们到目前为止所学的知识可以很好地预测公路上车辆的轨迹。</p><p id="bf39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以通过阅读这篇关于 T2 多模型算法的论文来了解更多关于预测的知识，作者是 T4 的瑞安·r·皮特里·维斯林·p·吉尔科夫·x·李蓉。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="c90c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如有任何疑问，请通过 LinkedIn<a class="ae kt" href="https://www.linkedin.com/in/atul-singh-2b8954115/" rel="noopener ugc nofollow" target="_blank">联系我</a>或写下私人笔记。</p></div></div>    
</body>
</html>