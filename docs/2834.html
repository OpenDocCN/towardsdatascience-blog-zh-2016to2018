<html>
<head>
<title>Real-Time Face Recognition: An End-To-End Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实时人脸识别:一个端到端的项目</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/real-time-face-recognition-an-end-to-end-project-b738bb0f7348?source=collection_archive---------0-----------------------#2018-03-12">https://towardsdatascience.com/real-time-face-recognition-an-end-to-end-project-b738bb0f7348?source=collection_archive---------0-----------------------#2018-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a554" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">逐步了解如何使用PiCam实时识别人脸。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/0964191b4d84fb7ec8cf8e630f9a8bc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sgROTW1Wa-u4hhUN62tWyw.png"/></div></div></figure><h1 id="8b39" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">1.介绍</h1><p id="899a" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在我探索OpenCV的教程中，我们学习了<a class="ae ma" href="https://medium.com/@rovai/automatic-vision-object-tracking-347af1cc8a3b" rel="noopener">自动视觉物体跟踪</a>。现在，我们将使用PiCam实时识别人脸，如下图所示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/fb2ba4256e166884bccd41b499007cd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*k1TkxDz9C__GWyHF."/></div></figure><p id="857a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个项目是用这个神奇的“开源计算机视觉库”<a class="ae ma" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank"> OpenCV </a>完成的。在本教程中，我们将专注于Raspberry Pi(所以，Raspbian作为操作系统)和Python，但我也在我的Mac上测试了代码，它也运行良好。</p><blockquote class="mc md me"><p id="de22" class="jn jo mf jp b jq jr js jt ju jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj kk ij bi translated">“要在Mac上运行它，需要对代码做一些修改。不要担心，我会对此进行评论”</p></blockquote><p id="2eb0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">OpenCV是为计算效率而设计的，非常注重实时应用。因此，它非常适合使用摄像头进行实时人脸识别。</p><h2 id="7aa0" class="mj ky iq bd kz mk ml dn ld mm mn dp lh jy mo mp ll kc mq mr lp kg ms mt lt mu bi translated">三个阶段</h2><p id="3369" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">为了创建一个完整的人脸识别项目，我们必须在三个截然不同的阶段开展工作:</p><ul class=""><li id="69a7" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">人脸检测和数据收集</li><li id="e38c" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">训练识别器</li><li id="c980" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">人脸识别</li></ul><p id="1811" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的框图恢复了这些阶段:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/a70e8e3cbc6dc28d132ab17333f18e51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*oJIRaoERCUHoyylG."/></div></figure><h1 id="9186" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">2.安装OpenCV 3包</h1><p id="bfe2" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我用的是Raspberry Pi V3，更新到了Raspbian (Stretch)的最新版本，所以安装OpenCV的最好方法是遵循Adrian Rosebrock开发的优秀教程:<a class="ae ma" href="https://www.pyimagesearch.com/2017/09/04/raspbian-stretch-install-opencv-3-python-on-your-raspberry-pi/" rel="noopener ugc nofollow" target="_blank"> Raspbian Stretch:在你的Raspberry Pi上安装OpenCV 3+Python</a>。</p><blockquote class="mc md me"><p id="9eb4" class="jn jo mf jp b jq jr js jt ju jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj kk ij bi translated">我尝试了几种不同的指南在我的Pi上安装OpenCV。阿德里安的教程是最好的。我建议你也这样做，一步一步地遵循他的指导方针。</p></blockquote><p id="2783" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦您完成了Adrian的教程，您就应该有一个OpenCV虚拟环境，可以在您的Pi上运行我们的实验。</p><p id="7600" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们进入虚拟环境，确认OpenCV 3安装正确。</p><p id="3a47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Adrian建议每次打开新终端时运行命令“source ”,以确保系统变量设置正确。</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="7f35" class="mj ky iq nl b gy np nq l nr ns">source ~/.profile</span></pre><p id="8865" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们进入虚拟环境:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="9f74" class="mj ky iq nl b gy np nq l nr ns">workon cv</span></pre><p id="9859" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您在提示前看到文本(cv ),则您处于<em class="mf"> cv虚拟</em>环境中:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="1182" class="mj ky iq nl b gy np nq l nr ns">(cv) pi@raspberry:~$</span></pre><blockquote class="mc md me"><p id="1e28" class="jn jo mf jp b jq jr js jt ju jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj kk ij bi translated"><em class="iq"> Adrian提醒注意，</em> <strong class="jp ir"> cv Python虚拟环境</strong> <em class="iq">完全独立于Raspbian Stretch下载中包含的默认Python版本。因此，全局站点包目录中的任何Python包对于cv虚拟环境都是不可用的。类似地，任何安装在cv的site-packages中的Python包对于Python的全局安装都是不可用的。</em></p></blockquote><p id="57ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在Python解释器中输入:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="4627" class="mj ky iq nl b gy np nq l nr ns">python</span></pre><p id="f488" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并确认您运行的是3.5(或更高)版本。</p><p id="6ed9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在解释器内部(会出现" &gt; &gt; &gt; ")，导入OpenCV库:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="5ef6" class="mj ky iq nl b gy np nq l nr ns">import cv2</span></pre><p id="c733" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果没有出现错误消息，则OpenCV已正确安装在您的PYTHON虚拟环境中。</p><p id="7ee5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您也可以检查安装的OpenCV版本:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="80e6" class="mj ky iq nl b gy np nq l nr ns">cv2.__version__</span></pre><p id="04d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.3.0应该会出现(或者将来可能发布的更高版本)。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/a63018e3f8c61197081d630bb02a4e91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*FEqK-Gc-u2uQ-8Cy."/></div></figure><p id="cb67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的终端打印屏幕显示了前面的步骤。</p><h1 id="2db4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">3.测试您的相机</h1><p id="b030" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">一旦你在RPi中安装了OpenCV，让我们来测试一下你的相机是否工作正常。</p><p id="dfa2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我假设您已经在您的Raspberry Pi上安装并启用了PiCam。</p><p id="d6e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在您的IDE上输入以下Python代码:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="0eeb" class="mj ky iq nl b gy np nq l nr ns">import numpy as np<br/>import cv2</span><span id="c25f" class="mj ky iq nl b gy nt nq l nr ns">cap = cv2.VideoCapture(0)<br/>cap.set(3,640) # set Width<br/>cap.set(4,480) # set Height</span><span id="e47e" class="mj ky iq nl b gy nt nq l nr ns">while(True):<br/>    ret, frame = cap.read()<br/>    frame = cv2.flip(frame, -1) # Flip camera vertically<br/>    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br/>    <br/>    cv2.imshow('frame', frame)<br/>    cv2.imshow('gray', gray)<br/>    <br/>    k = cv2.waitKey(30) &amp; 0xff<br/>    if k == 27: # press 'ESC' to quit<br/>        break</span><span id="1446" class="mj ky iq nl b gy nt nq l nr ns">cap.release()<br/>cv2.destroyAllWindows()</span></pre><p id="1f85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上述代码将捕获您的PiCam生成的视频流，以BGR彩色和灰色模式显示这两种视频流。</p><blockquote class="mc md me"><p id="b785" class="jn jo mf jp b jq jr js jt ju jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj kk ij bi translated">注意，由于组装的方式，我垂直旋转了我的相机。如果不是你的情况，评论或删除“翻转”命令行。</p></blockquote><p id="ab2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你也可以从我的GitHub下载代码:<a class="ae ma" href="https://github.com/Mjrovai/OpenCV-Object-Face-Tracking/blob/master/simpleCamTest.py" rel="noopener ugc nofollow" target="_blank"> simpleCamTest.py </a></p><p id="9bca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要执行脚本，请输入命令:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="d55f" class="mj ky iq nl b gy np nq l nr ns">python simpleCamTest.py</span></pre><blockquote class="mc md me"><p id="a011" class="jn jo mf jp b jq jr js jt ju jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj kk ij bi translated">要完成该程序，您必须按键盘上的[ESC]键。在按[ESC]键之前，在视频窗口上单击鼠标。</p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/697e13fe790e7bc63ee838ea91f46768.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*0L0psiQXno3KPHOu."/></div></figure><p id="01b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上图是结果。</p><p id="49f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些人在试图打开相机时发现问题，并得到“断言失败”的错误消息。如果在OpenCv安装过程中没有启用相机，相机驱动程序就不会正确安装，这种情况就会发生。要进行更正，请使用以下命令:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="9448" class="mj ky iq nl b gy np nq l nr ns">sudo modprobe bcm2835-v4l2</span></pre><blockquote class="mc md me"><p id="92a7" class="jn jo mf jp b jq jr js jt ju jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj kk ij bi translated"><em class="iq">您还可以将bcm2835-v4l2添加到/etc/modules文件的最后一行，以便在引导时加载驱动程序。</em></p></blockquote><p id="f622" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">了解OpenCV的更多内容，可以关注教程:<a class="ae ma" href="https://pythonprogramming.net/loading-video-python-opencv-tutorial/" rel="noopener ugc nofollow" target="_blank">加载-视频-python-OpenCV-教程</a></p><h1 id="f3c7" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">4.人脸检测</h1><p id="29b3" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">人脸识别最基本的任务当然是“人脸检测”。在做任何事情之前，你必须“捕捉”一张脸(阶段1)，以便在与未来(阶段3)捕捉的新脸进行比较时识别它。</p><p id="79ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最常见的检测人脸(或任何物体)的方法，是使用<a class="ae ma" href="https://docs.opencv.org/3.3.0/d7/d8b/tutorial_py_face_detection.html" rel="noopener ugc nofollow" target="_blank">哈尔级联分类器</a></p><p id="dafc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用基于Haar特征的级联分类器的目标检测是由Paul Viola和Michael Jones在2001年的论文“使用简单特征的增强级联的快速目标检测”中提出的一种有效的目标检测方法。这是一种基于机器学习的方法，其中从大量正面和负面图像中训练级联函数。然后，它被用于检测其他图像中的对象。</p><p id="155f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们将使用人脸检测。最初，该算法需要大量的正面图像(人脸图像)和负面图像(没有人脸的图像)来训练分类器。然后我们需要从中提取特征。好消息是OpenCV带有一个训练器和一个检测器。如果你想为任何物体训练你自己的分类器，比如汽车，飞机等等。您可以使用OpenCV创建一个。这里给出了它的全部细节:<a class="ae ma" href="https://docs.opencv.org/3.3.0/dc/d88/tutorial_traincascade.html" rel="noopener ugc nofollow" target="_blank">级联分类器训练</a>。</p><p id="b957" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不想创建自己的分类器，OpenCV已经包含了许多预先训练好的人脸、眼睛、微笑等分类器。那些XML文件可以从<a class="ae ma" href="https://github.com/Itseez/opencv/tree/master/data/haarcascades" rel="noopener ugc nofollow" target="_blank"> haarcascades </a>目录下载。</p><p id="734e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理论够了，我们用OpenCV造一个人脸检测器吧！</p><p id="ee6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从我的GitHub下载文件:<a class="ae ma" href="https://github.com/Mjrovai/OpenCV-Face-Recognition/blob/master/FaceDetection/faceDetection.py" rel="noopener ugc nofollow" target="_blank"> faceDetection.py </a>。</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="822e" class="mj ky iq nl b gy np nq l nr ns">import numpy as np<br/>import cv2</span><span id="af34" class="mj ky iq nl b gy nt nq l nr ns">faceCascade = cv2.CascadeClassifier('Cascades/haarcascade_frontalface_default.xml')<br/>cap = cv2.VideoCapture(0)<br/>cap.set(3,640) # set Width<br/>cap.set(4,480) # set Height</span><span id="adcb" class="mj ky iq nl b gy nt nq l nr ns">while True:<br/>    ret, img = cap.read()<br/>    img = cv2.flip(img, -1)<br/>    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br/>    faces = faceCascade.detectMultiScale(<br/>        gray,     <br/>        scaleFactor=1.2,<br/>        minNeighbors=5,     <br/>        minSize=(20, 20)<br/>    )<br/>    for (x,y,w,h) in faces:<br/>        cv2.rectangle(img,(x,y),(x+w,y+h),(255,0,0),2)<br/>        roi_gray = gray[y:y+h, x:x+w]<br/>        roi_color = img[y:y+h, x:x+w]  <br/>    cv2.imshow('video',img)<br/>    k = cv2.waitKey(30) &amp; 0xff<br/>    if k == 27: # press 'ESC' to quit<br/>        break</span><span id="76ad" class="mj ky iq nl b gy nt nq l nr ns">cap.release()<br/>cv2.destroyAllWindows()</span></pre><p id="7b4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">信不信由你，上面的几行代码就是你检测一张脸所需要的全部，使用Python和OpenCV。</p><p id="ad8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您与用于测试相机的最后一个代码进行比较时，您会发现添加到其中的部分很少。请注意下面一行:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="52aa" class="mj ky iq nl b gy np nq l nr ns">faceCascade = cv2.CascadeClassifier('Cascades/haarcascade_frontalface_default.xml')</span></pre><p id="2a6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是加载“分类器”的一行代码(必须位于项目目录下名为“Cascades/”的目录中)。</p><p id="ed90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们将设置我们的摄像机，在循环中，以灰度模式加载我们的输入视频(和我们之前看到的一样)。</p><p id="6d65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们必须调用我们的分类器函数，给它传递一些非常重要的参数，如比例因子、邻居数量和检测到的人脸的最小尺寸。</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="00c2" class="mj ky iq nl b gy np nq l nr ns">faces = faceCascade.detectMultiScale(<br/>        gray,     <br/>        scaleFactor=1.2,<br/>        minNeighbors=5,     <br/>        minSize=(20, 20)<br/>        )</span></pre><p id="28ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在哪里，</p><ul class=""><li id="06bd" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated"><strong class="jp ir">灰度</strong>是输入的灰度图像。</li><li id="be49" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated"><strong class="jp ir">比例因子</strong>是指定在每个图像比例下图像尺寸缩小多少的参数。它用于创建比例金字塔。</li><li id="86c4" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated"><strong class="jp ir"> minNeighbors </strong>是一个参数，指定每个候选矩形应该有多少个邻居来保留它。数字越大，误报率越低。</li><li id="0d7c" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated"><strong class="jp ir">最小尺寸</strong>是被视为面的最小矩形尺寸。</li></ul><p id="9b53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该功能将检测图像上的人脸。接下来，我们必须“标记”图像中的人脸，例如，使用蓝色矩形。这是通过这部分代码完成的:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="4876" class="mj ky iq nl b gy np nq l nr ns">for (x,y,w,h) in faces:<br/>    cv2.rectangle(img,(x,y),(x+w,y+h),(255,0,0),2)<br/>    roi_gray = gray[y:y+h, x:x+w]<br/>    roi_color = img[y:y+h, x:x+w]</span></pre><p id="6545" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果找到了人脸，它会将检测到的人脸的位置返回为一个矩形，左上角为(x，y)，宽度为“w ”,高度为“h ”= = &gt;(x，y，w，h)。请看图片。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/8d6de960d7511ef1f75b0f7799067c2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*De1DLB3Io5DAzfWl."/></div></figure><p id="8eec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们得到这些位置，我们就可以为面部创建一个“ROI”(绘制的矩形)，并用<em class="mf"> imshow() </em>函数呈现结果。</p><p id="2c5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Rpi终端，在您的python环境中运行上述python脚本:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="5aca" class="mj ky iq nl b gy np nq l nr ns">python faceDetection.py</span></pre><p id="e35a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果是:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/cb21bd1d93e93fa59a28e991248dd6b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*ieSMCirVIvsnK1wL."/></div></figure><p id="f514" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还可以包括用于“眼睛检测”甚至“微笑检测”的分类器。在这些情况下，您将在面部循环中包含分类器函数和矩形绘制，因为在面部之外检测眼睛或微笑是没有意义的。</p><blockquote class="mc md me"><p id="a05e" class="jn jo mf jp b jq jr js jt ju jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj kk ij bi translated"><em class="iq">请注意，在Pi上，几个分类器使用相同的代码会减慢处理速度，因为这种检测方法(HaarCascades)使用了大量的计算能力。在台式机上，运行它更容易。</em></p></blockquote><h2 id="75f8" class="mj ky iq bd kz mk ml dn ld mm mn dp lh jy mo mp ll kc mq mr lp kg ms mt lt mu bi translated">例子</h2><p id="da8e" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在我的GitHub上，您可以找到其他示例:</p><ul class=""><li id="5a17" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated"><a class="ae ma" href="https://github.com/Mjrovai/OpenCV-Face-Recognition/blob/master/FaceDetection/faceEyeDetection.py" rel="noopener ugc nofollow" target="_blank">faceyeedetection . py</a></li><li id="12bb" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated"><a class="ae ma" href="https://github.com/Mjrovai/OpenCV-Face-Recognition/blob/master/FaceDetection/faceSmileDetection.py" rel="noopener ugc nofollow" target="_blank">faces milled detection . py</a></li><li id="f0c8" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated"><a class="ae ma" href="https://github.com/Mjrovai/OpenCV-Face-Recognition/blob/master/FaceDetection/faceSmileEyeDetection.py" rel="noopener ugc nofollow" target="_blank"> faceSmileEyeDetection.py </a></li></ul><p id="7466" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在图片中，你可以看到结果。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/5b3a4107f1b59f0262a38089c5523e1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/0*sGjEiGKwrVucPGdd."/></div></figure><p id="d0ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您也可以按照下面的教程来更好地理解人脸检测:</p><p id="871a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae ma" href="https://pythonprogramming.net/haar-cascade-face-eye-detection-python-opencv-tutorial/" rel="noopener ugc nofollow" target="_blank">哈尔级联物体检测人脸&amp; Eye OpenCV Python教程</a></p><h1 id="f554" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">5.数据采集</h1><p id="d4a6" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">首先，我必须感谢Ramiz Raja在照片人脸识别方面的出色工作:</p><p id="1802" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae ma" href="https://www.superdatascience.com/opencv-face-recognition/" rel="noopener ugc nofollow" target="_blank">使用OPENCV和PYTHON的人脸识别:初学者指南</a></p><p id="4091" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有阿尼班·卡尔，他用视频开发了一个非常全面的教程:</p><p id="b316" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae ma" href="https://thecodacus.com/category/opencv/face-recognition/" rel="noopener ugc nofollow" target="_blank">人脸识别— 3个部分</a></p><p id="0f7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我真的建议你看一看这两个教程。</p><p id="805c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">说到这里，让我们开始我们项目的第一阶段。我们在这里要做的是，从最后一步(人脸检测)开始，我们将简单地创建一个数据集，其中我们将为每个id存储一组灰色照片，其中一部分用于人脸检测。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/f8693ea7cabaea5f52dca39102c4997a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*Nuf1sgV1y5DaH6wF."/></div></figure><p id="17e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，创建一个开发项目的目录，例如FacialRecognitionProject:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="c703" class="mj ky iq nl b gy np nq l nr ns">mkdir FacialRecognitionProject</span></pre><p id="f8a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个目录中，除了我们将为项目创建的3个python脚本之外，我们必须在上面保存面部分类器。可以从我的GitHub下载:<a class="ae ma" href="https://github.com/Mjrovai/OpenCV-Face-Recognition/blob/master/FacialRecognition/haarcascade_frontalface_default.xml" rel="noopener ugc nofollow" target="_blank">Haar cascode _ frontal face _ default . XML</a></p><p id="d00e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，创建一个子目录，我们将在其中存储面部样本，并将其命名为“数据集”:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="8663" class="mj ky iq nl b gy np nq l nr ns">mkdir dataset</span></pre><p id="f593" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并从我的GitHub下载代码:<a class="ae ma" href="https://github.com/Mjrovai/OpenCV-Face-Recognition/blob/master/FacialRecognition/01_face_dataset.py" rel="noopener ugc nofollow" target="_blank"> 01_face_dataset.py </a></p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="7b47" class="mj ky iq nl b gy np nq l nr ns">import cv2<br/>import os</span><span id="acae" class="mj ky iq nl b gy nt nq l nr ns">cam = cv2.VideoCapture(0)<br/>cam.set(3, 640) # set video width<br/>cam.set(4, 480) # set video height<br/>face_detector = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')</span><span id="b676" class="mj ky iq nl b gy nt nq l nr ns"># For each person, enter one numeric face id<br/>face_id = input('\n enter user id end press &lt;return&gt; ==&gt;  ')<br/>print("\n [INFO] Initializing face capture. Look the camera and wait ...")</span><span id="21fd" class="mj ky iq nl b gy nt nq l nr ns"># Initialize individual sampling face count<br/>count = 0<br/>while(True):<br/>    ret, img = cam.read()<br/>    img = cv2.flip(img, -1) # flip video image vertically<br/>    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br/>    faces = face_detector.detectMultiScale(gray, 1.3, 5)<br/>    for (x,y,w,h) in faces:<br/>        cv2.rectangle(img, (x,y), (x+w,y+h), (255,0,0), 2)     <br/>        count += 1<br/>        # Save the captured image into the datasets folder<br/>        cv2.imwrite("dataset/User." + str(face_id) + '.' +  <br/>                    str(count) + ".jpg", gray[y:y+h,x:x+w])<br/>        cv2.imshow('image', img)<br/>    k = cv2.waitKey(100) &amp; 0xff # Press 'ESC' for exiting video<br/>    if k == 27:<br/>        break<br/>    elif count &gt;= 30: # Take 30 face sample and stop video<br/>         break</span><span id="0768" class="mj ky iq nl b gy nt nq l nr ns"># Do a bit of cleanup<br/>print("\n [INFO] Exiting Program and cleanup stuff")<br/>cam.release()<br/>cv2.destroyAllWindows()</span></pre><p id="e3a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该代码与我们看到的人脸检测代码非常相似。我们添加的是一个“输入命令”来捕获一个用户id，它应该是一个整数(1，2，3等)</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="46f5" class="mj ky iq nl b gy np nq l nr ns">face_id = input('\n enter user id end press  ==&gt;  ')</span></pre><p id="a08f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于每一个捕捉到的帧，我们应该将其保存为“数据集”目录中的一个文件:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="98c3" class="mj ky iq nl b gy np nq l nr ns">cv2.imwrite("dataset/User." + str(face_id) + '.' + str(count) + ".jpg", gray[y:y+h,x:x+w])</span></pre><p id="ac95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，要保存上述文件，您必须导入库“os”。每个文件的名称将遵循以下结构:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="0ca2" class="mj ky iq nl b gy np nq l nr ns">User.face_id.count.jpg</span></pre><p id="82fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，对于face_id = 1的用户，数据集/目录上的第4个样本文件将类似于:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="a6b6" class="mj ky iq nl b gy np nq l nr ns">User.1.4.jpg</span></pre><p id="e7c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如我的Pi中的照片所示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/65ac4071f4b95153a15b2d18cf791093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/0*yxdD-qER_XOe-vFj."/></div></figure><p id="f073" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的代码中，我从每个id中捕获30个样本。最后一个“elif”可以改。样本数量用于打破捕捉面部样本的循环。</p><p id="ed92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行Python脚本并捕获一些id。每次您想要聚合新用户(或更改已存在用户的照片)时，您都必须运行该脚本。</p><h1 id="01a2" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">6.运动鞋</h1><p id="d329" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在第二阶段，我们必须从我们的数据集中获取所有用户数据，并“训练”OpenCV识别器。这是由特定的OpenCV函数直接完成的。结果将是一个. yml文件，该文件将保存在“trainer/”目录中。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/20315b274da157b73732a60321c4589a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*N4IcbE8v2nwgj6Xg."/></div></figure><p id="faff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，让我们开始创建一个子目录，用于存储训练数据:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="5e1d" class="mj ky iq nl b gy np nq l nr ns">mkdir trainer</span></pre><p id="2ae6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从我的GitHub下载第二个python脚本:<a class="ae ma" href="https://github.com/Mjrovai/OpenCV-Face-Recognition/blob/master/FacialRecognition/02_face_training.py" rel="noopener ugc nofollow" target="_blank"> 02_face_training.py </a></p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="d7ca" class="mj ky iq nl b gy np nq l nr ns">import cv2<br/>import numpy as np<br/>from PIL import Image<br/>import os</span><span id="1994" class="mj ky iq nl b gy nt nq l nr ns"># Path for face image database<br/>path = 'dataset'<br/>recognizer = cv2.face.LBPHFaceRecognizer_create()<br/>detector = cv2.CascadeClassifier("haarcascade_frontalface_default.xml");</span><span id="4f57" class="mj ky iq nl b gy nt nq l nr ns"># function to get the images and label data<br/>def getImagesAndLabels(path):<br/>    imagePaths = [os.path.join(path,f) for f in os.listdir(path)]     <br/>    faceSamples=[]<br/>    ids = []<br/>    for imagePath in imagePaths:<br/>        PIL_img = Image.open(imagePath).convert('L') # grayscale<br/>        img_numpy = np.array(PIL_img,'uint8')<br/>        id = int(os.path.split(imagePath)[-1].split(".")[1])<br/>        faces = detector.detectMultiScale(img_numpy)<br/>        for (x,y,w,h) in faces:<br/>            faceSamples.append(img_numpy[y:y+h,x:x+w])<br/>            ids.append(id)<br/>    return faceSamples,ids</span><span id="7dd9" class="mj ky iq nl b gy nt nq l nr ns">print ("\n [INFO] Training faces. It will take a few seconds. Wait ...")</span><span id="cb3e" class="mj ky iq nl b gy nt nq l nr ns">faces,ids = getImagesAndLabels(path)<br/>recognizer.train(faces, np.array(ids))</span><span id="bfed" class="mj ky iq nl b gy nt nq l nr ns"># Save the model into trainer/trainer.yml<br/>recognizer.write('trainer/trainer.yml') </span><span id="a9a6" class="mj ky iq nl b gy nt nq l nr ns"># Print the numer of faces trained and end program<br/>print("\n [INFO] {0} faces trained. Exiting Program".format(len(np.unique(ids))))</span></pre><blockquote class="mc md me"><p id="4442" class="jn jo mf jp b jq jr js jt ju jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj kk ij bi translated"><code class="fe nx ny nz nl b"># recognizer.save() worked on Mac, but not on Pi</code></p></blockquote><p id="5d90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确认您的Rpi上是否安装了PIL库。如果没有，请在终端中运行以下命令:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="dc0a" class="mj ky iq nl b gy np nq l nr ns">pip install pillow</span></pre><p id="477f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用OpenCV包中包含的LBPH(局部二进制模式直方图)人脸识别器作为识别器。我们用下面的代码行来实现这一点:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="91b6" class="mj ky iq nl b gy np nq l nr ns">recognizer = cv2.face.LBPHFaceRecognizer_create()</span></pre><p id="0a7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">函数“getImagesAndLabels (path)”，将拍摄目录:“dataset/”上的所有照片，返回2个数组:“Ids”和“faces”。将这些数组作为输入，我们将“训练我们的识别器”:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="995a" class="mj ky iq nl b gy np nq l nr ns">recognizer.train(faces, ids)</span></pre><p id="9b34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，名为“trainer.yml”的文件将保存在我们之前创建的培训师目录中。</p><p id="dfa0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！我包括了最后一个打印声明，其中我显示了我们已经训练的用户面部的数量以供确认。</p><p id="1aa5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每次执行阶段1时，也必须运行阶段2。</p><h1 id="6046" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">7.承认者</h1><p id="8ae4" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">现在，我们到了项目的最后阶段。在这里，我们将在我们的相机上捕捉一张新面孔，如果这个人的脸之前被捕捉并训练过，我们的识别器将进行“预测”，返回其id和索引，显示识别器对这一匹配的信心程度。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/2d341336842d8c574d009733299985f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/0*kkZMQyWtR5NOFr3q."/></div></figure><p id="8742" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面从我的GitHub下载第三期python脚本:<a class="ae ma" href="https://github.com/Mjrovai/OpenCV-Face-Recognition/blob/master/FacialRecognition/03_face_recognition.py" rel="noopener ugc nofollow" target="_blank"> 03_face_recognition.py </a>。</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="927d" class="mj ky iq nl b gy np nq l nr ns">import cv2<br/>import numpy as np<br/>import os </span><span id="5159" class="mj ky iq nl b gy nt nq l nr ns">recognizer = cv2.face.LBPHFaceRecognizer_create()<br/>recognizer.read('trainer/trainer.yml')<br/>cascadePath = "haarcascade_frontalface_default.xml"<br/>faceCascade = cv2.CascadeClassifier(cascadePath);<br/>font = cv2.FONT_HERSHEY_SIMPLEX</span><span id="8d3b" class="mj ky iq nl b gy nt nq l nr ns">#iniciate id counter<br/>id = 0</span><span id="eb08" class="mj ky iq nl b gy nt nq l nr ns"># names related to ids: example ==&gt; Marcelo: id=1,  etc<br/>names = ['None', 'Marcelo', 'Paula', 'Ilza', 'Z', 'W'] </span><span id="c65d" class="mj ky iq nl b gy nt nq l nr ns"># Initialize and start realtime video capture<br/>cam = cv2.VideoCapture(0)<br/>cam.set(3, 640) # set video widht<br/>cam.set(4, 480) # set video height</span><span id="aa13" class="mj ky iq nl b gy nt nq l nr ns"># Define min window size to be recognized as a face<br/>minW = 0.1*cam.get(3)<br/>minH = 0.1*cam.get(4)</span><span id="b97a" class="mj ky iq nl b gy nt nq l nr ns">while True:<br/>    ret, img =cam.read()<br/>    img = cv2.flip(img, -1) # Flip vertically<br/>    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)<br/>    <br/>    faces = faceCascade.detectMultiScale( <br/>        gray,<br/>        scaleFactor = 1.2,<br/>        minNeighbors = 5,<br/>        minSize = (int(minW), int(minH)),<br/>       )<br/>    for(x,y,w,h) in faces:<br/>        cv2.rectangle(img, (x,y), (x+w,y+h), (0,255,0), 2)<br/>        id, confidence = recognizer.predict(gray[y:y+h,x:x+w])<br/>        </span><span id="3401" class="mj ky iq nl b gy nt nq l nr ns">        # If confidence is less them 100 ==&gt; "0" : perfect match <br/>        if (confidence &lt; 100):<br/>            id = names[id]<br/>            confidence = "  {0}%".format(round(100 - confidence))<br/>        else:<br/>            id = "unknown"<br/>            confidence = "  {0}%".format(round(100 - confidence))<br/>        <br/>        cv2.putText(<br/>                    img, <br/>                    str(id), <br/>                    (x+5,y-5), <br/>                    font, <br/>                    1, <br/>                    (255,255,255), <br/>                    2<br/>                   )<br/>        cv2.putText(<br/>                    img, <br/>                    str(confidence), <br/>                    (x+5,y+h-5), <br/>                    font, <br/>                    1, <br/>                    (255,255,0), <br/>                    1<br/>                   )  <br/>    <br/>    cv2.imshow('camera',img) <br/>    k = cv2.waitKey(10) &amp; 0xff # Press 'ESC' for exiting video<br/>    if k == 27:<br/>        break</span><span id="c99a" class="mj ky iq nl b gy nt nq l nr ns"># Do a bit of cleanup<br/>print("\n [INFO] Exiting Program and cleanup stuff")<br/>cam.release()<br/>cv2.destroyAllWindows()</span></pre><p id="4962" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在这里包含了一个新的数组，所以我们将显示“名称”，而不是编号的id:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="a427" class="mj ky iq nl b gy np nq l nr ns">names = ['None', 'Marcelo', 'Paula', 'Ilza', 'Z', 'W']</span></pre><p id="e8b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，举个例子:Marcelo将id = 1的用户；宝拉:id=2，等等。</p><p id="a441" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将检测一张脸，就像我们之前用哈斯卡德分类器所做的一样。检测到人脸后，我们可以调用上面代码中最重要的函数:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="1bf4" class="mj ky iq nl b gy np nq l nr ns">id, confidence = recognizer.predict(gray portion of the face)</span></pre><p id="5636" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">recognizer.predict()将把要分析的面部的捕获部分作为参数，并将返回其可能的所有者，指示其id以及识别器与该匹配相关的置信度。</p><blockquote class="mc md me"><p id="c7e4" class="jn jo mf jp b jq jr js jt ju jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj kk ij bi translated"><em class="iq">注意，如果被认为是完美匹配，信心指数将返回“零”</em></p></blockquote><p id="6a82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，如果识别器可以预测人脸，我们就在图像上放一段文字，说明可能的id以及匹配正确的“概率”是多少(百分比)(“概率”= 100 —置信度指数)。如果没有，就在脸上贴上“未知”的标签。</p><p id="effa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是结果的gif:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/6c8d195261dcf6d3003a97260414ef43.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*i2-ODVuTz5X6P1xZ."/></div></figure><p id="61e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在图片上，我展示了这个项目的一些测试，我也用照片来验证识别器是否工作。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/8ef2b798ab0ab0c84961c74d72c14e1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/0*WtQqicLOVn1TukA2."/></div></figure><h1 id="3588" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">8.结论</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/67b037e2d3c0a7ca06341498bc821efc.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/0*9h2hjJaLY3_AerQd."/></div></figure><p id="034d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一如既往，我希望这个项目可以帮助其他人找到进入令人兴奋的电子世界的方法！</p><p id="17a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有关详细信息和最终代码，请访问我的GitHub仓库:</p><p id="7740" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">https://github.com/Mjrovai/OpenCV-Face-Recognition</p><p id="7098" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更多项目，请访问我的博客:【MJRoBot.org T4】</p><p id="a0d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来自世界南部的Saludos！</p><p id="270c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的下一篇文章再见！</p><p id="a500" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谢谢你，</p><p id="30ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">马塞洛</p></div></div>    
</body>
</html>