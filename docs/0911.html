<html>
<head>
<title>Neural Representation of Logic Gates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逻辑门的神经表示</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/neural-representation-of-logic-gates-df044ec922bc?source=collection_archive---------2-----------------------#2017-07-09">https://towardsdatascience.com/neural-representation-of-logic-gates-df044ec922bc?source=collection_archive---------2-----------------------#2017-07-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/411966a966c18f87d3ff719aa3fdd77c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RN9138k_S2xYuRgWYJ4j3g.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://static.pexels.com/photos/39290/mother-board-electronics-computer-board-39290.jpeg" rel="noopener ugc nofollow" target="_blank">https://static.pexels.com/photos/39290/mother-board-electronics-computer-board-39290.jpeg</a></figcaption></figure><p id="391c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">逻辑门即“与”、“或”、“非”是过去十年来每一项技术突破的组成部分，尤其是在硬件方面。</p><p id="cd42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个项目中，我们将使用神经网络的基础知识来表示逻辑门。我用 numpy 创建了一个感知器，它用数据集作为感知器的输入来实现这个逻辑门。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="16b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">第一部分:逻辑门</strong></p><p id="3aa1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们必须熟悉逻辑门。</p><p id="655f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="li">逻辑门是</em> </strong> <a class="ae kc" href="http://searchcio-midmarket.techtarget.com/definition/digital" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="li">数字</em></strong></a><strong class="kf ir"><em class="li"/></strong><a class="ae kc" href="http://searchcio-midmarket.techtarget.com/definition/circuit" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="li">电路</em> </strong> </a> <strong class="kf ir"> <em class="li">的基本构件。大多数逻辑门有两个输入和一个输出。在任何给定的时刻，每个终端都处于两种二进制状态之一:低(0)或高(1)，由不同的电压电平表示。当电路处理数据时，终端的逻辑状态可以经常改变，通常也确实如此。在大多数逻辑门中，低态大约为零伏(0 V)，而高态大约为正五伏(+5 V) </em> </strong> <em class="li">。如 techtarget </em>所述</p><p id="35dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最常见逻辑门是与、或、非。如果两个输入都是 1，则逻辑“与”门仅返回 1，否则返回 0；如果所有输入都是 1，则逻辑“或”门返回 1；如果两个输入都是 0，则仅返回 0；最后，逻辑“与”门不返回输入的反相，如果输入是 0，则返回 1；如果输入是 1，则返回 0。为了清楚起见，下图显示了基本门的真值表。</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/bad8bdb9af9dded5072784e3edb8043d.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*A_NAOXB-KhQpv_VhOv1Dlw.png"/></div></figure><p id="3b34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">A 列和 B 列是输入，Z 列是输出。因此，对于输入 A = 0，B = 0，输出为 Z = 0。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="f9b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二部分:感知器</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/18e30fee6ccd65d34d726acb8559a45e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*Y9uIm35kUaJd_gehP4MS8g.png"/></div></figure><p id="4f50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感知器是神经网络的基本部分。感知器代表人脑中的单个神经元，它由数据集(Xm)、权重(Wm)和激活函数组成，然后将产生输出和偏差。数据集(输入)被转换为一个 n array，然后与另一个保存权重的 n array 进行矩阵相乘。将所有矩阵相乘相加并加上一个偏差将创建净输入函数，然后输出将传递到一个激活函数，该函数将确定神经元是否需要触发输出。用于分类的最常见的激活函数是 sigmoid 函数，这是一个很好的分类函数(虽然 sigmoid 不是神经网络中间层的主要激活函数[ ehem ReLU / Leaky ReLU ],但它仍然广泛用于最终分类。)</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/beed00e0619e143199c02ad0eb747b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*MIeka59unAhS7MQk5e7FOg.png"/></div></figure><p id="66a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上图是 sigmoid 函数的曲线。模型的输出作为“z”传递到 sigmoid 中。简单来说，如果模型(z)的结果是负数，sigmoid 函数返回 0–0.4，如果模型是正数，返回 0.5–1。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="ff8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 3。代码</strong></p><p id="eaa3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于代码，我们将从导入 numpy 开始。Numpy 是一个内置数学函数的库，非常适合做矩阵乘法和科学编程。(在这里了解更多关于 numpy 的信息:【http://www.numpy.org/】T2)</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="005e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们将创建一个感知器函数，它将充当前面显示的图像中的感知器。该函数将接受权重矩阵、偏差和数据集矩阵。“np.dot(x，weight)”矩阵将数据集与来自输入的权重相乘，然后“np.add()”将矩阵乘法的输出与偏差相加。“1/(1+np.exp(-model)”表示激活函数，将模型传递到 sigmoid 函数中。</p><p id="9620" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:由于我们这个项目的目标是将感知器表示为逻辑门，我们将对激活函数的输出进行舍入，以使输出仅为 1 或 0，但出于实际目的，舍入输出是一个很大的错误，小数给出的小信息有助于为下一个将处理信息的神经元添加信息。更不用说消失和爆炸梯度，但这是另一个故事</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="c2be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建感知器后，我们需要为它填充输入。函数 compute 会执行此操作，因为数据集和权重还不是数组，我们将在这里执行此操作。它接受 logictype ( "logic_and "、" logic_or "等)来标记机器正在进行的计算，接受 weightdict，这是一个保存所有权重和偏差的字典，最后接受 dataset 参数</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="e494" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">计算函数将为数组中的每个数据集返回感知器函数的结果</p><p id="2696" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的要点是逻辑门 AND 和逻辑门 OR 的输出样本。</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="3f56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">神经逻辑项目到此结束。需要注意的是，为了引入感知器的基本功能，项目权重是手动设定的，尽管优化将是找到该问题正确权重的最佳答案，因此如果输入变大，神经网络可以正确回答该问题。</p><p id="c48c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要了解更多信息，您可以访问该知识库:<a class="ae kc" href="https://github.com/fjcamillo/Neural-Representation-of-Logic-Functions/blob/master/Logic.py" rel="noopener ugc nofollow" target="_blank">https://github . com/fjcamillo/Neural-Representation-of-Logic-Functions/blob/master/Logic . py</a></p></div></div>    
</body>
</html>