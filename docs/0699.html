<html>
<head>
<title>Structure and automated workflow for a machine learning project — part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习项目的结构和自动化工作流程—第2部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/structure-and-automated-workflow-for-a-machine-learning-project-part-2-b5b420625102?source=collection_archive---------1-----------------------#2017-06-10">https://towardsdatascience.com/structure-and-automated-workflow-for-a-machine-learning-project-part-2-b5b420625102?source=collection_archive---------1-----------------------#2017-06-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9bb41f35ca6bad7ba14ff75b26bcbbb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lyb2gstMmGemNFL902TWCw.png"/></div></div></figure><p id="8a66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated"><span class="l kx ky kz bm la lb lc ld le di"> H </span>我！我希望前一部分是有用的。今天，我们将讨论一些其他方面。我们将从预处理数据开始，并执行简单的探索性分析。然后我将向您展示如何创建自动化测试。最后，我们将训练一个模型。请记住，我将此描述为一个过程，而不仅仅是显示最终结果；)<br/> <br/>以防你错过，第一部分是<a class="ae lf" href="https://medium.com/towards-data-science/structure-and-automated-workflow-for-a-machine-learning-project-2fa30d661c1e" rel="noopener">这里是</a>。</p><h1 id="41d5" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">介绍</h1><p id="a8ef" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">首先，我们需要添加一些额外的包。这是今天的完整列表。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="c882" class="ms lh iq mo b gy mt mu l mv mw"><strong class="mo ir">dependencies:<br/> </strong>- python=3.5<br/> - numpy<br/> - scipy<br/> - scikit-learn<br/> - jupyter<br/> - requests<br/> - pandas<br/> - seaborn<br/> - click<br/> - openpyxl<br/> - <strong class="mo ir">pip:<br/>   </strong>- watermark<br/>   - pytest</span></pre><p id="f178" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于探索，我个人更喜欢用jupyter笔记本。让我们在目录<code class="fe mx my mz mo b">notebooks/00-initial-exploration.ipynb</code>中创建一个</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="42f7" class="ms lh iq mo b gy mt mu l mv mw">jupyter notebook</span></pre><p id="8d0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个<code class="fe mx my mz mo b">00</code>非常重要——它指示了执行的顺序。<br/> <br/>笔记本的第一个单元格包含:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="4d11" class="ms lh iq mo b gy mt mu l mv mw">%load_ext watermark<br/>%watermark -v -n -m -p numpy,scipy,sklearn,pandas</span></pre><p id="0aaf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将加载<em class="na">水印</em>扩展并打印关于运行平台的详细信息。这对其他人很有用，特别是当他们很难复制你的结果时。我的机器的输出:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="7ca7" class="ms lh iq mo b gy mt mu l mv mw">Mon May 29 2017</span><span id="13cb" class="ms lh iq mo b gy nb mu l mv mw">CPython 3.5.3<br/>IPython 6.0.0</span><span id="d042" class="ms lh iq mo b gy nb mu l mv mw">numpy 1.12.1<br/>scipy 0.19.0<br/>sklearn 0.18.1<br/>pandas 0.20.1</span><span id="8448" class="ms lh iq mo b gy nb mu l mv mw">compiler : MSC v.1900 64 bit (AMD64)<br/>system : Windows<br/>release : 7<br/>machine : AMD64<br/>processor : Intel64 Family 6 Model 69 Stepping 1, GenuineIntel<br/>CPU cores : 4<br/>interpreter: 64bit</span></pre><h1 id="c74c" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">探测</h1><p id="56d5" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">在下一个单元格中，我们导入所需的库并存储根目录——这非常有用。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="4790" class="ms lh iq mo b gy mt mu l mv mw">%matplotlib inline<br/>import pandas as pd<br/>import numpy as np<br/>import seaborn as sns<br/>import os<br/>PROJ_ROOT = os.path.abspath(os.path.join(os.pardir))<br/>print(PROJ_ROOT)</span></pre><p id="62a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">稍后，我们想要实际加载并查看数据:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="e33e" class="ms lh iq mo b gy mt mu l mv mw">data_fname = os.path.join(PROJ_ROOT, ‘data’, ‘raw’, ‘iris.csv’)<br/>dframe = pd.read_csv(data_fname, header=None)<br/>dframe.head()</span></pre><p id="1fb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="dcbf" class="ms lh iq mo b gy mt mu l mv mw">0 1 2 3 4 <br/>0 5.1 3.5 1.4 0.2 Iris-setosa <br/>1 4.9 3.0 1.4 0.2 Iris-setosa <br/>2 4.7 3.2 1.3 0.2 Iris-setosa <br/>3 4.6 3.1 1.5 0.2 Iris-setosa <br/>4 5.0 3.6 1.4 0.2 Iris-setosa </span></pre><p id="5e48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们知道第4列包含我们想要预测的标签。由于<em class="na"> iris </em>是著名的数据集，我们也知道列【0，3】中特征的名称——它们是:<em class="na">萼片长度</em>、<em class="na">萼片宽度</em>、<em class="na">花瓣长度</em>和<em class="na">花瓣宽度</em>。但出于练习目的，让我们假设我们不知道它们，并给出通用名称:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="59f8" class="ms lh iq mo b gy mt mu l mv mw">dframe.columns = [‘x0’, ‘x1’, ‘x2’, ‘x3’, ‘y’]<br/>dframe.head()<br/></span></pre><p id="9a39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="182c" class="ms lh iq mo b gy mt mu l mv mw"> x0 x1 x2 x3 y <br/>0 5.1 3.5 1.4 0.2 Iris-setosa <br/>1 4.9 3.0 1.4 0.2 Iris-setosa <br/>2 4.7 3.2 1.3 0.2 Iris-setosa <br/>3 4.6 3.1 1.5 0.2 Iris-setosa <br/>4 5.0 3.6 1.4 0.2 Iris-setosa </span></pre><p id="b4e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是施展魔法的时候了:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="58f7" class="ms lh iq mo b gy mt mu l mv mw">sns.pairplot(dframe, vars=[‘x0’, ‘x1’, ‘x2’, ‘x3’], hue=’y’)</span></pre><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/5b819ba0396195e1804a70d830545f48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F3Dp2z8P2Lc7nDovvekiaw.png"/></div></div></figure><p id="1918" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">哇哦。通过使用<em class="na"> seaborn </em>我们能够绘制所有变量之间的配对分布。这对于直观地检查数据非常有用。而且第一次用的时候印象深刻；)</p><h1 id="3c3e" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">重构</h1><p id="72cb" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">到目前为止，我们执行了两个基本步骤</p><ul class=""><li id="cbaf" class="nd ne iq ka b kb kc kf kg kj nf kn ng kr nh kv ni nj nk nl bi translated">加载和标记数据</li><li id="b022" class="nd ne iq ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated">外观检验</li></ul><p id="5b15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">笔记本对于实验来说很棒，但是对于执行这个过程来说却很差。现在，我们将代码转移到<code class="fe mx my mz mo b">src</code>。此外，我们将通过两个新项目扩展我们的渠道:</p><ul class=""><li id="3c10" class="nd ne iq ka b kb kc kf kg kj nf kn ng kr nh kv ni nj nk nl bi translated">标签-数据:添加标签(x0，…，y)并将其保存回来</li><li id="6044" class="nd ne iq ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated">探索性-可视化生成绘图并保存它</li></ul><p id="aa9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可能会争论我们是否真的需要仅仅通过添加列名来保存回数据。可能不会，但通常我们的第一轮预处理会更复杂。</p><p id="f9d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在文件<code class="fe mx my mz mo b">src/data/preprocess.py</code>中</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="22d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们真的需要read_raw_data方法吗？只有一行代码。是的，我们需要。您的同事会记住非标准csv文件的所有参数吗？请记住，读取数据可能要复杂得多，包括PCA之类的东西。在<code class="fe mx my mz mo b">preprocess_data</code>中，我复制了一帧。这是因为我喜欢参数不可变的函数式风格。<br/> <br/>为了避免枚举所有特征，这里有一个函数。<br/> <br/>另外一个值得一提的是这个excel文件。它不会在任何地方使用，但是，我发现它非常有用，可以导出Excel文件，以便在需要时手动查看。但是这是完全可选的(考虑到这一点，它也使用一个可选参数)。</p><p id="d0d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使其完整，创建包含内容的文件<code class="fe mx my mz mo b">src/data/__init__.py</code>:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="2d48" class="ms lh iq mo b gy mt mu l mv mw"><strong class="mo ir">from </strong>.preprocess <strong class="mo ir">import </strong>read_raw_data, read_processed_data, preprocess_data, get_label, get_featues</span></pre><h1 id="0b16" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">重构情节</h1><p id="4601" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">绘图代码要简单得多:</p><p id="17de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mx my mz mo b">src/visualization/exploratory.py</code></p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="aa24" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将matplotib后端设置为<code class="fe mx my mz mo b">agg</code>，因为我发现在我的系统上使用默认的(QtAgg)会导致不正确的渲染。</p><p id="1418" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还必须像第一部分一样创建<code class="fe mx my mz mo b">reports/figures/.gitkeep</code>文件。</p><h1 id="ae28" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">更新Makefile</h1><p id="8af4" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">更新依赖关系图的时间。对于绘制代码:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="ae91" class="ms lh iq mo b gy mt mu l mv mw">reports/figures/exploratory.png: data/processed/processed.pickle<br/>   python src/visualization/exploratory.py $&lt; $@</span></pre><p id="11ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上次我解释了<code class="fe mx my mz mo b">&lt;@</code>的意思。概括地说，这是第一个先决条件(本例中为<code class="fe mx my mz mo b">data/processed/processed.pickle</code>)。因此，<code class="fe mx my mz mo b">$&lt;</code>表示第一个目标。所以，上述规则相当于:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="eff4" class="ms lh iq mo b gy mt mu l mv mw">reports/figures/exploratory.png: data/processed/processed.pickle<br/>   python src/visualization/exploratory.py data/processed/processed.pickle reports/figures/exploratory.png</span></pre><p id="a26f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我他妈的为什么要在乎<code class="fe mx my mz mo b">$@</code>和<code class="fe mx my mz mo b">$&lt;</code>？</p><p id="d4a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能想知道为什么我使用这个疯狂的符号，而不是仅仅粘贴文件名两次。答案是:因为make可以使用泛型规则。<br/> <br/>设想如下规律:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="7116" class="ms lh iq mo b gy mt mu l mv mw">%.o : %.cpp<br/> gcc $&lt; -o $@</span></pre><p id="f373" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将使用<code class="fe mx my mz mo b">gcc</code>将每个<code class="fe mx my mz mo b">*.c</code>文件编译成相应的<code class="fe mx my mz mo b">*.o</code>。我们将在后面使用这个语法。</p><p id="18fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">预处理规则:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="ba57" class="ms lh iq mo b gy mt mu l mv mw">data/processed/processed.pickle: data/raw/iris.csv<br/>      python src/data/preprocess.py $&lt; $@ --excel data/processed/processed.xlsx</span></pre><p id="57bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">清除规则:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="3697" class="ms lh iq mo b gy mt mu l mv mw">clean:<br/>   rm -f data/raw/*.csv<br/>   rm -f data/processed/*.pickle<br/>   rm -f data/processed/*.xlsx<br/>   rm -f reports/figures/*.png</span></pre><p id="92cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和所有:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="eed6" class="ms lh iq mo b gy mt mu l mv mw">all: data/processed/processed.pickle reports/figures/exploratory.png</span></pre><p id="0919" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以更新笔记本了！这将为我们提供如下信息:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="e4d4" class="ms lh iq mo b gy mt mu l mv mw">%load_ext watermark<br/>%watermark -v -n -m -p numpy,scipy,sklearn,pandas<br/> <br/>%matplotlib inline<br/>import pandas as pd<br/>import numpy as np<br/>import seaborn as sns<br/>import os<br/>PROJ_ROOT = os.path.abspath(os.path.join(os.pardir))<br/>print(PROJ_ROOT)<br/>import sys<br/>sys.path.append(os.path.join(PROJ_ROOT, ‘src’))</span></pre><p id="e839" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从<code class="fe mx my mz mo b">src</code>导入代码</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="95b3" class="ms lh iq mo b gy mt mu l mv mw">import sys<br/>sys.path.append(os.path.join(PROJ_ROOT, ‘src’))<br/>from data.preprocess import read_raw_data, preprocess_data<br/>from visualization.exploratory import exploratory_visualization</span></pre><p id="35a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">加载原始数据</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="83ce" class="ms lh iq mo b gy mt mu l mv mw">data_fname = os.path.join(PROJ_ROOT, ‘data’, ‘raw’, ‘iris.csv’)<br/>raw_data = read_raw_data(data_fname)<br/>raw_data.head()</span></pre><p id="13b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">预处理数据</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="4ed4" class="ms lh iq mo b gy mt mu l mv mw">preprocessed_data = preprocess_data(raw_data)<br/>preprocessed_data.head()</span></pre><p id="f8a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和绘图</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="e37b" class="ms lh iq mo b gy mt mu l mv mw">exploratory_visualization(preprocessed_data) </span></pre><h1 id="f2bd" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">重新加载模块</h1><p id="fe96" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">一切都很好，除了一件事。我改变了主意，决定在图上使用核密度估计。将<code class="fe mx my mz mo b">exploratory.py</code>修改为<code class="fe mx my mz mo b">...pairplot(dframe, diag_kind=<strong class="ka ir">’kde’</strong>, vars=[<strong class="ka ir">‘x0’..</strong></code>后，我重新运行笔记本，没有任何反应。这是因为jupyter没有重新加载我的模块。要解决这个问题，请添加</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="e9df" class="ms lh iq mo b gy mt mu l mv mw">%load_ext autoreload<br/>%autoreload 2</span></pre><p id="e679" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">笔记本的开头。它会导致在执行代码时重新加载模块。</p><h1 id="ae68" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">测试</h1><p id="ebe0" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">自动化测试可以提供很多价值。为机器学习项目设计测试是另一篇文章的主题，所以这里我将只介绍非常基础的内容。</p><p id="26e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将只测试我们关于数据形状的假设。创建文件<code class="fe mx my mz mo b">src/tests/test_data.py</code></p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7b12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它包含两个简单的测试。首先，检查原始数据是否具有假定的维度。第二个检查是否有4个特征和1个标签。实际测试是通过使用内置的<code class="fe mx my mz mo b">assert</code>语句来完成的。要运行测试会话，请在项目根目录下打开终端并键入:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="b1bd" class="ms lh iq mo b gy mt mu l mv mw">pytest src</span></pre><p id="817a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果应该是这样的:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="bdba" class="ms lh iq mo b gy mt mu l mv mw">=========== test session starts ===========<br/>platform linux -- Python 3.5.2, pytest-3.1.1, py-1.4.34, pluggy-0.4.0<br/>rootdir: /home/xevaquor/code/overcome-the-chaos, inifile:<br/>collected 2 items</span><span id="e120" class="ms lh iq mo b gy nb mu l mv mw">src/tests/test_data.py ..</span><span id="0fc8" class="ms lh iq mo b gy nb mu l mv mw">======== 2 passed in 0.28 seconds =========</span></pre><p id="5501" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还应该将测试纳入我们的工作流程:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="acd7" class="ms lh iq mo b gy mt mu l mv mw">test: all<br/>   pytest src</span></pre><p id="ba99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不要忘记把它标记为。假的，因为它不创建任何文件</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="aa64" class="ms lh iq mo b gy mt mu l mv mw">.PHONY: all clean test</span></pre><h1 id="446d" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">创建模型</h1><p id="6acd" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">最后，让我们创建一个模型。它可以使用各种库来实现——sk learn、theano、xgboost等等，所以最好有一个通用的接口。<code class="fe mx my mz mo b">src/models/random_forest.py</code>。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="358e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很简单。我只想提一下保存和加载方法。它们在这里是为了提供一种方便的方法来持久化训练好的模型。每个模型应该自己定义它，因为它有很强的依赖性。</p><blockquote class="nt nu nv"><p id="2976" class="jy jz na ka b kb kc kd ke kf kg kh ki nw kk kl km nx ko kp kq ny ks kt ku kv ij bi translated">注意:我跳过模型评估。这是一个非常重要的话题，但在这里没有它的位置。</p></blockquote><h1 id="a084" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">训练模型</h1><p id="3afa" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">在我们的渠道中，我们还需要模特培训。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="34a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个很简单。只需加载预处理数据并将训练好的模型保存到一个文件中。当然，我们必须确保训练模型目录的存在。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="0917" class="ms lh iq mo b gy mt mu l mv mw">mkdir models<br/>touch models/.gitkeep<br/>git add --force models/.gitkeep</span></pre><p id="b114" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并更新Makefile</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="c195" class="ms lh iq mo b gy mt mu l mv mw">all: reports/figures/exploratory.png models/random_forest.model</span><span id="7814" class="ms lh iq mo b gy nb mu l mv mw">clean:<br/>   rm -f data/raw/*.csv<br/>   rm -f data/processed/*.pickle<br/>   rm -f data/processed/*.xlsx<br/>   rm -f reports/figures/*.png<br/>   rm -f models/*.model</span><span id="e8ae" class="ms lh iq mo b gy nb mu l mv mw">...</span><span id="e686" class="ms lh iq mo b gy nb mu l mv mw">models/random_forest.model: data/processed/processed.pickle<br/>   python src/models/train_model.py $&lt; $@</span></pre><blockquote class="nt nu nv"><p id="7d29" class="jy jz na ka b kb kc kd ke kf kg kh ki nw kk kl km nx ko kp kq ny ks kt ku kv ij bi translated">自动化测试的示例思想是检查模型是否达到合理的精确度水平。</p></blockquote><p id="7e8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">整个依赖关系图现在看起来如下:</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/17dee0dc908023412d957fe19702653b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*_VPd9GqOA0MwvYLaslOCfg.png"/></div></figure><h1 id="de58" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">摘要</h1><p id="21d8" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">我们今天做了很多。在接下来的最后一部分，我将向您展示如何部署您的模型。我们将创建一个简单的web服务，并使用docker使其在线。如果你想阅读一些东西，请在评论中告诉我。</p><p id="22ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一会儿见:)</p></div></div>    
</body>
</html>