<html>
<head>
<title>Implementation of Convolutional Neural Network Using Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Keras 实现卷积神经网络</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementation-of-convolutional-neural-network-using-keras-9ace67916c07?source=collection_archive---------13-----------------------#2018-09-24">https://towardsdatascience.com/implementation-of-convolutional-neural-network-using-keras-9ace67916c07?source=collection_archive---------13-----------------------#2018-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9968" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将看到在 MNIST 数据集上使用 Keras 实现卷积神经网络(CNN ),然后将结果与常规神经网络进行比较。强烈建议在继续学习 CNN 实现之前，先阅读文章<a class="ae kl" href="https://engmrk.com/convolutional-neural-network-3/" rel="noopener ugc nofollow" target="_blank">“卷积神经网络—简而言之”</a>，以培养对 CNN 的直觉。</p><h1 id="5470" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">1-简介</h1><p id="bcda" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">MNIST 数据集最常用于影像分类研究。MNIST 数据库包含美国人口普查局雇员和美国高中生手写的数字图像，从 0 到 9。分为 6 万张训练图像和 1 万张测试图像。Tensorflow 和 Keras 都允许我们使用 API 直接下载 MNIST 数据集。</p><h1 id="684c" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">2-使用 API 下载数据集</h1><p id="8c4e" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们将只使用两行代码来导入 TensorFlow 并在 Keras API 下下载 MNIST 数据集。我们将把数据分配到训练集和测试集中。x_train 和 x_test 部分包含灰度 RGB 代码(从 0 到 255 ),而 y_train 和 y_test 部分包含从 0 到 9 的标签。<br/>我们将使用‘matplotlib’库可视化图像。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/9472fc4ac8af21a3cb8c0a5bac6184fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A0Q8rdwjH0UNk_2rFwkxVw.png"/></div></div></figure><p id="84e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要强调的是，MNIST 数据集中的每幅图像大小为 28 X 28 像素，这意味着 x_train 的形状为(60000，28，28 ),其中 60，000 是样本数。作为通过 Keras API 进行处理的要求，我们必须将 x_train 从 3 维重塑为 4 维。此外，我们必须标准化我们的数据，否则我们的计算成本将非常高。我们可以通过将 RGB 代码划分为 255 来实现，如下所示:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mb"><img src="../Images/6fcb8c9cd8687b961316de5daf700c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gmAB5amFV2_CyvqOWf-LiQ.png"/></div></div></figure><h1 id="7599" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">3-卷积神经网络结构</h1><p id="23be" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">首先，我们将卷积神经网络架构定义如下:</p><p id="5712" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1-第一个隐藏层是一个卷积层，称为卷积 2D。我们将使用 32 个尺寸为 5×5 的过滤器。</p><p id="2184" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2-然后是池大小为 2×2 的最大池层。</p><p id="816c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3-具有 64 个滤波器的另一个卷积层，每个滤波器的大小为 5×5。</p><p id="da04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4-然后是池大小为 2×2 的最大池层。</p><p id="4275" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5-然后下一步是扁平化层，在建立完全连接的层之前，将 2D 矩阵数据转换为 1D 矢量。</p><p id="9a00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">6-之后，我们将使用一个具有 1024 个神经元和 relu 激活功能的全连接层。</p><p id="ede6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">7-然后我们将使用一个正则化层称为辍学。它被配置为随机排除该层中 20%的神经元，以减少过度拟合。</p><p id="2492" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">8-最后，输出层，其具有用于 10 个类别的 10 个神经元和用于输出每个类别的概率状预测的 softmax 激活函数。</p><p id="7ae1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">决定上述内容后，我们可以用如下几行代码建立一个神经网络模型:</p><blockquote class="mc md me"><p id="592b" class="jn jo mf jp b jq jr js jt ju jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">注:</em> </strong></p><p id="77ca" class="jn jo mf jp b jq jr js jt ju jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj kk ij bi translated"><em class="iq">–注释带有' # '来解释命令。</em></p><p id="d5a6" class="jn jo mf jp b jq jr js jt ju jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj kk ij bi translated"><em class="iq">–您可以下载</em> <a class="ae kl" href="https://estore.engmrk.com/product/module-22-cnn-using-keras/" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> iPython 笔记本</em> </a> <em class="iq">并在您的 PC 上训练模型，或者只是复制并粘贴这些代码。py 文件。</em></p></blockquote><p id="c572" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤 1 —创建模型:</strong></p><p id="9a44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Keras 首先创建一个模型对象的新实例，然后一个接一个地向其添加层。它被称为顺序模型 API。我们可以通过调用 model.add 并传入我们想要添加的层的类型来向神经网络添加层。最后，我们将用两个重要信息编译模型，损失函数和成本优化算法。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mj"><img src="../Images/99555565fe0f010cc885b301b4f33893.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E_1GOfYcO4TCzI7eNBOk6g.png"/></div></div></figure><p id="2eaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们执行了上面的代码，Keras 将在幕后构建一个 TensorFlow 模型。</p><p id="fe9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤 2 —训练模型:</strong></p><p id="5d88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过调用 model.fit 并传入训练数据和预期输出来训练模型。Keras 将运行培训过程，并将进度打印到控制台。训练完成后，它将报告训练数据达到的最终准确度。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mk"><img src="../Images/dbe37c13b04ef55624004d3e383278e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9SxTi4Ap1Ue-63L4TGnIg.png"/></div></div></figure><p id="faa6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤 3 —测试模型:</strong></p><p id="2008" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过调用 model.evaluate 并传入测试数据集和预期输出来测试模型。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi ml"><img src="../Images/78a30f3a7534b80b4b8587432510f818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*drrfNK1rBDecq1n7OZ-FJA.png"/></div></div></figure><p id="ed74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤 4 —保存并加载模型:</strong></p><p id="c33b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦达到最佳结果，我们可以使用 model.save 保存模型，并传入文件名。这个文件将包含我们在另一个程序中使用我们的模型所需要的一切。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mm"><img src="../Images/10b63e5a1bcb06074162747e291dc009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OoAiZ_dYTM5qS88Eq3XxjQ.png"/></div></div></figure><p id="aa8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您的模型将以扩展名为. h5 的分层数据格式(HDF)保存。它包含科学数据的多维数组。</p><p id="f62f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过调用 load model 函数并传入一个文件名来加载之前训练好的模型。然后，我们调用 predict 函数并传入新数据进行预测。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mm"><img src="../Images/18b1c7d2f5d767560f74bee2fb5bb3ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gqfpwPrbviYa2ZQ-3coVyA.png"/></div></div></figure><p id="a016" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">总结</strong></p><ul class=""><li id="42b5" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated">我们学习了如何加载 MNIST 数据集并对其进行归一化。</li><li id="b873" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">我们学习了使用 Keras 实现 CNN。</li><li id="4f66" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">我们看到了如何保存训练好的模型并在以后加载它进行预测。</li><li id="fb91" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">准确率超过 98%,这比我们用常规神经网络实现的准确率高得多。</li></ul></div></div>    
</body>
</html>