<html>
<head>
<title>Perceptrons, Logical Functions, and the XOR problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">感知器、逻辑函数和异或问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/perceptrons-logical-functions-and-the-xor-problem-37ca5025790a?source=collection_archive---------1-----------------------#2018-08-31">https://towardsdatascience.com/perceptrons-logical-functions-and-the-xor-problem-37ca5025790a?source=collection_archive---------1-----------------------#2018-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4003" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">深度学习药丸#2</h2></div><p id="a750" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天我们将探索感知器能做什么，它有什么限制，我们将为超越这些限制做准备！图形和代码支持的一切。</p><h2 id="65af" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">来自<a class="ae lu" rel="noopener" target="_blank" href="/https-medium-com-francesco-cicala-whats-whys-and-hows-of-perceptron-f87c66f512c5">深度学习药丸#1 </a>的元素</h2><p id="c2fc" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">在本系列的<a class="ae lu" rel="noopener" target="_blank" href="/https-medium-com-francesco-cicala-whats-whys-and-hows-of-perceptron-f87c66f512c5">第 1 部分</a>中，我们引入了感知器作为实现以下功能的模型:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ma"><img src="../Images/fb534a2784b34243bf188897282a363f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hm-Whb2f2dgObJuEoCuCAQ.png"/></div></div></figure><p id="c3ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于参数<strong class="kh ir"> <em class="mm"> w </em> </strong>和<em class="mm"> b </em>的特定选择，输出ŷ仅取决于<strong class="kh ir"> </strong>输入向量<strong class="kh ir"> <em class="mm"> x </em> </strong>。我用ŷ(“y 帽”)来表示这个数字是由模型产生/预测的。很快，你就会体会到这种符号的简易性。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mn"><img src="../Images/7d159edba45f15512f9e7ea007985b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CcZl83rOnYbs0vabvOolLA.jpeg"/></div></div></figure><h2 id="cfd8" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">计算图形</h2><p id="c7c7" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">为了可视化一个模型的<strong class="kh ir">架构</strong>，我们使用了所谓的<strong class="kh ir">计算图</strong>:一个用来表示数学函数的有向图。变量和操作都是节点；变量被输入到操作中，操作产生变量。</p><p id="3d6e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们感知机的计算图是:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/82cb6b7d7f026d2997ebccd40d06bb97.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*GRubAZEl0qmrD4u4mCC0Ng.png"/></div></figure><p id="94e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">σ符号通过权重<em class="mm"> </em> <strong class="kh ir"> <em class="mm"> w </em> </strong>和偏差<em class="mm"> b </em>表示输入<em class="mm"> </em> <strong class="kh ir"> <em class="mm"> x </em> </strong>的线性组合。由于这种符号非常复杂，从现在开始，我将按照以下方式简化计算图形:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/303530d494a5f1dc6151d50562da5792.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*9ps6ptfjkgIClD_HBeyOGA.png"/></div></figure><h1 id="e133" class="mq lc iq bd ld mr ms mt lg mu mv mw lj jw mx jx lm jz my ka lp kc mz kd ls na bi translated">感知器能做什么？</h1><p id="723f" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我正在介绍一些感知器可以用它的<em class="mm">能力</em>实现什么的例子(我将在本系列的后续部分讨论这个术语！).逻辑函数是一个很好的起点，因为它们将把我们带到感知器背后的理论的自然发展，因此也是<strong class="kh ir">神经网络</strong>。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/167e8d11781152f8fca01051cd641e56.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*IHlUT-kFAZ_t_ZHxLliJsg.png"/></div></figure><h2 id="6f28" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">非逻辑函数</h2><p id="9fd9" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">让我们从一个非常简单的问题开始:</p><blockquote class="nc nd ne"><p id="bc38" class="kf kg mm kh b ki kj jr kk kl km ju kn nf kp kq kr ng kt ku kv nh kx ky kz la ij bi translated">感知器能实现非逻辑功能吗？</p></blockquote><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/e3069bbb48efe094c2dcc43f95dad0c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:184/format:webp/1*2YxHEu05jeYvxxd9Rsf_7A.png"/></div></figure><p id="a6f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">NOT(x)是一个 1 变量函数，这意味着我们一次只有一个输入:N=1。此外，它是一个<strong class="kh ir">逻辑函数</strong>，因此输入和输出都只有两种可能的状态:0 和 1(即假和真):Heaviside 阶跃函数似乎符合我们的情况，因为它产生一个二进制输出。</p><p id="960f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑到这些因素，我们可以说，如果存在一个可以实现 NOT(x)函数的感知器，它就像左边显示的那样。<br/>给定两个参数<em class="mm"> w </em>和<em class="mm"> b </em>，它将执行以下计算:<br/>ŷ=θ(<em class="mm">wx+b)</em></p><p id="1742" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最基本的问题是:是否存在两个值，如果作为参数选取，允许感知器实现非逻辑功能？当我说<em class="mm">感知器实现一个函数时，</em>我的意思是，对于函数域中的每个输入，感知器返回相同的数字(或向量),函数将返回相同的输入。<br/>回到我们的问题:这些值之所以存在，是因为我们可以很容易地找到它们:让我们选择<em class="mm"> w = -1 </em>和<em class="mm"> b = 0.5。</em></p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="3f81" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到了:</p><pre class="mb mc md me gt nl nm nn no aw np bi"><span id="e509" class="lb lc iq nm b gy nq nr l ns nt">NOT(0) = 1<br/>NOT(1) = 0</span></pre><p id="4056" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得出结论，初始问题的答案是:是的，一个感知器可以实现 NOT 逻辑功能；我们只需要<strong class="kh ir">正确设置它的参数</strong>。请注意，我的解决方案不是唯一的；事实上，对于这个特殊的问题，作为(w，b)点的解是无限的！可以用自己喜欢的；)</p><h2 id="9c80" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">和逻辑功能</h2><p id="de00" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">下一个问题是:</p><blockquote class="nc nd ne"><p id="184f" class="kf kg mm kh b ki kj jr kk kl km ju kn nf kp kq kr ng kt ku kv nh kx ky kz la ij bi translated">感知器能实现 AND 逻辑功能吗？</p></blockquote><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/750b4770c2bf5f1b9891e4ad563056d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*zNs6iNlZIs7-XhNmPHlB9Q.png"/></div></figure><p id="792e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">AND 逻辑函数是一个二元函数，<em class="mm">和(x1，x2) </em>，具有二进制输入和输出。</p><p id="3390" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该图与以下计算相关:<br/>ŷ=θ(<em class="mm">w1 * x1+w2 * x2+b</em></p><p id="e100" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这次我们有三个参数:<em class="mm"> w1 </em>、<em class="mm"> w2、</em>和<em class="mm"> b </em>。你能猜出这些参数的哪三个值能让感知机解决<strong class="kh ir">和问题</strong>吗？</p><p id="b548" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解:<br/> <em class="mm"> w1 = 1，w2 = 1，b = -1.5 </em></p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="eb4c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它会打印:</p><pre class="mb mc md me gt nl nm nn no aw np bi"><span id="67b5" class="lb lc iq nm b gy nq nr l ns nt">AND(1, 1) = 1<br/>AND(1, 0) = 0<br/>AND(0, 1) = 0<br/>AND(0, 0) = 0</span></pre><h2 id="15cc" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">或逻辑函数</h2><p id="ad0b" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated"><em class="mm">或(x1，x2) </em>也是一个二元函数，它的输出是一维的(即一个数)，有两种可能的状态(0 或 1)。因此，我们将使用一个与之前相同架构的感知器。解决 OR 问题的三个参数是什么？</p><p id="fdd3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解:<br/> <em class="mm"> w1 = 1，w2 = 1，b = -0.5 </em></p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="nj nk l"/></div></figure><pre class="mb mc md me gt nl nm nn no aw np bi"><span id="ef4c" class="lb lc iq nm b gy nq nr l ns nt">OR(1, 1) = 1<br/>OR(1, 0) = 1<br/>OR(0, 1) = 1<br/>OR(0, 0) = 0</span></pre><h2 id="c4d5" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">XOR —所有(感知器)对一(逻辑功能)</h2><p id="e608" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我们的结论是，一个单一的感知器与亥维赛激活功能可以实现每一个基本的逻辑功能:非，与和或。它们被称为基本的，因为任何逻辑函数，无论多么复杂，都可以通过这三者的组合来获得。我们可以推断，<strong class="kh ir">如果把我们刚刚搭建的三个感知器适当的连接起来，就可以实现任何逻辑功能！让我们来看看如何:</strong></p><blockquote class="nc nd ne"><p id="d49f" class="kf kg mm kh b ki kj jr kk kl km ju kn nf kp kq kr ng kt ku kv nh kx ky kz la ij bi translated">我们如何建立一个由<strong class="kh ir">基本逻辑感知器</strong>组成的网络，使其实现异或功能？</p></blockquote><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/4533fbb776ad9dcb552c401417098844.png" data-original-src="https://miro.medium.com/v2/resize:fit:336/format:webp/1*YDVqZILfPCwFhePW3iK4nQ.png"/></div></figure><p id="3659" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决方案:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nw"><img src="../Images/87dbaafdb372f53ac68b036b7037f8c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B7j9TH-cCOEpYJzBT5T5zw.png"/></div></div></figure><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/9568e2044ca2e973d984cb4c900cbfdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*Rm1Cd2KDoi1ACE-5KFP_Iw.png"/></div></figure><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="253f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出是:</p><pre class="mb mc md me gt nl nm nn no aw np bi"><span id="a057" class="lb lc iq nm b gy nq nr l ns nt">XOR(1, 1) = 0<br/>XOR(1, 0) = 1<br/>XOR(0, 1) = 1<br/>XOR(0, 0) = 0</span></pre><p id="144f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些就是我们一直在寻找的预测！我们只是把上面的三个感知器组合起来，得到一个更复杂的逻辑函数。</p><p id="6c96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有些人可能想知道，就像我们对前面的函数所做的那样，是否有可能找到单个感知器的参数值，这样它就可以自己解决 XOR 问题。</p><p id="b546" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不会让你为寻找这三个数字而大费周章，因为那是没有用的:答案是它们不存在。<strong class="kh ir">为什么？</strong>答案是异或问题不是<strong class="kh ir">线性</strong> <strong class="kh ir">可分</strong>，我们在本系列下一章深入讨论！</p><p id="7523" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将在几天后发表它，我们将讨论我刚才提到的线性可分性。我将从几何的角度重塑我今天介绍的主题。这样，我们今天得到的每一个结果都会得到它自然直观的解释。</p><p id="e164" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你喜欢这篇文章，我希望你能考虑给它一些掌声！每一次鼓掌都是对我极大的鼓励:)还有，随时在<a class="ae lu" href="https://www.linkedin.com/in/francescocicala/" rel="noopener ugc nofollow" target="_blank"><em class="mm">Linkedin</em></a><em class="mm">上联系我！</em></p><p id="dbab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mm">很快再见，<br/>弗兰克</em></p></div></div>    
</body>
</html>