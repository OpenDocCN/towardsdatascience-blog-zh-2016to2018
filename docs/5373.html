<html>
<head>
<title>Extracting and Transforming Data in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Python 中提取和转换数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/extracting-and-transforming-data-in-python-63291f63d350?source=collection_archive---------8-----------------------#2018-10-14">https://towardsdatascience.com/extracting-and-transforming-data-in-python-63291f63d350?source=collection_archive---------8-----------------------#2018-10-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/fcfc11b4a63659dc29a0446620531267.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BMnmv7Q572kHcnPM6vSZGA.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk"><a class="ae jd" href="https://unsplash.com/photos/ZGnC2gOvzKw" rel="noopener ugc nofollow" target="_blank">(Source)</a></figcaption></figure><div class=""/><div class=""><h2 id="5e2a" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">为了从数据中获得洞察力，你必须对它稍加处理..</h2></div><p id="eaf0" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重要的是能够从数据帧中提取、过滤和转换数据，以便深入到真正重要的数据中。熊猫图书馆有许多技术使这一过程高效而直观。在今天的文章中，我将列出这些技术，并附有代码示例和一些解释。让我们开始吧。</p><p id="5143" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我用随机数创建了一个样本数据帧来玩它。在本文的解释过程中，我们将使用这些数据作为例子。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="34d4" class="mb mc jg lx b gy md me l mf mg">import pandas as pd<br/>import numpy as np<br/>cols = ['col0', 'col1', 'col2', 'col3', 'col4']<br/>rows = ['row0', 'row1', 'row2', 'row3', 'row4']<br/>data = np.random.randint(0, 100, size=(5, 5))<br/>df = pd.DataFrame(data, columns=cols, index=rows)df.head()</span><span id="31e9" class="mb mc jg lx b gy mh me l mf mg"><strong class="lx jh">Out[2]: <br/>      col0  col1  col2  col3  col4<br/>row0    24    78    42     7    96<br/>row1    40     4    80    12    84<br/>row2    83    17    80    26    15<br/>row3    92    68    58    93    33<br/>row4    78    63    35    70    95</strong></span></pre><h1 id="d690" class="mi mc jg bd mj mk ml mm mn mo mp mq mr km ms kn mt kp mu kq mv ks mw kt mx my bi translated">索引数据帧</h1><p id="f410" class="pw-post-body-paragraph kw kx jg ky b kz mz kh lb lc na kk le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">为了从 pandas 数据帧中提取数据，我们可以使用直接索引或访问器。我们可以使用标签选择必要的行和列:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="6c0f" class="mb mc jg lx b gy md me l mf mg">df['col1']['row1']</span><span id="628b" class="mb mc jg lx b gy mh me l mf mg"><strong class="lx jh">Out[3]: 4</strong></span></pre><p id="8cc9" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意这种索引的顺序:首先指定列标签，然后指定行。但事实是，数据集很少，而且很小，而在现实生活中，我们使用的机器要重得多。使用访问器— <em class="ne">来选择数据要好得多。锁定</em>和<em class="ne">。iloc </em>。他们的区别在于<em class="ne">。loc </em>接受标签，而<em class="ne">接受标签。iloc </em> —索引。同样，当我们使用访问器时，我们首先指定行，然后指定列。一开始我很难适应它——SQL 背景，你还能说什么..</p><figure class="ls lt lu lv gt is gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/976e1b03f91603fc0ac973eb46c91a6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*UfYxcD9427DIfgFr8X8vGw.jpeg"/></div></figure><p id="10a6" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，要使用访问器选择单个值，您需要执行以下操作:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="44e0" class="mb mc jg lx b gy md me l mf mg">df.loc['row4', 'col2']<br/><strong class="lx jh">Out[4]: 35</strong> </span><span id="9431" class="mb mc jg lx b gy mh me l mf mg">df.iloc[4, 2]<br/><strong class="lx jh">Out[5]: 35</strong></span></pre><p id="1ffe" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用索引，我们可以从数据帧中选择单个值、系列或数据帧(抱歉，这是同义反复)。上面我已经展示了如何选择一个值。</p><p id="9966" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要再选择几列，只需传递其标签的嵌套列表，DataFrame 将被返回:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="7fa3" class="mb mc jg lx b gy md me l mf mg">df_new = df[['col1','col2']]<br/>df_new.head(3)<br/><br/><strong class="lx jh">Out[6]: <br/>      col1  col2<br/>row0    78    42<br/>row1     4    80<br/>row2    17    80</strong></span></pre><p id="9b05" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您还想选择特定的行，添加它的索引，您将再次获得一个数据帧。这种技术被称为切片，下面会有更详细的介绍。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="2fed" class="mb mc jg lx b gy md me l mf mg">df_new = df[['col1','col2']][1:4]<br/>df_new.head(3)<br/><br/><strong class="lx jh">Out[7]: <br/>      col1  col2<br/>row1     4    80<br/>row2    17    80<br/>row3    68    58</strong></span></pre><p id="d12e" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要选择一个系列，您必须选择包含所有行或一系列行的单个列。每一行代码都会产生相同的输出:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="669e" class="mb mc jg lx b gy md me l mf mg">df['col0']<br/>df.loc[:,'col0']<br/>df.iloc[:, 0]<br/><br/><strong class="lx jh">Out[8]: <br/>row0    24<br/>row1    40<br/>row2    83<br/>row3    92<br/>row4    78<br/>Name: col0, dtype: int32</strong></span></pre><p id="79ab" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">冒号意味着我们要选择所有行或所有列— <em class="ne"> df.loc[:，:] </em>或<em class="ne"> df.iloc[:，:] </em>将返回所有值。慢慢地，我们进入了切片阶段——从数据中选择特定的范围。要对一个系列进行切片，您只需添加要使用其索引选择的一系列行:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="c032" class="mb mc jg lx b gy md me l mf mg">df['col3'][2:5]<br/><br/><strong class="lx jh">Out[12]: <br/>row2    26<br/>row3    93<br/>row4    70<br/>Name: col3, dtype: int32</strong></span></pre><p id="ba86" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要忘记 Python 中的范围——第一个元素被包含，第二个被排除。所以上面的代码将返回索引为 5、6、7、8 和 9 的行。索引从 0 开始。</p><figure class="ls lt lu lv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ng"><img src="../Images/76a1f3aeab2ff73ee6a03bc686b9ff30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WAHbOOFj5eOG_DDV5rfFxA.jpeg"/></div></div></figure><p id="a2bd" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">切片数据帧的工作方式相同。只有一个细微的差别。使用<em class="ne">时。loc </em>(标签)包括两个边框。例如，选择从标签“行 1”到标签“行 4”的行或从行索引 1 到索引 4 的行以及所有列:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="715a" class="mb mc jg lx b gy md me l mf mg">df.loc['row1':'row4', :]<br/><strong class="lx jh">Out[20]: <br/>      col0  col1  col2  col3  col4<br/>row1    40     4    80    12    84<br/>row2    83    17    80    26    15<br/>row3    92    68    58    93    33<br/>row4    78    63    35    70    95</strong><br/></span><span id="7629" class="mb mc jg lx b gy mh me l mf mg">df.iloc[1:4, :]<br/><strong class="lx jh">Out[21]: <br/>      col0  col1  col2  col3  col4<br/>row1    40     4    80    12    84<br/>row2    83    17    80    26    15<br/>row3    92    68    58    93    33</strong></span></pre><p id="f734" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的第一行代码选择了 row1、row2、row3 和 row4。而第二个—仅行 1、行 2 和行 3。下面再举几个例子。</p><p id="bcf3" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">选择从标签“列 1”到标签“列 4”或从列索引 1 到索引 4 的列以及所有行:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="9bf0" class="mb mc jg lx b gy md me l mf mg">df.loc[:, 'col1':'col4']<br/><strong class="lx jh">Out[22]: <br/>      col1  col2  col3  col4<br/>row0    78    42     7    96<br/>row1     4    80    12    84<br/>row2    17    80    26    15<br/>row3    68    58    93    33<br/>row4    63    35    70    95<br/></strong></span><span id="e765" class="mb mc jg lx b gy mh me l mf mg">df.iloc[:, 1:4]<br/><strong class="lx jh">Out[23]: <br/>      col1  col2  col3<br/>row0    78    42     7<br/>row1     4    80    12<br/>row2    17    80    26<br/>row3    68    58    93<br/>row4    63    35    70</strong></span></pre><p id="10b8" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">选择从标签“行 1”到标签“行 4”或从行索引 1 到索引 4 的行，以及从标签“列 1”到标签“列 4”或从列索引 1 到索引 4 的列:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="a336" class="mb mc jg lx b gy md me l mf mg">df.loc['row1':'row4', 'col1':'col4']<br/><strong class="lx jh">Out[24]: <br/>      col1  col2  col3  col4<br/>row1     4    80    12    84<br/>row2    17    80    26    15<br/>row3    68    58    93    33<br/>row4    63    35    70    95</strong><br/></span><span id="2b2d" class="mb mc jg lx b gy mh me l mf mg">df.iloc[1:4,1:4]<strong class="lx jh"><br/>Out[25]: <br/>      col1  col2  col3<br/>row1     4    80    12<br/>row2    17    80    26<br/>row3    68    58    93</strong></span></pre><p id="ff75" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用列表选择不在范围内的特定列或行。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="444f" class="mb mc jg lx b gy md me l mf mg">df.loc['row2':'row4', ['col1','col3']]<br/><strong class="lx jh">Out[28]: <br/>      col1  col3<br/>row2    17    26<br/>row3    68    93<br/>row4    63    70<br/></strong></span><span id="e52d" class="mb mc jg lx b gy mh me l mf mg">df.iloc[[2,4], 0:4]<br/><strong class="lx jh">Out[30]: <br/>      col0  col1  col2  col3<br/>row2    83    17    80    26<br/>row4    78    63    35    70</strong></span></pre><h1 id="f42c" class="mi mc jg bd mj mk ml mm mn mo mp mq mr km ms kn mt kp mu kq mv ks mw kt mx my bi translated">过滤数据帧</h1><p id="9219" class="pw-post-body-paragraph kw kx jg ky b kz mz kh lb lc na kk le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">过滤是一种更通用的工具，它根据数据本身的感兴趣的属性而不是索引或标签来选择数据的一部分。数据帧有几种过滤方法。所有这些方法的基本思想是布尔级数。在这个条件为真的情况下，<em class="ne"> df['col1'] &gt; 20 </em>(我们假设 col1 的类型是 integer)将返回一个布尔序列。我将在这里输入。head()方法，所以不需要向上滚动来匹配数字。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="e253" class="mb mc jg lx b gy md me l mf mg"><strong class="lx jh">Out[2]: <br/>      col0  col1  col2  col3  col4<br/>row0    24    78    42     7    96<br/>row1    40     4    80    12    84<br/>row2    83    17    80    26    15<br/>row3    92    68    58    93    33<br/>row4    78    63    35    70    95</strong></span></pre><p id="676a" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，要选择数据帧中 col1 的值大于 20 的部分，我们将使用以下代码:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="e13e" class="mb mc jg lx b gy md me l mf mg">df[df['col1'] &gt; 20]<br/><em class="ne"># assigning variable also works</em><br/>condition = df['col1'] &gt; 20<br/>df[condition]<br/><br/><strong class="lx jh">Out[31]: <br/>      col0  col1  col2  col3  col4<br/>row0    24    78    42     7    96<br/>row3    92    68    58    93    33<br/>row4    78    63    35    70    95</strong></span></pre><p id="2c33" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用标准的逻辑运算符(and — &amp;，or — |，not — ~)来组合这些过滤器。请注意括号在这些操作中的用法。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="04ac" class="mb mc jg lx b gy md me l mf mg">df[(df['col1'] &gt; 25) &amp; (df['col3'] &lt; 30)] # logical and<br/><strong class="lx jh">Out[33]: <br/>      col0  col1  col2  col3  col4<br/>row0    24    78    42     7    96</strong><br/></span><span id="6531" class="mb mc jg lx b gy mh me l mf mg">df[(df['col1'] &gt; 25) | (df['col3'] &lt; 30)] # logical or<br/><strong class="lx jh">Out[34]: <br/>      col0  col1  col2  col3  col4<br/>row0    24    78    42     7    96<br/>row1    40     4    80    12    84<br/>row2    83    17    80    26    15<br/>row3    92    68    58    93    33<br/>row4    78    63    35    70    95<br/></strong></span><span id="39ec" class="mb mc jg lx b gy mh me l mf mg">df[~(df['col1'] &gt; 25)] # logical not<br/><strong class="lx jh">Out[35]: <br/>      col0  col1  col2  col3  col4<br/>row1    40     4    80    12    84<br/>row2    83    17    80    26    15</strong></span></pre><h2 id="699a" class="mb mc jg bd mj nh ni dn mn nj nk dp mr lf nl nm mt lj nn no mv ln np nq mx nr bi translated">处理 0 和 NaN 值</h2><p id="6305" class="pw-post-body-paragraph kw kx jg ky b kz mz kh lb lc na kk le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">几乎所有的数据集都有零值或 NaN 值，我们肯定想知道它们在哪里。我们的比较特殊，所以我们会稍微修改一下:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="4c39" class="mb mc jg lx b gy md me l mf mg">df.iloc[3, 3] = 0<br/>df.iloc[1, 2] = np.nan<br/>df.iloc[4, 0] = np.nan<br/>df['col5'] = 0<br/>df['col6'] = np.NaN<br/>df.head()<br/><br/><strong class="lx jh">Out[57]: <br/>      col0  col1  col2  col3  col4  col5  col6<br/>row0  24.0    78  42.0     7    96     0   NaN<br/>row1  40.0     4   NaN    12    84     0   NaN<br/>row2  83.0    17  80.0    26    15     0   NaN<br/>row3  92.0    68  58.0     0    33     0   NaN<br/>row4   NaN    63  35.0    70    95     0   NaN</strong></span></pre><p id="279d" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要选择没有任何零值的列，我们可以使用<em class="ne">。all() </em>方法(所有数据都存在):</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="34ab" class="mb mc jg lx b gy md me l mf mg">df.loc[:, df.all()]<strong class="lx jh"><br/><br/>Out[43]: <br/>      col0  col1  col2  col4  col6<br/>row0  24.0    78  42.0    96   NaN<br/>row1  40.0     4   NaN    84   NaN<br/>row2  83.0    17  80.0    15   NaN<br/>row3  92.0    68  58.0    33   NaN<br/>row4   NaN    63  35.0    95   NaN</strong></span></pre><p id="2863" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们希望找到至少有一个非零(任意)值的列，这将有助于:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="1fd1" class="mb mc jg lx b gy md me l mf mg">df.loc[:, df.any()]<br/><br/><strong class="lx jh">Out[47]: <br/>      col0  col1  col2  col3  col4<br/>row0  24.0    78  42.0     7    96<br/>row1  40.0     4   NaN    12    84<br/>row2  83.0    17  80.0    26    15<br/>row3  92.0    68  58.0     0    33<br/>row4   NaN    63  35.0    70    95</strong></span></pre><p id="7fb3" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要选择具有任何 NaN 的列:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="a79c" class="mb mc jg lx b gy md me l mf mg">df.loc[:, df.isnull().any()]<br/><br/><strong class="lx jh">Out[48]: <br/>      col0  col2  col6<br/>row0  24.0  42.0   NaN<br/>row1  40.0   NaN   NaN<br/>row2  83.0  80.0   NaN<br/>row3  92.0  58.0   NaN<br/>row4   NaN  35.0   NaN</strong></span></pre><p id="06ca" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">选择不带 nan 的色谱柱:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="a609" class="mb mc jg lx b gy md me l mf mg">df.loc[:, df.notnull().all()]<br/><br/><strong class="lx jh">Out[49]: <br/>      col1  col3  col4  col5<br/>row0    78     7    96     0<br/>row1     4    12    84     0<br/>row2    17    26    15     0<br/>row3    68     0    33     0<br/>row4    63    70    95     0</strong></span></pre><p id="a7ef" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以删除那些包含 nan 的行，但是这是一个危险的游戏——删除通常不是一个解决方案。您必须理解您的数据，并明智地处理这样的行。我警告过你。</p><figure class="ls lt lu lv gt is gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/1fd4635c0c025b9b2fa7a46e4c90bab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*FezwrUHZv3N52mCy.gif"/></div></figure><p id="0551" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你确定你想知道吗？好..😀</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="bbad" class="mb mc jg lx b gy md me l mf mg">df.dropna(how='all', axis=1) # if all values in a column are NaN it will be dropped<br/><strong class="lx jh">Out[69]: <br/>      col0  col1  col2  col3  col4  col5<br/>row0  24.0    78  42.0     7    96     0<br/>row1  40.0     4   NaN    12    84     0<br/>row2  83.0    17  80.0    26    15     0<br/>row3  92.0    68  58.0     0    33     0<br/>row4   NaN    63  35.0    70    95     0</strong><br/></span><span id="0c31" class="mb mc jg lx b gy mh me l mf mg">df.dropna(how='any', axis=1) # if any value in a row is NaN it will be dropped<br/><strong class="lx jh">Out[71]: <br/>      col1  col3  col4  col5<br/>row0    78     7    96     0<br/>row1     4    12    84     0<br/>row2    17    26    15     0<br/>row3    68     0    33     0<br/>row4    63    70    95     0</strong></span></pre><p id="bf5f" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法不会修改原始数据帧，因此要继续处理过滤后的数据，必须将其分配给新的数据帧或重新分配给现有的数据帧</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="15ac" class="mb mc jg lx b gy md me l mf mg">df = df.dropna(how='any', axis=1)</span></pre><p id="d856" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">过滤的美妙之处在于，我们实际上可以根据一列的值来选择或修改另一列的值。例如，我们可以从 col1 中选择值，其中 col2 大于 35，并通过给每个值加 5 来更新这些值:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="a8db" class="mb mc jg lx b gy md me l mf mg"><em class="ne"># Find a column based on another</em><br/>df['col1'][df['col2'] &gt; 35]<br/><strong class="lx jh">Out[74]: <br/>row0    78<br/>row2    17<br/>row3    68<br/>Name: col1, dtype: int32</strong><br/><br/><em class="ne"># Modify a column based on another</em><br/>df['col1'][df['col2'] &gt; 35] += 5<br/>df['col1']<br/><strong class="lx jh">Out[77]: <br/>row0    83<br/>row1     4<br/>row2    22<br/>row3    73<br/>row4    63<br/>Name: col1, dtype: int32</strong></span></pre><p id="8ef1" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这让我们进入下一部分——</p><h1 id="0e10" class="mi mc jg bd mj mk ml mm mn mo mp mq mr km ms kn mt kp mu kq mv ks mw kt mx my bi translated">转换数据帧</h1><p id="ab2a" class="pw-post-body-paragraph kw kx jg ky b kz mz kh lb lc na kk le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">一旦我们选择或过滤了我们的数据，我们想以某种方式转换它。最好的方法是使用继承到 DataFrames 或 numpy universal funcs 的方法，它们按元素方式转换整列数据。熊猫<em class="ne">就是例子。floordiv() </em>函数(来自文档:<br/>‘data frame 和其他元素的整数除法’)或 numpy 的<em class="ne">。floor_divide() </em> (doc:'返回小于或等于输入的除法的最大整数。').</p><p id="f49c" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果这些函数不可用，我们可以编写自己的函数并与<em class="ne">一起使用。应用()</em>方法。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="c2b2" class="mb mc jg lx b gy md me l mf mg">def some_func(x): <br/>    return x * 2</span><span id="e788" class="mb mc jg lx b gy mh me l mf mg">df.apply(some_func) -- <em class="ne"># update each entry of a DataFrame without any loops</em></span><span id="de99" class="mb mc jg lx b gy mh me l mf mg"><em class="ne"># lambda also works</em> <br/>df.apply(lambda n: n*2) -- <em class="ne"># the same</em></span></pre><p id="4db0" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些函数不返回转换，所以我们必须显式地存储它:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="2eb9" class="mb mc jg lx b gy md me l mf mg">df['new_col'] = df['col4'].apply(lambda n: n*2)<br/>df.head()<br/><br/><strong class="lx jh">Out[82]: <br/>      col0  col1  col2  col3  col4  col5  col6  new_col<br/>row0  24.0    83  42.0     7    96     0   NaN      192<br/>row1  40.0     4   NaN    12    84     0   NaN      168<br/>row2  83.0    22  80.0    26    15     0   NaN       30<br/>row3  92.0    73  58.0     0    33     0   NaN       66<br/>row4   NaN    63  35.0    70    95     0   NaN      190</strong></span></pre><p id="bbd0" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果 index 是一个字符串，它有一个<em class="ne">。允许我们一次修改整个索引的访问器:</em></p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="87e1" class="mb mc jg lx b gy md me l mf mg">df.index.str.upper()<br/><strong class="lx jh">Out[83]: Index(['ROW0', 'ROW1', 'ROW2', 'ROW3', 'ROW4'], dtype='object')</strong></span></pre><p id="c60c" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，我们不能使用<em class="ne">。对索引应用()</em>方法—它的替代方法是<em class="ne">。map() </em></p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="96fc" class="mb mc jg lx b gy md me l mf mg">df.index = df.index.map(str.lower)<br/><strong class="lx jh">Out[85]: Index(['row0', 'row1', 'row2', 'row3', 'row4'], dtype='object')</strong></span></pre><p id="a71a" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是<em class="ne">。map() </em>也可以用在列上。例如:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="d5d5" class="mb mc jg lx b gy md me l mf mg"><em class="ne"># Create the dictionary: red_vs_blue</em><br/>red_vs_blue = {0:'blue', 12:'red'}<br/><br/><em class="ne"># Use the dictionary to map the 'col3' column to the new column df['color']</em><br/>df['color'] = df['col3'].map(red_vs_blue)<br/>df.head()<br/><br/><strong class="lx jh">Out[92]: <br/>      col0  col1  col2  col3  col4  col5  col6  new_col color<br/>row0  24.0    83  42.0     7    96     0   NaN      192   NaN<br/>row1  40.0     4   NaN    12    84     0   NaN      168   red<br/>row2  83.0    22  80.0    26    15     0   NaN       30   NaN<br/>row3  92.0    73  58.0     0    33     0   NaN       66  blue<br/>row4   NaN    63  35.0    70    95     0   NaN      190   NaN</strong></span></pre><p id="f9eb" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">序列和数据帧上的算术运算直接起作用。下面的表达式将创建一个新列，其中索引为<em class="ne"> n </em>的每个值是来自<em class="ne">‘col 3’</em>和<em class="ne">‘col 7’的索引为<em class="ne"> n </em>的值的总和。</em></p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="3209" class="mb mc jg lx b gy md me l mf mg">df['col7'] = df['col3'] + df['col4'] <br/>df.head()<br/><br/><strong class="lx jh">Out[94]: <br/>      col0  col1  col2  col3  col4  col5  col6  new_col color  col7<br/>row0  24.0    83  42.0     7    96     0   NaN      192   NaN   103<br/>row1  40.0     4   NaN    12    84     0   NaN      168   red    96<br/>row2  83.0    22  80.0    26    15     0   NaN       30   NaN    41<br/>row3  92.0    73  58.0     0    33     0   NaN       66  blue    33<br/>row4   NaN    63  35.0    70    95     0   NaN      190   NaN   165</strong></span></pre><p id="e745" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是文章的第二个版本，因为第一个完全是一团糟——代码中有错误，没有例子，也没有其他东西。感谢反馈，我又看了一遍这篇文章，我觉得现在看起来好多了。我在这里用代码片段和例子讲述了用 Python 转换和提取数据的基础知识，希望对刚开始涉足这一领域的人有用。</p><p id="4bca" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同时，热爱数据科学，多笑笑。我们必须乐观，因为我们拥有 21 世纪最性感的工作😀</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="d15c" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ne">原载于</em><a class="ae jd" href="http://sergilehkyi.com/extracting-and-transforming-data-in-python/" rel="noopener ugc nofollow" target="_blank"><em class="ne">sergilehkyi.com</em></a><em class="ne">。</em></p></div></div>    
</body>
</html>