<html>
<head>
<title>Hacking Scikit-Learn’s Vectorizers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">黑客Scikit-Learn的矢量器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/hacking-scikit-learns-vectorizers-9ef26a7170af?source=collection_archive---------2-----------------------#2018-02-15">https://towardsdatascience.com/hacking-scikit-learns-vectorizers-9ef26a7170af?source=collection_archive---------2-----------------------#2018-02-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ee28d16e740bf135f80cb5b9fd3ac0dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mmqb9LIRAyjnWo91Q4F5zw.jpeg"/></div></div></figure><p id="d1a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://en.wikipedia.org/wiki/Natural-language_processing" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"/></a>自然语言处理是一个令人着迷的领域。由于所有的预测因子都是从文本中提取的，因此数据清理、预处理和特征工程对模型的性能有着更加重要的影响。</p><p id="20f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我自己的一个涉及<strong class="ka ir"> NLP </strong>的机器学习项目中工作了几个月之后，我已经了解了关于Scikit-Learn的矢量器的一两件事，我想与大家分享一下。希望在这篇文章结束时，你会有一些新的想法用在你的下一个项目中。</p><h1 id="7b1b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">关于Scikit-Learn的矢量器</h1><p id="7e78" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如你所知，尽管机器可能很先进，但它们不能像人类一样理解单词和句子。为了使文档的语料库更适合计算机，它们必须首先被转换成某种数字结构。有一些技术可以实现这一点，但在这篇文章中，我将重点关注<strong class="ka ir">向量空间</strong>模型，也称为<a class="ae kw" href="https://en.wikipedia.org/wiki/Bag-of-words_model" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">词汇袋</strong> </a> (BoW)模型。</p><p id="9e95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">词汇袋</strong>是解决该问题的一种非常直观的方法，该方法包括:</p><ol class=""><li id="325b" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">按照某种模式将文档分割成令牌。</li><li id="7a47" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">给每个标记分配一个与它在文档和/或语料库中出现的频率成比例的权重。</li><li id="aedd" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">创建文档术语矩阵，每行代表一个文档，每列寻址一个标记。</li></ol><p id="a57f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Scikit-Learn提供的矢量器对象开箱即用，非常可靠，它们允许我们一次有效地执行上述所有步骤，甚至可以应用预处理和关于标记数量和频率的规则。最重要的是，它们有三种不同的风格(还有其他版本，如DictVectorizers，但它们并不常见):</p><ul class=""><li id="b0a5" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mo mg mh mi bi translated"><strong class="ka ir">计数矢量器</strong>:最简单的一个，它计算一个标记在文档中出现的次数，并使用这个值作为它的权重。</li><li id="af9b" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mo mg mh mi bi translated"><strong class="ka ir">哈希矢量器</strong>:这个设计是为了尽可能的提高内存效率。矢量器不是将记号存储为字符串，而是应用<a class="ae kw" href="https://en.wikipedia.org/wiki/Feature_hashing" rel="noopener ugc nofollow" target="_blank">散列技巧</a>将它们编码为数字索引。这种方法的缺点是，一旦矢量化，就无法再检索要素的名称。</li><li id="84f3" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mo mg mh mi bi translated"><strong class="ka ir"> TF-IDF矢量器</strong> : TF-IDF代表“术语频率-逆文档频率”，这意味着分配给每个标记的权重不仅取决于它在文档中的频率，还取决于该术语在整个语料库中的出现频率。更多关于<a class="ae kw" href="http://scikit-learn.org/stable/modules/feature_extraction.html#text-feature-extraction" rel="noopener ugc nofollow" target="_blank">这里</a>。</li></ul><p id="71f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个<strong class="ka ir">计数矢量器</strong>的例子。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0c7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出局:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/1d0e15eed661887fefa8cf4af6eee35b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zn3uK6kRR3q6nIIk."/></div></div></figure><p id="3211" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要更深入地了解每个步骤，请查看我写的这段代码。它实现了Sklearn的CountVectorizer的一个简化版本，该版本被分解成一些小函数，使其更具可解释性。</p><h1 id="3193" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">定制矢量器</h1><p id="7b36" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">矢量器本身非常强大，可以轻松地执行一些令人惊讶的复杂操作。也就是说，通过修改这些结构，可以将Scikit-Learn本身不支持的转换合并到单词包模型中。</p><p id="1d93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建自定义矢量器时主要使用两种方法:使用Sklearn默认分析器的修改版本实例化矢量器，以及创建从CountVectorizer继承的类。</p><h2 id="2d18" class="mw ky iq bd kz mx my dn ld mz na dp lh kj nb nc ll kn nd ne lp kr nf ng lt nh bi translated">修改默认分析器</h2><p id="a742" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在幕后，Sklearn的矢量器调用一系列函数将一组文档转换成文档术语矩阵。其中，三种方法最为突出:</p><ul class=""><li id="9987" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mo mg mh mi bi translated"><strong class="ka ir"> build_preprocessor </strong>:返回一个callable，用于在标记化之前对输入文本进行预处理。</li><li id="75c4" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mo mg mh mi bi translated"><strong class="ka ir"> build_tokenizer </strong>:创建一个函数，能够将文档的语料库拆分成标记。</li><li id="8754" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mo mg mh mi bi translated"><strong class="ka ir"> build_analyzer </strong>:构建一个应用预处理、标记化、移除<a class="ae kw" href="https://en.wikipedia.org/wiki/Stop_words" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">停用词</strong> </a>并创建<a class="ae kw" href="https://en.wikipedia.org/wiki/N-gram" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> n-grams </strong> </a>的分析器函数。</li></ul><p id="400a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简而言之，这些方法负责创建默认的<strong class="ka ir">分析器</strong>、<strong class="ka ir">预处理器</strong>和<strong class="ka ir">标记器</strong>，然后用于转换文档。通过用正确的参数实例化矢量器，我们可以轻松地绕过这些方法，创建一个定制的矢量器。让我们看一个如何实现的例子。</p><p id="728f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们模拟一个场景，我们从web上删除了一些文本。使用默认设置:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8e52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出局:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/8f533f1add98e81c0c56c88d541303fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qVyuUexTgNf8kWqW."/></div></div></figure><p id="3fa6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们通过创建一个矢量器来稍微清理一下文档集，该矢量器在预处理步骤中删除了<a class="ae kw" href="https://dev.w3.org/html5/html-author/charref" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> HTML实体</strong> </a>，并在文档被标记化时删除了<a class="ae kw" href="https://en.wikipedia.org/wiki/Lemmatisation" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">词汇</strong></a><strong class="ka ir"/>:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4f73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出局:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/ddff7ef04ecc6905b725c47bc5af0cd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_ZvjMzWsPbn3ATLC."/></div></div></figure><p id="3afa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看看“x00021”和“x0002e”是如何被人类可读的“！”替换的和“.”而“跳跃”被简化为引理？另外，如果你以前从未使用过<a class="ae kw" href="https://spacy.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> spaCy </strong> </a>，我建议你看一下它的文档。SpaCy 是一个高度优化的模块，能够同时执行多个复杂的<strong class="ka ir"> NLP </strong>任务，它可以是一个救命稻草。</p><p id="4023" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果由于某种原因，您不能将转换分成预处理和标记化阶段(这种方式可能效率不高)，那么您可以选择创建一个定制的分析器来同时执行这两个步骤。</p><h2 id="b603" class="mw ky iq bd kz mx my dn ld mz na dp lh kj nb nc ll kn nd ne lp kr nf ng lt nh bi translated">自定义矢量器类</h2><p id="ea5c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">尽管用户定义的分析器可能会派上用场，但它们会阻止矢量器执行一些操作，如提取<strong class="ka ir"> n元语法</strong>和删除停用词。引用Scikit-Learn的文档:</p><blockquote class="ni nj nk"><p id="c82a" class="jy jz nl ka b kb kc kd ke kf kg kh ki nm kk kl km nn ko kp kq no ks kt ku kv ij bi translated">“默认分析器都调用预处理器和标记器，但是定制分析器将跳过这一步。N-gram提取和停用词过滤发生在分析器级别，因此自定义分析器可能需要重复这些步骤。</p></blockquote><p id="a62a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，当使用预处理器+记号赋予器组合时:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7b43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">矢量器创建<strong class="ka ir">单字</strong>、<strong class="ka ir">双字</strong>并删除<strong class="ka ir">停用词</strong>如“The”:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/61872e7fc6fbef9b3dc3462b89286be3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hrNnVycRdNvBcGnC."/></div></div></figure><p id="9857" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，当尝试使用自定义分析器执行相同的操作时:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3570" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出不显示<strong class="ka ir">二元模型</strong>，包含<strong class="ka ir">停止字</strong>:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/014821c837de29042e1ab353ce8c18b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OLJtgSjKcYhmSphi."/></div></div></figure><p id="a493" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">发生这种情况是因为当使用用户定义的分析器时，<code class="fe np nq nr ns b">build_analyzer</code>方法不调用<code class="fe np nq nr ns b">_word_ngrams</code>，T1负责移除<strong class="ka ir">停止字</strong>并提取<strong class="ka ir"> n元语法</strong>。</p><p id="fe07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">避免这种情况的一种方法是创建定制的矢量器类。这个概念非常简单，只需创建一个从基础矢量器继承的新类，并根据需要覆盖<code class="fe np nq nr ns b">build_preprocessor</code>、<code class="fe np nq nr ns b">build_tokenizer</code>和/或<code class="fe np nq nr ns b">build_analyzer</code>方法。</p><p id="ab01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，让我们再试一次，但是这次创建一个<strong class="ka ir">自定义矢量器类</strong>:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="064c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出局:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/26b089305537059c9558d04fc448c717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0CWlb6WvrLxEobFT."/></div></div></figure><p id="c7f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">非常管用！尽管很耗时，但这种方法让分析器知道在矢量器实例化期间使用的任何参数，从而允许自定义函数与矢量器的其余部分无缝集成。</p><h1 id="03c0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">最后的想法</h1><p id="6525" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">考虑到创建定制矢量器的不同方法，我的建议是总是首先尝试使用最简单的方法。这样你就减少了错误发生的几率，避免了许多不必要的麻烦。</p><p id="f20e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，值得指出的是，这篇文章中讨论的结构本身非常通用，但只有在与<a class="ae kw" href="http://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">管道</strong> </a>中的其他变压器结合使用时，它们的真正潜力才会显现出来。你可以在这里了解更多关于这个<a class="ae kw" href="http://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="ad12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这篇文章给你一套新工具，用在你的下一个项目上！</p></div></div>    
</body>
</html>