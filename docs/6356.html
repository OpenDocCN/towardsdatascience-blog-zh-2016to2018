<html>
<head>
<title>Interesting packages taken from R/Pharma</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">来自 R/Pharma 的有趣包装</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/interesting-packages-taken-from-r-pharma-e89639788180?source=collection_archive---------12-----------------------#2018-12-09">https://towardsdatascience.com/interesting-packages-taken-from-r-pharma-e89639788180?source=collection_archive---------12-----------------------#2018-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c5cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几个月前，我参加了马萨诸塞州剑桥的 R/Pharma 会议。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/ab6ebee02219c35716e118df7bd55481.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uGAoQ-Ljn7LX4rrIAd2GPw.jpeg"/></div></div></figure><p id="d307" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为一个收获，我想到了我的项目，以及如何利用别人提供的解决方案进行改进。<em class="kx"> R </em>中的解决方案主要是<em class="kx"> R 包。</em>我是一名在监管环境下的优秀程序员，所以我列出的解决方案主要是为了帮助你，如果你提供 a)优秀的应用程序 b)统计软件包 c)经过验证的解决方案。让我们来看看哪些 R 包我以前不知道，现在发现确实有用:</p><h1 id="d1e7" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">个人信息管理程序</h1><p id="fd65" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我的大多数同事制作的是报告。实际上是大量的统计报告。由于我们在受监管的环境中工作，所有报告都要经过双重检查。意思是你给它编程，别人也给它编程。你不想浪费时间，因为有一个数学包的更新导致了数字的差异。有一个非常好的解决方案。</p><p id="cf4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Packrat 允许您存储在某个会话/项目中使用的所有包。packrat 的主要指南可以在描述 it 的<a class="ae mb" href="https://rstudio.github.io/packrat/commands.html" rel="noopener ugc nofollow" target="_blank"> RStudio 博客中找到。</a></p><p id="1d5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Packrat 不仅会存储所有的包，还会存储所有的项目文件。它集成在 RStudio 的用户界面中。它让你可以很快地与不同的同事分享项目。</p><p id="3287" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我认为主要的不足是需要一个服务器，在那里你存储所有这些包。这个应该可以用 RStudio 新的<a class="ae mb" href="https://www.rstudio.com/products/package-manager/" rel="noopener ugc nofollow" target="_blank">包管理器</a>解决。另一个缺点是与一些软件包不兼容。我注意到我不能用 packrat 使用 R-3.4.2 下的 BH 包，必须找到一个解决办法。</p><h1 id="19c8" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Diffdf</h1><p id="b06a" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我必须告诉你，我浪费了将近 30%的时间来比较数据。这是测试统计结果或用你编写的统计应用程序进行计算的一项重要任务。在制药和诊断应用中，最相关的方面之一是数据的有效性。确保我们在临床研究、质量保证或日常工作中使用的数据来自同事。对我来说，这个任务不仅很难，而且更难记录。</p><p id="b2ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基兰·马丁的<a class="ae mb" href="https://cran.r-project.org/web/packages/diffdf/index.html" rel="noopener ugc nofollow" target="_blank"> diffdf </a>包真正解决了这个任务。它不仅为你提供了一个整洁的界面，还提供了精心安排的结果。</p><p id="71f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本的 diffdf 示例如下所示:</p><pre class="km kn ko kp gt mc md me mf aw mg bi"><span id="23ed" class="mh kz iq md b gy mi mj l mk ml">library(diffdf)<br/>iris2 &lt;- iris<br/>for (i in 1:3) iris2[i,i] &lt;- i^2<br/>iris2$new_var &lt;- "hello"<br/>class(iris2$Species) &lt;- "some class"<br/>diffdf(iris, iris2)</span></pre><p id="f599" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以看到，基本上新引入了一个列，在 3 个不同的数字列中更改了三个值，并且更改了一个列的类型。所有这三个变化都显示在单独的输出中。此外，还提到了没有变化的内容，如果您没有检查正在比较的数据帧是否完全相等，这可能会非常有帮助。</p><pre class="km kn ko kp gt mc md me mf aw mg bi"><span id="52d2" class="mh kz iq md b gy mi mj l mk ml">Differences found between the objects!<br/><br/>A summary is given below.<br/><br/>There are columns in BASE and COMPARE with different classes !!<br/>All rows are shown in table below<br/><br/>  ==================================<br/>   VARIABLE  CLASS.BASE  CLASS.COMP <br/>  ----------------------------------<br/>   Species     factor    some class <br/>  ----------------------------------<br/><br/>There are columns in COMPARE that are not in BASE !!<br/>All rows are shown in table below<br/><br/>  =========<br/>   COLUMNS <br/>  ---------<br/>   new_var <br/>  ---------<br/><br/>Not all Values Compared Equal<br/>All rows are shown in table below<br/><br/>  =================================<br/>     Variable    No of Differences <br/>  ---------------------------------<br/>   Sepal.Length          1         <br/>   Sepal.Width           1         <br/>   Petal.Length          1         <br/>  ---------------------------------<br/><br/><br/>All rows are shown in table below<br/><br/>  ============================================<br/>     VARIABLE    ..ROWNUMBER..  BASE  COMPARE <br/>  --------------------------------------------<br/>   Sepal.Length        1        5.1      1    <br/>  --------------------------------------------<br/><br/><br/>All rows are shown in table below<br/><br/>  ===========================================<br/>    VARIABLE    ..ROWNUMBER..  BASE  COMPARE <br/>  -------------------------------------------<br/>   Sepal.Width        2         3       4    <br/>  -------------------------------------------<br/><br/><br/>All rows are shown in table below<br/><br/>  ============================================<br/>     VARIABLE    ..ROWNUMBER..  BASE  COMPARE <br/>  --------------------------------------------<br/>   Petal.Length        3        1.3      9    <br/>  --------------------------------------------</span></pre><p id="0793" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出易于阅读，并且包含了完成预期任务所需的所有信息:比较两个数据帧。我真正喜欢的是关于观察到多少差异的快速反馈。如果您有很多不同之处，除了您给列的每个值加了+1，您可以立即在摘要中看到这一点。</p><p id="9f12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，详细信息不仅给出了值的差异，还给出值在表中的位置，这是一个巨大的优势。有时，分析大型患者群组，可以揭示测量值 99，880 的差异，并且您不希望在找到这一差异之前滚动“匹配”表。因此，这个详细视图相对于其他包来说是一个巨大的优势。</p><h1 id="3319" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">档案保管员</h1><p id="a77d" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">旨在改进数据分析结果管理的 R 包。该软件包的主要功能包括:</p><p id="cab5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(I)管理包含 R 对象及其元数据(对象的属性和它们之间的关系)的本地和远程储存库；</p><p id="82c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">㈡将 R 对象存档到储存库；</p><p id="25b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(iii)通过其独特的挂钩共享和检索对象(及其谱系);</p><p id="bd37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">㈣搜索具有特定属性或与其他对象有关系的对象；</p><p id="7b35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">㈤核实物品的身份及其创造背景。</p><p id="ab1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这在可再生数据分析中非常重要。在药理学项目中，你经常需要在很长时间后重现病例。档案包允许在文件中存储模型、数据集和整个 R 对象，这些对象也可以是函数或表达式。现在，您可以将文件存储在长期数据存储器中，甚至在 10 年后，使用 packrat + archivist，您将能够重现您的研究。</p><h2 id="a030" class="mh kz iq bd la mm mn dn le mo mp dp li jy mq mr lm kc ms mt lq kg mu mv lu mw bi translated">任务(ii)示例—恢复模型</h2><p id="9a2c" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">此示例给出了存储在包中的模型列表</p><pre class="km kn ko kp gt mc md me mf aw mg bi"><span id="d573" class="mh kz iq md b gy mi mj l mk ml">library(archivist)<br/>models &lt;- asearch("pbiecek/graphGallery", patterns = "class:lm")<br/>modelsBIC &lt;- sapply(models, BIC)</span><span id="8941" class="mh kz iq md b gy mx mj l mk ml">sort(modelsBIC)</span></pre><h2 id="e7f0" class="mh kz iq bd la mm mn dn le mo mp dp li jy mq mr lm kc ms mt lq kg mu mv lu mw bi translated">任务(I)示例—本地存储对象</h2><p id="59a6" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我在 https://github.com/zappingseb/RPharma2018packages<a class="ae mb" href="https://github.com/zappingseb/RPharma2018packages#archivist" rel="noopener ugc nofollow" target="_blank">的</a>文件夹里有一个 data.frame。您的任务是创建一个新的 data.frame，将其存储在<code class="fe my mz na md b">arepo_new</code>文件夹中，并将其添加到恢复的 data.frame 中。如果一切顺利，data.frames 的总和显示为位置(1，1)的 2。</p><pre class="km kn ko kp gt mc md me mf aw mg bi"><span id="c905" class="mh kz iq md b gy mi mj l mk ml">library(archivist)</span><span id="d181" class="mh kz iq md b gy mx mj l mk ml">repo &lt;- "arepo_new"<br/>createLocalRepo(repoDir = repo, default = TRUE)</span><span id="0b3a" class="mh kz iq md b gy mx mj l mk ml">df &lt;- data.frame(x=c(1,2),y=c(2,3))<br/>saveToRepo(df)</span><span id="7e0b" class="mh kz iq md b gy mx mj l mk ml">setLocalRepo("arepo")<br/>df2 &lt;- loadFromLocalRepo("4a7369a8c51cb1e7efda0b46dad8195e",value = TRUE)</span><span id="da94" class="mh kz iq md b gy mx mj l mk ml">df_test &lt;- df + df2</span><span id="badd" class="mh kz iq md b gy mx mj l mk ml">print(df_test[1,1]==2)</span></pre><p id="1d27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在此任务中，您可以看到，我的旧 data.frame 不仅存储为 data.frame，而且还具有独特的可复制 md5 哈希。这使得在几年后再次找到东西并展示它正是你所需要的东西变得非常容易。</p><h1 id="1ebc" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">logR</h1><p id="a5d2" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">logR 包可以用来记录你的分析步骤。如果您在分析中有很多步骤，并且需要知道这些步骤需要多长时间，状态是什么(错误、警告)以及确切的调用是什么，那么您可以使用 logR 来存储所做的一切。因此，logR 连接到 PostGres 数据库，并在那里记录您分析的所有步骤。我强烈推荐使用 logR，以防您不确定您的分析是否会再次运行它。logR 将检查你的每一个步骤，因此任何失败都会被存储。如果您的下一步运行只是因为设置了任何环境变量，您肯定会看到这一点。下面是来自<a class="ae mb" href="https://github.com/jangorecki" rel="noopener ugc nofollow" target="_blank">作者</a>的 logR 的基本示例:</p><pre class="km kn ko kp gt mc md me mf aw mg bi"><span id="cccd" class="mh kz iq md b gy mi mj l mk ml">library(logR)<br/><br/># setup connection, default to env vars: `POSTGRES_DB`, etc.<br/># if you have docker then: docker run --rm -p 127.0.0.1:5432:5432 -e POSTGRES_PASSWORD=postgres --name pg-logr postgres:9.5<br/>logR_connect()<br/># [1] TRUE<br/><br/># create logr table<br/>logR_schema()<br/><br/># make some logging and calls<br/><br/>logR(1+2) # OK<br/>#[1] 3<br/>logR(log(-1)) # warning<br/>#[1] NaN<br/>f = function() stop("an error")<br/>logR(r &lt;- f()) # stop<br/>#NULL<br/>g = function(n) data.frame(a=sample(letters, n, TRUE))<br/>logR(df &lt;- g(4)) # out rows<br/>#  a<br/>#1 u<br/>#2 c<br/>#3 w<br/>#4 p<br/><br/># try CTRL+C / 'stop' button to interrupt<br/>logR(Sys.sleep(15))<br/><br/># wrapper to: dbReadTable(conn = getOption("logR.conn"), name = "logr")<br/>logR_dump()<br/>#   logr_id              logr_start          expr    status alert                logr_end      timing in_rows out_rows  mail message cond_call  cond_message<br/>#1:       1 2016-02-08 16:35:00.148         1 + 2   success FALSE 2016-02-08 16:35:00.157 0.000049163      NA       NA FALSE      NA        NA            NA<br/>#2:       2 2016-02-08 16:35:00.164       log(-1)   warning  TRUE 2016-02-08 16:35:00.171 0.000170801      NA       NA FALSE      NA   log(-1) NaNs produced<br/>#3:       3 2016-02-08 16:35:00.180      r &lt;- f()     error  TRUE 2016-02-08 16:35:00.187 0.000136896      NA       NA FALSE      NA       f()      an error<br/>#4:       4 2016-02-08 16:35:00.197    df &lt;- g(4)   success FALSE 2016-02-08 16:35:00.213 0.000696145      NA        4 FALSE      NA        NA            NA<br/>#5:       5 2016-02-08 16:35:00.223 Sys.sleep(15) interrupt  TRUE 2016-02-08 16:35:05.434 5.202319000      NA       NA FALSE      NA        NA            NA</span></pre><h1 id="a490" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">RInno——像 Windows 应用程序一样闪亮的应用程序</h1><p id="fbb9" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们经常构建闪亮的应用程序，需要本地 PC 设置才能运行良好。例如，我们是否构建了一个闪亮的应用程序，通过用户的活动目录登录来访问 MySQL 数据库。为了在没有登录窗口的情况下获取 Active Directory 凭证，我们只需在本地运行这个闪亮的应用程序。由于部门中并非所有用户都知道如何运行 R + <code class="fe my mz na md b">runApp()</code>，RInno 对我来说听起来是一个很好的解决方案。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nb"><img src="../Images/ab71bf760f8de02e5726cbfff424346f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwoDG0P8ESvNXyblczyWIA.png"/></div></div></figure><p id="89ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RInno 将你闪亮的应用打包成一个<code class="fe my mz na md b">.exe</code>文件，你的用户可以直接在他们的 PC 上运行。这也将允许他们在本地存储的 Excel 文件上使用奇特的 ggplot 功能。这在数据受到安全保护而无法上传到服务器的情况下非常重要。开发者给出的<a class="ae mb" href="https://github.com/ficonsulting/RInno" rel="noopener ugc nofollow" target="_blank">教程</a>可以帮助你很好的理解这个问题以及如何解决。</p><h1 id="b14a" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">码尺</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nc"><img src="../Images/75a05da45778bc17842415699ac8085d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Gx2bExzFYDD7W5aO"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">Photo by <a class="ae mb" href="https://unsplash.com/@sernarial?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">patricia serna</a> on <a class="ae mb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ba9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">包含评估统计模型预测能力所需的所有度量的软件包。我在第一次治疗中看到了这个包裹。每当我们想到一种恰当的方法来衡量我们的模型和数据之间的差异时，我们会讨论很多不同的方法。当然写<code class="fe my mz na md b">sqrt(sum((x-y)**2))</code>很简单，但是用标尺<code class="fe my mz na md b">two_class_example %&gt;% rmse(x, y)</code>看起来更好。在码尺中，你知道你的数据来自哪里，你可以很容易地交换函数<code class="fe my mz na md b">rmse</code>，而在我展示的例子中，你需要重新编码整个功能。码尺以后会省去我们团队很多讨论。很高兴它出来了。</p></div></div>    
</body>
</html>