<html>
<head>
<title>What makes LightGBM lightning fast?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">是什么让 LightGBM 快如闪电？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-makes-lightgbm-lightning-fast-a27cf0d9785e?source=collection_archive---------4-----------------------#2018-10-15">https://towardsdatascience.com/what-makes-lightgbm-lightning-fast-a27cf0d9785e?source=collection_archive---------4-----------------------#2018-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a660" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解戈斯和 EFB:light GBM 的核心支柱</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7c248efa956b61e38c433684e228e420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mKkwlQF25Rq1ilne5UiEXA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source : <a class="ae kv" href="http://arogozhnikov.github.io/2016/06/24/gradient_boosting_explained.html" rel="noopener ugc nofollow" target="_blank">http://arogozhnikov.github.io/2016/06/24/gradient_boosting_explained.html</a></figcaption></figure><p id="0152" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该员额的结构如下:</p><p id="68ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">1.GBM 基础。</p><p id="39da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.GBM 的计算瓶颈。</p><p id="9307" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.LightGBM 对这些瓶颈的优化</p><h2 id="2249" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">GBM 基础——梯度下降、升压和 GBDT。</strong></h2><blockquote class="ml mm mn"><p id="009b" class="kw kx mo ky b kz la jr lb lc ld ju le mp lg lh li mq lk ll lm mr lo lp lq lr ij bi translated"><strong class="ky ir">什么是梯度下降？</strong></p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/27dbac50f1da340647f5bb41bef597de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3yAe8DsD7aZ4AucCm-7L0Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><strong class="bd mt">Gradient descent graph : </strong>Example of working with the gradient descent method</figcaption></figure><p id="00ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一种优化技术，通过以固定步长跟随斜率来降低损失函数。</p><blockquote class="ml mm mn"><p id="f789" class="kw kx mo ky b kz la jr lb lc ld ju le mp lg lh li mq lk ll lm mr lo lp lq lr ij bi translated"><strong class="ky ir">什么是助推？</strong></p></blockquote><p id="9fce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Boosting 是一种顺序集成技术，其中难以分类的实例被赋予更多的权重。这实质上意味着后续的学习者将更加重视学习错误分类的数据实例。最终模型将是 n 个弱学习者的加权平均值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/1b74c3c2c54ea0bae7380ea14ee56094.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*zFOpJUSU_zgg0FCPBOSXvg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://quantdare.com/what-is-the-difference-between-bagging-and-boosting/" rel="noopener ugc nofollow" target="_blank">https://quantdare.com/what-is-the-difference-between-bagging-and-boosting/</a></figcaption></figure><p id="9b85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随后的学习者更加重视训练不足/错误分类的样本。点大小的变化代表了赋予该实例的权重。点的大小越大，分配给它的权重就越大。请注意，所有模型都是连续的。</p><blockquote class="ml mm mn"><p id="6edc" class="kw kx mo ky b kz la jr lb lc ld ju le mp lg lh li mq lk ll lm mr lo lp lq lr ij bi translated">什么是 GBDT？</p></blockquote><p id="b051" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GBDT(Gradient Boosting Decision Tree)是一种顺序训练的决策树的集成模型(即 Boosting 的集成模型)。在每次迭代中，GBDT 通过拟合残差(到当前迭代为止的误差)来学习决策树。这意味着每个随后的学习者试图学习实际输出和预测的加权和之间的差异，直到迭代之前。使用梯度法可以使误差最小化。</p><p id="4ce9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就把我们带到了文章的第二部分。GBDT 最昂贵的操作是训练决策树，最耗时的任务是寻找最佳分裂点。</p><p id="d41c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">什么是拆分点？</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/aa7ef3e99022624408f8dc2d9b826820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o0E5qzKxkbfzd6hv"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><em class="mw">Source : </em><a class="ae kv" href="https://machinelearningmastery.com/classification-and-regression-trees-for-machine-learning/" rel="noopener ugc nofollow" target="_blank"><em class="mw">https://machinelearningmastery.com/classification-and-regression-trees-for-machine-learning/</em></a></figcaption></figure><p id="51c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分割点是特征值，取决于在树节点上分割的数据。在上面的例子中，数据分割发生在节点 1 的高度(180)和节点 2 的重量(80)。基于信息增益从候选分裂池中选择最佳分裂。换句话说，选择具有最大信息增益的分裂点。</p><blockquote class="ml mm mn"><p id="a01b" class="kw kx mo ky b kz la jr lb lc ld ju le mp lg lh li mq lk ll lm mr lo lp lq lr ij bi translated"><strong class="ky ir">最佳分割点是如何产生的？</strong></p></blockquote><p id="ef75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分裂查找算法用于查找候选分裂。<br/>最流行的分裂查找算法之一是<strong class="ky ir"> <em class="mo">预排序算法</em> </strong>，它列举了预排序值上所有可能的分裂点。这种方法很简单，但是在计算能力和内存方面效率很低。<br/>第二种方法是基于<strong class="ky ir"> <em class="mo">直方图的算法</em> </strong>，该算法在训练期间将连续的特征桶入离散的箱中以构建特征直方图。直方图构建的开销为 O(#data * #feature)，分裂点查找的开销为 O(#bin * #feature)。由于 bin &lt; &lt;数据直方图的建立将支配计算的复杂性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/f670c12c1daeabe9ab350e21b745c968.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*qJOh7NqBlxPGe3xsiq4hoA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><em class="mw">Binning example : Binning has greatly reduced the number of candidate splits</em></figcaption></figure><p id="980e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与使用 GBM 的 sklearn 相比，LightGBM 和 xgboost 都使用基于直方图的分裂查找(这是它速度慢的原因之一)。让我们从这篇文章的症结开始</p><blockquote class="ml mm mn"><p id="3b2c" class="kw kx mo ky b kz la jr lb lc ld ju le mp lg lh li mq lk ll lm mr lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="iq">是什么让 LightGBM 与众不同？</em> </strong></p></blockquote><p id="898f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">LightGBM 旨在通过使用<strong class="ky ir"> <em class="mo">【高斯】</em> </strong>和<strong class="ky ir"> <em class="mo"> EFB 对数据和特征进行下采样来降低直方图构建的复杂度。</em> </strong>这将降低<strong class="ky ir"> (O(data2 * bundles)) </strong>的复杂度，其中<strong class="ky ir"> data2 &lt;数据和 bundles &lt; &lt;特性</strong>。</p><blockquote class="ml mm mn"><p id="1084" class="kw kx mo ky b kz la jr lb lc ld ju le mp lg lh li mq lk ll lm mr lo lp lq lr ij bi translated"><strong class="ky ir">高斯是什么？</strong></p></blockquote><p id="a04d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GOSS(Gradient Based One Side Sampling)是一种基于梯度对样本进行下采样的新型采样方法。正如我们所知，梯度小的实例训练良好(训练误差小)，梯度大的实例训练不足。一种简单的下采样方法是通过只关注具有大梯度的实例来丢弃具有小梯度的实例，但是这将改变数据分布。简而言之，GOSS 保留具有大梯度的实例，同时对具有小梯度的实例执行随机采样。</p><ol class=""><li id="479a" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nd ne nf ng bi translated"><strong class="ky ir">高斯计算的直观步骤<br/>T36】1<strong class="ky ir">。</strong>根据绝对梯度以降序对实例进行排序<br/> 2。选择前 a * 100%个实例。【欠训练/大梯度】<br/> 3。从其余数据中随机抽取 b * 100%的实例。这将通过因子 b ( b &lt; 1 ) <br/> 4 减少训练有素的例子的贡献。没有点 3，具有小梯度的样本计数将是 1-a(目前是 b)。为了保持原始分布光，GBM 通过常数(1-a)/b 放大具有小梯度的样本的贡献，以将更多焦点放在训练不足的实例上。这将更多的注意力放在训练不足的实例上，而不会改变太多的数据分布。</strong></li></ol><p id="0a43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mo"> 2。</em> <strong class="ky ir"> <em class="mo">形式算法为戈斯</em> </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/2d49e4756f73e9599c8d83d618d15bd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*R9Qxmejhs1rbXsd1Rmo2-g.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Algorithm 2 from the original paper</figcaption></figure><blockquote class="ml mm mn"><p id="f35f" class="kw kx mo ky b kz la jr lb lc ld ju le mp lg lh li mq lk ll lm mr lo lp lq lr ij bi translated"><strong class="ky ir">什么是 EFB(独家功能捆绑)？</strong></p></blockquote><p id="590a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住直方图构建需要 O(#data * #feature)。如果我们能够向下采样#特性，我们将加快树学习。LightGBM 通过将特性捆绑在一起来实现这一点。我们通常处理高维数据。这种数据有许多相互排斥的特征，即它们从不同时取零值。LightGBM 安全地识别这样的特征，并将它们捆绑成单个特征，以将复杂度降低到<strong class="ky ir"> <em class="mo"> O(#data * #bundle) </em> </strong>其中#bundle &lt; &lt; #feature。</p><p id="3457" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">EFB 的第 1 部分:识别可以捆绑在一起的特性</strong></p><p id="de50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建功能包的直观说明</p><ol class=""><li id="e069" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nd ne nf ng bi translated">构建一个带加权边(衡量要素间冲突的标准)的图。冲突是具有重叠非零值的排他性特征的比例的度量。</li><li id="497b" class="my mz iq ky b kz ni lc nj lf nk lj nl ln nm lr nd ne nf ng bi translated">按非零实例数降序对要素进行排序。</li><li id="bf00" class="my mz iq ky b kz ni lc nj lf nk lj nl ln nm lr nd ne nf ng bi translated">遍历特征的有序列表，并将该特征分配给现有束(如果冲突&lt; threshold) or create a new bundle (if conflict &gt;阈值)。</li></ol><p id="cdb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mo">捆绑特性的形式化算法</em> </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/3f0af34072aa57a5b91b0f3c997e1fb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*RxnB_JE7uZh4Onz_xwxXHg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Algorithm 3 from the official paper</figcaption></figure><p id="4925" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">EFB 第二部分:特征合并算法</strong></p><p id="beca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将通过一个例子来理解合并特征背后的直觉。但在此之前，让我们先回答以下问题:</p><blockquote class="ml mm mn"><p id="3f34" class="kw kx mo ky b kz la jr lb lc ld ju le mp lg lh li mq lk ll lm mr lo lp lq lr ij bi translated">EFB 在实现什么？</p></blockquote><p id="aa5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">EFB 正在合并这些功能，以降低训练的复杂性。为了保持合并的可逆性，我们将把独有的特征保存在不同的容器中。</p><blockquote class="ml mm mn"><p id="80df" class="kw kx mo ky b kz la jr lb lc ld ju le mp lg lh li mq lk ll lm mr lo lp lq lr ij bi translated"><strong class="ky ir">合并的例子</strong></p></blockquote><p id="0ceb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的示例中，您可以看到功能 1 和功能 2 是互斥的。为了实现不重叠的桶，我们增加了特征 1 到特征 2 的包大小。这确保了捆绑特征(特征 1 和特征 2)的非零数据点位于不同的桶中。在 feature_bundle 中，存储桶 1 到 4 包含 feature1 的非零实例，存储桶 5、6 包含 feature2 的非零实例。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/1615da40f3986c009d9672e010fa4091.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*SigQkx_yJFh_5ZVmJvCpxQ.png"/></div></figure><p id="35d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">合并特征的直观说明</strong></p><ol class=""><li id="5299" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nd ne nf ng bi translated">计算要添加到特征包中每个特征的偏移量。</li><li id="dc67" class="my mz iq ky b kz ni lc nj lf nk lj nl ln nm lr nd ne nf ng bi translated">迭代每个数据实例和特征。</li><li id="0124" class="my mz iq ky b kz ni lc nj lf nk lj nl ln nm lr nd ne nf ng bi translated">对于所有特性都为零的情况，将新桶初始化为零。</li><li id="c141" class="my mz iq ky b kz ni lc nj lf nk lj nl ln nm lr nd ne nf ng bi translated">通过将各自的偏移量添加到该特征的原始桶中，为特征的每个非零实例计算新桶。</li></ol><p id="1583" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">特征合并的形式算法</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/37a656494174d38ef973a261b4dc68c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*h2awiG8ja01sX_N97O4F_w.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Algorithm 4 from the official paper</figcaption></figure><p id="6f0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至此，我们已经涵盖了原始论文中提出的大多数优化。我希望这篇文章能让你对 LightGBM 库的核心概念有所了解。至此，我完成了写博客的第一次尝试。请在下面分享您的想法、反馈或建议。</p><p id="70b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mo">参考文献</em> </strong></p><ol class=""><li id="4acb" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nd ne nf ng bi translated"><a class="ae kv" href="https://papers.nips.cc/paper/6907-lightgbm-a-highly-efficient-gradient-boosting-decision-tree.pdf" rel="noopener ugc nofollow" target="_blank">https://papers . nips . cc/paper/6907-light GBM-a-high-efficient-gradient-boosting-decision-tree . pdf</a></li><li id="f296" class="my mz iq ky b kz ni lc nj lf nk lj nl ln nm lr nd ne nf ng bi translated"><a class="ae kv" href="https://quantdare.com/what-is-the-difference-between-bagging-and-boosting/" rel="noopener ugc nofollow" target="_blank">https://quant dare . com/bagging-and-boosting 的区别是什么/ </a></li><li id="b264" class="my mz iq ky b kz ni lc nj lf nk lj nl ln nm lr nd ne nf ng bi translated"><a class="ae kv" href="http://mlexplained.com/2018/01/05/lightgbm-and-xgboost-explained/" rel="noopener ugc nofollow" target="_blank">http://ml explained . com/2018/01/05/light GBM-and-xgboost-explained/</a></li><li id="d9a9" class="my mz iq ky b kz ni lc nj lf nk lj nl ln nm lr nd ne nf ng bi translated"><a class="ae kv" href="https://github.com/Microsoft/LightGBM" rel="noopener ugc nofollow" target="_blank">https://github.com/Microsoft/LightGBM</a></li></ol></div></div>    
</body>
</html>