<html>
<head>
<title>How to extract data from MS Word Documents using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 Python 从 MS Word 文档中提取数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-extract-data-from-ms-word-documents-using-python-ed3fbb48c122?source=collection_archive---------0-----------------------#2018-10-31">https://towardsdatascience.com/how-to-extract-data-from-ms-word-documents-using-python-ed3fbb48c122?source=collection_archive---------0-----------------------#2018-10-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c605" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇博客将详细介绍如何从本地 Word 文档中提取信息。由于许多公司和角色都与 Microsoft Office 套件密不可分，对于任何面临通过传输数据的人来说，这都是一个有用的博客。多克还是。docx 格式。</p><p id="dedb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为先决条件，您需要在计算机上安装 Python。对于那些在工作中这样做的人，你可能没有管理员权限。<a class="ae kl" href="https://medium.com/@GalarnykMichael/install-python-on-windows-anaconda-c63c7c3d1444" rel="noopener">这篇博客</a>解释了如何在没有管理员权限的情况下在 Windows 机器上安装 Anaconda。</p><p id="8ea7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里找到支持这个博客<a class="ae kl" href="https://github.com/nmolivo/tesu_scraper/blob/master/Python_Blogs/01_extract_from_MSWord.ipynb" rel="noopener ugc nofollow" target="_blank">的笔记本。</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/6e4b476e9d033ec01bfe14979f17cedd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7oAmMEW4lvpuOARbVJTzrA.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Image created with Microsoft Word and google searches “Microsoft Word Logo” and “Python Logo”</figcaption></figure><p id="20d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将利用每个 word 文档的 XML 构成。从那里，我们将使用 regex 库来查找文档文本中的每个 URL，然后将这些 URL 添加到一个列表中，这对于执行 for 循环来说将是完美的。</p><pre class="kn ko kp kq gt lc ld le lf aw lg bi"><span id="a810" class="lh li iq ld b gy lj lk l ll lm">#specific to extracting information from word documents<br/><strong class="ld ir">import</strong> <strong class="ld ir">os</strong><br/><strong class="ld ir">import</strong> <strong class="ld ir">zipfile</strong></span><span id="2ab7" class="lh li iq ld b gy ln lk l ll lm">#other tools useful in extracting the information from our document<br/><strong class="ld ir">import</strong> <strong class="ld ir">re</strong></span><span id="71ef" class="lh li iq ld b gy ln lk l ll lm">#to pretty print our xml:<br/><strong class="ld ir">import xml.dom.minidom</strong></span></pre><ul class=""><li id="6605" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated"><a class="ae kl" href="https://docs.python.org/3/library/os.html" rel="noopener ugc nofollow" target="_blank"> os </a>将允许您在操作系统上导航和查找相关文件</li><li id="dac8" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated"><a class="ae kl" href="https://docs.python.org/3/library/zipfile.html" rel="noopener ugc nofollow" target="_blank"> zipfile </a>将允许你从文件中提取 xml</li><li id="926e" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated"><a class="ae kl" href="https://docs.python.org/3/library/xml.dom.minidom.html" rel="noopener ugc nofollow" target="_blank"> xml.dom.minidom </a>解析 xml 代码</li></ul><p id="1586" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要指导我们的代码在文件存储的位置打开文件。要从我们的笔记本上看到这一点(而不是打开文件浏览器)，我们可以使用<code class="fe mc md me ld b">os</code>。虽然知道了感兴趣的单个文件的路径就不需要在这个简单的例子中使用<code class="fe mc md me ld b">os</code>,但是这个库以后可以用来创建存储在目标文件夹中的文档列表。如果您想编写一个 for 循环来从文件夹中存储的所有 word 文档中提取信息，那么在文件夹中存储一个文档列表会很有帮助。</p><p id="595b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要查看当前目录中的文件列表，请在<code class="fe mc md me ld b">os</code>文件路径中使用一个句点:</p><pre class="kn ko kp kq gt lc ld le lf aw lg bi"><span id="0bb8" class="lh li iq ld b gy lj lk l ll lm">os.listdir('.')</span></pre><p id="8040" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要查看当前位置上方目录中的文件列表，请使用双句点:</p><pre class="kn ko kp kq gt lc ld le lf aw lg bi"><span id="3bb1" class="lh li iq ld b gy lj lk l ll lm">os.listdir('..')</span></pre><p id="0829" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦找到 word 文档的存储位置，就可以将找到的文件路径转换为 zip 文件。ZipFile 文件类型，对于我们来说，它是可读的。</p><blockquote class="mf mg mh"><p id="c73c" class="jn jo mi jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated">ZIP 文件格式是一种常见的归档和压缩标准</p><p id="914b" class="jn jo mi jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated"><a class="ae kl" href="https://docs.python.org/3/library/zipfile.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/zipfile.html</a></p></blockquote><pre class="kn ko kp kq gt lc ld le lf aw lg bi"><span id="dcbd" class="lh li iq ld b gy lj lk l ll lm">document = zipfile.ZipFile('../docs/TESU CBE 29 Employee Job Description Evaluation - Final Approved.docx')</span><span id="9aff" class="lh li iq ld b gy ln lk l ll lm">#document will be the filetype zipfile.ZipFile</span></pre><p id="e066" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，zipfile 类的<code class="fe mc md me ld b">.read()</code>对象需要一个名称参数，它不同于文件名或文件路径。</p><pre class="kn ko kp kq gt lc ld le lf aw lg bi"><span id="81a7" class="lh li iq ld b gy lj lk l ll lm">ZipFile.read(name, pwd=None)</span></pre><p id="a082" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要查看可用名称的示例，我们可以使用<code class="fe mc md me ld b">.name()</code>对象</p><pre class="kn ko kp kq gt lc ld le lf aw lg bi"><span id="8303" class="lh li iq ld b gy lj lk l ll lm">document.namelist()</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mm"><img src="../Images/5d28ba20957d626bc8f98a56305d5837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ATXnrcyVApfctvUej8N5g.png"/></div></div></figure><p id="59c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个博客的<a class="ae kl" href="https://github.com/nmolivo/tesu_scraper/blob/master/Python_Blogs/01_extract_from_MSWord.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter 笔记本中，我探究了其中几个名字来展示它们是什么。包含 Word 文档正文文本的名称为“word/document.xml”</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mn"><img src="../Images/b201b17d6422f70b20332cc5ce7ad588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*deECn4SPQHfy3JxHLgFkQg.png"/></div></div></figure><p id="9867" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在 StackOverflow 用户<a class="ae kl" href="https://stackoverflow.com/users/47775/nick-bolton" rel="noopener ugc nofollow" target="_blank"> Nate Bolton </a>对问题的回答中发现了漂亮的打印技术:<a class="ae kl" href="https://stackoverflow.com/questions/749796/pretty-printing-xml-in-python" rel="noopener ugc nofollow" target="_blank">用 Python 漂亮地打印 XML</a>。</p><p id="26f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将只使用漂亮的字体来帮助我们识别 XML 中的模式以提取我们的数据。我个人不太了解 XML，所以我将依靠语法模式来查找 word 文档文本中的每个 URL。如果您已经知道提取数据的语法模式，您可能根本不需要打印出来。</p><p id="4ff4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，我们发现字符<code class="fe mc md me ld b">&gt;http</code>和<code class="fe mc md me ld b">&lt;</code>包围了文档文本中包含的每个超链接。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/870e3c0e6c173c74202fc26ed54d158e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*xYxE3xgs7WSvGNYEuo1gqg.png"/></div></figure><p id="6ffb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我需要完成我们的目标，收集上述字符之间的所有文本。为了帮助使用 regex 实现这一点，我使用了下面的 StackOverflow 问题，它包含了我在最初的 ask 中要寻找的内容:<a class="ae kl" href="https://stackoverflow.com/questions/1454913/regular-expression-to-find-a-string-included-between-two-characters-while-exclud" rel="noopener ugc nofollow" target="_blank">正则表达式查找两个字符之间包含的字符串，同时排除分隔符。</a></p><p id="476a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然我确实想保留<code class="fe mc md me ld b">http</code>，但我不想保留<code class="fe mc md me ld b">&lt;</code>或<code class="fe mc md me ld b">&gt;</code>。我将使用字符串切片和列表理解对列表项进行这些修改。</p><pre class="kn ko kp kq gt lc ld le lf aw lg bi"><span id="ab97" class="lh li iq ld b gy lj lk l ll lm">link_list = re.findall('http.*?\&lt;',xml_str)[1:]<br/>link_list = [x[:-1] for x in link_list]</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mp"><img src="../Images/d9e0f725aa0834eb98d1f78b8fc0e265.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zCUm7WPOw4HVUbeqZhdsPg.png"/></div></div></figure><p id="432d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要查看这个博客后面的完整 Jupyter 笔记本，<a class="ae kl" href="https://github.com/nmolivo/tesu_scraper/blob/master/Python_Blogs/01_extract_from_MSWord.ipynb" rel="noopener ugc nofollow" target="_blank">点击这里</a>！</p><p id="1d42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您对使用 python 创建和编写 MS Word 文档感兴趣，请查看库<a class="ae kl" href="https://python-docx.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> python-docx </a>。</p><p id="94ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有其他从 word 文档中提取文本和信息的方法，比如在下面的<a class="ae kl" href="https://python-forum.io/Thread-extract-data-inside-a-table-from-a-doc-file" rel="noopener ugc nofollow" target="_blank"> Python 论坛帖子</a>的回答中提到的 docx2txt 和 docx 库。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="2cdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我关于托马斯·爱迪生州立大学(苏特)开源材料可访问性倡议的博客的姊妹博客。<a class="ae kl" href="https://medium.com/@NatalieOlivo/preserving-web-content-of-links-provided-in-a-word-doc-using-aws-services-ec2-and-s3-2c4f0cee0a26" rel="noopener">中邮</a> / <a class="ae kl" href="https://github.com/nmolivo/tesu_scraper" rel="noopener ugc nofollow" target="_blank"> Github 资源库</a></p><p id="7144" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我为这个项目撰写的第一篇博客很具体，有点笨拙，所以这篇博客是我将撰写的系列文章中的第一篇，深入探讨苏特项目的各个方面，并使材料更容易理解。</p></div></div>    
</body>
</html>