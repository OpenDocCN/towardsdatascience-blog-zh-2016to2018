# 语法演变的 PonyGE2 介绍

> 原文：<https://towardsdatascience.com/introduction-to-ponyge2-for-grammatical-evolution-d51c29f2315a?source=collection_archive---------1----------------------->

语法进化是算法优化的一种强有力的方法。给定一个目标函数和一个搜索空间(语法)，有可能使用进化计算方法来进化一个算法，以最优地(或至少有效地)最大化目标函数。

PonyGE2 是 Python3 的一个实现，它让 GE 变得简单。本演练讨论了 GE 的优点和缺点，并提供了一个如何用 GE 改进您自己的算法的示例。一篇全面描述 PonyGE2 运作的论文可以在[这里](https://arxiv.org/pdf/1703.08535.pdf)找到。

不幸的是，在当前计算机上用 PonyGE2 进行语法进化还不够快，不能在合理的时间内从大量语法中进化出函数，但这种技术肯定是未来需要关注的。

# 语法演变

这种方法最初是由[的迈克尔·奥尼尔](http://ieeexplore.ieee.org/document/942529/)(付费墙)博士在 2001 年提出的，作为一种将进化计算方法应用于具有正式语法结构的问题的方式，比如算法。

一个正式的语法可以被认为是定义一种语言的一套规则，或者仅仅是一种规定什么样的单词组合有意义的官方方式。在英语中，我们在学说话时从父母那里学到这些，在学校里也是如此。学习第二语言时，通常可以分为两个步骤:

1.  学习词汇
2.  学习语法

编程并没有太大的不同，编程语言之间的主要区别不是你试图实现什么，而是你如何告诉计算机去做。

那么我们如何向计算机教授语法呢？那么这些词是如何用于进化优化的呢？

这个过程大概是这样的:

1.  定义语法的巴克斯诺尔形式(BNF)表示；
2.  随机生成线性染色体来编码信息；
3.  通过将语法映射到染色体并对照适应度函数进行测试来评估染色体的适应度；
4.  使用交叉、变异、繁殖等遗传算子生成下一代染色体；
5.  重复第 3 步和第 4 步一定数量的世代。

## 巴克斯诺尔形式

BNF 语法是一种编写计算机可以理解的语法的方式(上下文无关)。在 Python 中，它由包含 4 个集合的元组表示:

*   t:终端设备
*   n:非终结集
*   生产规则集
*   s:开始符号(是 N 的成员)。

这可能不能澄清事实，但是记住这一点是有好处的。让我们看一个例子:

```
T = {+, -, /, *, x, y}
```

所以终端集是你想在程序中使用的所有操作符和变量的集合。

```
N = {<e>, <o>, <v>}
```

非终结集是程序可以承担的所有生产活动的集合。在这种情况下，`<e>`是一个表达式，`<o>`是一个运算符，`<v>`是一个变量。

`P`接下来是生产规则的设定:

```
<e> ::= <e><o><e> | <v>
<o> ::= + | - | / | *
<v> ::= x | y
```

注意，`P`中的所有条目都是`T`或`N`的条目。管道操作符`|`代表`or`。因此，当在染色体中遇到`<e>`时，它要么被替换为`<e><o><e>`，要么被替换为`<v>`，对于`<o>`和`<v>`也是如此。

最后，开始符号:

```
S = <e>
```

这可能仍然很令人困惑，但是在评估染色体时，以这种形式表示语法的原因变得很明显。

## 染色体

描述染色体最简单的方式是作为一个非负整数数组。值并不重要，但长度很重要(稍后会详细介绍)。

举个例子，我们称我们的染色体为:

```
C: [4, 15, 75, 8, 41, 12]
```

## 将染色体映射到语法

现在一切都在一起了。记得我们的开始符号是:

```
<e>
```

现在，根据我们的生产规则`P`，当遇到一个`<e>`时，要么用`<e><o><e>`替换，要么用`<v>`替换。但是我们怎么知道是哪一个呢？染色体告诉我们。染色体的第一个值是`4`，产生式规则中有`<e>`的`2`选项。`4 mod 2`是`0`，所以我们从产生式规则`<e><o><e>`中取第`0` -th(零索引，所以真的是`1` -st 条目)选项。

所以现在我们的表达式已经扩展到了`<e><o><e>`，我们正在评估第一个条目`<e>`(因为它不是终端集的成员，所以我们一直评估每个条目，直到它被终端集的成员替换)。

我们知道在产生式规则中有`<e>`的`2`选项，所以我们取染色体中的第二个条目`15`，并且`15 mod 2`给出了`1`，所以我们从产生式规则`<v>`中取第一个(零索引，所以实际上是第二个条目)选项。

我们继续以下步骤:

*   完整表达式:`<v><o><e>`
    当前表达式:`<v>`
    语法中`<v>`选项个数:`2`
    染色体值:`75``75 mod 2 = 1`
    用`y`替换`<v>`
*   完整表达式:`y <o><e>`
    当前表达式:`<o>`
    语法中`<o>`选项个数:`4`
    染色体值:`8`
    `8 mod 4 = 0`
    用`+`替换`<o>`
*   完整表达式:`y + <e>`
    当前表达式:`<e>`
    语法中`<e>`选项个数:`2`
    染色体值:`41`
    `41 mod 2 = 1`
    用`<v>`替换`<e>`
*   完整表达式:`y + <v>`
    当前表达式:`<v>`
    语法中`<v>`选项个数:`2`
    染色体值:`12`
    `12 mod 2 = 0`
    用`x`替换`<v>`

最终表情:`y + x`

所以我们已经用我们的语法表示把我们的染色体(数组)变成了一个函数！请随意重读几遍，因为理解表达式和运算符的来源需要一些时间。

## 评估适应度函数

现在我们有了一个语法上正确的函数，我们可以根据一些适应度函数来评估这个函数的性能。那些表现良好的功能有更大的机会将它们的 DNA 传递给下一代染色体。从这一点来看，GE 与其他遗传算法没有太大的不同，因为染色体被交叉和变异以产生下一代染色体，然后这些染色体被映射到语法并根据适应度函数进行测试。

这将持续用户指定的代数，最后将最有效的(适应度函数的最佳分数)算法返回给您。

# 通用电气公司分析

现在你(希望)对语法进化有了更多的了解，你可能会问为什么它这么好？

首先是快，真的快。通过代代相传信息，它大大改进了随机搜索。

其次，因为语法是你写的，你可以很容易地将领域知识编码到函数中。你可能会经常听到这种说法，并问“这到底是什么意思？”(我知道我有)。以下是一些例子:

*   允许访问你所有的信息，不管它是否有用。这可以通过在语法中使用一个`<v>`表达式来实现，并且包含你想要的所有变量。
*   根据需要使程序尽可能复杂或简单。在`<e>`中包含许多选项(包括重复的选项，以改变特定操作符被选中的机会)允许容易地操纵进化程序的复杂性。
*   通过设置`<n> ::= 0|1|2|3|4|5|6|7|8|9`然后`<const> ::= <n><n><n>.<n><n><n>`来定义常量的精度等级，设置精度为 3 位小数的 0 到 999 之间的常量。
*   包含表达式包含`<fn>(<e>)`和`<fn> ::= sin | max`的函数

这一切都很酷，但通用电气也有一些缺点。首先，如上所述，染色体的长度确实会导致程序无效。对于上面的例子，如果染色体中的倒数第二个条目是 42 而不是 41，那么`<e>`将被替换为`<e><o><e>`，但是没有留下染色体数据来评估这些表达式。由于该染色体无效，因此不能根据适应度函数对其进行评估。因此，虽然一条染色体可能包含接近好的解决方案，但它永远不会为人所知。

与此相反的是，程序进化时没有使用整个染色体。剩余的数据称为尾部，可以忽略。因此，通常最好将染色体构造为长尾，因为这可以减少无效解出现的机会。

然而，可能最大的缺点是，语法必须非常非常仔细地构建，为问题构建适当的语法和适应度函数需要一点艺术。除此之外，“大”语法可能需要很长时间才能进化。包括单级 for 循环、if 语句、列表函数和字典操作的语法可能需要 12 个小时以上才能完成。希望这在未来会有所改善，但这是阻止语法进化取代人类代码优化器的主要原因吗…

所以现在你有希望对语法演变有更多的了解，我们可以尝试在 PonyGE2 中实现一个简单的例子。

# PonyGE2

PonyGE2 可以从[这里](https://github.com/jmmcd/PonyGE2)克隆或者分叉。不需要任何设置，演化将从带有适当参数的命令行运行。

研究这个包的最好方法是通过一个例子来完成。我们将尝试开发一个函数来查找列表中的最大值。这很容易在 Python 中用`max()`或函数实现:

```
for val in list:
    if val >= current_max:
        current_max = val
```

第一步是创建一个适应度函数，或者我们想要最大化或最小化的函数。这里的术语有点混乱，因为我们正在进化一个函数，其结果将优化适应度函数。目前我们只是在讨论适应度函数。

这些例子的所有代码都包含在 https://github.com/Padam-0/NC-GA 的[中](https://github.com/Padam-0/NC-GA)

在`PonyGE2/src/fitness`中有很多例子，要运行你自己的，在那个文件夹中创建一个名为`max_in_list.py`的文件，结构如下:

```
*from* fitness.base_ff_classes.base_ff *import* base_ff
import random
import time*class* max_in_list(base_ff):
    *def* __init__(self):
        # Initialise base fitness function class.
        super().__init__() *def* evaluate(self, *ind*, ***kwargs*):
        p = *ind*.phenotype print("\n" + p) fitness = 0 for trial in range(50):
            self.test_list = generate_list()
            m = max(self.test_list) d = {'test_list': self.test_list} *try*:
                t0 = time.time()
                exec(p, d)
                t1 = time.time() guess = d['return_val'] fitness += len(p) v = abs(m - guess)
                if v <= 10**6:
                    fitness += v
                else:
                    fitness = self.default_fitness
                    break if t1 - t0 < 10:
                    fitness = self.default_fitness
                    break
                else:
                    fitness += (t1 - t0) * 1000 *except*:fitness = self.default_fitness
                break return fitness *def* generate_list():
    return [random.randint(0, round(random.random() * 90 + 10, 0)) for i in range(9)]
```

让我们一行一行地来。

第 1–3 行:

*   进口。`base-ff`是我们将要继承的类，random 用于生成随机列表，time 用于跟踪执行时间

第 5 行:

*   定义类，`max_in_list`，继承自`base_ff`。这需要与您正在处理的文件同名(在本例中是`max_in_list.py`)。

第 6–9 行:

*   该类的实例初始化信息。

第 10 行:

*   创建带有三个参数的`evaluate`函数，self、ind 和 kwargs。

*到目前为止，这是每个健身功能的标准配置。下一步是独立于每一个正在进化的算法。*

第 11–13 行:

*   从进化中返回当前算法作为`p`。我们可以将它打印到命令行(如我们在第 13 行中所做的那样)，并查看它。

第 15 行:

*   将适应性初始化为`0`

第 17 行:

*   将 for 循环设置为运行 50 次。如果我们不这样做，每个算法将运行在同一个“随机”列表上，并可能演化出一行，如随后返回的`m=49`。`49`可能恰好在那个列表里，而且是最大值，所以计算机认为找到了完美的算法。短、快、准！但是对于这个例子来说。在任何其他列表中，如果`49`不在其中(或者不是最大值)，那么算法就是错误的。因此，我们给出了适应度函数的 50 个列表，每个列表都有不同的值(实际上是最大可能值)，以避免过度适应。

第 18 行:

*   从函数`generate_list()`创建随机列表`self.test_list`
*   跳到最后几行，这个函数在`0`之间生成 10 个随机整数，以及 10 到 100 之间的某个数字。这是避免过度拟合的最好方法。

第 19 行:

*   找出当前使用列表的最大值。重要的是在这里完成，而不是在算法执行之后，因为在执行过程中列表可能会改变(如果语法中已经包含列表操作)，所以可能不会返回正确的结果。
*   此时你可能(正确地)会问，如果我们已经有了一个函数来寻找列表的最大值，那么做这些有什么意义呢？这是一个很好的问题，通用电气的重点是找到一种潜在的更有效的方法来做到这一点。对于简单的函数来说，这并不值得，但却是一个很好的学习练习。

第 21 行:

*   创建一个字典`d`，其中有一个条目`test_list`，用于保存当前列表。这在我们写语法的时候会更有意义。

第 23/45–47 行:

*   Try/Except 语句。一般来说，拥有一个开放式 Except 语句不是一个好主意，因为你永远不会捕捉到错误，但在这种情况下，所有错误都可能发生在进化的算法中(因为它只是半随机地将单词放在一起，所以它们不可能都是完美的代码)，所以该语句是合理的。
*   如果返回一个错误，该算法的适合度被设置为默认值(NA ),循环被中断，下一个算法被测试。

第 24 行:

*   获取开始时间。

第 25 行:

*   执行算法`p`并在`d`内传递参数，以便可以访问它们。这是实际评估算法的地方。返回的值作为`return_val`写入字典`d`(我们在语法中定义了这一点)。

第 26 行:

*   获取结束时间。

第 28 行:

*   从当前算法中检索最大值猜测。

第 30 行:

*   将当前适应度分数增加算法的长度。这是为了避免臃肿和不必要的 if 语句。进化试图让事情尽可能的短。

第 32 行:

*   求列表的实际最大值和猜测值之差。最好的情况是这是`0`，但如果不是，这是一个算法如何接近得到正确答案的代理。

第 33–37 行:

*   有一些算法可能会产生完全超大的猜测，这将破坏进化，所以最好保留一个 if 语句来检查值是否高于某个永远不可行的大(但不太大)数。
*   同样，如果该检查失败，则将适应度设置为 NA，并继续下一个算法。否则，将猜测值和正确值之间的差加到当前的适应性分数上。

第 39–43 行:

*   一些算法(具有多层 for 循环，或`for i in range(1000)`语句)需要很长时间来评估。除非这是预期的，否则这表示有错误，因此建议使用 if 语句来捕获那些花费了更多时间(在本例中为 10 秒)的错误。
*   如果算法花费的时间少于此，则可以将该时间添加到适应度分数中，这样，工作更快的算法将获得较低的适应度。由于时间尺度很小，建议将这部分分数放大 100 或 1000 倍。

第 49 行:

*   还健身，就完事了！

有很多东西需要理解，有一些可能没有意义，但我们会继续写语法，希望有了完整的描述，会更清晰一些。

# 语法

这是困难的部分，因为你必须对你写的东西非常精确和深思熟虑。我们将逐步介绍发展 max 函数所需的基本语法，但是包括附加逻辑、列表函数和字典函数的语法扩展可在[https://github.com/Padam-0/NC-GA](https://github.com/Padam-0/NC-GA)获得。

同样，PonyGE2 在 PonyGE2/grammars 目录中提供了语法示例。在那里创建你的(它可以被称为任何东西，但是给它扩展名`.pybnf`)。

第一行包含程序的起点:

```
<fc> ::= <deff>{::}<callf>
```

用英语来说，这表示:

*   `<fc>`是起始符号，包含一个选项:`<deff>`后面跟一个换行符(`{::}`代表换行符，`{:`是缩进(tab 或 4 个空格)`:}`关闭缩进)，后面跟`<callf>`。

下一行，我们定义`<deff>`:

```
<deff> ::= def fun(li):{:m = 0{::}<code>{::}return m:}
```

这看起来有点像 Python。我们可以看到我们有一个名为`fun()`的函数的函数定义，有一个参数`li`。

接下来我们打开一个缩进(像 Python 要求的那样)，初始化我们的变量`m=0`，开始一个新行，写一些`<code>`，开始一个新行，返回`m`，然后关闭缩进。

还是那句话，`<deff>`只有一个选项，所以这个肯定会写。接下来，`<callf>`:

```
<callf> ::= return_val = fun(test_list)
```

同样，这看起来更像 Python。而且只有一个选项，所以不管染色体如何，我们的算法看起来总是这样:

```
def fun(li):
    m = 0
    <code>
    return m
return_val = fun(test_list)
```

`<code>`部分是进化完成的地方，但是在大多数情况下，我们现在将有一个工作函数。酷嘿！天气变凉了。

还记得在我们的健身函数中，我们给了字典`d`一个名为`test_list`的键吗？嗯，因为我们调用了`exec(p, d)`，所以程序可以看到那个字典`d`的内容，所以当它在算法中看到`test_list`的时候，就用字典`d`中`test_list`对应的值来替换它，或者在我们的例子中，就是我们想要找到的最大值的随机列表！很酷吧，现在我们有办法将数据从我们的适应函数传递到我们的进化函数中。

同样，在我们的适应度函数中，我们设置`guess = d['return_val']`？事实证明，我们不仅可以从`d`读取，还可以向它写入，从`fun(test_list)`返回的值作为`return_val`传递给`d`，这样我们就可以在适应度函数中访问进化算法的返回值，这样我们就可以访问它的适应度了！

因此，我们现在可以双向发送数据，我建议重新阅读适应度函数部分，看看这是否更有意义。对我来说绝对是。

至于我们剩下的语法:

```
<code> ::= <stmt> | <stmt>{::}<code>
```

代码可以是一条语句，也可以是一条语句后在新的一行上跟随更多的代码。这样我们就可以给自己多线功能了！这种语法的递归性质是非常有用的，将会出现很多，使我们能够增加进化的复杂性。

```
<stmt> ::= <var> = <expr> | <for> | <if>
```

然后，语句要么将表达式赋给变量，要么赋给 for 循环，要么赋给 if 语句。让我们以相反的顺序来看这些:

```
<if> ::= if <cond>:<if-opt>
<if-opt> ::= {:<code>:} | {:<code>:}else:{:<code>:} | {:<code>:}elif <cond>:{:<if-opt>:}<cond> ::= <expr> <c-op> <expr>
<c-op> ::= ">=" | "<=" | ">" | "<"
```

所以 if 语句接受一个条件，然后是一个选项。条件采用表达式、运算符和表达式的形式。

为了使这一点更清楚，现在有必要讨论一下`<expr>`标签:

```
<expr> ::= <number> | <var> | <expr> <op> <expr>
```

所以一个表达式要么是一个数字，要么是一个变量，要么是一个操作(后面会详细介绍)。

回到我们的 if 语句，我们的条件采用形式`if <cond>:`,它扩展为:

```
if <expr> <c-op> <expr>:
```

然后可以扩展为:

```
if <var> >= <number>:
```

我们有一个我们认可的 if 语句。`<if-opt>`稍微复杂一点，因为它们必须包括`elif`和`else`功能，但是它们都归结为一个 if 语句、一个条件，然后一些`<code>`被写入其中。

接下来，对于循环:

```
<for> ::= for i in <list-var>:{:<fl-code>:}
<fl-stmt> ::= <var> = <expr> | <fl-if>
<fl-code> ::= <fl-stmt> | <fl-stmt>{::}<fl-code>
```

因此，for 循环采用形式`for i in list:`,然后为某个语句创建一个缩进(在新的一行上)。语句本身可能只是我们上面的`<stmt>`，但是这将允许嵌套 for 循环，这会成倍地增加计算时间。除非您认为嵌套的 for 循环是绝对必要的，否则请避免使用它们(一般来说，这是一个非常好的编程规则)。

所以我们的`<fl-stmt>`只包括变量赋值，和一个特殊的 if 语句，`<fl-if>`:

```
<fl-if> ::= if <cond>:<fl-if-opt>
<fl-if-opt> ::= {:<fl-code>:} | {:<fl-code>:}else:{:<fl-code>:} | {:<fl-code>:}elif <cond>:{:<fl-if-opt>:}
```

这实际上与上面的 if 语句语法相同，但是它不调用`<code>`，而是调用`<fl-code>`，基本上是为了避免 for 循环内部的 if 语句内部出现 for 循环。有点麻烦，但比允许嵌套 for 循环要好！

最后，变量赋值。我们已经看过`<expr>`，所以让我们看看组成它的零件:

```
<var> ::= m | i
<list-var> ::= li<number> ::= <num><num><num> | <num><num> | <num>
<num> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9<op> ::= + | - | * | / | // | %
```

这应该很简单。我们的变量是开始时初始化的`m`和运行 for 循环时初始化的`i`。数字可以从 0 到 999，我们有所有的 python 运算符(除了指数运算符，它会导致整数溢出和一大堆执行非常慢的算法。像嵌套的 for 循环一样，只在需要时才包含它)。

信不信由你，这就是我们的语法！让我们看看如何从一个`<code>`标签到我们的最终函数。像这样的染色体:

```
[0, 1, 0, 1, 0, 1, 1, 2, 1, 0, 0, 0, 0, 1, 1]
```

绘制出来后，我们可以得到:

```
def fun(li):
    for i in li:
        if i > m:
            m = i
return_val = fun(test_list)
```

太棒了。现在我们有了适应度函数和语法，我们如何用 PonyGE2 运行它呢？

好吧，如果 fitness 函数在 PonyGE2/src/fitness 中(并且与它保存的类具有相同的文件名，在本例中是 max_in_list)，并且语法在 PonyGE2/grammars 中，我们可以从命令行运行:

```
python ponyge.py --fitness_function max_in_list --grammar_file max_in_list.pybnf
```

这将运行您的语法和健身功能的演变，与其他选项的默认参数。有很多，值得一读参考文献，但两个真正重要的是人口规模和世代数。

群体大小是在开始时产生的染色体的数量，并且在每一代进化。这个数字越大，搜索范围越广，但进化时间越慢。

代数是染色体进化的次数。同样，它扩大了搜索范围，但以进化速度为代价。

您可以通过以下方式设置这些参数:

```
python ponyge.py --fitness_function max_in_list --grammar_file MIL_e2.pybnf --population_size 500 --generations 100
```

现在，对于简单的语法，这些参数的值在 100-500 的范围内就足够了，但是随着语法变得更加复杂，它们需要更多的群体和世代来确保进化出足够的算法。一个好的测试是给你的语法增加复杂性，用和上面一样的适应度函数来运行它。如果你得到一个在列表中找到最大值的函数，你可以确信你的参数是合适的，然后把它转换到你要解决的问题的另一个适应度函数上。

不幸的是，运行时间变得很快。对我来说，2000 代和 750 代的人口需要大约 6 个半小时，这不足以用上面的语法进化出一个合适的算法(但也包括列表和字典操作)。

这就是通用电气的问题所在。承诺是，如果你能写一个适应度函数，和一个包含大量 Python 操作的健壮语法，那么 ge 将能进化出一种更有效的做事方式。不幸的是，目前这种处理能力和时间在公共机器上是不可行的。

不管怎样，这是一个值得关注的领域，就像我们要教机器编码一样，很有可能语法进化与此有关。

# 其他示例

[UCD 自然计算研究和应用集团](http://ncra.ucd.ie/index.shtml)的团队是这项研究的前沿，他们发表了许多展示通用电气力量的伟大论文(尽管是在超级计算机上)。其中包括:

*   [寻找正则表达式的改进性能](https://arxiv.org/abs/1704.04119)；
*   [用语法进化优化复杂的桥塔结构](http://www.sciencedirect.com/science/article/pii/S0020025514002904)；和
*   [结合结构分析和多目标标准的进化建筑设计](https://link.springer.com/chapter/10.1007%2F978-3-642-20520-0_21?LI=true)。

如果你喜欢这篇文章，请点击❤按钮让你的追随者知道，或者让我知道你的想法。

![](img/852d66557edc7439da173eedcc04738f.png)