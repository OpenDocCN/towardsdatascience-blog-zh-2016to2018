<html>
<head>
<title>Tidying Up Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">收拾熊猫</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tidying-up-pandas-4572bfa38776?source=collection_archive---------4-----------------------#2018-12-20">https://towardsdatascience.com/tidying-up-pandas-4572bfa38776?source=collection_archive---------4-----------------------#2018-12-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7147dce00168c834f89a42998a65dd71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*806xuq2CMjrFzG39TLFc-g.png"/></div></div></figure><p id="8625" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于那些使用熊猫模块的人来说，你会很快意识到的第一件事是，做任何事情都有不止一种方法。</p><p id="c327" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文的目的是展示我们如何通过从 R 的<code class="fe kw kx ky kz b">dplyr</code>和<code class="fe kw kx ky kz b">tidyverse</code>库汲取灵感来限制这种情况。</p><p id="dc37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于来自学术界，R 通常是我周围人的通用语言(计算生物学/生物信息学或统计学)。和他们一样，我迷上了著名的<code class="fe kw kx ky kz b">tidyverse</code>元包，它包括<code class="fe kw kx ky kz b">dplyr</code>(之前的<code class="fe kw kx ky kz b">plyr</code>、ply(e)r)、<code class="fe kw kx ky kz b">lubridate</code>(时间序列)和<code class="fe kw kx ky kz b">tidyr</code>。</p><blockquote class="lb lc ld"><p id="cafd" class="jy jz la ka b kb kc kd ke kf kg kh ki le kk kl km lf ko kp kq lg ks kt ku kv ij bi translated"><em class="iq"> PS。在我写这篇文章的时候，我意识到这不仅仅是</em> <code class="fe kw kx ky kz b"><em class="iq">tidyverse</em></code> <em class="iq">，而是整个 R 生态系统，我已经开始喜欢上它了，同时也喜欢上了宏基因组学和计算生物学。</em></p></blockquote><p id="cca9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了方便从 R 起步的人，<code class="fe kw kx ky kz b">pandas</code>是 python 的 dataframe 模块。像 H2Oai 的<a class="ae lh" href="https://datatable.readthedocs.io/en/latest/using-datatable.html" rel="noopener ugc nofollow" target="_blank">数据表</a>这样的其他包是存在的，它在很大程度上受到 R 自己的<a class="ae lh" href="https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html" rel="noopener ugc nofollow" target="_blank">数据表</a>库的启发。</p><p id="5375" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在他的演讲中，<a class="ae lh" href="https://youtu.be/dWjSYqI7Vog?t=2m7s" rel="noopener ugc nofollow" target="_blank">Hadley Wickham</a>(dplyr 包的创建者)他提到我们真正需要的表格操作只是一些函数:</p><ul class=""><li id="e01a" class="li lj iq ka b kb kc kf kg kj lk kn ll kr lm kv ln lo lp lq bi translated">过滤器</li><li id="1517" class="li lj iq ka b kb lr kf ls kj lt kn lu kr lv kv ln lo lp lq bi translated">挑选</li><li id="d1b3" class="li lj iq ka b kb lr kf ls kj lt kn lu kr lv kv ln lo lp lq bi translated">安排</li><li id="ffaf" class="li lj iq ka b kb lr kf ls kj lt kn lu kr lv kv ln lo lp lq bi translated">使突变</li><li id="0a73" class="li lj iq ka b kb lr kf ls kj lt kn lu kr lv kv ln lo lp lq bi translated">group_by</li><li id="37f4" class="li lj iq ka b kb lr kf ls kj lt kn lu kr lv kv ln lo lp lq bi translated">概括</li><li id="15c4" class="li lj iq ka b kb lr kf ls kj lt kn lu kr lv kv ln lo lp lq bi translated">合并</li></ul><p id="c06e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，我认为你需要比以上更多的东西。</p><p id="4ce5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">比如知道 R 的<code class="fe kw kx ky kz b">apply</code>函数族，会有很大帮助。或者像<code class="fe kw kx ky kz b">summary</code>或<code class="fe kw kx ky kz b">str</code>这样的汇总统计函数，尽管现在我大多使用<code class="fe kw kx ky kz b">skimr::skim</code>进行汇总。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="3a1a" class="me mf iq kz b gy mg mh l mi mj">skim(iris) <br/>## Skim summary statistics <br/>## n obs: 150  <br/>## n variables: 5  <br/>##  <br/>## ── Variable type:factor ────────────────────────────────────────────────────────────────────────────────────────────────── <br/>## variable missing complete n n_unique top_counts ordered <br/>## Species 0 150 150 3 set: 50, ver: 50, vir: 50, NA: 0 FALSE <br/>##  <br/><em class="la">## ── Variable type:numeric ─────────────────────────────────────────────────────────────────────────────────────────────────</em><br/><em class="la">##      variable missing complete   n mean   sd  p0 p25  p50 p75 p100     hist</em><br/><em class="la">##  Petal.Length       0      150 150 3.76 1.77 1   1.6 4.35 5.1  6.9 ▇▁▁▂▅▅▃▁</em><br/><em class="la">##   Petal.Width       0      150 150 1.2  0.76 0.1 0.3 1.3  1.8  2.5 ▇▁▁▅▃▃▂▂</em><br/><em class="la">##  Sepal.Length       0      150 150 5.84 0.83 4.3 5.1 5.8  6.4  7.9 ▂▇▅▇▆▅▂▂</em><br/><em class="la">##   Sepal.Width       0      150 150 3.06 0.44 2   2.8 3    3.3  4.4 ▁▂▅▇▃▂▁▁</em></span></pre><p id="d7bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，skimr 的输出看起来真的很像 Google 的 Facets。正如您所看到的，打印基本的分布统计和直方图。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/47d422933ea3f6960e45ca4570a731db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tVOZtKRuf1vSLD7x.png"/></div></div></figure><p id="8075" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在这篇文章中，我将尽力演示<code class="fe kw kx ky kz b">tidyverse</code>词汇表与<code class="fe kw kx ky kz b">pandas</code> DataFrame 方法的一对一映射。</p><p id="8a11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了演示，我们将使用著名的<a class="ae lh" href="https://en.wikipedia.org/wiki/Iris_flower_data_set" rel="noopener ugc nofollow" target="_blank">鸢尾花数据集</a>。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="b58e" class="me mf iq kz b gy mg mh l mi mj"># python <br/>import seaborn as sns <br/>iris = sns.load_data("iris")</span></pre><p id="8438" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我选择使用 seaborn 导入 iris 数据集，而不是使用 sklearn 的<code class="fe kw kx ky kz b">datasets.load_iris</code>，这是因为后者将数据集导入为 numpy 数组，而不是 pandas DataFrames。</p><p id="d683" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在导入一个表之后，我做的第一件事就是在 data.frame 上运行<code class="fe kw kx ky kz b">str</code>函数(不完全等同于<code class="fe kw kx ky kz b">pd.DataFrame.info()</code>方法)并检查是否有 NAs。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="c3e5" class="me mf iq kz b gy mg mh l mi mj"># R<br/>str(iris)<br/>&gt; <!-- -->'data.frame':   150 obs. of  5 variables:<br/> $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...<br/> $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...<br/> $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...<br/> $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...<br/> $ Species     : Factor w/ 3 levels "setosa","versicolor",..: 1 1 1 1 1 1 1 1 1 1 ...</span><span id="dbbb" class="me mf iq kz b gy ml mh l mi mj"># python <br/>iris.info(null_counts=True)<br/>&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 150 entries, 0 to 149<br/>Data columns (total 5 columns):<br/>sepal_length    150 non-null float64<br/>sepal_width     150 non-null float64<br/>petal_length    150 non-null float64<br/>petal_width     150 non-null float64<br/>species         150 non-null object<br/>dtypes: float64(4), object(1)<br/>memory usage: 5.9+ KB</span></pre><h1 id="ae1a" class="mm mf iq bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">过滤器</h1><p id="557f" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">现在，进入下一个功能。与 R 的<code class="fe kw kx ky kz b">filter</code>最接近的方法是<code class="fe kw kx ky kz b">pd.query</code>方法。在下面的例子中，截止值已经被定义为一个变量。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="28d4" class="me mf iq kz b gy mg mh l mi mj"># R<br/>iris %&gt;% filter(sepal.width &gt; cutoff)</span><span id="5bf8" class="me mf iq kz b gy ml mh l mi mj"># python<br/>## Method 1: <br/>iris[iris.sepal_width &gt; cutoff]</span><span id="ba3f" class="me mf iq kz b gy ml mh l mi mj">## Method 2:<br/>iris.query("sepal_width &gt; @cutoff”)</span></pre><p id="3e44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在 python 中有两种方法可以做到这一点。</p><p id="f896" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">方法 1 可能是你会发现大多数 python 爱好者使用的方法。</p><p id="2dd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不过在我看来，<code class="fe kw kx ky kz b">pd.DataFrame.query()</code>和<code class="fe kw kx ky kz b">dplyr::filter()</code>的映射更为紧密。</p><blockquote class="lb lc ld"><p id="9100" class="jy jz la ka b kb kc kd ke kf kg kh ki le kk kl km lf ko kp kq lg ks kt ku kv ij bi translated"><em class="iq">使用 query 的一个缺点是…遵循</em> <code class="fe kw kx ky kz b"><em class="iq">pep8</em></code> <em class="iq">约定的 linters，比如</em> <code class="fe kw kx ky kz b"><em class="iq">flake8</em></code> <em class="iq">，会抱怨</em> <code class="fe kw kx ky kz b"><em class="iq">cutoff</em></code> <em class="iq">变量没有被使用，尽管它已经被声明:</em> <code class="fe kw kx ky kz b"><em class="iq">sepal_width &gt; @cutoff</em></code> <em class="iq">。这是因为 linter 无法识别在查询的引用参数中使用的</em> <code class="fe kw kx ky kz b"><em class="iq">cutoff</em></code> <em class="iq">变量。</em></p></blockquote><p id="5f37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">&gt;注意:令人惊讶的是，filter 在 pySpark 中有所回报。:)</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="e4e1" class="me mf iq kz b gy mg mh l mi mj"># python (pyspark)</span><span id="ef55" class="me mf iq kz b gy ml mh l mi mj">type(flights) <br/>pyspark.sql.dataframe.DataFrame</span><span id="d0db" class="me mf iq kz b gy ml mh l mi mj"># filters flights which are &gt; 1000 miles long flights.filter('distance &gt; 1000')</span></pre><h1 id="84cb" class="mm mf iq bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">挑选</h1><p id="6d3e" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">这让人想起 SQL 的<code class="fe kw kx ky kz b">select</code>关键字，它允许您选择列。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="c14c" class="me mf iq kz b gy mg mh l mi mj"># R <br/>iris %&gt;% select(sepal.width, sepal.length)</span><span id="bdba" class="me mf iq kz b gy ml mh l mi mj"># Python <br/>iris.loc[:, [["sepal_width", "sepal_length"]]]</span></pre><p id="8e6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最初，我认为下面的<code class="fe kw kx ky kz b">df[[’col1’, 'col2’]]</code>模式会是一个很好的地图。但是我很快意识到我不能做类似于<code class="fe kw kx ky kz b">select</code>的柱状切片。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="7e87" class="me mf iq kz b gy mg mh l mi mj"># R <br/>iris %&gt;% select(Sepal.Length:Petal.Width)</span><span id="4dab" class="me mf iq kz b gy ml mh l mi mj"># Python  <br/>iris.loc[:, "sepal_length":"petal_width"]</span></pre><p id="012f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于<code class="fe kw kx ky kz b">loc</code>方法需要注意的一点是，当选择只有一行时，它可能返回一个序列而不是一个数据帧。因此，您必须对感兴趣的行进行切片，以便输出返回一个数据帧。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="708a" class="me mf iq kz b gy mg mh l mi mj"># Python</span><span id="a6b2" class="me mf iq kz b gy ml mh l mi mj">iris.loc[1, :]  # returns a Series <br/>iris.loc[[1],:] # slicing returns a dataframe</span></pre><p id="f6c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是<code class="fe kw kx ky kz b">select</code>真正令人惊叹的是，它能够让<em class="la">取消选择</em>列，这是<code class="fe kw kx ky kz b">loc</code>方法中所没有的。</p><p id="1d89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你必须使用<code class="fe kw kx ky kz b">.drop()</code>方法。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="4d85" class="me mf iq kz b gy mg mh l mi mj"># R<br/>df %&gt;&gt;% select(-col1)</span><span id="18e9" class="me mf iq kz b gy ml mh l mi mj"><br/># Python<br/>df.drop(columns=["col1"])</span></pre><blockquote class="lb lc ld"><p id="41b8" class="jy jz la ka b kb kc kd ke kf kg kh ki le kk kl km lf ko kp kq lg ks kt ku kv ij bi translated"><em class="iq">注意我必须添加参数</em> <code class="fe kw kx ky kz b"><em class="iq">columns</em></code> <em class="iq">，因为 drop 不仅可以用于删除列，该方法还可以基于它们的索引删除行。</em></p></blockquote><p id="ca83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和<code class="fe kw kx ky kz b">filter</code>一样，<code class="fe kw kx ky kz b">select</code>也用在 pySpark 上！</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="a62f" class="me mf iq kz b gy mg mh l mi mj"># python (pySpark)</span><span id="bd9c" class="me mf iq kz b gy ml mh l mi mj"># shows the column xyz of the spark dataframe.<br/>df.select("xyz").show()</span><span id="8890" class="me mf iq kz b gy ml mh l mi mj"># alternative  <br/>df.select(df.xyz)</span></pre><h1 id="26c2" class="mm mf iq bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">安排</h1><p id="0b89" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">通过 arrange 函数，可以按照特定的列对表格进行排序。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="0bbe" class="me mf iq kz b gy mg mh l mi mj"># R <br/>df %&gt;% arrange(desc(col1))</span><span id="2b56" class="me mf iq kz b gy ml mh l mi mj"># Python<!-- --> <br/>df.sort_values(by="col1", ascending=False) <br/># everything is reversed in python fml.</span></pre><h1 id="fed8" class="mm mf iq bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">使突变</h1><p id="338b" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated"><code class="fe kw kx ky kz b">dplyr</code>的<code class="fe kw kx ky kz b">mutate</code>实际上是 R 的<code class="fe kw kx ky kz b">apply</code>的升级版。</p><blockquote class="lb lc ld"><p id="ca9b" class="jy jz la ka b kb kc kd ke kf kg kh ki le kk kl km lf ko kp kq lg ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">注意</em> </strong> <em class="iq"> : R 的许多其他应用如</em> <code class="fe kw kx ky kz b"><em class="iq">mapply</em></code> <em class="iq">和</em> <code class="fe kw kx ky kz b"><em class="iq">lapply</em></code> <em class="iq">但是可以在很大程度上被 purrr 库中的新函数所取代。</em></p></blockquote><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="56df" class="me mf iq kz b gy mg mh l mi mj"># R <br/>df %&gt;% mutate(new = something / col2, newcol = col+1 )</span><span id="d74b" class="me mf iq kz b gy ml mh l mi mj"># Python <br/>iris.assign(new = iris.sepal_width / iris.sepal, <br/>newcol = lambda x: x["col"] + 1 )</span></pre><p id="66bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认情况下，<code class="fe kw kx ky kz b">tidyverse</code>的<code class="fe kw kx ky kz b">mutate</code>函数获取整列并对其进行矢量化操作。如果你想逐行应用这个函数，你必须将<code class="fe kw kx ky kz b">rowwise</code>和<code class="fe kw kx ky kz b">mutate</code>连接起来。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="8896" class="me mf iq kz b gy mg mh l mi mj"># R<br/># my_function() does not take vectorised input of the entire column <br/># this will fail</span><span id="4025" class="me mf iq kz b gy ml mh l mi mj">iris %&gt;% <br/>    rowwise %&gt;% <br/>    mutate(new_column = my_function(sepal.width, sepal.length))</span></pre><p id="be6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使用<code class="fe kw kx ky kz b">.assign</code>方法达到同样的效果，您应该在函数中嵌套一个<code class="fe kw kx ky kz b">apply</code>。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="09ad" class="me mf iq kz b gy mg mh l mi mj"># Python</span><span id="4275" class="me mf iq kz b gy ml mh l mi mj">def do_something(col): <br/>    #set_trace() <br/>    if re.search(r".*(osa)$", col): <br/>        value = "is_setosa" <br/>    else: value = "not_setosa" <br/>        return value </span><span id="56d0" class="me mf iq kz b gy ml mh l mi mj">iris = iris.assign( <br/>    transformed_species = lambda df: df.species.apply(do_something) <br/>)</span></pre><p id="d2f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你很懒，你可以把两个匿名函数链接在一起。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="1909" class="me mf iq kz b gy mg mh l mi mj"># Python</span><span id="313e" class="me mf iq kz b gy ml mh l mi mj">iris = iris.assign( transformed_species = lambda df: df.species.apply(do_something_string))</span></pre><h1 id="533a" class="mm mf iq bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">绕道:申请</h1><p id="3798" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">来自 R 的<code class="fe kw kx ky kz b">apply</code>帮助文档:</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="87b6" class="me mf iq kz b gy mg mh l mi mj">apply(X, MARGIN, FUN, ...)</span></pre><p id="6ad8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中<code class="fe kw kx ky kz b">MARGIN</code>的值对于(行、列)取<code class="fe kw kx ky kz b">1</code>或<code class="fe kw kx ky kz b">2</code>，即。如果您想应用于每一行，您可以将轴设置为<code class="fe kw kx ky kz b">0</code>。</p><p id="cc7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，在 pandas axis 中，什么值(索引 I 或列 j)将用于应用函数输入参数的索引。</p><p id="7108" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">be 使用的<code class="fe kw kx ky kz b">0</code>是指数据帧的索引，轴<code class="fe kw kx ky kz b">1</code>是指列。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/2a9d450c10186ec3604a6509d9957b72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QNxXdjiKmvFVL-Nh.png"/></div></div></figure><p id="0660" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，如果你想进行行操作，你可以设置轴为 0。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="1625" class="me mf iq kz b gy mg mh l mi mj"># R</span><span id="c989" class="me mf iq kz b gy ml mh l mi mj">df %&gt;% apply(0, function(row){ ... do some compute ... })</span></pre><blockquote class="lb lc ld"><p id="1aa9" class="jy jz la ka b kb kc kd ke kf kg kh ki le kk kl km lf ko kp kq lg ks kt ku kv ij bi translated"><em class="iq">自从</em> <code class="fe kw kx ky kz b"><em class="iq">plyr</em></code> <em class="iq">和后来的</em> <code class="fe kw kx ky kz b"><em class="iq">dplyr.</em></code>之后就很少这样做了</p></blockquote><p id="1dc3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而在熊猫身上没有<code class="fe kw kx ky kz b">plyr</code>。因此，如果您想要进行逐行操作，我们必须返回使用 apply，但是，轴现在是 1 而不是 0。我最初发现这非常令人困惑。原因是因为<code class="fe kw kx ky kz b">row</code>实际上只是一个<code class="fe kw kx ky kz b">pandas.Series</code>，它的索引是父 p 和 as。DataFame 的列。因此，在本例中，轴指的是将哪个轴设置为索引。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="3835" class="me mf iq kz b gy mg mh l mi mj"># python</span><span id="df2b" class="me mf iq kz b gy ml mh l mi mj">iris.apply(lambda row: do_something(row), axis=1)</span></pre><p id="7878" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有趣的是，我在 R 中没有使用的模式是在列上使用 apply，在这个例子中是<code class="fe kw kx ky kz b">pandas.Series</code>对象。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="230e" class="me mf iq kz b gy mg mh l mi mj"># python</span><span id="ecc4" class="me mf iq kz b gy ml mh l mi mj">iris.sepal_width.apply(lambda x: x**2) # if you want a fancy progress bar, you could use the tqdm function</span><span id="d03d" class="me mf iq kz b gy ml mh l mi mj">iris.sepal_width.apply_progress(lambda x: x**2) # If u need parallel apply # this works with dask underneath  import swifter</span><span id="155d" class="me mf iq kz b gy ml mh l mi mj">iris.sepal_width.swifter.apply(lambda x : x**2)</span></pre><p id="2b91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在 R 中，有一个常见的习惯用法，我经常在<code class="fe kw kx ky kz b">groupby</code>的平行版本中使用，如下所示:</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="3eb0" class="me mf iq kz b gy mg mh l mi mj"># R</span><span id="3bbe" class="me mf iq kz b gy ml mh l mi mj">unique_list %&gt;% <br/>lapply(function(x){ <br/>    ... <br/>    df %&gt;% filter(col == x) %&gt;% do_something() # do something to the subset <br/>    ... <br/>}) %&gt;% do.call(rbind,.)</span></pre><p id="297d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想要一个平行版本，你只需要把<code class="fe kw kx ky kz b">lapply</code>改成<code class="fe kw kx ky kz b">mclapply</code>。</p><p id="d00e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，还有来自 r 的<code class="fe kw kx ky kz b">parallel</code> / <code class="fe kw kx ky kz b">snow</code>图书馆的<code class="fe kw kx ky kz b">mclapply</code></p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="531b" class="me mf iq kz b gy mg mh l mi mj"># R</span><span id="7148" class="me mf iq kz b gy ml mh l mi mj">ncores = 10 # the number of cores <br/>unique_list %&gt;% <br/>    mclapply(function(x){ <br/>    ... <br/>    df %&gt;% filter(col == x) %&gt;% do_something() # do something to the subset <br/>    ... <br/>}, mc.cores=ncores) %&gt;% <br/>do.call(rbind,.)</span></pre><p id="9a30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另外，在 PySpark 中，您可以将整个表分成几个分区，并行地进行操作。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="5227" class="me mf iq kz b gy mg mh l mi mj"># Python (pySpark)</span><span id="dd34" class="me mf iq kz b gy ml mh l mi mj">(<br/>    dd.from_pandas(my_df,npartitions=nCores)<br/>        .map_partitions(lambda df : df.apply( lambda x : nearest_street(x.lat,x.lon),axis=1))<br/>        .compute(get=get) # imports at the end</span><span id="5706" class="me mf iq kz b gy ml mh l mi mj">)</span></pre><p id="2949" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了达到同样的目的，我们可以使用<code class="fe kw kx ky kz b">dask</code>，或者使用<code class="fe kw kx ky kz b">swiftapply</code>模块的更高级别的包装器。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="d053" class="me mf iq kz b gy mg mh l mi mj"># Python</span><span id="7371" class="me mf iq kz b gy ml mh l mi mj"># you can easily vectorise the example using by adding the `swift` method before `.apply` <br/>series.swift.apply()</span></pre><h1 id="b5fb" class="mm mf iq bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">分组依据</h1><p id="95d8" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">pandas 中的<code class="fe kw kx ky kz b">.groupby</code>方法相当于 R 函数<code class="fe kw kx ky kz b">dplyr::group_by</code>返回一个<code class="fe kw kx ky kz b">DataFrameGroupBy</code>对象。</p><blockquote class="lb lc ld"><p id="44ef" class="jy jz la ka b kb kc kd ke kf kg kh ki le kk kl km lf ko kp kq lg ks kt ku kv ij bi translated"><em class="iq">tidy verse 中有</em> <code class="fe kw kx ky kz b"><em class="iq">ungroup</em></code> <em class="iq">函数对分组后的数据帧进行解组，为了达到同样的效果，不存在一对一的映射函数。</em></p><p id="40d7" class="jy jz la ka b kb kc kd ke kf kg kh ki le kk kl km lf ko kp kq lg ks kt ku kv ij bi translated"><em class="iq">一种方式是完成</em><code class="fe kw kx ky kz b"><em class="iq">groupby</em></code><em class="iq">-&gt;-</em><code class="fe kw kx ky kz b"><em class="iq">apply</em></code><em class="iq">(两步法)和送料应用同一个功能</em> <code class="fe kw kx ky kz b"><em class="iq">apply(lambda x: x)</em></code> <em class="iq">。这是一个身份函数。</em></p></blockquote><h1 id="75b6" class="mm mf iq bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">概括</h1><p id="4399" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">在熊猫中，<code class="fe kw kx ky kz b">summarise</code>功能的对等物是<code class="fe kw kx ky kz b">aggregate</code>，缩写为<code class="fe kw kx ky kz b">agg</code>功能。你必须把这个和<code class="fe kw kx ky kz b">groupby</code>结合起来，所以这又是一个类似的两步<code class="fe kw kx ky kz b">groupby</code> - &gt; <code class="fe kw kx ky kz b">agg</code>转换。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="ddd6" class="me mf iq kz b gy mg mh l mi mj"># R </span><span id="d70d" class="me mf iq kz b gy ml mh l mi mj">r_mt = mtcars %&gt;% <br/>    mutate(model = rownames(mtcars)) %&gt;% <br/>    select(cyl, model, hp, drat) %&gt;% <br/>    filter(cyl &lt; 8) %&gt;% <br/>    group_by(cyl) %&gt;% <br/>    summarise( <br/>        hp_mean = mean(hp),<br/>        drat_mean = mean(drat), <br/>        drat_std = sd(drat), <br/>        diff = max(drat) - min(drat) <br/>    ) %&gt;% <br/>    arrange(drat_mean) %&gt;% <br/>    as.data.frame</span></pre><p id="1514" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用 Python 编写的相同系列的转换如下:</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="964f" class="me mf iq kz b gy mg mh l mi mj"># Python </span><span id="06e8" class="me mf iq kz b gy ml mh l mi mj">def transform1(x): <br/>    return max(x)-min(x) </span><span id="4ae8" class="me mf iq kz b gy ml mh l mi mj">def transform2(x): <br/>    return max(x)+5 <br/>    py_mt = ( <br/>        mtcars<br/>            .loc[:,["cyl", "model", "hp", "drat"]] #select      <br/>            .query("cyl &lt; 8") #filter <br/>            .groupby("cyl") #group_by <br/>            .agg({ #summarise, agg is an abbreviation of aggregation     <br/>                    'hp':'mean', <br/>                    'drat':[<br/>                        'mean', <br/>                        'std', <br/>                        transform1, <br/>                        transform2] # hmmmmmm<br/>            })<br/>            .sort_values(by=[("drat", "mean")]) <br/># multindex sort (unique to pandas) ) py_mt</span></pre><h1 id="25b1" class="mm mf iq bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">合并</h1><p id="6a7f" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">R 本身支持<code class="fe kw kx ky kz b">merge</code>函数，类似地，熊猫也有<code class="fe kw kx ky kz b">pd.merge</code>函数。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="ab3f" class="me mf iq kz b gy mg mh l mi mj"># R </span><span id="09dc" class="me mf iq kz b gy ml mh l mi mj">df1 %&gt;% merge(df2, by="common_column")</span><span id="d1b2" class="me mf iq kz b gy ml mh l mi mj"># Python</span><span id="337c" class="me mf iq kz b gy ml mh l mi mj">df1.merge(df2, how="inner", on="common_column")</span></pre><p id="3927" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了<code class="fe kw kx ky kz b">merge</code>功能，还有<code class="fe kw kx ky kz b">join</code>功能。dplyr 中还存在其他连接，例如<code class="fe kw kx ky kz b">left_join</code>、<code class="fe kw kx ky kz b">right_join</code>、<code class="fe kw kx ky kz b">inner_join</code>和<code class="fe kw kx ky kz b">anti_join.</code></p><h1 id="b174" class="mm mf iq bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">原地</h1><p id="177b" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">在 R 中有一个复合赋值管道操作符<code class="fe kw kx ky kz b">%&lt;&gt;%</code>，它类似于一些 pandas 函数<em class="la">中的<code class="fe kw kx ky kz b">inplace=True</code>参数，但不是所有的</em>。:(很明显，熊猫将会完全取代……</p><h1 id="76b0" class="mm mf iq bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">排除故障</h1><p id="f984" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">在 R 中，我们有<code class="fe kw kx ky kz b">browser()</code>函数。</p><p id="8223" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，这不适用于 Jupyter 的 IRKernel。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="d9fe" class="me mf iq kz b gy mg mh l mi mj"># R <br/>unique(iris$species) %&gt;% <br/>    lapply(function(s){ <br/>        browser() <br/>        iris %&gt;% filter(species == s) <br/>        ....<br/>     })</span></pre><p id="1cd2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它会让你<em class="la">进入</em>功能，如果你想做一些调试，这是非常有用的。</p><p id="ebbe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在 Python 中，有<code class="fe kw kx ky kz b">set_trace</code>函数。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="cc3c" class="me mf iq kz b gy mg mh l mi mj"># Python</span><span id="36ab" class="me mf iq kz b gy ml mh l mi mj">from IPython.core.debugger import set_trace</span><span id="cde5" class="me mf iq kz b gy ml mh l mi mj">(<br/>    iris<br/>        .groupby("species") <br/>        .apply(lambda groupedDF: set_trace())<br/>) <!-- --> </span></pre><p id="90d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后但同样重要的是，如果你真的需要使用一些 R 函数，你总是可以依赖于<code class="fe kw kx ky kz b">rpy2</code>包。对我来说，我主要用这个来绘图。ggplot2 ftw！抱歉 matplotlib 和 seaborn</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="eb50" class="me mf iq kz b gy mg mh l mi mj">%load_ext rpy2.ipython</span></pre><blockquote class="lb lc ld"><p id="eb14" class="jy jz la ka b kb kc kd ke kf kg kh ki le kk kl km lf ko kp kq lg ks kt ku kv ij bi translated"><em class="iq">有时使用 r 安装 r 包会有问题。你可以运行</em></p></blockquote><p id="b0cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">conda install -r r r-tidyverse r-ggplot</code></p><p id="8a8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此后，您可以在同一个 Jupyter 笔记本中交替使用 R 和 Python。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="eaad" class="me mf iq kz b gy mg mh l mi mj">%%R -i python_df -o transformed_df</span><span id="d987" class="me mf iq kz b gy ml mh l mi mj">transformed_df = python_df %&gt;% <br/>    select(-some_columns) %&gt;% <br/>    mutate(newcol = somecol * 2)</span></pre><blockquote class="lb lc ld"><p id="1139" class="jy jz la ka b kb kc kd ke kf kg kh ki le kk kl km lf ko kp kq lg ks kt ku kv ij bi translated"><em class="iq">注:</em> <code class="fe kw kx ky kz b"><em class="iq">%%R</em></code> <em class="iq">是细胞魔法，</em> <code class="fe kw kx ky kz b"><em class="iq">%R</em></code> <em class="iq">是线条魔法。这意味着如果你有一个多行 r 函数/代码，使用前者。</em></p></blockquote><p id="1dab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你需要输出像一个正常的熊猫数据帧打印，你可以使用百分之一魔术</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="01bb" class="me mf iq kz b gy mg mh l mi mj">%R some_dataFrame %&gt;% skim</span></pre><h1 id="2be4" class="mm mf iq bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">迂回:省略</h1><p id="537c" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">在 R 中，您可以做的一个巧妙的技巧是将参数传递给内部函数，而不必在外部函数的函数签名中定义它们。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="a3a4" class="me mf iq kz b gy mg mh l mi mj"># R <br/>#' Simple function which takes two parameters `one` and `two` and elipisis `...`,</span><span id="c494" class="me mf iq kz b gy ml mh l mi mj">somefunction = function(one, two, ...){ <br/>     three = one + two <br/>     sometwo = function(x, four){ <br/>         x + four <br/>     } <br/>     sometwo(three, ...) # four exists within the elipisis  <br/>} <br/># because of the elipisis, we can pass as many parameters as we we want. the extras will be stored in the elipisis</span><span id="b5be" class="me mf iq kz b gy ml mh l mi mj">somefunction(one=2, two=3, four=5, name="wesley")</span></pre><p id="be0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在 python 中，<code class="fe kw kx ky kz b">**kwargs</code>代替了<code class="fe kw kx ky kz b">...</code>。下面是对其工作原理的解释。</p><h2 id="558a" class="me mf iq bd mn no np dn mr nq nr dp mv kj ns nt mz kn nu nv nd kr nw nx nh ny bi translated">说明</h2><p id="92ae" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">首先，双星号<code class="fe kw kx ky kz b">**</code>被称为<em class="la">解包</em>操作符(它被放在函数签名之前，例如<code class="fe kw kx ky kz b">kwargs</code>，所以合起来看起来像<code class="fe kw kx ky kz b">**kwargs</code>)。</p><blockquote class="lb lc ld"><p id="fc4a" class="jy jz la ka b kb kc kd ke kf kg kh ki le kk kl km lf ko kp kq lg ks kt ku kv ij bi translated"><em class="iq">约定是将该变量命名为</em> <code class="fe kw kx ky kz b"><em class="iq">kwargs</em></code> <em class="iq">(代表</em><strong class="ka ir"><em class="iq">k</em></strong><em class="iq">ey</em><strong class="ka ir"><em class="iq">w</em></strong><em class="iq">orded arguments)但它可以被命名为任何名称。</em></p></blockquote><p id="287e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大多数描述 unpack 操作符的文章都会以<strong class="ka ir">这个</strong>解释开始:字典被用来传递函数的参数。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="8423" class="me mf iq kz b gy mg mh l mi mj"># Python</span><span id="514a" class="me mf iq kz b gy ml mh l mi mj">adictionary = { 'first' : 1, 'second': 2 } <br/>def some_function(first, second): <br/>    return first + second <br/>some_function(**adictionary) # which gives 3</span></pre><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/bc90fc0e4f9b4a9761013dade320fa5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bqlYqN_k2rwLK-wz.jpg"/></div></div></figure><p id="9495" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是你也可以改变这一点，将<code class="fe kw kx ky kz b">**kwargs</code>设置为一个函数签名。这样做可以让您在调用函数时键入任意数量的函数签名。</p><p id="4628" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">签名-值对被包装到一个名为<code class="fe kw kx ky kz b">kwargs</code>的字典中，该字典可以在函数内部访问。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="a657" class="me mf iq kz b gy mg mh l mi mj"># Python <br/># dummy function which prints `kwargs`</span><span id="0a5f" class="me mf iq kz b gy ml mh l mi mj">def some_function (**kwargs): <br/>    print(kwargs) <br/>some_function(first=1, second=2)</span></pre><p id="3604" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前两种情况并不排斥，你实际上可以~<strong class="ka ir"><em class="la"/></strong>~它们混合在一起。即。有署名的还有一个<code class="fe kw kx ky kz b">**kwargs</code>。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="2f86" class="me mf iq kz b gy mg mh l mi mj"># Python <br/>adictionary = { <br/>    'first' : 1,<br/>    'second': 2,<br/>    'useless_value' : "wesley"<br/>} </span><span id="0c66" class="me mf iq kz b gy ml mh l mi mj">def some_function(first, second, **kwargs): <br/>    print(kwargs) return first + second</span><span id="8bca" class="me mf iq kz b gy ml mh l mi mj">some_function(**adictionary)</span></pre><p id="566d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出将是:<code class="fe kw kx ky kz b">{'useless_value': 'wesley'}</code></p><p id="2cd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它允许 python 函数接受您提供的任意多的函数签名。将直接使用在函数声明期间已经定义的那些。没有出现在其中的可以从 kwargs 中访问。</p><p id="d23b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过将<code class="fe kw kx ky kz b">**kwargs</code>作为内部函数中的一个参数，您基本上是将字典展开到函数 params 中。</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="d934" class="me mf iq kz b gy mg mh l mi mj"># Python</span><span id="32f5" class="me mf iq kz b gy ml mh l mi mj">def somefunction(one, two, **kwargs): <br/>    print(f"outer function:\n\t{kwargs}") <br/>    three = one + two <br/>def sometwo(x, four): <br/>    print(f"inner function: \n\t{kwargs}") <br/>    return x + four return</span><span id="312c" class="me mf iq kz b gy ml mh l mi mj">sometwo(three, **kwargs) <br/>somefunction(one=2, two=3, four=5, name=“wesley”)</span></pre><p id="1530" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">外部功能:<code class="fe kw kx ky kz b">{“four":5, “name":"wesley"}</code>。</p><p id="9714" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">里面里面夸尔格斯:<code class="fe kw kx ky kz b">{“name":"jw"}.</code></p><p id="291b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们将它与原始的 R 省略号进行比较:</p><pre class="lw lx ly lz gt ma kz mb mc aw md bi"><span id="4ae0" class="me mf iq kz b gy mg mh l mi mj"># R </span><span id="98f2" class="me mf iq kz b gy ml mh l mi mj">#' Simple function which takes two parameters `one` and `two` and elipisis `...`,</span><span id="fac0" class="me mf iq kz b gy ml mh l mi mj">somefunction = function(one, two, ...){ <br/>    three = one + two <br/>    sometwo = function(x, four){ <br/>        x + four <br/>    } <br/>    sometwo(three, ...) # four exists within the elipisis  <br/>} <br/># because of the elipisis, we can pass as many parameters as we we want. the extras will be stored in the elipisis</span><span id="93ff" class="me mf iq kz b gy ml mh l mi mj">somefunction(one=2, two=3, four=5, name="wesley")</span></pre><h1 id="fee8" class="mm mf iq bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">结论</h1><p id="53a0" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">虽然在熊猫身上做同样的事情有很多方法，比 dplyr (tidyverse)规定的方法更多。我希望内部 R 用户在用 pandas 编码时标准化代码库，提高代码可读性。</p><p id="65e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，来到 Honestbee 后，让我措手不及的是所需的 SQL 数量。</p><p id="0af6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这一点我感觉是来到工业界对学术界最大的偏离。公司中的数据以数据库/数据湖(不太常见)和数据流的形式有序存储。不再有一个大的平面数据文件。</p><p id="8b97" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然有 dbplyr 包，但我强烈建议您花点时间熟悉一下 SQL，尤其是查询 RDS 和 Redshift 的 postgreSQL。</p><h2 id="32a9" class="me mf iq bd mn no np dn mr nq nr dp mv kj ns nt mz kn nu nv nd kr nw nx nh ny bi translated">更新:</h2><blockquote class="lb lc ld"><p id="e91a" class="jy jz la ka b kb kc kd ke kf kg kh ki le kk kl km lf ko kp kq lg ks kt ku kv ij bi translated">Sparklyr 对 rstudio 的人们竖起了大拇指</p></blockquote><p id="8a78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经完成了将<code class="fe kw kx ky kz b">tidyverse</code>动词映射到熊猫的尝试，希望你发现这是有益的！回头见！</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="4d57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="la">原载于 2018 年 12 月 16 日</em><a class="ae lh" href="https://etheleon.github.io/articles/tidying-up-pandas/" rel="noopener ugc nofollow" target="_blank"><em class="la">ethe Leon . github . io</em></a><em class="la">。</em></p></div></div>    
</body>
</html>