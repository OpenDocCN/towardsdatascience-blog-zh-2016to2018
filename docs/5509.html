<html>
<head>
<title>Breaking Down the CDC’s “500 Cities” Health-Metrics Data-Set (Code Included)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分解 CDC 的“500 个城市”健康指标数据集(包括代码)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/breaking-down-the-cdcs-500-cities-health-metrics-data-set-code-included-625ed534088e?source=collection_archive---------21-----------------------#2018-10-22">https://towardsdatascience.com/breaking-down-the-cdcs-500-cities-health-metrics-data-set-code-included-625ed534088e?source=collection_archive---------21-----------------------#2018-10-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6063" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://chronicdata.cdc.gov/500-Cities/500-Cities-Local-Data-for-Better-Health-2017-relea/6vp6-wxuq" rel="noopener ugc nofollow" target="_blank">疾病预防控制中心的“500 个城市”数据集</a>包含了美国 500 个最大城市超过 28，000 个不同人口普查区域的各种健康指标。这是一个令人敬畏的数据集，因为它包含了大量的地点，也因为它包含了每个非常具体的地点的大量详细的结构化数据。在这篇文章中，我会给你一些关于如何重新格式化“500 个城市”的建议，让它更有用。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/911928ada299423cb51f7a688dee4a29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*8Y-81qKmxjYR210AFredLA.jpeg"/></div></figure><p id="a004" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像许多数据集一样，“500 个城市”将需要我们做一些工作，使其成为可用的格式。首先要注意的是，数据集大约有 800，000 多行，因为 28，000 多个人口普查区域中的<em class="ku">每个</em>都有一行用于收集 20 多个指标中的<em class="ku">每个</em>，包含这些人口普查区域的 500 个城市中的<em class="ku">每个</em>都有一行用于收集同样 20 多个指标中的<em class="ku">每个</em>的平均值。我不确定 CDC 为什么决定以这种格式发布数据，但有一种快速的方法可以清理数据，使其可用于各种项目和实验。下面是几个例子。</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><p id="ed4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">更改数据帧格式</strong></p><p id="03c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我上面提到的，数据集的实际布局并不理想。组织数据框的一种更直观的方式是将 28，000 多个人口普查区中的每一个表示为单独的一行，并在该行中为每个健康测量值设置单独的一列。以这种方式组织需要几个步骤:</p><p id="23b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">阅读《和熊猫在一起:<code class="fe lc ld le lf b">500_cities_data = pd.read_csv("./&lt;your file path")</code>中的“500 个城市”数据</p><p id="c1d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">屏蔽数据框以隔离城市级数据或人口普查区级数据。如果您的目标是人口普查级别的数据，您的代码应该是:</p><pre class="kn ko kp kq gt lg lf lh li aw lj bi"><span id="7c78" class="lk ll iq lf b gy lm ln l lo lp">census_data = 500_cities_data[500_cities_data["GeographicLevel"] == "Census Tract"] </span></pre><p id="7262" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您查看<code class="fe lc ld le lf b">census_data</code>(我们在步骤 1 中创建的新数据框架)的列，您会看到一个标记为“Measure”的列查看带有<code class="fe lc ld le lf b">census_data["Measure"].value_counts()</code>的那一列中的唯一值，您将看到收集的所有健康指标(例如，“18 岁以上成年人中的慢性肾病”)。请注意，每个测量值有 28，004 个，数据集中表示的每个普查区域一个。</p><p id="96c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个感兴趣的所有健康指标的列表，确保它们在上面的 value_counts 中的拼写正确，如下所示</p><pre class="kn ko kp kq gt lg lf lh li aw lj bi"><span id="72c1" class="lk ll iq lf b gy lm ln l lo lp">measures_of_interest = [“Chronic kidney disease among adults aged &gt;=18 Years",”No leisure-time physical activity among adults aged &gt;=18 Years", ... , ...]</span></pre><p id="c4aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将为列表<code class="fe lc ld le lf b">measures_of_interest</code>中的每个测量制作一个数据帧。一个快速的方法是从列表理解开始，制作一个数据帧列表，如下所示:</p><pre class="kn ko kp kq gt lg lf lh li aw lj bi"><span id="b585" class="lk ll iq lf b gy lm ln l lo lp">data_frame_list = census_data[census_data[“Measure”] == x] for x in measures_of_interest] </span></pre><p id="6ad0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您查看<code class="fe lc ld le lf b">data_frame_list</code> ( <code class="fe lc ld le lf b">data_frame_list[0]</code>)中的第一个数据帧，您将看到一个包含您的<code class="fe lc ld le lf b">measures_of_interest</code>列表中第一个健康指标数据的数据帧，每个人口普查区域占一行。</p><p id="1c0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是循环通过<code class="fe lc ld le lf b">data_frame_list</code>并提取每个普查区域的实际值。有几种方法可以做到这一点，但是我使用了一个 for 循环来提取列表中每个数据帧的<code class="fe lc ld le lf b">Data_Value</code>列，以及我想要保留用于分析的其他各种列。确保保留<code class="fe lc ld le lf b">UniqueID</code>列；我们需要重置每个数据帧的索引(原文如此),以适当地循环，保持<code class="fe lc ld le lf b">UniqueID</code>将允许我们正确地合并我们的数据。我们还可以使用<code class="fe lc ld le lf b">UniqueID</code>来使我们的健康数据与其他数据框架兼容，我将在本文稍后介绍。我还建议保留<code class="fe lc ld le lf b">GeoLocation</code>列，因为我们稍后可以用它来生成纬度和经度。</p><p id="7504" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了提取信息，我们将创建一个空列表，我们可以用新的数据帧填充它，并循环通过<code class="fe lc ld le lf b">data_frame_list</code>来提取我们想要的信息。将您想要从<code class="fe lc ld le lf b">data_frame_list</code>内的数据帧中提取的任何更多列作为键/值对添加到<code class="fe lc ld le lf b">temp_df</code>行，其中键是列名，值是列本身:</p><pre class="kn ko kp kq gt lg lf lh li aw lj bi"><span id="aa85" class="lk ll iq lf b gy lm ln l lo lp">metric_dfs = []<br/>for df in data_frame_list:<br/>    df.reset_index(inplace=True, drop=True)<br/>    temp_df = pd.DataFrame({df.MeasureId[0]:df.Data_Value,                <br/>              "UniqueID":df.UniqueID, "GeoLocation":df.GeoLocation, <br/>               "state":df.StateAbbr, "population":df.PopulationCount, ... })<br/>    metric_dfs.append(temp_df)</span></pre><p id="b687" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在<code class="fe lc ld le lf b">metric_dfs</code>中的数据帧现在是一种直观的格式！现在让我们制作一个<code class="fe lc ld le lf b">master</code>数据框架，使用<code class="fe lc ld le lf b">UniqueID</code>作为我们连接<code class="fe lc ld le lf b">metric_dfs</code>的列。首先实例化<code class="fe lc ld le lf b">master</code>数据帧，如下所示:</p><pre class="kn ko kp kq gt lg lf lh li aw lj bi"><span id="5ee7" class="lk ll iq lf b gy lm ln l lo lp">master = pd.merge(left = metrics_dfs[0], right = metrics_df[1],<br/>                  how = 'left', on = 'UniqueID')</span></pre><p id="aff9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用 for 循环将<code class="fe lc ld le lf b">metrics_dfs</code>中剩余的数据帧与<code class="fe lc ld le lf b">master</code>合并:</p><pre class="kn ko kp kq gt lg lf lh li aw lj bi"><span id="98b6" class="lk ll iq lf b gy lm ln l lo lp">for i in metric_dfs[2:]:<br/>    master = master.merge(i, how = "left",on="GeoLocation")</span></pre><p id="d1e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一步是从<code class="fe lc ld le lf b">metric_dfs</code>中的数据帧中删除重复的列。为此，只需像这样重新分配<code class="fe lc ld le lf b">master</code>(在下面的代码块中，我们用<code class="fe lc ld le lf b">.T</code>转置数据帧，删除重复的列，然后将数据帧转置回其原始配置):</p><pre class="kn ko kp kq gt lg lf lh li aw lj bi"><span id="2340" class="lk ll iq lf b gy lm ln l lo lp">master = master.T.drop_duplicates().T</span></pre><p id="b5d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，您已经有了一个格式正确的“500 个城市”数据集可以使用了！您仍然可以删除或创建大量的列，但是我让您按照自己的意愿去做。如果您想从数据中获得更多信息，请继续阅读！</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><p id="5756" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">使用正则表达式提取纬度和经度</strong></p><p id="66d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我建议在创建纬度和经度之前清理您的数据，但是您可以在过程<strong class="jp ir">的任何步骤中这样做，只要您保留了</strong> <code class="fe lc ld le lf b"><strong class="jp ir">GeoLocation</strong></code> <strong class="jp ir">列</strong>。<code class="fe lc ld le lf b">GeoLocation</code>这个数据帧中的值实际上是填充在一个字符串中的人口普查区域的纬度和经度，但是我们可以使用 RegEx 通过以下步骤将它们提取出来:</p><p id="73bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进口 RegEx: <code class="fe lc ld le lf b">import regex as re</code>。如果您还没有，请使用<code class="fe lc ld le lf b">!pip install regex</code>。</p><p id="aebc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来我们将使用 RegEx 的<code class="fe lc ld le lf b">.findall()</code>函数来定位纬度和经度。如果你不熟悉正则表达式，我强烈推荐<a class="ae kl" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank"> RegEx101 </a>来掌握窍门或者为你的给定任务开发正确的正则表达式模式。下面两行使用列表理解和特定的正则表达式模式来提取纬度和经度，并将它们转换为<code class="fe lc ld le lf b">float64</code>对象，并将新列添加到我们的 DataFrame 中:</p><pre class="kn ko kp kq gt lg lf lh li aw lj bi"><span id="a982" class="lk ll iq lf b gy lm ln l lo lp">master['Latitude'] = [float(re.findall("(\d+.\d+),", master.GeoLocation[i])[0]) for i in master.index]</span><span id="3efe" class="lk ll iq lf b gy lq ln l lo lp">master['Longitude'] = [float(re.findall("-\d+.\d+", master.GeoLocation[i])[0]) for i in master.index]</span></pre><p id="a170" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您的数据现在有明确的纬度和经度数据！您可以将这些数据用于地图绘制或任何需要纬度和经度列的事情。</p><p id="549c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">从唯一 ID 创建 5 位 FIPS 代码</strong></p><p id="f106" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对我们的数据帧的一个快速但有用的修改是拉出五位数的 FIPS 码(注意:有几种不同的 FIPS 格式；五位数格式指定了州和县)，这将允许我们将“500 个城市”数据与其他外部数据集适当地结合起来。我们的<code class="fe lc ld le lf b">UniqueID</code>列实际上是一个长格式的 FIPS 代码，其中前两位指定州，第三、第四和第五位指定县。提取前五个数字，并创建一个新的<code class="fe lc ld le lf b">FIPS5</code>列，其列表理解如下:</p><pre class="kn ko kp kq gt lg lf lh li aw lj bi"><span id="c634" class="lk ll iq lf b gy lm ln l lo lp">master['FIPS5'] = [x[0:5] for x in master.UniqueID]</span></pre><p id="ef8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们把这些新的 FIPS 代码工作！</p><p id="b59f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">结合“500 城”与收入数据</strong></p><p id="77d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们把健康数据和收入数据结合起来。维基百科上有一个很棒的表格(<a class="ae kl" href="https://en.wikipedia.org/wiki/List_of_United_States_counties_by_per_capita_income" rel="noopener ugc nofollow" target="_blank">这里是</a>)包含了美国每个县的收入数据。如果你知道怎么刮，那就去刮吧！如果你是这类事情的新手，去<a class="ae kl" href="http://wikitable2csv.ggor.de/" rel="noopener ugc nofollow" target="_blank"> Wiki 表格转换器</a>，粘贴 Wikipedia 页面链接，下载 csv。无论你选择哪条路线，用熊猫读取数据:<code class="fe lc ld le lf b">us_income_data = pd.read_csv('./&lt;your file name&gt;')</code></p><p id="d6ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你查看维基百科表格中的数据，我们有县和州名，但没有 FIPS 代码。幸运的是，我们可以使用一个名为<code class="fe lc ld le lf b">addfips</code>的库来添加它们！安装库，并导入<code class="fe lc ld le lf b">addfips</code>。我们可以使用<code class="fe lc ld le lf b">.get_county_fips()</code>函数获得五位数的 FIPS 代码，只要我们指定县和州名。下面是如何对它进行编码(注意，在指定县和州时，我使用“f-strings”来创建动态字符串):</p><pre class="kn ko kp kq gt lg lf lh li aw lj bi"><span id="976d" class="lk ll iq lf b gy lm ln l lo lp">fips_codes = []<br/>index = 0<br/>for i in range(us_county_income.shape[0]):<br/>    af = addfips.AddFIPS()<br/>    fip = af.get_county_fips(county = f"{us_county_income['County-equivalent'][i]}",<br/>                             state = f"{us_county_income['State'][i]}")<br/>    fips_codes.append(fip)</span><span id="fae2" class="lk ll iq lf b gy lq ln l lo lp">us_county_income['FIPS5'] = fips_codes</span></pre><p id="162b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们的<code class="fe lc ld le lf b">master</code>健康数据框架和<code class="fe lc ld le lf b">us_county_income</code>数据框架上都有了我们的<code class="fe lc ld le lf b">FIPS5</code>栏目。像这样结合两者:</p><pre class="kn ko kp kq gt lg lf lh li aw lj bi"><span id="1cb2" class="lk ll iq lf b gy lm ln l lo lp">health_and_income_df = pd.merge(master, us_county_income,how = 'left', on = 'FIPS5')</span></pre><p id="9157" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望这有助于你将“500 个城市”的数据转换成更有用的格式，我很高兴听到你用它做了什么！如果您有任何问题，请联系我们，或者分享您使用这些数据创建的东西！</p></div></div>    
</body>
</html>