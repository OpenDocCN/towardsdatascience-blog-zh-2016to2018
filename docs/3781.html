<html>
<head>
<title>Image Classification using Convolutional Neural Networks on MNIST data-set.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于 MNIST 数据集的卷积神经网络图像分类。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/image-classification-using-convolutional-neural-networks-on-mnist-data-set-406db0c265ed?source=collection_archive---------7-----------------------#2018-06-17">https://towardsdatascience.com/image-classification-using-convolutional-neural-networks-on-mnist-data-set-406db0c265ed?source=collection_archive---------7-----------------------#2018-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/95a5b8297678b9f40c26b0c51edf21c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LmxW8FDfXZJl5yvESvjP7Q.jpeg"/></div></div></figure><p id="9bb7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章是为那些对机器学习感兴趣并且正在寻找一个不太复杂的来源的人准备的。</p><p id="d45f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我是犹他大学的一名研究生，在我短暂的课程工作中，我对机器学习和人工智能产生了兴趣。我喜欢研究不同的数据集，并做笔记，然后发布到网上，这样那些觉得难以理解深度研究论文的人就可以从更简单、更容易理解的角度来看待人工智能和人工智能。</p><p id="4c20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我必须向一个五年级学生解释什么是机器学习，我会说，你迈出的每一小步都会产生一个结果，让你知道什么是有利的，什么是不利的。这是机器学习的基础。类似地，当我们在大型数据集上训练计算机系统时，我们在给它们提供什么是有利的，什么是不利的信息。例如，当狗和猫的图片被提供给系统时，系统根据该信息训练自己，并且基于该信息，系统现在能够识别什么是猫，什么是狗。如何训练一个计算机系统来完成这样的魔法，我们将在本文的后面部分找到答案。</p><h1 id="1699" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">MNIST 手写的图像:</h1><p id="cc83" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这是一个数据集，由从 0 到 9 的手写数字图像组成。每个图像都是单色的，28 * 28 像素。请参见下面的示例:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/ebbb3607eca55123338ecd335c026dbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*4HVsamLrsRuBrZe1gHZmVA.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Source: <a class="ae mi" href="https://www.tensorflow.org/tutorials/layers" rel="noopener ugc nofollow" target="_blank">https://www.tensorflow.org/tutorials/layers</a></figcaption></figure><h1 id="f9ee" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">目标:</h1><p id="d98f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">训练计算机系统首先理解什么是数字的手写图像，然后测试该系统以正确预测新的手写图像。我们将向我们的系统提供 MNIST 数据集，并用随机图像对其进行测试，以检查其预测的准确性。</p><h1 id="f633" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">先决条件:</h1><ol class=""><li id="d6fb" class="mj mk iq ka b kb lu kf lv kj ml kn mm kr mn kv mo mp mq mr bi translated">python 脚本基础知识，Python 3.6。</li><li id="2597" class="mj mk iq ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated">关于什么是机器学习和张量流的概念。</li><li id="a8bd" class="mj mk iq ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated">学习新事物的活力。</li></ol><h1 id="4a82" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">如何做:</h1><p id="a0fe" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><strong class="ka ir">导入张量流和 MNIST 数据:</strong></p><pre class="ma mb mc md gt mx my mz na aw nb bi"><span id="06de" class="nc kx iq my b gy nd ne l nf ng">import tensorflow as tf</span><span id="e651" class="nc kx iq my b gy nh ne l nf ng">from tensorflow.examples.tutorials.mnist import input_data<br/>mnist = input_data.read_data_sets("MNIST_data/", one_hot=True)</span></pre><p id="3dc9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">占位符:</strong></p><p id="bb12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">占位符不同于变量。它们是为保存训练数据而创建的参数，在这种情况下，它们是训练图像。MNIST 图像的形状为(28*28)。这些将被展平成(None *784)形状张量。“无”表示它可以是任何大小。</p><pre class="ma mb mc md gt mx my mz na aw nb bi"><span id="959a" class="nc kx iq my b gy nd ne l nf ng">x = tf.placeholder(tf.float32, [None, 784])</span></pre><p id="a259" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">权重和偏差:</strong></p><p id="2fda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">权重和偏差的初始值被设置为零，因为当计算发生时它将被改变。因此，初始值是什么并不重要。因为存在 784 个特征和 10 个输出，所以 w’是(784 * 10)形状。“b”的形状是 10，因为从 0 到 9(数字)有 10 个输出。</p><pre class="ma mb mc md gt mx my mz na aw nb bi"><span id="4327" class="nc kx iq my b gy nd ne l nf ng">w = tf.Variable(tf.zeros([784,10]))<br/>b = tf.Variable(tf.zeros([10]))</span></pre><p id="1a09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">预测模型:</strong></p><p id="747a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">x 和 w 是相乘并加到偏差上的矩阵。softmax 函数接受值并使总和为 1。这样，它可以用作概率值，使得判断哪个数字(0 -9)被预测的机会更高变得一致。</p><pre class="ma mb mc md gt mx my mz na aw nb bi"><span id="32d3" class="nc kx iq my b gy nd ne l nf ng">y = tf.nn.softmax(tf.matmul(x,w) + b)<br/>#training our model<br/>y_ = tf.placeholder(tf.float32, [None,10])</span></pre><p id="c47b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">交叉熵函数:</strong></p><p id="4b29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">交叉熵函数是成本或损失函数。它将真实值与预测值进行比较。目标是使损失最小化。</p><pre class="ma mb mc md gt mx my mz na aw nb bi"><span id="e842" class="nc kx iq my b gy nd ne l nf ng">cross_entropy = tf.reduce_mean(-tf.reduce_sum(y_ * tf.log(y), reduction_indices=[1]))</span></pre><p id="25df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">梯度下降优化器:</strong></p><p id="a0bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当使用交叉熵函数形成模型图时，我们希望找到损失最小的点。这是使用梯度下降优化器完成的。它向图中值较小的部分移动。可以手动设置步数或学习率。如果设定一个非常小的学习率，如 0.001，系统将永远需要达到损失最小的点，但它将更加精确。如果学习率设置得很高，则系统可能会产生快速但错误的结果。</p><pre class="ma mb mc md gt mx my mz na aw nb bi"><span id="850a" class="nc kx iq my b gy nd ne l nf ng">train_step = tf.train.GradientDescentOptimizer(0.5).minimize(cross_entropy)</span></pre><p id="e701" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">训练模式:</strong></p><p id="d724" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们正在训练我们的模型，以 100 个为一批来学习 MNIST 数据。</p><pre class="ma mb mc md gt mx my mz na aw nb bi"><span id="1814" class="nc kx iq my b gy nd ne l nf ng">y_ = tf.placeholder(tf.float32, [None,10])</span><span id="f628" class="nc kx iq my b gy nh ne l nf ng">cross_entropy = tf.reduce_mean(-tf.reduce_sum(y_ * tf.log(y), reduction_indices=[1]))</span><span id="1f01" class="nc kx iq my b gy nh ne l nf ng">train_step = tf.train.GradientDescentOptimizer(0.5).minimize(cross_entropy)</span></pre><p id="5712" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">评估和测试模型:</strong></p><p id="f455" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，模型以 0.8916 的精度被评估和测试。tf.argmax 给出一个轴中的最高值。所以，y_ 是正确值，y 是预测值。tf.equal 用于判断它们是否相等。</p><pre class="ma mb mc md gt mx my mz na aw nb bi"><span id="b179" class="nc kx iq my b gy nd ne l nf ng">prediction = tf.equal(tf.argmax(y,1), tf.argmax(y_,1))</span></pre><p id="2b7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">多卷积层:</strong></p><p id="65ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们使用更多的层、权重和偏差来改进我们的模型并提高准确性。</p><p id="520e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的第一个卷积层对于每个 5*5 的面片有 32 个特征。它的权重张量将是[5，5，1，32]的形状。前两个维度是面片大小，接下来是输入通道，最后一个数字是输出通道。</p><p id="7512" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了应用卷积层，x 被整形为 4D 张量。28*28 是图像的宽度和高度，最后一个维度是颜色通道的数量。</p><p id="537e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后应用 ReLU 函数使负值为 0，并保持正值不变。最大池将图像大小缩小到 14*14。</p><p id="2d56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二卷积层对于每个 5*5 的面片具有 64 个特征。</p><p id="a26a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，图像大小已经减少到 7*7，我们添加一个具有 1024 个神经元的全连接层。</p><p id="87d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">漏失和读出层:</strong></p><p id="759f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了减少过度拟合，我们会随机丢弃一些数据。因此，下降层有助于提高预测的准确性。下一层用于读取数据。</p><p id="0485" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">最终精度:</strong></p><p id="f6fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">0.9919</p><p id="ef63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">完整的 Python 代码:</strong></p><div class="ni nj gp gr nk nl"><a href="https://github.com/rajitnikhare/MNIST/blob/master/MNIST_Softmax.py" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">拉吉特尼哈尔/MNIST</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">在 GitHub 上创建一个帐户，为 rajitnikhare/MNIST 的发展做出贡献。</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">github.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz jw nl"/></div></div></a></div><p id="8a2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">参考文献:</strong></p><ol class=""><li id="6eff" class="mj mk iq ka b kb kc kf kg kj oa kn ob kr oc kv mo mp mq mr bi translated"><a class="ae mi" href="https://www.tensorflow.org/versions/r1.0/get_started/mnist/pros" rel="noopener ugc nofollow" target="_blank">https://www . tensor flow . org/versions/r 1.0/get _ started/Mn ist/pros</a></li><li id="2706" class="mj mk iq ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated"><a class="ae mi" href="https://codelabs.developers.google.com/codelabs/cloud-tensorflow-mnist/#2" rel="noopener ugc nofollow" target="_blank">https://code labs . developers . Google . com/code labs/cloud-tensor flow-mnist/# 2</a></li></ol></div></div>    
</body>
</html>