<html>
<head>
<title>Speeding up your code (3): batches and multithreading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加速您的代码(3):批处理和多线程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/speeding-up-your-code-3-batches-and-multiprocess-52d2d34a4091?source=collection_archive---------3-----------------------#2017-09-29">https://towardsdatascience.com/speeding-up-your-code-3-batches-and-multiprocess-52d2d34a4091?source=collection_archive---------3-----------------------#2017-09-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="15d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来自本系列:</p><ol class=""><li id="e9f4" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><a class="ae ku" href="https://medium.com/@vincenzo.lavorini/speeding-up-your-code-1-the-example-of-the-mean-shift-clustering-in-poincar%C3%A9-ball-space-d46169bfdfc8" rel="noopener">庞加莱球空间中均值漂移聚类的例子</a></li><li id="d908" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><a class="ae ku" href="https://hackernoon.com/speeding-up-your-code-2-vectorizing-the-loops-with-numpy-e380e939bed3" rel="noopener ugc nofollow" target="_blank">用Numpy对循环进行矢量化</a></li><li id="a509" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">批处理和多线程(这篇文章)</li><li id="aaee" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><a class="ae ku" href="https://medium.com/@vincenzo.lavorini/speeding-up-your-code-4-in-time-compilation-with-numba-177d6849820e" rel="noopener">用Numba实时编译</a></li></ol><p id="1b49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上一篇文章中，我们展示了我们算法的矢量化版本会随着向量数量的增加而变慢，我们将这一特性与以下事实相关联:对于<em class="la"> N </em>个向量，我们处理的是<em class="la"> N </em>个矩阵。</p><p id="4cfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们将实现一种算法，每次处理一批向量，即批处理版本。利用这个技巧，我们将对顺序为<em class="la"> n x N </em>的矩阵进行计算，其中小的<em class="la"> n </em>是一批中要考虑的向量的数量。这个技巧的一个很好的副作用是，我们还可以并行计算。</p><h1 id="956c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">更新代码</h1><p id="102c" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">均值漂移过程中的第一个操作是计算每个向量到所有其他向量的距离，在庞加莱球空间中，距离为:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi me"><img src="../Images/c2c8ea988bc2dece7fa519d37cab9b6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/1*AqOYJVG7apuyWu5O65MlyA.gif"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Distance in Poincaré ball</figcaption></figure><p id="d07b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按照我们的1000个二维向量的例子，为了计算距离公式的分子，我们需要第一个<em class="la"> n </em>元素的这个<em class="la"> n x 1000 </em>矩阵:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mq"><img src="../Images/42abf87f69d2df754155a988288d48d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/1*3l-vL7N9DBFFQ-Pnx__sjQ.gif"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Batched version of the vectorized numerator of the distance formula.</figcaption></figure><p id="cf9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后像以前一样，得到的矩阵中每个元素的分量(都是向量，还记得隐藏维吗？)都得平方总结。</p><p id="fa2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在分母上，我们必须对这个结构进行编码:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/2404dcce4d71b1f702983a081cd9e323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/1*0QB152MUvlEoHfDM3C0ZJw.gif"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Batched version of the vectorized denominator of the distance formula.</figcaption></figure><p id="a36a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">距离函数的其余部分很容易。使用Numpy语言，下面是计算数据集子样本(批处理)和整个数据集之间的距离所需的代码。只有修改过的行被注释:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Batched version of the code for the Poincaré ball distance.</figcaption></figure><p id="84bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">整个meanshift算法几乎保持不变:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Code for one iteration of the meanshift algorithm, batched version</figcaption></figure><p id="e4f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最大的不同是，这里我们动态地更新矢量，也就是说，我们根据已经移动的矢量计算出的距离来移动矢量。实际上:在第一批中，距离是以传统方式计算的，产生的移位向量被放置在原始数据集中。因此，我们将有一个数据集，其中第一个<em class="la"> n个</em>向量被移位，而其他向量没有被移位。当我们考虑第二批时，将针对该混合数据集计算距离，对于其他批也是如此。</p><p id="fac6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这个版本的算法的稳定性需要更好的研究，但我们可以相当肯定的是，使用小高斯宽度(<em class="la">∑</em>)我们不会遇到问题。</p><p id="a811" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，在我们在<a class="ae ku" href="https://hackernoon.com/speeding-up-your-code-2-vectorizing-the-loops-with-numpy-e380e939bed3" rel="noopener ugc nofollow" target="_blank">前一篇文章</a>中介绍的位置循环=bad之后，我们回到另一个循环，因为为了移动所有的向量，我们必须为每一个可能的批次运行这个过程。但是好消息是每个批处理都是相互独立的，所以我们可以并行化这个循环！</p><p id="2f51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了利用我们的多核处理器，我们将使用Python的<a class="ae ku" href="https://docs.python.org/3.4/library/concurrent.futures.html" rel="noopener ugc nofollow" target="_blank"><em class="la">ThreadPoolExecutor</em></a><em class="la"/>函数:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="eb5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于ThreadPoolExecutor的细节超出了本系列文章的范围，但简而言之:</p><ol class=""><li id="64a4" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">修改<em class="la"> __shift </em>函数，以恢复该函数已移动的向量的位置；这是追踪移动的向量并将其放入数据集中正确位置所必需的。</li><li id="d492" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">定义了一个字典(<em class="la">future _ shift</em>)，它包含所有要并行执行的函数，每个批处理一个；函数的数量将取决于所选择的批量大小，例如，如果数据集包含1000个向量，并且选择的批量大小为200，则字典将包含5个函数。</li><li id="e33c" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">一旦执行了每个函数，数据集中由跟踪号指定的位置(此列表中的点1)处的相对位移矢量就会更新。</li></ol><p id="126d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅此而已！现在，我们在速度执行方面获得了多少？让我们用通常的二维向量集合来检查一下:</p><div class="mf mg mh mi gt ab cb"><figure class="my mj mz na nb nc nd paragraph-image"><img src="../Images/fd1949cc7b504f53e3cd6e5621707ee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*dT2bDr3PtdteFr4d1_s57g.png"/></figure><figure class="my mj ne na nb nc nd paragraph-image"><img src="../Images/c9056521f5f2acc298b0207d3850130d.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*kFw1HeG30Way1b56ECcieg.png"/><figcaption class="mm mn gj gh gi mo mp bd b be z dk nf di ng nh">Comparison of the execution time for the mean shift algorithm, absolute on the left, relative on the right.</figcaption></figure></div><p id="1a8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不出所料，水货版更快。数据集越大，它的性能就越好:对于移动一个由18k个向量组成的数据集，并行版本只需要一次移动所有向量所需时间的5%。这是因为旧版本在<a class="ae ku" href="https://en.wikipedia.org/wiki/Time_complexity#Polynomial_time" rel="noopener ugc nofollow" target="_blank">多项式时间</a> O(N)中执行，而并行版本在<a class="ae ku" href="https://en.wikipedia.org/wiki/Time_complexity#Linear_time" rel="noopener ugc nofollow" target="_blank">线性时间</a>中执行:不管数据集大小如何，我们总是使用固定大小的矩阵执行操作(<em class="la"> n_batches x N </em>，在前面的示例中<em class="la"> n_batches </em> =100)。</p><h1 id="70a1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="2853" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">所有的数值算法都有一个要达到的目标:在合理的时间内获得合理精确的结果。所以，一般来说，在保持精度不变的情况下，加快算法的执行速度就像金子一样。如果考虑生产环境，更快的执行意味着更早地释放硬件资源；在相同的单位时间内可以执行更多的线程，这意味着省钱。更多:在实时应用中，执行速度可以区分可能和不可能。</p><p id="5db4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于“我如何才能提高速度？”这个问题，第一个天真的答案是通常是“购买更快的硬件！”，但看看接下来的图，我们比较了算法的原始版本(在第一篇文章的<a class="ae ku" href="https://medium.com/@vincenzo.lavorini/speeding-up-your-code-1-the-example-of-the-mean-shift-clustering-in-poincar%C3%A9-ball-space-d46169bfdfc8" rel="noopener">中描述)和这里解释的版本:</a></p><div class="mf mg mh mi gt ab cb"><figure class="my mj ni na nb nc nd paragraph-image"><img src="../Images/1220bb34c529854d5456c135b872fd1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*TmKyNHqvmcI_I1sFaII-Rw.png"/></figure><figure class="my mj nj na nb nc nd paragraph-image"><img src="../Images/7978314384f15d8f7f2feab0b6584217.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*uctxA11NQvqoLA9hFLipAw.png"/><figcaption class="mm mn gj gh gi mo mp bd b be z dk nk di nl nh">Comparison between the algorithm in the first post (‘looped’) and the one in the present post (‘batched &amp; parallel’).</figcaption></figure></div><p id="cc51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要0.4%多一点的时间来执行一次迭代，这意味着并行矢量化算法比循环算法快250倍。或者，如果你喜欢，快25000%。</p><p id="59f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你能想到购买硬件的速度快250倍吗？这就像从2009年构建的英特尔赛扬处理器(~4 GFLOPS)过渡到2017年构建的英特尔I9(~ 1000 GFLOPS)。是的，你需要一个时间机器。</p><p id="0016" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更好的优化代码，不是吗？</p><p id="5eff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想自己试试，可以在这里找到代码<a class="ae ku" href="https://github.com/vlavorini/meanshift_blog" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>