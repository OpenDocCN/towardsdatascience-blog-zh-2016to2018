<html>
<head>
<title>Simple NLP Search in Your Application — Step-by-Step Guide in Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应用中的简单NLP搜索Scala中的逐步指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/simple-nlp-search-in-your-application-step-by-step-guide-in-scala-22ca1ce3e475?source=collection_archive---------1-----------------------#2017-06-25">https://towardsdatascience.com/simple-nlp-search-in-your-application-step-by-step-guide-in-scala-22ca1ce3e475?source=collection_archive---------1-----------------------#2017-06-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c62d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">全文搜索很容易使用。但是自然语言固有的模糊性导致搜索结果存在误报。为了获得更准确的结果，我们需要改变方法，向搜索引擎提供更多特定领域的数据。</p><p id="01cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">改善搜索结果最常见和最容易的方法是引入过滤器，即多个输入字段(文本字段、单选按钮等)。)以属性命名。这样我们就知道如何构造查询，然后返回特定的结果。结合一些近似的字符串匹配算法，我们可以获得非常精确的搜索结果。不幸的是，过滤器需要具有多个字段的表单，代价是简单的UX。(参见<em class="kl">图1 </em>)。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/3a3b104ea288f462ff530dec0466fff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*7fpROwH7dgUzCtvNzaiJog.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Figure 1</figcaption></figure><p id="53ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们希望坚持使用单个文本字段，并且仍然有准确的搜索结果(见<em class="kl">图2 </em>)会怎么样？当然，人们需要使用自然语言处理(NLP)工具。但是IT行业的每个人都知道NLP很难掌握，大多数人认为这是一种高度学术化的方法。如何轻松地利用这一点来改善特定领域的搜索结果？</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi ky"><img src="../Images/7e2450b1e43a98e638bbc583322a1823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vFT6X5y5RoAiHinkHN14tw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Figure 2</figcaption></figure><h2 id="2331" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">领域</h2><p id="8c91" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">领域的特殊性是该方法的关键部分。机器学习算法还远远没有准备好回答一般的问题。即使算法存在，它们也离我们很远。为了简单起见，我们必须缩小范围。通常，当我们需要引入一个搜索表单时，我们在某个区域内操作，即在ebay.com找到一辆车，我们指定车的类型、生产年份、制造商、型号等..</p><p id="65da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于本文，让我们以电影放映的领域为例，即:电影、剧院和日期时间的元组。我们也可以假设我们知道电影院的地理位置和电影的类型。我们将通过标题(或只是流派)、影院名称(或只是地点)以及放映的日期和时间来查询电影放映，这是我们需要从用户那里收集的数据。我们想要处理的示例表达式:</p><ul class=""><li id="15af" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated"><em class="kl">明天旧金山的火星人</em>:查询旧金山所有明天上映<em class="kl">火星人</em>的影院，</li><li id="2f53" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated"><em class="kl">下周amc的《归来者》</em>:查询<em class="kl"> AMC </em>剧场<em class="kl">下周《归来者》</em>的所有演出，</li><li id="f40d" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated"><em class="kl"> cinemark下周三</em>:查询<em class="kl"> Cinemark </em>影院下周三将上演的所有节目，</li><li id="b88d" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated"><em class="kl">6月11日旧金山的戏剧</em>:查询旧金山所有剧院将于6月11日上演的戏剧。</li></ul><p id="96a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有表达式都从自然语言转换为以下形式的查询:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h2 id="b4f9" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">对自然语言处理的需求</h2><p id="3e89" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">很难从自然语言中提取信息。如果我们假设只有几种输入语句，如<strong class="jp ir">【电影名称】</strong><strong class="jp ir">【剧院位置】【时间表情】</strong>，那么就有可能为这种语句显式地编写解析器。但是，即使有人设法做到了这一点，这样的算法将是不可维护的。有了NLP工具，我们可以在不需要显式编程的情况下解决这个问题。</p><p id="45b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，一些语句在结构上极其相似，例如:<strong class="jp ir">【电影名称】【时间表达式】</strong>和<strong class="jp ir">【剧院名称】【时间表达式】</strong>——不可能明确区分这两种语句。NLP工具还关心<strong class="jp ir">【MOVIE _ NAME】</strong>和<strong class="jp ir">【THEATER NAME】</strong>的结构，那么当从语句中提取信息时，它拥有比显式解析器更多的数据来做出决定。</p><h2 id="1e04" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">解决方案的描述</h2><p id="258f" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">对于我们的例子，我们需要的信息提取的唯一子任务叫做<em class="kl">命名实体识别</em>。正确标记了语句之后，我们就能够编写我们的<em class="kl">查询</em>。我们所说的标记是指为语句中的每个单词分配一些特定于领域的元信息，例如:</p><ul class=""><li id="99a8" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated"><em class="kl">明日旧金山的火星人</em>——<strong class="jp ir">(电影_名字:火星人)(介词:在)(影院_地点:旧金山)(时间_表情:明日)</strong></li><li id="c1cc" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated"><em class="kl"> amc下周三</em>——<strong class="jp ir">(剧场_名称:amc)(时间_表情:下周三)</strong></li></ul><h2 id="c0e2" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">工具</h2><p id="b6f7" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">当试图解决这个问题时，我们的第一次尝试是尝试斯坦福命名实体识别器，它给了我们惊人的结果，但不幸的是，由于GNU GPLv2许可，它不能用于商业。</p><p id="b3a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们决定使用ScalaNLP套件中的Epic库。Epic 实现了许多NLP算法，但是我们遇到的缺点是缺少文档，因此它的使用远非简单明了。</p><h2 id="2a74" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">抽样资料</h2><p id="761d" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">为了训练命名实体识别器(NER ),我们需要为算法提供样本数据。如果我们没有任何现实生活中的数据，那么我们可能会根据可能的模式生成一些随机语句，例如:</p><ul class=""><li id="24f8" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">[影院_位置][时间_表情]中的[电影_名称]</li><li id="0a0a" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">[影院_位置]中的[电影_流派][时间_表情]</li></ul><p id="87f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输入的格式取决于我们使用的库。描述训练数据的学术标准<a class="ae mr" href="http://www.cnts.ua.ac.be/conll2003/ner/" rel="noopener ugc nofollow" target="_blank"> CoNLL </a>涵盖了我们所需要的更多。幸运的是，有一种方法可以简化标记，即:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="5818" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">训练样本的最佳大小取决于领域的复杂性，应该根据经验进行验证。</p><p id="12be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在<a class="ae mr" href="https://github.com/evojam/simple-nlp-search-dataset-generator" rel="noopener ugc nofollow" target="_blank"> GitHub </a>查看我们如何生成样本数据的例子。</p><h2 id="628d" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">训练NER</h2><p id="40cc" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们需要对标记语句之间的关系进行编码，然后构建一些一致的解释以供进一步重用。解决这个问题的统计工具被称为<em class="kl">条件随机场(CRF)</em>。在<em class="kl"> ScalaNLP </em>中，有两种可用的CRF实现。第一个<em class="kl"> epic.sequences.CRF </em>是普通的线性链CRF，第二个<em class="kl"> epic.sequences.SemiCRF </em>是半马尔可夫线性链的实现，它应该以较小的精度代价具有更好的性能。</p><p id="6f97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">将输入数据加载到序列阅读器</strong> <br/> <em class="kl"> ScalaNLP </em>具有内置的用于CoNLL数据的解析器—<em class="kl">epic . corpora . conllsequencereader</em>，它接受我们在<em class="kl">示例数据</em>一节中提出的数据输入。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6507" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">应用分段函数</strong> <br/>我们通过将输入数据转换为<em class="kl">epic . sequences . segmentation【Any，String】</em>来训练CRF。分段是将相同的标签组合成一行。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="b4f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用的分段函数:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="2bdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">构建CRF </strong> <br/>将输入分段后，我们可以构建CRF:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="1c92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">使用经过训练的<em class="kl">通用报告格式</em>来标记序列</strong></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="1cac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">epic . preprocess . tokenize</em>只是通过空格进行标记。</p><p id="77b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">分段</em>携带标记序列。当我们呈现一个样本表达式时，我们得到一个带有标记段的字符串:</p><p id="b3f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">【电影_名称:</em> <strong class="jp ir"> <em class="kl">火星人</em> </strong> <em class="kl">】【介词:</em> <strong class="jp ir"> <em class="kl">在</em> </strong> <em class="kl">】【剧场_地点:</em> <strong class="jp ir"> <em class="kl">三藩</em> </strong> <em class="kl">】【介词:</em> <strong class="jp ir"> <em class="kl">在</em> </strong> <em class="kl">】【时间_表情:</em><strong class="jp ir"><em class="kl">2016年6月11日<em class="kl">唯一缺少的部分是<em class="kl"> TIME_EXPRESSION </em> s。我们需要类型<em class="kl"> DateTime </em>的从</em>和<em class="kl">到</em>的显式<em class="kl">参数。我们可以使用<a class="ae mr" href="http://www.ocpsoft.org/prettytime/nlp/" rel="noopener ugc nofollow" target="_blank"> PrettyTime::NLP </a>来解析显式的时间表达式，比如:<em class="kl">2016年6月11日</em>，但是如果我们想要获得更复杂的东西，比如<em class="kl">下周三</em>或<em class="kl">明天</em>，我们应该再次使用NLP方法，即训练CRF用于时间表达式。结果相当惊人。<em class="kl"> crf </em>一旦经过训练，马上就能发挥作用。解释的准确性将根据领域的复杂性和训练样本的大小而变化。在我们的案例中，我们对准确性感到惊讶——即使对于含糊不清的陈述,<em class="kl"> crf </em>也做得很好。</em></em></strong></p><p id="1a87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于20万条输入语句的样本量(用<a class="ae mr" href="https://github.com/evojam/simple-nlp-search-dataset-generator" rel="noopener ugc nofollow" target="_blank">simple-ner-search-dataset-generator</a>生成)，我们用<a class="ae mr" href="https://github.com/evojam/ner-trainer" rel="noopener ugc nofollow" target="_blank"> ner-trainer </a>对ner进行了训练，得到如下结果:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="eeb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过安装<a class="ae mr" href="https://github.com/evojam/ner-trainer" rel="noopener ugc nofollow" target="_blank"> ner-trainer </a>并通过调用<strong class="jp ir"><em class="kl">ner-trainer-l film-screenings.tar.gz</em></strong>加载序列化的<a class="ae mr" href="https://www.dropbox.com/s/qfezeynlcegkfni/film-screenings.tar.gz?dl=0" rel="noopener ugc nofollow" target="_blank">示例</a>，您可以在互动会话中亲自检查这一点。</p><h2 id="66fd" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">权衡</h2><p id="cda8" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">不幸的是，训练<em class="kl"> CRF </em>非常耗时(以小时计算)。为了不浪费时间，需要序列化<em class="kl"> SemiCRF </em>对象。序列化是以牺牲二进制兼容性为代价的。此外，SemiCRF可能是一个相当重的物体，因此会增加额外内存的成本。</p><p id="ec64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> Epic </em>库不好用。文档不是很有帮助，也缺乏严肃的静态类型。即使在这个简短的例子中，我们也无法避免将<em class="kl">作为</em>的实例。</p><h2 id="915b" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">结论</h2><p id="600b" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">目前可用的库很好地覆盖了问题的困难部分。权衡是可能克服的，而且其中许多相对容易解决，所以将来可能会消失。尽管如此，我们还是有可能构建非常复杂的基于自然语言处理的搜索，而不会淹没在复杂的数学中。即使是新手也应该能够在几天内实现搜索。</p><h2 id="ef41" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">资源定位符</h2><ul class=""><li id="a9b1" class="mb mc iq jp b jq lw ju lx jy ms kc mt kg mu kk mg mh mi mj bi translated">http://www.scalanlp.org/</li><li id="1460" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">斯坦福命名实体识别器:<a class="ae mr" href="http://nlp.stanford.edu/software/CRF-NER.shtml" rel="noopener ugc nofollow" target="_blank">http://nlp.stanford.edu/software/CRF-NER.shtml</a></li><li id="fb87" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">pretty time::NLP:<a class="ae mr" href="http://www.ocpsoft.org/prettytime/nlp/" rel="noopener ugc nofollow" target="_blank">http://www.ocpsoft.org/prettytime/nlp/</a></li><li id="dc7a" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">https://github.com/evojam/ner-trainer<a class="ae mr" href="https://github.com/evojam/ner-trainer" rel="noopener ugc nofollow" target="_blank">NER培训师</a></li><li id="b9fc" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">电影放映数据集生成器:<a class="ae mr" href="https://github.com/evojam/simple-nlp-search-dataset-generator" rel="noopener ugc nofollow" target="_blank">https://github . com/Evo jam/simple-NLP-search-dataset-Generator</a></li><li id="85b9" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">样本<a class="ae mr" href="https://drive.google.com/file/d/0ByjmxsRtyWkLMWwxT2cyamJ1WUU/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">用于电影放映的序列化通用报告格式</a></li></ul><p id="285b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你们所有人都觉得被邀请去使用NER训练器和数据集生成器在你们的领域进行测试和黑客攻击。请在评论中提供反馈，说明这种方法如何为您服务。</p><p id="cfb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该帖子最初在tech.evojam.com发表。</p></div></div>    
</body>
</html>