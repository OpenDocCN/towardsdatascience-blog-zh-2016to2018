<html>
<head>
<title>Object Detection and Counting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">目标检测和计数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/object-detection-10f3601e4175?source=collection_archive---------3-----------------------#2017-04-01">https://towardsdatascience.com/object-detection-10f3601e4175?source=collection_archive---------3-----------------------#2017-04-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d493" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用不同技术的对象检测、识别</h2></div><p id="f83e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对象检测，尤其是识别可以使用不同的技术来完成，如<a class="ae lb" href="http://opencv.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> OpenCV </strong> </a>函数的组合。对我来说，用R语言构建一个快速模型，然后花几周时间编写冗长的C++或。它的NET代码。我从一个人计数器开始，作为对象检测的实际应用，并拍摄了经过办公室的人的镜头。</p><p id="2f71" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先需要使用<a class="ae lb" href="https://ffmpeg.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> FFmpeg </strong> </a>从视频中准备图像。然后选择一个背景图像，创建一个有物体的图像和背景图像之间的差异矩阵。正如可以在<a class="ae lb" href="http://bosyi.com/craft/vectorization-raster-polygon-r-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">我的博客</strong> </a>上找到的，我已经创建了一个用于光栅图像处理和矢量化的R库—<a class="ae lb" href="https://cran.r-project.org/package=fasteraster" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir">faster raster</strong></a>，这可以用于对象检测，因此想法是通过一些梯度检测区域来矢量化差异矩阵。</p><p id="85d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这张图片上，有一个变体#1，其中图片矩阵由简单的RGB值表示。他们的比较让我对这个人的影子有了很强的物体探测能力(参见课程代码):</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/530bd1b173b51b4ca8cb3f7af92a274e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/0*LuM4AmKzDjrJm9Ma.png"/></div></figure><p id="2804" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，下一个想法(代码中的变量#2)是计算颜色(红/绿，绿/蓝)之间的差异，然后与背景进行比较。这清理了阴影检测，但引入了另一个问题，即大量黑暗区域的检测，这可能是由较差的CMOS相机颜色检测能力引起的:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/08266d43a035fc058075e92e21c7748a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/0*ELe1r1qrcgopnZjn.png"/></div></figure><p id="e5c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我决定减去颜色(红-绿，绿-蓝),效果很好。我还增加了检测区域重量的过滤，并在视频中显示出来。正如你所看到的，当一个黑色物体穿过黑色背景时，还有另一个问题——它被分成两个或三个部分:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="a5ee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本例中，我只是添加了代码来连接这些区域，并计算连接对象的新中心。添加了跟踪线和两个绿色边距，以检测沿同一方向通过的对象:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="76e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以看到，模型本身花了一页代码，大部分是为了可视化。然而，模型中不包括以下项目:</p><ul class=""><li id="3350" class="lm ln iq kh b ki kj kl km ko lo ks lp kw lq la lr ls lt lu bi translated">背景图像——它必须适应天气、白天和其他条件(就像有人在观察区域的中央留下了一个包)。</li><li id="65a9" class="lm ln iq kh b ki lv kl lw ko lx ks ly kw lz la lr ls lt lu bi translated">清点物体——只需检查穿过绿色空白处的向量</li><li id="62ba" class="lm ln iq kh b ki lv kl lw ko lx ks ly kw lz la lr ls lt lu bi translated">多目标检测——基于路径近似的需求识别算法。</li><li id="a4e3" class="lm ln iq kh b ki lv kl lw ko lx ks ly kw lz la lr ls lt lu bi translated">连接对象识别-需要对形状中线进行聚类，通过平均权重和路径近似将连接区域分割成更小的区域。</li></ul><p id="641d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="ma">物体检测R源代码</em> </strong></p><pre class="ld le lf lg gt mb mc md me aw mf bi"><span id="f4b2" class="mg mh iq mc b gy mi mj l mk ml">library("png");<br/>library("raster");<br/>library("fasteraster");<br/><br/>X &lt;- 48 * 2 ;<br/>Y &lt;- 27 * 2;<br/>from &lt;- 140;<br/>to &lt;- 200;<br/><br/>matrixFromFrame &lt;- function (idx)<br/>{<br/>  v &lt;- readPNG(sprintf("in/%03d.png", idx));<br/>  rgb &lt;- lapply(1:3, function(x) as.matrix(aggregate(raster(v[ , , x]), fact = 5)));<br/>  rgb &lt;- lapply(rgb, function(x) t(x)[1:X, Y:1]);<br/>  #1 return(rgb);<br/>  #2 return(list(rgb[[1]] / rgb[[2]], rgb[[2]] / rgb[[3]]));<br/>  return(list(rgb[[1]] - rgb[[2]], rgb[[2]] - rgb[[3]], (rgb[[1]] + rgb[[2]] + rgb[[3]]) / 3));<br/>}<br/><br/>processFrame &lt;- function(idx, back)<br/>{<br/><em class="ma">#  png(file = sprintf("out/final%03d.png", idx), width = 640, height = 480);</em><br/>  rggb &lt;- matrixFromFrame(idx);<br/>  diff &lt;- (rggb[[1]] - back[[1]]) ^ 2 + (rggb[[2]] - back[[2]]) ^ 2;<br/>  pol &lt;- raster2vector(diff, 0.001, 100, 100);<br/>  plot(0, type = "l", xlim = c(1, X), ylim = c(1, Y));<br/>  rasterImage(readPNG(sprintf("in/%03d.png", idx), native = TRUE), 1, 1, X, Y);<br/>  abline(v = 30, col = 'green');<br/>  abline(v = 70, col = 'green');<br/>  lapply(pol, function(x) lines(rbind(x, x[1,]), col = 'blue'));<br/>  zone &lt;- rasterZoneAnalyzer(diff, 0.001, 100, 100);<br/>  zone &lt;- zone[zone[ , 2] &gt; 10, , drop = FALSE];<br/>  <em class="ma">#text(zone[ , 3], zone[ , 4], labels = zone[ , 2], col = 'red');</em><br/>  track[[idx - from + 1, 1]] &lt;&lt;- sum(zone[, 2] * zone[, 3]) / sum(zone[, 2]);<br/>  track[[idx - from + 1, 2]] &lt;&lt;- sum(zone[, 2] * zone[, 4]) / sum(zone[, 2]);<br/>  lines(track, col = 'red');<br/>  points(track, col = 'red', pch = 20);<br/><em class="ma">#  dev.off();</em><br/>}<br/><br/>track &lt;- matrix(nrow = to - from + 1, ncol = 2);<br/>back &lt;- matrixFromFrame(100);<br/>lapply(from:to, function(x) processFrame(x, back));</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mm"><img src="../Images/61f39f701ca4be96d403d22c5ad9e66d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IeIteQRdV1FGo5S8tJsKGA.jpeg"/></div></div></figure><p id="7552" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码你可以在这里找到:<a class="ae lb" href="https://www.linkedin.com/pulse/object-detection-counting-andy-bosyi/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> R源代码</strong> </a></p><h2 id="90be" class="mg mh iq bd mr ms mt dn mu mv mw dp mx ko my mz na ks nb nc nd kw ne nf ng nh bi translated">附言（同postscript）；警官（police sergeant）</h2><p id="82e9" class="pw-post-body-paragraph kf kg iq kh b ki ni jr kk kl nj ju kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated">对于个人问题，请在Linkedin或脸书上联系我，有时我会在那里发布关于人工智能的简短新闻和想法。<br/>如果有AI方面的需求，或者需要组建数据科学咨询团队，联系我</p></div></div>    
</body>
</html>