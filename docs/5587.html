<html>
<head>
<title>Working with Datetime Index in pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 pandas 中使用日期时间索引</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tips-on-working-with-datetime-index-in-pandas-2bcedf956d70?source=collection_archive---------5-----------------------#2018-10-28">https://towardsdatascience.com/tips-on-working-with-datetime-index-in-pandas-2bcedf956d70?source=collection_archive---------5-----------------------#2018-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/0e7e5fb525879d6d6b90cd36eeec47da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MsJuFrKtzlxjfrKweHM7gw.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by Jordan Benton from Pexels</figcaption></figure><div class=""/><div class=""><h2 id="3c72" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">对一个人有用的东西可能对另一个人有用</h2></div><p id="3d3e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">正如您从标题中所理解的，它并不是 Python 中时间序列或日期时间数据类型的完整指南。因此，如果你期望从 A 到 Z 得到深入的解释，那就错了。说真的。关于这个话题有一篇精彩的<a class="ae lq" href="https://jakevdp.github.io/PythonDataScienceHandbook/03.11-working-with-time-series.html" rel="noopener ugc nofollow" target="_blank">文章</a>，解释得很好，很详细，也很直白。不要在这个上浪费你的时间。</p><p id="378f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">对于已经读到这一部分的人，我会告诉他们，你肯定会在这里找到有用的东西。再说一次，说真的。我找到了我关于时间序列的笔记，并决定把它整理成一篇小文章，里面有一些通用的提示，我想这些提示在你处理日期的 80%到 90%的情况下都是适用的。所以很值得分享不是吗？</p><p id="b926" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我有一个数据集，其中包含自 2016 年以来马德里每小时的空气污染物测量值，因此我将以它为例。</p><h1 id="56b5" class="lr ls jf bd lt lu lv lw lx ly lz ma mb kl mc km md ko me kp mf kr mg ks mh mi bi translated">导入数据</h1><p id="472f" class="pw-post-body-paragraph ku kv jf kw b kx mj kg kz la mk kj lc ld ml lf lg lh mm lj lk ll mn ln lo lp ij bi translated">默认情况下，当使用<code class="fe mo mp mq mr b">read_csv()</code>导入 csv 文件时，pandas 将使用第一列作为索引，因此如果您的日期时间列不是第一列，您将需要显式指定它<code class="fe mo mp mq mr b">index_col='date'.</code></p><p id="789f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">pandas 的美妙之处在于它可以在导入过程中预处理您的 datetime 数据。通过指定<code class="fe mo mp mq mr b">parse_dates=True</code>，pandas 将尝试解析索引，如果我们传递整数或名称的列表，例如 if [1，2，3]–它将尝试将第 1、2、3 列分别解析为单独的日期列，列表列表，例如 if [[1，3]]–将第 1 和第 3 列合并，解析为单个日期列，dict，例如{'foo' : [1，3]}–将第 1、3 列解析为日期，并调用结果“foo”。如果您使用其他方法导入数据，您可以在其后使用<code class="fe mo mp mq mr b">pd.to_datetime</code>。</p><p id="559e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我使用以下代码导入了我的数据:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="e4a7" class="na ls jf mr b gy nb nc l nd ne">import pandas as pd<br/>import glob</span><span id="8bd6" class="na ls jf mr b gy nf nc l nd ne">pattern = 'data/madrid*.csv'<br/>csv_files = glob.glob(pattern)<br/>frames = []</span><span id="070c" class="na ls jf mr b gy nf nc l nd ne">for csv in csv_files: <br/>    df = pd.read_csv(csv, index_col='date', parse_dates=True)     frames.append(df)<br/>df = pd.concat(frames)<br/>df.head()</span><span id="e000" class="na ls jf mr b gy nf nc l nd ne">Out[4]: <br/>                     BEN  CH4   CO  EBE  NMHC     NO   NO_2  NOx  <br/>date                                                                          <br/>2016-11-01 01:00:00  NaN  NaN  0.7  NaN   NaN  153.0   77.0  NaN  <br/>2016-11-01 01:00:00  3.1  NaN  1.1  2.0  0.53  260.0  144.0  NaN  <br/>2016-11-01 01:00:00  5.9  NaN  NaN  7.5   NaN  297.0  139.0  NaN  <br/>2016-11-01 01:00:00  NaN  NaN  1.0  NaN   NaN  154.0  113.0  NaN   <br/>2016-11-01 01:00:00  NaN  NaN  NaN  NaN   NaN  275.0  127.0  NaN</span></pre><p id="7ef3" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这些数据是从 24 个不同的站点收集的，涉及 14 种不同的污染物。我们不打算分析这些数据，为了简单一点，我们将只选择一个站，两种污染物，并删除所有 NaN 值(危险！请不要在不了解后果的情况下在家里重复)。</p><figure class="ms mt mu mv gt is gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/addfc0656574a4bad7e14ce10fe5757e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*S1HH5F8PqWWcId9sb0L8og.jpeg"/></div></figure><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="7795" class="na ls jf mr b gy nb nc l nd ne">df_time = df[['O_3', 'PM10']][df['station'] == 28079008].dropna() df_time.head() </span><span id="28cc" class="na ls jf mr b gy nf nc l nd ne">Out[9]: <br/>                     O_3  PM10<br/>date                          <br/>2016-11-01 01:00:00  4.0  46.0<br/>2016-11-01 02:00:00  4.0  37.0<br/>2016-11-01 03:00:00  4.0  31.0<br/>2016-11-01 04:00:00  5.0  31.0<br/>2016-11-01 05:00:00  6.0  27.0</span></pre><p id="d962" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">现在，当我们准备好数据后，我们就可以玩日期时间索引了。</p><h1 id="64f8" class="lr ls jf bd lt lu lv lw lx ly lz ma mb kl mc km md ko me kp mf kr mg ks mh mi bi translated">选择值</h1><p id="d3f7" class="pw-post-body-paragraph ku kv jf kw b kx mj kg kz la mk kj lc ld ml lf lg lh mm lj lk ll mn ln lo lp ij bi translated">尽管默认的 pandas datetime 格式是 ISO8601(“yyyy-mm-DD hh:mm:ss”)，但当使用部分字符串索引选择数据时，它可以理解许多其他不同的格式。例如:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="fb8f" class="na ls jf mr b gy nb nc l nd ne"><strong class="mr jg">df_time.loc['2016-11-01'].head()<br/></strong>Out[17]: <br/>                     O_3  PM10<br/>date                          <br/>2016-11-01 01:00:00  4.0  46.0<br/>2016-11-01 02:00:00  4.0  37.0<br/>2016-11-01 03:00:00  4.0  31.0<br/>2016-11-01 04:00:00  5.0  31.0<br/>2016-11-01 05:00:00  6.0  27.0</span><span id="7ff3" class="na ls jf mr b gy nf nc l nd ne"><strong class="mr jg">df_time.loc['November 1, 2016'].head()<br/></strong>Out[18]: <br/>                     O_3  PM10<br/>date                          <br/>2016-11-01 01:00:00  4.0  46.0<br/>2016-11-01 02:00:00  4.0  37.0<br/>2016-11-01 03:00:00  4.0  31.0<br/>2016-11-01 04:00:00  5.0  31.0<br/>2016-11-01 05:00:00  6.0  27.0</span><span id="9046" class="na ls jf mr b gy nf nc l nd ne"><strong class="mr jg">df_time.loc['2016-Nov-1'].head()<br/></strong>Out[19]: <br/>                     O_3  PM10<br/>date                          <br/>2016-11-01 01:00:00  4.0  46.0<br/>2016-11-01 02:00:00  4.0  37.0<br/>2016-11-01 03:00:00  4.0  31.0<br/>2016-11-01 04:00:00  5.0  31.0</span></pre><p id="ba73" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">都产生相同的输出。所以我们可以自由使用任何对我们来说更舒适的东西。我们还可以选择整个月的数据:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="620a" class="na ls jf mr b gy nb nc l nd ne"><strong class="mr jg">df_time.loc['2016-11'].head()<br/></strong>Out[20]: <br/>                     O_3  PM10<br/>date                          <br/>2016-11-01 01:00:00  4.0  46.0<br/>2016-11-01 02:00:00  4.0  37.0<br/>2016-11-01 03:00:00  4.0  31.0<br/>2016-11-01 04:00:00  5.0  31.0<br/>2016-11-01 05:00:00  6.0  27.0</span><span id="1616" class="na ls jf mr b gy nf nc l nd ne"><strong class="mr jg">df_time.loc['2016-11'].count()<br/></strong>Out[24]: <br/>O_3     715<br/>PM10    715<br/>dtype: int64</span></pre><p id="1e4e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果我们想选择整年，情况也是如此:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="9127" class="na ls jf mr b gy nb nc l nd ne"><strong class="mr jg">df_time.loc['2016'].head()<br/></strong>Out[31]: <br/>                     O_3  PM10<br/>date                          <br/>2016-11-01 01:00:00  4.0  46.0<br/>2016-11-01 02:00:00  4.0  37.0<br/>2016-11-01 03:00:00  4.0  31.0<br/>2016-11-01 04:00:00  5.0  31.0<br/>2016-11-01 05:00:00  6.0  27.0</span><span id="d715" class="na ls jf mr b gy nf nc l nd ne"><strong class="mr jg">df_time.loc['2016'].count()<br/></strong>Out[32]: <br/>O_3     8720<br/>PM10    8720<br/>dtype: int64</span></pre><p id="95ae" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果我们想对数据进行切片并找到某个特定时间段的记录，我们继续使用<code class="fe mo mp mq mr b">loc</code>访问器，所有规则与常规索引相同:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="c600" class="na ls jf mr b gy nb nc l nd ne"><strong class="mr jg">df_time.loc['2017-11-02 23:00' : '2017-12-01'].head()<br/></strong>Out[34]: <br/>                     O_3  PM10<br/>date                          <br/>2017-11-02 23:00:00  5.0  30.0<br/>2017-11-03 00:00:00  5.0  25.0<br/>2017-11-03 01:00:00  5.0  12.0<br/>2017-11-03 02:00:00  6.0   8.0<br/>2017-11-03 03:00:00  7.0  14.0</span><span id="2ca0" class="na ls jf mr b gy nf nc l nd ne"><strong class="mr jg">df_time.loc['2017-11-02 23:00' : '2017-12-01'].count()<br/></strong>Out[35]: <br/>O_3     690<br/>PM10    690<br/>dtype: int64</span></pre><h1 id="ca0c" class="lr ls jf bd lt lu lv lw lx ly lz ma mb kl mc km md ko me kp mf kr mg ks mh mi bi translated">重采样</h1><p id="317f" class="pw-post-body-paragraph ku kv jf kw b kx mj kg kz la mk kj lc ld ml lf lg lh mm lj lk ll mn ln lo lp ij bi translated">Pandas 具有简单、强大且高效的功能，用于在频率转换期间执行重采样操作(例如，将秒数据转换为 5 分钟数据)。这在金融应用中极为常见，但不限于此。</p><p id="1a68" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><code class="fe mo mp mq mr b">resample()</code>是一个基于时间的 groupby，其后是对其每个组的归约方法。</p><p id="a8b7" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><code class="fe mo mp mq mr b">resample</code>功能非常灵活，允许我们指定许多不同的参数来控制频率转换和重采样操作。<code class="fe mo mp mq mr b">sum</code>、<code class="fe mo mp mq mr b">mean</code>、<code class="fe mo mp mq mr b">std</code>、<code class="fe mo mp mq mr b">sem</code>、<code class="fe mo mp mq mr b">max</code>、<code class="fe mo mp mq mr b">min</code>、<code class="fe mo mp mq mr b">median</code>、<code class="fe mo mp mq mr b">first</code>、<code class="fe mo mp mq mr b">last</code>、<code class="fe mo mp mq mr b">ohlc</code>、<br/>是<code class="fe mo mp mq mr b">resample()</code>返回对象的方法</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="3788" class="na ls jf mr b gy nb nc l nd ne"># Converting hourly data into monthly data<br/><strong class="mr jg">df_time.resample('M').mean().head()<br/></strong>Out[46]: <br/>                  O_3       PM10<br/>date                            <br/>2016-01-31  21.871622  19.990541<br/>2016-02-29  32.241679  25.853835<br/>2016-03-31  44.234014  16.952381<br/>2016-04-30  46.845938  12.189076<br/>2016-05-31  53.136671  14.671177</span></pre><p id="d398" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">对于向上采样，我们可以指定一种向上采样的方法，以便在创建的间隙上进行插值:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="8364" class="na ls jf mr b gy nb nc l nd ne"># Converting hourly data into 10-minutely data<br/><strong class="mr jg">df_time.resample('10Min').mean().head()<br/></strong>Out[47]: <br/>                     O_3  PM10<br/>date                          <br/>2016-01-01 01:00:00  8.0  17.0<br/>2016-01-01 01:10:00  NaN   NaN<br/>2016-01-01 01:20:00  NaN   NaN<br/>2016-01-01 01:30:00  NaN   NaN<br/>2016-01-01 01:40:00  NaN   NaN</span><span id="54d4" class="na ls jf mr b gy nf nc l nd ne"><strong class="mr jg">df_time.resample('10Min').mean().ffill().head()<br/></strong>Out[48]: <br/>                     O_3  PM10<br/>date                          <br/>2016-01-01 01:00:00  8.0  17.0<br/>2016-01-01 01:10:00  8.0  17.0<br/>2016-01-01 01:20:00  8.0  17.0<br/>2016-01-01 01:30:00  8.0  17.0<br/>2016-01-01 01:40:00  8.0  17.0</span></pre><p id="be72" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们可以使用以下方法来填充 NaN 值:<em class="nh">'填充'，'回填'，' ffill '，' bfill '，'最近的'。</em>在<a class="ae lq" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.core.resample.Resampler.fillna.html" rel="noopener ugc nofollow" target="_blank">文档</a>中可以找到更多相关细节。或者我们可以通过以下方法使用插值来实现:<em class="nh">'线性'，'时间'，'索引'，'值'，'最近'，'零'，'线性'，'二次'，'三次'，'重心'，' krogh '，'多项式'，'样条'，'分段 _ 多项式'，' from _ 导数'，' pchip '，' akima '。</em>同样，关于这一点的更深入的解释可以在<a class="ae lq" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.core.resample.Resampler.interpolate.html#pandas.core.resample.Resampler.interpolate" rel="noopener ugc nofollow" target="_blank">熊猫文档中找到。</a></p><p id="8ad9" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">和重采样频率:</p><figure class="ms mt mu mv gt is gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/0e3c000a8736d95f28e7ddfca68a76a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*tbblxq-kmKUQZ9bBPjjCTQ.png"/></div></figure><h1 id="5b8b" class="lr ls jf bd lt lu lv lw lx ly lz ma mb kl mc km md ko me kp mf kr mg ks mh mi bi translated">形象化</h1><p id="77fd" class="pw-post-body-paragraph ku kv jf kw b kx mj kg kz la mk kj lc ld ml lf lg lh mm lj lk ll mn ln lo lp ij bi translated">Datetime Index 的另一个令人惊叹的特性是绘图简单，因为 matplotlib 会自动将其视为 x 轴，所以我们不需要显式指定任何内容。</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="4c1f" class="na ls jf mr b gy nb nc l nd ne">import seaborn as sns<br/>sns.set()<br/>df_plot = df_time.resample('M').mean()<br/><strong class="mr jg">plt.plot(df_plot)<br/></strong>plt.title('Air polution by O3 and PM10')<br/>plt.ylabel('micrograms per cubic meter (mg/m3)')<br/>plt.xticks(rotation=45)<br/>plt.show()</span></pre><figure class="ms mt mu mv gt is gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/08adbdd49d2d53b60844f6392de996b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*ybEIyTPXiDKtIiHeRANl3w.png"/></div></figure><p id="995e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">正如在开始时所承诺的——一些小技巧，在大多数情况下，在处理日期时间数据时会有所帮助。对我来说——又一个将思想转化为知识的更新者和组织者。都赢了。有人会觉得它有用，有人可能不会(我在第一段就警告过:D)，所以实际上我希望每个阅读这篇文章的人都会觉得它有用。</p><p id="6602" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这是知识最令人兴奋的特点——当你分享它时，你不会失去任何东西，你只会有所收获。要写一篇文章，需要一些研究，一些验证，一些学习——基本上你最终会获得更多的知识。</p><p id="08f0" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">知识只是一种工具。应用与否是你的责任。归根结底，你知道多少并不重要，重要的是你如何运用这些知识。但那已经是另一个故事了…</p><p id="bd9d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">感谢您的阅读，度过不可思议的一周，学习，传播知识，明智地使用它，并将其用于行善🙂</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="8b43" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><em class="nh">最初发表于</em><a class="ae lq" href="http://sergilehkyi.com/tips-on-working-with-datetime-index-in-pandas/" rel="noopener ugc nofollow" target="_blank"><em class="nh">【sergilehkyi.com】</em></a><em class="nh">。</em></p></div></div>    
</body>
</html>