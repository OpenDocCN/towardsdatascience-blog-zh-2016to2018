<html>
<head>
<title>Befriending Tensors with tsalib library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与 tsalib 图书馆的 Tensors 成为朋友</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introducing-tensor-shape-annotation-library-tsalib-963b5b13c35b?source=collection_archive---------7-----------------------#2018-10-28">https://towardsdatascience.com/introducing-tensor-shape-annotation-library-tsalib-963b5b13c35b?source=collection_archive---------7-----------------------#2018-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4df12f312bc23185577950283c999f61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nfjz4kgki5PvKmkzw1E1CQ.png"/></div></div></figure><p id="cdee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw"> tldr: </em> <code class="fe kx ky kz la b"><a class="ae lb" href="https://github.com/ofnote/tsalib" rel="noopener ugc nofollow" target="_blank">tsalib</a></code>是为张量定义<em class="kw"> </em>维度名称和命名形状表达式的库。允许变量上的形状标签、形状断言和使用名称的直观形状转换。使用任意张量库。显式形状注释加速了深度学习程序的调试，并提高了开发人员的生产率和代码可读性。</p><h2 id="8451" class="lc ld iq bd le lf lg dn lh li lj dp lk kj ll lm ln kn lo lp lq kr lr ls lt lu bi translated"><strong class="ak">源代码可在 github </strong> <a class="ae lb" href="https://github.com/ofnote/tsalib" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">资源库</strong> </a> <strong class="ak">获得。</strong></h2><p id="5daf" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><strong class="ka ir">更新(2019 年 11 月):</strong>检查我们的库<a class="ae lb" href="https://github.com/ofnote/tsanley" rel="noopener ugc nofollow" target="_blank"> tsanley </a>到<strong class="ka ir">注释</strong>和<strong class="ka ir">动态检查</strong>命名的形状。使用 tsanley，您可以避免编写显式的形状断言，并自动注释您想要重用的第三方深度学习代码。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><p id="e076" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编写操纵张量的深度学习程序(例如，使用<code class="fe kx ky kz la b">numpy</code>、<code class="fe kx ky kz la b">pytorch</code>、<code class="fe kx ky kz la b">tensorflow</code>、<code class="fe kx ky kz la b">keras</code>..)要求你仔细记录张量变量的形状。当你编写更复杂的程序时，在你的头脑中思考这些图形变得越来越困难。例如，当创建一个新的<code class="fe kx ky kz la b">RNN</code>细胞或设计一种新的<code class="fe kx ky kz la b">attention</code>机制或试图做一个非平凡的预训练架构的手术(<code class="fe kx ky kz la b">resnet101</code>，<code class="fe kx ky kz la b">densenet</code>)。不幸的是，没有在代码中跟踪形状的原则性方法——大多数开发人员求助于编写嵌入代码中的特别注释来跟踪张量形状。</p><p id="c0de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，考虑一下最近流行的来自 Google 的<strong class="ka ir"> BERT </strong>模型实现的<a class="ae lb" href="https://github.com/google-research/bert/blob/a21d4848ec33eca7d53dd68710f04c4a4cc4be50/modeling.py#L664" rel="noopener ugc nofollow" target="_blank">片段</a>。注意每条语句是如何被其<code class="fe kx ky kz la b">input</code>和<code class="fe kx ky kz la b">output</code>形状标记的。没有这种明确的形状跟踪，实际上不可能编写和调试复杂的张量程序。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/979c67655bf39cdfe8e8cd15c47b1082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DKBOXKIuL8ihah6U_w9OEA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Code from BERT <a class="ae lb" href="https://github.com/google-research/bert/blob/a21d4848ec33eca7d53dd68710f04c4a4cc4be50/modeling.py#L664" rel="noopener ugc nofollow" target="_blank">implementation</a> from Google.</figcaption></figure><p id="75c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，考虑 tensorflow <a class="ae lb" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/examples/tutorials/layers/cnn_mnist.py" rel="noopener ugc nofollow" target="_blank">教程</a>中的这个 CNN 模型。注意每个语句是如何用其<code class="fe kx ky kz la b">input </code>和<code class="fe kx ky kz la b">output</code>形状来标记的，以帮助开发人员。因为形状可能是动态的，所以这些注释同时包含了<em class="kw">参数</em> (batch_size)和<em class="kw">常量</em> (28)。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/408a0908f8e647e8fd477de6341bf3a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OV97ai49OSlfrRaV2rujSQ.png"/></div></div></figure><p id="6bca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着网络架构变得复杂，这些注释对于保持开发人员的理智以及其他人理解和扩展代码变得非常重要。不幸的是，没有对这些注释的本地支持，工程师们继续编写<em class="kw">特别注释</em>来填补空白。事实上，从业者一直在向 T21 寻求更好的支持。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h2 id="0452" class="lc ld iq bd le lf lg dn lh li lj dp lk kj ll lm ln kn lo lp lq kr lr ls lt lu bi translated">张量形状注释</h2><p id="6ae6" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">美国运输安全管理局图书馆 ( <code class="fe kx ky kz la b">tsalib</code>)来帮你了。</p><ul class=""><li id="0cff" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv mw mx my mz bi translated">该库允许您定义自定义维度变量(<em class="kw"> B </em> =Batch，<em class="kw"> C </em> =Channels，…)以及它们的张量形状表达式。</li><li id="3597" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated"><code class="fe kx ky kz la b">tsalib</code>不触及代码所依赖的张量库的内部——适用于任何张量库(<code class="fe kx ky kz la b">numpy</code>、<code class="fe kx ky kz la b">tensorflow,</code>、<code class="fe kx ky kz la b">pytorch</code>等等)。</li><li id="2a94" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">直接在代码中用其形状表达式标注张量变量，作为<em class="kw">一级</em>类型标注。</li><li id="96d3" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">您可以使用 TSA 直接构建(清晰的)形状变换(<code class="fe kx ky kz la b">reshape</code>、<code class="fe kx ky kz la b">permute</code>、<code class="fe kx ky kz la b">axis</code>索引)和简洁的矩阵/张量运算——稍后将详细介绍。</li></ul><p id="1d58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里是使用 TSAs 的简单张量程序(代码在这里<a class="ae lb" href="https://github.com/ofnote/tsalib/blob/master/tests/test.py" rel="noopener ugc nofollow" target="_blank">可用</a>)。注意变量<code class="fe kx ky kz la b">a</code>、<code class="fe kx ky kz la b">b</code>和<code class="fe kx ky kz la b">c</code>是如何用它们的形状标注的。<strong class="ka ir">形状标注</strong>，例如<code class="fe kx ky kz la b">(2,B,D)</code>既可以包含常量，也可以包含<strong class="ka ir">命名的尺寸变量</strong> ( <code class="fe kx ky kz la b">B</code>、<code class="fe kx ky kz la b">D</code>)。请注意代码是如何立即变得更具可读性的——您可以简单地浏览一下形状注释，发现由<code class="fe kx ky kz la b">numpy</code>函数执行的形状转换(即使您不熟悉 API)。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/06018da61f98d28ff5ff4dc9528339e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eSvKoP8R4YerWKLOpcdHQQ.png"/></div></div></figure><h2 id="aff6" class="lc ld iq bd le lf lg dn lh li lj dp lk kj ll lm ln kn lo lp lq kr lr ls lt lu bi translated">尺寸变量，形状表达式</h2><p id="7eff" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">该库背后的核心思想是<strong class="ka ir">维度变量</strong>及其表达式。</p><ul class=""><li id="5b09" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv mw mx my mz bi translated"><code class="fe kx ky kz la b"><a class="ae lb" href="https://github.com/ofnote/tsalib" rel="noopener ugc nofollow" target="_blank">tsalib</a></code>允许你为你的架构声明<em class="kw">自定义</em>维度变量，在形状注释中使用它们，并像普通 Python 变量一样对它们执行算术运算。</li><li id="1469" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">声明包括可选的大小默认值和简写名称。用 dim 变量(<code class="fe kx ky kz la b">B</code>、<code class="fe kx ky kz la b">D</code>)替换您的配置参数(<code class="fe kx ky kz la b">batch_size</code>、<code class="fe kx ky kz la b">embed_dim</code>)。在代码的所有部分只使用 dim 变量。</li></ul><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/313b8b2d8168dbd894b71186abe93365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gVDyebNpsWJ5t5YD3SY3yA.png"/></div></div></figure><p id="8971" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">TSA 在很多方面都很有用。</p><ul class=""><li id="e3e0" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv mw mx my mz bi translated">当编写新的转换或修改现有模块时，它们帮助我们快速地<em class="kw">交叉检查</em>和<em class="kw">调试</em>变量形状。</li><li id="c161" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">TSA 作为有用的文档来指导其他人理解或扩展你的模块。</li><li id="3770" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">周围有明确的形状是有益的，原因有几个(见下文)。</li><li id="692c" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">TSA 不会以任何方式影响程序的性能或正确性。您可以根据需要或多或少地添加注释。</li></ul><h2 id="c0c1" class="lc ld iq bd le lf lg dn lh li lj dp lk kj ll lm ln kn lo lp lq kr lr ls lt lu bi translated">示例:带 TSAs 的 Resnet</h2><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/4bb7a3fe6026c9f43a9bfeb900069f74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Nq73Af9-LkXJu4fA-9npA.png"/></div></div></figure><p id="51c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个更复杂的例子，一个来自<code class="fe kx ky kz la b">pytorch</code> <code class="fe kx ky kz la b">torchvision</code>库的<code class="fe kx ky kz la b">resnet</code>模块。这个模块是多个<code class="fe kx ky kz la b">resnet </code>实现的基础:<code class="fe kx ky kz la b">resnet{18,34,50,101,152}</code>。现在，通过查看<code class="fe kx ky kz la b">__init__</code>和<code class="fe kx ky kz la b">_make_layer</code>模块很难获得对架构的任何洞察，即使你直觉地<em class="kw">非常了解</em>架构。因此，你也不能理解<code class="fe kx ky kz la b">forward</code>函数。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/3ea601675dfc4d9971219e50f16445bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KDtB1NBQVXWqh8kHvST_ow.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Resnet Implementation (Pytorch)</figcaption></figure><p id="00e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们看看带注释的<code class="fe kx ky kz la b">forward</code>函数。无需了解各组件层的细节，TSA 允许您发现模块的预期输入(图像)的形状<code class="fe kx ky kz la b">x</code>以及它如何被每一层转换。如果您正在重用该模块，例如在<code class="fe kx ky kz la b">SSD</code>中用于对象检测，或在<code class="fe kx ky kz la b">U-Net</code>中用于分割，您可以一目了然地读出所有中间层的形状。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/99126cda912b536b6caecbc8f72286c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G7utTb4_7cAj8E5EoY9PCw.png"/></div></div></figure><p id="d3a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意在命名维度上编写算术表达式的能力是多么有帮助。配置变量(<code class="fe kx ky kz la b">num_classes</code>)可以直接在形状中使用。同样，很明显，架构是通过块扩展变量<code class="fe kx ky kz la b">Ex </code>来参数化的(在较小的 resnetss 中为 1，在较大的 resnet 中为 4)。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><p id="6400" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">基于注意力的架构</strong>，例如 Transformer，也深受不透明问题的困扰。参见<a class="ae lb" href="https://github.com/ofnote/tsalib/blob/master/examples/openai_transformer.py" rel="noopener ugc nofollow" target="_blank">TSA lib/examples/open ai _ transformer . py</a>(注释从 AllenNLP 的<a class="ae lb" href="https://github.com/allenai/allennlp/blob/master/allennlp/modules/openai_transformer.py" rel="noopener ugc nofollow" target="_blank">实现</a>开始)了解 TSA 如何显著影响代码的可读性。同样，通过浏览前进模块，我们可以快速了解架构。解剖一个多头注意力架构现在是小菜一碟！</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/ac588d782036fbcb127357fa885228a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*AO6mjwJWINNZOkB9_VTIGg.jpeg"/></div></figure></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="4548" class="nl ld iq bd le nm nn no lh np nq nr lk ns nt nu ln nv nw nx lq ny nz oa lt ob bi translated">形状变换，速记符号</h1><p id="4508" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">一旦代码中有了维度变量，我们就可以利用它们来进一步提高代码的生产率和清晰度。我们可以使用维度变量直接指定视图和置换转换。例如，这就是从<a class="ae lb" href="https://github.com/allenai/allennlp" rel="noopener ugc nofollow" target="_blank"> AllenNLP </a>库中在原始<code class="fe kx ky kz la b">openai_transformer.py</code>中实现<code class="fe kx ky kz la b">merge_heads</code>的方式。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="855c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以使用<code class="fe kx ky kz la b">tsalib</code>简洁地编写它。所有形状都是显式的，不再需要代码操作。通过使用它们的速记<code class="fe kx ky kz la b">string</code>表示代替元组，形状注释可以变得更加简洁，例如用<code class="fe kx ky kz la b">'bcd'</code>代替<code class="fe kx ky kz la b">(B,C,D)</code>。<code class="fe kx ky kz la b">tsalib</code>允许使用快捷键来指定转换。在这里阅读更多<a class="ae lb" href="https://github.com/ofnote/tsalib/blob/master/README.md" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="2aa7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在所有张量库(numpy，pytorch，tensorflow)中拥有类似 TSA 的原生支持将对从业者极为有益。然而，这可能涉及到<a class="ae lb" href="https://www.python.org/dev/peps/pep-0472/" rel="noopener ugc nofollow" target="_blank">严重的</a> <a class="ae lb" href="https://docs.google.com/document/d/1vpMse4c6DrWH5rq2tQSx3qwP_m_0lyn-Ij4WHqQqRHY/edit#heading=h.rkj7d39awayl" rel="noopener ugc nofollow" target="_blank">重新设计</a>。相比之下，TSA 是独立于库的、轻量级的和即插即用的。你可以从今天开始在你的深度学习项目中使用它们！</p><h2 id="f74f" class="lc ld iq bd le lf lg dn lh li lj dp lk kj ll lm ln kn lo lp lq kr lr ls lt lu bi translated">一定要给<code class="fe kx ky kz la b"><a class="ae lb" href="https://github.com/ofnote/tsalib" rel="noopener ugc nofollow" target="_blank">tsalib</a></code>一次机会，并给我发送反馈——通过<a class="ae lb" href="https://twitter.com/ekshakhs" rel="noopener ugc nofollow" target="_blank"> twitter </a>联系我，或者直接给我发<a class="ae lb" href="mailto:nishantsinha@acm.org" rel="noopener ugc nofollow" target="_blank">电子邮件。</a></h2></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="b731" class="nl ld iq bd le nm nn no lh np nq nr lk ns nt nu ln nv nw nx lq ny nz oa lt ob bi translated"><strong class="ak">库内部</strong></h1><p id="3057" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">类型注释(或类型提示)是 Python 3 中一个受支持的可选特性。随着 Python 3 的改进和被广泛采用，对注释和类型检查的支持也在改进。例如，<a class="ae lb" href="https://github.com/allenai/allennlp/tree/master/allennlp" rel="noopener ugc nofollow" target="_blank"> AllenNLP </a>的人在他们的代码中使用类型和形状注释，并且<a class="ae lb" href="https://github.com/allenai/writing-code-for-nlp-research-emnlp2018/blob/master/writing_code_for_nlp_research.pdf" rel="noopener ugc nofollow" target="_blank">推荐</a>作为最佳实践。</p><p id="a6db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">tsalib</code>内部使用一个奇妙的符号表达式库<code class="fe kx ky kz la b"><a class="ae lb" href="https://www.sympy.org/" rel="noopener ugc nofollow" target="_blank">sympy</a></code>来构建和转换表达式。<code class="fe kx ky kz la b">sympy</code>是它唯一的依赖。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><p id="bab9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">关于我:</strong>我是一名独立的计算机科学研究员、工程师和演讲者，喜欢提炼复杂的技术并将其转化为可消费的产品。我在学术界、工业界和初创公司都工作过。我帮助公司理解和应对复杂、不断发展的人工智能空间，并构建基于深度学习的解决方案，以最大化投资回报。如果你喜欢这篇文章，请<em class="kw">鼓掌</em>并发表你的评论。你可以关注我，在这里阅读我的其他文章<a class="ae lb" href="https://medium.com/@ekshakhs" rel="noopener">，在</a><a class="ae lb" href="https://in.linkedin.com/in/nishant-sinha-a610311" rel="noopener ugc nofollow" target="_blank"> linkedin </a>上找到我，或者<a class="ae lb" href="mailto:nishant@offnote.co" rel="noopener ugc nofollow" target="_blank">直接发邮件给我</a>。</p></div></div>    
</body>
</html>