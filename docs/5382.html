<html>
<head>
<title>Anchor Boxes — The key to quality object detection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">锚盒——质量目标检测的关键</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/anchor-boxes-the-key-to-quality-object-detection-ddf9d612d4f9?source=collection_archive---------0-----------------------#2018-10-15">https://towardsdatascience.com/anchor-boxes-the-key-to-quality-object-detection-ddf9d612d4f9?source=collection_archive---------0-----------------------#2018-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8f71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在学习用于对象检测的卷积神经网络时，最难理解的概念之一是锚盒的概念。它也是可以优化以提高数据集性能的最重要的参数之一。事实上，如果锚盒没有正确调整，你的神经网络甚至永远不会知道某些小的、大的或不规则的对象的存在，也永远不会有机会检测到它们。幸运的是，你可以采取一些简单的步骤来确保你不会落入这个陷阱。</p><h1 id="2c2c" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">什么是锚盒？</h1><p id="68d8" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">当你使用像 YOLO 或 SDD 这样的神经网络来预测一张图片中的多个对象时，网络实际上正在进行成千上万次预测，并且只显示它确定为对象的那些。多个预测以下列格式输出:</p><p id="afd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">预测一:(X，Y，高度，宽度)，类<br/> …。<br/>预测~8 万:(X，Y，高度，宽度)，类</p><p id="9936" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中(X，Y，高度，宽度)被称为“边界框”，或包围对象的框。这个框和 object 类由人工注释者手动标记。</p><p id="0b28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在一个极其简单的示例中，假设我们有一个模型，它有两个预测，并接收到以下图像:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/667728f65fd66f09a74950000a3eda30.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*wbQKcvM8UW7Wd1iuCsevbg.png"/></div></figure><p id="1c9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要告诉我们的网络它的每一个预测是否正确，以便它能够学习。但是我们告诉神经网络 it 预测<em class="lw">应该是什么呢？预测的类别应该是:</em></p><p id="d172" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">预测一:梨<br/>预测二:苹果</p><p id="b851" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者应该是:</p><p id="3696" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">预测一:苹果<br/>预测二:梨</p><p id="caf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果网络预测:</p><p id="d421" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">预测一:苹果<br/>预测二:苹果</p><p id="f953" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要我们网络的两个预测者能够分辨出他们的工作是预测梨还是苹果。要做到这一点，有几种工具。预测器可以专注于特定大小的对象、具有特定纵横比(高与宽)的对象或图像不同部分的对象。大多数网络使用所有三个标准。在梨/苹果图像的示例中，我们可以让预测 1 针对图像左侧的对象，预测 2 针对图像右侧的对象。那么我们就有了网络应该预测的答案:</p><p id="e8fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">预测一:梨<br/>预测二:苹果</p><h1 id="8443" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">实践中的锚箱</h1><p id="a76b" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">现有技术的物体检测系统目前做以下工作:</p><p id="1283" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.为每个预测器创建数千个“锚框”或“先验框”，代表它专门预测的对象的理想位置、形状和大小。</p><p id="0e19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.对于每个锚定框，计算哪个对象的边界框具有最高的重叠除以非重叠。这被称为并集上的交集或 IOU。</p><p id="049e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.如果最高 IOU 大于 50%，告诉锚盒它应该检测给出最高 IOU 的对象。</p><p id="43e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.否则，如果 IOU 大于 40%，则告诉神经网络真实检测是不明确的，并且不要从该示例中学习。</p><p id="21e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.如果最高 IOU 低于 40%，那么主播框应该预测没有对象。</p><p id="de3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这在实践中效果很好，数以千计的预测器在决定他们的对象类型是否出现在图像中方面做得非常好。看一看 RetinaNet 的<a class="ae lx" href="https://github.com/kuangliu/pytorch-retinanet" rel="noopener ugc nofollow" target="_blank">开源实现，这是一个最先进的对象检测器，我们可以可视化锚框。太多了，无法一次全部形象化，然而这里只是其中的 1%:</a></p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/a643e490523b3fd65cf7e9f99485cf98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*q7bYvvpZWeZ9dBVB4yI8EA.png"/></div></figure><p id="6662" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用默认的锚框配置可以创建<em class="lw">太过</em>专门化的预测器，并且出现在图像中的对象可能无法实现带有<em class="lw">任何</em>锚框的 50% IOU。在这种情况下，神经网络将永远不会知道这些对象的存在，也永远不会学会预测它们。我们可以将锚盒调整得更小，比如这个 1%的样本:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/f517220c24d9ca1d5a7239d6e841a4e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*SLKgjh8ikR0X4PeZlj3w0A.png"/></div></figure><p id="1630" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在 RetinaNet 配置中，最小的锚盒大小为 32x32。这意味着许多比这更小的物体将无法被探测到。这里有一个来自<a class="ae lx" href="http://mmlab.ie.cuhk.edu.hk/projects/WIDERFace/" rel="noopener ugc nofollow" target="_blank"> WiderFace </a>数据集(杨，硕和罗，平和洛伊，陈变和唐，小欧)的例子，其中我们将边界框与它们各自的锚框进行匹配，但有些没有被发现:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lz"><img src="../Images/c9975ef143d06ef3058897e626fe7bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cmca7U_1W7E2EH7sLL03Eg.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Source: <a class="ae lx" href="http://shuoyang1213.me/WIDERFACE/" rel="noopener ugc nofollow" target="_blank">WIDER FACE</a></figcaption></figure><p id="8f7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，只有四个基本事实边界框与任何锚框重叠。神经网络永远不会学会预测其他面孔。我们可以通过改变默认的锚盒配置来解决这个问题。减小最小的锚框尺寸，所有的脸至少与我们的锚框之一对齐，我们的神经网络可以学习检测它们！</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lz"><img src="../Images/5304bfcf0201a08ec4231cabefa303d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rRCpjohTBBDTuVFMaOzfAg.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Source: <a class="ae lx" href="http://shuoyang1213.me/WIDERFACE/" rel="noopener ugc nofollow" target="_blank">WIDER FACE</a></figcaption></figure><h1 id="3991" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">改进锚箱配置</h1><p id="206f" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">一般来说，在开始训练模型之前，您应该问自己以下关于数据集的问题:</p><ol class=""><li id="7f1c" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">我希望能够检测到的最小尺寸的盒子是什么？</li><li id="d182" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">我希望能够检测到的最大尺寸的盒子是什么？</li><li id="5aac" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">这个盒子可以有哪些形状？例如，只要汽车或摄像机不会侧翻，汽车检测器可能有短而宽的锚盒。</li></ol><p id="5f44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以通过实际计算数据集中最极端的大小和长宽比来获得粗略的估计。另一个物体检测器 YOLO v3 使用 K 均值来估计理想的边界框。另一个选择是<a class="ae lx" href="https://arxiv.org/abs/1807.00980" rel="noopener ugc nofollow" target="_blank">学习锚箱配置</a>。</p><p id="9ec4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦你想通了这些问题，你就可以开始设计你的锚盒了。一定要对它们进行测试，方法是对你的基本事实边界框进行编码，然后对它们进行解码，就好像它们是来自你的模型的预测一样。您应该能够恢复地面真实边界框。</p><p id="a4ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，请记住，如果边界框和定位框的中心不同，这将减少 IOU。即使你有小的锚盒，如果锚盒之间的跨度很大，你可能会错过一些地面真相盒。改善这种情况的一种方法是将 IOU 阈值从 50%降至 40%。</p><p id="f88a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lx" href="https://www.liip.ch/en/blog/face-detection-an-overview-and-comparison-of-different-solutions-part1" rel="noopener ugc nofollow" target="_blank">David Pacassi Torrico 最近的一篇文章</a>比较了当前人脸检测的 API 实现，强调了正确指定锚盒的重要性。你可以看到算法做得很好<em class="lw">除了</em>对于小脸。下面是一些 API 根本无法检测到任何人脸的图片，但我们的新模型检测到了许多人脸:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi mw"><img src="../Images/f8727c5d1ab5275177dff87774622822.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4t90PoQlLB7eDqRrZ9gGLA.jpeg"/></div></div></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi mw"><img src="../Images/3e16683cc73d95cf24fecb4c18d102d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MU-7lszARJ50KWm0ikdp2g.jpeg"/></div></div></figure><p id="0165" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你喜欢这篇文章，你可能会喜欢阅读没有锚盒的<a class="ae lx" href="https://medium.com/@andersasac/the-end-of-anchors-improving-object-detection-models-and-annotations-73828c7b39f6" rel="noopener">对象检测<em class="lw">。</em></a></p></div></div>    
</body>
</html>