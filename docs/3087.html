<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://towardsdatascience.com/eager-execution-tensorflow-8042128ca7be?source=collection_archive---------1-----------------------#2018-04-08">https://towardsdatascience.com/eager-execution-tensorflow-8042128ca7be?source=collection_archive---------1-----------------------#2018-04-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/fe9ffc8c6337a5d7321ec84a46c9828a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-_-KC5YpXSR9jzeyX-5hQ.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Source:<a class="ae jd" href="https://blog.oursky.com/2018/02/14/tensorflow-business-applications-ai-hong-kong/" rel="noopener ugc nofollow" target="_blank">https://blog.oursky.com/2018/02/14/tensorflow-business-applications-ai-hong-kong/</a></figcaption></figure><p id="cdc4" class="pw-post-body-paragraph je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ij bi translated">谷歌刚刚在 Tensorflow Dev Summit 2018 上推出了 Tensorflow 的最新版本即 Tensorflow 1.7。您可以在此查看所有变更的列表<a class="ae jd" href="https://github.com/tensorflow/tensorflow/releases/tag/v1.7.0" rel="noopener ugc nofollow" target="_blank">。要观看完整的发展峰会，请访问这里的</a><a class="ae jd" href="https://www.youtube.com/watch?v=gplTc2F5Wvk" rel="noopener ugc nofollow" target="_blank"/>。以下是 TF 1.7 的一些主要亮点:</p><ul class=""><li id="db77" class="kd ke jg jh b ji jj jm jn jq kf ju kg jy kh kc ki kj kk kl bi translated">急切模式正在脱离 contrib，使用急切执行，您可以在没有会话的情况下运行代码。</li><li id="5d55" class="kd ke jg jh b ji km jm kn jq ko ju kp jy kq kc ki kj kk kl bi translated">使用您自己的函数轻松定制梯度计算。</li><li id="fd76" class="kd ke jg jh b ji km jm kn jq ko ju kp jy kq kc ki kj kk kl bi translated">将 sqlite 数据库作为数据集读取的实验支持。</li><li id="4d61" class="kd ke jg jh b ji km jm kn jq ko ju kp jy kq kc ki kj kk kl bi translated">对 TensorRT 的初始支持，以便您可以优化您的模型。</li></ul><p id="e6c7" class="pw-post-body-paragraph je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ij bi translated">其中一个最有趣的特性是 eager_execution，允许用户运行 tensorflow 代码而无需创建图形。不要在太多的理论上浪费时间，让我们用一个简单的程序试试:</p><figure class="ks kt ku kv gt is gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/5793505fb76fb8f0be8706b61a598b51.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*POHsUTexHHDWkmP0rjSP_g.png"/></div></figure><p id="039b" class="pw-post-body-paragraph je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ij bi translated">注意，输出是一个张量，而不是实际的数组本身。要获得这个值，您需要在一个会话中运行它。现在你可以想象，当创建大型神经网络时，你无法通过使用 print 看到操作的输出，这增加了调试的复杂性。要检查操作的输出，您需要运行一个会话并在会话中检查输出:</p><figure class="ks kt ku kv gt is gh gi paragraph-image"><div class="gh gi kw"><img src="../Images/36708469f3380a77eae6bc36b3ad978c.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*DwzUMDt4pmJncf0nDIuDLA.png"/></div></figure><p id="da26" class="pw-post-body-paragraph je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ij bi translated">现在让我们用一行额外的代码再试一次:</p><figure class="ks kt ku kv gt is gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/5741a8dffe00fd2af4fe1388f37d64d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*JZQ83ivGKYAZad04JeGqIg.png"/></div></figure><p id="70f8" class="pw-post-body-paragraph je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ij bi translated">现在你通过使用<em class="ky">TF . enable _ eager _ execution()</em>得到了实际值本身。在 eager_execution 中，操作的输出将是实际值，而不是张量。</p><p id="3f86" class="pw-post-body-paragraph je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ij bi translated">但事情没那么简单。看看下一个例子。下面是一段变量声明:</p><figure class="ks kt ku kv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi kz"><img src="../Images/6545a9ce12a7d08513647f7f0f4bf3f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zJmlb9KWX5e36HwxG1pejw.png"/></div></div></figure><p id="a528" class="pw-post-body-paragraph je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ij bi translated">因此声明一个 Tensorflow 变量会抛出一个错误，指出应该使用<em class="ky">TF . contrib . eager . variable</em>。<em class="ky">这意味着我们不能在已经实现的程序中使用急切执行，并希望它神奇地工作。要使用渴望功能，您需要更改您的代码。</em></p><p id="601d" class="pw-post-body-paragraph je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ij bi translated">其中一个变化是不再使用占位符和变量将数据输入模型，而是使用 tensorflow 数据 API。这通常更快，也更容易管理。下面是一个从展平图像、标签和批量生成数据集的函数。</p><figure class="ks kt ku kv gt is gh gi paragraph-image"><div class="gh gi la"><img src="../Images/48d666a89e9d886ce0d4056ff911349f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*ebqcLALcnqhcDEmiMa8Q4A.png"/></div></figure><p id="e16d" class="pw-post-body-paragraph je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ij bi translated">现在我们来试试这个函数。我们得到下面的结果。我们可以使用迭代器从数据集中访问数据，以获得下一批数据。</p><figure class="ks kt ku kv gt is gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/4f7b165a9bd3b8cea756da8fb2779bdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*iU4fR4-nhqfsa4QN4Xrw6g.png"/></div></figure><p id="1e98" class="pw-post-body-paragraph je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ij bi translated">我们使用梯度磁带，记录所有的操作，以应用梯度后。</p><figure class="ks kt ku kv gt is gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/0e63773b4edea85100bc4f15143a56bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*oY4h7y79V6anN2661zpC7A.png"/></div></figure><p id="aa2f" class="pw-post-body-paragraph je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ij bi translated">grad()函数返回损失对权重和偏差的导数。然后将其传递给<em class="ky">optimizer . apply _ gradients()</em>以完成应用梯度下降的过程。</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><p id="d445" class="pw-post-body-paragraph je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ij bi translated">除了上述变化，几乎一切都保持不变。以下是使用急切执行之前的一些要点:</p><p id="9269" class="pw-post-body-paragraph je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ij bi translated">必须使用<em class="ky">tensor flow . data . dataset</em>初始化数据。(可以使用其他方式，但不推荐使用)</p><p id="bf43" class="pw-post-body-paragraph je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ij bi translated">默认情况下，急切执行在 CPU 上运行，使用 GPU 包括以下代码:<br/> <em class="ky">和 tf.device('/gpu:0') </em></p><p id="5cc8" class="pw-post-body-paragraph je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ij bi translated">急切执行不会创建张量图，要构建图只需删除<em class="ky">TF . enable _ eager _ execution()</em>。</p><p id="789b" class="pw-post-body-paragraph je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ij bi translated">急切执行对 R&amp;D 来说是好的，但是对于生产来说，你应该使用图形执行。</p><p id="3780" class="pw-post-body-paragraph je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ij bi translated">您可以保存通过紧急执行生成的模型，稍后在 graph 或紧急执行中加载该模型。</p><p id="3080" class="pw-post-body-paragraph je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ij bi translated">这里有一个<a class="ae jd" href="https://drive.google.com/file/d/1EEiYUfE63S2IaADXwGT40nH5Ip2iri2-/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">链接</a>指向谷歌合作实验室的工作代码，你可以试着玩玩。</p><p id="26ca" class="pw-post-body-paragraph je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ij bi translated">更新:grad()函数的定义。</p></div></div>    
</body>
</html>