<html>
<head>
<title>Cleaning Financial Time Series data with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 清理金融时间序列数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/cleaning-financial-time-series-data-with-python-f30a3ed580b7?source=collection_archive---------7-----------------------#2018-08-19">https://towardsdatascience.com/cleaning-financial-time-series-data-with-python-f30a3ed580b7?source=collection_archive---------7-----------------------#2018-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/938f8aeee28543c5b0510a328457da43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lpYAnDef4KkR4AHQ"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">“Black and white photo of the street sign for Wall St in New York City” by <a class="ae jd" href="https://unsplash.com/@ricktap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Rick Tap</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="fc2d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设有一家公司，<strong class="kf jh"> <em class="lb"> ABC 金融服务公司</em> </strong>根据公司的经济研究代表其客户做出金融投资决策。这些决策中有许多涉及对金融工具未来价格的投机。ABC 公司利用几个经济指标，但有一个指标在他们的分析中特别重要，那就是<a class="ae jd" href="https://en.wikipedia.org/wiki/University_of_Michigan_Consumer_Sentiment_Index" rel="noopener ugc nofollow" target="_blank">密歇根大学的消费者情绪调查</a> (CSI)。</p><p id="1537" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一的问题是，他们必须等待这些数据的发布(每月发布一次)，这削弱了 ABC 在市场上的一些优势。为了保持竞争力，他们希望能够提前预测这个数字。我建议使用一种机器学习(ML)的形式对尚未发布的最终消费者情绪数据进行时间序列预测。</p><p id="faa3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们将使用在 CSI 之前发布的其他经济数据(作为 ML 算法的特征)。我们将使用这些数据构建最终数据集，为预测算法做好准备。</p><h1 id="bb91" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">多个数据集</h1><p id="df56" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">我们将使用的历史数据集如下所列，可从以下链接下载:</p><ul class=""><li id="edd1" class="mf mg jg kf b kg kh kk kl ko mh ks mi kw mj la mk ml mm mn bi translated">道琼斯指数:来源(雅虎财经)</li><li id="9aee" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">来自美国劳工部的美国失业(失业救济)数据:来源(美联储)</li><li id="1f61" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated"><a class="ae jd" href="https://fred.stlouisfed.org/series/MCOILBRENTEU" rel="noopener ugc nofollow" target="_blank">公开市场原油历史价格</a>:来源(美联储)</li><li id="813e" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated"><a class="ae jd" href="https://fred.stlouisfed.org/series/HOUST#0" rel="noopener ugc nofollow" target="_blank">美国人口普查局新屋开工数</a>:资料来源(美联储)</li><li id="1239" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated"><a class="ae jd" href="https://fred.stlouisfed.org/series/TOTALSA" rel="noopener ugc nofollow" target="_blank">售出车辆总数</a>:资料来源(美联储)</li><li id="2436" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated"><a class="ae jd" href="https://fred.stlouisfed.org/series/RSXFS" rel="noopener ugc nofollow" target="_blank">美国人口普查局的零售销售数据</a>:来源(美联储)</li><li id="1feb" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated"><a class="ae jd" href="https://fred.stlouisfed.org/series/FEDFUNDS%5D" rel="noopener ugc nofollow" target="_blank">联邦利率</a>:来源(美联储)</li><li id="b3de" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">密歇根大学的消费者情绪调查 —数据预测:来源(密歇根大学)</li></ul><h1 id="70a1" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">工具</h1><p id="822c" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">我们将使用 Python 和 Pandas 库来处理我们的数据清理任务。我们将使用 Jupyter Notebook，这是一个开源的 web 应用程序，允许您创建和共享包含实时代码、等式、可视化和叙述性文本的文档。对于数据科学家来说，这是一个非常棒的工具。你可以前往<a class="ae jd" href="http://anaconda.org" rel="noopener ugc nofollow" target="_blank">Anaconda.org</a>下载大多数数据科学库预装的最新版本。</p><p id="cb48" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用 pandas 将上述数据集合并到一个表中，然后进行必要的清理。上述部分数据集已经过季节性调整，以消除可预测的季节性模式的影响。在实际的预测学习/测试中，我们将对两种类型的数据集进行实验。</p><p id="f23f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据清理在很大程度上取决于数据的类型和您试图完成的任务。在我们的例子中，我们组合来自不同来源的数据，并清理产生的数据帧。在图像分类数据中，我们可能需要对图像进行整形和调整大小，并创建标签，而情感分析任务可能需要检查语法错误和关键词提取。</p><h1 id="8181" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">目视检查数据帧</h1><p id="b23d" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">为此，我们需要从 python 库中导入一些内容，如下所示。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="6a72" class="nc ld jg my b gy nd ne l nf ng"><em class="lb"># Import necessary modules</em></span><span id="2634" class="nc ld jg my b gy nh ne l nf ng"><strong class="my jh">import</strong> <strong class="my jh">numpy</strong> <strong class="my jh">as</strong> <strong class="my jh">np</strong><br/><strong class="my jh">import</strong> <strong class="my jh">pandas</strong> <strong class="my jh">as</strong> <strong class="my jh">pd</strong><br/><strong class="my jh">import</strong> <strong class="my jh">matplotlib.pyplot</strong> <strong class="my jh">as</strong> <strong class="my jh">plt</strong><br/><strong class="my jh">import</strong> <strong class="my jh">seaborn</strong> <strong class="my jh">as</strong> <strong class="my jh">sns</strong><br/>%matplotlib inline<br/><strong class="my jh">from</strong> <strong class="my jh">scipy</strong> <strong class="my jh">import</strong> stats<br/><strong class="my jh">from</strong> <strong class="my jh">datetime</strong> <strong class="my jh">import</strong> datetime<br/><strong class="my jh">from</strong> <strong class="my jh">functools</strong> <strong class="my jh">import</strong> reduce<br/><strong class="my jh">import</strong> <strong class="my jh">datetime</strong></span></pre><p id="e3cf" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将数据表导入 Pandas 数据框架。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="bc47" class="nc ld jg my b gy nd ne l nf ng"><em class="lb"># load all the datasets to pandas DataFrames</em></span><span id="dead" class="nc ld jg my b gy nh ne l nf ng">dow     = pd.read_csv('data/Dow Jones Industrial Average DJI.csv')<br/>unemp   = pd.read_csv('data/Civilian Unemployment Rate UNRATE.csv')<br/>oil     = pd.read_csv('data/Crude Oil Prices MCOILBRENTEU.csv')<br/>hstarts = pd.read_csv('data/Housing Starts HOUST.csv')<br/>cars    = pd.read_csv('data/Total Vehicle SalesTOTALSA .csv')<br/>retail  = pd.read_csv('data/Advance Retail Sales_RSXFS.csv')<br/>fedrate = pd.read_csv('data/Federal Interest Rates FEDFUNDS.csv')<br/>umcsi   = pd.read_excel('data/consumer_sent_UMCH_tbmics.xls',header=3)</span></pre><p id="2a4b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">加载完数据后，我们要做的第一件事就是目视检查数据，了解数据的结构、内容，并注意任何异常情况。您将遇到的大多数数据至少有数千行长，所以我喜欢一次检查随机的行块。</p><p id="c67f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<em class="lb"> head() </em>和<em class="lb"> tail() </em>函数分别检查表格的顶部和底部。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="7c0e" class="nc ld jg my b gy nd ne l nf ng"># view the top of the dow jones table</span><span id="318d" class="nc ld jg my b gy nh ne l nf ng">dow.head()</span></pre><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/f79ba619197f905e8d16611f31997d52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*16ZVajQnFAAs_wHM99jiaA.png"/></div></figure><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="e4ee" class="nc ld jg my b gy nd ne l nf ng"># view the top of the umcsi table</span><span id="ea5a" class="nc ld jg my b gy nh ne l nf ng">umcsi.head()</span></pre><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/4e10db7f25662adf0699cb0179c22663.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*D8ZOoD-Jj0bIXdKzl1PrxQ.png"/></div></figure><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="9e03" class="nc ld jg my b gy nd ne l nf ng"># view the bottom of the data table</span><span id="56e3" class="nc ld jg my b gy nh ne l nf ng">umcsi.tail()</span></pre><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/ac612818bce8baa57ec52f93b81747a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*b7ZJzC-gvn0bydC87a4WuA.png"/></div></figure><p id="b42c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以使用一个循环来遍历所有的表，并获取大小。从这一步开始，我们可以开始预测我们需要做的连接的种类，或者决定我们是否有足够的统计数据来开始。记住坏数据比没有数据更糟糕。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="9d7f" class="nc ld jg my b gy nd ne l nf ng"><em class="lb"># get the shape of the different datasets</em><br/><br/>dflist = [dow, unemp, oil, hstarts, cars, retail, fedrate, umcsi]<br/><strong class="my jh">for</strong> i, dfr <strong class="my jh">in</strong> enumerate(dflist):<br/> print(dflist[i].shape)</span></pre><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/c2a74a9c168a107b8bed3ea6bd23bf29.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*xt6JODJei787VXkV8s5PaA.png"/></div></figure><p id="cf9e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们检查数据时，另一个有用的 pandas 工具是<em class="lb"> describe() </em>函数，它给出了数据中所有数字列的一般统计信息的快照。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="793b" class="nc ld jg my b gy nd ne l nf ng"><em class="lb"># we look at the statistical charateristics of the datsets</em><br/><br/><strong class="my jh">for</strong> i, dfr <strong class="my jh">in</strong> enumerate(dflist):<br/>    print(dflist[i].describe())</span></pre><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/4f02dd4573968833fe6fb1d6e95a159b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*8kDV4pf0rVTmkPRtAeZ0Vw.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">The table above contains more columns as indicated by the back slash at the top right</figcaption></figure><p id="2cbb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还想知道我们是否正在处理包含空值的数据，因为如果忽略，这可能会导致坏数据。获取空值的一种方法是使用<em class="lb"> isnull() </em>函数来提取这些信息。我们使用下面的循环来迭代所有的数据表。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="5711" class="nc ld jg my b gy nd ne l nf ng"><em class="lb"># see which datasets have null values</em><br/><br/><strong class="my jh">for</strong> i, dfr <strong class="my jh">in</strong> enumerate(dflist):<br/>    print(dflist[i].isnull().sum().sum())</span></pre><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/0d62fd5bdf82f48f2ecc62f56593d118.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*7NAPlqXI9fZ-J806MzbKVw.png"/></div></figure><h1 id="8818" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">对数据进行观察</h1><ul class=""><li id="01c1" class="mf mg jg kf b kg ma kk mb ko no ks np kw nq la mk ml mm mn bi translated">下面的一些观察结果在上面的图片中并不明显，但在<a class="ae jd" href="https://github.com/RonKG/machine-learning-portfolio-projects.......in-progress/tree/master/1.%20data_cleaning_project" rel="noopener ugc nofollow" target="_blank">我的 GitHub </a>库中的<a class="ae jd" href="https://github.com/RonKG/machine-learning-portfolio-projects.......in-progress/tree/master/1.%20data_cleaning_project" rel="noopener ugc nofollow" target="_blank">这里</a>的原始笔记本中可以看到。</li><li id="285b" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">在这种情况下，我们获得的数据对于数百个列来说并不太复杂，但是记住这一点是有好处的，因为情况并不总是如此，我们必须能够轻松处理非常大的杂乱数据。</li><li id="75fe" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">从上面的检查来看，在我们能够实现最终的干净数据集之前，有一些事情需要纠正。</li><li id="8d14" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">所有数据集的日期格式都需要转换成统一的格式。</li><li id="37c6" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">日期范围也很不一致。开始日期从 1947 年到 1992 年。</li><li id="d087" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">umcsi 中的日期在两列中(字符串<strong class="kf jh">月</strong>T14】浮点<strong class="kf jh">年</strong>)，很难与该列中的其他数据集合并。</li><li id="926c" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">umcsi 也有 3 个空值，因此我们必须删除存在空值的整行。</li><li id="77a6" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">出于我们的目的，道琼斯数据框架也有额外的列，所以我们需要去掉一些。</li><li id="a5e0" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">这些只是我能观察到的一些修改，但很可能会有其他的并发症。</li><li id="fb31" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">注释你的代码也是必要的，这样你的同事就能理解你在做什么。</li><li id="e26c" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">在某些时候，我们还必须将日期格式从字符串更改为支持绘图的格式。</li></ul><h1 id="3909" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">数据清理</h1><p id="0283" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">道琼斯数据附带了许多我们在最终数据框架中不需要的额外列，因此我们将使用<em class="lb"> pandas drop 函数</em>来释放额外的列。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="cbbc" class="nc ld jg my b gy nd ne l nf ng"><em class="lb"># drop the unnecessary columns</em><br/><br/><em class="lb"> dow.drop(['Open','High','Low','Adj Close','Volume'],axis=1,inplace=True)</em></span><span id="cea0" class="nc ld jg my b gy nh ne l nf ng"># view the final table after dropping unnecessary columns</span><span id="4ad3" class="nc ld jg my b gy nh ne l nf ng">dow.head()</span></pre><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/cdf8bc95f9a7817ef3513ff3e3557407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*3LJiRC0MXaD4syq_a6KMZQ.png"/></div></figure><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="ef41" class="nc ld jg my b gy nd ne l nf ng"><em class="lb"># rename columns to upper case to match other dfs</em><br/><br/>dow.columns = ['DATE', 'OPEN', 'HIGH', 'LOW', 'CLOSE', 'ADJ CLOSE', 'VOLUME']</span><span id="1755" class="nc ld jg my b gy nh ne l nf ng"># view result after renaming columns<br/>dow.head()</span></pre><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ns"><img src="../Images/a1195beff3d023a3c23c06432cc883ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*bLwldYfMVbx3plm2nQ6D0A.png"/></div></div></figure><p id="f83e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些步骤中的大部分可以合并成更少的步骤，但我将它们分解，这样我们就可以遵循，并且我们还可以确认我们正在实现预期的结果。接下来，我们从数据表中删除那些具有空值的列。有时候，我们可能需要组合这些空列，然后在以后删除它们，这样我们就可以填充其他表中的值或获得额外的列(信息)。</p><p id="bf63" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的<em class="lb">原位</em>标志永久删除被删除的行。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="072c" class="nc ld jg my b gy nd ne l nf ng"><em class="lb"># drop NaN Values</em><br/><br/>umcsi.dropna(inplace=<strong class="my jh">True</strong>)</span></pre><p id="fbe2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">umcsi 表包含数据类型为 float 的年份值，当我们开始获取年份的小数数字时，这可能会有问题。我创建了一个函数，它从 float 列创建一个新的 integer 列。然后我们可以将旧的 float year 列<em class="lb">放到()</em>中。有时日期列是字符串格式，我们必须使用内置函数来解析日期，或者我们可以为那些特殊的情况创建自己的列。当您清理数据时，会有很多这样的情况。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="9699" class="nc ld jg my b gy nd ne l nf ng"><em class="lb"># create 'Year' column with int values instead of float</em></span><span id="f3ea" class="nc ld jg my b gy nh ne l nf ng"># casting function<br/><strong class="my jh">def</strong> to_int(x):<br/>    <strong class="my jh">return</strong> int(x)</span><span id="f3be" class="nc ld jg my b gy nh ne l nf ng"># use function to convert floats to int<br/><br/>umcsi['Year'] = umcsi['Unnamed: 1'].apply(to_int)<br/>umcsi.head()</span></pre><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/784d35ac315d83b6e0122633d201fbe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*sjmItT4URSg0TOcdlHFG6A.png"/></div></figure><p id="93cd" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，我们将月份和年份作为单独的列，需要将它们组合起来，以匹配其余数据表中的日期格式。为此，我们使用 pandas <em class="lb"> datetime </em>函数，它能够处理大多数日期和时间操作。事实证明，其他表的日期数据类型为 string，因此我们还必须将 umcsi 日期列更改为 string。这很有意义，因为作为一个时间序列，任何表连接都将在日期列上作为键。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="1d4d" class="nc ld jg my b gy nd ne l nf ng"><em class="lb"># combine year columns to one column format</em><br/><br/>umcsi['DATE'] = umcsi.apply(<strong class="my jh">lambda</strong> x: datetime.datetime.strptime("<strong class="my jh">{0}</strong> <strong class="my jh">{1}</strong>".format(x['Year'],x['DATE OF SURVEY']), "%Y %B"),axis=1)</span><span id="e7c3" class="nc ld jg my b gy nh ne l nf ng"><em class="lb"># turn date format to string to match other DATE's. We'll merge the data on this column so this is a vital step.</em><br/><br/><strong class="my jh">def</strong> to_str(x):<br/>    <strong class="my jh">return</strong> str(x)[:10]<br/><br/>umcsi['DATE'] = umcsi['DATE'].apply(to_str)<br/>umcsi.head()</span></pre><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/4680005f81bfa27651c842716ba91492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*Or96eARB8NyS0rqj950nUw.png"/></div></figure><p id="6f41" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的 umcsi 表看起来很好，除了旧的浮动日期列和月份列，所以我们必须去掉它。为了保持条理，我们还应该把最后的日期列移到前面的列。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="78b6" class="nc ld jg my b gy nd ne l nf ng"><em class="lb"># drop unneeded columns column</em><br/>umcsi.drop(['Unnamed: 1','Year','DATE OF SURVEY'], axis=1, inplace=<strong class="my jh">True</strong>)<br/><br/><em class="lb"># move 'DATE' column to the front</em><br/>cols = list(umcsi)<br/>cols.insert(0, cols.pop(cols.index('DATE')))<br/>umcsi = umcsi.reindex(columns = cols)<br/>umcsi.head()</span></pre><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/1613fe5765102ddc219ebcac90379a8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*NYdFB0DGhMdg650S01JpLw.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">A more useful table than we started of with.</figcaption></figure><p id="7cf7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了内聚格式的所有表，我们可以继续连接它们并做一些最后的清理步骤。我们将用日期列作为键来连接这些表。我们将使用强大的 lambda 函数来快速完成这个任务。实际上，我们将封装更多的函数来展示 pandas 在数据操作方面有多么强大。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="83fb" class="nc ld jg my b gy nd ne l nf ng"><em class="lb"># concatenate all dataframes into one final dataframe</em>  </span><span id="f01c" class="nc ld jg my b gy nh ne l nf ng">dfs = [dow,unemp,oil,hstarts,cars,retail,fedrate,umcsi] </span><span id="3426" class="nc ld jg my b gy nh ne l nf ng"># we perform the joins on DATE column as key and drop null values</span><span id="b843" class="nc ld jg my b gy nh ne l nf ng">df = reduce(<strong class="my jh">lambda</strong> left,right: pd.merge(left,right,on='DATE', how='outer'), dfs).dropna() df.head(5)</span></pre><div class="mt mu mv mw gt ab cb"><figure class="nw is nx ny nz oa ob paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/db4e860dd8bf1b04b9c4d2dc1b19b4b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*U-Hjgd1_dYddh04257IXzw.png"/></div></figure><figure class="nw is oc ny nz oa ob paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/bbbed7fd331e319af6be1ec164672e82.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*fI7DAfR_nITMqANqdz1FGw.png"/></div></figure></div><p id="0d58" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在有了一个最终的熊猫数据框架，尽管它还需要更多的清理。接下来，我们必须从我们的最终表中删除异常值，因为这些异常值可能会在稍后的机器学习任务中引入大量噪声。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="4c24" class="nc ld jg my b gy nd ne l nf ng"><em class="lb"># remove all rows with outliers in at least one row</em><br/><br/>df = df[(np.abs(stats.zscore(df.drop(['DATE'], axis=1))) &lt; 3).all(axis=1)]</span><span id="6292" class="nc ld jg my b gy nh ne l nf ng"># show final size after removing outliers<br/>df.shape</span></pre><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi od"><img src="../Images/dc6ad9f27b59d780b5ea9eb3f43420cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:302/format:webp/1*rHLiaIya9QODcgE5_6bB2g.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Final dataframe shape</figcaption></figure><p id="1bb4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python 有一种专门的格式来处理时间列，这种格式非常有效。我们可以使用<em class="lb"> strip() </em>函数从当前的字符串格式中提取出<em class="lb"> datetime.datetime </em>格式。同样，我们将使用 lambda 函数动态地将其应用于所有行。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="4380" class="nc ld jg my b gy nd ne l nf ng"><em class="lb"># change the DATE column from String to python's <br/># datetime.datetime format</em>  </span><span id="5af6" class="nc ld jg my b gy nh ne l nf ng">df['DATE'] = df['DATE'].apply(<strong class="my jh">lambda</strong> x: datetime.datetime.strptime(x,"%Y-%m-<strong class="my jh">%d</strong>"))</span></pre><p id="2558" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一步是将这些列重命名为更便于用户使用的名称，以便那些继续使用这些数据的用户使用。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="ccbc" class="nc ld jg my b gy nd ne l nf ng"><em class="lb"># rename columns to more user friendly names</em><br/><br/>df.columns = ['DATE', 'OPEN', 'HIGH', 'LOW', 'CLOSE', 'ADJ CLOSE', 'VOLUME', 'UNEMP %','OIL PRICE','NEW HOMES','NEW CARS SOLD',<br/>                    'RETAIL SALES','FED INTRST %','CSI' ]</span><span id="df60" class="nc ld jg my b gy nh ne l nf ng"># preview final table<br/>df.head(20)</span></pre><div class="mt mu mv mw gt ab cb"><figure class="nw is oe ny nz oa ob paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/23792ac8635ce26e96028c298f451519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1574/format:webp/1*DJI5FQixagz1ufNFFE0joA.png"/></div></figure><figure class="nw is of ny nz oa ob paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/4985843a65874e594ce0994bd352476a.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*GebIBZ576bv1wpcNEetI7w.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk og di oh oi">FINAL pandas dataframe</figcaption></figure></div><h1 id="0815" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">数据清理结论</h1><ul class=""><li id="ed6a" class="mf mg jg kf b kg ma kk mb ko no ks np kw nq la mk ml mm mn bi translated">数据清理有各种形式和大小，没有一个模板可以处理所有情况。</li><li id="5e76" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">虽然我们不知道数据在预测 CSI 的任务中表现如何，但我们知道所提供的数据已经过处理，以便在 ML 环境中快速采用和测试。</li><li id="4b3f" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">当然，我们可以设计出更多的功能，并对当前的功能进行更多的处理，但对于我们来说，ML 团队将如何进行就太放肆了。例如，我们可以将特征归一化到统一的比例，但没有这样做。</li><li id="77ed" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">总之，像数据科学领域的大多数任务一样，我们最多只能在合适的团队中不断提问，并根据这些问题进行更深入的实验。</li></ul></div></div>    
</body>
</html>