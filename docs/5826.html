<html>
<head>
<title>Variational Autoencoders Explained in Detail</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">变型自动编码器详细解释</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/variational-autoencoders-explained-in-detail-d585327c660a?source=collection_archive---------2-----------------------#2018-11-11">https://towardsdatascience.com/variational-autoencoders-explained-in-detail-d585327c660a?source=collection_archive---------2-----------------------#2018-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0db9826dd493a73944365228370bf034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D3-3CvH6A31u8rye16Aq9Q.jpeg"/></div></div></figure><p id="3df4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本系列的前一篇文章中，我介绍了变分自动编码器(VAE)框架，并解释了其背后的理论。</p><p id="9783" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我将更详细地解释 VAE，或者换句话说，我将提供一些代码:)</p><p id="8729" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">读完这篇文章后，你会理解实现 VAE 所需的技术细节。</p><p id="206b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为奖励，我将向您展示如何通过对一些潜在向量的维度施加特殊作用，该模型可以根据手指类型生成图像。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="cc06" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该模型将在<a class="ae kz" href="https://en.wikipedia.org/wiki/MNIST_database" rel="noopener ugc nofollow" target="_blank">MNIST</a>——手写数字数据集上进行训练。输入是ℝ[28∙28].的图像</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="15ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将定义将要使用的超参数。</p><p id="e1ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">随意使用不同的值来感受模型是如何被影响的。笔记本可以在这里找到<a class="ae kz" href="https://github.com/yoel-zeldes/yoel-zeldes.github.io/blob/source/content/vae2/vae2.ipynb" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><h1 id="2f1d" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">模型</h1><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi me"><img src="../Images/8c0ec13a952f9f73e8e4af7909b5e4f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tMUXpkJZW1EUB8kcLytQ6A.jpeg"/></div></div></figure><p id="cdac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该模型由三个子网络组成:</p><ol class=""><li id="e47c" class="mf mg it kd b ke kf ki kj km mh kq mi ku mj ky mk ml mm mn bi translated">给定<em class="mo"> x </em>(图像)，将其编码成潜在空间上的分布——在前一篇文章中称为<em class="mo">Q</em>(<em class="mo">z</em>|<em class="mo">x</em>)。</li><li id="55e5" class="mf mg it kd b ke mp ki mq km mr kq ms ku mt ky mk ml mm mn bi translated">给定<em class="mo"> z </em>在潜空间(一个图像的代码表示)，解码成它所表示的图像——在上一篇文章中称为<em class="mo"> f </em> ( <em class="mo"> z </em>)。</li><li id="1d76" class="mf mg it kd b ke mp ki mq km mr kq ms ku mt ky mk ml mm mn bi translated">给定<em class="mo"> x </em>，通过将其映射到大小为 10 的层来对其数字进行分类，其中第 I 个值包含第 I 个数字的概率。</li></ol><p id="5f68" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">前两个子网络是普通的 VAE 框架。</p><p id="145f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第三个用作<a class="ae kz" href="http://ruder.io/multi-task/index.html" rel="noopener ugc nofollow" target="_blank">辅助任务</a>，它将执行一些潜在维度来编码图像中的数字。让我解释一下动机:在上一篇文章中，我解释过我们不在乎潜在空间的每个维度包含什么信息。该模型可以学习编码它认为对其任务有价值的任何信息。因为我们熟悉数据集，所以我们知道数字类型应该很重要。我们希望通过向模型提供这些信息来帮助它。此外，我们将使用这些信息生成以手指类型为条件的图像，我将在后面解释。</p><p id="6a07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">给定数字类型，我们将使用一种热编码对其进行编码，即大小为 10 的向量。这 10 个数字将被连接成潜在向量，因此当将该向量解码成图像时，该模型将利用数字信息。</p><p id="9ad3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有两种方法为模型提供一个热编码向量:</p><ol class=""><li id="d05b" class="mf mg it kd b ke kf ki kj km mh kq mi ku mj ky mk ml mm mn bi translated">将其作为输入添加到模型中。</li><li id="b3a4" class="mf mg it kd b ke mp ki mq km mr kq ms ku mt ky mk ml mm mn bi translated">将它添加为标签，这样模型将必须自己预测它:我们将添加另一个预测大小为 10 的向量的子网络，其中损失是与预期的一个热向量的交叉熵。</li></ol><p id="020a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将采用第二种选择。为什么？在测试时，我们可以以两种方式使用这个模型:</p><ol class=""><li id="75d7" class="mf mg it kd b ke kf ki kj km mh kq mi ku mj ky mk ml mm mn bi translated">提供图像作为输入，并推断潜在向量。</li><li id="4f26" class="mf mg it kd b ke mp ki mq km mr kq ms ku mt ky mk ml mm mn bi translated">提供潜在向量作为输入，并生成图像。</li></ol><p id="d2cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我们也想支持第一个选项，所以我们不能为模型提供数字作为输入，因为我们在测试时不会知道它。因此，模型必须学会预测它。</p><p id="7142" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">既然我们已经了解了组成模型的所有子网，我们就可以对它们进行编码了。编码器和解码器背后的数学细节可以在之前的文章中找到。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><h1 id="9fd0" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">培养</h1><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mu"><img src="../Images/6bf31417c7afdc34d18dec98b64c1351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*juj_EJJLbRzv0nVn5J86nw.jpeg"/></div></div></figure><p id="f09b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将使用<a class="ae kz" href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent" rel="noopener ugc nofollow" target="_blank"> SGD </a>训练模型来优化两种损失——VAE 损失和分类损失。</p><p id="0c6f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在每个时期结束时，我们将对潜在向量进行采样，并将它们解码成图像，这样我们就可以直观地看到模型的生成能力如何随着时期的推移而提高。取样方法如下:</p><ol class=""><li id="3d0e" class="mf mg it kd b ke kf ki kj km mh kq mi ku mj ky mk ml mm mn bi translated">根据我们想要生成图像的数字，确定性地设置用于数字分类的维度。例如，如果我们想要生成数字 2 的图像，这些尺寸将被设置为[0010000000]。</li><li id="5ec6" class="mf mg it kd b ke mp ki mq km mr kq ms ku mt ky mk ml mm mn bi translated">根据先验——多元高斯随机抽取其他维度的样本。我们将把这些采样值用于我们在给定时期生成的所有不同数字。通过这种方式，我们可以对其他维度的编码有一种感觉，例如笔画风格。</li></ol><p id="a035" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">步骤 1 背后的直觉是，在收敛之后，模型应该能够使用这些维度对输入图像中的数字进行分类。另一方面，这些维度也用于解码步骤以生成图像。这意味着解码器子网络了解到当这些维度具有对应于数字 2 的值时，它应该生成该数字的图像。因此，如果我们手动设置这些维度来包含数字 2 的信息，我们将得到该数字的生成图像。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="451a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们验证一下这两种损失看起来都不错，也就是说——在减少:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/9aff1cb80f65e2fe908b71e71c436106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a2sr2OXX2TqODZLlOrosHg.png"/></div></div></figure><p id="fd3c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，让我们绘制生成的图像，看看模型是否真的能够生成数字图像:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mw"><img src="../Images/33cc85dbbaf0627b2239466903ffc85a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NPQbqw3ZAcfLP5GNQC8gYA.png"/></div></div></figure></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="3a43" class="lg lh it bd li lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md bi translated">最后的想法</h1><p id="0164" class="pw-post-body-paragraph kb kc it kd b ke nj kg kh ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky im bi translated">很高兴看到使用一个简单的前馈网络(没有花哨的卷积)，我们能够在仅仅 20 个时期后生成好看的图像。该模型很快学会了使用特殊的数字维度——在第 9 纪元，我们已经看到了我们试图生成的数字序列。</p><p id="7ee4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个纪元对其他维度使用不同的随机值，因此我们可以看到不同纪元之间的风格如何不同，而每个纪元内部的风格是相似的——至少对于某些纪元而言是如此。例如，与时段 20 相比，在时段 18，所有的数字都更粗。</p><p id="efef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我邀请你打开<a class="ae kz" href="https://github.com/yoel-zeldes/yoel-zeldes.github.io/blob/source/content/vae2/vae2.ipynb" rel="noopener ugc nofollow" target="_blank">这个笔记本</a>和 VAE 一起玩耍。例如，超参数值对生成的图像有很大影响。玩得开心:)</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="7b9c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mo">原文由我在</em><a class="ae kz" href="http://anotherdatum.com/vae2.html" rel="noopener ugc nofollow" target="_blank"><em class="mo"/></a><em class="mo">发表。</em></p></div></div>    
</body>
</html>