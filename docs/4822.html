<html>
<head>
<title>Sprinting into the Visualization Track (Part 1) : Matplotlib</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">冲刺可视化轨道(第 1 部分):Matplotlib</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sprinting-into-the-visualization-track-part-1-matplotlib-6c069ac91e40?source=collection_archive---------6-----------------------#2018-09-09">https://towardsdatascience.com/sprinting-into-the-visualization-track-part-1-matplotlib-6c069ac91e40?source=collection_archive---------6-----------------------#2018-09-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2d3cdf235589fa8949c538d30aa83ffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xyxRpLx2KNj4PEJd"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">“A race on the running track at Anglo-Chinese School in Singapore” by <a class="ae kc" href="https://unsplash.com/@gohrhyyan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Goh Rhy Yan</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f883" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经用 DataFrame 走了很久，</p><div class="lb lc gp gr ld le"><a rel="noopener follow" target="_blank" href="/beginning-to-walk-the-data-science-road-part-2-pandas-dataframe-c3e898499d90"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">开始走数据科学之路(下) :熊猫数据框架</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">在第 1 部分中，我们开始走这条路，一路上，我们遇到了系列。</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">towardsdatascience.com</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls jw le"/></div></div></a></div><p id="a62d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并获得了相当大的势头。现在，我们准备开始冲刺。在这篇文章中，我们将开始研究可视化。到目前为止，我们看到的都是数字，文本，数组。无聊的东西。可视化是我们可以更好地交流我们的发现的方法。在这篇文章中，我们将看看可能是最流行的可视化库— <a class="ae kc" href="https://matplotlib.org/index.html" rel="noopener ugc nofollow" target="_blank"> Matplotlib </a>。特别是，我们将使用 Matplotlib 库中的<a class="ae kc" href="https://matplotlib.org/api/pyplot_summary.html" rel="noopener ugc nofollow" target="_blank"> pyplot </a>模块。</p><p id="f841" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一如既往，我们将寻求解决问题。首先，我们来看一个在图像处理中使用的著名图像——Lenna 图像<a class="ae kc" href="https://en.wikipedia.org/wiki/Lenna" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"/></a>。之后，我们将使用温度变化数据集在 pyplot 上再玩一些。</p><p id="eefc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章的完整代码可以在下面的资源库中找到。</p><div class="lb lc gp gr ld le"><a href="https://github.com/bajracharya-kshitij/matplotlib" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">bajracharya-kshitij/matplotlib</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">边解题边探索 matplotlib。为 bajracharya-kshitij/matplotlib 开发做出贡献，创建一个…</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">github.com</p></div></div><div class="ln l"><div class="lt l lp lq lr ln ls jw le"/></div></div></a></div><p id="7edc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重要的事情先来。使用<a class="ae kc" href="https://anaconda.org/" rel="noopener ugc nofollow" target="_blank"> anaconda </a>和 Python 3 安装 matplotlib。之后，导入 pyplot 模块。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="a095" class="md me iq lz b gy mf mg l mh mi">import matplotlib.pyplot as plt</span></pre><h1 id="d06c" class="mj me iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">问题 1</h1><p id="7f80" class="pw-post-body-paragraph kd ke iq kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">Lenna 图像是图像处理中广泛使用的测试图像。</p><p id="01ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">a)找出其广泛使用背后的原因。调查一下它有什么特别之处。</p><p id="840e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">b)为图像的 RGB 值创建堆叠直方图。</p><p id="85b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">c)表示饼图中(50，100)处像素的 RGB 值。</p><p id="6f90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">d)表示饼图中(100，100)处像素的 RGB 值。这个饼状图有什么不寻常的地方？</p><p id="8f3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">e)生成该图像的负片。</p><h1 id="da47" class="mj me iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">解决方案 1</h1><p id="9366" class="pw-post-body-paragraph kd ke iq kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">快速的谷歌搜索应该会显示 Lenna 图片的结果。原图可以在这里<a class="ae kc" href="http://www.lenna.org/" rel="noopener ugc nofollow" target="_blank">找到</a>，是 512x512 的 tif 图像。在这篇文章中，我将使用在这个<a class="ae kc" href="https://upload.wikimedia.org/wikipedia/en/thumb/7/7d/Lenna_%28test_image%29.png/220px-Lenna_%28test_image%29.png" rel="noopener ugc nofollow" target="_blank">链接</a>中找到的图像，这是一个 220x220 的 png 图像。</p><h2 id="41ec" class="md me iq bd mk nl nm dn mo nn no dp ms ko np nq mw ks nr ns na kw nt nu ne nv bi translated">注意:</h2><p id="2aea" class="pw-post-body-paragraph kd ke iq kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">关于这一形象的使用一直存在一些争议。但是用于测试的图像的裁剪版本对于工作是安全的。</p><p id="ef2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们使用<code class="fe nw nx ny lz b">imread</code>来读取图像<code class="fe nw nx ny lz b">lenna.png</code>。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="7953" class="md me iq lz b gy mf mg l mh mi">img = plt.imread('lenna.png')</span></pre><p id="dde6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你现在打印<code class="fe nw nx ny lz b">img</code>，你会看到它是一个 3D 数组，每个条目的值在 0 和 1 之间。其他图像没有必要具有介于 0 和 1 之间的条目。例如，原始 tif 具有 0 到 255 之间的条目；只有我们选择的图像的值在 0 和 1 之间。然而，所有的 2D 图像都会形成一个 3D 阵列。如果你检查<code class="fe nw nx ny lz b">img.shape</code>，你会得到<code class="fe nw nx ny lz b">(220,220,3)</code>，表明这是一个三维数组。前两个维度代表图像的维度。但是最后那个<code class="fe nw nx ny lz b">3</code>代表什么？</p><p id="3eef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">lenna 图像有 3 个颜色通道—红色(<strong class="kf ir"> R </strong>)、绿色(<strong class="kf ir"> G </strong>)和蓝色(<strong class="kf ir"> B </strong>)。<code class="fe nw nx ny lz b">3</code>代表这三个颜色通道。因此，前两个维度给出一个像素，最后一个给出该像素的 3 个颜色通道的值。为了更清楚起见，<code class="fe nw nx ny lz b">img[0][0][0]</code>给出了第一个像素的<strong class="kf ir"> R </strong>通道的像素值，<code class="fe nw nx ny lz b">img[219][219][2]</code>给出了最后一个像素的<strong class="kf ir"> B </strong>通道的像素值，所有剩余像素也是如此。</p><p id="3a0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们现在显示图像。为此，我们使用<code class="fe nw nx ny lz b">imshow</code>。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="54f9" class="md me iq lz b gy mf mg l mh mi">plt.imshow(img)</span></pre><p id="f8dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，单独这样做，我们会在结果中看到类似这样的内容。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="c269" class="md me iq lz b gy mf mg l mh mi">&lt;matplotlib.image.AxesImage at 0x119434fd0&gt;</span></pre><p id="63d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了显示图像，我们需要使用<code class="fe nw nx ny lz b">plt.show()</code>,之后我们将看到下图</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/9b4d453f03883362b1c948f676b05732.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*KOHx2dcE4GyEdmh8SrY0xw.png"/></div></figure><p id="6265" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你使用的不是 Jupyter 笔记本，每次你需要显示一个图形时，你都必须使用<code class="fe nw nx ny lz b">plt.show()</code>。幸运的是，Jupyter 笔记本有一个<a class="ae kc" href="https://www.dummies.com/programming/python/common-jupyter-notebook-magic-functions/" rel="noopener ugc nofollow" target="_blank">魔法函数</a>，你可以用它来显示图像，而不需要每次都调用 show 函数。你需要做的就是添加下面一行。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="d86b" class="md me iq lz b gy mf mg l mh mi">%matplotlib inline</span></pre><p id="dd6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后你可以简单地使用<code class="fe nw nx ny lz b">plt.imshow(img)</code>，它将返回图像。</p><h2 id="1dba" class="md me iq bd mk nl nm dn mo nn no dp ms ko np nq mw ks nr ns na kw nt nu ne nv bi translated">那么，这张图片有什么特别之处呢？</h2><p id="489a" class="pw-post-body-paragraph kd ke iq kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">为了理解这一点，让我们生成此图像的灰度版本。为此，首先我们将原始图像复制到一个新的 NumPy 数组中，并找到 3 个颜色通道的平均值。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="e5f3" class="md me iq lz b gy mf mg l mh mi">import numpy as np<br/>img_gray = np.copy(img)<br/>img_gray[:] = img.mean(axis=-1,keepdims=1)</span></pre><p id="850e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将为每个像素在 3 个条目的每一个中放置平均值。这里，<code class="fe nw nx ny lz b">axis=-1</code>将取最里面的轴，即每个像素的所有 3 个值，并求其平均值。当我们这样做的时候，其中一个维度被删除，得到的数组将是 2D。但是，我们希望通过用平均值替换三个值中的每一个来保留一个像素的所有三个值。这可以通过保留原始数组的尺寸的<code class="fe nw nx ny lz b">keepdims=1</code>来实现。现在，<code class="fe nw nx ny lz b">plt.imshow(img_gray)</code>将显示如下图像。</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/41fdcf1e527706907b94839a39def6c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/format:webp/1*z9M_HtS4mWqgNlNiGr6f1w.png"/></div></figure><p id="fc1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">灰度图像的形状仍然保持<code class="fe nw nx ny lz b">(220,220,3)</code>。让我们把它弄平，这样我们就可以在一个维度上得到所有的像素值。我们<code class="fe nw nx ny lz b">reshape</code>它来获取像素值。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="7133" class="md me iq lz b gy mf mg l mh mi">pixels = img_gray.reshape(220*220*3)</span></pre><p id="a82e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，<code class="fe nw nx ny lz b">pixels.shape</code>现在返回(145200，)。现在我们有了平面阵列中的所有像素，让我们为这些像素值绘制一个直方图。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="ba89" class="md me iq lz b gy mf mg l mh mi">plt.hist(pixels,bins=255)</span></pre><p id="8318" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nw nx ny lz b">hist</code>函数将所有像素值作为第一个参数。它还需要一个我们设置为 255 的<code class="fe nw nx ny lz b">bin</code>参数。</p><h2 id="49fb" class="md me iq bd mk nl nm dn mo nn no dp ms ko np nq mw ks nr ns na kw nt nu ne nv bi translated">什么是垃圾箱？</h2><p id="d951" class="pw-post-body-paragraph kd ke iq kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">为了更好地解释直方图和条柱，请查看此<a class="ae kc" href="https://courses.lumenlearning.com/wmopen-concepts-statistics/chapter/histograms-2-of-4/" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="71f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您运行上面包含<code class="fe nw nx ny lz b">hist</code>函数的代码块时，它返回两个数组。第一个数组的前 5 个条目如下所示:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="a606" class="md me iq lz b gy mf mg l mh mi">6.,     0.,     0.,     9.,     6.</span></pre><p id="8e48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个数组如下所示:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="60b7" class="md me iq lz b gy mf mg l mh mi">0.12679739,  0.12989876,  0.13300014,  0.13610151,  0.13920288</span></pre><p id="03a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，这些数字是什么？如果仔细观察，您会发现两个数组都有 256 个条目，比我们在<code class="fe nw nx ny lz b">bins</code>中设置的多一个。现在，如果你生成一个线性间隔的数组，比如</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="bb08" class="md me iq lz b gy mf mg l mh mi">np.linspace(pixels.min(),pixels.max(),256)</span></pre><p id="3dda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将生成与上面第二个数组完全相同的数组。因此，<code class="fe nw nx ny lz b">bins</code>正在做的是，从像素阵列中获取最小和最大值，生成 256 个线性间隔的数字，然后创建块(其中 255 个)。因此，第一个块将具有范围<code class="fe nw nx ny lz b">0.12679739-0.12989876</code>，第二个块将具有范围<code class="fe nw nx ny lz b">0.12989876-0.13300014</code>，以此类推，直到上限等于<code class="fe nw nx ny lz b">pixels.max()</code>的最后一个块。那么第一个数组呢？嗯，它是值落在相应块内的频率。因此，有 6 个像素的值落在第一个范围内，9 个像素的值落在第四个范围内，依此类推。为什么是 256？你可以选择任何你喜欢的数字。我选择 256 是因为这是一个很好的数字，因为在灰度图像中有 256 种不同的亮度。如果没有为<code class="fe nw nx ny lz b">bins</code>提供值，缺省值是 10。</p><p id="21bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这些值，<code class="fe nw nx ny lz b">hist</code>函数将生成一个如下所示的直方图</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/66b141bd2a2b682a76ef871f746ce5e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*66dHX_CWHBT7dtQ5j93xSw.png"/></div></figure><p id="0735" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从图中可以看出，lenna 图像几乎覆盖了整个面元范围。几乎每个箱都有强度值。正如在<a class="ae kc" href="http://www.ee.cityu.edu.hk/~lmpo/lenna/Lenna97.html" rel="noopener ugc nofollow" target="_blank">这个链接</a>中提到的，Lenna 图像包含了细节、平坦区域、阴影和纹理的良好混合，可以很好地测试各种图像处理算法。这就是该图像被视为标准测试图像的原因。</p><p id="c519" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们分别看看每个颜色通道。我们在单独的数组中提取对应于每种颜色的像素。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="422c" class="md me iq lz b gy mf mg l mh mi">img_r = img[:,:,0]<br/>img_g = img[:,:,1]<br/>img_b = img[:,:,2]</span></pre><p id="e3c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你检查这些数组的<code class="fe nw nx ny lz b">shape</code>，你会得到(220，220)。所以我们现在有三个 2D 阵列。像前面一样，让我们为这三个元素创建一个平面一维数组。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="3fd4" class="md me iq lz b gy mf mg l mh mi">img_r_pixels = img_r.reshape(220*220)<br/>img_g_pixels = img_g.reshape(220*220)<br/>img_b_pixels = img_b.reshape(220*220)</span></pre><p id="ad3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我想看看这三个像素的亮度是如何分布的。如果所有的颜色都可以并排比较就好了。我们可以使用<code class="fe nw nx ny lz b">subplot</code>来做到这一点。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="798f" class="md me iq lz b gy mf mg l mh mi">plt.subplot(1,3,1)<br/>plt.hist(img_r_pixels,bins=100)</span><span id="096b" class="md me iq lz b gy oc mg l mh mi">plt.subplot(1,3,2)<br/>plt.hist(img_g_pixels,bins=100)</span><span id="b91c" class="md me iq lz b gy oc mg l mh mi">plt.subplot(1,3,3)<br/>plt.hist(img_b_pixels,bins=100)</span></pre><p id="05dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你用过 MATLAB，你可能对支线剧情很熟悉。<code class="fe nw nx ny lz b">subplot</code>函数有三个参数——第一个是行数，第二个是列数，第三个是索引号。然后对于<code class="fe nw nx ny lz b">plt.subplot(1,3,2)</code>上面的第二个支线剧情表示我们要取剧情，把它分成 1×3 的格子，这样一共 3 个支线剧情都是可能的，然后我们要用第 2 个支线剧情。之后，我们用<code class="fe nw nx ny lz b">plt.hist(img_g_pixels,bins=100)</code>绘制绿色像素的直方图。这里我们用<code class="fe nw nx ny lz b">bins=100</code>。同样，您可以使用任何您喜欢的数字。或者直接跳过。</p><p id="6901" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们有这样的东西:</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/558c94a1612a761c155e025ab9cc5ea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*yicUB5nNNueCGI2-VKDD5g.png"/></div></figure><p id="6e7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但这看起来不太好。这些地块非常拥挤，纵轴上的数字相互重叠。让我们在结尾加上<code class="fe nw nx ny lz b">plt.tight_layout()</code>让它更漂亮一点，就像</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="ce19" class="md me iq lz b gy mf mg l mh mi">plt.subplot(1,3,1)<br/>plt.hist(img_r_pixels,bins=100)</span><span id="82e7" class="md me iq lz b gy oc mg l mh mi">plt.subplot(1,3,2)<br/>plt.hist(img_g_pixels,bins=100)</span><span id="586f" class="md me iq lz b gy oc mg l mh mi">plt.subplot(1,3,3)<br/>plt.hist(img_b_pixels,bins=100)</span><span id="e10a" class="md me iq lz b gy oc mg l mh mi">plt.tight_layout()</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/1ecb631c72c8b508c600f87b29666587.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*zKaIQ6bt9ZmV3CqqmNec3Q.png"/></div></figure><p id="440c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很好。我们还可以使用<code class="fe nw nx ny lz b">hist</code>函数中的<code class="fe nw nx ny lz b">histtype</code>参数来生成不同类型的直方图。现在，直方图在宽度方向上看起来仍然有点拥挤；这个数字比我们想要的要小得多。所以，让我们用<code class="fe nw nx ny lz b">plt.figure</code>来设置支线剧情的大小。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="7bcd" class="md me iq lz b gy mf mg l mh mi">plt.figure(figsize=(15,5))<br/>plt.subplot(1,3,1)<br/>plt.hist(img_r_pixels,bins=100,histtype='barstacked')</span><span id="748e" class="md me iq lz b gy oc mg l mh mi">plt.subplot(1,3,2)<br/>plt.hist(img_g_pixels,bins=100,histtype='step')</span><span id="2ce8" class="md me iq lz b gy oc mg l mh mi">plt.subplot(1,3,3)<br/>plt.hist(img_b_pixels,bins=100,histtype='stepfilled')</span><span id="1a8f" class="md me iq lz b gy oc mg l mh mi">plt.tight_layout()</span></pre><p id="a326" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nw nx ny lz b">figsize</code>将元组作为参数—元组的第一个条目是宽度，第二个条目是高度，以英寸为单位。我们可以将这些值更改为最适合该图的值。对于上面的例子，我们现在有一个类似于</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/b982f11c8aff474351f0f5193e9a4667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0xZndHKAhSy8MP_pwpR6YA.png"/></div></div></figure><p id="2f7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好多了。现在，只有 3 种颜色，但还是让我们通过给这些图添加颜色来使它更清晰。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="9599" class="md me iq lz b gy mf mg l mh mi">plt.figure(figsize=(15,5))<br/>plt.subplot(1,3,1)<br/>plt.hist(img_r_pixels,bins=100,histtype='barstacked',color='r')</span><span id="9142" class="md me iq lz b gy oc mg l mh mi">plt.subplot(1,3,2)<br/>plt.hist(img_g_pixels,bins=100,histtype='step',color='g')</span><span id="1eae" class="md me iq lz b gy oc mg l mh mi">plt.subplot(1,3,3)<br/>plt.hist(img_b_pixels,bins=100,histtype='stepfilled',color='b')</span><span id="2955" class="md me iq lz b gy oc mg l mh mi">plt.tight_layout()</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/b7fc19a39741f1404ce9640039fe5802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hg82PeSH9Ryby8alAK9rRQ.png"/></div></div></figure><p id="f670" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们标记坐标轴，并给每个支线剧情一个标题。使用<code class="fe nw nx ny lz b">xlabel</code>和<code class="fe nw nx ny lz b">ylabel</code>作为轴，使用<code class="fe nw nx ny lz b">title</code>作为子剧情标题。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="2a86" class="md me iq lz b gy mf mg l mh mi">plt.figure(figsize=(15,5))<br/>plt.subplot(1,3,1)<br/>plt.hist(img_r_pixels,bins=100,histtype='barstacked',color='r')<br/>plt.title('Histogram for Red Pixels')<br/>plt.xlabel('Pixel Intensity')<br/>plt.ylabel('Frequency')</span><span id="7f7b" class="md me iq lz b gy oc mg l mh mi">plt.subplot(1,3,2)<br/>plt.hist(img_g_pixels,bins=100,histtype='step',color='g')<br/>plt.title('Histogram for Green Pixels')<br/>plt.xlabel('Pixel Intensity')<br/>plt.ylabel('Frequency')</span><span id="251e" class="md me iq lz b gy oc mg l mh mi">plt.subplot(1,3,3)<br/>plt.hist(img_b_pixels,bins=100,histtype='stepfilled',color='b')<br/>plt.title('Histogram for Blue Pixels')<br/>plt.xlabel('Pixel Intensity')<br/>plt.ylabel('Frequency')</span><span id="2b57" class="md me iq lz b gy oc mg l mh mi">plt.tight_layout()</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/ddfd52023ec24aa2be03cd7b338cf6e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J_YyYZi5Rtg9O5jIYv1E_Q.png"/></div></div></figure><p id="c4e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，让我们把这三个支线剧情叠加成一个</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="39da" class="md me iq lz b gy mf mg l mh mi">colors = ['red','green','blue']<br/>plt.hist([img_r_pixels,img_g_pixels,img_b_pixels],bins=100,stacked=True,color=colors,normed=1)<br/>plt.title('Stacked Histogram')<br/>plt.xlabel('Pixel Intensity')<br/>plt.ylabel('Frequency')</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/a5daba2a63c43470c896f9492d2d56df.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*vfsRSdnm9MW1sfADds8rsQ.png"/></div></figure><p id="632c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，<code class="fe nw nx ny lz b">hist</code>接受一个像素值数组，这个数组的每个元素都用<code class="fe nw nx ny lz b">color</code>参数赋予适当的颜色。<code class="fe nw nx ny lz b">stacked=True</code>创建堆积直方图。由于 3 个颜色通道具有不同的频率范围，如单独的子图所示，我们使用<code class="fe nw nx ny lz b">normed=1</code>标准化直方图。</p><p id="d364" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe nw nx ny lz b">normed=1</code>，强度值将以这样一种方式绘制，即强度值和相应箱宽度的乘积总和等于 1。有关<code class="fe nw nx ny lz b">normed</code>的更多信息，请参见<a class="ae kc" href="https://stackoverflow.com/questions/5498008/pylab-histdata-normed-1-normalization-seems-to-work-incorrect" rel="noopener ugc nofollow" target="_blank">此链接</a>。</p><p id="2ccd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的例子中，如果我们设定</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="c3c2" class="md me iq lz b gy mf mg l mh mi">x = plt.hist([img_r_pixels,img_g_pixels,img_b_pixels],bins=100,stacked=True,color=colors,normed=1)</span></pre><p id="a6a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">打印出 x，我们将看到它返回一个元组—第一个元素是每种颜色的像素强度数组，第二个元素是 bin 大小数组。我们将把它设置为</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="61f0" class="md me iq lz b gy mf mg l mh mi">r = x[0][0]<br/>g = x[0][1]<br/>b = x[0][2]<br/>bins = x[1]</span></pre><p id="089b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们检查每一个的尺寸(像<code class="fe nw nx ny lz b">r.size</code>，我们会看到<code class="fe nw nx ny lz b">r</code>、<code class="fe nw nx ny lz b">g</code>和<code class="fe nw nx ny lz b">b</code>的尺寸是 100，而<code class="fe nw nx ny lz b">bins</code>的尺寸是 101 (100 个间隔)。然后，如果我们找到总和，</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="eba3" class="md me iq lz b gy mf mg l mh mi">def getSum(frequency_array, bins_array):<br/>    _sum = 0<br/>    for i in range(frequency_array.size):<br/>        _sum += frequency_array[i] * (bins_array[i+1]-bins_array[i])<br/>    return _sum<br/>    <br/>print("red px: ", getSum(r,bins))<br/>print("green px: ", getSum(g,bins))<br/>print("blue px: ", getSum(b,bins))</span></pre><p id="1711" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们会回来的</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="ff37" class="md me iq lz b gy mf mg l mh mi">red px:  0.333333333333<br/>green px:  0.666666666667<br/>blue px:  1.0</span></pre><p id="a34d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显示总和为 1，因此强度已经被归一化。</p><h2 id="a407" class="md me iq bd mk nl nm dn mo nn no dp ms ko np nq mw ks nr ns na kw nt nu ne nv bi translated">只有直方图？pyplot 能做的就这些吗？</h2><p id="7313" class="pw-post-body-paragraph kd ke iq kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">我们已经看到了很多使用直方图的东西。但这只是 pyplot 可以生成的各种图之一。查看官方 matplotlib 网站中的<a class="ae kc" href="https://matplotlib.org/gallery/index.html" rel="noopener ugc nofollow" target="_blank">图库</a>页面，查看可以使用 pyplot 绘制的所有各种类型的绘图。现在，让我们转移到一些其他类型的情节。</p><p id="ff2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们看看饼状图。让我们取(50，100)处的一个像素，并找出该像素处的主色。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="2540" class="md me iq lz b gy mf mg l mh mi">intensities = img[50][100]</span></pre><p id="d022" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nw nx ny lz b">intensities</code>给出一个类似于</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="4bfd" class="md me iq lz b gy mf mg l mh mi">array([0.8745098 , 0.7058824 , 0.64705884], dtype=float32)</span></pre><p id="1e83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在(50，100)处，3 种颜色有 3 个强度值。要绘制一个代表该像素亮度的饼图，我们需要做的就是</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="d015" class="md me iq lz b gy mf mg l mh mi">plt.pie(intensities)</span></pre><p id="9634" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">饼状图将被绘制成</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/ffe31707ea44cb99508053ac8674bd85.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*kH6mK5k2n5BrpPsQP55ASw.png"/></div></figure><p id="f204" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但目前看起来不太好看。第一，它不是一个规则的圆。让我们解决这个问题。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="c527" class="md me iq lz b gy mf mg l mh mi">plt.pie(intensities)<br/>plt.axis('equal')</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/4aa8911e451055fa4e1541fed5dcad44.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*qzGBdi4Fjb8b-xrQGOcefw.png"/></div></figure><p id="95c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好多了。现在，我们不能真正区分哪个部分代表哪个颜色。请注意，这个饼图中的蓝色和绿色不一定表示蓝色和绿色部分。这只是 pyplot 分配的 3 种默认颜色。所以，让我们给馅饼添加一些更多的信息。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="ad79" class="md me iq lz b gy mf mg l mh mi">colors = ['red', 'green', 'blue']<br/>explode = (0, 0.1, 0)<br/>plt.pie(intensities,labels=colors,colors=colors,autopct='%1.2f%%',explode=explode)<br/>plt.axis('equal')</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/243562a472b4a0cfeb3f2513a5c9e8d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*SOsukqPNpKKHircbiZc0NQ.png"/></div></figure><p id="aa5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好多了。<code class="fe nw nx ny lz b">plt.pie</code>这里以<code class="fe nw nx ny lz b">intensities</code>数组为数据。它使用<code class="fe nw nx ny lz b">colors</code>数组将<code class="fe nw nx ny lz b">labels</code>和<code class="fe nw nx ny lz b">colors</code>应用于截面。<code class="fe nw nx ny lz b">autopct=’%1.2f%%’</code>格式化区段的百分比，对于<code class="fe nw nx ny lz b">explode</code>参数，它只是从圆形饼图中分离出一个区段。我们将<code class="fe nw nx ny lz b">explode=(0,0.1,0)</code>定义为我们想要将第二个元素(绿色元素)分解 0.1。如上图所示，绿色部分已被分离。因此，从这个饼图中我们可以看到，在 pixel (50，100)处，像素值几乎相似，但红色比其他两个略占优势。</p><p id="864c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们再次做同样的事情；这次是像素(100，100)。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="5ca0" class="md me iq lz b gy mf mg l mh mi">intensities2 = img[100][100]<br/>print(intensities2)<br/>colors = ['red', 'green', 'blue']<br/>plt.pie(intensities2,autopct='%1.2f%%',labels=colors,colors=colors)<br/>plt.axis('equal')</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/32769c4ac670799a95b878a50b961270.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*NH0XQbKTDsLMBcD3eh6t8Q.png"/></div></figure><p id="86e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太奇怪了。它看起来不像普通的馅饼。如果你把各部分加起来，它甚至不是 100%。那么，为什么会这样呢？如果你看看文件，你会发现</p><blockquote class="om on oo"><p id="bc91" class="kd ke op kf b kg kh ki kj kk kl km kn oq kp kq kr or kt ku kv os kx ky kz la ij bi translated">每个楔形的分数面积由<code class="fe nw nx ny lz b">x/sum(x)</code>给出。如果<code class="fe nw nx ny lz b">sum(x) &lt; 1</code>，那么<em class="iq"> x </em>的值直接给出分数面积，数组不会被归一化。生成的饼图将有一个大小为<code class="fe nw nx ny lz b">1 - sum(x)</code>的空楔形区</p></blockquote><p id="8c66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你打印出<code class="fe nw nx ny lz b">intensities2</code>，你会得到</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="b6bb" class="md me iq lz b gy mf mg l mh mi">array([0.34509805, 0.07843138, 0.24705882], dtype=float32)</span></pre><p id="1d0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">的确，如果你把它们都加起来，总和在 1 以下。这就是为什么数组没有被规范化，并且有一个空的楔形，一个空的部分覆盖了大约 33%的饼图。</p><p id="9ae8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，要生成图像的负片，我们只需要从 255 减去原始亮度值。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="bc09" class="md me iq lz b gy mf mg l mh mi">plt.imshow(255-img)</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/80095fdf202256d57b9a10f908471416.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*fEYvFyM0cPyBZ5C_29YYHg.png"/></div></figure><p id="6688" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这么简单。但是让我们来硬的，看看会发生什么。首先，我们为 3 个颜色通道中的每一个通道生成一个反向像素阵列。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="51ec" class="md me iq lz b gy mf mg l mh mi">img_r_pixels_inv = 255 - img_r_pixels<br/>img_g_pixels_inv = 255 - img_g_pixels<br/>img_b_pixels_inv = 255 - img_b_pixels</span></pre><p id="6f18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们把这些组合成一个数组。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="0c1b" class="md me iq lz b gy mf mg l mh mi">pixels_inv = np.append(img_r_pixels_inv,(np.append(img_g_pixels_inv,img_b_pixels_inv)))</span></pre><p id="28f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们一个接一个地为每种颜色添加像素，现在如果我们检查<code class="fe nw nx ny lz b">pixel_inv</code>的<code class="fe nw nx ny lz b">shape</code>，我们将得到(145200，)即 220*220*3。接下来我们<code class="fe nw nx ny lz b">reshape</code>将这些像素还原到原始的三维空间并绘制图像。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="b80a" class="md me iq lz b gy mf mg l mh mi">img_inv = pixels_inv.reshape(220,220,3)<br/>plt.imshow(img_inv)</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/b229805d04edcf0ea2b354620d27e96e.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*erxrG-lTY4pdOhUCv6ueTA.png"/></div></figure><p id="6c3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很有趣，但这不是我们想要的形象。为什么会这样？如果你检查<code class="fe nw nx ny lz b">255-img</code>和<code class="fe nw nx ny lz b">img_inv</code>，你会发现它们是两个不同的数组。原因是在后一种方法中，我们首先堆叠所有的<strong class="kf ir"> R </strong>像素，然后是<strong class="kf ir"> G </strong>像素，最后是<strong class="kf ir"> B </strong>像素。我们应该做的是取第一个<strong class="kf ir"> R </strong>像素、第一个<strong class="kf ir"> G </strong>像素和第一个<strong class="kf ir"> B </strong>像素，它们将形成数组的第一个分量，并对所有像素重复同样的操作。</p><p id="1a60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们试试别的东西。让我们首先用全零初始化一个(220，220，3)数组<code class="fe nw nx ny lz b">img_inv</code>。然后，我们为 3 个通道中的每一个找到逆像素。我们使用两个循环，找到每个颜色通道的<code class="fe nw nx ny lz b">i*j</code>像素的倒数。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="c97a" class="md me iq lz b gy mf mg l mh mi">img_inv = np.zeros((220,220,3))<br/>for i in range(220):<br/>    for j in range(220):<br/>        img_inv[i][j][0] = 255 - img_r_pixels[i*j]<br/>        img_inv[i][j][1] = 255 - img_g_pixels[i*j]<br/>        img_inv[i][j][2] = 255 - img_b_pixels[i*j]</span></pre><p id="6208" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果我们检查<code class="fe nw nx ny lz b">img_inv</code>，我们将得到一个看起来像这样的图像</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/919305acbefb2ad01357ceaec7e44446.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*J9curGWVRKFDM0oL84oTaw.png"/></div></figure><p id="87c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那确实是一件很好的艺术品，但不是我们想要的。然而，我们可以看到，这可以用来如果你想加密你的图像。当然，这是一种非常幼稚的加密方法，但如果你愿意，你也可以这样做。</p><p id="3cea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的方法行不通，因为我们不想要第<code class="fe nw nx ny lz b">i*j</code>个像素；我们想要第<code class="fe nw nx ny lz b">[i][j]</code>个像素。让我们最终做到这一点。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="2c75" class="md me iq lz b gy mf mg l mh mi">img_inv = np.zeros((220,220,3))<br/>for i in range(220):<br/>    for j in range(220):<br/>        img_inv[i][j][0] = 255 - img_r[i][j]<br/>        img_inv[i][j][1] = 255 - img_g[i][j]<br/>        img_inv[i][j][2] = 255 - img_b[i][j]</span></pre><p id="d2d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们在<code class="fe nw nx ny lz b">img_inv</code>中有了我们需要的负像。</p><p id="c807" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们使用<code class="fe nw nx ny lz b">savefig</code>将该图像保存为一个新文件。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="6fc0" class="md me iq lz b gy mf mg l mh mi">plt.axis('off')<br/>plt.savefig('lenna_negative.png',dpi=300)</span></pre><p id="c83b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nw nx ny lz b">plt.axis('off')</code>从图像中删除轴和标签。<code class="fe nw nx ny lz b">savefig</code>的第一个参数是文件名，而<code class="fe nw nx ny lz b">dpi</code>定义了我们希望图像拥有的每英寸点数。</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/d9f0553b0d8055c08857285dfafc7d9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*IqsT73CX-dNqMKtfq2SOjQ.png"/></div></figure><p id="bded" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图像将保存在记事本所在的文件夹中。您可以提供一个不同的路径来将其保存在您想要的位置。</p><h1 id="9b78" class="mj me iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">所以，pyplot 只对图像起作用？</h1><p id="13ea" class="pw-post-body-paragraph kd ke iq kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">不，绝对不行。这只是一个应用。事实上，大多数时候，我们会处理文本数据。就像我们接下来要看的一样。</p><p id="5948" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们离开图像。在本节中，我们将使用温度变化数据集，通过 pyplot 探索更多的曲线图。</p><h1 id="5b2b" class="mj me iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">问题 2</h1><p id="68e4" class="pw-post-body-paragraph kd ke iq kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">给定来自<a class="ae kc" href="https://www.kaggle.com/berkeleyearth/climate-change-earth-surface-temperature-data" rel="noopener ugc nofollow" target="_blank">Kaggle</a>上此链接的 globallandtemperaturesbycount . CSV 数据集，使用 1960 年至 2009 年期间的数据</p><p id="c473" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">a)显示尼泊尔的年气温</p><p id="0097" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">b)比较美国、英国和中国的年气温</p><p id="fdc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">c)从(b)中找出温度的平均值和范围</p><h1 id="736f" class="mj me iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">解决方案 2</h1><p id="ed9b" class="pw-post-body-paragraph kd ke iq kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">数据集在一个 csv 文件<code class="fe nw nx ny lz b">GlobalLandTemperaturesByCountry.csv</code>中，所以让我们首先使用 pandas 来读取它。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="eeb8" class="md me iq lz b gy mf mg l mh mi">import pandas as pd<br/>df = pd.read_csv('GlobalLandTemperaturesByCountry.csv')</span></pre><p id="5d25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们检查这个数据帧的<code class="fe nw nx ny lz b">info</code>，我们会看到它有 4 列— <code class="fe nw nx ny lz b">dt</code>即日期、<code class="fe nw nx ny lz b">AverageTemperature</code>、<code class="fe nw nx ny lz b">AverageTemperatureUncertainty</code>和<code class="fe nw nx ny lz b">Country</code>。您可以使用<code class="fe nw nx ny lz b">head</code>或<code class="fe nw nx ny lz b">tail</code>查看更多信息，它列出了从 1743 年到 2013 年所有国家的月平均气温。一些月份的数据丢失了。很难看到所有这些数据，所以让我们只看一个特定的国家。在这里，我们看看尼泊尔。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="4f83" class="md me iq lz b gy mf mg l mh mi">df_nepal = df[df['Country']=='Nepal']</span></pre><p id="7f53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们只有<code class="fe nw nx ny lz b">df_nepal</code>中尼泊尔的条目。如果我们检查<code class="fe nw nx ny lz b">info</code>，我们看到它仍然有 2613 个条目。我们不想要 18 世纪的数据。此外，很多 20 世纪以前的数据都丢失了。所以，让我们来看看从 1960 年初到 2009 年底的 50 年间的数据。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="7dfe" class="md me iq lz b gy mf mg l mh mi">df_nepal = df_nepal[(df_nepal['dt'] &gt;= '1960-01-01') &amp; (df_nepal['dt'] &lt; '2010-01-01')]</span></pre><p id="12f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们过滤掉数据，只剩下 600 个条目。现在我们有 50 年的月平均气温。让我们把它改成年平均温度。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="f170" class="md me iq lz b gy mf mg l mh mi">start_year = 1960<br/>year = np.zeros(50)<br/>avg_temp = np.zeros(50)<br/>for i in range(0,df_nepal.shape[0],12):<br/>    new_df_index = int(((i+12)/12)) - 1<br/>    year[new_df_index] = start_year + new_df_index<br/>    avg_temp[new_df_index] = np.mean(<br/>                      [df_nepal.iloc[i:i+12]['AverageTemperature']])<br/>df_nepal_annual = pd.DataFrame([],columns=['year','avg_temp'])<br/>df_nepal_annual['year'] = year<br/>df_nepal_annual['avg_temp'] = avg_temp</span></pre><p id="3558" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从<code class="fe nw nx ny lz b">start_year = 1960</code>开始，设置<code class="fe nw nx ny lz b">year</code>和<code class="fe nw nx ny lz b">avg_temp</code>保存 50 年及其各自的年平均温度，并暂时将其设置为全零。接下来，我们遍历 600 个条目，其中 600 由<code class="fe nw nx ny lz b">df_nepal.shape[0]</code>给出，我们采取 12 的步骤，以便每 12 个条目被分组在一起，并且结果由<code class="fe nw nx ny lz b">new_df_index</code>给出的单个索引来表示。使用此<code class="fe nw nx ny lz b">new_df_index</code>，条目被追加到<code class="fe nw nx ny lz b">year</code>和<code class="fe nw nx ny lz b">avg_temp</code>中。对于<code class="fe nw nx ny lz b">avg_temp</code>中的每个条目，取连续 12 行的平均值，并设置为当年的年平均温度。最后，创建一个新的数据帧<code class="fe nw nx ny lz b">df_nepal_annual</code>，并将<code class="fe nw nx ny lz b">year</code>和<code class="fe nw nx ny lz b">avg_temp</code>的更新数组设置到该数据帧的列中。</p><p id="d274" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们现在检查<code class="fe nw nx ny lz b">df_nepal_annual</code>，这个数据帧中正好有 50 个条目，只有两列——year 和 avg_temp。我们现在可以绘制 avg_temp 对应的年份</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="17bf" class="md me iq lz b gy mf mg l mh mi">plt.plot(df_nepal_annual['year'],df_nepal_annual['avg_temp'])</span></pre><p id="fbb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以获得以下情节。</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/c9b544c849e47d231e9463cbdf9af492.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*qm2NZqqEff1pgaQosO4JVg.png"/></div></figure><p id="3e38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，在过去的半个世纪里，尼泊尔的气温一直在稳步上升。</p><p id="1a3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们想将同样的概念扩展到绘制其他国家的温度。这里，我们来看看三个国家——美国、英国和中国。因为我们将对所有国家做同样的事情，所以让我们把上面的代码放到函数中。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="7588" class="md me iq lz b gy mf mg l mh mi">def getDataForCountry(df,countryName):<br/>    df_country = df[df['Country']==countryName]<br/>    return df_country[(df_country['dt'] &gt;= '1960-01-01') &amp;   (df_country['dt'] &lt; '2010-01-01')]</span></pre><p id="5252" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nw nx ny lz b">getDataForCountry</code>提取 1960 年至 2009 年(含)50 年间的数据。</p><p id="ef5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们定义另一个函数来计算年平均温度。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="bcef" class="md me iq lz b gy mf mg l mh mi">def getAvgTempByYear(df):<br/>    start_year = 1960<br/>    year = np.zeros(50)<br/>    avg_temp = np.zeros(50)<br/>    for i in range(0,df.shape[0],12):<br/>        new_df_index = int(((i+12)/12)) - 1<br/>        year[new_df_index] = start_year + new_df_index<br/>        avg_temp[new_df_index] = np.mean([df.iloc[i:i+12]['AverageTemperature']])<br/>    df_annual = pd.DataFrame([],columns=['year','avg_temp'])<br/>    df_annual['year'] = year<br/>    df_annual['avg_temp'] = avg_temp<br/>    return df_annual</span></pre><p id="e87c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，使用这个函数<code class="fe nw nx ny lz b">getAvgTempByYear</code>，我们可以对所有三个国家进行计算。为了更好地进行比较，让我们在一个图中绘制所有国家的图表。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="7423" class="md me iq lz b gy mf mg l mh mi">df_usa = getDataForCountry(df,'United States')<br/>df_usa = getAvgTempByYear(df_usa)<br/>plt.plot(df_usa['year'],df_usa['avg_temp'],'r--')</span><span id="a740" class="md me iq lz b gy oc mg l mh mi">df_uk = getDataForCountry(df,'United Kingdom')<br/>df_uk = getAvgTempByYear(df_uk)<br/>plt.plot(df_uk['year'],df_uk['avg_temp'])</span><span id="9afc" class="md me iq lz b gy oc mg l mh mi">df_china = getDataForCountry(df,'China')<br/>df_china = getAvgTempByYear(df_china)<br/>plt.plot(df_china['year'],df_china['avg_temp'],'#0be3df')</span></pre><p id="f3ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用红色虚线<code class="fe nw nx ny lz b">r--</code>，使用类似<code class="fe nw nx ny lz b">#0be3df</code>的六进制代码，或者简单地使用默认颜色，而不需要明确定义。最终的图看起来会像这样</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ox"><img src="../Images/a102b108dda532b3dbb3856dceb779dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*c7VUeh5RXKx5qjYIJA-T5Q.png"/></div></div></figure><p id="9d48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们也为这些线条添加一个图例。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="4ccc" class="md me iq lz b gy mf mg l mh mi">plt.legend(['USA','UK','China'],loc=(0.2,0.25))</span></pre><p id="814d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个参数是标签，第二个参数是<code class="fe nw nx ny lz b">loc</code>，它是图例的位置。<code class="fe nw nx ny lz b">loc</code>当给定一个元组时，将图例放置在绘图左下方的该百分比处。所以在这种情况下，20%来自左边，25%来自底部。</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oy"><img src="../Images/164514d1379ec298a935deae7a42cb93.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*hELy66ZKLHCV8K2wB23gzQ.png"/></div></div></figure><p id="200a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可能很难手动确定图例的最佳放置位置。因此，我们可以使用<code class="fe nw nx ny lz b">loc='best'</code>，pyplot 将图例放在可能的最佳位置。这一次，让我们也加入一个网格，这样就可以很容易地可视化这些值。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="00de" class="md me iq lz b gy mf mg l mh mi">plt.legend(['USA','UK','China'],loc='best')<br/>plt.grid()</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/3c28dac2991807842bc1488572c488bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*YFX81H6aL_IS9oH2R1h1gw.png"/></div></figure><p id="8faf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，左上角似乎是这个剧情传说的最佳位置。正如我们所看到的，美国和英国的气温变化非常相似，在 20 世纪 70 年代末到 80 年代初有所不同，在 80 年代末，美国似乎每年都比英国热。这些年中国似乎相对更冷。</p><p id="8216" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后给三国画个<code class="fe nw nx ny lz b">boxplot</code>。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="aa59" class="md me iq lz b gy mf mg l mh mi">plt.boxplot([df_usa['avg_temp'],df_uk['avg_temp'],df_china['avg_temp']],labels=['USA','UK','China'])</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/fb9bd0f309daab79c75673cf4586607c.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*KeQ-GgWAxzcXdJYst_TQnQ.png"/></div></figure><p id="514a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用单个箱线图可以传达许多信息，如中位数、四分位数和极差。盒状图由盒状图和须状图组成。根据文件，方框从数据的下四分位数延伸到上四分位数，中间有一条线。触须从框中延伸出来，以显示数据的范围。</p><p id="f820" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">美国和英国的平均气温非常接近 9 度，而中国的平均气温在 7 度左右。美国的范围超过 1.5，最高和最低温度分别略高于 10 度和低于 8.5 度。中国也有 1.5 左右的类似区间。英国的范围约为 2。</p><p id="2ba5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可视化是一种重要的技术，通过这种技术，大量的信息可以以一种更紧凑的方式传达。此外，它比纯文本、数字和表格更具视觉吸引力。和往常一样，这并不是 pyplot 所能做的详尽列表。但现在如果我们需要任何情节，至少我们知道去哪里找。</p></div></div>    
</body>
</html>