<html>
<head>
<title>Build your own Python RESTful Web Service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建自己的 Python RESTful Web 服务</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-your-own-python-restful-web-service-840ed7766832?source=collection_archive---------0-----------------------#2018-07-30">https://towardsdatascience.com/build-your-own-python-restful-web-service-840ed7766832?source=collection_archive---------0-----------------------#2018-07-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c34a84c252101556beb2df22e2567ad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WiAWFdpD1x8njiIs"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">“An overhead shot of strawberry and blackberry pies next to a white coffee pot and a bunch of flowers” by <a class="ae kc" href="https://unsplash.com/@brookelark?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Brooke Lark</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="36a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇博客中，我将解释我是如何创建一个 RESTful web 服务来充当数据工程服务的。web 服务是通过一个<strong class="kf ir"> Docker </strong>容器中的 python web framework<strong class="kf ir">CherryPy</strong>提供的。以下是如何使用 3 个文件和不到 30 行代码实现这一目标的分步说明。</p><p id="1e08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一步是通过安装<a class="ae kc" href="https://www.docker.com/get-docker" rel="noopener ugc nofollow" target="_blank"> Docker </a>、<a class="ae kc" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank"> Python 3 </a>和以下 Python 库来设置开发环境:</p><ul class=""><li id="ece8" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">pandas——用于对数据集执行聚合</li><li id="49fb" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">CherryPy  -服务于 web 服务的 web 框架</li></ul><p id="f843" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些库可以使用<em class="lp"> pip </em>命令安装:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="296a" class="lz ma iq lv b gy mb mc l md me">&gt;&gt; pip install pandas<br/>&gt;&gt; pip install CherryPy</span></pre><p id="f9b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们首先编写一个简单的数据处理器<em class="lp"> myprocessor.py </em>:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="04ae" class="lz ma iq lv b gy mb mc l md me">class MyProcessor:     </span><span id="3d21" class="lz ma iq lv b gy mf mc l md me">    def run(self, df):        <br/>        return df.agg(['mean', 'min', 'max'])</span></pre><p id="242f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该处理器计算输入数据帧所有列的平均值、最小值和最大值。</p><p id="70b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在同一个目录中，我们创建一个 web 服务脚本<em class="lp"> ws.py </em>，它包含请求处理程序的定义:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="63c8" class="lz ma iq lv b gy mb mc l md me"><strong class="lv ir">import </strong>cherrypy<br/><strong class="lv ir">import </strong>pandas <strong class="lv ir">as </strong>pd<br/><strong class="lv ir">import </strong>myprocessor</span><span id="1b3e" class="lz ma iq lv b gy mf mc l md me">p = myprocessor.MyProcessor()<br/><br/><strong class="lv ir">class MyWebService</strong>(object):<br/><br/>   @cherrypy.expose<br/>   @cherrypy.tools.json_out()<br/>   @cherrypy.tools.json_in()<br/>   <strong class="lv ir">def process</strong>(self):<br/>      data = cherrypy.request.json<br/>      df = pd.DataFrame(data)<br/>      output = p.run(df)<br/>      <strong class="lv ir">return </strong>output.to_json()</span><span id="11bd" class="lz ma iq lv b gy mf mc l md me"><strong class="lv ir">if </strong>__name__ == '__main__':<br/>      ...</span></pre><p id="bbce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该处理程序接受指向<em class="lp"> /process </em>端点的请求，并期望输入数据在请求体中表示为 JSON 字符串。处理的结果将作为 JSON 字符串返回——使用 panda <em class="lp"> to_json() </em>方法方便地进行转换。</p><p id="f9f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来是在<em class="lp"> ws.py </em>的主要部分启动 web 服务的代码:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="4d4d" class="lz ma iq lv b gy mb mc l md me"><strong class="lv ir">if </strong>__name__ == '__main__':<br/>   config = {'server.socket_host': '0.0.0.0'}<br/>   cherrypy.config.update(config)<br/>   cherrypy.quickstart(MyWebService())</span></pre><p id="d20d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">myprocessor.py 和 ws.py 都是 web 服务所需要的。我们现在可以使用以下 python 命令启动 web 服务:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="6ab6" class="lz ma iq lv b gy mb mc l md me">&gt;&gt; python ws.py<br/>[24/Jul/2018:11:13:53] ENGINE Listening for SIGTERM.<br/>[24/Jul/2018:11:13:53] ENGINE Listening for SIGHUP.<br/>[24/Jul/2018:11:13:53] ENGINE Listening for SIGUSR1.<br/>[24/Jul/2018:11:13:53] ENGINE Bus STARTING</span><span id="aab7" class="lz ma iq lv b gy mf mc l md me">[24/Jul/2018:11:13:53] ENGINE Started monitor thread 'Autoreloader'.<br/>[24/Jul/2018:11:13:53] ENGINE Started monitor thread '_TimeoutMonitor'.<br/>[24/Jul/2018:11:13:53] ENGINE Serving on <a class="ae kc" href="http://0.0.0.0:8080" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:8080</a><br/>[24/Jul/2018:11:13:53] ENGINE Bus STARTED</span></pre><p id="609a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哒哒！这里是我们的网络服务运行在任何时候。</p><p id="a40b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 Linux 系统中，我们可以使用<em class="lp"> curl </em>发送这个 POST 请求来验证 REST API 是否正常工作:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="091c" class="lz ma iq lv b gy mb mc l md me">&gt;&gt; <!-- -->curl -d '{"num1" : [1, 2, 3], "num2":[4, 5, 6]}' -H "Content-Type: application/json" -X POST <a class="ae kc" href="http://localhost:8080/process" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/process</a></span><span id="33cc" class="lz ma iq lv b gy mf mc l md me">"{\"num1\":{\"mean\":2.0,\"min\":1.0,\"max\":3.0},\"num2\":{\"mean\":5.0,\"min\":4.0,\"max\":6.0}}"</span></pre><p id="436b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">预期结果是一个数据集，包括发送到 web 的两组数字的平均值、最小值和最大值。</p><p id="b330" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">码头集装箱</strong></p><p id="f39e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要编写一个<em class="lp"> Dockerfile — </em>这是一个文本文件，用于设置 web 服务将要运行的环境。如果你以前没有使用过 Docker，我建议至少阅读一下<a class="ae kc" href="https://docs.docker.com/get-started/" rel="noopener ugc nofollow" target="_blank"> Docker 入门文档</a>，这样你就可以熟悉 Docker 的概念。文件中的第一行声明使用<em class="lp">python:3 . 6 . 4-slim-Jessie</em>作为基础映像:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="6d73" class="lz ma iq lv b gy mb mc l md me">from python:3.6.4-slim-jessie</span></pre><p id="5d3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个<em class="lp"> </em>是<a class="ae kc" href="https://hub.docker.com/_/python/" rel="noopener ugc nofollow" target="_blank">官方 Python Linux 映像</a>之一，预装了 Python 3 的普通版本，还有许多其他映像可以从 Docker 存储库中选择，但这是一个精简版本，足以运行一个简单的服务。就像我们必须安装额外的 python 包来本地运行 web 服务一样，在构建 docker 映像时也需要这样做:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="a400" class="lz ma iq lv b gy mb mc l md me">RUN pip install pandas<br/>RUN pip install CherryPy</span></pre><p id="55f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，构建过程需要将 web 服务文件复制到默认的工作目录中:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="6b11" class="lz ma iq lv b gy mb mc l md me">COPY myprocessor.py .<br/>COPY ws.py .</span></pre><p id="0ef5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">容器需要公开端口 8080 以允许访问:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="7f23" class="lz ma iq lv b gy mb mc l md me">EXPOSE 8080</span></pre><p id="4257" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lp">docker 文件</em>中的最后一条语句定义了容器启动时要运行的命令:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="0c7b" class="lz ma iq lv b gy mb mc l md me">ENTRYPOINT ["python", "ws.py"]</span></pre><p id="0d1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是完成的<em class="lp">docker 文件</em>的样子，它应该与之前编写的 python 脚本驻留在同一个目录中:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="94e2" class="lz ma iq lv b gy mb mc l md me">from python:3.6.4-slim-jessie</span><span id="ead1" class="lz ma iq lv b gy mf mc l md me">RUN pip install pandas<br/>RUN pip install CherryPy<br/>COPY myprocessor.py .<br/>COPY ws.py .<br/>EXPOSE 8080<br/>ENTRYPOINT ["python", "ws.py"]</span></pre><p id="6330" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了执行 docker build 命令，我们停留在创建了<em class="lp"> Dockerfile </em>的目录中。为 docker 映像分配一个标记是一个很好的做法，这个标记可以在以后引用，因此我们使用带有-t 标记的 build 命令来构建映像:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="d48d" class="lz ma iq lv b gy mb mc l md me">&gt;&gt; docker build -t python-ws .</span></pre><p id="f349" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在已经准备好了一个 docker 图像，让我们试一试:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="fc0b" class="lz ma iq lv b gy mb mc l md me">&gt;&gt; docker run -p 8080:8080 python-ws</span></pre><p id="de1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该命令以附加模式启动容器，因此 Cherrypy 日志将立即出现在控制台中。同样，之前用于测试的相同 curl 命令也应该工作，因为主机(localhost)现在将定向到端口 8080 的请求转发到正在运行的 docker 容器。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="7926" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经演示了如何构建一个简单的 RESTful web 服务，但是这个服务还远远不能用于生产。如果 web 服务托管在公共云中，应采取额外的安全措施，例如 HTTPS 连接、某种形式的身份验证。如何启用这些安全特性的示例代码可以在我的<a class="ae kc" href="https://github.com/hungapl/python-ws" rel="noopener ugc nofollow" target="_blank"> GitHub 项目</a>中找到。Cherrypy 教程页面提供了许多关于如何定制 web 服务的例子。</p></div></div>    
</body>
</html>