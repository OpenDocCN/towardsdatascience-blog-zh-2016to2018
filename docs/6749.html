<html>
<head>
<title>Music Feature Extraction in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的音乐特征提取</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/extract-features-of-music-75a3f9bc265d?source=collection_archive---------2-----------------------#2018-12-30">https://towardsdatascience.com/extract-features-of-music-75a3f9bc265d?source=collection_archive---------2-----------------------#2018-12-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b88d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">不同类型的音频特征以及如何提取它们。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/65a96d62be490af5cda1417dbd403148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kLLpD8FvzOcMmuxf4cT0Pw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">MFCC feature extraction</figcaption></figure><p id="a6be" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">特征提取是分析和发现不同事物之间关系的一个非常重要的部分。所提供的音频数据不能被模型直接理解以将它们转换成可理解的格式，使用特征提取。这是一个以可理解的方式解释大部分数据的过程。分类、预测和推荐算法都需要特征提取。</p><p id="f48e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个博客中，我们将提取音乐文件的特征，这将有助于我们将音乐文件分类为不同的流派，或者根据您的喜好推荐音乐。我们将学习用于提取音乐特征的不同技术。</p><p id="5d2d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">音频信号是三维信号，其中三个轴代表时间、振幅和频率。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/e1d7e15da10032e9130faa26d5c7d29f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*7sKM9aECRmuoqTadCYVw9A.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Audio signal</figcaption></figure><p id="57dd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">要使用的包</strong></p><p id="a2f1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将使用<a class="ae ls" href="https://librosa.github.io/librosa/" rel="noopener ugc nofollow" target="_blank"> librosa </a>来分析和提取音频信号的特征。为了播放音频，我们将使用<a class="ae ls" href="https://people.csail.mit.edu/hubert/pyaudio/docs/" rel="noopener ugc nofollow" target="_blank"> pyAudio </a>，这样我们就可以直接在 jupyter 上播放音乐。</p><p id="18c1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">加载音频</strong></p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="53ec" class="ly lz iq lu b gy ma mb l mc md">import librosa<br/>audio_path = 'audio-path'<br/>x , sr = librosa.load(audio_path)<br/>print(type(x), type(sr))</span></pre><p id="ef12" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe me mf mg lu b">.load</code>加载一个音频文件，解码成一维数组，一维数组是时间序列<code class="fe me mf mg lu b">x</code>，<code class="fe me mf mg lu b">sr</code>是采样率<code class="fe me mf mg lu b">x</code>。默认<code class="fe me mf mg lu b">sr</code>是 22kHz。我们可以通过以下方式覆盖<code class="fe me mf mg lu b">sr</code></p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="dd4a" class="ly lz iq lu b gy ma mb l mc md">librosa.load(audio_path, sr=44100)</span></pre><p id="5816" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以通过以下方式禁用采样:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="2300" class="ly lz iq lu b gy ma mb l mc md">librosa.load(audio_path, sr=none)</span></pre><p id="5ccd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">播放音频</strong></p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="1106" class="ly lz iq lu b gy ma mb l mc md">import IPython.display as ipd<br/>ipd.Audio(audio_path)</span></pre><p id="523c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe me mf mg lu b">IPython.display</code>允许我们直接在 jupyter 笔记本上播放音频。它有一个非常简单的界面，有一些基本的按钮。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="142a" class="ly lz iq lu b gy ma mb l mc md">#display waveform<br/>%matplotlib inline<br/>import matplotlib.pyplot as plt<br/>import librosa.display<br/>plt.figure(figsize=(14, 5))<br/>librosa.display.waveplot(x, sr=sr)</span></pre><p id="17a4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe me mf mg lu b">librosa.display</code>用于显示不同格式的音频文件，如波形图、声谱图或色彩图。波形图让我们知道在给定时间音频的响度。频谱图显示了在特定时间播放的不同频率及其振幅。振幅和频率是声音的重要参数，对于每个音频都是唯一的。<code class="fe me mf mg lu b">librosa.display.waveplot</code>用于绘制振幅对时间的波形，其中第一轴为振幅，第二轴为时间。</p><p id="6ee0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">频谱图</strong></p><p id="c9ff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">声谱图是<a class="ae ls" href="https://en.wikipedia.org/wiki/Sound" rel="noopener ugc nofollow" target="_blank">声音</a>的<a class="ae ls" href="https://en.wikipedia.org/wiki/Frequencies" rel="noopener ugc nofollow" target="_blank">频率</a>的<a class="ae ls" href="https://en.wikipedia.org/wiki/Spectral_density" rel="noopener ugc nofollow" target="_blank">频谱</a>或其他信号随时间变化的直观表示。它代表了给定音乐信号的频率随时间的变化。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="09ec" class="ly lz iq lu b gy ma mb l mc md">#display Spectrogram<br/>X = librosa.stft(x)<br/>Xdb = librosa.amplitude_to_db(abs(X))<br/>plt.figure(figsize=(14, 5))<br/>librosa.display.specshow(Xdb, sr=sr, x_axis='time', y_axis='hz') <br/>#If to pring log of frequencies  <br/>#librosa.display.specshow(Xdb, sr=sr, x_axis='time', y_axis='log')<br/>plt.colorbar()</span></pre><p id="86fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe me mf mg lu b">.stft</code>将数据转换成短期傅立叶变换。<a class="ae ls" href="https://www.youtube.com/watch?v=g1_wcbGUcDY" rel="noopener ugc nofollow" target="_blank"> STFT </a>转换信号，这样我们就可以知道给定时间给定频率的幅度。使用 STFT，我们可以确定音频信号在给定时间播放的各种频率的幅度。<code class="fe me mf mg lu b">.specshow</code>用于显示频谱图。</p><p id="d5d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">输出如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mh"><img src="../Images/535d5e1a14f13292f04de023a702a426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZaPCkJjxRHfyYUcVC1cq2g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">spectrum</figcaption></figure><h1 id="e5e1" class="mi lz iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated"><strong class="ak">特征提取</strong></h1><p id="3d02" class="pw-post-body-paragraph kv kw iq kx b ky mz jr la lb na ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated"><strong class="kx ir">过零率</strong></p><p id="9bda" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">过零率是信号符号变化的速率，即信号从正变到负或反变的速率。这个特性已经在语音识别和音乐信息检索中大量使用。它通常具有较高的值，适用于像金属和摇滚这样的高敲击声。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="26eb" class="ly lz iq lu b gy ma mb l mc md">x, sr = librosa.load(audio_path)<br/>#Plot the signal:<br/>plt.figure(figsize=(14, 5))<br/>librosa.display.waveplot(x, sr=sr)</span></pre><p id="8b9e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">放大:</strong></p><p id="2661" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里我们将只缩放或打印 100 个阵列列的光谱。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="e124" class="ly lz iq lu b gy ma mb l mc md"># Zooming in<br/>n0 = 9000<br/>n1 = 9100<br/>plt.figure(figsize=(14, 5))<br/>plt.plot(x[n0:n1])<br/>plt.grid()</span></pre><p id="5501" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">情节看起来像:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/a4fcd564ea2745854aea2a21abfc34e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*scDEE3LEYKh0YG7DkgBP0A.png"/></div></div></figure><p id="3c74" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如我们所见，在给定的图表中有三个过零点。</p><p id="410d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们也可以使用给定代码计算过零事件:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="441e" class="ly lz iq lu b gy ma mb l mc md">zero_crossings = librosa.zero_crossings(x[n0:n1], pad=False)<br/>print(sum(zero_crossings))</span></pre><p id="3a6b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">光谱质心</strong></p><p id="dc08" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它表示声音的“质量中心”所在的位置，计算方法是声音中频率的加权平均值。如果音乐中的频率始终相同，那么频谱质心将围绕一个中心，如果在声音的末端有高频，那么质心将朝向其末端。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="e70d" class="ly lz iq lu b gy ma mb l mc md">#spectral centroid -- centre of mass -- weighted mean of the frequencies present in the sound<br/>import sklearn<br/>spectral_centroids = librosa.feature.spectral_centroid(x, sr=sr)[0]<br/>spectral_centroids.shape</span><span id="9548" class="ly lz iq lu b gy nf mb l mc md"># Computing the time variable for visualization<br/>frames = range(len(spectral_centroids))<br/>t = librosa.frames_to_time(frames)<br/># Normalising the spectral centroid for visualisation<br/>def normalize(x, axis=0):<br/>    return sklearn.preprocessing.minmax_scale(x, axis=axis)<br/>#Plotting the Spectral Centroid along the waveform<br/>librosa.display.waveplot(x, sr=sr, alpha=0.4)<br/>plt.plot(t, normalize(spectral_centroids), color='r')</span></pre><p id="d603" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe me mf mg lu b">.spectral_centroid</code>用于计算每一帧的光谱质心。所以它将返回一个数组，其列数等于样本中的帧数。</p><p id="a5f3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe me mf mg lu b">.frames_to_time</code>将帧转换为时间。时间[i] ==帧[i]。</p><p id="96fd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们正在标准化，以便我们可以轻松地可视化数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/754344f276dfbd83cc7e11cda5e354e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*Ekw65hA93Zf_azmPJj8FMA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">spectral centroid</figcaption></figure><p id="f97d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与过零率类似，在信号开始时，频谱质心会出现杂散上升。这是因为开始时的静音幅度很小，高频成分有机会占主导地位。</p><p id="f772" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">光谱衰减</strong></p><p id="21c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">频谱<strong class="kx ir"> </strong>衰减是总频谱能量的指定百分比(例如 85%)低于的频率。</p><p id="c052" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它也给出了每一帧的结果。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="0b90" class="ly lz iq lu b gy ma mb l mc md">spectral_rolloff = librosa.feature.spectral_rolloff(x, sr=sr)[0]<br/>librosa.display.waveplot(x, sr=sr, alpha=0.4)<br/>plt.plot(t, normalize(spectral_rolloff), color='r')</span></pre><p id="2fff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe me mf mg lu b">.spectral_rolloff</code>用于计算给定帧的滚降。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/15ff978c4aca7477d2f0e45a5c1699e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*4N7e-MMvWfT_2JwjXda-bg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Spectral Rolloff</figcaption></figure><p id="6336" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> MFCC —梅尔频率倒谱系数</strong></p><p id="c74b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该特征是提取音频信号特征的最重要的方法之一，并且主要在处理音频信号时使用。信号的 mel 频率倒谱系数(MFCCs)是一小组特征(通常约 10–20)，它们简明地描述了频谱包络的整体形状。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="6ad2" class="ly lz iq lu b gy ma mb l mc md">mfccs = librosa.feature.mfcc(x, sr=sr)<br/>print(mfccs.shape)</span><span id="0e6e" class="ly lz iq lu b gy nf mb l mc md">#Displaying  the MFCCs:<br/>librosa.display.specshow(mfccs, sr=sr, x_axis='time')</span></pre><p id="1e9d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe me mf mg lu b">.mfcc</code>用于计算信号的 mfccs。</p><p id="6e8f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过打印 MFCC 的形状，你可以得到多少 MFCC 是根据多少帧计算的。第一个值表示计算的 mfccs 的数量，另一个值表示可用的帧数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/4e43eaf6c6c11eb73687f6d2b662a203.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*D6hkd_jL2Ee_ZIEBPHgUtQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">MFCC</figcaption></figure><p id="69ea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们已经提取了音乐信号的特征。我们可以使用在各种用例中提取的这个特征，例如分类成不同的流派。我们将在我们的<a class="ae ls" href="https://medium.com/@sdoshi579/classification-of-music-into-different-genres-using-keras-82ab5339efe0" rel="noopener">下一篇博客</a>中实现这一点。</p></div></div>    
</body>
</html>