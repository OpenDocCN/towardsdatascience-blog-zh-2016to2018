# 只是另一个试图预测股市的人工智能:第二部分

> 原文：<https://towardsdatascience.com/just-another-ai-trying-to-predict-the-stock-market-part-2-88605f9d8e45?source=collection_archive---------3----------------------->

![](img/9276ed13ddfd3e6b33005de5877ea239.png)

在本节中，我将向您展示如何使用来自[第 1 部分](/just-another-ai-trying-to-predict-the-stock-market-part-1-d0663673a30e)的数据训练模型。我们挑选了一份过去 50 年中每天的标准普尔 500 指数价格清单，并对其做了一些修改。**现在我们要训练我们的模型**，让它尽可能准确地预测未来价格。

在上一部分中，我们使用`load_data`函数和定义为`df_stock`矩阵的价格值将数据分为训练/验证/测试。它是按如下方式完成的:

`x_train, y_train, x_valid, y_valid, x_test, y_test = load_data(df_stock, seq_len)`在哪里`seq_len = 20`。如果你从[我的上一篇文章](/just-another-ai-trying-to-predict-the-stock-market-part-1-d0663673a30e)中考察`load_data`的实现，你会对`seq_len`有更好的理解。基本上，它将数据分成更大的 20 个元素的块。

## #1.定义超参数

当建立机器学习模型时，需要定义一组直接反映模型性能的参数。当你自己做的时候，你可能会发现自己花了太多的时间在调整正确的组合和评估基于你的选择的模型上。在本例中，我们将浏览预定义的，但可以随意更改它们并进行实验。

*   `n_steps = seq_len-1`:输入(训练)数据的第一维度。
*   `n_inputs = 4`:输入(训练)数据的第二维——不同种类的价格(“开盘价”、“收盘价”、“最高价”、“最低价”)。
*   `n_neurons = 200`:用于表示我们 GRU 单元格中隐藏状态的维度。使用隐藏层的数量和输入数据的大小来确定维度。想了解更多信息，我推荐参考这个 Quora 回答。
*   `n_outputs = 4`:神经网络输出层的维度。
*   `n_layers = 2`:我们希望我们的网络由多少个 GRU 细胞组成。
*   `learning_rate = 0.001`:当我们使用梯度下降(或另一个优化器)来最小化损失函数以校正权重和偏差时，使用该比率。
*   通常，在训练时，一次使用全部数据是低效的。这就是为什么我们迭代一组长度为 50 的批处理。
*   `n_epochs = 100`:帮助确定训练迭代的次数，每个迭代使用不同的批次。
*   `train_set_size = x_train.shape[0]`:也有助于确定训练迭代的次数。

## #2.设置图表

我们的下一步是使用上面的一些参数来建立训练图。但这意味着什么呢？术语“图形”来自张量流的构造方式。基本上，用 Tensorflow 建立模型时，首先需要建立架构(图)，然后使用适当的训练数据运行它。

首先是 GRU 层:

*   第 1 行:重置图形堆栈，为新的初始化做准备。
*   第 3–4 行:初始化输入和输出的张量流占位符。
*   第 6 行:使用张量流 GRU 单元格，我们将几个单元格(基于 n_layers 参数)组合成一个列表。GRU 单元用`num_units`和激活函数初始化，在这种情况下激活函数是`leaky_relu`。如上所述,`num_units`是隐藏状态的维度。[激活功能](/activation-functions-neural-networks-1cbd9f8d91d6)应用于结果值。
*   第 8–9 行:将 GRU 细胞堆叠成一个`multi_layer_cell`并运行 [tf.nn.dynamic_rnn](https://www.tensorflow.org/api_docs/python/tf/nn/dynamic_rnn) 来使用输入数据 x 创建递归神经网络
*   第 11 行:重塑网络输出。

现在我们需要添加输出层并设置损失函数:

使用`tf.layers.dense`添加最后一层，该层在对(输入*权重+偏差)应用激活函数后返回输出。

您可以从第 7–9 行看到优化器是如何使用学习率初始化的(我们使用 AdamOptimizer 而不是梯度下降)。然后，我们只需最小化损失函数，在这种情况下，就是均方误差。

如果你觉得有点困惑，把上面的方程看成一个黑盒，我会推荐你略读我之前关于[递归神经网络](/learn-how-recurrent-neural-networks-work-84e975feaaf7)的文章。如果你还有任何问题，就在评论区留下，我会跳出来讨论。

## #3.开始训练

现在最有趣的部分来了——训练模型。一般来说，如果你想得到一组可以做出准确预测的权重和偏差，你至少需要等几个小时。训练的速度取决于上面定义的超参数。

首先，我们将定义一个简单的函数`get_next_batch`，它将使用训练数据生成一批给定大小的数据:

*   第 1–3 行:从每批数据集中定义初始索引，并用 0 到`x_train.shape[0]-1`的值填充一个排列数组。
*   第 6 行:在已经声明的变量前使用 python 关键字`global`将允许我们从函数内部修改以反映全局范围。
*   最后，我们从`x_train`和`y_train`返回大小为`batch_size`的集合。

现在让我们运行图表来训练模型:

*   第 1 行:我们使用 Tensorflow 会话，它用于运行 Tensorflow 操作。
*   第 2 行:用`tf.global_variables_initializer()`我们初始化任何被声明的 Tensorflow 变量。在我们的例子中，我们没有任何。
*   第 3–11 行:我们通过多次迭代来训练模型——通过运行`training_op`,我们最小化了损失函数。第 8-11 行用于通知我们关于 out 培训的进度。
*   第 13、14、15 行:我们根据优化器模型计算输出。在第 3 部分，我们将比较`y_valid_pred`和`y_valid`以及`y_test_pred`和`y_test`，看看我们的模型表现如何。

## 在下一部分

通过以上培训，我们完成了系列的第 2 部分。在[的最后一部分](https://medium.com/p/ee2d419e00c3/edit)，我们将使用我们的模型进行预测，看看我们是否能够破解股票市场😄。

## 谢谢你的阅读。如果你喜欢这篇文章，给它一些掌声👏。希望你有一个伟大的一天！