<html>
<head>
<title>Data Science 101: Is Python better than R?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学 101:Python 比 R 好吗？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-science-101-is-python-better-than-r-b8f258f57b0f?source=collection_archive---------7-----------------------#2018-08-22">https://towardsdatascience.com/data-science-101-is-python-better-than-r-b8f258f57b0f?source=collection_archive---------7-----------------------#2018-08-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/88bfba655f5d8768af98fa6fbfb3c55f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NxVusBc0DRCZ58Be0oP5KA.jpeg"/></div></div></figure><p id="e288" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">几十年来，研究人员和开发人员一直在争论 Python 和 R 是数据科学和分析的更好语言。数据科学在包括生物技术、金融和社交媒体在内的多个行业中迅速发展。它的重要性不仅被在行业中工作的人们所认识，而且也被现在开始提供数据科学学位的学术机构所认识。随着开源技术迅速取代传统的闭源商业技术，Python 和 R 在数据科学家和分析师中变得非常流行。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi kw"><img src="../Images/219f42ac2ba048ad66bbac58d7bb37e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/0*nH24pLyFRLXXLhae"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">“Data science job growth chart — Indeed.com</figcaption></figure></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="6d6e" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">(非常)简短的介绍</strong></h1><p id="d6ab" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">Python 由吉多·范·罗苏姆发明，于 1991 年首次发布。<strong class="ka ir"> Python 2.0 </strong>发布于 2000 年，8 年后<strong class="ka ir"> Python 3.0 </strong>也发布了。<strong class="ka ir"> Python 3.0 </strong>有一些主要的语法修订，并且不向后兼容<strong class="ka ir"> Python 2.0 </strong>。然而，有一些 Python 库，比如<a class="ae mp" href="https://docs.python.org/2/library/2to3.html" rel="noopener ugc nofollow" target="_blank"> 2to3 </a>，可以自动完成两个版本之间的翻译。<strong class="ka ir"> Python 2.0 </strong>目前计划于 2020 年退役。</p><p id="ef2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">r 是 1995 年由 Ross Ihaka 和 Robert Gentleman 发明的。它最初是约翰·钱伯斯在 1976 年发明的 S 编程语言的一个实现。一个稳定的测试版本<strong class="ka ir"> 1.0.0 </strong>于 2000 年发布。目前由 R 开发核心团队维护，最新稳定版本为<strong class="ka ir"> 3.5.1 </strong>。与 Python 不同，R 在过去没有需要语法转换的重大变化。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/1a30cc127ca0efcbf727c06ee946e19a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qy7V6LFQtgWM4sJms586fg.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Guido van Rossum (left) Ross Ihaka (middle) Robert Gentleman (right)</figcaption></figure><p id="92e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Python 和 R 都有庞大的用户群体和支持。由 Stack Overflow 完成的 2017 年<a class="ae mp" href="https://insights.stackoverflow.com/survey/2017" rel="noopener ugc nofollow" target="_blank">调查</a>显示，几乎<strong class="ka ir"> 45% </strong>的数据科学家使用 Python 作为他们的主要编程语言。而 r 则被<strong class="ka ir"> 11.2% </strong>的数据科学家使用。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/391a22aaf9a37f091fcfd59973714e4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JMP0SgtuTAO1A2Mj04qtfw.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">“Developer Survey Results 2017” — Stack Overflow</figcaption></figure><p id="355f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">值得注意的是，Python，特别是<strong class="ka ir"> Jupyter Notebook </strong>，在最近几年里获得了极大的流行。虽然<strong class="ka ir"> Jupyter Notebook </strong>可以用于 Python 以外的语言，但它主要用于在数据科学竞赛的浏览器中记录和展示 Python 程序，如<a class="ae mp" href="https://www.kaggle.com/" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>。由 Ben Frederickson 做的一项调查显示<strong class="ka ir"> Jupyter Notebook </strong>在 Github 上的月活跃用户百分比(MAU)在 2015 年后大幅上升。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/d6e4cd2b79baea9e14763467e9e04391.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hr4AQ8riFqCrUzncv0SaRA.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">“<a class="ae mp" href="https://www.benfrederickson.com/ranking-programming-languages-by-github-users/" rel="noopener ugc nofollow" target="_blank">Ranking Programming Languages by GitHub Users</a>” — Ben Frederickson</figcaption></figure><p id="2ac1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着 Python 近年来越来越受欢迎，我们观察到用 r 编写的 Github 用户的 MAU 百分比略有下降。然而，这两种语言在数据科学家、工程师和分析师中仍然非常受欢迎。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="ba84" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">可用性</strong></h1><p id="ce62" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">最初用于研究和学术领域，R 已经不仅仅是一种统计语言。R 可以从<a class="ae mp" href="https://cran.r-project.org/" rel="noopener ugc nofollow" target="_blank"> CRAN </a>(综合 R 档案网)轻松下载。CRAN 还被用作一个包管理器，有超过<strong class="ka ir"> 10，000 </strong>个包可供下载。许多流行的开源 ide 如<a class="ae mp" href="https://www.rstudio.com/" rel="noopener ugc nofollow" target="_blank"> R Studio </a>可以用来运行 R。作为一名统计学专业的学生，我认为 R 在堆栈溢出方面有一个非常强大的用户社区。我在本科学习期间关于 R 的大多数问题都可以在<a class="ae mp" href="https://stackoverflow.com/questions/tagged/r" rel="noopener ugc nofollow" target="_blank"> Stack Overflow 的 R 标签 Q 和 A </a>上找到答案。如果你刚刚开始学习 R，许多 MOOCs 如<a class="ae mp" href="https://www.coursera.org/learn/r-programming" rel="noopener ugc nofollow" target="_blank"> Coursera </a>也提供入门 R 甚至 Python 课程。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="3c81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本地机器上设置 Python 工程环境也同样容易。事实上，最近的 MAC 电脑都内置了 Python 2.7 和几个有用的库。如果你像我一样是一个狂热的 Mac 用户，我建议查看<a class="ms mt ep" href="https://medium.com/u/d9b3e07b88?source=post_page-----b8f258f57b0f--------------------------------" rel="noopener" target="_blank"> Brian Torres-Gil </a>的<a class="ae mp" href="https://medium.com/@briantorresgil/definitive-guide-to-python-on-mac-osx-65acd8d969d0" rel="noopener">Mac OSX 上的 Python 权威指南</a>以获得更好的 Python 设置。开源 Python 包管理系统，如 PyPI 和 Anaconda 可以很容易地从他们的官方网站下载。在这一点上，我可能应该提到 Anaconda 也支持 R。当然，大多数人更喜欢直接通过 CRAN 管理包。PyPI 或 Python 通常比 r 有更多的包。然而，并不是所有的<strong class="ka ir"> 100，000+ </strong>包都适用于统计和数据分析。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="6bf8" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">形象化</h1><p id="0424" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">Python 和 R 都有优秀的可视化库。由 R Studio 的首席科学家<a class="ms mt ep" href="https://medium.com/u/2f166aac6770?source=post_page-----b8f258f57b0f--------------------------------" rel="noopener" target="_blank"> Hadley Wickham </a>，<a class="ae mp" href="https://github.com/hadley/ggplot2-book" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">ggplot2</strong></a><strong class="ka ir"/>创建，现在是 R 历史上最流行的数据可视化软件包之一。我完全爱上了 gg plot 2 的各种功能和定制。与 base R 图形相比，ggplot2 允许用户在更高的抽象层次上定制绘图组件。ggplot2 提供了超过<strong class="ka ir"> 50 </strong>种适用于不同行业的地块。我最喜欢的图表包括日历热图、分层树状图和聚类图。<a class="ms mt ep" href="https://medium.com/u/28472f176d5?source=post_page-----b8f258f57b0f--------------------------------" rel="noopener" target="_blank">塞尔瓦·普拉巴卡兰</a>有一个关于如何开始使用 ggplot2 的精彩<a class="ae mp" href="http://r-statistics.co/Complete-Ggplot2-Tutorial-Part1-With-R-Code.html" rel="noopener ugc nofollow" target="_blank">教程</a>。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/c814db3004f4b8f7f8b3ed5f2c8b9825.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3RsBsXaPrJAZy6YLjVp5uQ.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Calendar Heatmap (top left), Clusters (bottom left) and Hierarchical Dendrogram (right) in ggplot2</figcaption></figure><p id="c1a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Python 也有很好的数据可视化库。<a class="ae mp" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> Matplotlib </strong> </a>及其<a class="ae mp" href="https://seaborn.pydata.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> seaborn </strong> </a>扩展对于可视化和制作有吸引力的统计图非常有帮助。我强烈推荐你去看看 George Seif 的用 Python 编写的快速简单的数据可视化代码，以便更好地理解 matplotlib。与 R 的 ggplot2 类似，matplotlib 能够创建各种各样的图，从直方图到矢量场流图和雷达图。也许 matplotlib 最酷的特性之一是地形山体阴影，在我看来，这比 R <a class="ae mp" href="https://www.rdocumentation.org/packages/raster/versions/2.6-7" rel="noopener ugc nofollow" target="_blank"> raster </a>的<code class="fe my mz na nb b">hillShade()</code>功能更强大。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/c3307d0dc51b119692afe29260cb891f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*a1DZ28fVS80ng3Eu.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Topographic hillshading using matplotlib</figcaption></figure><p id="6d2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">R 和 Python 都有<strong class="ka ir">fleet . js</strong>的包装器，这是一个用 Javascript 编写的漂亮的交互式地图模块。我之前写过一篇文章，介绍了如何使用 follow 可视化房地产价格(follow 是 fleet . js 的 Python 包装)。Leaflet.js 是我使用过的较好的开源 GIS 技术之一，因为它提供了与 OpenStreetMaps 和 Google Maps 的无缝集成。您还可以使用 fleed . js 轻松创建吸引人的气泡图、热图和 choropleth 图。我强烈建议您查看 fleed . js 的 Python 和 R wrappers，因为与底图和其他 GIS 库相比，安装要简单得多。</p><p id="7684" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者，<a class="ae mp" href="http://plot.ly" rel="noopener ugc nofollow" target="_blank"> Plotly </a>是两种语言共有的令人惊叹的图形库。Plotly(或 Plot.ly)是使用 Python，特别是 Django 框架构建的。它的前端是用 JavaScript 构建的，集成了 Python、R、MATLAB、Perl、Julia、Arduino 和 REST。如果你正试图建立一个 web 应用程序来展示你的可视化，我肯定会推荐你去看看 Plotly，因为他们有很棒的带有滑块和按钮的交互图。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/29f3a54d518eb2554ef51709036efd7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*V7JruLRdZcLUYm1x_GeCZg.gif"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Plotly correlation plots of the Iris dataset</figcaption></figure></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="b9ec" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">预测分析</h1><p id="560b" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">正如我之前提到的，Python 和 R 都有强大的预测分析库。很难在高层次上比较两者在预测建模方面的表现。r 是专门作为统计语言编写的，因此与 Python 相比，它更容易搜索与统计建模相关的信息。简单的谷歌搜索<code class="fe my mz na nb b">logistic regression in R</code>会返回 6000 万个结果，这是搜索<code class="fe my mz na nb b">logistic regression in Python</code>的 37 倍。然而，对于具有软件工程背景的数据科学家来说，使用 Python 可能更容易，因为 R 是由统计学家编写的。虽然我发现与其他编程语言相比，R 和 Python 同样容易理解。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ne mw l"/></div></figure><p id="1b5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kaggle 用户<em class="nf"> NanoMathias </em>已经做了一个非常彻底的<a class="ae mp" href="https://www.kaggle.com/nanomathias/predicting-r-vs-python" rel="noopener ugc nofollow" target="_blank">调查</a>关于 Python 或 R 在预测分析中是否是一个更好的工具。他总结道，在数据科学家和分析师中，Python 和 R 用户的数量相当。他的研究中有一个有趣的发现，那就是从事编码工作 12 年以上的人倾向于选择 R 而不是 Python。这说明程序员选择 R 还是 Python 进行预测分析，无非是个人喜好。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/925310029da69bd4616cb2efaef500d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G5l9D7uqNmT7JGZz.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Linear Discriminant Analysis with embeded scalings, R and Python user analysis</figcaption></figure><p id="eefe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯（表示踌躇等）..所以普遍的共识是两种语言在预测的能力上非常相似。这有点无聊，不是吗？让我们使用 R 和 Python 将逻辑回归模型拟合到<a class="ae mp" href="https://archive.ics.uci.edu/ml/datasets/iris" rel="noopener ugc nofollow" target="_blank"> Iris 数据集</a>，并计算其预测的准确性。我选择 Iris 数据集是因为它很小并且缺少缺失数据。没有进行探索性数据分析(EDA)和特征工程。我只是做了一个 80-20 的训练测试分割，并用一个预测因子拟合了一个逻辑回归模型。</p><pre class="kx ky kz la gt nh nb ni nj aw nk bi"><span id="74c1" class="nl ln iq nb b gy nm nn l no np">library(datasets)</span><span id="d3ce" class="nl ln iq nb b gy nq nn l no np">#load data<br/>ir_data&lt;- iris<br/>head(ir_data)</span><span id="9054" class="nl ln iq nb b gy nq nn l no np">#split data<br/>ir_data&lt;-ir_data[1:100,]<br/>set.seed(100)<br/>samp&lt;-sample(1:100,80)<br/>ir_train&lt;-ir_data[samp,]<br/>ir_test&lt;-ir_data[-samp,]</span><span id="fd90" class="nl ln iq nb b gy nq nn l no np">#fit model<br/>y&lt;-ir_train$Species; x&lt;-ir_train$Sepal.Length<br/>glfit&lt;-glm(y~x, family = 'binomial')<br/>newdata&lt;- data.frame(x=ir_test$Sepal.Length)</span><span id="d6b0" class="nl ln iq nb b gy nq nn l no np">#prediction<br/>predicted_val&lt;-predict(glfit, newdata, type="response")<br/>prediction&lt;-data.frame(ir_test$Sepal.Length, ir_test$Species,predicted_val, ifelse(predicted_val&gt;0.5,'versicolor','setosa'))</span><span id="5d3e" class="nl ln iq nb b gy nq nn l no np">#accuracy<br/>sum(factor(prediction$ir_test.Species)==factor(prediction$ifelse.predicted_val...0.5...versicolor....setosa..))/length(predicted_val)</span></pre><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/96a366b2098b9d39e5ed085c717f6ec3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CSS_IxxsqwBUYr5H72TRWA.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">95% accuracy achieved with R’s glm model. Not bad!</figcaption></figure><pre class="kx ky kz la gt nh nb ni nj aw nk bi"><span id="1cef" class="nl ln iq nb b gy nm nn l no np">import pandas as pd<br/>from sklearn.linear_model import LogisticRegression<br/>from sklearn.metrics import confusion_matrix</span><span id="684b" class="nl ln iq nb b gy nq nn l no np">#load data<br/>traindf = pd.read_csv("~/data_directory/ir_train")<br/>testdf = pd.read_csv("~/data_directory/ir_test")<br/>x = traindf['Sepal.Length'].values.reshape(-1,1)<br/>y = traindf['Species']<br/>x_test = testdf['Sepal.Length'].values.reshape(-1,1)<br/>y_test = testdf['Species']</span><span id="a943" class="nl ln iq nb b gy nq nn l no np">#fit model<br/>classifier = LogisticRegression(random_state=0)<br/>classifier.fit(x,y)</span><span id="0ce8" class="nl ln iq nb b gy nq nn l no np">#prediction<br/>y_pred = classifier.predict(x_test)</span><span id="3e3d" class="nl ln iq nb b gy nq nn l no np">#confusion matrix<br/>confusion_matrix = confusion_matrix(y_test, y_pred)<br/>print confusion_matrix</span><span id="8a50" class="nl ln iq nb b gy nq nn l no np">#accuracy<br/>print classifier.score(x_test, y_test)</span></pre><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/4e074ffe20c1f5a903728d6090f0e003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_jHVpOrGhEr2V1BPapeGkg.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">90% accuracy achieved with Python sklearn’s LogisticRegression model</figcaption></figure><p id="39ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用 R stat 的<code class="fe my mz na nb b">glm</code>函数和 Python scikit-learn 的<code class="fe my mz na nb b">LogisticRegression</code>，我将两个逻辑回归模型拟合到 Iris 数据集的随机子集。在我们的模型中，我们只使用了一个预测因子<code class="fe my mz na nb b">sepal length</code>来预测花的<code class="fe my mz na nb b">species</code>。两个模型都达到了 90%或更高的准确率，R 给出了稍好的预测。然而，这不足以证明 R 比 Python 有更好的预测模型。逻辑回归只是你可以用 Python 和 R 构建的许多预测模型中的一种。Python 挤掉 R 的一个方面是它构建良好的深度学习模块。流行的 Python 深度学习库包括<strong class="ka ir"> Tensorflow </strong>、<strong class="ka ir"> Theano </strong>和<strong class="ka ir"> Keras </strong>。这些库都有足够的文档，我确信 Siraj Raval 有数百个关于如何使用它们的 Youtube 教程。老实说，我宁愿花一个小时在 Keras 中编写 dCNNs(深度卷积神经网络),也不愿花半天时间弄清楚如何在 r 中实现它们。<a class="ms mt ep" href="https://medium.com/u/f7782f0aeb1b?source=post_page-----b8f258f57b0f--------------------------------" rel="noopener" target="_blank"> Igor Bobriakov </a>制作了一个出色的信息图，描述了 Python、Scala 和 r 中流行库的提交和贡献者数量。我强烈推荐阅读他的文章(下面提供了链接)。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="ab gu cl nt"><img src="../Images/ea03616ab786a10a141136c7325f5c0b.png" data-original-src="https://miro.medium.com/v2/format:webp/0*gorWChPPTZpr9ULL.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">“<a class="ae mp" href="https://medium.com/activewizards-machine-learning-company/comparison-of-top-data-science-libraries-for-python-r-and-scala-infographic-574069949267" rel="noopener">Comparison of top data science libraries for Python, R and Scala [Infographic]</a>” — Igor Bobriakov</figcaption></figure></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="26ef" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">表演</h1><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="nu mw l"/></div></figure><p id="5aef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测量编程语言的速度通常被认为是一项有偏见的任务。每种语言都有针对特定任务优化的内置特性(比如 R 如何针对统计分析进行优化)。用 Python 和 R 进行性能测试可以用许多不同的方法来完成。我用 Python 和 R 编写了两个简单的脚本来比较 Yelp 的<a class="ae mp" href="https://www.kaggle.com/yelp-dataset/yelp-dataset#yelp_academic_dataset_user.json" rel="noopener ugc nofollow" target="_blank">学术用户数据集</a>的加载时间，该数据集略超过 2g。</p><p id="94dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> R </strong></p><pre class="kx ky kz la gt nh nb ni nj aw nk bi"><span id="61dd" class="nl ln iq nb b gy nm nn l no np">require(RJSONIO)<br/>start_time &lt;- Sys.time()<br/>json_file &lt;- fromJSON("~/desktop/medium/rpycomparison/yelp-dataset/yelp_academic_dataset_user.json")<br/>json_file &lt;- lapply(json_file, function(x) {<br/>  x[sapply(x, is.null)] &lt;- NA<br/>  unlist(x)<br/>})<br/>df&lt;-as.data.frame(do.call("cbind", json_file))<br/>end_time &lt;- Sys.time()<br/>end_time - start_time</span><span id="c111" class="nl ln iq nb b gy nq nn l no np">#Time difference of 37.18632 secs</span></pre><p id="8064" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Python </strong></p><pre class="kx ky kz la gt nh nb ni nj aw nk bi"><span id="637b" class="nl ln iq nb b gy nm nn l no np">import time<br/>import pandas as pd<br/>start = time.time()<br/>y1 = pd.read_json('~/desktop/medium/rpycomparison/yelp-dataset/yelp_academic_dataset_user.json', lines = True)<br/>end = time.time()<br/>print("Time difference of " + str(end - start) + " seconds"</span><span id="25ba" class="nl ln iq nb b gy nq nn l no np">#Time difference of 169.13606596 seconds</span></pre><p id="3605" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯……有意思。r 加载 json 文件的速度几乎是 Python 的 5 倍。众所周知，Python 比 R 有更快的加载时间，布莱恩·雷(Brian Ray)的 T2 测试(T3)证明了这一点。让我们看看这两个程序如何处理一个大的？csv 文件为。csv 是一种常用的数据格式。我们稍微修改了上面的代码，以加载<a class="ae mp" href="https://www.kaggle.com/city-of-seattle/seattle-library-collection-inventory/version/15" rel="noopener ugc nofollow" target="_blank">西雅图图书馆库存数据集</a>，它几乎有 4.5 千兆字节。</p><p id="5441" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> R </strong></p><pre class="kx ky kz la gt nh nb ni nj aw nk bi"><span id="191e" class="nl ln iq nb b gy nm nn l no np">start_time &lt;- Sys.time()<br/>df &lt;- read.csv("~/desktop/medium/library-collection-inventory.csv")<br/>end_time &lt;- Sys.time()<br/>end_time - start_time</span><span id="9fd7" class="nl ln iq nb b gy nq nn l no np">#Time difference of 3.317888 mins</span></pre><p id="ad1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Python </strong></p><pre class="kx ky kz la gt nh nb ni nj aw nk bi"><span id="7d3b" class="nl ln iq nb b gy nm nn l no np">import time<br/>import pandas as pd<br/>start = time.time()<br/>y1 = pd.read_csv('~/desktop/medium/library-collection-inventory.csv')<br/>end = time.time()<br/>print("Time difference of " + str(end - start) + " seconds")</span><span id="de08" class="nl ln iq nb b gy nq nn l no np">#Time difference of 92.6236419678 seconds</span></pre><p id="f92a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">呀！r 花了几乎两倍的时间来加载 4.5 千兆字节。csv 文件比 Python <strong class="ka ir"> pandas </strong>(用于数据操作和分析的 Python 编程语言)。重要的是要知道，虽然 pandas 主要是用 Python 编写的，但是库的更重要的部分是用 Cython 或 c 编写的，这可能会对加载时间产生潜在的影响，具体取决于数据格式。</p><p id="db81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们做一些更有趣的事情。<strong class="ka ir"> Bootstrapping </strong>是一种从总体中随机重新取样的统计方法。我以前做过足够的引导，知道这是一个耗时的过程，因为我们必须重复地对数据进行多次迭代。以下代码分别测试了在 R 和 Python 中引导 100，000 次复制的运行时:</p><p id="48c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> R </strong></p><pre class="kx ky kz la gt nh nb ni nj aw nk bi"><span id="e009" class="nl ln iq nb b gy nm nn l no np">#generate data and set boostrap size<br/>set.seed(999)<br/>x &lt;- 0:100<br/>y &lt;- 2*x + rnorm(101, 0, 10)<br/>n &lt;- 1e5</span><span id="1190" class="nl ln iq nb b gy nq nn l no np">#model definition<br/>fit.mod &lt;- lm(y ~ x)<br/>errors &lt;- resid(fit.mod)<br/>yhat &lt;- fitted(fit.mod)</span><span id="65ee" class="nl ln iq nb b gy nq nn l no np">#bootstrap<br/>boot &lt;- function(n){<br/>  b1 &lt;- numeric(n)<br/>  b1[1] &lt;- coef(fit.mod)[2]<br/>  for(i in 2:n){<br/>    resid_boot &lt;- sample(errors, replace=F)<br/>    yboot &lt;- yhat + resid_boot<br/>    model_boot &lt;- lm(yboot ~ x)<br/>    b1[i] &lt;- coef(model_boot)[2]<br/>  }<br/>  return(b1)<br/>}<br/>start_time &lt;- Sys.time()<br/>boot(n)<br/>end_time &lt;- Sys.time()</span><span id="ddc3" class="nl ln iq nb b gy nq nn l no np">#output time<br/>end_time - start_time</span><span id="756d" class="nl ln iq nb b gy nq nn l no np">#Time difference of 1.116677 mins</span></pre><p id="d8a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Python </strong></p><pre class="kx ky kz la gt nh nb ni nj aw nk bi"><span id="4cc3" class="nl ln iq nb b gy nm nn l no np">import numpy as np<br/>import statsmodels.api as sm<br/>import time<br/>#generate data and set bootstrap size<br/>x = np.arange(0, 101)<br/>y = 2*x + np.random.normal(0, 10, 101)<br/>n = 100000<br/>X = sm.add_constant(x, prepend=False)</span><span id="7e37" class="nl ln iq nb b gy nq nn l no np">#model definition<br/>fitmod = sm.OLS(y, X)<br/>results = fitmod.fit()</span><span id="9634" class="nl ln iq nb b gy nq nn l no np">resid = results.resid<br/>yhat = results.fittedvalues</span><span id="a17a" class="nl ln iq nb b gy nq nn l no np">#bootstrap<br/>b1 = np.zeros((n))<br/>b1[0] = results.params[0]<br/>start = time.time()<br/>for i in np.arange(1, 100000):<br/>   resid_boot = np.random.permutation(resid)<br/>   yboot = yhat + resid_boot<br/>   model_boot = sm.OLS(yboot, X)<br/>   resultsboot = model_boot.fit()<br/>   b1[i] = resultsboot.params[0]<br/>end = time.time()</span><span id="8acc" class="nl ln iq nb b gy nq nn l no np">#output time<br/>print("Time difference of " + str(end - start) + " seconds")</span><span id="0a70" class="nl ln iq nb b gy nq nn l no np">#Time difference of 29.486082077 seconds</span></pre><p id="08b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">r 花了几乎两倍的时间来运行引导程序。这是相当令人惊讶的，因为 Python 通常被认为是一种“慢”的编程语言。我慢慢开始后悔用 R 而不是 Python 来运行我所有的本科统计学作业。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="bca9" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="nv mw l"/></div></figure><p id="3b6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文只讨论了 Python 和 R 之间的基本区别。就个人而言，我会根据手头的任务在 Python 和 R 之间进行转换。最近，数据科学家一直在推动在<a class="ae mp" href="https://www.kdnuggets.com/2015/12/using-python-r-together.html" rel="noopener ugc nofollow" target="_blank">结合</a>中使用 Python 和 R。很有可能在不久的将来会出现第三种语言，并最终在流行程度上超过 Python 和 R。作为数据科学家和工程师，跟上最新技术并保持创新是我们的责任。最后，强烈推荐你阅读<a class="ms mt ep" href="https://medium.com/u/b9a4f6da81ed?source=post_page-----b8f258f57b0f--------------------------------" rel="noopener" target="_blank"> Karlijn Willems </a>的<a class="ae mp" href="https://www.datacamp.com/community/tutorials/r-or-python-for-data-analysis" rel="noopener ugc nofollow" target="_blank">选择 R 还是 Python 做数据分析？一张信息图</a>。它为我们在本文中讨论的内容提供了一个很好的视觉总结，并提供了额外的信息，包括就业趋势和平均工资。在下面评论，让我知道你更喜欢哪种语言！</p><p id="b76c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您阅读我的文章。</p></div></div>    
</body>
</html>