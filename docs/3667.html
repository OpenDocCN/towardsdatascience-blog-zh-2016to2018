<html>
<head>
<title>How to use image preprocessing to improve the accuracy of Tesseract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何利用图像预处理提高立方体的精度</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/getting-started-with-tesseract-part-ii-f7f9a0899b3f?source=collection_archive---------1-----------------------#2018-06-06">https://towardsdatascience.com/getting-started-with-tesseract-part-ii-f7f9a0899b3f?source=collection_archive---------1-----------------------#2018-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e1a0c35771d40d4ca136d96f1cbf9443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iueeZmOsovXFNwtU5L-5lA.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Photo by <a class="ae jg" href="https://unsplash.com/@chatelp" rel="noopener ugc nofollow" target="_blank">Pierre Châtel-Innocenti</a>.</figcaption></figure><div class=""/><div class=""><h2 id="a29a" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">应用计算机视觉技术提高精确度</h2></div><p id="4c28" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在之前的<a class="ae jg" href="https://medium.com/@bkaankuguoglu/getting-started-with-tesseract-part-i-2a6a6b1cf75e" rel="noopener">如何开始使用宇宙魔方</a>中，我给了你一个关于使用 Python 使用宇宙魔方的实用快速入门教程。这是一个非常简单的概述，但它应该可以帮助您开始使用 Tesseract，并清除我在您的位置时所面临的一些障碍。现在，我热衷于向您展示更多的技巧和东西，您可以使用 Tesseract 和 OpenCV 来提高您的整体准确性。</p><h1 id="367a" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">我们上次讲到哪里了？</h1><p id="e240" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">在<a class="ae jg" href="https://medium.com/@bkaankuguoglu/getting-started-with-tesseract-part-i-2a6a6b1cf75e" rel="noopener">之前的故事</a>中，大部分内容我都懒得赘述。但是如果你喜欢第一个故事，续集来了！那么，我们在哪里停下来的？</p><p id="1bbc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">啊，我们对重缩放、去噪和二值化做了一个简单的概述。现在，是时候进入细节并向您展示一些您可以使用的设置了。</p><h1 id="108a" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">改比例</h1><p id="5336" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">被重新缩放的图像或者缩小或者放大。如果你对缩小你的形象感兴趣，<strong class="la jk"> INTER_AREA </strong>是适合你的选择。(顺便说一下，参数<em class="mr"> fx </em>和<em class="mr"> fy </em>表示下面函数中的比例因子。)</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="5d0e" class="nb lv jj mx b gy nc nd l ne nf">img = cv2.resize(img, None, fx=0.5, fy=0.5, interpolation=cv2.INTER_AREA)</span></pre><p id="7dc9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，在大多数情况下，您可能需要将图像放大以识别小字符。在这种情况下，<strong class="la jk"> INTER_CUBIC </strong>通常比其他替代方法执行得更好，尽管它比其他方法慢。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="09c5" class="nb lv jj mx b gy nc nd l ne nf">img = cv2.resize(img, None, fx=2, fy=2, interpolation=cv2.INTER_CUBIC)</span></pre><p id="c29e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想牺牲一些图像质量来获得更快的性能，您可能想尝试使用<strong class="la jk"> INTER_LINEAR </strong>来放大图像。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="9d13" class="nb lv jj mx b gy nc nd l ne nf">img = cv2.resize(img, None, fx=2, fy=2, interpolation=cv2.INTER_LINEAR)</span></pre><h1 id="26eb" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated"><strong class="ak">模糊</strong></h1><p id="3fe3" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">值得一提的是，<a class="ae jg" href="https://docs.opencv.org/3.4.0/d4/d13/tutorial_py_filtering.html" rel="noopener ugc nofollow" target="_blank"> OpenCV 库</a>中有一些模糊滤镜可用。图像模糊通常通过将图像与低通滤波器核进行卷积来实现。虽然滤镜通常用于模糊图像或减少噪点，但它们之间还是有一些差异。</p><h2 id="cbaf" class="nb lv jj bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">1.求平均值</h2><p id="3d5f" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">在使用归一化的盒状滤波器对图像进行卷积之后，这将取核心区域下所有像素的平均值，并替换中心元素。我想这是不言自明的。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="406d" class="nb lv jj mx b gy nc nd l ne nf">img = cv.blur(img,(5,5))</span></pre><h2 id="2568" class="nb lv jj bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">2.高斯模糊</h2><p id="abbc" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">这类似于求平均值，但它使用高斯核，而不是归一化的盒式滤波器进行卷积。这里，核的维数和两个方向上的标准偏差可以独立确定。高斯模糊对于去除非常有用——你猜怎么着？—图像中的高斯噪声。相反，<strong class="la jk"> </strong>高斯模糊不会保留输入中的边缘。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="eb7c" class="nb lv jj mx b gy nc nd l ne nf">img = cv2.GaussianBlur(img, (5, 5), 0)</span></pre><h2 id="cb50" class="nb lv jj bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">3.中间模糊</h2><p id="bd8a" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">内核区域中的中心元素被替换为内核下所有像素的中值。特别是，在去除图像中的椒盐噪声方面，这优于其他模糊方法。</p><p id="5f2b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">中值模糊是一种非线性滤波器。与线性过滤器不同，中值模糊用邻域值中的中值替换像素值。因此，中值模糊保留了边缘，因为中值必须是相邻像素之一的值。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="bc20" class="nb lv jj mx b gy nc nd l ne nf">img = cv2.medianBlur(img, 3)</span></pre><h2 id="8064" class="nb lv jj bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">4.双边过滤</h2><p id="de7f" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">说到锐边，双边滤波对于去除噪声而不平滑边缘是非常有用的。与高斯模糊类似，双边滤波也使用高斯滤波器来寻找邻域中的高斯加权平均值。但是，在模糊附近的像素时，它也考虑了像素差异。</p><p id="5910" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，它确保只有那些与中心像素具有相似强度的像素被模糊，而具有不同像素值的像素不被模糊。这样，具有较大强度变化的边缘，即所谓的边缘，被保留下来。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="efd4" class="nb lv jj mx b gy nc nd l ne nf">img = cv.bilateralFilter(img,9,75,75)</span></pre><p id="23e4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总的来说，如果你对保留边缘感兴趣，选择中值模糊或双边滤波。相反，高斯模糊很可能比中值模糊更快。由于计算复杂，双边滤波是所有方法中最慢的。</p><p id="d797" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">再说一次，你做你的。</p><h1 id="c3c2" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">图像阈值处理</h1><p id="4d2c" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">没有一种图像阈值方法适合所有类型的文档。实际上，所有的滤镜对不同的图像都有不同的表现。例如，虽然一些滤波器成功地将一些图像二值化，但是它们可能无法将其他图像二值化。同样地，有些滤镜可以很好地处理其他滤镜无法很好地二值化的图像。</p><p id="9e6f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将尝试在这里涵盖基础知识，尽管我建议您阅读官方文档<a class="ae jg" href="https://docs.opencv.org/3.4.0/d7/d4d/tutorial_py_thresholding.html" rel="noopener ugc nofollow" target="_blank"> OpenCV 关于图像阈值处理</a>以获得更多信息及其背后的理论。</p><h2 id="c801" class="nb lv jj bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">1.简单阈值</h2><p id="678d" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">你可能记得你的一个朋友给你的生活提了一些建议，他说，“事情并不总是非黑即白的。”嗯，对于一个简单的门槛来说，事情相当简单。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="a1f3" class="nb lv jj mx b gy nc nd l ne nf">cv.threshold(img,127,255,cv.THRESH_BINARY)</span></pre><p id="c762" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，你选择一个阈值，比如 127。如果像素值大于阈值，它会变成黑色。少的话就变成白色了。OpenCV 为我们提供了不同类型的阈值方法，可以作为第四个参数传递。我经常在大多数任务中使用二进制阈值，但是你可以访问<a class="ae jg" href="https://docs.opencv.org/3.4.0/d7/d4d/tutorial_py_thresholding.html" rel="noopener ugc nofollow" target="_blank">的官方文档了解其他阈值方法。</a></p><h2 id="9485" class="nb lv jj bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">2.自适应阈值</h2><p id="42a3" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我们让算法为图像的小区域计算阈值，而不是设置一个全局阈值。因此，我们最终为不同的图像区域设置了不同的阈值，这太棒了！</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="ddfa" class="nb lv jj mx b gy nc nd l ne nf">cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 31, 2)</span></pre><p id="41d0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有两种计算阈值的自适应方法。<strong class="la jk">自适应阈值均值</strong>返回邻域面积的均值，<strong class="la jk">自适应高斯均值</strong>计算邻域值的加权和。</p><p id="3435" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还有两个参数来决定邻域的大小和从结果中减去的常量值:分别是第五个和第六个参数。</p><h2 id="0b09" class="nb lv jj bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">3.大津的门槛</h2><p id="6e90" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">这种方法特别适用于<strong class="la jk">双峰图像</strong>，这种图像的直方图有两个峰值。如果是这种情况，我们可能会热衷于在这些峰值之间选择一个阈值。不过，这就是 Otsu 的二值化实际做的事情。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="eb84" class="nb lv jj mx b gy nc nd l ne nf">cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1]</span></pre><p id="59c5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这在某些情况下非常有用。但是它可能无法对非双峰图像进行二值化。所以，请大家对这个滤镜半信半疑。</p><h2 id="ced2" class="nb lv jj bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">阈值处理的类型</h2><p id="5397" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">您可能已经注意到有一个参数，或者在某些情况下是几个参数的组合，作为参数传递以确定阈值的类型，比如 THRESH_BINARY。我现在就不在这里赘述了，因为在<a class="ae jg" href="https://docs.opencv.org/3.4.0/d7/d4d/tutorial_py_thresholding.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>里已经解释的很清楚了。</p><h1 id="89de" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">接下来呢？</h1><p id="f705" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">到目前为止，我们已经讨论了一些图像预处理技术。你可能想知道你什么时候会弄脏你的手。好吧，时候到了。在你回到你最喜欢的 Python IDE——我的是<a class="ae jg" href="https://www.jetbrains.com/pycharm/" rel="noopener ugc nofollow" target="_blank"> PyCharm </a>，顺便说一句——之前，我将向你展示几行代码，这将节省你一些时间，同时试图找到哪种过滤器和图像操作的组合适合你的文档。</p><p id="26c2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们从定义一个带有一些阈值过滤器和模糊方法组合的开关函数开始。一旦你有了这个想法，你也可以添加更多的过滤器，结合其他图像预处理方法，如重新调整你的过滤器集。</p><p id="6f02" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我创建了 20 种不同的图像阈值方法、模糊方法和内核大小的组合。switcher 函数<em class="mr"> apply_threshold </em>有两个参数:OpenCV image 和一个表示过滤器的整数。同样，由于这个函数返回 OpenCV 图像，它可以很容易地集成到我们上一篇文章中的<em class="mr"> get_string </em>函数中。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="d651" class="nb lv jj mx b gy nc nd l ne nf">def apply_threshold(img, argument):<br/>    switcher = {<br/>        1: cv2.threshold(cv2.GaussianBlur(img, (9, 9), 0), 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1],<br/>        2: cv2.threshold(cv2.GaussianBlur(img, (7, 7), 0), 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1],<br/>        3: cv2.threshold(cv2.GaussianBlur(img, (5, 5), 0), 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1],</span><span id="8a72" class="nb lv jj mx b gy nr nd l ne nf">                          <strong class="mx jk">    ...  </strong>            </span><span id="50d6" class="nb lv jj mx b gy nr nd l ne nf">        18: cv2.adaptiveThreshold(cv2.medianBlur(img, 7), 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 31, 2),<br/>        19: cv2.adaptiveThreshold(cv2.medianBlur(img, 5), 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 31, 2),<br/>        20: cv2.adaptiveThreshold(cv2.medianBlur(img, 3), 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 31, 2)<br/>    }<br/>    return switcher.get(argument, "Invalid method")</span></pre><p id="11ad" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它来了。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="1e68" class="nb lv jj mx b gy nc nd l ne nf">def get_string(img_path, method):<br/>    # Read image using opencv<br/>    img = cv2.imread(img_path)<br/><br/>    # Extract the file name without the file extension<br/>    file_name = os.path.basename(img_path).split('.')[0]<br/>    file_name = file_name.split()[0]<br/><br/>    # Create a directory for outputs<br/>    output_path = os.path.join(output_dir, file_name)<br/>    if not os.path.exists(output_path):<br/>        os.makedirs(output_path)</span><span id="3bb1" class="nb lv jj mx b gy nr nd l ne nf">    # Rescale the image, if needed.<br/>    img = cv2.resize(img, None, fx=1.5, fy=1.5, interpolation=cv2.INTER_CUBIC)</span><span id="197b" class="nb lv jj mx b gy nr nd l ne nf">    # Convert to gray<br/>    img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br/><br/>    # Apply dilation and erosion to remove some noise<br/>    kernel = np.ones((1, 1), np.uint8)<br/>    img = cv2.dilate(img, kernel, iterations=1)<br/>    img = cv2.erode(img, kernel, iterations=1)</span><span id="480c" class="nb lv jj mx b gy nr nd l ne nf"><strong class="mx jk">    # Apply threshold to get image with only black and white<br/>    img = apply_threshold(img, method)</strong></span><span id="927f" class="nb lv jj mx b gy nr nd l ne nf">    # Save the filtered image in the output directory<br/>    save_path = os.path.join(output_path, file_name + "_filter_" + str(method) + ".jpg")<br/>    cv2.imwrite(save_path, img)<br/><br/>    # Recognize text with tesseract for python<br/>    result = pytesseract.image_to_string(img, lang="eng")</span><span id="c292" class="nb lv jj mx b gy nr nd l ne nf">    return result</span></pre><h1 id="5ff8" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">临终遗言</h1><p id="9fa6" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">现在，我们需要编写一个简单的 for 循环，遍历输入目录来收集图像，并对收集的图像应用每个过滤器。我更喜欢使用<em class="mr"> glob </em>或<em class="mr"> os </em>从目录中收集图像，使用<em class="mr"> argparse </em>通过终端传递参数，就像任何其他正常人会做的那样。</p><p id="0a9f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想看的话，我在这里做了和我的<a class="ae jg" href="https://gist.github.com/bkaankuguoglu/111f9f5e0c30b5f57d7c5338d6dcb6fc" rel="noopener ugc nofollow" target="_blank">要点</a>差不多的事情。然而，请随意使用您觉得舒服的工具。</p><p id="b19d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到目前为止，我已经尝试介绍了一些有用的图像预处理概念和实现，尽管这可能只是冰山一角。我不知道在接下来的几周里我会有多少“闲暇时间”，所以我不能给你一个发表下一篇文章的具体时间框架。然而，我正在考虑在这个系列中至少增加一个部分来解释我遗漏的一些东西，比如图像的旋转和去歪斜。</p><p id="8553" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在那之前，最好的办法是保持警惕，继续寻找迹象。<a class="ae jg" href="https://www.youtube.com/watch?v=B_CHjYoqPUU" rel="noopener ugc nofollow" target="_blank"> * </a></p></div></div>    
</body>
</html>