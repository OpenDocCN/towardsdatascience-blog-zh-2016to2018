# 用于数据科学的 Python:第 2 部分

> 原文：<https://towardsdatascience.com/python-for-data-science-part-2-373d6473fa40?source=collection_archive---------4----------------------->

在 Python for data science 系列的第 1 部分中，我们看了 Python 中数值计算的基本内置函数。在这一部分，我们将看看 Numpy 库。

![](img/07af13db4ede5b06935fe1b9333d20d4.png)

Numpy 是 Python 中科学计算的基础包。它提供了对大型多维数组的支持，也提供了对这些数组进行操作的高级数学函数。

很好，让我们看看如何使用 Numpy 库进行基本的数组操作。

# Numpy 图书馆

首先，我们需要在 Python 中导入 numpy。

```
import numpy as np
```

让我们创建一个 numpy 数组。

```
np.array([1,2,3])
```

***输出:数组([1，2，3])***

现在，让我们创建一个多维数组。

```
a = np.array([[1,2,3],[4,5,6]]) 
a
```

***输出:数组([[1，2，3]，
[4，5，6])***

检查形状(数组的行和列)。

```
a.shape
```

***输出:(2，3)***

在 1 到 30 之间创建一个间距均匀的数组，差值为 2。

```
b = np.arange(1,30,2)
b
```

***输出:数组([ 1，3，5，7，9，11，13，15，17，19，21，23，25，27，29])***

将上面的数组重新塑造成想要的形状。

```
b.reshape(5,3) 
```

***输出:数组([[ 1，3，5]，
，【7，9，11】，
，【13，15，17】，
，【19，21，23】，
，【25，27，29】)*，**

在区间 1 和 5 之间生成一个等间距列表。(在这里花一分钟来理解‘Lin space’和‘arange’之间的区别)

```
c = np.linspace(1,5,20)
c
```

***输出:数组(【1。，1.21052632，1.42105263，1.63157895，1.84210526，
2.05263158，2.26315789，2.4736848，2.684842，2.6843，2.89473684，
3.105266，3.])***

现在，就地改变数组的形状(“resize”功能就地改变数组的形状，不同于“reshape”)

```
c.resize(5,4)
c
```

***输出:数组([[ 1。，1.21052632，1.42105263，1.63157895]，
，【1.84210526，2.05263158，2.26315789，2.47368421】，
，【2.68421053，2.89473684，3.10526316，3.37】。]])***

创建一个所有元素都为 1 的数组。

```
d = np.ones((2,2))
d
```

***输出:数组([[ 1。, 1.]，
【1。, 1.]])***

创建一个用零填充的数组。

```
e = np.zeros((3,3))
e
```

***输出:数组([[ 0。, 0., 0.]，
【0。, 0., 0.]，
【0。, 0., 0.]])***

创建对角线值= 1 的对角矩阵

```
f = np.eye(2)
f
```

***输出:数组([[ 1。, 0.]，
【0。, 1.]])***

仅从数组中提取对角线值。

```
np.diag(f)
```

***输出:数组(【1。, 1.])***

创建由重复列表组成的数组

```
g = np.array([1,2,3]*5)
g
```

***输出:数组(【1，2，3，1，2，3，1，2，3，1，2，3，1，2，3，1，2，3】)***

现在，使用 repeat 函数将数组中的每个元素重复 n 次。

```
np.repeat([1,2,3],3)
```

***输出:数组([1，1，1，2，2，2，3，3，3])***

生成两个所需形状的数组，用 0 到 1 之间的随机值填充。

```
g = np.random.rand(2,3)
print(g)
h = np.random.rand(2,3)
print(h)
```

***输出:***

***[[0.61631842 0.28352987 0.56174714]
【0.54302204 0.47257786 0.21923943]]***

***[[0.57233679 0.22981962 0.15870184]
【0.52548056 0.81495971 0.22014512]]***

垂直堆叠上面创建的两个数组

```
i = np.vstack([h,g])
i
```

***输出:***

***数组([[ 0.57233679，0.22981962，0.15870184]，
【0.52548056，0.81495971，0.22014512】，
，【0.61631842，0.28352987，0.56174714]，【T30***

现在，让我们把它们水平堆叠起来。

```
j = np.hstack([h,g])
j
```

**输出:**

***数组([[ 0.57233679，0.22981962，0.15870184，0.61631842，0.28352987，
0.56174714]，
[ 0.52548056，0.81495971，0.22014512，0.544512***

很好，现在让我们执行一些数组操作。首先让我们创建两个随机数组

```
k = np.random.rand(2,2)
l = np.random.rand(2,2)
print(k)
print(l)
```

***输出:***

***[[0.02430146 0.14448542]
【0.54428337 0.40332494]]***

***[[0.77574886 0.08747577]
【0.51484157 0.92319888]]***

让我们做元素加法。

```
m = k + l
m
```

***输出:数组([[ 0.80005032，0.23196118]，
，【1.05912494，1.32652381])*，**

元素减法。

```
n = k-l
n
```

***输出:数组([[-0.75144739，0.05700965]，
，【0.02944179，-0.51987394])***

让我们对每个元素进行 2 次幂运算。

```
p = k**2
p
```

***输出:数组([[ 0.00059056，0.02087604]，
，【0.29624438，0.162671 ]])***

现在，让我们执行两个数组 k 和 l 的点积，而不是元素运算。

```
q = k.dot(l)
q
```

***输出:数组([[ 0.09323893，0.13551456]，
，【0.62987564，0.41996073]])***

让我们创建一个新的数组并转置它。

```
a = np.array([[1,2],[3,4]])
a
```

**输出:**

***数组([[1，2]，
，[3，4])***

```
a.T
```

**输出:**

***数组([[1，3]，
，[2，4])***

现在，检查数组中元素的数据类型。

```
a.dtype
```

***输出:dtype('int32')***

更改数组的数据类型。

```
b = a.astype('f')
b.dtype
```

***输出:dtype('float32')***

现在，让我们看看数组中的一些数学函数，从数组的 sum 开始。

```
c = np.array([1,2,3,4,5])
c.sum()
```

***输出:15***

数组元素的最大值。

```
c.max()
```

***输出:5***

数组元素的平均值

```
c.mean()
```

***输出:3***

现在，让我们检索数组最大值的索引。

```
c.argmax()
```

***输出:4***

```
c.argmin()
```

***输出:0***

创建一个由前十个整数的平方组成的数组。

```
d = np.arange(10)**2
d
```

***输出:数组([ 0，1，4，9，16，25，36，49，64，81]，dtype=int32)***

使用 index 访问上述数组中的值。

```
d[2]
```

***输出:4***

```
d[1:5]
```

***输出:数组([ 1，4，9，16]，dtype=int32)***

使用负号反向访问变量。

```
d[-1:]
```

***输出:数组([81]，dtype=int32)***

现在，根据步长访问数组的某些元素。

```
d[1:10:2] *#d[start:stop:stepsize]*
```

***输出:数组([ 1，9，25，49，81]，dtype=int32)***

创建多维数组

```
e = np.arange(36)
e.resize(6,6)
e
```

***输出:数组([[ 0，1，2，3，4，5]，
，
，【12，13，14，15，16，17】，
，【18，19，20，21，22，23】，
，【24，25，26，27，28，29】，
，【30，30***

访问第二行和第三列

```
e[1,2]
```

***输出:8***

访问第二行和第 3 至 7 列。请注意，行和列的编号从 0 开始。

```
e[1, 2:6]
```

***输出:数组([ 8，9，10，11])***

选择第 2 行之前的所有行以及除最后一列之外的所有列

```
e[:2,:-1]
```

***输出:数组([[ 0，1，2，3，4]，
[ 6，7，8，9，10])***

从数组中选择大于 20 的值。

```
e[e>20]
```

***输出:数组(【21，22，23，24，25，26，27，28，29，30，31，32，33，34，35】)***

如果元素值大于 20，则将数组元素的值赋为 20。

```
e[e>20] = 20
e
```

***输出:数组([[ 0，1，2，3，4，5]，
，【6，7，8，9，10，11】，
，【12，13，14，15，16，17】，
，【18，19，20，20，20】，
，【20，20，20，20】，*** 

要将一个数组复制到另一个变量上，请始终使用 copy 函数。

```
f = e.copy()
f
```

***输出:数组([[ 0，1，2，3，4，5]，
，【6，7，8，9，10，11】，
，【12，13，14，15，16，17】，
，【18，19，20，20，20】，
，【20，20，20，20】，*** 

用一组 1 到 10 之间的随机整数创建一个数组。将数组指定为 4*4 的形状

```
g = np.random.randin(1,10,(4,4))
g
```

***输出:数组([[9，7，1，4]，
[1，4，3，6]，
[2，5，5，1]，
[2，2，9，9])***

很好，我们已经了解了在 Numpy 中创建、访问和操作数组。在系列的下一部分[，我们将会看到一个建立在 Numpy 图书馆基础上的图书馆——熊猫图书馆。Pandas 是一个库，它使得 Python 中的数据操作和分析更加容易。它为数字表和时间序列提供数据结构和操作。](/python-for-data-science-part-3-be9b08660af9)

在 [LinkedIn](https://www.linkedin.com/feed/) 上连接，并查看 Github(如下)以获得完整的笔记本。

[](https://github.com/rohanjoseph93/Python-for-data-science/blob/master/Python%20for%20Data%20Science%20-%20Part%202.ipynb) [## rohanjoseph 93/用于数据科学的 Python

### Python-for-data-science -用 Python 学习数据科学

github.com](https://github.com/rohanjoseph93/Python-for-data-science/blob/master/Python%20for%20Data%20Science%20-%20Part%202.ipynb)