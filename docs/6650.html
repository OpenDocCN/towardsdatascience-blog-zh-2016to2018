<html>
<head>
<title>Build Hand Gesture Recognition from Scratch using Neural Network — Machine Learning Easy and Fun</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用神经网络从零开始构建手势识别-机器学习简单而有趣</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-hand-gesture-recognition-from-scratch-using-neural-network-machine-learning-easy-and-fun-d7652dd105af?source=collection_archive---------4-----------------------#2018-12-24">https://towardsdatascience.com/build-hand-gesture-recognition-from-scratch-using-neural-network-machine-learning-easy-and-fun-d7652dd105af?source=collection_archive---------4-----------------------#2018-12-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="48e5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从自拍图像到学习神经网络模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2f44b975023b469e2d0879152581bee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g9L9KPslB_dno4cl"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@perrygrone?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Perry Grone</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="8114" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h2><p id="5f81" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">这种算法应该适用于所有不同的肤色，只要确保你的手放在中间。</p><p id="3713" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">对于这个解决方案，我使用了<a class="ae ky" href="https://www.gnu.org/software/octave/" rel="noopener ugc nofollow" target="_blank"> GNU Octave </a>和 Visual Studio 代码。</p><p id="2885" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><em class="mt">数据和代码可以在我的 Github 库中找到。</em></p><div class="mu mv gp gr mw mx"><a href="https://github.com/Gago993/HandGestureRecognitionNeuralNetwork" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">gago 993/HandGestureRecognitionNeuralNetwork</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">使用神经网络的手势识别软件-gago 993/handsgeturerecognitionneuralnetwork</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">github.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl ks mx"/></div></div></a></div><p id="a380" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们需要做的所有工作可以分为 5 个步骤:</p><ol class=""><li id="763f" class="nm nn it lx b ly mo mb mp li no lm np lq nq mn nr ns nt nu bi translated">生成和准备数据</li><li id="c522" class="nm nn it lx b ly nv mb nw li nx lm ny lq nz mn nr ns nt nu bi translated">生成要素</li><li id="db06" class="nm nn it lx b ly nv mb nw li nx lm ny lq nz mn nr ns nt nu bi translated">生成 ML 模型</li><li id="93ad" class="nm nn it lx b ly nv mb nw li nx lm ny lq nz mn nr ns nt nu bi translated">测试 ML 模型</li><li id="17ba" class="nm nn it lx b ly nv mb nw li nx lm ny lq nz mn nr ns nt nu bi translated">用 ML 模型预测</li></ol><p id="b66e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">那么让我们开始… </strong></p><h2 id="d19a" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">生成和准备数据</h2><p id="6b87" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">因为我们是从底层构建这个项目。我们需要做的第一件事是创建用于训练神经网络模型的数据。</p><p id="018e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">对于这一步，我使用我的电脑内置摄像头。我从手上抓拍了 78 张图片，展示了 4 种不同的手势，它们被分成 4 个文件夹。我裁剪了一些图像，使它们更适合稍后训练我们的模型。所有训练(准备)图像都存储在<strong class="lx iu"> <em class="mt">数据集</em> </strong>文件夹中。</p><ul class=""><li id="6843" class="nm nn it lx b ly mo mb mp li no lm np lq nq mn oa ns nt nu bi translated">左—包含 27 个向左指的手的图像</li><li id="27fe" class="nm nn it lx b ly nv mb nw li nx lm ny lq nz mn oa ns nt nu bi translated">右-包含 24 个向右指的手的图像</li><li id="a861" class="nm nn it lx b ly nv mb nw li nx lm ny lq nz mn oa ns nt nu bi translated">手掌—包含 11 个手掌图像</li><li id="c884" class="nm nn it lx b ly nv mb nw li nx lm ny lq nz mn oa ns nt nu bi translated">和平—包含 14 个和平之手的图像(V 形符号)</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/8ed250cd5275aee219d5b601d40617fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*C9FRseFZtpctABA4iLsjjw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Image 1: Dataset Example (Peace V Sign)</figcaption></figure><h2 id="1929" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">生成要素</h2><p id="7682" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">训练图像准备就绪后，我们可以继续下一步，即处理所有图像并创建特征。从图像中分离手的主要算法通过几个简单的步骤完成:</p><ol class=""><li id="8998" class="nm nn it lx b ly mo mb mp li no lm np lq nq mn nr ns nt nu bi translated">加载图像</li><li id="6b42" class="nm nn it lx b ly nv mb nw li nx lm ny lq nz mn nr ns nt nu bi translated">将图像大小调整为 50x50</li><li id="fffe" class="nm nn it lx b ly nv mb nw li nx lm ny lq nz mn nr ns nt nu bi translated">将图像从 RGB 转换为 YCbCr 颜色</li><li id="abf8" class="nm nn it lx b ly nv mb nw li nx lm ny lq nz mn nr ns nt nu bi translated">选择中心点颜色(期望手放在图像的中间)</li><li id="652a" class="nm nn it lx b ly nv mb nw li nx lm ny lq nz mn nr ns nt nu bi translated">根据步骤 3 中定义的肤色范围分割手部。</li><li id="42f9" class="nm nn it lx b ly nv mb nw li nx lm ny lq nz mn nr ns nt nu bi translated">用白色标记所选像素，用黑色标记其他像素</li></ol><p id="78b2" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这个算法放在<strong class="lx iu"><em class="mt">processskinimage . m</em></strong>文件中。我记下了代码中的每一步。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="1158" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">该图像皮肤处理由<strong class="lx iu"><em class="mt">create _ image _ dataset . m</em></strong>文件使用，该文件遍历所有图像，使用上述代码处理它们，并将它们分别写入左、右、手掌、和平文件夹中名为<strong class="lx iu"><em class="mt">dataset _ resized</em></strong>的单独文件夹中。</p><p id="e2ca" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">最后，我们需要准备我们的图像，以便它们可以用于生成和测试我们的神经网络模型。因为我们得到了 78 幅图像，它们是 50x50 像素，所以我们将它们保存为 78x2500 大小的矩阵，其中每一列代表我们图像中的像素。我们也将随机地把矩阵分成两组。训练矩阵将被保存在<strong class="lx iu"> <em class="mt"> x_features_train </em> </strong>矩阵中，并将包含 80%的图像和<strong class="lx iu"> <em class="mt"> x_features_test </em> </strong>中的测试矩阵以及其他 20%的图像。标签将分别保存在<strong class="lx iu"> <em class="mt"> y_labels_train </em> </strong>和<strong class="lx iu"><em class="mt">y _ labels _ test</em></strong>中。</p><p id="4ea1" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">创建特征矩阵的代码如下所示</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="fd33" class="kz la it of b gy oj ok l ol om">...<br/>% Generate random number from 1 to 10<br/>randNum = ceil(rand() * 10);</span><span id="fc31" class="kz la it of b gy on ok l ol om">% Split the images in 80%-20% train-test set<br/>if randNum &gt; 2<br/>% Create the features for the image<br/>X_train = [X_train; image_out(:)'];<br/>y_train = [y_train; label];<br/>else<br/>X_test = [X_test; image_out(:)'];<br/>y_test = [y_test; label];<br/>endif<br/>...</span></pre><p id="79e2" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">有四种类型的标签:</p><ul class=""><li id="fac2" class="nm nn it lx b ly mo mb mp li no lm np lq nq mn oa ns nt nu bi translated">[1 0 0 0] —左指手形图像</li><li id="ea75" class="nm nn it lx b ly nv mb nw li nx lm ny lq nz mn oa ns nt nu bi translated">[0 1 0 0] —右手图像</li><li id="d55b" class="nm nn it lx b ly nv mb nw li nx lm ny lq nz mn oa ns nt nu bi translated">[0 0 1 0] —手掌图像</li><li id="316c" class="nm nn it lx b ly nv mb nw li nx lm ny lq nz mn oa ns nt nu bi translated">[0 0 0 1] —和平标志手形图像</li></ul><p id="b763" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这个标签是在<strong class="lx iu"><em class="mt">create _ image _ dataset . m</em></strong>中创建的，如下面的代码所示。其中<strong class="lx iu"> <em class="mt">文件夹</em> </strong> <em class="mt"> </em>是包含图像的文件夹名称，<strong class="lx iu"> <em class="mt">是成员</em> </strong>从上面的列表中返回 4 个选项中的一个。</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="9ea0" class="kz la it of b gy oj ok l ol om">...<br/>label_keys = { 'left', 'right', 'palm', 'peace'};<br/>...<br/>label = ismember(label_keys, folder);<br/>...</span></pre><p id="b0ea" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这个脚本完成后，我们可以在<strong class="lx iu"><em class="mt">dataset _ resized</em></strong>文件夹中检查已处理的图像，我们应该会看到类似这样的内容</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/651fa62bcad73a3096c55239135438ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:102/format:webp/1*w4M4LM_0_kZVc4jxN4GbQw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Image 2: Processed Image (Peace V Sign)</figcaption></figure><p id="d6f5" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">还应该有<strong class="lx iu"><em class="mt">x _ features _ train</em></strong>和<strong class="lx iu"><em class="mt">y _ labels _ train</em></strong>文件，我们将在下一步中使用它们来训练我们的模型，还有<strong class="lx iu"><em class="mt">x _ features _ test</em></strong>和<strong class="lx iu"><em class="mt">y _ labels _ test</em></strong>用于稍后测试我们的模型。</p></div><div class="ab cl op oq hx or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="im in io ip iq"><p id="e53e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在继续之前，在这篇博客中，我假设你已经熟悉神经网络，这就是为什么我不打算深入神经网络的解释。</p><p id="47ae" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了充分理解概念和公式，我建议阅读我的帖子，以便更深入地理解神经网络。</p><div class="mu mv gp gr mw mx"><a rel="noopener follow" target="_blank" href="/everything-you-need-to-know-about-neural-networks-and-backpropagation-machine-learning-made-easy-e5285bc2be3a"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">你需要知道的关于神经网络和反向传播的一切-机器学习变得容易…</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">神经网络的基础解释，包括理解背后的数学</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">towardsdatascience.com</p></div></div><div class="ng l"><div class="ow l ni nj nk ng nl ks mx"/></div></div></a></div></div><div class="ab cl op oq hx or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="im in io ip iq"><h2 id="44c3" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">生成 ML 模型</h2><p id="a010" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">让我们从定义我们的神经网络结构开始。我们将在网络中使用一个隐藏层。输入层的大小将是 2500 个节点，因为我们的图像是 50x50 像素。隐藏层大小将是 25 个节点，输出将是 4 个节点(4 种类型的符号)。</p><p id="03ab" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">定义隐藏层大小没有严格的公式，但通常取决于“它与数据的拟合程度如何？”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/1e77b59d4272e069e9a1e0030ac3731a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8cCcJ9C1LGj8PYtx6hWCug.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Image 3: Andrew Ng on Neural Network Size</figcaption></figure><p id="cfe9" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这里我们将使用<strong class="lx iu"> <em class="mt"> main.m </em> </strong>文件，我们将:</p><ul class=""><li id="f73d" class="nm nn it lx b ly mo mb mp li no lm np lq nq mn oa ns nt nu bi translated">加载要素和标注</li><li id="81d3" class="nm nn it lx b ly nv mb nw li nx lm ny lq nz mn oa ns nt nu bi translated">随机初始化θ值(NN 节点权重)</li><li id="72f1" class="nm nn it lx b ly nv mb nw li nx lm ny lq nz mn oa ns nt nu bi translated">创建成本函数并向前传播</li><li id="6dad" class="nm nn it lx b ly nv mb nw li nx lm ny lq nz mn oa ns nt nu bi translated">为 NN 成本函数创建梯度(<em class="mt">反向传播</em></li><li id="f19d" class="nm nn it lx b ly nv mb nw li nx lm ny lq nz mn oa ns nt nu bi translated">使用<strong class="lx iu"> <em class="mt"> fmincg </em> </strong>最小化器最小化成本函数</li></ul><p id="5d92" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">加载特征和标签</strong></p><p id="5082" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">让我们开始第一步，加载要素和标签。我们通过使用<strong class="lx iu"> <em class="mt"> dlmread </em> </strong>函数来实现。</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="613f" class="kz la it of b gy oj ok l ol om">...<br/>X = dlmread('x_features_train');<br/><br/>% Labels for each processed training image<br/>%[1 0 0 0] - left, [0 1 0 0] - right, [0 0 1 0] - palm, [0 0 0 1] - peace<br/>y = dlmread('y_labels_train');<br/>...</span></pre><p id="396e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">随机初始化θ值(NN 节点权重)</strong></p><p id="f87f" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">接下来我们需要使用<strong class="lx iu"><em class="mt">randinitializeweights . m</em></strong>函数初始化 Theta 值。它由下面的代码表示</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="a249" class="kz la it of b gy oj ok l ol om">epsilon = sqrt(6) / (L_in + L_out);<br/>W = zeros(L_out, 1 + L_in);<br/>W = (rand(L_out, 1 + L_in) * 2 * epsilon) - epsilon;</span></pre><p id="e1ca" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">其中生成的值在[-ε，ε]之间。该代码与“均匀分布方差”的统计公式相关。如果你对这个公式更感兴趣，我会在这个博客的末尾留下链接，或者你可以提出问题。</p><p id="a373" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">创建成本函数并向前传播</strong></p><p id="5583" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们的下一个目标是实现下面等式定义的<em class="mt">成本函数</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/4b96a6ee044eba5192148f339643c850.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OrACH0OzclVrFN7jGb9W7g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Image 4: Regularized Cost Function</figcaption></figure><p id="1546" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">其中<em class="mt"> g </em>是激活函数(在这种情况下是 Sigmoid 函数)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/c2ad5cfdb4dfaeac283617f7c830cf21.png" data-original-src="https://miro.medium.com/v2/resize:fit:338/format:webp/1*pDL5viYIKR21wUH8CZx19A.png"/></div></figure><p id="a162" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了计算成本，我们需要使用前馈计算。代码在<strong class="lx iu"><em class="mt">nncostfunction . m .</em></strong>中实现。我们将在示例中使用 for 循环来计算成本，我们还需要将 1 的列添加到 X 矩阵中，表示“偏差”值。θ₁(θ1)和θ₂(θ2)值是神经网络中每个单元的参数，θ₁的第一行对应于第二层中的第一个隐藏单元。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="c3f8" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">为 NN 成本函数创建梯度(<em class="mt">反向传播</em> ) </strong></p><p id="81e7" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了能够最小化成本函数，我们需要计算 NN 成本函数的梯度。为此，我们将使用<em class="mt">反向传播</em>算法<em class="mt">，</em>是“误差反向传播”的缩写，<em class="mt"> </em>用于最小化我们的成本函数，这意味着最小化我们的 NN 的误差和最小化每个输出神经元的误差。这个计算是在<strong class="lx iu"><em class="mt">nncostfunction . m</em></strong>中实现的代码的一部分</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="743b" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">使用<em class="mt"> fmincg </em> minimizer </strong>最小化成本函数</p><p id="d1af" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">一旦我们计算出梯度，我们可以通过使用高级优化器(如<em class="mt"> fmincg)最小化成本函数 J(θ)来训练神经网络。</em>这个函数不是 Octave 的一部分，所以我是从吴恩达的<a class="ae ky" href="https://www.coursera.org/learn/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习课程中得到的。据我所知，这个函数比 Octave 中实现的函数更快，它使用了</a><a class="ae ky" href="https://en.wikipedia.org/wiki/Conjugate_gradient_method" rel="noopener ugc nofollow" target="_blank">共轭梯度法</a>。</p><p id="a88c" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><em class="mt"> fmincg </em>接受 3 个参数，如下面的代码示例所示。它采用成本函数、连接成单个向量的初始θ (Theta)参数和选项参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="bd23" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在我们的测试例子上运行<em class="mt"> fmincg </em>之后，我们得到了一个向量中的θ值，我们需要在矩阵中对它们进行整形，以简化矩阵乘法。</p><h2 id="e57a" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">测试 ML 模型</h2><p id="22a9" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">现在，我们成功地从神经网络中生成了我们的 Theta(权重)值。接下来要做的是检查我们的模型与训练的吻合程度，以及它在测试数据上的表现。</p><p id="14d4" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了预测我们将使用<strong class="lx iu"> <em class="mt">预测</em> </strong>函数位于<strong class="lx iu"> <em class="mt">预测. m </em> </strong>文件中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="7d37" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">该函数采用参数和特征矩阵。然后，它将表示“偏差”值的 1 列添加到特征矩阵中。只需将两个 NN 层的特征乘以θ值。然后，它获得大小为(number_of_images x 4)的向量 h2，其中每列(4)表示该图像在该类别中的可能性(左、右、手掌、和平)。最后 if 返回概率最高的一个。</p><p id="ec67" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">让我们执行训练集准确性和测试集准确性。</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="7352" class="kz la it of b gy oj ok l ol om">...<br/>pred = predict(Theta1, Theta2, X_train);<br/>% Compare the prediction with the actual values<br/>[val idx] = max(y_train, [], 2);<br/>fprintf('\nTraining Set Accuracy: %f\n', mean(double(pred == idx)) * 100);</span><span id="acd0" class="kz la it of b gy on ok l ol om">...<br/>pred = predict(Theta1, Theta2, X_test);<br/>% Compare the prediction with the actual values<br/>[val idx] = max(y_test, [], 2);<br/>fprintf('\nTest Set Accuracy: %f\n', mean(double(pred == idx)) * 100);</span></pre><p id="7365" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们得到的是</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="ff7a" class="kz la it of b gy oj ok l ol om">Training Set Accuracy: 100.000000%<br/>Test Set Accuracy: 90.909091%</span></pre><h2 id="2bd7" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">用 ML 模型预测</h2><p id="cb13" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我还制作了一些额外的图片，并将它们放在<strong class="lx iu"> <em class="mt">测试</em> </strong>文件夹中。它们代表完整的图像(未编辑)，所以我可以测试神经网络模型的性能。我得到的是对他们四个人的预测。</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="22ee" class="kz la it of b gy oj ok l ol om">pred =  2<br/>Type: right</span><span id="989d" class="kz la it of b gy on ok l ol om">pred =  1<br/>Type: left</span><span id="69e6" class="kz la it of b gy on ok l ol om">pred =  3<br/>Type: palm</span><span id="43b3" class="kz la it of b gy on ok l ol om">pred =  4<br/>Type: peace</span></pre><p id="4f02" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">您可以用您的图像甚至您自己的训练图像来尝试这一点。只需将您的训练图像放在<strong class="lx iu"> <em class="mt">数据集</em> </strong>文件夹下，并调用<strong class="lx iu"><em class="mt">create _ image _ dataset . m</em></strong>文件来创建训练和测试矩阵。同样所有的<strong class="lx iu"> <em class="mt">测试</em> </strong>图片都在<strong class="lx iu"> <em class="mt">测试</em> </strong>文件夹下，你就可以调用<strong class="lx iu"> <em class="mt"> main.m </em> </strong>脚本了。</p></div><div class="ab cl op oq hx or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="im in io ip iq"><h1 id="30dd" class="pa la it bd lb pb pc pd le pe pf pg lh jz ph ka ll kc pi kd lp kf pj kg lt pk bi translated">结论</h1><p id="c4d7" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">恭喜你从零开始构建你的机器学习神经网络模型。希望这将有助于理解使用神经网络时的总体情况以及如何迈出第一步。如有任何问题或建议，请发表评论或联系我。</p><p id="6b7f" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">希望你喜欢它！</p><h2 id="56a4" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">有用的链接</h2><div class="mu mv gp gr mw mx"><a href="https://en.wikibooks.org/wiki/Statistics/Distributions/Uniform#Variance" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">统计/分布/制服- Wikibooks，开放世界的开放书籍</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">顾名思义,(连续)均匀分布是一种概率密度为……</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">en.wikibooks.org</p></div></div></div></a></div><div class="mu mv gp gr mw mx"><a href="https://stats.stackexchange.com/questions/47590/what-are-good-initial-weights-in-a-neural-network#answer-297777" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">神经网络中什么是好的初始权重？</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">我刚刚听说，从范围$(\frac{-1}中选择神经网络的初始权重是一个好主意…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">stats.stackexchange.com</p></div></div><div class="ng l"><div class="pl l ni nj nk ng nl ks mx"/></div></div></a></div><div class="mu mv gp gr mw mx"><a href="https://mattmazur.com/2015/03/17/a-step-by-step-backpropagation-example/" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">一个逐步反向传播的例子</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">背景技术反向传播是训练神经网络的常用方法。网上不缺论文说…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">mattmazur.com</p></div></div><div class="ng l"><div class="pm l ni nj nk ng nl ks mx"/></div></div></a></div></div></div>    
</body>
</html>