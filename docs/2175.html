<html>
<head>
<title>GPU Optimized dynamic programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GPU优化的动态编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/gpu-optimized-dynamic-programming-8d5ba3d7064f?source=collection_archive---------4-----------------------#2017-12-30">https://towardsdatascience.com/gpu-optimized-dynamic-programming-8d5ba3d7064f?source=collection_archive---------4-----------------------#2017-12-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f70e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">利用GPU计算能力开发动态编程的并行性。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bd3f3688bba98e6be2346eee82ac7bf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p_LLEzTeExOPsF-pWvI25w.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: <a class="ae kv" href="http://www.mandurahmail.com.au/story/4326806/new-campaign-to-keep-drivers-safe-on-rural-roads/" rel="noopener ugc nofollow" target="_blank">link</a></figcaption></figure><p id="575d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来考虑一下<strong class="ky ir"> <em class="ls">路径和:项目欧拉问题81中的两路</em></strong>(<a class="ae kv" href="https://projecteuler.net/problem=81" rel="noopener ugc nofollow" target="_blank">环节</a>)。探索解的动态编程范式和GPU优化是我们感兴趣的问题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/f088806f527b9ff9634c86b9fb3c3ecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*pQLWVzip3HWQWC2ouWXwoA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Project Euler: 81</figcaption></figure><p id="1edd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您需要通过向右或向下移动矩阵中具有最小单元聚合和的单元，从左上向右下遍历。所以在左边的图中，红色区域展示了满足给定条件的路径。</p><h1 id="e572" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">动态程序建模</h1><p id="cfcd" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">对于上述任务，我们可以如下对动态程序建模。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/f7f37837f9d64ee1dace0fa9ee8dbfa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*isS8y7m4wpRq04pxAr2lnw.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Dynamic Approach</figcaption></figure><p id="7666" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以从原点<strong class="ky ir"> <em class="ls"> O </em> </strong>开始遍历，并向右或向下移动。如果我们移动到B的成本是<strong class="ky ir"> <em class="ls">成本(O + B) </em> </strong>，移动到<strong class="ky ir"> A </strong>给出<strong class="ky ir"> <em class="ls">成本(O + A) </em> </strong>。我们在拐角处没有选择的余地。考虑移动到x点，我们有两个选择。因此，现在正确的值是<strong class="ky ir"> <em class="ls"> min(Cost(A + X)，Cost(B + X)) </em> </strong>。同样，我们可以遍历整个矩阵，更新从其<strong class="ky ir"> <em class="ls">顶部</em> </strong>和<strong class="ky ir"> <em class="ls">左侧</em> </strong>双亲到特定单元的最小范围。这需要<strong class="ky ir"> O(mn) </strong>的迭代次数，在我们的例子中我们考虑<strong class="ky ir"> <em class="ls"> 80 x 80 </em> </strong>导致我们<strong class="ky ir"><em class="ls">6400</em></strong>次迭代。现在让我们从GPU的角度来考虑这个问题。在GPU中，所有的单元都是同时计算的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/ebf5e5f51958df200b02ba8b3dbb25fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*I4UWpI2X9epJNlePree18w.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">GPU Computation</figcaption></figure><p id="fb37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如所展示的，尽管在整个矩阵的初始迭代中立刻计算了所有单元，但是只有具有标记<strong class="ky ir"> 1 </strong>的单元将被计算为具有正确的值。仅仅一次迭代之后，带有标记<strong class="ky ir"> 2 </strong>的单元将不会计算出正确的值，因为此时带有标记<strong class="ky ir"> 1 </strong>的单元不具有正确的值。同样，我们必须多次运行程序，以获得单元格中的正确数字。在图中，标有相同数字的单元可以并行计算，这是动态程序中可用的并行度。我们对GPU所要做的就是虚线所示的正确的<em class="ls">行刷</em>次数，但是有多少呢？它显然是行数和列数的总和。因此，时间复杂度是<strong class="ky ir"> O(m+n) </strong>在我们的例子中是160。这是一个巨大的收获。然而，由于我们一次又一次地计算整个矩阵，我们需要存储原始矩阵，从而增加了程序的空间复杂度。</p><h1 id="7c09" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">示例代码</h1><h2 id="0e93" class="ms lv iq bd lw mt mu dn ma mv mw dp me lf mx my mg lj mz na mi ln nb nc mk nd bi translated">pom.xml和DynamicProgramming.java</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5bc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用这种方法可以很快地得到非常大的矩阵的结果。迭代次数的上限是行数和列数之和，而不是乘积。我在代码中使用的数据集可以在项目欧拉问题81的网页上找到。</p><p id="6315" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">链接:<a class="ae kv" href="https://projecteuler.net/problem=81" rel="noopener ugc nofollow" target="_blank">https://projecteuler.net/problem=81</a></p></div></div>    
</body>
</html>