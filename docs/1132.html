<html>
<head>
<title>Web scraping tutorial in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R 中的网页抓取教程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/web-scraping-tutorial-in-r-5e71fd107f32?source=collection_archive---------4-----------------------#2017-08-02">https://towardsdatascience.com/web-scraping-tutorial-in-r-5e71fd107f32?source=collection_archive---------4-----------------------#2017-08-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="99bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几天前，<a class="ae kl" href="http://www.dataschool.io/" rel="noopener ugc nofollow" target="_blank">数据学校</a>的<a class="ae kl" href="https://twitter.com/justmarkham?lang=en" rel="noopener ugc nofollow" target="_blank">凯文·马卡姆</a>发表了一篇很好的<a class="ae kl" href="http://www.dataschool.io/python-web-scraping-of-president-trumps-lies/" rel="noopener ugc nofollow" target="_blank">教程</a>，讲述了使用 16 行 Python 代码进行网络抓取的方法。</p><div class="km kn gp gr ko kp"><a href="http://www.dataschool.io/python-web-scraping-of-president-trumps-lies/" rel="noopener  ugc nofollow" target="_blank"><div class="kq ab fo"><div class="kr ab ks cl cj kt"><h2 class="bd ir gy z fp ku fr fs kv fu fw ip bi translated">网络抓取总统的 16 行 Python 谎言</h2><div class="kw l"><h3 class="bd b gy z fp ku fr fs kv fu fw dk translated">注意:本教程以 Jupyter 笔记本的形式提供，谎言的数据集以 CSV 文件的形式提供，两者都…</h3></div><div class="kx l"><p class="bd b dl z fp ku fr fs kv fu fw dk translated">www.dataschool.io</p></div></div></div></a></div><p id="dc8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">教程很简单，制作精良。我强烈建议你看一看。事实上，这样的教程激励我复制结果，但这次使用 r。在 Kevin 的允许下，我将使用与他的博客帖子相似的布局。此外，我将使用同一个网站发表一篇名为<a class="ae kl" href="https://www.nytimes.com/interactive/2017/06/23/opinion/trumps-lies.html" rel="noopener ugc nofollow" target="_blank">特朗普的谎言</a>的观点文章。这将有助于对这两种方法进行比较。</p><h1 id="a022" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">检查纽约时报的文章</h1><p id="9682" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">为了更好地描述我们将要学习的文章，我鼓励你看看 Kevin 的教程<a class="ae kl" href="http://www.dataschool.io/python-web-scraping-of-president-trumps-lies/" rel="noopener ugc nofollow" target="_blank">。总之，我们感兴趣的数据由一个谎言记录组成，每个谎言包含 4 个部分:</a></p><ul class=""><li id="2586" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">谎言的日期</li><li id="8d41" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">谎言本身</li><li id="84f5" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">解释为什么这是一个谎言</li><li id="5bae" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">支持解释的文章的 URL(嵌入在文本中)</li></ul><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mp"><img src="../Images/4a3b5db5cafef845c9ee7e9d7306e5ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7sB5AT4KX0BsWbzbn33kmQ.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">The data that we want to extract from the web page.</figcaption></figure><h1 id="36f9" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">将网页读入 R</h1><p id="47b9" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">要将网页读入 R，我们可以使用 R 大师 Hadley Wickham 制作的包。这个包的灵感来自于像<a class="ae kl" href="https://www.crummy.com/software/BeautifulSoup/" rel="noopener ugc nofollow" target="_blank"> Beautiful Soup </a>这样的库，使得从 html 网页中抓取数据变得容易。要使用的第一个重要函数是<code class="fe nf ng nh ni b">read_html()</code>，它返回一个包含关于网页的所有信息的<a class="ae kl" href="https://en.wikipedia.org/wiki/XML" rel="noopener ugc nofollow" target="_blank"> XML </a>文档。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="ba18" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">收集所有的记录</h1><p id="3a8d" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">正如 Kevin 的教程中所解释的那样，每条记录在 HTML 代码中具有以下结构:</p><p id="e6e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nf ng nh ni b">&lt;span class="short-desc"&gt;&lt;strong&gt; DATE &lt;/strong&gt; LIE &lt;span class="short-truth"&gt;&lt;a href="URL"&gt; EXPLANATION &lt;/a&gt;&lt;/span&gt;&lt;/span&gt;</code></p><p id="37e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，要收集所有的谎言，我们需要识别所有属于<code class="fe nf ng nh ni b">class="short-desc"</code>的<code class="fe nf ng nh ni b">&lt;span&gt;</code>标签。将帮助我们这样做的功能是<code class="fe nf ng nh ni b">html_nodes()</code>。这个函数需要我们已经阅读过的 XML 文档和我们想要选择的节点。对于后者，我们鼓励使用<a class="ae kl" href="http://selectorgadget.com/" rel="noopener ugc nofollow" target="_blank"> SelectorGadget </a>，这是一个开源工具，可以轻松地生成和发现 CSS 选择器。使用这样一个工具，我们发现所有的谎言都可以通过使用选择器<code class="fe nf ng nh ni b">".short-desc"</code>来选择。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5fef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将返回一个包含 116 个 XML 节点的列表，其中包含了网页中 116 个谎言的信息。</p><p id="5631" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我使用的是 magritter<a class="ae kl" href="http://magrittr.tidyverse.org/" rel="noopener ugc nofollow" target="_blank">包中的<code class="fe nf ng nh ni b">%&gt;%</code>管道操作符，它可以帮助将复杂的操作表达为由简单、容易理解的部分组成的优雅管道。</a></p><h1 id="5749" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">提取日期</h1><p id="fe86" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">让我们从简单的开始，专注于从第一个谎言中提取所有必要的细节。然后，我们可以很容易地将这种方法推广到其他领域。请记住，单个记录的一般结构是:</p><p id="5987" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nf ng nh ni b">&lt;span class="short-desc"&gt;&lt;strong&gt; <strong class="jp ir">DATE </strong>&lt;/strong&gt; <strong class="jp ir">LIE </strong>&lt;span class="short-truth"&gt;&lt;a href="<strong class="jp ir">URL</strong>"&gt; <strong class="jp ir">EXPLANATION </strong>&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;</code></p><p id="1bdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，日期嵌入在<code class="fe nf ng nh ni b">&lt;strong&gt;</code>标签中。要选择它，我们可以使用选择器<code class="fe nf ng nh ni b">"strong"</code>使用<code class="fe nf ng nh ni b">html_nodes()</code>功能。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="650d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们需要使用<code class="fe nf ng nh ni b">html_text()</code>函数只提取文本，trim 参数被激活来修剪前导和尾随空格。最后，我们利用<a class="ae kl" href="http://stringr.tidyverse.org/" rel="noopener ugc nofollow" target="_blank"> stringr </a>包将年份添加到提取的日期中。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="0ad8" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">提取谎言</h1><p id="fcc0" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">为了选择 lie，我们需要使用 xml2 包中的<code class="fe nf ng nh ni b">xml_contents()</code>函数(这个包是 rvest 包所需要的，所以没有必要加载它)。该函数返回一个包含属于<code class="fe nf ng nh ni b">first_result</code>的节点的列表。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="4f6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们感兴趣的是谎言，它是第二个节点的文本。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2517" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，谎言周围多了一对引号(“…”)。为了去掉它们，我们只需使用 stringr 包中的<code class="fe nf ng nh ni b">str_sub()</code>函数来选择谎言。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="e136" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">提取解释</h1><p id="511a" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">希望现在不要太复杂，我们只需要选择属于<code class="fe nf ng nh ni b">class=".short-truth"</code>的<code class="fe nf ng nh ni b">&lt;span&gt;</code>标签中的文本就可以提取解释。这将把文本连同左括号和右括号一起提取出来，但是我们可以很容易地去掉它们。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="d48f" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">正在提取 URL</h1><p id="5da3" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">最后，要获取 URL，请注意这是<code class="fe nf ng nh ni b">&lt;a&gt;</code>标签中的一个属性。我们简单地用<code class="fe nf ng nh ni b">html_nodes()</code>函数选择这个节点，然后用<code class="fe nf ng nh ni b">html_attr()</code>函数选择<code class="fe nf ng nh ni b">href</code>属性。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="fcaf" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">构建数据集</h1><p id="214c" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们找到了提取第一条记录的 4 个部分的方法。我们可以使用 for 循环将这个过程扩展到所有其他地方。最后，我们想要一个有 116 行(每条记录一行)和 4 列(保存日期、谎言、解释和 URL)的数据框。一种方法是创建一个空数据框，并在处理每个新记录时简单地添加一个新行。但是，这被认为不是一个好的做法。正如这里建议的<a class="ae kl" href="http://r4ds.had.co.nz/iteration.html#unknown-output-length" rel="noopener ugc nofollow" target="_blank"/>，我们将为每条记录创建一个单独的数据帧，并将它们全部存储在一个列表中。一旦我们有了 116 个数据帧，我们将使用<a class="ae kl" href="http://dplyr.tidyverse.org/" rel="noopener ugc nofollow" target="_blank"> dplyr </a>包中的<code class="fe nf ng nh ni b">bind_rows()</code>函数将它们绑定在一起。这就创建了我们想要的数据集。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6b65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，日期列被认为是一个字符向量。如果把它作为日期时间向量就更好了。为此，我们可以使用<a class="ae kl" href="http://lubridate.tidyverse.org/" rel="noopener ugc nofollow" target="_blank"> lubridate </a>包并使用<code class="fe nf ng nh ni b">mdy()</code>函数(月-日-年)进行转换。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="b405" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">将数据集导出到 CSV 文件</h1><p id="7ef4" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">如果想导出数据集，可以使用 R 默认自带的<code class="fe nf ng nh ni b">write.csv()</code>函数，或者使用<a class="ae kl" href="http://readr.tidyverse.org/" rel="noopener ugc nofollow" target="_blank"> readr </a>包中的<code class="fe nf ng nh ni b">write_csv()</code>函数，这比第一个函数快两倍，也更方便。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="67c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，要检索数据集，可以使用默认函数<code class="fe nf ng nh ni b">read.csv()</code>或<a class="ae kl" href="http://readr.tidyverse.org/" rel="noopener ugc nofollow" target="_blank"> readr </a>包中的<code class="fe nf ng nh ni b">read_csv()</code>函数。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="f621" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">摘要</h1><p id="3cd1" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">本教程的完整代码如下所示:</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5e65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还想提一下，stringr、dplyr、lubridate 和 readr 包都是<a class="ae kl" href="http://tidyverse.org/" rel="noopener ugc nofollow" target="_blank"> tidyverse </a>家族的一部分。这是一个 R 包的集合，它们被设计成一起工作来使<a class="ae kl" href="http://r4ds.had.co.nz/introduction.html#what-you-will-learn" rel="noopener ugc nofollow" target="_blank">数据分析过程</a>更容易。事实上，你也可以使用流行的<a class="ae kl" href="http://purrr.tidyverse.org/" rel="noopener ugc nofollow" target="_blank"> purrr </a>包来避免 for 循环。但是，这需要创建一个函数，将每个记录映射到一个数据框。关于如何进行网络抓取的另一个例子，请看迪安·阿塔利写的这篇很棒的<a class="ae kl" href="http://deanattali.com/blog/user2017/" rel="noopener ugc nofollow" target="_blank">博客文章</a>。</p><p id="b07b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望你觉得这个教程有用。它的目的不是展示哪种编程语言更好，而是向 Python 和 R 学习，以及增加您的编程技能和工具来处理更多样化的问题。</p></div></div>    
</body>
</html>