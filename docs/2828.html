<html>
<head>
<title>Depth / Breath First Search Matrix Traversal in Python with Interactive Code [ Back to Basics ]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用交互式代码在 Python 中进行深度/呼吸优先搜索矩阵遍历[回到基础知识]</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/depth-breath-first-search-matrix-traversal-in-python-with-interactive-code-back-to-basics-31f1eca46f55?source=collection_archive---------1-----------------------#2018-03-11">https://towardsdatascience.com/depth-breath-first-search-matrix-traversal-in-python-with-interactive-code-back-to-basics-31f1eca46f55?source=collection_archive---------1-----------------------#2018-03-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1e9f198f97d879283c3aec7218a7aa47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xJSyIlUfL8GodVkQyjAoOQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Image from <a class="ae kc" href="https://pixabay.com/en/fibonacci-spiral-science-board-3210943/" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="0844" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你想了解更多关于算法和人工智能的知识时，搜索算法是一个完美的起点。所以让我们从基本的<a class="ae kc" href="https://en.wikipedia.org/wiki/Breadth-first_search" rel="noopener ugc nofollow" target="_blank">呼吸优先搜索</a>和<a class="ae kc" href="https://en.wikipedia.org/wiki/Depth-first_search" rel="noopener ugc nofollow" target="_blank">深度优先搜索</a>开始遍历一个矩阵。</p><p id="e053" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，代码没有在任何其他方法优化。这是暴力实现。所以要小心。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="5771" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">给定矩阵/问题</strong></p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi li"><img src="../Images/bd0ccbf3830c52282cefa11b02612632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kFTvI2G-d8fOCV0zICwt6g.png"/></div></div></figure><p id="809b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">红框</strong> →我们的 1 所在的位置(我们要找的东西)<br/> <strong class="kf ir">黄框→ </strong>我们开始搜索的位置</p><p id="9320" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个问题很简单，给定矩阵的 n*n 个网格，将会有一个称为“1”的元素，我们想要找到这个值，换句话说，我们想要知道元素 1 的坐标。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="d6dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">深度优先搜索方法</strong></p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ln"><img src="../Images/c36e016000ca82da1b5b03164e19b271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*inFcNA4k9VKZv5XtRK6R2w.png"/></div></div></figure><p id="e067" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面是递归的 DFS 实现，我们有一个名为 visited 的变量(这是一个列表)来跟踪我们访问过的所有坐标。而如果我们接下来要访问的坐标不在这个列表中，我们就要访问那个位置。为了形象化这个搜索算法的开始序列，请见下文。</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi li"><img src="../Images/560ae32569c469ed17a80c055ca75c48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XYu7Ay-W4q6VRSGa_a8vDw.png"/></div></div></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="9c1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">呼吸优先搜索算法</strong></p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/da33ad20b94738ce226831a40e308c6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v6v36SjlCeSdFY_L-piQhw.png"/></div></div></figure><p id="68fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">BFS 算法也非常类似于 DFS。但是这次我们有一个队列变量来跟踪我们将要执行的下一个搜索坐标。另外，请注意，我们只是传递队列，而不是直接传递 x 和 y 坐标。再次想象这个算法的开始。</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi li"><img src="../Images/f3b2224459f55e5cb2df2baa47d6efd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BCHPs-fs59lYEqmqMv0NeA.png"/></div></div></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="fc56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">交互代码</strong></p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lp"><img src="../Images/e5a192149df81e799b855122a9045645.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dQCyMmihU25Izg25lCcLUg.png"/></div></div></figure><p id="e2b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lq">为了交互代码，我搬到了 Google Colab！所以你需要一个谷歌帐户来查看代码，你也不能在谷歌实验室运行只读脚本，所以在你的操场上做一个副本。最后，我永远不会请求允许访问你在 Google Drive 上的文件，仅供参考。编码快乐！</em></p><p id="bb0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要访问代码<a class="ae kc" href="https://colab.research.google.com/drive/1EhoK9zsBJUv_Id6lUeWjrHTXutsNg8bZ" rel="noopener ugc nofollow" target="_blank">，请点击此处。</a></p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="105a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">最后的话</strong></p><p id="86ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我很喜欢实现这些算法，下次我会尝试做恒星搜索。</p><p id="d72e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果发现任何错误，请发电子邮件到 jae.duk.seo@gmail.com 给我，如果你想看我所有的写作清单，请在这里查看我的网站。</p><p id="ccc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同时，在我的 twitter 上关注我<a class="ae kc" href="https://twitter.com/JaeDukSeo" rel="noopener ugc nofollow" target="_blank">这里</a>，访问<a class="ae kc" href="https://jaedukseo.me/" rel="noopener ugc nofollow" target="_blank">我的网站</a>，或者我的<a class="ae kc" href="https://www.youtube.com/c/JaeDukSeo" rel="noopener ugc nofollow" target="_blank"> Youtube 频道</a>了解更多内容。如果你感兴趣的话，我还做了解耦神经网络<a class="ae kc" href="https://becominghuman.ai/only-numpy-implementing-and-comparing-combination-of-google-brains-decoupled-neural-interfaces-6712e758c1af" rel="noopener ugc nofollow" target="_blank">的比较。</a></p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="83f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">参考</strong></p><ol class=""><li id="cabb" class="lr ls iq kf b kg kh kk kl ko lt ks lu kw lv la lw lx ly lz bi translated">python？，C. (2018)。为 python 选择除特定数字以外的随机整数？。Stackoverflow.com。检索于 2018 年 3 月 11 日，来自<a class="ae kc" href="https://stackoverflow.com/questions/17907213/choosing-random-integers-except-for-a-particular-number-for-python" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/17907213/choosing-random-integers-except-for-a-special-number-for-python</a></li><li id="6e5b" class="lr ls iq kf b kg ma kk mb ko mc ks md kw me la lw lx ly lz bi translated">Python？，M. (2018)。在 Python 中测量经过的时间？。Stackoverflow.com。检索于 2018 年 3 月 11 日，来自<a class="ae kc" href="https://stackoverflow.com/questions/7370801/measure-time-elapsed-in-python" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/7370801/measure-time-elapsed-in-python</a></li><li id="b4ae" class="lr ls iq kf b kg ma kk mb ko mc ks md kw me la lw lx ly lz bi translated">8.10.队列—同步队列类— Python 2.7.14 文档。(2018).Docs.python.org。检索于 2018 年 3 月 11 日，来自<a class="ae kc" href="https://docs.python.org/2/library/queue.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/2/library/queue.html</a></li><li id="bf88" class="lr ls iq kf b kg ma kk mb ko mc ks md kw me la lw lx ly lz bi translated">[复本]，H. (2018)。如何在推送新对象之前检查队列中是否存在对象？Stackoverflow.com。检索于 2018 年 3 月 11 日，来自<a class="ae kc" href="https://stackoverflow.com/questions/27024881/how-to-check-if-object-exists-in-queue-before-pushing-new-object/27025015" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/27024881/how-to-check-if-object-exists-in-queue-before-pushing-new-object/27025015</a></li><li id="e8d3" class="lr ls iq kf b kg ma kk mb ko mc ks md kw me la lw lx ly lz bi translated">修复错误-已达到最大递归深度。(2013).Python 技巧。检索于 2018 年 3 月 11 日，来自<a class="ae kc" href="https://pythontips.com/2013/08/31/fixing-error-maximum-recursion-depth-reached/" rel="noopener ugc nofollow" target="_blank">https://python tips . com/2013/08/31/fixing-error-maximum-recursion-depth-reached/</a></li><li id="5c40" class="lr ls iq kf b kg ma kk mb ko mc ks md kw me la lw lx ly lz bi translated">p . j .(2013 年)。sys.setrecursionlimit @说真的，不要用这个代码！。Seriously.dontusethiscode.com。检索于 2018 年 3 月 11 日，来自<a class="ae kc" href="http://seriously.dontusethiscode.com/2013/04/14/setrecursionlimit.html" rel="noopener ugc nofollow" target="_blank">http://serious . dontusethiscode . com/2013/04/14/setrecursionlimit . html</a></li><li id="5898" class="lr ls iq kf b kg ma kk mb ko mc ks md kw me la lw lx ly lz bi translated">A*搜索算法。(2018).En.wikipedia.org。检索于 2018 年 3 月 11 日，来自<a class="ae kc" href="https://en.wikipedia.org/wiki/A*_search_algorithm" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/A*_search_algorithm</a></li><li id="aaf3" class="lr ls iq kf b kg ma kk mb ko mc ks md kw me la lw lx ly lz bi translated">广度优先搜索。(2018).En.wikipedia.org。检索于 2018 年 3 月 11 日，来自 https://en.wikipedia.org/wiki/Breadth-first_search<a class="ae kc" href="https://en.wikipedia.org/wiki/Breadth-first_search" rel="noopener ugc nofollow" target="_blank"/></li><li id="0e90" class="lr ls iq kf b kg ma kk mb ko mc ks md kw me la lw lx ly lz bi translated">深度优先搜索。(2018).En.wikipedia.org。检索于 2018 年 3 月 11 日，来自 https://en.wikipedia.org/wiki/Depth-first_search<a class="ae kc" href="https://en.wikipedia.org/wiki/Depth-first_search" rel="noopener ugc nofollow" target="_blank"/></li></ol></div></div>    
</body>
</html>