<html>
<head>
<title>Tutorial: Webcam Paint Application Using OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">教程:使用 OpenCV 的网络摄像头绘画应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tutorial-webcam-paint-opencv-dbe356ab5d6c?source=collection_archive---------3-----------------------#2018-07-02">https://towardsdatascience.com/tutorial-webcam-paint-opencv-dbe356ab5d6c?source=collection_archive---------3-----------------------#2018-07-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2ede" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个关于如何构建 OpenCV 应用程序的教程，该应用程序可以跟踪对象的移动，用户可以通过移动对象在屏幕上绘图——我称之为网络摄像头绘画。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/9b93e3c67a55ad78a507f29dded77962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eQagCcmqCkAkRl0_QXnqyQ.png"/></div></div></figure><h1 id="345e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">项目描述</h1><p id="ffec" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">给定实时网络摄像头数据，这个类似 paint 的 python 应用程序使用 OpenCV 库来跟踪感兴趣的对象(在本例中是一个瓶盖),并允许用户通过移动对象来绘制，这使得绘制简单的东西既令人敬畏又具有挑战性。</p><p id="2155" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在此访问完整的项目代码:</p><div class="ma mb gp gr mc md"><a href="https://github.com/acl21/Webcam_Paint_OpenCV" rel="noopener  ugc nofollow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd ir gy z fp mi fr fs mj fu fw ip bi translated">acl21/Webcam_Paint_OpenCV</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">更新]:我将不再关注与回购相关的问题或邮件，因为我目前非常忙…</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">github.com</p></div></div></div></a></div><h1 id="2de1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">工作示例</h1><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="b6fb" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">代码要求</h1><p id="ae59" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这个应用程序是用 Python 3.6 编写的，它使用了非常著名的 OpenCV 库。OpenCV 是一个计算机视觉和机器学习软件库，包括许多常见的图像分析算法，可以帮助我们构建定制的智能计算机视觉应用程序。</p><p id="5e62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按照<a class="ae mo" href="https://medium.com/@akshaychandra21/how-to-install-opencv-and-keras-in-python-3-6-f5f721f0d0b3" rel="noopener">这篇中帖</a>在 Python 3 中安装 OpenCV。</p><h1 id="7ee6" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">视频跟踪快速介绍</h1><h2 id="1069" class="mp ky iq bd kz mq mr dn ld ms mt dp lh jy mu mv ll kc mw mx lp kg my mz lt na bi translated">视频跟踪</h2><p id="0175" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">为了执行视频跟踪，一种算法分析连续的视频帧，并输出帧之间的目标运动。算法多种多样，各有优缺点。在选择使用哪种算法时，考虑预期用途很重要。视觉跟踪系统有两个主要组成部分:目标表示和定位，以及过滤和数据关联。</p><p id="78e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">视频跟踪是使用摄像机在一段时间内定位一个移动对象(或多个对象)的过程。它有多种用途，其中一些是:人机交互、安全和监控、视频通信和压缩、增强现实、交通控制、医学成像和视频编辑。</p><p id="1934" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更多信息，<a class="ae mo" href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_tutorials.html" rel="noopener ugc nofollow" target="_blank">见</a>。</p><h2 id="1ab2" class="mp ky iq bd kz mq mr dn ld ms mt dp lh jy mu mv ll kc mw mx lp kg my mz lt na bi translated">什么是等高线？</h2><p id="b095" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">如果你是 OpenCV 的新手，在阅读本文中的代码之前，最好先浏览一下这个关于轮廓的教程页面。也看看这个 Jupyter <a class="ae mo" href="https://github.com/akshaychandra21/OpenCV_Basic_Exercises/blob/master/11%20-%20Contours.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>的轮廓。需要明确的是，术语“边缘”和“轮廓”经常互换使用，但这是不对的。如果你对这种差异的理解模糊不清，请浏览一下 ResearchGate 网站上的<a class="ae mo" href="https://www.researchgate.net/post/What_is_the_difference_between_edge_and_contour" rel="noopener ugc nofollow" target="_blank">这个问题帖子</a>。</p><h1 id="2915" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">代码解释</h1><h2 id="bf50" class="mp ky iq bd kz mq mr dn ld ms mt dp lh jy mu mv ll kc mw mx lp kg my mz lt na bi translated">第一步:初始化一些东西</h2><p id="a233" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">首先，我们导入必要的库。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb mn l"/></div></figure><p id="1b34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们初始化在以下步骤中使用的变量。</p><p id="a28a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nc"> blueLower </em>和<em class="nc"> blueUpper </em> numpy 阵列帮助我们找到蓝色的帽子。一旦发现蓝帽，内核<em class="nc">有助于使其平滑。<em class="nc"> bpoints </em>、<em class="nc">gppoints</em>、<em class="nc"> rpoints 和 ypoints </em> deques 分别用于存储蓝色、绿色、红色和黄色屏幕上绘制的点。</em></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb mn l"/></div></figure><h2 id="4732" class="mp ky iq bd kz mq mr dn ld ms mt dp lh jy mu mv ll kc mw mx lp kg my mz lt na bi translated">步骤 2:设置绘画界面</h2><p id="a6a8" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这是一件痛苦的事情。我们必须手动设置框架上每个彩色框的坐标。我们使用 OpenCV 函数<strong class="jp ir"><em class="nc">cv2 . rectangle()</em></strong>来绘制盒子。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb mn l"/></div></figure><h2 id="e649" class="mp ky iq bd kz mq mr dn ld ms mt dp lh jy mu mv ll kc mw mx lp kg my mz lt na bi translated">第三步:开始阅读视频(一帧一帧)</h2><p id="ff2f" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">现在我们使用 OpenCV 函数<strong class="jp ir"> <em class="nc"> cv2。VideoCapture() </em> </strong>从视频文件或网络摄像头实时逐帧读取视频(使用 while 循环)的方法。在这种情况下，我们将 0 传递给方法以从网络摄像头读取数据。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb mn l"/></div></figure><p id="5222" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使用方便，我们可以添加完全相同的画图界面。</p><h2 id="ad67" class="mp ky iq bd kz mq mr dn ld ms mt dp lh jy mu mv ll kc mw mx lp kg my mz lt na bi translated">步骤 4:找到感兴趣的轮廓(瓶盖)</h2><p id="806b" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">一旦我们开始读取网络摄像头馈送，我们就会借助<strong class="jp ir"><em class="nc">cv2 . in range()</em></strong>方法不断在帧中寻找蓝色对象，并使用在步骤 0 中初始化的<em class="nc"> blueUpper </em>和<em class="nc"> blueLower </em>变量。一旦我们找到轮廓，我们做一系列的图像操作，并使其平滑。它们让我们的生活变得更轻松。如果你想知道更多关于这些操作——腐蚀、变形和扩张，请查看<a class="ae mo" href="https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_imgproc/py_morphological_ops/py_morphological_ops.html" rel="noopener ugc nofollow" target="_blank">这个</a>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb mn l"/></div></figure><p id="61fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们找到轮廓(当找到轮廓时，如果 条件通过，则为<strong class="jp ir"> <em class="nc">)，我们使用轮廓的中心(蓝色帽)在屏幕上绘制它的移动。下面的代码做了同样的事情。</em></strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb mn l"/></div></figure><p id="ba2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码找到轮廓(最大的一个)，使用<strong class="jp ir"><em class="nc">cv2 . minenclosingcircle()</em></strong>和<strong class="jp ir"> <em class="nc"> cv2.circle() </em> </strong>方法围绕它画一个圆，借助<strong class="jp ir"><em class="nc">cv2 . moments()</em></strong>方法得到找到的轮廓的中心。</p><h2 id="0372" class="mp ky iq bd kz mq mr dn ld ms mt dp lh jy mu mv ll kc mw mx lp kg my mz lt na bi translated">第五步:开始绘图并存储绘图</h2><p id="2d60" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">现在我们开始跟踪轮廓中心接触屏幕的每一个点的坐标，以及它的颜色。我们将这些不同颜色的点存储在不同的 deques 中(<em class="nc">b 点</em>、<em class="nc">g 点</em>等)。).当轮廓的中心接触到我们在步骤 1 中放在屏幕上的一个彩色框时，我们将这些点存储在其各自的颜色队列中。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb mn l"/></div></figure><h2 id="94f8" class="mp ky iq bd kz mq mr dn ld ms mt dp lh jy mu mv ll kc mw mx lp kg my mz lt na bi translated">第六步:在屏幕上显示图画</h2><p id="6958" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">到目前为止，我们将所有点存储在它们各自的颜色队列中。现在我们用他们自己的颜色加入他们。OpenCV 函数<strong class="jp ir"> <em class="nc"> cv2.line() </em> </strong>为我们做到这一点提供了便利。下面的代码做了同样的事情。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb mn l"/></div></figure><p id="8870" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们用一条线连接每一帧中的所有点，并把它放在我们用<strong class="jp ir"> <em class="nc"> cv2.imshow() </em> </strong>方法创建的两个窗口上，它就像一个绘画应用程序一样完美地工作了。当我们进入 循环从网络摄像头读取数据时，从<strong class="jp ir"> <em class="nc">循环中掉出后，我们释放摄像头并使用以下代码行销毁所有窗口。</em></strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb mn l"/></div></figure><p id="a03c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！我们在 OpenCV 中成功地使用了一堆基本的图像处理工具和操作，创建了一个类似绘画的应用程序——网络摄像头绘画！</p><h1 id="c102" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">执行</h1><pre class="km kn ko kp gt nd ne nf ng aw nh bi"><span id="0394" class="mp ky iq ne b gy ni nj l nk nl">&gt; python Webcam_Paint_OpenCV.py</span></pre><h1 id="1a11" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">结论</strong></h1><p id="e57b" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这是 OpenCV 图像处理能力的简单演示。如果你觉得这很有趣或容易或无聊，或者认为这没有什么挑战性，我建议你尝试添加更多的绘画功能，如橡皮擦，不同类型的笔刷，颜色填充选项等。为了真正感受 OpenCV 有多有趣。</p><p id="dbca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望这个教程是有趣的。感谢阅读。</p><p id="6d8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">活也让别人活！<br/>答</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nm"><img src="../Images/e66597517477776e5267b92d82f03c58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kTMTZQ4EqYekvE9_RfnOzg.jpeg"/></div></div><figcaption class="nn no gj gh gi np nq bd b be z dk">Photo by <a class="ae mo" href="https://unsplash.com/photos/Sj0nhVIb4eY?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Kelli Tungay</a> on <a class="ae mo" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div></div>    
</body>
</html>