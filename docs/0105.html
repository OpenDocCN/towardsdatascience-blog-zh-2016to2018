<html>
<head>
<title>Feature Engineering: Bayesian Methods for Binning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">特征工程:宁滨的贝叶斯方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/feature-engineering-bayesian-methods-for-binning-38d29a29bb88?source=collection_archive---------0-----------------------#2017-03-11">https://towardsdatascience.com/feature-engineering-bayesian-methods-for-binning-38d29a29bb88?source=collection_archive---------0-----------------------#2017-03-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/934d0055dda626e017d21b83954015f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1_-zldMAxdh8WCbh_VuIPg.jpeg"/></div></div></figure><div class=""/><p id="261d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">任何数据科学难题中最关键的一块，或许也是最不迷人的一块:特征工程。这可能是漫长而令人沮丧的，但如果做得不好，它可能会给随后的任何建模或分析带来灾难。在这篇文章中，我希望揭示一种令人愉快的推理技术。</p><blockquote class="kz la lb"><p id="39ec" class="kb kc lc kd b ke kf kg kh ki kj kk kl ld kn ko kp le kr ks kt lf kv kw kx ky im bi translated">“应用机器学习”基本上是特征工程——吴恩达</p></blockquote><p id="671e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将数据点“组合”在一个特征中是一种常见的策略。根据您对某个特性的期望，它可以从简单到复杂。考虑这样一种情况，您想要对具有大量不同值的要素进行热编码。基于每个不同值的分桶可能会给你留下很大的特征空间，并且将来的模型容易过度拟合。</p><p id="45ac" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么怎么斗呢？已经提出了几种经验法则，包括<em class="lc">斯科特法则</em>、<em class="lc">克努特法则</em>和<em class="lc">弗里德曼-迪康尼斯法则</em>。这些方法的问题是它们都假设相同大小的箱，这是有问题的，并且不一定是最佳的。</p><p id="6922" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">是时候打破一些神话了。首先，数据点必须被分类以使它们有意义。第二，容器必须大小相等。第三，箱必须足够大，以便每个箱都有“统计上显著的”样本量。</p><p id="32b1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">许多人陷入了一种思维定势，认为减少噪音的最佳方式是平滑他们的数据，处理数据点的最佳方式是将数据存储起来。这种宁滨方法是有问题的，因为它们丢弃了信息并引入了对以下参数的依赖:(1)平滑度和(2)面元大小——并且指定参数是不好的。理想情况下，面元宽度应该仅取决于数据本身的属性，并且所得到的直方图不应该是先验固定的。</p><p id="9d95" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">"一定有我们能做的事情！"我听见你哭泣，睁大眼睛，长着爱因斯坦般的头发。有。</p></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><h2 id="b5b3" class="ln lo je bd lp lq lr dn ls lt lu dp lv km lw lx ly kq lz ma mb ku mc md me mf bi translated">贝叶斯块</h2><p id="ad96" class="pw-post-body-paragraph kb kc je kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">贝叶斯块框架是一种自适应的方法，用于自动识别容器大小和划分数据。像其他非参数方法一样，贝叶斯块寻求一种通用的表示，避免提供先验限制的关于平滑度和形状的假设。</p><p id="9af4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最佳分割是一个简单而有效的优化问题，其目标是最大化标准的定量表达，或者最小化误差测量。更重要的是，它能够计算全局最优值，而不仅仅是局部最优值。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ml"><img src="../Images/78b7c5fa1b3824a24eac6cddd397c789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8v9sZuw-PJcHnHZkVE0vQg.png"/></div></div></figure><p id="693e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在高层次上:给定一个任意但固定的<em class="lc">块</em>大小的直方图，如左图所示，我们可以使用贝叶斯似然框架，该框架使用一个<em class="lc">适应度函数</em>，该函数仅取决于(1)每个块的宽度和(2)每个块内数据点的数量。<em class="lc">最佳</em>宁滨模式将是块配置，基于块之间的边缘(称为<em class="lc">改变点</em>，其将变化)，具有最大的适应性。</p><p id="3735" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lc">注意:任何尝试扩大这种方法的暴力版本都是徒劳的。可能的配置数量按2^N.的顺序呈指数级增长，如果不是因为动态编程技术的美丽，这是不可能的。</em></p><p id="db7e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了澄清，变化点是序列中经历突然转变的点，其一个或多个参数瞬间跳到新值。这里，我们将块适应度作为相对于块高度的最大相关可能性</p><p id="2782" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">适应度函数是对恒定水平表示块内数据有多好的方便测量，它也仅取决于该块内的数据，而不取决于除了指定块边缘位置的模型参数之外的模型参数。有不同的方法来定义适应度函数，其价值将根据最适合手头数据的方式而有所不同。</p><p id="4ef1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来本质上是数学归纳法。首先，我们对数据进行排序。接下来，我们从第一个数据单元格开始，并进行迭代。在每一步，增加一个单元，直到所有数据点都被分析完(为了优化，在下面链接的论文中描述了一个触发器，当检测到第一个变化点时停止)。在步骤R，对于前R个单元，我们识别出<em class="lc">最佳单元划分</em>，在每个步骤存储最佳<em class="lc">适应度</em>(在称为<strong class="kd jf">最佳</strong>的数组中表示为F(r ))和最佳划分的最后变化点的位置(在称为<strong class="kd jf">最后</strong>的数组中)。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mq"><img src="../Images/cdd2dc6f0eb7aa3cc5641d5161ed01a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WQmtzGhMDFObDL8VmBhr0Q.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk">Bayesian Blocks fitted to two concatenated, randomly sampled beta distributions</figcaption></figure><p id="9022" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于给定的单元位置R，可以通过首先考虑前R+1个单元的所有分区的集合，并使用该集合中唯一可能是最佳的成员是第一个R的最佳分区，然后是R+1处的最后一个块的知识，来计算单元位置R+1处的最佳分区。这个划分的适合度是F(r)的和。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mv"><img src="../Images/8035c6411735b6290690f748ab8b7e7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eTOwHgUb2_3EuMemhzLn6Q.png"/></div></div></figure><p id="f5b0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在存储了在范围r上可能是最优的所有分区的适合度。产生最优解的r值可以通过找到最大值A(r)简单地计算出来。</p><p id="fbe9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">迭代完所有点后，我们现在需要获取最佳分区的变点位置。为此，我们使用<strong class="kd jf"> last </strong>数组中的最后一个值来确定最佳分区的最后一个变化点。我们“剥离”对应于最后一个块的部分并重复。</p><p id="ab3e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">差不多就是这样。</p></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><p id="2c1a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">谢谢你过来。要了解更多关于贝叶斯块的信息，一定要看看Jeffrey D. Scargle的原始论文和Jake Vanderplas <em class="lc">的酷帖。</em></p><p id="1e8a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae mw" href="https://arxiv.org/pdf/1207.5578.pdf" rel="noopener ugc nofollow" target="_blank">天文时间序列分析研究。不及物动词贝叶斯块表示法</a> —杰弗里·d·斯卡格尔</p><p id="8852" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Python中的动态编程:贝叶斯块</p></div></div>    
</body>
</html>