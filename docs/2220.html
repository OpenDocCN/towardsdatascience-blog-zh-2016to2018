<html>
<head>
<title>Improving the Interpretation of Topic Models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改进主题模型的解释</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/improving-the-interpretation-of-topic-models-87fd2ee3847d?source=collection_archive---------0-----------------------#2016-09-03">https://towardsdatascience.com/improving-the-interpretation-of-topic-models-87fd2ee3847d?source=collection_archive---------0-----------------------#2016-09-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/7a414efa176a951958f437e5a189182d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AvskkPVJtXuE0EXwy46Jtg.jpeg"/></div></div></figure><div class=""/><p id="60a6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的<a class="ae kw" href="https://medium.com/@aneesha/topic-modeling-with-scikit-learn-e80d33668730#.vivglhmhv" rel="noopener">上一篇博文</a>中，我使用了在令人惊叹的<a class="ae kw" href="http://scikit-learn.org/" rel="noopener ugc nofollow" target="_blank"> Scikit Learn </a>机器学习 Python 库中实现的非负矩阵分解(NMF)和潜在狄利克雷分配(LDA)算法，来在文档集合中查找主题。派生主题的输出包括给主题分配一个数字标签，并打印出主题中的热门单词。通常的做法是简单地打印出每个主题的热门词汇——很多主题模型浏览器、可视化工具和公开网站上的例子都是这样做的！然而，仅仅显示主题中的顶部单词可能不会帮助用户理解每个主题是关于什么的或者确定使用这些单词的上下文。仅显示顶部主题单词不能利用两种算法返回的所有数据。在这篇博文中，我将解释 NMF 和 LDA 返回的矩阵，包括打印出主题中顶部文档的代码，并讨论我改进派生主题解释的想法，特别是当数据集中包含冗长的文档时。</p><h1 id="037a" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">NMF 和 LDA 返回的矩阵</h1><p id="695f" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">NMF 和 LDA 都采用一个单词包矩阵(没有文档*没有单词)作为输入。在单词包矩阵中，文档表示为行，单词表示为列。这两种算法都需要主题的数量(<em class="ma"> k </em>)，这些主题必须作为参数导出。主题建模算法产生的输出是 2 个矩阵:文档到主题矩阵(无文档* <em class="ma"> k </em>主题)和主题到单词矩阵(<em class="ma"> k </em>主题*无单词)。大多数主题模型输出仅使用主题到单词矩阵，并显示主题中权重最高的单词。通过显示主题中的热门文档，可以更好地理解主题，这对于 Scikit Learn 来说是相对简单的。</p><h1 id="b677" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">显示主题中的热门词汇和文档</h1><p id="1cbf" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">让我们首先编写一个新的 display_topics()方法，它将单词到主题矩阵(H)和主题到文档矩阵(W)作为参数。除了单词(feature_names)和顶部单词数(no_top_words)作为参数显示之外，该方法还需要显示文档集合(documents)和顶部文档数(no_top_documents)。display_topics 方法打印出一个数字索引作为主题名，打印出主题中的热门单词，然后打印出主题中的热门文档。顶部的单词和顶部的文档在返回的矩阵中具有最高的权重。argsort()方法用于对矩阵的行或列进行排序，并按顺序返回权重最高的单元格的索引。</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="63dc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要从 NMF 和 LDA 算法中获得单词到主题矩阵(H)和主题到文档矩阵(W)。词到主题矩阵(H)可以从模型的 component_ attribute 后得到。调用 fit()。将主题转换为文档矩阵有点棘手，但在阅读了 Scikit Learn api 文档后，每个算法都会变得有意义。在算法模型上调用 transform()方法会将主题返回到文档矩阵(W)。下面是从 NMF 和 LDA 获得 H 和 W 矩阵，然后调用 display_topics()方法的完整代码:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="mf mg l"/></div></figure><h1 id="7a97" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">一个说明性的玩具例子</h1><p id="20cc" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">一个很小的，我是说<a class="ae kw" href="http://web.eecs.utk.edu/~berry/order/node4.html#SECTION00022000000000000000" rel="noopener ugc nofollow" target="_blank">非常小的数据集</a>被用来说明一个主题中的热门单词和文档的打印。这个小小的数据集有两个主题，分别是关于用户界面和图形/树。有 9 个非常短的句子组成了这个数据集。下面的代码使用 NMF 和 LDA 查找 2 个主题，在一个主题中打印 4 个热门单词和 4 个热门文档:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="5f28" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来自 NMF 和 LDA 的主题显示如下。NMF 和 LDA 在寻找我们知道的主题方面做得很好。</p><p id="19cb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> NMF 话题</strong> <br/> <strong class="ka jc">话题 0: </strong> <br/>树图未成年人调查<br/> -图未成年人 IV:树的宽度与准有序<br/> -树中路径的交集图<br/> -随机、二进制、无序树的生成<br/> -图未成年人:调查</p><p id="ea67" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">主题 1: </strong> <br/>用户时间响应界面<br/>用户对计算机系统响应时间的意见调查<br/>用户感知的响应时间与误差测量的关系<br/>EPS 用户界面管理系统<br/>实验室 ABC 计算机应用的人机界面</p><p id="972d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> LDA 主题:</strong> <br/> <strong class="ka jc">主题 0: </strong> <br/>用户响应时间计算机<br/> -对计算机系统响应时间的用户意见调查<br/> -用户感知的响应时间与误差测量的关系<br/>-EPS 用户界面管理系统<br/> -实验室 ABC 计算机应用的人机界面</p><p id="9496" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">主题 1: </strong> <br/>树图人类未成年人<br/> -图未成年人 IV:树的宽度和准排序<br/> -图未成年人:调查<br/> -树中路径的交集图<br/> -实验室 ABC 计算机应用的人机界面</p><h1 id="7505" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">主题建模浏览器的构想</h1><p id="b7ad" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">当文档很大时，打印主题时显示整个文档是不切实际的。该技术仅对短文档(例如，tweets)或单个段落文档直接有用。一种解决方案是只显示文档中包含任何热门单词的片段。在以后的博文中，我将发布一些 Python 代码来实现这个想法，并提供一个派生主题的上下文关键字视图。将这种想法与可视化工具如 LDAVis T1 结合起来，将会产生一个真正有用的主题模型浏览器，帮助用户解释和探索派生的主题。</p></div></div>    
</body>
</html>