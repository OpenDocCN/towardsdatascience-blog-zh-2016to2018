<html>
<head>
<title>Time Series Nested Cross-Validation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时序嵌套交叉验证</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-nested-cross-validation-76adba623eb9?source=collection_archive---------0-----------------------#2018-05-19">https://towardsdatascience.com/time-series-nested-cross-validation-76adba623eb9?source=collection_archive---------0-----------------------#2018-05-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4971" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇博文讨论了对时间序列数据使用传统交叉验证的缺陷。具体来说，我们解决了 1)在不导致数据泄漏的情况下分割时间序列，2)使用嵌套交叉验证来获得独立测试集的无偏误差估计，以及 3)使用包含多个时间序列的数据集进行交叉验证。</p><h2 id="179a" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">用例</h2><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/53570184739d3857eb8e9017ae064155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hegxfUfVAuY5WilbbBiHmg.png"/></div></div></figure><p id="c94d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章是对缺乏关于如何对包含多个时间序列的数据使用交叉验证的在线信息的回应。</p><p id="8141" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章将帮助任何有时间序列数据的人，特别是多个<em class="lq">独立的</em>时间序列。这些方法是为医学研究中多个参与者的时间序列医学数据而设计的。</p><h2 id="6d3b" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">交叉验证</h2><p id="6e38" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">交叉验证(CV)是一种用于调整超参数和产生模型性能的稳健测量的流行技术。两种最常见的交叉验证是<em class="lq">k</em>-折叠交叉验证和保留交叉验证。</p><p id="337a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于文献中术语的差异，我们明确定义了我们的 CV 程序。首先，我们将数据集分成一个称为<em class="lq">训练集</em>的子集和另一个称为<em class="lq">测试集</em>的子集。如果需要调整任何参数，我们将训练集分成一个<em class="lq">训练子集</em>和一个<em class="lq">验证集</em>。在训练子集上训练模型，并且选择最小化验证集上的误差的参数。最后，使用选择的参数在完整的训练集上训练模型，并记录测试集上的误差。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi lw"><img src="../Images/a7ebd65ec8405f4d3d96f7abffde4b59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*obKmc_bTKbUFgcgryhaAnA.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Figure 1: Example of hold-out cross-validation. The data is split into a training set and a testing set. Then the training set is split again to tune hyperparameters- one part is used to train the model (training subset) and the other part (validation set) is used to validate the model.</figcaption></figure><h2 id="3972" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated"><em class="mb">为什么时间序列的交叉验证不同？</em></h2><p id="27fb" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">在处理时间序列数据时，传统的交叉验证(如<em class="lq"> k </em> -fold)不应使用，原因有二:</p><ol class=""><li id="29bd" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated"><strong class="jp ir">时间依赖性</strong></li></ol><p id="cbfb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于时间序列数据，在分割数据时必须特别小心，以防止数据泄漏。为了准确地模拟“真实世界的预测环境，我们站在现在并预测未来”(Tashman 2000)，预测者必须保留在用于拟合模型的事件之后按时间顺序发生的事件的所有数据。因此，对于时间序列数据，我们使用保留交叉验证，而不是使用<em class="lq"> k </em>折叠交叉验证，其中数据的子集(<em class="lq">暂时分割</em>)被保留用于验证模型性能。例如，参见图 1，其中测试集数据按时间顺序排在训练集之后。类似地，验证集按时间顺序排在训练子集之后。</p><p id="e97c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<strong class="jp ir">任意选择测试集</strong></p><p id="c3de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能会注意到，图 1 中测试集的选择是相当随意的，这种选择可能意味着我们的测试集误差是对独立测试集误差的糟糕估计。为了解决这个问题，我们使用了一种叫做嵌套交叉验证的方法。嵌套 CV 包含一个用于误差估计的外环和一个用于参数调整的内环(见图 2)。内部循环的工作方式与前面讨论的完全一样:将训练集分为训练子集和验证集，在训练子集上训练模型，并选择使验证集上的误差最小化的参数。然而，现在我们添加了一个外部循环，它将数据集分成多个不同的训练和测试集，并且对每次分割的误差进行平均，以便计算模型误差的稳健估计。这是有利的，因为:</p><blockquote class="ml mm mn"><p id="2c08" class="jn jo lq jp b jq jr js jt ju jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj kk ij bi translated">嵌套的交叉验证过程提供了真实误差的几乎无偏的估计。(瓦尔马和西蒙，2006 年)</p></blockquote><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi lw"><img src="../Images/bfe32d2b6accc9d4ef0d71e037c3e13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5vky1z29e1iO6iOvCTBJxg.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Figure 2: Nested CV Example</figcaption></figure><h2 id="2a90" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">时间序列的嵌套 CV 方法</h2><p id="c9b5" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我们建议用两种方法对单一时间序列的数据进行嵌套 CV。我们将处理这样一个场景，其中我们有来自一个医疗患者/参与者的多天数据:</p><ol class=""><li id="92fa" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated">预测下半年</li><li id="6603" class="mc md iq jp b jq mr ju ms jy mt kc mu kg mv kk mh mi mj mk bi translated">日正向链接</li></ol><p id="17c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">预测下半年</strong></p><p id="e639" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一种类型，预测后半部分，是嵌套 CV 的“基本情况”,只有一个训练/测试分割。这样做的好处是这种方法易于实现；然而，它仍然受到任意选择的测试集的限制。数据的前半部分(在时间上分开)被分配给训练集，后半部分成为测试集。验证集的大小可以根据给定的问题而变化(例如，在图 3 的示例中是 1 天的数据)，但是确保验证集在时间上在训练子集之后是很重要的。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mw"><img src="../Images/ef3a56cfd99fde4143889e04a643897b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vsMy_6R3Q-dhLO5OuZ1lJA.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Figure 3: Predict Second Half Nested Cross-Validation</figcaption></figure><p id="90b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">日前向连锁</strong></p><p id="0ef6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">预测后半部分嵌套交叉验证方法的一个缺点是，任意选择保留测试集会对独立测试集产生预测误差的有偏估计。为了更好地估计模型预测误差，通常的方法是创建许多训练/测试分割，并对所有分割的误差进行平均。我们使用的技术称为日前向链，基于一种称为前向链的方法(在文献中也称为滚动原点评估(Tashman 2000 年)和滚动原点重新校准评估(Bergmeir 和 bentez 2012 年))。使用这种方法，我们连续地将每一天作为测试集，并将所有以前的数据分配到训练集中。例如，如果我们的数据集有五天，那么我们将产生三个不同的训练和测试分割，如图 4 所示。请注意，在本例中，我们有三次拆分，而不是五次，因为我们需要确保至少有一天的培训和验证数据可用。该方法产生许多不同的训练/测试分割，并且对每个分割的误差进行平均，以便计算模型误差的稳健估计。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mx"><img src="../Images/d5c31c6ed55aa70286922f39936abbc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2-zaRQ-dsv8KWxOlzc8VaA.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Figure 4: Day Forward-Chaining Nested Cross-Validation</figcaption></figure><p id="b1e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，在我们的示例中，我们使用“Day”正向链接；然而，一次也可以迭代每个<em class="lq">数据点</em>(但这将意味着更多的分割)<em class="lq">，而不是迭代跨越<em class="lq">天</em>。</em></p><h2 id="dd7b" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">多个时间序列的嵌套交叉验证</h2><p id="a2ec" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">既然我们有两种分割单个时间序列的方法，我们讨论如何处理具有多个不同时间序列的数据集。同样，我们使用两种类型:</p><p id="9ee3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">常规</strong></p><p id="b897" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于“常规”嵌套交叉验证，如何进行训练/验证/测试分割的基本思想与之前相同。唯一的变化是拆分现在包含了来自我们数据集中每个参与者的数据。例如，如果有两个参与者，参与者 A 和 B，则训练集将包含来自参与者 A 的前半天的数据和来自参与者 B 的前半天的数据。同样，测试集将包含每个参与者的后半天的数据。</p><p id="222e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">人口知情</strong></p><p id="47d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于“群体知情嵌套交叉验证”,我们利用不同参与者数据之间的<strong class="jp ir">独立性</strong>。这使得我们可以打破严格的时间顺序，至少在个体的数据之间(在个体的数据内部仍然是必要的)。由于这种独立性，我们可以稍微修改常规的嵌套交叉验证算法。现在，测试和验证集只包含来自一个参与者的数据，比如说参与者 A，并且<em class="lq">来自数据集中所有其他参与者的所有</em>数据都允许出现在训练集中。请参见图 5，了解这对于群体通知日正向链接嵌套交叉验证是如何工作的。该图显示，参与者 A 的第 18 <em class="lq">天</em>是测试集(红色)，之前的三天是验证集(黄色)，训练集(绿色)包含来自参与者 A 之前的所有数据，以及来自其余参与者的<em class="lq"> all </em>数据(本例中为<em class="lq"> B </em>、<em class="lq"> C </em>、<em class="lq"> D </em>和<em class="lq"> E </em>)。需要强调的重要一点是，正是由于这些参与者的时间序列的独立性，使用其他参与者的“未来”观察结果不会造成数据泄漏。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi my"><img src="../Images/480149ab3b6905c9d76c5747b050ab2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dVudz5wg-UNVPD7befgw8A.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Figure 5: Population-Informed Day Forward-Chaining, where, in addition to Day Forward-Chaining method (left subfigure) for Participant A, we also allow all other participants’ data to be in the training set (right subfigure). Note that the grey bars indicate when the participant was sleeping.</figcaption></figure><h2 id="3e74" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">其他重要的嵌套交叉验证注意事项</h2><p id="61ee" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">最后，我们总结了不同嵌套交叉验证方法的优缺点，特别是在计算时间和独立测试集误差估计的偏差方面。分割数量假设数据集包含<em class="lq"> p </em>名参与者和<em class="lq"> d </em>名参与者的数据。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mz"><img src="../Images/fb75cc1fa14c996ed597b045223c8078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cwoqPsWh_lEUmxmcAL5-rw.png"/></div></div></figure><h2 id="18c1" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">总结:</h2><p id="01fe" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我们首先回顾了交叉验证，列举了使用嵌套交叉验证背后的基本原理。我们讨论了如何分割时间序列数据而不导致数据泄漏，特别建议了两种方法:1)预测下半年和 2)日前向链接。然后，我们讨论了如何使用两种方法处理多个<em class="lq">独立的</em>时间序列:1)常规方法和 2)群体通知方法。</p><h2 id="800f" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated"><strong class="ak">引文</strong>:</h2><p id="3f7c" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">C.伯格梅尔和 J. M .贝尼特斯。时间序列预测器评估的交叉验证的使用我<em class="lq"> nf。Sci。，</em>2012 年 5 月 191:192–213。ISSN 0020–0255。doi:10.1016/j . ins . 2011 . 12 . 028 . URL h<a class="ae na" href="http://dx.doi.org/10.1016/j.ins.2011.12.028." rel="noopener ugc nofollow" target="_blank">TTP://dx . doi . org/10.1016/j . ins . 2011 . 12 . 028 .</a></p><p id="90b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">长度 j .塔什曼。预测准确性的样本外检验:分析与评述。国际预测杂志，16(4):437–450，2000 年。URL https://ideas . repec . org/a/eee/int for/v16y 2000 i4p 437-450 . html</p><p id="7d5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">南瓦尔玛和西蒙。使用交叉验证进行模型选择时误差估计的偏差。BMC 生物信息学，7(1):91，2006 年 2 月。ISSN 1471–2105。doi:10.1186/1471–2105-7–91。</p></div></div>    
</body>
</html>