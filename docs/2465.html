<html>
<head>
<title>Traditional Methods for Text Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">文本数据的传统方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-feature-engineering-part-3-traditional-methods-for-text-data-f6f7d70acd41?source=collection_archive---------0-----------------------#2018-01-29">https://towardsdatascience.com/understanding-feature-engineering-part-3-traditional-methods-for-text-data-f6f7d70acd41?source=collection_archive---------0-----------------------#2018-01-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="b043" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/tds-feature-engineering" rel="noopener" target="_blank">了解特征工程</a>(第三部分)</h2><div class=""/><div class=""><h2 id="d50b" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">驯服非结构化文本数据的传统策略</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/0f716becb1b5ec61739338a3eb7e5116.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vXKKe3J-lfi1YQ7HC6onxQ.jpeg"/></div></div></figure><h1 id="62e4" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">介绍</h1><p id="d290" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">在本系列<em class="mo">的前两部分中，我们已经介绍了处理结构化数据的各种特性工程策略。</em>检查<em class="mo"> </em> <a class="ae mp" rel="noopener" target="_blank" href="/understanding-feature-engineering-part-1-continuous-numeric-data-da4e47099a7b"> <strong class="lu ja"> <em class="mo">第一部分:连续的数值数据</em> </strong> </a> <em class="mo"> </em>和<a class="ae mp" rel="noopener" target="_blank" href="/understanding-feature-engineering-part-2-categorical-data-f54324193e63"> <strong class="lu ja"> <em class="mo">第二部分:离散的分类数据</em></strong></a><strong class="lu ja"><em class="mo"/></strong>复习<em class="mo">。在本文中，我们将了解如何处理文本数据，这无疑是最丰富的非结构化数据来源之一。文本数据通常由能够代表自由流动文本的单词、句子甚至段落的文档组成。</em>固有的非结构化(没有格式整齐的数据列！)和文本数据的噪声性质使得机器学习方法更难直接在原始文本数据上工作。因此，在本文中，我们将遵循动手实践的方法，探索一些最流行和最有效的从文本数据中提取有意义特征的策略。这些特征可以很容易地用于建立机器学习或深度学习模型。</p><h1 id="6e2f" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">动机</h1><p id="8627" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">特征工程通常被认为是创造卓越和性能更好的机器学习模型的秘方。仅仅一个优秀的功能就可能成为你赢得挑战的入场券！对于非结构化的文本数据，特征工程的重要性甚至更加重要，因为我们需要将自由流动的文本转换为一些数字表示，然后机器学习算法可以理解这些数字表示。即使有了自动化特征工程能力的出现，在将它们作为黑盒模型应用之前，您仍然需要理解不同特征工程策略背后的核心概念。永远记住，<em class="mo">“如果给你一盒修理房子的工具，你要知道什么时候用电钻，什么时候用锤子！”</em>。</p><h1 id="1540" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">理解文本数据</h1><p id="e465" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">我敢肯定，在这种情况下，你们所有人对文本数据的组成都有一个大致的概念。请记住，您总是可以拥有结构化数据属性形式的文本数据，但是这些数据通常属于结构化分类数据的范畴。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/ba524eeea5dd6da495a91187fbac1845.png" data-original-src="https://miro.medium.com/v2/resize:fit:370/format:webp/1*1ihhqrBr0M6C-zgHeR7I_Q.png"/></div></figure><p id="c5a1" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">在这个场景中，我们谈论的是单词、短语、句子和整个文档形式的自由流动的文本。本质上，我们有一些句法结构，像单词组成短语，短语组成句子，句子又组成段落。然而，文本文档没有固有的结构，因为您可能有各种各样的单词，这些单词可能在文档之间有所不同，并且与结构化数据集中固定数量的数据维度相比，每个句子的长度也是可变的。这篇文章本身就是一个完美的文本数据例子！</p><h1 id="c453" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">特征工程策略</h1><p id="ba20" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">让我们看看一些流行而有效的策略，用于处理文本数据并从中提取有意义的特征，这些策略可用于下游的机器学习系统。请注意，您可以在我的GitHub库 中访问本文中使用的所有代码，以供将来参考。我们将从加载一些基本的依赖项和设置开始。</p><pre class="kp kq kr ks gt mw mx my mz aw na bi"><span id="f238" class="nb lb iq mx b gy nc nd l ne nf">import pandas as pd<br/>import numpy as np<br/>import re<br/>import nltk<br/>import matplotlib.pyplot as plt</span><span id="9e5c" class="nb lb iq mx b gy ng nd l ne nf">pd.options.display.max_colwidth = 200<br/>%matplotlib inline</span></pre><p id="787d" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">现在让我们来看一个样本文档集，我们将在本文中对其进行大部分分析。<a class="ae mp" href="https://en.wikipedia.org/wiki/Text_corpus" rel="noopener ugc nofollow" target="_blank"> <strong class="lu ja"> <em class="mo">语料库</em> </strong> </a>通常是通常属于一个或多个主题的文本文档的集合。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/721e89ac117c828d262d0ff39682c274.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*NGAjqKmla8_N6c4tKmxkgA.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Our sample text corpus</figcaption></figure><p id="9b2c" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">您可以看到，我们已经为我们的玩具语料库提取了几个属于不同类别的样本文本文档。在我们谈论特征工程之前，一如既往，我们需要做一些数据预处理或争论，以删除不必要的字符，符号和令牌。</p><h2 id="c9f5" class="nb lb iq bd lc no np dn lg nq nr dp lk mb ns nt lm mf nu nv lo mj nw nx lq iw bi translated">文本预处理</h2><p id="e8b5" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">可以有多种清理和预处理文本数据的方式。在下面的几个要点中，我们强调了自然语言处理(NLP)管道中大量使用的一些最重要的方法。</p><ul class=""><li id="b639" class="ny nz iq lu b lv mr ly ms mb oa mf ob mj oc mn od oe of og bi translated"><strong class="lu ja">去除标签:</strong>我们的文本往往包含HTML标签这样不必要的内容，在分析文本的时候并没有增加多少价值。BeautifulSoup库在为此提供必要的函数方面做得非常出色。</li><li id="7627" class="ny nz iq lu b lv oh ly oi mb oj mf ok mj ol mn od oe of og bi translated"><strong class="lu ja">删除带重音的字符:</strong>在任何文本语料库中，尤其是在处理英语语言时，经常会遇到带重音的字符\字母。因此，我们需要确保这些字符被转换并标准化为ASCII字符。一个简单的例子就是将<strong class="lu ja">转换成</strong>再转换成<strong class="lu ja"> e </strong>。</li><li id="34ad" class="ny nz iq lu b lv oh ly oi mb oj mf ok mj ol mn od oe of og bi translated"><strong class="lu ja">扩展缩写:</strong>在英语中，缩写基本上是单词或音节的缩短版本。这些现有单词或短语的缩短版本是通过删除特定的字母和声音创建的。例如，<strong class="lu ja"> <em class="mo">不要</em> </strong>要<strong class="lu ja"> <em class="mo">不要</em> </strong>和<strong class="lu ja"> <em class="mo">我要</em> </strong>要<strong class="lu ja"> <em class="mo">我要</em> </strong>。将每个缩写转换为其扩展的原始形式通常有助于文本标准化。</li><li id="dc04" class="ny nz iq lu b lv oh ly oi mb oj mf ok mj ol mn od oe of og bi translated"><strong class="lu ja">去除特殊字符:</strong>通常为非字母数字字符的特殊字符和符号通常会增加非结构化文本中的额外噪声。更常见的是，简单的正则表达式(regexes)可以用来实现这一点。</li><li id="5037" class="ny nz iq lu b lv oh ly oi mb oj mf ok mj ol mn od oe of og bi translated"><strong class="lu ja">词干和词汇化:</strong>词干通常是可能单词的基本形式，可以通过将<em class="mo">词缀</em>如<em class="mo">前缀</em>和<em class="mo">后缀</em>附加到词干来创建新单词。这就是所谓的变调。获得单词基本形式的反向过程被称为<em class="mo">词干提取</em>。一个简单的例子就是<strong class="lu ja"> <em class="mo">手表</em> </strong> <em class="mo"> ES </em>，<strong class="lu ja"> <em class="mo">手表</em> </strong> <em class="mo"> ING </em>和<strong class="lu ja"> <em class="mo">手表</em> </strong> <em class="mo"> ED </em>这几个词。他们以词根词干<strong class="lu ja"> <em class="mo">表</em> </strong>为基础形式。词汇化与词干化非常相似，我们移除词缀来获得单词的基本形式。然而，在这种情况下，基本形式被称为词根，而不是词干。区别在于词根总是字典上正确的单词(存在于字典中),但是词干可能不是这样。</li><li id="2956" class="ny nz iq lu b lv oh ly oi mb oj mf ok mj ol mn od oe of og bi translated"><strong class="lu ja">去除停用词:</strong>意义不大或没有意义的词，尤其是在从文本中构建有意义的特征时，被称为停用词或停用词。如果你在语料库中做一个简单的术语或词频，这些通常是出现频率最高的词。像<strong class="lu ja"> <em class="mo"> a </em> </strong>，<strong class="lu ja"><em class="mo">a</em></strong>，<strong class="lu ja"><em class="mo"/></strong>，<strong class="lu ja"><em class="mo"/></strong>等单词都被认为是停用词。没有通用的停用词表，但是我们使用来自<code class="fe om on oo mx b">nltk</code>的标准英语停用词表。您也可以根据需要添加自己的特定领域的停用词。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi op"><img src="../Images/bc727526e25dc634c519cd4ca82b4b1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*hTzCB81C8Wi5VxMSGAzd-w.png"/></div></figure><p id="b2b2" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">除此之外，您还可以进行其他标准操作，如标记化、删除多余的空格、文本小写以及更高级的操作，如拼写纠正、语法错误纠正、删除重复字符等。如果你有兴趣，你可以从<a class="ae mp" href="https://github.com/dipanjanS/practical-machine-learning-with-python" rel="noopener ugc nofollow" target="_blank">我最近的一本书</a>中查阅<a class="ae mp" href="https://github.com/dipanjanS/practical-machine-learning-with-python/blob/master/notebooks/Ch07_Analyzing_Movie_Reviews_Sentiment/Text%20Normalization%20Demo.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="lu ja">一个关于文本预处理</strong> </a>的样本笔记本。</p><p id="aaff" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">由于本文的重点是特征工程，我们将构建一个简单的文本预处理程序，重点是删除文本语料库中的特殊字符、多余空格、数字、停用词和小写字母。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="af54" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">一旦我们准备好基本的预处理管道，让我们将同样的应用到我们的样本语料库。</p><pre class="kp kq kr ks gt mw mx my mz aw na bi"><span id="1db2" class="nb lb iq mx b gy nc nd l ne nf">norm_corpus = normalize_corpus(corpus)<br/>norm_corpus</span><span id="223a" class="nb lb iq mx b gy ng nd l ne nf"><strong class="mx ja">Output<br/>------<br/></strong>array(['sky blue beautiful', 'love blue beautiful sky',<br/>       'quick brown fox jumps lazy dog',<br/>       'kings breakfast sausages ham bacon eggs toast beans',<br/>       'love green eggs ham sausages bacon',<br/>       'brown fox quick blue dog lazy', <br/>       'sky blue sky beautiful today',<br/>       'dog lazy brown fox quick'],<br/>      dtype='&lt;U51')</span></pre><p id="ae95" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">上面的输出应该让您清楚地看到我们的每个样本文档在预处理后的样子。现在让我们来设计一些功能吧！</p><h2 id="0955" class="nb lb iq bd lc no np dn lg nq nr dp lk mb ns nt lm mf nu nv lo mj nw nx lq iw bi translated">词汇袋模型</h2><p id="2776" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">对于非结构化文本，这可能是最简单的向量空间表示模型。向量空间模型是一个简单的数学模型，将非结构化文本(或任何其他数据)表示为数字向量，这样向量的每个维度都是一个特定的特征\属性。单词袋模型将每个文本文档表示为数字向量，其中每个维度是来自语料库的特定单词，并且该值可以是它在文档中的频率、出现次数(用1或0表示)或者甚至是加权值。这个模型之所以叫这个名字，是因为每个文档都被字面上表示为它自己的单词的“包”,而不考虑单词顺序、序列和语法。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><pre class="kp kq kr ks gt mw mx my mz aw na bi"><span id="f326" class="nb lb iq mx b gy nc nd l ne nf"><strong class="mx ja">Output<br/>------</strong><br/>array([[0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],<br/>       [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0],<br/>       [0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0],<br/>       [1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0],<br/>       [1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0],<br/>       [0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0],<br/>       [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1],<br/>       [0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0]<br/>      ], dtype=int64)</span></pre><p id="95dc" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">因此，您可以看到我们的文档已经被转换成数字向量，这样，在上面的特征矩阵中，每个文档都由一个向量(行)表示。下面的代码将有助于用一种更容易理解的格式来表示这一点。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oq"><img src="../Images/be890b376a91d9490a5fdd04e2e7e493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zMdHVQQ7HYv_mMZ5Ne-2yQ.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Our Bag of Words model based document feature vectors</figcaption></figure><p id="e96b" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">这应该会让事情更清楚吧！您可以清楚地看到，特征向量中的每一列或每一个维度代表语料库中的一个单词，每一行代表我们的一个文档。任何单元格中的值表示该单词(由列表示)在特定文档(由行表示)中出现的次数。因此，如果文档集由跨越所有文档的<strong class="lu ja"> <em class="mo"> N个</em> </strong>唯一单词组成，那么对于每个文档，我们将有一个<strong class="lu ja"> <em class="mo"> N维</em> </strong>向量。</p><h2 id="e4ac" class="nb lb iq bd lc no np dn lg nq nr dp lk mb ns nt lm mf nu nv lo mj nw nx lq iw bi translated">N克模型袋</h2><p id="8604" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">一个单词只是一个标记，通常被称为一元语法或一元语法。我们已经知道单词袋模型不考虑单词的顺序。但是如果我们也想考虑出现在序列中的短语或单词集合呢？N-grams帮助我们实现了这一点。N元语法基本上是来自文本文档的单词标记的集合，使得这些标记是连续的并且按顺序出现。二元语法表示2阶的n元语法(两个单词)，三元语法表示3阶的n元语法(三个单词)，依此类推。因此，N-gram模型只是单词模型的扩展，所以我们也可以利用基于N-gram的特征。下面的例子描述了每个文档特征向量中基于二元语法的特征。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi or"><img src="../Images/2605dc7997264f22db0d02ac4197cecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TrMMDjpylFZQIU6EY8INPw.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Bi-gram based feature vectors using the Bag of N-Grams Model</figcaption></figure><p id="19e2" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">这为我们的文档提供了特征向量，其中每个特征由表示两个单词序列的二元语法组成，值表示该二元语法在我们的文档中出现的次数。</p><h2 id="d38f" class="nb lb iq bd lc no np dn lg nq nr dp lk mb ns nt lm mf nu nv lo mj nw nx lq iw bi translated">TF-IDF模型</h2><p id="835d" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">词袋模型在用于大型语料库时可能会出现一些潜在的问题。因为特征向量是基于绝对术语频率的，所以可能有一些术语在所有文档中频繁出现，并且这些术语可能会盖过特征集中的其他术语。TF-IDF模型试图通过在其计算中使用一个缩放或归一化因子来解决这个问题。TF-IDF代表词频-逆文档频率，它在<br/>的计算中使用了两个度量的组合，即:<strong class="lu ja"> <em class="mo">【词频】</em> </strong>和<strong class="lu ja"> <em class="mo">逆文档频率(idf) </em> </strong>。这项技术是为搜索引擎中的查询结果排序而开发的，现在它是信息检索和NLP领域中不可或缺的模型。</p><p id="0ca5" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">数学上，我们可以将TF-IDF定义为<strong class="lu ja"> <em class="mo"> tfidf = tf x idf </em> </strong>，可以进一步展开表示如下。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi os"><img src="../Images/0a6e465c48fd721fd3034dfd54d9c42e.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*PUtPh3Jj0sPiRuCGhzpxSg.png"/></div></figure><p id="e801" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">这里，<strong class="lu ja"> <em class="mo"> tfidf(w，D) </em> </strong>是文档<strong class="lu ja"><em class="mo"/></strong>中单词<strong class="lu ja"> <em class="mo"> w </em> </strong>的TF-IDF得分。术语<strong class="lu ja"> <em class="mo"> tf(w，D) </em> </strong>表示单词<strong class="lu ja"> <em class="mo"> w </em> </strong>在文档<strong class="lu ja"> <em class="mo"> D </em> </strong>中的词频，可以从词袋模型中得到。术语<strong class="lu ja"> <em class="mo"> idf(w，D) </em> </strong>是术语<strong class="lu ja"> <em class="mo"> w </em> </strong>的逆文档频率，其可以计算为语料库<strong class="lu ja"> <em class="mo"> C </em> </strong>中的文档总数除以单词<strong class="lu ja"> <em class="mo"> w </em> </strong>的文档频率的对数变换，这基本上是单词<strong class="lu ja"> <em class="mo"> w </em>在语料库中的文档频率这个模型有多种变体，但最终都给出了非常相似的结果。现在让我们把它应用到我们的语料库中吧！</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ot"><img src="../Images/638736b3b864212276dc47cca5e1fbf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VTI7EPLNqXECMM_48SZTww.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Our TF-IDF model based document feature vectors</figcaption></figure><p id="af92" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">我们的每个文本文档的基于TF-IDF的特征向量显示了与原始单词包模型值相比的缩放和归一化值。有兴趣的读者可能想深入了解这个模型内部工作原理的更多细节，可以参考第181页的<a class="ae mp" href="https://github.com/dipanjanS/text-analytics-with-python" rel="noopener ugc nofollow" target="_blank"> <em class="mo">使用Python的文本分析(Springer \ ApressDipanjan Sarkar，2016) </em> </a>。</p><h2 id="e35a" class="nb lb iq bd lc no np dn lg nq nr dp lk mb ns nt lm mf nu nv lo mj nw nx lq iw bi translated">文档相似度</h2><p id="928b" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">文档相似性是使用基于距离或相似性的度量的过程，该度量可用于基于从文档中提取的特征(如单词袋或tf-idf)来识别文本文档与任何其他文档的相似程度。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/09bd4eac09b3126ba94b59f87da6c2ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/0*yqSGboQIoKYxkMh3."/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Are we similar?</figcaption></figure><p id="5adb" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">因此，您可以看到，我们可以在上一节中设计的基于tf-idf的功能的基础上进行构建，并通过利用这些基于相似性的功能，使用它们来生成在搜索引擎、文档聚类和信息检索等领域中有用的新功能。</p><p id="8e2e" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">语料库中的成对文档相似性涉及计算语料库中每对文档的文档相似性。因此，如果在一个语料库中有<strong class="lu ja"> <em class="mo"> C </em> </strong>个文档，那么最终会得到一个<strong class="lu ja"> <em class="mo"> C </em> x <em class="mo"> C </em> </strong>矩阵，使得每一行和每一列都代表一对文档的相似性得分，这分别代表该行和该列的索引。有几种用于计算文档相似性的相似性和距离度量。其中包括余弦距离/相似度、欧氏距离、曼哈顿距离、BM25相似度、jaccard距离等等。在我们的分析中，我们将使用可能是最流行和最广泛使用的相似性度量，<br/>余弦相似性，并基于它们的TF-IDF特征向量来比较成对的文档相似性。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/3ebc19061e180c37c5e4ff3e6d2bf608.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*1FT_YXdRC1hc7Ns18Non2Q.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Pairwise document similarity matrix (cosine similarity)</figcaption></figure><p id="7cb2" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">余弦相似性基本上给出了一种度量，表示两个文本文档的特征向量表示之间的角度的余弦。文档之间的角度越小，它们就越接近和相似，如下图所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ow"><img src="../Images/bc671598995dbde2ce6dd7db12dca012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6kOlPsrmOvTFIuGGb0qBJw.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Cosine similarity depictions for text document feature vectors</figcaption></figure><p id="bfbf" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">仔细观察相似性矩阵清楚地告诉我们，文档(0、1和6)、(2、5和7)彼此非常相似，文档3和4彼此稍微相似，但是幅度不是很大，但是仍然比其他文档强。这一定表明这些相似的文件有一些相似的特征。这是一个分组或聚类的完美例子，可以通过无监督学习来解决，特别是当您处理数百万文本文档的庞大语料库时。</p><h2 id="ed04" class="nb lb iq bd lc no np dn lg nq nr dp lk mb ns nt lm mf nu nv lo mj nw nx lq iw bi translated">基于相似特征的文档聚类</h2><p id="67aa" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">聚类利用无监督学习将数据点(在这个场景中是文档)分组到组或聚类中。我们将在这里利用无监督的层次聚类算法，通过利用我们之前生成的文档相似性特征，尝试将来自我们的玩具语料库的相似文档分组在一起。有两种类型的层次聚类算法，即凝聚和分裂方法。我们将使用凝聚聚类算法，这是一种使用自下而上方法的分层聚类，即每个观察或文件从其自己的聚类开始，然后使用测量数据点之间距离的距离度量和链接合并标准将聚类连续合并在一起。下图显示了一个示例描述。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/c14ef96600ebe3d990fc00a60c383c54.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/0*nkjubhFvynBLrXv7.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Agglomerative Hierarchical Clustering</figcaption></figure><p id="ac00" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">关联标准的选择决定了合并策略。连锁标准的一些例子是沃德、完全连锁、平均连锁等。该标准对于在每个步骤中基于目标函数的最优值选择要合并的聚类对(最低步骤中的单个文档和较高步骤中的聚类)非常有用。我们选择沃德的<em class="mo">最小方差方法</em>作为我们的连锁标准，以最小化总的组内方差。因此，在每一步，我们找到合并后导致总的类内方差最小增加的那对类。因为我们已经有了相似性特征，所以让我们在样本文档上构建链接矩阵。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/5ab37bfb6cb30a1525eeaad6034f432a.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*2dcWnQrb8ws3d8aBMu1irA.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Linkage Matrix for our Corpus</figcaption></figure><p id="eed1" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">如果仔细观察关联矩阵，您会发现关联矩阵的每一步(每一行)都告诉我们哪些数据点(或聚类)被合并在一起。如果你有<strong class="lu ja"> <em class="mo"> n </em> </strong>个数据点，那么链接矩阵，<strong class="lu ja"> <em class="mo"> Z </em> </strong>将具有<strong class="lu ja"><em class="mo">(n-1)</em>x<em class="mo">4</em></strong>其中<strong class="lu ja"><em class="mo"/></strong>将告诉我们哪些聚类在步骤<strong class="lu ja"> <em class="mo"> i </em> </strong>被合并。每行有四个元素，前两个元素是数据点标识符或聚类标签(在矩阵的后面部分，一旦<br/>多个数据点合并)，第三个元素是前两个元素(数据点或聚类)之间的聚类距离，最后一个元素是合并完成后聚类中元素\数据点的总数。我们推荐你参考<a class="ae mp" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.linkage.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lu ja"> scipy文档</strong> </a>，里面对此有详细解释。</p><p id="1705" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">现在让我们把这个矩阵想象成一个树状图，以便更好地理解这些元素！</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/247b2d4a33ec02f7e973e366d6c2f313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*Be-eVWH7XbpQ0J04ixL4uQ.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Dendrogram visualizing our hierarchical clustering process</figcaption></figure><p id="0e73" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">我们可以看到每个数据点如何开始作为一个单独的集群，并慢慢开始与其他数据点合并形成集群。从颜色和树状图的高度来看，如果您考虑大约<strong class="lu ja"> 1.0 </strong>或更高的距离度量(由虚线表示)，您可以看到该模型已经正确地识别了三个主要聚类。利用这个距离，我们得到我们的聚类标签。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/1ce6d1776336fdc8682d755055375434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*P-F02GgiCwIUndQXWRGqSg.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Clustering our documents into groups with hierarchical clustering</figcaption></figure><p id="6f1a" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">因此，您可以清楚地看到，我们的算法已经根据分配给它们的聚类标签，在我们的文档中正确地识别了三个不同的类别。这将让您很好地了解如何利用我们的TF-IDF特性来构建我们的相似性特性，这反过来又有助于对我们的文档进行聚类。您实际上可以在将来使用这个管道来聚集您自己的文档！</p><h2 id="ceb7" class="nb lb iq bd lc no np dn lg nq nr dp lk mb ns nt lm mf nu nv lo mj nw nx lq iw bi translated">主题模型</h2><p id="e93e" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">我们还可以使用一些摘要技术从文本文档中提取基于主题或概念的特征。主题模型的思想围绕着从表示为主题的文档语料库中提取关键主题或概念的过程。每个主题可以被表示为来自文档语料库的单词/术语的包或集合。总的来说，这些术语表示特定的主题、主题或概念，并且每个主题可以通过这些术语所传达的语义来容易地与其他主题区分开来。然而，基于这些数据，你经常会得到一些重叠的主题。这些概念可以从简单的事实和陈述到观点和展望。主题模型在总结大量文本文档以提取和描述关键概念时非常有用。它们还可用于从文本数据中提取特征，以捕捉数据中的潜在模式。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/3d663cfaf61519450f1de821533faaa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/0*3YiGp_YuwcwPNfM8.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">An example of topic models</figcaption></figure><p id="b4d5" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">主题建模有多种技术，其中大多数都涉及某种形式的矩阵分解。像潜在语义索引(LSI)这样的一些技术使用矩阵分解操作，更具体地说是奇异值分解。我们将使用另一种技术是潜在狄利克雷分配(LDA)，它使用一种生成概率模型，其中每个文档由几个主题的组合组成，每个术语或单词可以分配给一个特定的主题。这类似于基于pLSI的模型(概率LSI)。在LDA的情况下，每个潜在主题包含一个Dirichlet先验。</p><p id="8d11" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">这项技术背后的数学是相当复杂的，所以我会尽量总结一下，而不会用很多细节来烦你。我推荐读者去看看克里斯汀·多伊格的这篇精彩的演讲<a class="ae mp" href="http://chdoig.github.io/pygotham-topic-modeling/#/" rel="noopener ugc nofollow" target="_blank"><strong class="lu ja"/></a>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pc"><img src="../Images/b026f919140eb65fdbbe0ae9f4f9723c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qZAMpfL2XlHF2gCT.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">End-to-end LDA framework (courtesy of C. Doig, Introduction to Topic<br/>Modeling in Python)</figcaption></figure><p id="8918" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">上图中的黑框表示核心算法，该算法利用前面提到的参数从<strong class="lu ja"> <em class="mo"> M </em> </strong>文档中提取<strong class="lu ja"> <em class="mo"> K </em> </strong>主题。下面的步骤简单地解释了算法在幕后发生了什么。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/82a7d7aa88b9f49cfb4575c2f67645d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Wa5tvzIPAfcJj3bV6RW7xg.png"/></div></figure><p id="e06c" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">运行几次迭代后，我们应该为每个文档准备好主题混合，然后从指向该主题的术语中生成每个主题的成分。像<code class="fe om on oo mx b">gensim</code>或<code class="fe om on oo mx b">scikit-learn</code>这样的框架使我们能够利用LDA模型来生成主题。</p><p id="cd1d" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">出于特征工程的目的(这也是本文的目的)，您需要记住，当LDA应用于文档术语矩阵(TF-IDF或单词包特征矩阵)时，它被分解为两个主要部分。</p><ul class=""><li id="7e86" class="ny nz iq lu b lv mr ly ms mb oa mf ob mj oc mn od oe of og bi translated">文档-主题矩阵，这将是我们正在寻找的特征矩阵。</li><li id="fe1d" class="ny nz iq lu b lv oh ly oi mb oj mf ok mj ol mn od oe of og bi translated">一个主题术语矩阵，帮助我们在语料库中寻找潜在的主题。</li></ul><p id="b4df" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">让我们利用<code class="fe om on oo mx b">scikit-learn</code>得到如下的文档-主题矩阵。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/95545029e2ba9ce9f4de777e88eb81b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/format:webp/1*JfwMR3Ye0WVXuSHWOp7DPQ.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Document-Topic Matrix from our LDA Model</figcaption></figure><p id="2711" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">在上面的输出中，您可以清楚地看到哪些文档对三个主题中的哪一个贡献最大。您可以按如下方式查看主题及其主要组成部分。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><pre class="kp kq kr ks gt mw mx my mz aw na bi"><span id="0616" class="nb lb iq mx b gy nc nd l ne nf"><strong class="mx ja">Topic 1<br/>-------</strong><br/>[('sky', 4.3324395825632624), ('blue', 3.3737531748317711), ('beautiful', 3.3323652405224857), ('today', 1.3325579841038182), ('love', 1.3304224288080069)]</span><span id="3b13" class="nb lb iq mx b gy ng nd l ne nf"><strong class="mx ja">Topic 2<br/>-------</strong><br/>[('bacon', 2.3326959484799978), ('eggs', 2.3326959484799978), ('ham', 2.3326959484799978), ('sausages', 2.3326959484799978), ('love', 1.335454457601996), ('beans', 1.3327735253784641), ('breakfast', 1.3327735253784641), ('kings', 1.3327735253784641), ('toast', 1.3327735253784641), ('green', 1.3325433207547732)]</span><span id="f15c" class="nb lb iq mx b gy ng nd l ne nf"><strong class="mx ja">Topic 3<br/>-------<br/></strong>[('brown', 3.3323474595768783), ('dog', 3.3323474595768783), ('fox', 3.3323474595768783), ('lazy', 3.3323474595768783), ('quick', 3.3323474595768783), ('jumps', 1.3324193736202712), ('blue', 1.2919635624485213)]</span></pre><p id="3912" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">因此，你可以清楚地看到，这三个主题根据它们的构成术语彼此有很大的区别，第一个谈论天气，第二个谈论食物，最后一个谈论动物。选择主题建模的主题数量本身就是一个完整的主题(不是双关语！)是一门艺术，也是一门科学。有各种各样的方法和试探法来获得最佳的主题数量，但是由于这些技术的详细性质，我们在这里不讨论它们。</p><h2 id="ad1d" class="nb lb iq bd lc no np dn lg nq nr dp lk mb ns nt lm mf nu nv lo mj nw nx lq iw bi translated">具有主题模型特征的文档聚类</h2><p id="454b" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">我们使用基于特征的词袋模型，使用LDA建立基于特征的主题模型。我们现在实际上可以利用我们获得的文档术语矩阵，并使用无监督聚类算法来尝试对我们的文档进行分组，就像我们之前使用相似性特征所做的那样。</p><p id="9d37" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">这一次，我们将使用一种非常流行的基于划分的聚类方法，K-means聚类来根据这些文档的主题模型特征表示对它们进行聚类或分组。在K-means聚类中，我们有一个输入参数<strong class="lu ja"> <em class="mo"> k </em> </strong>，它指定了使用文档特征输出的聚类数。这种聚类方法是一种基于质心的聚类方法，它试图将这些文档聚类成等方差的聚类。它试图通过最小化类内平方和度量(也称为惯性)来创建这些类。有多种方法来选择<strong class="lu ja"> <em class="mo"> k </em> </strong>的最佳值，如使用误差平方和度量、轮廓系数和肘方法。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/1e1429533cc06ae64bb94792d2b1fccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*WxRbRltR92LuQG5oZs08uA.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Clustering our documents into groups with K-means clustering</figcaption></figure><p id="1e7a" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">从上面的输出中我们可以看到，我们的文档被正确地分配到了正确的集群中！</p><h1 id="34a8" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">高级策略的未来范围</h1><p id="40e0" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">我们在本文中没有涉及的是围绕文本数据的特征工程的几个高级策略，这些策略最近变得很突出。这包括利用基于深度学习的模型来获得单词嵌入。在本系列的下一部分中，我们将深入探讨这些模型，并通过详细的实践示例介绍流行的单词嵌入模型，如<a class="ae mp" href="https://en.wikipedia.org/wiki/Word2vec" rel="noopener ugc nofollow" target="_blank"><strong class="lu ja"><em class="mo">word 2 vec</em></strong></a>和<a class="ae mp" href="https://nlp.stanford.edu/projects/glove/" rel="noopener ugc nofollow" target="_blank"><strong class="lu ja"><em class="mo">GloVe</em></strong></a>，敬请关注！</p><h1 id="99cb" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">结论</h1><p id="ffa8" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">这些例子应该让您对文本数据的特征工程的流行策略有一个很好的了解。请记住，这些是基于数学、信息检索和自然语言处理概念的传统策略。因此，随着时间的推移，这些经过试验和测试的方法在各种数据集和问题中被证明是成功的。接下来将是利用深度学习模型对文本数据进行特征工程的详细策略！</p></div><div class="ab cl pg ph hu pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="ij ik il im in"><p id="a426" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">要阅读关于连续数值数据的特征工程策略，请查看本系列的第1部分的<a class="ae mp" rel="noopener" target="_blank" href="/understanding-feature-engineering-part-1-continuous-numeric-data-da4e47099a7b"> <strong class="lu ja">！</strong></a></p><p id="2a79" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">要了解离散分类数据的特征工程策略，请查看本系列的<a class="ae mp" rel="noopener" target="_blank" href="/understanding-feature-engineering-part-2-categorical-data-f54324193e63"> <strong class="lu ja">第2部分</strong> </a>！</p><p id="7af3" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">本文中使用的所有代码和数据集都可以从我的<a class="ae mp" href="https://github.com/dipanjanS/practical-machine-learning-with-python/tree/master/bonus%20content/feature%20engineering%20text%20data" rel="noopener ugc nofollow" target="_blank"> <strong class="lu ja"> GitHub </strong> </a>中获得</p><p id="b9dc" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">该代码也可作为<a class="ae mp" href="https://github.com/dipanjanS/practical-machine-learning-with-python/blob/master/bonus%20content/feature%20engineering%20text%20data/Feature%20Engineering%20Text%20Data%20-%20Traditional%20Strategies.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="lu ja"> Jupyter笔记本</strong> </a></p><p id="44a6" class="pw-post-body-paragraph ls lt iq lu b lv mr ka lx ly ms kd ma mb mt md me mf mu mh mi mj mv ml mm mn ij bi translated">如果你对我的文章或数据科学有任何反馈、评论或有趣的见解要分享，请随时通过我的LinkedIn社交媒体频道联系我。</p><div class="pn po gp gr pp pq"><a href="https://www.linkedin.com/in/dipanzan/" rel="noopener  ugc nofollow" target="_blank"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd ja gy z fp pv fr fs pw fu fw iz bi translated">Dipanjan Sarkar | LinkedIn</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">查看Dipanjan Sarkar在世界最大的职业社区LinkedIn上的个人资料。Dipanjan有5份工作列在…</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">www.linkedin.com</p></div></div><div class="pz l"><div class="qa l qb qc qd pz qe ky pq"/></div></div></a></div></div></div>    
</body>
</html>