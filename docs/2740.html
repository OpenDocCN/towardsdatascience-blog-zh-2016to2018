<html>
<head>
<title>Functional Programming in R with purrr</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 purrr 实现 R 语言中的函数式编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/functional-programming-in-r-with-purrr-469e597d0229?source=collection_archive---------0-----------------------#2018-02-27">https://towardsdatascience.com/functional-programming-in-r-with-purrr-469e597d0229?source=collection_archive---------0-----------------------#2018-02-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/e4a2976cfcdccad5f2c7b2cd37c95d63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WIKyR5fGZodIwF2_."/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Want replication without repetition? Use purrr!</figcaption></figure><div class=""/></div><div class="ab cl kc kd hu ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ij ik il im in"><p id="bf47" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">当您第一次开始使用 R 时，您可能正在编写简单的代码。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="8d65" class="lq lr jf lm b gy ls lt l lu lv">print("Hello world!")</span><span id="13d0" class="lq lr jf lm b gy lw lt l lu lv">5 * 6</span><span id="7d25" class="lq lr jf lm b gy lw lt l lu lv">x &lt;- c(1, 2, 3, 4, 5)</span></pre><p id="50d6" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">这很好，你正在学习 R 中的字符串、数学和向量！</p><p id="9565" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">然后你开始做一些基本的分析。你想看看你是否能找到一些数字的平均值。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="acdc" class="lq lr jf lm b gy ls lt l lu lv">employee &lt;- c('John Doe','Peter Gynn','Jolie Hope')<br/>salary &lt;- c(21000, 23400, 26800)<br/>startdate &lt;- as.Date(c('2010-11-1','2008-3-25','2007-3-14'))</span><span id="6136" class="lq lr jf lm b gy lw lt l lu lv"># form dataframe and take mean of salary column<br/>employ_data &lt;- data.frame(employee, salary, startdate)<br/>mean(employ_data$salary)</span><span id="bc6d" class="lq lr jf lm b gy lw lt l lu lv"># output<br/>[1] 23733.33</span></pre><p id="4be3" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">最终，您有希望接触到<code class="fe lx ly lz lm b">tidyverse</code>，并且您会发现这个“为数据科学设计的 R 包的固执己见的集合”是如何使 R 中的数据分析更容易和更可读的！</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="e044" class="lq lr jf lm b gy ls lt l lu lv">mtcars %&gt;% <br/>  group_by(cyl) %&gt;% <br/>  summarize(mean(mpg))</span><span id="f5da" class="lq lr jf lm b gy lw lt l lu lv"># A tibble: 3 x 2<br/>    cyl `mean(mpg)`<br/>  &lt;dbl&gt;       &lt;dbl&gt;<br/>1  4.00        26.7<br/>2  6.00        19.7<br/>3  8.00        15.1</span></pre><p id="b835" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">一切都很顺利！在这一点上，你很可能已经取代了 Excel，还有 SPSS 或其他一些统计软件套件！但是你会遇到一个问题，你需要重复使用一个函数。</p><p id="8845" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">您可以使用类似下面的代码来计算一些<strong class="kl jg">因变量</strong>和一组<strong class="kl jg">自变量</strong>的单向方差分析:</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="d596" class="lq lr jf lm b gy ls lt l lu lv">aov_mpg &lt;- aov(mpg ~ factor(cyl), data = mtcars)<br/>summary(aov_mpg)</span><span id="b9af" class="lq lr jf lm b gy lw lt l lu lv">aov_disp &lt;- aov(disp ~ factor(cyll), data = mtcars)<br/>summary(aov_disp)</span><span id="e90d" class="lq lr jf lm b gy lw lt l lu lv">aov_hp &lt;- aov(hp ~ factor(cyl), data = mrcars)<br/>summry(aov_hpp)</span><span id="b3f9" class="lq lr jf lm b gy lw lt l lu lv">aov_wt &lt;- aov(wt ~ factor(cyl), datas = mtcars)<br/>summary(aov_wt)</span></pre><p id="fd77" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">但是您复制粘贴了 3 次代码，糟糕的是，您犯了一些小的拼写错误，从而引发了一个错误！(以上代码导致错误！)</p><p id="ac04" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">此外，如果您意识到您实际上想要运行这些 ANOVAs 来计算齿轮数而不是气缸数，会怎么样呢？你必须回去把<code class="fe lx ly lz lm b">factor(cyl)</code>呼叫改成<code class="fe lx ly lz lm b">factor(gear)</code> 4x！这不是很有效率，而且你更有可能以错误结束，因为你必须多次输入所有的内容！</p></div><div class="ab cl kc kd hu ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ij ik il im in"><p id="f929" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">再举个例子怎么样。</p><p id="ff30" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">让我们根据<strong class="kl jg">气缸</strong>的数量，计算<strong class="kl jg">重量</strong>和<strong class="kl jg">每加仑行驶里程</strong>之间的线性关系的<strong class="kl jg"> R 平方</strong>值。</p><p id="a77a" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">我在下面写了代码，为来自<code class="fe lx ly lz lm b">mtcars</code>数据集的 4 缸汽车做了这些。这是一个最坏的情况，你知道一些<code class="fe lx ly lz lm b">dplyr</code>代码(<code class="fe lx ly lz lm b">dplyr::filter</code>)，但是不习惯使用管道。这很好，你完成了你的目标，但大量的编码！你必须为 6 缸和 8 缸汽车复制这个代码，甚至更多的代码…</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="9897" class="lq lr jf lm b gy ls lt l lu lv"># create df for 4 cylinder cars<br/>cyl_4 &lt;- filter(mtcars, cyl == 4)</span><span id="92ba" class="lq lr jf lm b gy lw lt l lu lv"># create a linear model on 4 cyl cars<br/>lm_4 &lt;- lm(mpg ~ wt, data = cyl_4)</span><span id="7c26" class="lq lr jf lm b gy lw lt l lu lv"># get the summ<br/>lm_4_summary &lt;- summary(lm_4)</span><span id="4184" class="lq lr jf lm b gy lw lt l lu lv"># get the r.squared value<br/>lm_4_r_squared &lt;- lm_4_summary["r.squared"]</span><span id="4267" class="lq lr jf lm b gy lw lt l lu lv"># check the value<br/>lm_4cyl_r_squared</span><span id="9c21" class="lq lr jf lm b gy lw lt l lu lv"># output<br/>$r.squared<br/>[1] 0.5086326</span></pre><p id="03f2" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">或者，你可以对管道做同样的事情。输入要少得多，但是对所有 3 个子集都这样做意味着我们必须多次复制粘贴，所以如果你最终想除了 mpg ~ wt 之外还作为 mpg ~ disp 的线性模型这样做，你就必须再复制代码 3 次，再修改 3 次。这可能看起来没什么大不了的，但是一旦你开始按比例增加代码(比如 10+倍或 100+倍，等等)，最终将是一件大事。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="eb41" class="lq lr jf lm b gy ls lt l lu lv">lm_4cyl_rsquared &lt;- mtcars %&gt;% <br/>  filter(cyl == 4) %&gt;%<br/>  lm(mpg ~ wt, data = .) %&gt;% <br/>  summary() %&gt;% <br/>  .$"r.squared"</span><span id="17fc" class="lq lr jf lm b gy lw lt l lu lv"># output<br/>[1] 0.5086326</span></pre><p id="5a98" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">为了解决这个最小化<strong class="kl jg"> <em class="ma">重复</em> </strong>并进一步<strong class="kl jg"><em class="ma"/></strong>复制的问题，我们可以直接进入<code class="fe lx ly lz lm b">purrr</code>！要阅读更多关于<code class="fe lx ly lz lm b">purrr</code>的内容，Hadley Wickham 推荐了“R for Data Science”中的<a class="ae mb" href="http://r4ds.had.co.nz/iteration.html" rel="noopener ugc nofollow" target="_blank">迭代</a>章节，或者你也可以看看<code class="fe lx ly lz lm b">purrr</code> <a class="ae mb" href="https://cran.r-project.org/web/packages/purrr/purrr.pdf" rel="noopener ugc nofollow" target="_blank">文档</a>。最后，珍妮·布莱恩在这里有一个很棒的咕噜咕噜教程<a class="ae mb" href="https://jennybc.github.io/purrr-tutorial/bk01_base-functions.html" rel="noopener ugc nofollow" target="_blank"/>。你可以单独加载<code class="fe lx ly lz lm b">purrr</code>，但是它也作为<code class="fe lx ly lz lm b">tidyverse</code>库的一部分被加载。</p></div><div class="ab cl kc kd hu ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ij ik il im in"><figure class="lh li lj lk gt is gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/632cd243f2dd2ef32a644ca390916cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*YsySYq7Pq-x9W5ZnIw7EnA.gif"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">I used to be all meep — meep — PANIC about purrr!!</figcaption></figure><figure class="lh li lj lk gt is gh gi paragraph-image"><div class="gh gi md"><img src="../Images/fe0ea48dd9a0cb86f1f1185a2f8bf4c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/1*eXcgQl9n4s-cqzRmhXqjjQ.gif"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">now I’m all like <br/> map %&gt;% <br/> map %&gt;% <br/>PARTY!</figcaption></figure><p id="3cc2" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated"><code class="fe lx ly lz lm b">purrr</code>允许您将<strong class="kl jg"> <em class="ma">映射</em> </strong>函数到数据。恰当地说，<code class="fe lx ly lz lm b">purrr</code>中的基本功能叫做<code class="fe lx ly lz lm b">map()</code>！map 函数通过对每个元素应用一个函数并返回一个与输入长度相同的向量来转换它们的输入。</p><p id="58a4" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated"><strong class="kl jg">map()的基本参数有:<br/> </strong> <code class="fe lx ly lz lm b">.x</code> —列表或原子向量(逻辑、整数、双精度/数字和字符)<br/> <code class="fe lx ly lz lm b">.f</code> —函数、公式或原子向量</p><p id="3f67" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">基本上<code class="fe lx ly lz lm b">map()</code>采用一个函数(<code class="fe lx ly lz lm b">.f</code>)并将其应用于数据(<code class="fe lx ly lz lm b">.x</code>)。</p><p id="62f7" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">回到我们从线性模型中获取 R 平方的例子，我们使用下面的代码和<code class="fe lx ly lz lm b">purrr</code>。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="5650" class="lq lr jf lm b gy ls lt l lu lv">mtcars %&gt;%<br/>  split(.$cyl) %&gt;%<br/>  map(~ lm(mpg ~ wt, data = .)) %&gt;%<br/>  map(summary) %&gt;%<br/>  map_dbl("r.squared")</span><span id="26d4" class="lq lr jf lm b gy lw lt l lu lv"># output<br/>4         6         8 <br/>0.5086326 0.4645102 0.4229655</span></pre><p id="3978" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">这将在 5 行代码中根据气缸数量生成我们所有 3 个线性模型的输出！这就是<code class="fe lx ly lz lm b">purrr</code>的妙处，函数的高效缩放！</p><p id="897e" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">让我们来分解我们的线性模型 R 平方码。</p><p id="5ebc" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">我们采用 mtcars 数据集，根据气缸数量将其分成数据子集，将<em class="ma"> mpg </em> by <em class="ma"> wt </em>的线性模型应用于每个数据子集，应用汇总函数，然后得出 r.squared 值。然而，尽管<code class="fe lx ly lz lm b">purrr</code>是可读的，我们还是需要了解一些使用它的习惯。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="c58f" class="lq lr jf lm b gy ls lt l lu lv">mtcars %&gt;%<br/>  split(.$cyl) %&gt;%<br/>  map(~ lm(mpg ~ wt, data = .)) %&gt;%<br/>  map(summary) %&gt;%<br/>  map_dbl("r.squared")</span><span id="91ac" class="lq lr jf lm b gy lw lt l lu lv"># output<br/>4         6         8 <br/>0.5086326 0.4645102 0.4229655</span></pre><p id="c3dc" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">对于我们这里的代码，你可能已经注意到我们有一个“.”在代码中放置了两次。这是数据的占位符，我们可以在下面看到。的“.”指示左侧数据，在本例中为<code class="fe lx ly lz lm b">mtcars</code>。我们的 split 调用将<code class="fe lx ly lz lm b">mtcars</code>数据帧分成 3 个数据帧，每个数据帧存储在一个列表中。这可能看起来很奇怪，但是它允许<code class="fe lx ly lz lm b">map</code>循环遍历我们的 3 个数据帧，并在其中的每一个上单独复制<code class="fe lx ly lz lm b">lm()</code>函数。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="d4dd" class="lq lr jf lm b gy ls lt l lu lv"># piped<br/>mtcars %&gt;% <br/>  split(.$cyl)</span><span id="e9c3" class="lq lr jf lm b gy lw lt l lu lv"># base R<br/>split(mtcars, mtcars$cyl)</span><span id="1d4c" class="lq lr jf lm b gy lw lt l lu lv"># output<br/>List of 3<br/> $ 4:'data.frame': 11 obs. of  11 variables:<br/>  ..$ mpg : num [1:11] 22.8 24.4 22.8 32.4 30.4 33.9 21.5 27.3 26...<br/>  ..$ cyl : num [1:11] 4 4 4 4 4 4 4 4 4 4 ...<br/>  ..$ disp: num [1:11] 108 146.7 140.8 78.7 75.7 ...<br/>  ..$ hp  : num [1:11] 93 62 95 66 52 65 97 66 91 113 ...<br/>  ..$ drat: num [1:11] 3.85 3.69 3.92 4.08 4.93 4.22 3.7 4.08 ...<br/>  ..$ wt  : num [1:11] 2.32 3.19 3.15 2.2 1.61 ...<br/>  ..$ qsec: num [1:11] 18.6 20 22.9 19.5 18.5 ...<br/>  ..$ vs  : num [1:11] 1 1 1 1 1 1 1 1 0 1 ...<br/>  ..$ am  : num [1:11] 1 0 0 1 1 1 0 1 1 1 ...<br/>  ..$ gear: num [1:11] 4 4 4 4 4 4 3 4 5 5 ...<br/>  ..$ carb: num [1:11] 1 2 2 1 2 1 1 1 2 2 ...<br/> $ 6:'data.frame': 7 obs. of  11 variables:<br/>  ..$ mpg : num [1:7] 21 21 21.4 18.1 19.2 17.8 19.7<br/>  ..$ cyl : num [1:7] 6 6 6 6 6 6 6<br/>  ..$ disp: num [1:7] 160 160 258 225 168 ...<br/>  ..$ hp  : num [1:7] 110 110 110 105 123 123 175<br/>  ..$ drat: num [1:7] 3.9 3.9 3.08 2.76 3.92 3.92 3.62<br/>  ..$ wt  : num [1:7] 2.62 2.88 3.21 3.46 3.44 ...<br/>  ..$ qsec: num [1:7] 16.5 17 19.4 20.2 18.3 ...<br/>  ..$ vs  : num [1:7] 0 0 1 1 1 1 0<br/>  ..$ am  : num [1:7] 1 1 0 0 0 0 1<br/>  ..$ gear: num [1:7] 4 4 3 3 4 4 5<br/>  ..$ carb: num [1:7] 4 4 1 1 4 4 6<br/> $ 8:'data.frame': 14 obs. of  11 variables:<br/>  ..$ mpg : num [1:14] 18.7 14.3 16.4 17.3 15.2 10.4 10.4 14.7...<br/>  ..$ cyl : num [1:14] 8 8 8 8 8 8 8 8 8 8 ...<br/>  ..$ disp: num [1:14] 360 360 276 276 276 ...<br/>  ..$ hp  : num [1:14] 175 245 180 180 180 205 215 230 150 150 ...<br/>  ..$ drat: num [1:14] 3.15 3.21 3.07 3.07 3.07 2.93 3 3.23 2.76...<br/>  ..$ wt  : num [1:14] 3.44 3.57 4.07 3.73 3.78 ...<br/>  ..$ qsec: num [1:14] 17 15.8 17.4 17.6 18 ...<br/>  ..$ vs  : num [1:14] 0 0 0 0 0 0 0 0 0 0 ...<br/>  ..$ am  : num [1:14] 0 0 0 0 0 0 0 0 0 0 ...<br/>  ..$ gear: num [1:14] 3 3 3 3 3 3 3 3 3 3 ...<br/>  ..$ carb: num [1:14] 2 4 3 3 3 4 4 4 2 2 ...</span></pre><p id="b227" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">类似地，这个“.”in 或 first map 调用是数据的占位符，但在这种情况下，它将循环遍历由前面的管道生成的 3 个数据帧的列表。你可以看到我们得到了一个 3 个<code class="fe lx ly lz lm b">lm()</code>输出的列表，我们需要<code class="fe lx ly lz lm b">map</code>一个对每个输出的总结调用来访问 R 平方。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="5f60" class="lq lr jf lm b gy ls lt l lu lv">mtcars %&gt;%<br/>  split(.$cyl) %&gt;%<br/>  map(~ lm(mpg ~ wt, data = .))</span><span id="2f85" class="lq lr jf lm b gy lw lt l lu lv"># output<br/>$`4`</span><span id="d96f" class="lq lr jf lm b gy lw lt l lu lv">Call:<br/>lm(formula = mpg ~ wt, data = .)</span><span id="b1bc" class="lq lr jf lm b gy lw lt l lu lv">Coefficients:<br/>(Intercept)           wt  <br/>     39.571       -5.647</span><span id="59c7" class="lq lr jf lm b gy lw lt l lu lv">$`6`</span><span id="b6a8" class="lq lr jf lm b gy lw lt l lu lv">Call:<br/>lm(formula = mpg ~ wt, data = .)</span><span id="a328" class="lq lr jf lm b gy lw lt l lu lv">Coefficients:<br/>(Intercept)           wt  <br/>      28.41        -2.78</span><span id="4ef1" class="lq lr jf lm b gy lw lt l lu lv">$`8`</span><span id="10f8" class="lq lr jf lm b gy lw lt l lu lv">Call:<br/>lm(formula = mpg ~ wt, data = .)</span><span id="e9a3" class="lq lr jf lm b gy lw lt l lu lv">Coefficients:<br/>(Intercept)           wt  <br/>     23.868       -2.192</span></pre><p id="a1d2" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">接下来，我们将总结函数映射到每个列表项，以获得具有 R 平方值的更清晰的输出。我们现在有了统计输出的其余部分，包括 p 值和 R 平方。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="70f7" class="lq lr jf lm b gy ls lt l lu lv">mtcars %&gt;%<br/>  split(.$cyl) %&gt;%<br/>  map(~ lm(mpg ~ wt, data = .)) %&gt;%<br/>  map(summary)</span><span id="206b" class="lq lr jf lm b gy lw lt l lu lv"># output<br/>$`4`</span><span id="d751" class="lq lr jf lm b gy lw lt l lu lv">Call:<br/>lm(formula = mpg ~ wt, data = .)</span><span id="c5be" class="lq lr jf lm b gy lw lt l lu lv">Residuals:<br/>    Min      1Q  Median      3Q     Max <br/>-4.1513 -1.9795 -0.6272  1.9299  5.2523</span><span id="80b0" class="lq lr jf lm b gy lw lt l lu lv">Coefficients:<br/>            Estimate Std. Error t value Pr(&gt;|t|)    <br/>(Intercept)   39.571      4.347   9.104 7.77e-06 ***<br/>wt            -5.647      1.850  -3.052   0.0137 *  <br/>---<br/>Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</span><span id="ed29" class="lq lr jf lm b gy lw lt l lu lv">Residual standard error: 3.332 on 9 degrees of freedom<br/>Multiple R-squared:  0.5086, Adjusted R-squared:  0.454 <br/>F-statistic: 9.316 on 1 and 9 DF,  p-value: 0.01374</span><span id="10f5" class="lq lr jf lm b gy lw lt l lu lv">$`6`</span><span id="c143" class="lq lr jf lm b gy lw lt l lu lv">Call:<br/>lm(formula = mpg ~ wt, data = .)</span><span id="93d9" class="lq lr jf lm b gy lw lt l lu lv">Residuals:<br/>     Mazda RX4  Mazda RX4 Wag Hornet 4 Drive        Valiant       Merc 280 <br/>       -0.1250         0.5840         1.9292        -0.6897         0.3547 <br/>     Merc 280C   Ferrari Dino <br/>       -1.0453        -1.0080</span><span id="2987" class="lq lr jf lm b gy lw lt l lu lv">Coefficients:<br/>            Estimate Std. Error t value Pr(&gt;|t|)   <br/>(Intercept)   28.409      4.184   6.789  0.00105 **<br/>wt            -2.780      1.335  -2.083  0.09176 . <br/>---<br/>Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</span><span id="4109" class="lq lr jf lm b gy lw lt l lu lv">Residual standard error: 1.165 on 5 degrees of freedom<br/>Multiple R-squared:  0.4645, Adjusted R-squared:  0.3574 <br/>F-statistic: 4.337 on 1 and 5 DF,  p-value: 0.09176</span><span id="a404" class="lq lr jf lm b gy lw lt l lu lv">$`8`</span><span id="54f1" class="lq lr jf lm b gy lw lt l lu lv">Call:<br/>lm(formula = mpg ~ wt, data = .)</span><span id="3f31" class="lq lr jf lm b gy lw lt l lu lv">Residuals:<br/>    Min      1Q  Median      3Q     Max <br/>-2.1491 -1.4664 -0.8458  1.5711  3.7619</span><span id="b537" class="lq lr jf lm b gy lw lt l lu lv">Coefficients:<br/>            Estimate Std. Error t value Pr(&gt;|t|)    <br/>(Intercept)  23.8680     3.0055   7.942 4.05e-06 ***<br/>wt           -2.1924     0.7392  -2.966   0.0118 *  <br/>---<br/>Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</span><span id="1bf6" class="lq lr jf lm b gy lw lt l lu lv">Residual standard error: 2.024 on 12 degrees of freedom<br/>Multiple R-squared:  0.423, Adjusted R-squared:  0.3749 <br/>F-statistic: 8.796 on 1 and 12 DF,  p-value: 0.01179</span></pre><p id="63ed" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">我们上一张地图有点不同。你可以看到我们这次使用了<code class="fe lx ly lz lm b">map_dbl</code>。这表明我们希望我们的输出是 dbl 或数字结果。我们得到了很好的命名数字！</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="bf8e" class="lq lr jf lm b gy ls lt l lu lv">mtcars %&gt;%<br/>  split(.$cyl) %&gt;%<br/>  map(~ lm(mpg ~ wt, data = .)) %&gt;%<br/>  map(summary) %&gt;%<br/>  map_dbl("r.squared")</span><span id="d396" class="lq lr jf lm b gy lw lt l lu lv"># output<br/>        4         6         8 <br/>0.5086326 0.4645102 0.4229655</span></pre><p id="45be" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">如果我们没有指明<code class="fe lx ly lz lm b">map_dbl</code>，而是使用了<code class="fe lx ly lz lm b">map</code>，我们将得到一个相同结果的列表。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="2efc" class="lq lr jf lm b gy ls lt l lu lv">mtcars %&gt;%<br/>  split(.$cyl) %&gt;% <br/>  map(~ lm(mpg ~ wt, data = .)) %&gt;%<br/>  map(summary) %&gt;%<br/>  map("r.squared")</span><span id="d18b" class="lq lr jf lm b gy lw lt l lu lv"># output<br/>$`4`<br/>[1] 0.5086326</span><span id="8c3e" class="lq lr jf lm b gy lw lt l lu lv">$`6`<br/>[1] 0.4645102</span><span id="24a6" class="lq lr jf lm b gy lw lt l lu lv">$`8`<br/>[1] 0.4229655</span></pre><p id="37c0" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">您也可以使用<code class="fe lx ly lz lm b">map_dfr</code>，它将输出绑定到数据帧的行中。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="70ba" class="lq lr jf lm b gy ls lt l lu lv">mtcars %&gt;%<br/>  split(.$cyl) %&gt;% <br/>  map(~ lm(mpg ~ wt, data = .)) %&gt;%<br/>  map(summary) %&gt;%<br/>  map_dfr("r.squared")</span><span id="af17" class="lq lr jf lm b gy lw lt l lu lv"># output<br/># A tibble: 1 x 3<br/>    `4`   `6`   `8`<br/>  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;<br/>1 0.509 0.465 0.423</span></pre></div><div class="ab cl kc kd hu ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ij ik il im in"><p id="bb77" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated"><code class="fe lx ly lz lm b">purrr</code>和<code class="fe lx ly lz lm b">purrr</code>中的其他函数有无限的应用，这极大地增强了 r 中函数式编程的能力。我希望本指南能激励您将<code class="fe lx ly lz lm b">purrr</code>添加到工具箱中，并探索这个有用的<code class="fe lx ly lz lm b">tidyverse</code>包！</p><p id="3057" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">作为<code class="fe lx ly lz lm b">purrr</code>更多应用的一个简短的引子，我将留给你这个例子。我在开始时提到了计算多个变量的 ANOVAs。自己分解一下这个例子，看看大家怎么看！(您可以将这段代码复制粘贴到 R 中，但是需要先加载<code class="fe lx ly lz lm b">tidyverse</code>和<code class="fe lx ly lz lm b">broom</code>包)。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="364d" class="lq lr jf lm b gy ls lt l lu lv">mtcars %&gt;%<br/>  mutate(cyl = factor(cyl),<br/>         am = factor(am)) %&gt;%<br/>  select(mpg, disp, hp) %&gt;%<br/>  map(~ aov(.x ~ cyl * am, data = mtcars)) %&gt;%<br/>  map_dfr(~ broom::tidy(.), .id = 'source') %&gt;%<br/>  mutate(p.value = round(p.value, 5))</span></pre></div><div class="ab cl kc kd hu ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ij ik il im in"><p id="8f69" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">最后，我要感谢几个#r4ds slack 社区成员，他们帮助我理解了 purrr: Frank Farach，Michael Kuehn 和 Kent Johnson。</p><p id="08e1" class="pw-post-body-paragraph kj kk jf kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">如果你有兴趣加入这个由<a class="me mf ep" href="https://medium.com/u/56211c3483cf?source=post_page-----469e597d0229--------------------------------" rel="noopener" target="_blank">杰西·梅根</a>领导的社区，在这里查看她的帖子<a class="ae mb" href="https://medium.com/@kierisi/r4ds-the-next-iteration-d51e0a1b0b82" rel="noopener">，愿原力与你同在！</a></p><figure class="lh li lj lk gt is gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/58b1853ac21c84c986f931ffb8360c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/1*k4slavWmJrvzdHdfule1Bw.gif"/></div></figure></div></div>    
</body>
</html>