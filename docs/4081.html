<html>
<head>
<title>Big Data with Sketchy Structures, Part 1 — the Count-Min Sketch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有粗略结构的大数据，第 1 部分—计数-最小草图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/big-data-with-sketchy-structures-part-1-the-count-min-sketch-b73fb3a33e2a?source=collection_archive---------2-----------------------#2018-07-17">https://towardsdatascience.com/big-data-with-sketchy-structures-part-1-the-count-min-sketch-b73fb3a33e2a?source=collection_archive---------2-----------------------#2018-07-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/5d780406ed751768b4363f5c6b0c9a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*IbtPZ-eX_00mWT8LosqSBA.jpeg"/></div></figure><p id="79aa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你是一家流媒体公司的开发人员。你的团队开发了一个视频内容平台，比如网飞和 YouTube。你的应用程序很受欢迎，用户基数大，内容丰富。</p><p id="b6d8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，您的团队希望开始加强数据分析，以提高用户参与度。你的团队做的第一件事就是分析平台上的视频流行度。您可能在某个地方有一个散列表，将每个视频的唯一 id 映射到一个观看次数。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi ks"><img src="../Images/66b7d48cbe312c481cba5f4eeffba0d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*fC_-aRoBadjgaqk2CsjZmQ.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">a standard hash table</figcaption></figure><p id="6a48" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以你开始分析这个视频观看计数数据，试图找到趋势和诸如此类的东西，但你很快就遇到了一个问题。哈希表的空间复杂度为 O(n)——消耗的空间量与存储的项目数量成正比。例如，如果您的平台有 40 亿个视频，并且每个视频都有一个 32 位的唯一 id(这是支持这种规模的集合的最低值)，那么您将需要 160 亿字节的数据，或 16 GB，仅仅是为了跟踪每个视频的 id！然后，您必须考虑视图计数——每个视图都可以存储在一个 32 位整数中。这又是 16 GB，意味着您的哈希表总共将消耗 32 GB！</p><p id="7b64" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">大多数消费者笔记本电脑没有足够的内存来处理这么多数据。如果您想要将这些视图计数与元数据(如地区、语言、年份、长度和流派)进行交叉引用，以便进行高级分析？你做梦去吧。</p><p id="a8b2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这一点上，很多人会认输，惊呼他们需要一个计算集群来运行分布式并行计算工具，如 Hadoop 和 Spark。也许这是正确的解决方案。但是，在我们投入大量资金并给我们的项目增加大量复杂性之前，让我们探索一些可能使我们的工作稍微容易一点的替代数据结构。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="1a94" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">草图——它们是什么？</h1><p id="fb13" class="pw-post-body-paragraph ju jv iq jw b jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ij bi translated">有一类数据结构被称为<strong class="jw ir">草图</strong>，它们有能力用次对数甚至恒定的空间复杂度来表示极大的集合。这意味着，当您从第一千个视频过渡到第一个一百万个视频，再到第一个十亿个视频时，您不需要扩展您的计算能力！</p><p id="a7fc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">听起来好得难以置信？从某种意义上来说，的确如此。草图依靠各种技巧来压缩数据，通常，这些技巧会导致草图包含不准确的信息。初始化草图时，可以分配任意多的空间。但是如果你的集合变得太大，或者你没有分配足够的空间，那么草图很可能返回不精确的结果。这里有一个非常明显的权衡——尺寸与精度——作为一名工程师，这取决于您能否找到满足您需求的平衡点。</p><p id="823f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">作为一个比喻，把原始场景想象成一幅美丽的画，而你的素描，嗯，就是那幅画的素描。就像你需要投入更多的精力来完美地复制这幅画一样，你也需要更多的空间来正确地复制一套。就像一幅错综复杂的画比一幅简单的画更难模仿一样，大型布景比小型布景需要更多的空间来绘制草图。如果你熟悉机器学习，你可以认为素描类似于降维。当您的应用程序正在处理大数据时，这是一种有效的技术，但它不需要完美的准确性。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="aa4e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Count-Min Sketches——人们大约看了多少次阿黛尔的《你好》?</p><p id="4927" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">回想一下，我们需要目录中每个视频的浏览量。本质上，这是一个事件发生问题；我们有一个事件流(视图),我们想计算每个事件发生了多少次。事件发生问题的一个流行解决方案是<strong class="jw ir">计数分钟草图</strong>。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ml"><img src="../Images/a8e3b2119ad3f3867b336ae91a6b2aa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*IKXMPJQUk1W3GXNg5aBueQ.png"/></div></div></figure><p id="c9c7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Count-Min 草图的内部结构是一个表，类似于散列表。然而，虽然散列表使用单个散列函数，但 Count-Min 草图使用多个散列函数，每列一个。最初，Count-Min-Sketch 中的每个单元都被初始化为 0。当一个事件发生时，该事件的 id 在每一列上被散列。每个哈希函数输出一个行值，并且每个行-列组合的计数器都会递增。为了查询一个事件的计数，我们在所有散列函数中取该事件计数的最小值。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/4077a14c882c2aa7f65ac84ca01ab2d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*D8xinX1lKDFCzoT_TBmETw.png"/></div></figure><p id="ca14" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们举个例子。假设我们有一个 3 列 4 行的最小计数草图。你平台上的第一个用户决定观看“日本历史”。当视频的 id 被这三个散列值散列后，我们得到 1、2 和 1，这表明我们应该在(1，1)、(2，2)和(1，3)处递增计数器。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mr"><img src="../Images/81241345e31b771e19e6eeb5b9173139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t9opULWtmlcfOM1iejpHsg.png"/></div></div></figure><p id="c6ce" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在假设另一个用户观看 Adele 的“Hello ”,它的哈希值为 1、1 和 4。接下来，又一个用户观看“日本历史”。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ms"><img src="../Images/e727243535370118ee76ff3bab149552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DFBZYwhV8OvY2a8joFUvUw.png"/></div></div></figure><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mt"><img src="../Images/f1a0297ab29f7d98944ab6c9885ec560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8dSLtRol1TBLSkCNDhIiDA.png"/></div></div></figure><p id="5017" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此时，我们决定检查用户观看“Hello”的次数。我们已经看到“Hello”散列为 1、1 和 4，所以我们应该检查单元格(1，1)、(1，2)和(4，3)的计数。这些计数分别为 3、1 和 1。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mu"><img src="../Images/6cb761fda6057e1a0fb03bdf03c39d0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*cQ_xsI5iR1IgFg5vW00Wlw.png"/></div></div></figure><p id="3227" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们知道“你好”只被观看了一次，然而，在上面的计数-分钟草图中，一个计数器显示“你好”被观看了三次！这是因为“Hello”和“Japan”在第一个 hash 函数上发生碰撞，所以任何观看了两次的“Japan”的视图也将计入“Hello”中。从本质上讲，Count-Min 草图是双重的，允许多个事件共享同一个计数器以节省空间。表格中的单元格越多，我们在内存中存储的计数器就越多，因此重复出现的次数就越少，我们的计数器就越精确。</p><p id="7dd1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">即使我们不知道观看历史，我们也可以很容易地断定“你好”被观看了不超过一次。如果它真的被观看了 3 次，那么<em class="mv">所有加粗的计数器将至少为 3。因为三个加粗的计数器中的最小值是 1，所以我们可以断定“Hello”被观看了不超过 1 次。</em></p><p id="7675" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在让我们看一个 Count-Min 草图错误的例子。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/a5477e228c5e7985114d3556ff7630eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*HqEB5b3wrdSixrRLv9y-RQ.png"/></div></figure><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/00cd1c088fe0502f275f540a8240f129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*MhX-RmhFo8EFFpfZFPqHtQ.png"/></div></figure><p id="7574" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">即使“你好”在这个序列中从未被观看过，但每个视频都至少在一个哈希函数中与“你好”发生了冲突。结果，当我们查询 Adele 的“Hello”的观看次数时，我们被错误地告知它已经被观看了一次。如前所述，我们可以通过使用更大的表来降低错误的概率和大小。一个小错误并不意味着世界末日，特别是如果我们的目标是了解总体趋势而不是进行精确测量的话。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="d440" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">最小计数草图的属性</h1><p id="ff14" class="pw-post-body-paragraph ju jv iq jw b jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ij bi translated">Count-Min Sketch 不寻常的结构的伟大之处在于，当我们向集合中添加新事件时，我们不需要分配新的内存。我们增加了一些计数器，但是我们分配的空间是不变的。即使我们添加了一百个、一千个或一百万个新事件，我们的程序也应该在同样多的时间内用同样多的内存运行。换句话说，Count-Min Sketch 在时间和空间上都是 O(1)。问题是，随着我们添加新的事件，会发生更多的冲突，我们的近似计数和真实计数之间的差距会越来越大。</p><p id="1020" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">尽管如此，计数分钟草图是非常有效的。一个 1000x8 的 Count-Min 草图(即 8 个散列函数，每个函数映射到一个 1000 长度的数组)需要存储 8000 个 32 位整数。总共是 32kb——比我们之前设想的 32 GB 的大型哈希表小几个数量级！</p><p id="9849" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Count-Min 草图的另一个吸引人的特性是它是并行的。我们可以同时向表中添加多个事件，只要这些事件的散列不冲突。在“较高”的表中，冲突发生的频率较低，在这些表中，散列函数(列)的数量较少，而散列值(行)的范围较大。为并行应用设计的 Count-Min 草图应该记住这一点。</p><p id="7592" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">任何需要精确计数的任务——比如跟踪广告显示的次数——都不适合计数-分钟草图。计数-最小草图也不提供减少计数的功能，因此您不会使用它们来跟踪可能上下波动的值。</p><p id="7c79" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，计数-分钟草图有一个有趣的特性，他们从来不会低估——他们只会高估事件的数量。从统计学上来说，你可能会说计数分钟草图是<strong class="jw ir">偏差</strong>。如果你只是在比较两个值，这没问题——例如，如果你想弄清楚“你好”是否比“日本历史”更受欢迎。</p><p id="3e33" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，如果偏差是一个问题，那么您可以使用计数最小草图的<strong class="jw ir">去偏差</strong>版本，称为<strong class="jw ir">计数平均最小草图</strong>。当从 Count-Mean-Min 草图中获取事件<em class="mv"> e </em>的计数时，每个<em class="mv"> e </em>的单元格通过减去列平均值来消除偏差。然后，Count-Mean-Min 草图返回偏差校正计数的中值(与 Count-Min 草图不同，它返回高估计数的最小值)。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="4469" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">下次—超对数和布隆过滤器</h1><p id="14d1" class="pw-post-body-paragraph ju jv iq jw b jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ij bi translated">在本文中，我们学习了一种很酷的、节省空间的方法来计算一个元素在流或大型集合中出现的次数，而不必将集合本身存储在内存中。在下一篇文章的<a class="ae my" href="https://medium.com/@shuklak13/big-data-with-sketchy-structures-part-2-hyperloglog-and-bloom-filters-73b1c4a2e6ad" rel="noopener">中，我们将学习两种新的用于处理大规模集合的草图数据结构——一种让您估算一个集合的大小，另一种让您检查一个集合中的成员。</a></p></div></div>    
</body>
</html>