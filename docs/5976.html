<html>
<head>
<title>Scheduling data ingest using Cloud Functions and Cloud Scheduler</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用云功能和云调度程序安排数据接收</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/scheduling-data-ingest-using-cloud-functions-and-cloud-scheduler-b24c8b0ec0a5?source=collection_archive---------11-----------------------#2018-11-19">https://towardsdatascience.com/scheduling-data-ingest-using-cloud-functions-and-cloud-scheduler-b24c8b0ec0a5?source=collection_archive---------11-----------------------#2018-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b317" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着谷歌云的不断发展，我在《谷歌云平台上的数据科学》一书中提出的一些解决方案被取代了，因为更简单、更强大的解决方案变得可用。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/7196249f131fed278f785474cbdd5371.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*VJTjk8GBTq50i9PVVbqBNQ.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">There is now a better way to do periodic ingest than the method I suggested in Chapter 2 of this book.</figcaption></figure><p id="53fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，几个月前，我展示了如何仅使用 SQL 构建回归和分类模型。无需移动数据即可实现高度可扩展的机器学习，这意味着我们可以非常轻松地探索机器学习的价值。如果我今天写这本书，我会在第 5 章(交互式数据探索)中插入一个关于 BigQuery ML 的<a class="ae kl" rel="noopener" target="_blank" href="/how-to-train-and-predict-regression-and-classification-ml-models-using-only-sql-using-bigquery-ml-f219b180b947">部分。</a></p><p id="083b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将讨论第二个更新:一个比我在第 2 章最后一节中介绍的更好的定期数据接收方法。</p><h2 id="8d59" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">老办法:使用 AppEngine Cron 每月更新</h2><p id="20bc" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在本书第二章的最后一节，我提出了一个安排每月下载的解决方案。这包括五个步骤:</p><ol class=""><li id="c1d9" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">在 Python 中摄取</li><li id="aa2f" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">Flask webapp</li><li id="9093" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">在 AppEngine 上运行</li><li id="8547" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">保护 URL</li><li id="18cd" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">调度 Cron 任务</li></ol><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/99401d252cf8355e8ceb384089678142.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*2z4CDOmwQtF9NTpGNRPBAw.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">The solution for periodic ingest presented in the book can be greatly simplified now.</figcaption></figure><p id="ef4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一步已经在书中完成了，我可以简单地重用那个 Python 程序。剩下的步骤变得更容易了。简单多了。</p><h2 id="3f7f" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">使用云功能摄取</h2><p id="ad43" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">有一种更简单的方法来创建可通过 Http 访问的 web 端点，而不是构建 Flask web 应用程序并在 AppEngine 中运行它。新的方法是使用<a class="ae kl" href="https://cloud.google.com/functions/?utm_source=google&amp;utm_medium=cpc&amp;utm_campaign=na-US-all-en-dr-skws-all-all-trial-e-dr-1003905&amp;utm_content=text-ad-none-any-DEV_c-CRE_311551739239-ADGP_Hybrid%20%7C%20AW%20SEM%20%7C%20SKWS%20%7C%20US%20%7C%20en%20%7C%20EXA%20~%20Compute%20~%20Cloud%20Functions%20~%20cloud%20functions-KWID_43700037004320779-kwd-66359843554&amp;utm_term=KW_cloud%20functions-ST_cloud%20functions&amp;gclid=CNmWx8nB4d4CFR2IxQIdjAoFdw" rel="noopener ugc nofollow" target="_blank">云功能</a>。我可以使用用于摄取的相同 Python 代码，但是将它包装在一个名为 main.py 的文件中(本文中的所有<a class="ae kl" href="https://github.com/GoogleCloudPlatform/data-science-on-gcp/tree/master/updates/scheduler" rel="noopener ugc nofollow" target="_blank">代码都在 GitHub </a>上):</p><pre class="kn ko kp kq gt mp mq mr ms aw mt bi"><span id="f1ca" class="lc ld iq mq b gy mu mv l mw mx">import logging<br/>from flask import escape<br/>from ingest_flights import *<br/> <br/>def ingest_flights(request):<br/>   try:<br/>      logging.basicConfig(format='%(levelname)s: %(message)s', level=logging.INFO)<br/>      json = request.get_json()<br/>      year = escape(json['year']) if 'year' in json else None<br/>      month = escape(json['month']) if 'month' in json else None<br/>      bucket = escape(json['bucket'])  # required</span><span id="5a43" class="lc ld iq mq b gy my mv l mw mx">if year is None or month is None or len(year) == 0 or len(month) == 0:<br/>         year, month = next_month(bucket)<br/>      logging.debug('Ingesting year={} month={}'.format(year, month))<br/>      gcsfile = ingest(year, month, bucket)<br/>      logging.info('Success ... ingested to {}'.format(gcsfile))<br/>   except DataUnavailable as e:<br/>      logging.info('Try again later: {}'.format(e.message))To create</span></pre><p id="fd10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本质上，我的 main.py 有一个接收 Flask 请求对象的函数，从中我可以提取 HTTP Post 的 JSON 有效负载，云函数将通过它被触发。</p><p id="e542" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我通过查看桶中已经有哪些月份，然后使用 ingest_flights.py 中的现有代码获取必要的数据，从而获得下一个月。</p><p id="f8ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我写好了 main.py，就可以通过 gcloud 部署云功能了:</p><pre class="kn ko kp kq gt mp mq mr ms aw mt bi"><span id="0cb0" class="lc ld iq mq b gy mu mv l mw mx">gcloud functions deploy ingest_flights \<br/>       --runtime python37 --trigger-http --timeout 480s</span></pre><p id="2b81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过向 Cloud 函数发送 curl 请求来测试它:</p><pre class="kn ko kp kq gt mp mq mr ms aw mt bi"><span id="939e" class="lc ld iq mq b gy mu mv l mw mx">REGION='us-central1'<br/>PROJECT=$(gcloud config get-value project)<br/>BUCKET=cloud-training-demos-ml</span><span id="7469" class="lc ld iq mq b gy my mv l mw mx">echo {\"year\":\"2015\"\,\"month\":\"03\"\,\"bucket\":\"${BUCKET}\"} &gt; /tmp/message<br/></span><span id="a62d" class="lc ld iq mq b gy my mv l mw mx">curl -X POST "<a class="ae kl" href="https://${REGION}-${PROJECT}.cloudfunctions.net/ingest_flights" rel="noopener ugc nofollow" target="_blank">https://${REGION}-${PROJECT}.cloudfunctions.net/ingest_flights</a>" -H "Content-Type:application/json" --data-binary @/tmp/message</span></pre><h2 id="aa10" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">保护云功能</h2><p id="8b3c" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">正如上面的代码所示，云函数的 URL 是完全开放的。为了在某种程度上保护 URL 免受拒绝服务攻击，我们应该将 URL 改为不可访问的。</p><p id="f017" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要使 URL 不可访问，请使用 openssl 库生成一个 48 个字符的字符串，删除非字母数字字符，并将结果精简为 32 个字符:</p><pre class="kn ko kp kq gt mp mq mr ms aw mt bi"><span id="45fa" class="lc ld iq mq b gy mu mv l mw mx">URL=ingest_flights_$(openssl rand -base64 48 | tr -d /=+ | cut -c -32)<br/>echo $URL</span><span id="a9fc" class="lc ld iq mq b gy my mv l mw mx">gcloud functions deploy $URL --runtime python37 --trigger-http --timeout 480s</span></pre><p id="b171" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这本身是不够的。我们还应该坚持让合法的调用者向我们提供一个令牌作为有效负载的一部分。同样，我们可以使用 openssl 程序生成一个令牌，并将支票添加到 main.py:</p><pre class="kn ko kp kq gt mp mq mr ms aw mt bi"><span id="f170" class="lc ld iq mq b gy mu mv l mw mx">if escape(json['token']) != 'DI8TWPzTedNF0b3B8meFPxXSWw6m3bKG':<br/>         logging.info('Ignoring request without valid token')<br/>         return</span></pre><p id="5a5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">做这两件事——一个不可访问的 URL 和检查云函数中的令牌——有助于保护云函数。</p><h2 id="001b" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">使用云调度程序调度摄取</h2><p id="669c" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">现在，云功能提供了一个启动接收作业的 http 端点，我们可以使用云调度程序每月访问该端点一次:</p><pre class="kn ko kp kq gt mp mq mr ms aw mt bi"><span id="f0cc" class="lc ld iq mq b gy mu mv l mw mx">gcloud beta scheduler jobs create http monthlyupdate \<br/>       --schedule="8 of month 10:00" \<br/>       --uri=$URL \<br/>       --max-backoff=7d \<br/>       --max-retry-attempts=5 \<br/>       --max-retry-duration=3h \<br/>       --min-backoff=1h \<br/>       --time-zone="US/Eastern" \<br/>       --message-body-from-file=/tmp/message</span></pre><p id="6bdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">调度器采用多种格式，包括 Unix 的 crontab 格式，但是我发现 AppEngine 的 cron 支持的简单语言格式可读性最好。因此，我们的端点将在每月 8 日美国东部时间上午 10 点被访问。</p><h2 id="f4d1" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">使它不那么单一</h2><p id="153c" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">如果你看看 ingest_flights.py，ingest 方法做了相当多的事情。它下载文件，解压缩文件，清理文件，转换文件，然后将清理后的文件上传到云存储。</p><p id="48a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然我们正在使用云函数，那么重新设计使其不那么单一可能会更好。除了通过 http 调用触发之外，云功能还可以通过向桶中添加文件来触发。</p><p id="d72a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们可以让第一个云函数简单地将解压缩后的文件上传到云存储，然后让第二个云函数执行提取-转换-加载(ETL)部分。这可能更容易维护，尤其是如果事实证明我们在 ETL 部分有一个 bug。原始数据可用于重新运行 ETL 作业。</p><h2 id="6e8b" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">后续步骤</h2><ul class=""><li id="134e" class="ma mb iq jp b jq lv ju lw jy mz kc na kg nb kk nc mg mh mi bi translated">查看 GitHub 上的代码<a class="ae kl" href="https://github.com/GoogleCloudPlatform/data-science-on-gcp/tree/master/updates/scheduler" rel="noopener ugc nofollow" target="_blank"/></li><li id="0c34" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk nc mg mh mi bi translated">看书:<a class="ae kl" href="http://shop.oreilly.com/product/0636920057628.do" rel="noopener ugc nofollow" target="_blank">谷歌云平台上的数据科学</a></li></ul></div></div>    
</body>
</html>