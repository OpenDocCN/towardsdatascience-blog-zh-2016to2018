<html>
<head>
<title>10 Machine Learning Algorithms You need to Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你需要知道的10个机器学习算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-machine-learning-algorithms-you-need-to-know-77fb0055fe0?source=collection_archive---------0-----------------------#2017-12-31">https://towardsdatascience.com/10-machine-learning-algorithms-you-need-to-know-77fb0055fe0?source=collection_archive---------0-----------------------#2017-12-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d75c3781252c2c9a6371c4556f401770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OGX-RSc2GOwlv9VI5I4DCQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo: <a class="ae kc" href="http://hpc-asia.com/wp-content/uploads/2016/02/equations.jpg" rel="noopener ugc nofollow" target="_blank">http://hpc-asia.com/wp-content/uploads/2016/02/equations.jpg</a></figcaption></figure><p id="3e34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于数据分析、大计算能力和云计算的发展，我们生活在一个革命性时代的开端。机器学习肯定会在那里发挥巨大作用，机器学习背后的大脑是基于算法的。本文涵盖了目前使用的10种最流行的机器学习算法。</p><p id="0e0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些算法可以分为三大类。</p><ol class=""><li id="7056" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kf ir">监督算法:</strong>训练数据集有输入，也有期望输出。在训练期间，模型将调整其变量，以将输入映射到相应的输出。</li><li id="e3a5" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">无监督算法:</strong>在这个类别中，没有目标结果。这些算法将对不同组的数据集进行聚类。</li><li id="1e9e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">强化算法:</strong>这些算法是在做决策时训练出来的。因此，基于这些决定，算法将基于输出的成功/错误来训练自己。最终凭经验算法将能够给出好的预测。</li></ol><p id="c63f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的算法将在这篇文章中讨论。</p><ul class=""><li id="2098" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lp lh li lj bi translated">线性回归</li><li id="9661" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lp lh li lj bi translated">SVM(支持向量机)</li><li id="1093" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lp lh li lj bi translated">KNN(K-最近邻)</li><li id="5e09" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lp lh li lj bi translated">逻辑回归</li><li id="e2ae" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lp lh li lj bi translated">决策图表</li><li id="694c" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lp lh li lj bi translated">k均值</li><li id="fd38" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lp lh li lj bi translated">随机森林</li><li id="f2db" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lp lh li lj bi translated">朴素贝叶斯</li><li id="3cfb" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lp lh li lj bi translated">降维算法</li><li id="de7f" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lp lh li lj bi translated">梯度推进算法</li></ul><h2 id="e171" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">1.线性回归</h2><p id="9efe" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">线性回归算法将使用数据点找到最佳拟合线来模拟数据。一条线可以用方程来表示，<strong class="kf ir"> y = m*x + c </strong>其中<strong class="kf ir"> y </strong>为因变量，<strong class="kf ir"> x </strong>为自变量。应用基本的微积分理论，使用给定的数据集找到m<strong class="kf ir">和c</strong>的值。</p><p id="6613" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">线性回归有两种类型:仅使用一个自变量的简单线性回归和定义多个自变量的多元线性回归。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/27eec70e65702479743f55036b6002bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*OEPyTDINRK3sxd4zXWX2Ew.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/Linear_regression.svg/400px-Linear_regression.svg.png" rel="noopener ugc nofollow" target="_blank">https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/Linear_regression.svg/400px-Linear_regression.svg.png</a></figcaption></figure><p id="ad28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“<a class="ae kc" href="http://scikit-learn.org/" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>”是一个简单高效的工具，用于python中的机器学习。下面是使用scikit-learn实现线性回归。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="7f7f" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">2.SVM(支持向量机)</h2><p id="ed6e" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">这属于分类型算法。该算法将使用直线来分隔数据点。选择这条线，使其距离两个类别中最近的数据点最远。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/86d6088c19d0e73c069d31608eeaa598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*DW6xRZ9ylA3JMnlfNFuuBg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b5/Svm_separating_hyperplanes_%28SVG%29.svg/512px-Svm_separating_hyperplanes_%28SVG%29.svg.png" rel="noopener ugc nofollow" target="_blank">https://upload.wikimedia.org/wikipedia/commons/thumb/b/b5/Svm_separating_hyperplanes_%28SVG%29.svg/512px-Svm_separating_hyperplanes_%28SVG%29.svg.png</a></figcaption></figure><p id="cd09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上图中，红线是最好的线，因为它距离最近的点最远。基于这条线，数据点被分为2组。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="33f5" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">3.KNN(K-最近邻)</h2><p id="2a14" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">这是一个简单的算法，用k个最近邻预测未知数据点。k的值在这里是关于预测准确性的一个关键因素。它通过使用基本的距离函数(如欧几里德距离函数)计算距离来确定最近的距离。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/9cced52f0a464f80770392765f57610c.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/1*9h-WczF6csbeut5vsvjSUA.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://au.mathworks.com/matlabcentral/mlc-downloads/downloads/submissions/63621/versions/1/screenshot.gif" rel="noopener ugc nofollow" target="_blank">https://au.mathworks.com/matlabcentral/mlc-downloads/downloads/submissions/63621/versions/1/screenshot.gif</a></figcaption></figure><p id="679a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，这种算法需要很高的计算能力，并且我们需要首先归一化数据，以使每个数据点都在相同的范围内</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="4d40" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">4.逻辑回归</h2><p id="2669" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">逻辑回归用于预期有离散输出的情况，如某些事件的发生(例如预测是否会下雨)。通常，逻辑回归使用一些函数将值压缩到特定的范围。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/33ec173bd850b9ba87755e1f36a42dca.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*Be3Bhz0BA-NgZIYqRVZtug.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Logistic function (<a class="ae kc" href="https://qph.ec.quoracdn.net/main-qimg-05edc1873d0103e36064862a45566dba" rel="noopener ugc nofollow" target="_blank">https://qph.ec.quoracdn.net/main-qimg-05edc1873d0103e36064862a45566dba</a>)</figcaption></figure><p id="5c1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“Sigmoid”(逻辑函数)就是这样一种函数，它具有用于二元分类的“S”形曲线。它将值转换到0，1的范围内，这解释为发生某个事件的概率。</p><p id="d4a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">y = e^(b0+B1 * x)/(1+e^(b0+B1 * x))</strong></p><p id="4b8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面是一个简单的逻辑回归方程，其中b0，b1是常数。同时将计算这些的训练值，使得预测值和实际值之间的误差变得最小。</p><h2 id="1d55" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">5.决策图表</h2><p id="47b5" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">该算法基于群体的一些选定属性(独立变量)将群体分类为几个集合。通常，该算法用于解决分类问题。分类是通过使用一些技术来完成的，如基尼系数、卡方、熵等。</p><p id="025a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们考虑一群人，并使用决策树算法来识别谁喜欢拥有信用卡。例如，考虑人口的年龄和婚姻状况。如果年龄超过30岁或已婚，人们倾向于更多或更少地使用信用卡。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/65700cacb6df15f95958936e34b707eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*J0aEfcQQyI5UWPFweide_w.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Simple Decision Tree</figcaption></figure><p id="a5c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该决策树可以通过识别合适的属性来进一步扩展，以定义更多的类别。在这个例子中，如果一个人已婚并且超过30岁，他们更有可能拥有信用卡(100%偏好)。测试数据用于生成该决策树。</p><h2 id="7d29" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">6.k均值</h2><p id="e677" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">这是一个无监督的算法，为聚类问题提供了一个解决方案。该算法遵循一个程序来形成包含同类数据点的聚类。</p><p id="bfe2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">k的值是算法的输入。在此基础上，算法选择k个质心。然后，指向一个质心的相邻数据点与其质心相结合，并创建一个聚类。稍后，在每个聚类内创建一个新的质心。然后，靠近新质心的数据点将再次组合以扩展聚类。这个过程一直持续到质心不变。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/5452eb4271e94faff61a0a654abd414e.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*jWlAdba9U1zzbfP3p2y6qg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Cluster forming process</figcaption></figure><h2 id="44f4" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">7.随机森林</h2><p id="e3ef" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">如其名，Random forest可以被识别为决策树的集合。每棵树试图估计一个分类，这被称为“投票”。理想情况下，我们考虑每棵树的每一张选票，并选择投票最多的分类。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/0e16d7f7003962e7abda9dae3ea8402d.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*rLYBTFztVFOpAy7m3OtElg.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://www.kdnuggets.com/wp-content/uploads/rand-forest-1.jpg" rel="noopener ugc nofollow" target="_blank">https://www.kdnuggets.com/wp-content/uploads/rand-forest-1.jpg</a></figcaption></figure><h2 id="6ba1" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">8.朴素贝叶斯</h2><p id="3221" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">该算法基于概率论中的“贝叶斯定理”。由于朴素贝叶斯只有在特征彼此独立的情况下才能应用，因为这是贝叶斯定理的要求。如果我们试图通过花瓣的长度和宽度来预测一种花的类型，我们可以使用朴素贝叶斯方法，因为这两个特征是独立的。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/82d161df08740237dde34d69620e2509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*ADp6qgk1IVI4oILwQS-1ZA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Bayes Equation</figcaption></figure><p id="1dbc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">朴素贝叶斯算法也属于分类类型。当问题中存在多个类别时，通常使用这种算法。</p><h2 id="4336" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">9.降维算法</h2><p id="179b" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">一些数据集可能包含许多变量，这可能导致非常难以处理。尤其是现在，由于存在足够多的资源，系统中的数据收集发生在非常详细的级别。在这种情况下，数据集可能包含成千上万的变量，其中大多数也可能是不必要的。</p><p id="353d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，几乎不可能找出对我们的预测影响最大的变量。在这种情况下使用降维算法。它利用随机森林、决策树等其他算法来识别最重要的变量。</p><h2 id="9553" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">10.梯度推进算法</h2><p id="6e7c" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">梯度提升算法使用多个弱算法来创建更强大的精确算法。与使用单个估计器相比，使用多个估计器将创建一个更稳定和更健壮的算法。</p><p id="3bc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有几种梯度增强算法。</p><ul class=""><li id="a844" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lp lh li lj bi translated">XGBoost —使用线性和树算法</li><li id="4f66" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lp lh li lj bi translated">LightGBM —仅使用基于树的算法</li></ul><p id="dec7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">梯度推进算法的特点是精度更高。此外，像LightGBM这样的算法也具有令人难以置信的高性能。</p><p id="cada" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读。</p><p id="5353" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">干杯！</p></div></div>    
</body>
</html>