<html>
<head>
<title>Utilizing quosures to create ultra flexible filtering controls in R Shiny</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用 quosures 在 R Shiny 中创建超灵活的过滤控件</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/utilizing-quosures-to-create-ultra-flexible-filtering-controls-in-r-shiny-f3e5dc461399?source=collection_archive---------5-----------------------#2018-07-29">https://towardsdatascience.com/utilizing-quosures-to-create-ultra-flexible-filtering-controls-in-r-shiny-f3e5dc461399?source=collection_archive---------5-----------------------#2018-07-29</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><p id="6f96" class="pw-post-body-paragraph js jt iv ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp io bi translated">我构建了很多闪亮的应用程序，其中一个常见的用途是允许动态过滤底层数据，这样你就可以根据感兴趣的特定子集来调整图表或表格。</p><p id="7c8f" class="pw-post-body-paragraph js jt iv ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp io bi translated">通常，我们将过滤选项硬编码到某种形式的侧边栏菜单中，并为感兴趣的字段定义输入选项列表。例如，如果我们正在过滤<code class="fe kq kr ks kt b">mtcars</code>数据集，我们可能会在 UI 端提供这样的输入选项列表:</p><pre class="ku kv kw kx gt ky kt kz la aw lb bi"><span id="b551" class="lc ld iv kt b gy le lf l lg lh">shiny::selectInput('cyl', "Select no of cylinders", choices = mtcars$cyl %&gt;% unique() %&gt;% sort())</span></pre><p id="a265" class="pw-post-body-paragraph js jt iv ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp io bi translated">然后我们可以在服务器端使用<code class="fe kq kr ks kt b">input$cyl</code>过滤<code class="fe kq kr ks kt b">mtcars</code>，例如:</p><pre class="ku kv kw kx gt ky kt kz la aw lb bi"><span id="bfc8" class="lc ld iv kt b gy le lf l lg lh">df &lt;- shiny::reactive({<br/>   mtcars %&gt;% dplyr::filter(cyl == input$cyl)<br/>})</span></pre><p id="4bb1" class="pw-post-body-paragraph js jt iv ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp io bi translated">我一直致力于创建一个更通用的结构，它允许完全灵活的动态过滤系统(类似于 MSExcel 电子表格中的过滤)，允许用户选择他们希望过滤的任何字段，以及他们感兴趣的任何字段值。我还想对它进行设置，以便它可以通用地应用于任何数据集，只需要用户指定数据集和允许过滤的列名子集。</p><h2 id="c937" class="lc ld iv bd li lj lk dn ll lm ln dp lo kd lp lq lr kh ls lt lu kl lv lw lx ly bi translated">闪亮输入的参照透明度</h2><p id="ad16" class="pw-post-body-paragraph js jt iv ju b jv lz jx jy jz ma kb kc kd mb kf kg kh mc kj kk kl md kn ko kp io bi translated">为了做到这一点，我们必须避开非标准的评估问题。在上面的<code class="fe kq kr ks kt b">mtcars</code>示例中，<code class="fe kq kr ks kt b">cyl</code>与<code class="fe kq kr ks kt b">input$cyl</code>的处理方式不同。<code class="fe kq kr ks kt b">cyl</code>在<code class="fe kq kr ks kt b">mtcars</code>的上下文中是引用透明的，但是<code class="fe kq kr ks kt b">input$cyl</code>作为输入变量被传递，其值被引用。例如，如果我们选择<code class="fe kq kr ks kt b">input$cyl = 6</code>，这将被解释为我们在 dplyr 中所期望的:</p><pre class="ku kv kw kx gt ky kt kz la aw lb bi"><span id="a2cb" class="lc ld iv kt b gy le lf l lg lh">df &lt;- mtcars %&gt;% dplyr::filter(cyl == '6')</span></pre><p id="1fb5" class="pw-post-body-paragraph js jt iv ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp io bi translated">这很好，但是如果我们想选择这个列作为闪亮的输入呢？例如，您可能希望您的用户能够选择 20 或 30 个不同的列进行筛选。也许我们可以为要过滤的选定列创建一个<code class="fe kq kr ks kt b">input$col</code>,为选定的值创建一个<code class="fe kq kr ks kt b">input$val</code>,如下所示:</p><pre class="ku kv kw kx gt ky kt kz la aw lb bi"><span id="f36f" class="lc ld iv kt b gy le lf l lg lh">df &lt;- shiny::reactive({<br/>   mtcars %&gt;% dplyr::filter(input$col == input$val)<br/>})</span></pre><p id="ab28" class="pw-post-body-paragraph js jt iv ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp io bi translated">嗯，不，我们不能，因为<code class="fe kq kr ks kt b">input$col</code>是作为引用值传递的，并且不是引用透明的。</p><p id="add7" class="pw-post-body-paragraph js jt iv ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp io bi translated">这就是 quosures 真正有用的地方，它可以让你抽象出你的过滤能力(以及你的分组、选择和所有其他我们喜欢的关于<code class="fe kq kr ks kt b">dplyr</code>的可爱的事情)。</p><p id="170a" class="pw-post-body-paragraph js jt iv ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp io bi translated">考虑设置以下简单函数，允许您选择要筛选的列和值:</p><pre class="ku kv kw kx gt ky kt kz la aw lb bi"><span id="bddb" class="lc ld iv kt b gy le lf l lg lh">filter1_by &lt;- function(df, fcol1, fv1) {<br/>  <br/>  filter_var1 &lt;- dplyr::quo(fcol1)</span><span id="1cb0" class="lc ld iv kt b gy me lf l lg lh">  df %&gt;% filter_at(vars(!!filter_var1), all_vars(. == fv1))</span><span id="0c2a" class="lc ld iv kt b gy me lf l lg lh">}</span></pre><p id="6741" class="pw-post-body-paragraph js jt iv ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp io bi translated">这个简单的小函数允许我们使用<code class="fe kq kr ks kt b">filter_at()</code>将列选择(<code class="fe kq kr ks kt b">fcol1</code>)与值选择(<code class="fe kq kr ks kt b">fval1</code>)分开处理。<code class="fe kq kr ks kt b">fcol1</code>现在被捕获为带引号的表达式及其环境，使其在引用上透明，然后我们简单地使用<code class="fe kq kr ks kt b">!!</code> (bangbang)操作符去掉引号，这样<code class="fe kq kr ks kt b">dplyr</code>就可以接受不带引号但在引用上透明的列名。</p><p id="e9fe" class="pw-post-body-paragraph js jt iv ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp io bi translated">不用说，这可以扩展到从任意数量的列中选择任意数量的输入进行过滤。例如，允许三个过滤器的函数如下所示:</p><pre class="ku kv kw kx gt ky kt kz la aw lb bi"><span id="95df" class="lc ld iv kt b gy le lf l lg lh">filter3_by &lt;- function(df, fcol1, fv1, fcol2, fv2, fcol3, fv3) {<br/>  filter_var1 &lt;- dplyr::quo(fcol1)<br/>  filter_var2 &lt;- dplyr::quo(fcol2)<br/>  filter_var3 &lt;- dplyr::quo(fcol3)</span><span id="54c6" class="lc ld iv kt b gy me lf l lg lh">df %&gt;% <br/>     filter_at(vars(!!filter_var1), all_vars(. == fv1)) %&gt;% <br/>     filter_at(vars(!!filter_var2), all_vars(. == fv2)) %&gt;%<br/>     filter_at(vars(!!filter_var3), all_vars(. == fv3))<br/>)</span></pre><h2 id="203b" class="lc ld iv bd li lj lk dn ll lm ln dp lo kd lp lq lr kh ls lt lu kl lv lw lx ly bi translated">让我们构建一个完整的示例</h2><p id="0b7d" class="pw-post-body-paragraph js jt iv ju b jv lz jx jy jz ma kb kc kd mb kf kg kh mc kj kk kl md kn ko kp io bi translated">让我们继续使用<code class="fe kq kr ks kt b">mtcars</code>构建一个完整的例子。假设我们希望用户能够从<code class="fe kq kr ks kt b">mtcars</code>中的任何可用列中选择三列进行过滤。</p><p id="7990" class="pw-post-body-paragraph js jt iv ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp io bi translated">我们首先从<code class="fe kq kr ks kt b">mtcars</code>的列名创建一个向量，我们将使用它作为我们的初始输入选择:</p><pre class="ku kv kw kx gt ky kt kz la aw lb bi"><span id="94ac" class="lc ld iv kt b gy le lf l lg lh">fields &lt;- colnames(mtcars)</span></pre><p id="9d07" class="pw-post-body-paragraph js jt iv ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp io bi translated">让我们设置三个函数来基于一列、两列或三列进行筛选:</p><pre class="ku kv kw kx gt ky kt kz la aw lb bi"><span id="49ec" class="lc ld iv kt b gy le lf l lg lh"># filter on 1 columns</span><span id="8820" class="lc ld iv kt b gy me lf l lg lh">filter1_by &lt;- function(df, fcol1, fv1) {<br/>  filter_var1 &lt;- dplyr::quo(fcol1)</span><span id="8287" class="lc ld iv kt b gy me lf l lg lh">df %&gt;% <br/>     filter_at(vars(!!filter_var1), all_vars(. == fv1))<br/>)</span><span id="23bd" class="lc ld iv kt b gy me lf l lg lh"># filter on 2 columns</span><span id="820a" class="lc ld iv kt b gy me lf l lg lh">filter2_by &lt;- function(df, fcol1, fv1, fcol2, fv2) {<br/>  filter_var1 &lt;- dplyr::quo(fcol1)<br/>  filter_var2 &lt;- dplyr::quo(fcol2)</span><span id="8822" class="lc ld iv kt b gy me lf l lg lh">df %&gt;% <br/>     filter_at(vars(!!filter_var1), all_vars(. == fv1)) %&gt;% <br/>     filter_at(vars(!!filter_var2), all_vars(. == fv2))<br/>)</span><span id="16f2" class="lc ld iv kt b gy me lf l lg lh"># filter on 3 columns</span><span id="8027" class="lc ld iv kt b gy me lf l lg lh">filter3_by &lt;- function(df, fcol1, fv1, fcol2, fv2, fcol3, fv3) {<br/>  filter_var1 &lt;- dplyr::quo(fcol1)<br/>  filter_var2 &lt;- dplyr::quo(fcol2)<br/>  filter_var3 &lt;- dplyr::quo(fcol3)</span><span id="b380" class="lc ld iv kt b gy me lf l lg lh">df %&gt;% <br/>     filter_at(vars(!!filter_var1), all_vars(. == fv1)) %&gt;% <br/>     filter_at(vars(!!filter_var2), all_vars(. == fv2)) %&gt;%<br/>     filter_at(vars(!!filter_var3), all_vars(. == fv3))<br/>)</span></pre><p id="aafe" class="pw-post-body-paragraph js jt iv ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp io bi translated">现在，让我们构建一个闪亮的输入结构，允许我们至少过滤一列，但最多三列，使用复选框允许用户决定他们是否需要额外的过滤器:</p><pre class="ku kv kw kx gt ky kt kz la aw lb bi"><span id="dfa6" class="lc ld iv kt b gy le lf l lg lh">shiny::mainPanel(<br/>  # select first filter column from fields vector <br/>  shiny::selectInput("filter1", "Select filter column 1:", <br/>                     choices = fields),<br/>  # reference a uiOutput that will offer values for first column<br/>  shiny::uiOutput("filter1choice"),<br/>  # offer a checkbox to allow user to select a second filter<br/>  shiny::checkboxInput("filter2req", "Add second filter?"),<br/>  # set further conditional panels to appear in the same fashion<br/>  shiny::conditionalPanel(condition = 'input.filter2req', <br/>                          shiny::uiOutput("filter2eval"),<br/>                          shiny::uiOutput("filter2choice"),<br/>                          shiny::checkboxInput("filter3req", <br/>                                               "Add third filter?")),<br/>  shiny::conditionalPanel(condition = 'input.filter3req &amp; <br/>                                       input.filter2req', <br/>                  shiny::uiOutput("filter3eval"),<br/>                  shiny::uiOutput("filter3choice"))<br/> <br/>)</span></pre><p id="5c27" class="pw-post-body-paragraph js jt iv ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp io bi translated">现在我们需要构建<code class="fe kq kr ks kt b">uiOutputs</code>,它根据所选的过滤器列进行填充，并对已经选择的内容进行响应:</p><pre class="ku kv kw kx gt ky kt kz la aw lb bi"><span id="27f7" class="lc ld iv kt b gy le lf l lg lh"># vector of picklist values for the first selected filter <br/>choicevec1 &lt;- reactive({<br/>    mtcars %&gt;%  dplyr::select(input$filter1) %&gt;% unique() %&gt;% dplyr::arrange_(input$filter1)<br/>})</span><span id="4888" class="lc ld iv kt b gy me lf l lg lh"># renders the picklist for the first selected filter<br/>output$filter1choice &lt;- renderUI(<br/>  selectizeInput("filter1val", "Select filter 1 condition:", choices = choicevec1(), multiple = TRUE)<br/>)</span><span id="d54e" class="lc ld iv kt b gy me lf l lg lh"># second column chosen from all remaining fields<br/>output$filter2eval &lt;- renderUI({<br/>  selectInput("filter2", "Select filter criteria 2:", choices = sort(fields[fields != input$filter1]))<br/>})</span><span id="ef76" class="lc ld iv kt b gy me lf l lg lh"># vector of picklist values for the second selected filter<br/>choicevec2 &lt;- reactive({<br/>    filter1_by(mtcars, input$filter1, input$filter1val) %&gt;% <br/>                       dplyr::select(input$filter2) %&gt;% <br/>                       unique() %&gt;% <br/>                       dplyr::arrange_(input$filter2)<br/>})</span><span id="75f1" class="lc ld iv kt b gy me lf l lg lh"># renders picklist for filter 2<br/>output$filter2choice &lt;- renderUI(<br/>  selectizeInput("filter2val", "Select filter 2 condition:", choices = choicevec2(), multiple = TRUE)<br/>)</span><span id="19c8" class="lc ld iv kt b gy me lf l lg lh"># third column selected from remaining fields<br/>output$filter3eval &lt;- renderUI({<br/>  selectInput("filter3", "Select filter criteria 3:", choices = sort(fields[!fields %in% c(input$filter1, input$filter2)]))<br/>})</span><span id="38f4" class="lc ld iv kt b gy me lf l lg lh"># vector of picklist values for third selected column<br/>choicevec3 &lt;- reactive({<br/>    filter2_by(mtcars, input$filter1, input$filter1val, <br/>               input$filter2, input$filter2val) %&gt;% <br/>               dplyr::select(input$filter3) %&gt;% <br/>               unique() %&gt;% <br/>               dplyr::arrange_(input$filter3)<br/>})</span><span id="8cd4" class="lc ld iv kt b gy me lf l lg lh"># render picklist for filter 3<br/>output$filter3choice &lt;- renderUI(<br/>  selectizeInput("filter3val", "Select filter 3 condition:", choices = choicevec3(), multiple = TRUE)<br/>)</span></pre><p id="600d" class="pw-post-body-paragraph js jt iv ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp io bi translated">所以这就是我们在 UI 端需要做的全部。</p><p id="af54" class="pw-post-body-paragraph js jt iv ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp io bi translated">在服务器端，我们现在只需要根据选择的输入定义我们需要的过滤器:</p><pre class="ku kv kw kx gt ky kt kz la aw lb bi"><span id="0ff2" class="lc ld iv kt b gy le lf l lg lh">filtered_mtcars &lt;- reactive({</span><span id="910c" class="lc ld iv kt b gy me lf l lg lh">  # case when all three filters are used<br/>  if (input$filter3req &amp; input$filter2req) {<br/>    filter3_by(mtcars, input$filter1, input$filter1val, <br/>               input$filter2, input$filter2val,<br/>               input$filter3, input$filter3val) <br/>  } else if (input$filter2req) {<br/>  # case when two filters are used<br/>    filter2_by(mtcars, input$filter1, input$filter1val, <br/>               input$filter2, input$filter2val) <br/>  } else {<br/>  # case when only one filter is used   <br/>    filter1_by(mtcars, input$filter1, input$filter1val)<br/>  }</span><span id="9df0" class="lc ld iv kt b gy me lf l lg lh">})</span></pre><p id="9bb3" class="pw-post-body-paragraph js jt iv ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp io bi translated">现在你可以显示你的反应数据框<code class="fe kq kr ks kt b">filtered_mtcars()</code>或者在上面进行操作。</p><h2 id="d85d" class="lc ld iv bd li lj lk dn ll lm ln dp lo kd lp lq lr kh ls lt lu kl lv lw lx ly bi translated">在实践和进一步发展中使用这种方法</h2><p id="104a" class="pw-post-body-paragraph js jt iv ju b jv lz jx jy jz ma kb kc kd mb kf kg kh mc kj kk kl md kn ko kp io bi translated">这些功能可以很容易地移植到你正在设计的任何需要这种灵活过滤的应用程序中。通过简单地编写进一步的函数<code class="fe kq kr ks kt b">filter4_by</code>、<code class="fe kq kr ks kt b">filter5_by</code>等，您可以轻松地扩展到更多的过滤器选择。您还可以通过使用<code class="fe kq kr ks kt b">selectizeInput()</code>并将<code class="fe kq kr ks kt b">==</code>替换为<code class="fe kq kr ks kt b">filter_at()</code>中的<code class="fe kq kr ks kt b">%in%</code>来轻松调整选项列表中的多值选择。</p><p id="cff7" class="pw-post-body-paragraph js jt iv ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp io bi translated">见<a class="ae mf" href="https://keith-mcnulty.shinyapps.io/summer_olympics/" rel="noopener ugc nofollow" target="_blank">这里</a>一个非常简单的演示应用程序，我构建了显示奥运会奖牌统计，允许多达三个过滤器。Github 的代码是<a class="ae mf" href="https://github.com/keithmcnulty/summer_olympics/blob/master/index.Rmd" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><figure class="ku kv kw kx gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mg"><img src="../Images/989681c5b22460f9f3cd4e440dffb42e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t4ARdUcrg8RoTo7_bsiPQQ.jpeg"/></div></div></figure><p id="298c" class="pw-post-body-paragraph js jt iv ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp io bi translated">你能帮助改善这一点吗？理想情况下，我们只需要一个如下所示的过滤函数，而不是编写所有这些独立的函数<code class="fe kq kr ks kt b">filter1_by</code>、<code class="fe kq kr ks kt b">filter2_by</code>等:</p><pre class="ku kv kw kx gt ky kt kz la aw lb bi"><span id="71ef" class="lc ld iv kt b gy le lf l lg lh">filter_by &lt;- function (df, ...) {<br/>  filter_conditions &lt;- quos(...)<br/>  df %&gt;% dplyr::filter(!!!filter_conditions)<br/>}</span></pre><p id="e150" class="pw-post-body-paragraph js jt iv ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp io bi translated">其中输入是条件列表。这些输入将需要某种调整来应对非标准的评估，但我还没有想出它们应该如何措辞。</p><p id="0d87" class="pw-post-body-paragraph js jt iv ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp io bi translated">如果你破解了就告诉我。</p><p id="4ec1" class="pw-post-body-paragraph js jt iv ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp io bi translated">最初我是一名纯粹的数学家，后来我成为了一名心理计量学家和数据科学家。我热衷于将所有这些学科的严谨性应用到复杂的人的问题上。我也是一个编码极客和日本 RPG 的超级粉丝。在<a class="ae mf" href="https://www.linkedin.com/in/keith-mcnulty/" rel="noopener ugc nofollow" target="_blank"><em class="mo">LinkedIn</em></a><em class="mo">或</em><a class="ae mf" href="https://twitter.com/dr_keithmcnulty" rel="noopener ugc nofollow" target="_blank"><em class="mo">Twitter</em></a><em class="mo">上找我。</em></p></div></div>    
</body>
</html>