<html>
<head>
<title>How to generate new data in Machine Learning with AE (Autoencoder) applied to Mnist with Python code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用 Python 代码将 AE (Autoencoder)应用于 Mnist 生成机器学习中的新数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-generate-new-data-in-machine-learning-with-vae-variational-autoencoder-applied-to-mnist-ca68591acdcf?source=collection_archive---------6-----------------------#2018-10-25">https://towardsdatascience.com/how-to-generate-new-data-in-machine-learning-with-vae-variational-autoencoder-applied-to-mnist-ca68591acdcf?source=collection_archive---------6-----------------------#2018-10-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="7374" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://github.com/lbun/VAE_Variational_Autoencoders" rel="noopener ugc nofollow" target="_blank">链接到 github </a></p><p id="455c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">自动编码器是用于生成新数据的神经网络(无监督学习)。该模型用于为数据集生成新数据，或者在我们想要从数据中消除噪声的情况下使用。网络由多个神经网络组成；一个<strong class="js iu">编码器</strong>和一个<strong class="js iu">解码器</strong>通过一个瓶颈连接；这个瓶颈就是下图所示的潜在空间；</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/bfa70a31876c73e1e0d2bd858c745d9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KljH__AWgps488GDaEIH1A.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">font: Hackernoon</figcaption></figure><p id="af0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">编码器</strong>处理数据，直到瓶颈(<strong class="js iu">潜在空间</strong>)减小尺寸，并且<strong class="js iu">解码器</strong>获取数据并重构数据结构，以给出与我们的原始数据相同的输出。我们可以把潜在空间看作是我们数据的一种表示。</p><p id="6483" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个具体的例子中，我们正在读取 28x28 像素(784 个元素)的数字(Mnist 数据集)图像，我们希望将它们减少到 32 个元素(潜在空间),再次创建 28x28 像素的图像。</p><p id="6848" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://en.wikipedia.org/wiki/MNIST_database" rel="noopener ugc nofollow" target="_blank"> MNIST 数据集</a> <strong class="js iu"> </strong>是一个大型的<a class="ae ko" href="https://en.wikipedia.org/wiki/Database" rel="noopener ugc nofollow" target="_blank"> c </a>手写数字集合，常用于图像处理。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lf"><img src="../Images/6854df2b6df3e06a20f87dd2329e5224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xYSAmgivlMCdYuMGZbiq2Q.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">font: <a class="ae ko" href="https://en.wikipedia.org/wiki/MNIST_database" rel="noopener ugc nofollow" target="_blank">Wikipedia</a></figcaption></figure><p id="a54c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以开始导入我们将需要的所有库:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/e0e1c654e9ff9c4826df16279d10d58c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*21XyFM97CtPvgYDVAhC2gQ.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">import</figcaption></figure><p id="5283" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们正在使用来自 keras.models 的<a class="ae ko" href="https://keras.io/models/model/" rel="noopener ugc nofollow" target="_blank">类模型</a>。为了更深入，使用<a class="ae ko" href="https://keras.io/getting-started/functional-api-guide/" rel="noopener ugc nofollow" target="_blank"> keras 功能 API </a>的教程是有用的，这是定义复杂模型的方法，例如多输出模型、有向无环图或具有共享层的模型。</p><p id="98ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在所有的导入之后，我们需要导入数据集，在本例中是由 keras 提供的。</p><p id="3229" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用的图像是 28x28 像素的黑白图像。每个像素由 1 到 255 范围内的一个数字表示。</p><p id="5e8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">导入数据后，我们将对它们进行归一化，将每个像素值除以 255，这是可能的最大值，所有值的范围为 0-1。</p><p id="9938" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">标准化之后，我们需要为输入层重新调整数组的形状。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lh"><img src="../Images/d805cd357c922167509fb03a3d5f80d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qOeh209GJVHf44l9C4HgKA.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Importing and Data Normalization</figcaption></figure><p id="ecb2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦我们有了所有的数据，我们可以开始定义我们的模型，在这里我们可以清楚地看到 3 个部分(编码，瓶颈和解码。通过我们的模型结构，我们可以看到，我们有超过 25k 个参数需要训练，这些参数由权重和偏差表示。这些参数将帮助你生成新的数据。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi li"><img src="../Images/c760e3ecd578d56ab6cc8d6c1863bd89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5bQVZxZMcUBzrk4CFwK7kA.png"/></div></div></figure><p id="5426" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">模型架构的代码可以在 github 上看到。</p><p id="a3fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在建模之后，我们需要编译(定义<a class="ae ko" href="https://keras.io/optimizers/" rel="noopener ugc nofollow" target="_blank">优化器</a>和<a class="ae ko" href="https://keras.io/losses/" rel="noopener ugc nofollow" target="_blank">损失函数</a>)并使其适合我们的训练集。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lj"><img src="../Images/1b36f80a87b00d4a919d265971eb9ea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WYeFPbJqljW8WP8mOm8dWg.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Compiling the model</figcaption></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lk"><img src="../Images/bab9747532b1672f60452a3a2564810a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J-QwGHUzZxn9YpLjxn7dEw.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Plotting the Validation Loss</figcaption></figure><p id="850d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与训练损失相比，验证损失告诉我们我们的模型在泛化方面有多好。</p><p id="4b3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们已经编译和训练了模型，我们可以使用模型的预测功能生成新数据。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ll"><img src="../Images/8bc9a2968968e5fe8f97a17381499a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9FZT48SpEItDG2gQdrsJzw.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">code for plotting</figcaption></figure><p id="28f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用这个代码我们绘制了两行，每行 10 个数字。第一行是真实的图像，第二行是生成的图像。正如我们所看到的，我们丢失了一些信息，但数量显然是相同的。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lm"><img src="../Images/4986d5402222e915fd94e958a9ed84a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W_kGBk5J09gVjo5ShriqjA.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">1s row real &lt;***&gt; 2nd row generated</figcaption></figure><p id="6ee8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个非常强大的模型，可以与管道中的其他机器学习模型相结合，也可以用于预训练模型或减少数据中的噪声。</p><p id="33cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你愿意支持我写其他类似的文章，<a class="ae ko" href="https://www.buymeacoffee.com/berlin" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">请我喝杯咖啡</strong> </a>:)</p></div></div>    
</body>
</html>