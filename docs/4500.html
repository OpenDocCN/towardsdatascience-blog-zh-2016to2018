<html>
<head>
<title>What is the C4.5 algorithm and how does it work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是 C4.5 算法，它是如何工作的？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-is-the-c4-5-algorithm-and-how-does-it-work-2b971a9e7db0?source=collection_archive---------0-----------------------#2018-08-20">https://towardsdatascience.com/what-is-the-c4-5-algorithm-and-how-does-it-work-2b971a9e7db0?source=collection_archive---------0-----------------------#2018-08-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/405f728b89eec909140ab56ab7ab7601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W2dmcgCVYhp2WNOD0UjuXA.jpeg"/></div></div></figure><p id="65a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">C4.5 算法在数据挖掘中用作决策树分类器，可用于基于特定数据样本(单变量或多变量预测器)生成决策。</p><p id="5338" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，在我们直接进入 C4.5 之前，让我们讨论一下<strong class="ka ir">决策树</strong>以及它们如何被用作分类器。</p><h1 id="d1bc" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">决策树</h1><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/4776ac49e44728b55ceb5e93a56cde92.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/1*BVlXBsUgnzRmkE4EgwBb8Q.gif"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Example of a Decision Tree</figcaption></figure><p id="7bc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">决策树看起来有点像这个流程图。假设你想计划今天的活动，但是你被告知一些会影响你决定的情况。</p><p id="fdde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上图中，我们注意到影响决策的一个主要因素是<strong class="ka ir">父母拜访</strong>。所以，如果这是真的，那么很快就会做出决定，我们选择去<strong class="ka ir">电影院</strong>。如果他们不来访呢？</p><p id="d3d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这带来了一系列其他情况。现在，如果<strong class="ka ir">天气</strong>是<strong class="ka ir">晴天</strong>或<strong class="ka ir">雨天</strong>，我们要么分别去<strong class="ka ir">打网球</strong>或<strong class="ka ir">待在</strong>。但是，如果是刮风的天气，我会检查自己有多少钱。如果我有足够的钱可以花，也就是说，<strong class="ka ir">有钱，<strong class="ka ir"> </strong>我会去购物，否则我会去电影院。</strong></p><p id="9f6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">记住，树的根总是对一个价值函数有最小值的变量。在这个例子中，父母来访的概率各为 50%,如果你仔细想想，会更容易做出决定。但是如果<strong class="ka ir">天气</strong>被选为根呢？那么我们将有 33.33%的几率发生这种情况，这可能会增加我们做出错误决策的几率，因为有更多的测试用例需要考虑。</p><p id="1ab5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们过一遍<strong class="ka ir">信息增益和熵</strong>的概念，会更容易理解。</p><h1 id="ae50" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">信息增益</h1><p id="ed6c" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">如果你随着时间的推移获得了有助于你准确预测某件事是否会发生的信息，那么关于你所预测的事件的信息就不是新信息了。但是，如果情况变糟，出现了意想不到的结果，这也是有用和必要的信息。</p><p id="60e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">类似的还有信息增益的概念。</p><blockquote class="mi mj mk"><p id="beaa" class="jy jz ml ka b kb kc kd ke kf kg kh ki mm kk kl km mn ko kp kq mo ks kt ku kv ij bi translated">你对一个话题了解得越多，你就越不容易获得新的信息。更简洁地说:如果你知道一件事很有可能发生，那么当它发生时就不奇怪了，也就是说，它给你的信息很少是它确实发生了。</p></blockquote><p id="46fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从上面的陈述中，我们可以得出，获得的信息量与事件发生的概率成反比。我们也可以说，随着熵的增加，信息增益减少。这是因为熵指的是事件发生的概率。</p><p id="d7e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们正在看掷硬币。期待公平硬币任何一面的概率是 50%。如果硬币是不公平的，获得正面或反面的概率是 T2 1.00，那么我们说熵是最小的，因为不需要任何尝试，我们就可以预测硬币的结果。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/bb72df80b8947b264bc5327c73574739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*sW_qz6EVb6ZUMffxhXXyPg.png"/></div></figure><p id="2889" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下面的图表中，我们注意到，当每个事件的概率相等时，由于特定事件的最大不确定性而获得的信息量最大。这里，p=q=0.5p=q=0.5</p><p id="cddc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">E =系统事件的熵</p><p id="c2a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">p =人头作为结果的概率</p><p id="8097" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">q =作为结果的尾部概率</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/c5efd6e585c3bd8732d68d975ae73951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*0d0z_LSsk-5geMDQ3fwagg.png"/></div></figure><p id="3e0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在决策树的情况下，重要的是节点被排列成使得熵随着向下分裂而减少。这基本上意味着，越是恰当地分割，做出明确的决定就越容易。</p><p id="e46c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们针对每种分裂可能性检查每个节点。<strong class="ka ir">信息增益比</strong>是观测值与观测值总数的比值(m/N = p)和(n/N = q)其中 m+n=Nm+n=N，p+q=1p+q=1。在分裂之后，如果下一个节点的熵小于分裂之前的熵，并且如果该值与所有可能的分裂测试用例相比是最小的，则该节点被分裂成其最纯的成分。</p><p id="99ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的例子中，我们发现<strong class="ka ir">父母访问</strong>与其他选项相比，在更大程度上降低了熵。因此，我们选择了这一方案。</p><h1 id="34eb" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">修剪</h1><p id="6a9b" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">我们最初例子中的决策树非常简单，但是当数据集很大并且需要考虑更多的变量时，情况就不一样了。这就是需要<a class="ae mr" href="https://en.wikipedia.org/wiki/Pruning_(decision_trees)" rel="noopener ugc nofollow" target="_blank">修剪</a>的地方。修剪指的是在我们的决策树中删除那些我们认为对我们的决策过程没有显著贡献的分支。</p><p id="9136" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们假设我们的示例数据有一个名为<strong class="ka ir"> Vehicle </strong>的变量，当它的值为<strong class="ka ir"> Rich </strong>时，它与条件<strong class="ka ir"> Money </strong>相关或者是条件<strong class="ka ir">Money</strong>的衍生物。现在，如果<strong class="ka ir">车辆</strong>可用，我们就开车去<strong class="ka ir">购物</strong>，但是如果没有，我们就通过任何其他交通工具去购物。但最终我们还是去了 T21 购物。</p><p id="6d7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着<strong class="ka ir">车辆</strong>变量意义不大，可以在构建决策树时排除。</p><p id="f5eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">修剪</strong>的概念使我们能够避免回归或分类模型的<a class="ae mr" href="https://www.investopedia.com/terms/o/overfitting.asp" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"/></a>过度拟合，以便对于小样本数据，在生成模型时不包括测量中的误差。</p><h1 id="5e8d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">伪代码</h1><ol class=""><li id="83d1" class="ms mt iq ka b kb md kf me kj mu kn mv kr mw kv mx my mz na bi translated">检查<strong class="ka ir">为</strong>以上<strong class="ka ir">底座</strong>情况。</li><li id="03a3" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">对于每个属性 a，从 a 上的分裂中找到标准化的信息增益比<strong class="ka ir">。</strong></li><li id="62ac" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">设 a_best 是具有最高归一化信息增益的属性<strong class="ka ir">。</strong></li><li id="9ed4" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">创建一个在 a_best 上拆分的决策节点。</li><li id="c910" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">在通过对 a_best 进行拆分而获得的<strong class="ka ir">子列表上重现，<strong class="ka ir">和</strong>将这些节点<strong class="ka ir">添加为节点的</strong>子节点。</strong></li></ol><p id="4762" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">c 4.5 相对于其他决策树系统的优势:</strong></p><ol class=""><li id="a801" class="ms mt iq ka b kb kc kf kg kj ng kn nh kr ni kv mx my mz na bi translated">该算法固有地采用单遍修剪过程来减轻过拟合。</li><li id="b8ca" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">它可以处理<strong class="ka ir">离散</strong>和<strong class="ka ir">连续</strong>数据</li><li id="35c6" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">C4.5 可以很好地处理数据不完整的问题</li></ol><p id="9453" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还应该记住，C4.5 并不是最好的算法，但它在某些情况下确实证明是有用的。</p></div></div>    
</body>
</html>