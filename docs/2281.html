<html>
<head>
<title>dplyr-style Data Manipulation with Pipes in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python中的管道进行dplyr风格的数据操作</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dplyr-style-data-manipulation-with-pipes-in-python-380dcb137000?source=collection_archive---------1-----------------------#2018-01-04">https://towardsdatascience.com/dplyr-style-data-manipulation-with-pipes-in-python-380dcb137000?source=collection_archive---------1-----------------------#2018-01-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/ec0be07fbac52e6ab74d75687f944f9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ElH1TzAM8c0S2OegFB2XoQ.jpeg"/></div></div></figure><div class=""/><p id="03b9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我经常使用R的<code class="fe kw kx ky kz b">dplyr</code>包进行探索性的数据分析和数据操作。除了提供一组一致的函数来解决最常见的数据操作问题，dplyr还允许使用管道编写优雅的、可链接的数据操作代码。</p><p id="554b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，Python是我的主要语言，而<code class="fe kw kx ky kz b">pandas</code>是我用于数据分析的瑞士军刀，然而我常常希望有一个Python包，允许直接在熊猫数据帧上进行dplyr风格的数据操作。我上网搜了一下，找到了一个叫<code class="fe kw kx ky kz b">dfply</code>的包，是由<a class="ae la" href="https://github.com/kieferk" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc">基弗·卡托维奇</strong> </a>开发的。和dplyr一样，dfply也允许用管道操作符链接多个操作。</p><p id="627e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章将关注dfply包的核心函数，并展示如何使用它们来操作pandas数据帧。完整的源代码和数据集可在<a class="ae la" href="https://github.com/allenakinkunle/dplyr-style-data-manipulation-in-python" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> Github </strong> </a>上获得。</p><h2 id="781a" class="lb lc jb bd ld le lf dn lg lh li dp lj kj lk ll lm kn ln lo lp kr lq lr ls lt bi translated">入门指南</h2><p id="c720" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们需要做的第一件事是使用<code class="fe kw kx ky kz b">pip</code>安装包。</p><p id="249e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">pip install dfply</code></p><p id="071e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据该项目的Github repo，dfply只适用于Python 3，因此请确保您安装了正确版本的Python。</p><h2 id="6da6" class="lb lc jb bd ld le lf dn lg lh li dp lj kj lk ll lm kn ln lo lp kr lq lr ls lt bi translated">数据</h2><p id="0564" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">为了探索dfply的功能，我们将使用<a class="ae la" href="https://cran.r-project.org/web/packages/dplyr/vignettes/dplyr.html" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc">dplyr</strong></a>简介中使用的相同数据。数据来自于<a class="ae la" href="https://www.bts.gov/" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc"/></a>交通统计局，包含了2013年所有从纽约市出发的336776次航班的信息。</p><pre class="lz ma mb mc gt md kz me mf aw mg bi"><span id="855d" class="lb lc jb kz b gy mh mi l mj mk">from dfply import *<br/>import pandas as pd<br/><br/>flight_data = pd.read_csv('nycflights13.csv')<br/>flight_data.head()</span></pre><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ml"><img src="../Images/a30ff41331ef2052c185c87857bb106d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BwmfPK5UNf78IfaE6DZddw.png"/></div></div></figure><h2 id="c5fe" class="lb lc jb bd ld le lf dn lg lh li dp lj kj lk ll lm kn ln lo lp kr lq lr ls lt bi translated">平静的</h2><p id="f946" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">假设您想在输出最终结果之前对数据集执行<code class="fe kw kx ky kz b">n</code>离散变换操作。最常见的方法是逐步执行操作，并将每一步的结果存储在一个变量中。保存中间结果的变量将用于转换管道的下一步。让我们看一个抽象的例子。</p><pre class="lz ma mb mc gt md kz me mf aw mg bi"><span id="f5d5" class="lb lc jb kz b gy mh mi l mj mk"># 'original_data' could be a pandas DataFrame.<br/>result_1 = transformation_1(original_data, *args, **kwargs)<br/>result_2 = transformation_2(result_1, *args, **kwargs)<br/>result_3 = transformation_3(result_2, *args, **kwargs)<br/>.<br/>.<br/>.<br/>final_result = transformation_n(result_n-1, *args, **kwargs)</span></pre><p id="89f4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这不是非常优雅的代码，写起来可能会令人困惑和混乱。这就是管道救援的地方。管道允许我们重写上面的代码，而不需要那些中间变量。</p><pre class="lz ma mb mc gt md kz me mf aw mg bi"><span id="b366" class="lb lc jb kz b gy mh mi l mj mk">final_result = original_data --&gt;<br/>                transformation_1(*args, **kwargs) --&gt;<br/>                transformation_2(*args, **kwargs) --&gt;<br/>                transformation_3(*args, **kwargs) --&gt;<br/>                .<br/>                .<br/>                .<br/>                transformation_n(*args, **kwargs)</span></pre><p id="cb33" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">魔法？！不，不是的。管道的工作原理是隐式地将一个阶段的输出作为下一个阶段的输入。换句话说，每个变换步骤都处理前一个步骤的变换结果。</p><h2 id="202a" class="lb lc jb bd ld le lf dn lg lh li dp lj kj lk ll lm kn ln lo lp kr lq lr ls lt bi translated">带供给的管道</h2><p id="8262" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">dfply允许在pandas数据帧上用<code class="fe kw kx ky kz b">&gt;&gt;</code>操作符链接多个操作。可以将操作链接起来，并将最终输出(一个pandas数据帧，因为dfply直接在数据帧上工作)赋给一个变量。在dfply中，一个操作链的每一步的DataFrame结果都用<code class="fe kw kx ky kz b">X</code>来表示。<br/>例如，如果您想在一个步骤中从数据帧中选择三列，在下一个步骤中删除第三列，然后显示最终数据帧的前三行，您可以这样做:</p><pre class="lz ma mb mc gt md kz me mf aw mg bi"><span id="ba51" class="lb lc jb kz b gy mh mi l mj mk"># 'data' is the original pandas DataFrame<br/>(data &gt;&gt;<br/> select(X.first_col, X.second_col, X.third_col) &gt;&gt;<br/> drop(X.third_col) &gt;&gt;<br/> head(3))</span></pre><p id="3bd1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">select</code>和<code class="fe kw kx ky kz b">drop</code>都是dfply变换函数，而<code class="fe kw kx ky kz b">X</code>代表每个变换步骤的结果。</p><h2 id="b444" class="lb lc jb bd ld le lf dn lg lh li dp lj kj lk ll lm kn ln lo lp kr lq lr ls lt bi translated">探索dfply的一些转换方法</h2><p id="280a" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><code class="fe kw kx ky kz b">dfply</code>提供了一组用于选择和删除列、子集化和过滤行、数据分组和数据整形的函数。</p><h2 id="66e7" class="lb lc jb bd ld le lf dn lg lh li dp lj kj lk ll lm kn ln lo lp kr lq lr ls lt bi translated">用<code class="fe kw kx ky kz b">select()</code>和<code class="fe kw kx ky kz b">drop()</code>选择并放下列</h2><p id="362c" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">有时，您会处理包含许多列的数据集，但只有一部分列是感兴趣的；<code class="fe kw kx ky kz b">select()</code>允许您选择这些列。<br/>例如，要选择我们之前加载的<code class="fe kw kx ky kz b">flight_data</code>数据帧中的<code class="fe kw kx ky kz b">origin</code>、<code class="fe kw kx ky kz b">dest</code>和<code class="fe kw kx ky kz b">hour</code>列，我们需要:</p><pre class="lz ma mb mc gt md kz me mf aw mg bi"><span id="86a2" class="lb lc jb kz b gy mh mi l mj mk">(flight_data &gt;&gt;<br/> select(X.origin, X.dest, X.hour))</span></pre><figure class="lz ma mb mc gt is gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/4772d3dd8c48cd866c24778d306ba2fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:322/format:webp/1*MgnKWLa1pr7oyUTumOiYQA.png"/></div></figure><p id="0d9b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">drop()</code>是<code class="fe kw kx ky kz b">select()</code>的逆。它返回除作为参数传入的列之外的所有列。<br/>例如，获取除<code class="fe kw kx ky kz b">year</code>、<code class="fe kw kx ky kz b">month</code>和<code class="fe kw kx ky kz b">day</code>列之外的所有列:</p><pre class="lz ma mb mc gt md kz me mf aw mg bi"><span id="a4a9" class="lb lc jb kz b gy mh mi l mj mk">(flight_data &gt;&gt;  <br/>  drop(X.year, X.month, X.day))</span></pre><p id="b188" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您也可以通过在您想要删除的列前面放一个波浪号<code class="fe kw kx ky kz b">~</code>来删除<code class="fe kw kx ky kz b">select()</code>方法中的列。<br/>例如，选择<code class="fe kw kx ky kz b">flight_data</code>数据框中除<code class="fe kw kx ky kz b">hour</code>和<code class="fe kw kx ky kz b">minute</code>列之外的所有列:</p><pre class="lz ma mb mc gt md kz me mf aw mg bi"><span id="6e81" class="lb lc jb kz b gy mh mi l mj mk">(flight_data &gt;&gt; <br/>  select(~X.hour, ~X.minute))</span></pre><h2 id="d4e2" class="lb lc jb bd ld le lf dn lg lh li dp lj kj lk ll lm kn ln lo lp kr lq lr ls lt bi translated">用<code class="fe kw kx ky kz b">mask()</code>过滤行</h2><p id="0f08" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><code class="fe kw kx ky kz b">mask()</code>允许您根据逻辑标准选择pandas数据框架中行的子集。<code class="fe kw kx ky kz b">mask()</code>选择条件为真的所有行。<br/>例如，选择1月1日从JFK机场始发的所有超过10小时的航班:</p><pre class="lz ma mb mc gt md kz me mf aw mg bi"><span id="66a7" class="lb lc jb kz b gy mh mi l mj mk">(flight_data &gt;&gt;<br/>  mask(X.month == 1, X.day == 1, X.origin == 'JFK', X.hour &gt; 10))</span></pre><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mn"><img src="../Images/d0dec7ce9721d0510e528df32adca70e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WZZHuTJajDuxuHK3Cdsdrg.png"/></div></div></figure><h2 id="f20f" class="lb lc jb bd ld le lf dn lg lh li dp lj kj lk ll lm kn ln lo lp kr lq lr ls lt bi translated">使用<code class="fe kw kx ky kz b">arrange()</code>对行进行排序</h2><p id="9732" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><code class="fe kw kx ky kz b">arrange()</code>允许您根据一列或多列对行进行排序；默认行为是按升序对行进行排序。<br/>例如，先按<code class="fe kw kx ky kz b">distance</code>排序，然后按航班的数量<code class="fe kw kx ky kz b">hours</code>排序，我们这样做:</p><pre class="lz ma mb mc gt md kz me mf aw mg bi"><span id="0329" class="lb lc jb kz b gy mh mi l mj mk">(flight_data &gt;&gt;<br/>  arrange(X.distance, X.hour))</span></pre><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mo"><img src="../Images/12d6cdb6c70f216bb0c93fd511a3e53f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0zbLTkbj8AIJvFVskG85QA.png"/></div></div></figure><p id="3a02" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要按降序排序，可以将<code class="fe kw kx ky kz b">arrange()</code>的<code class="fe kw kx ky kz b">ascending</code>关键字参数设置为<code class="fe kw kx ky kz b">False</code>，如下所示:</p><pre class="lz ma mb mc gt md kz me mf aw mg bi"><span id="7298" class="lb lc jb kz b gy mh mi l mj mk">(flight_data &gt;&gt;<br/>  arrange(X.distance, X.hour, ascending=False))</span></pre><h2 id="9965" class="lb lc jb bd ld le lf dn lg lh li dp lj kj lk ll lm kn ln lo lp kr lq lr ls lt bi translated">用<code class="fe kw kx ky kz b">mutate()</code>添加新列</h2><p id="15f7" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><code class="fe kw kx ky kz b">mutate()</code>允许您在数据框中创建新列。新列可以由现有列组成。<br/>例如，让我们创建两个新列:一个是将<code class="fe kw kx ky kz b">distance</code>列除以<code class="fe kw kx ky kz b">1000</code>，另一个是连接<code class="fe kw kx ky kz b">carrier</code>和<code class="fe kw kx ky kz b">origin</code>列。我们将这些新列分别命名为<code class="fe kw kx ky kz b">new_distance</code>和<code class="fe kw kx ky kz b">carrier_origin</code>。</p><pre class="lz ma mb mc gt md kz me mf aw mg bi"><span id="7210" class="lb lc jb kz b gy mh mi l mj mk">(flight_data &gt;&gt;<br/> mutate(<br/>   new_distance = X.distance / 1000,<br/>   carrier_origin = X.carrier + X.origin<br/> ))</span></pre><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mp"><img src="../Images/e430b7fefa1b1d9b02c7828cea3eb0ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RRrtP7Ifly015iF28uWEWg.png"/></div></div></figure><p id="8639" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">新创建的列将位于数据帧的末尾。</p><h2 id="145a" class="lb lc jb bd ld le lf dn lg lh li dp lj kj lk ll lm kn ln lo lp kr lq lr ls lt bi translated">使用<code class="fe kw kx ky kz b">group_by()</code>和<code class="fe kw kx ky kz b">ungroup()</code>对数据进行分组和取消分组</h2><p id="768e" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><code class="fe kw kx ky kz b">group_by()</code>允许您按一列或多列对数据帧进行分组。在<code class="fe kw kx ky kz b">group_by()</code>之后链接的功能应用于该组，直到数据框被<code class="fe kw kx ky kz b">ungroup()</code>功能取消分组。例如，要按始发机场对数据进行分组，我们需要:</p><pre class="lz ma mb mc gt md kz me mf aw mg bi"><span id="418d" class="lb lc jb kz b gy mh mi l mj mk">(flight_data &gt;&gt;<br/> group_by(X.origin))</span></pre><h2 id="dd81" class="lb lc jb bd ld le lf dn lg lh li dp lj kj lk ll lm kn ln lo lp kr lq lr ls lt bi translated">使用<code class="fe kw kx ky kz b">summarize()</code>总结数据</h2><p id="b1dc" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><code class="fe kw kx ky kz b">summarize()</code>通常与<code class="fe kw kx ky kz b">group_by()</code>一起使用，将每个组缩减为单行摘要。换句话说，每个组在输出中都有一行。例如，要计算从每个机场始发的航班的平均距离，我们需要:</p><pre class="lz ma mb mc gt md kz me mf aw mg bi"><span id="e25b" class="lb lc jb kz b gy mh mi l mj mk">(flight_data &gt;&gt;<br/>  group_by(X.origin) &gt;&gt;<br/>  summarize(mean_distance = X.distance.mean())<br/>)</span></pre><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mq"><img src="../Images/511e7bc88535bd705815802d43c9e38d.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*G9KGiF3_bO_LvIK8dcKkbA.png"/></div></div></figure><h1 id="2fdf" class="mr lc jb bd ld ms mt mu lg mv mw mx lj my mz na lm nb nc nd lp ne nf ng ls nh bi translated">用管道把它们聚集在一起</h1><p id="a241" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">假设您想要对航班数据执行以下操作</p><ul class=""><li id="fbb5" class="ni nj jb ka b kb kc kf kg kj nk kn nl kr nm kv nn no np nq bi translated">[第一步]:过滤掉所有不到10小时的航班</li><li id="3163" class="ni nj jb ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated">[步骤2]:使用公式[距离/(飞行时间* 60)]创建一个新列T25</li><li id="60b3" class="ni nj jb ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated">[步骤3]:计算从每个机场始发的航班的平均速度</li><li id="8906" class="ni nj jb ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated">[步骤4]:按平均速度降序排列结果</li></ul><p id="cd7f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用<code class="fe kw kx ky kz b">dfply</code>管道操作员<code class="fe kw kx ky kz b">&gt;&gt;</code>编写操作。我们不必使用中间变量来保存每一步的结果。</p><pre class="lz ma mb mc gt md kz me mf aw mg bi"><span id="ea8d" class="lb lc jb kz b gy mh mi l mj mk">(flight_data &gt;&gt;<br/>  mask(X.hour &gt; 10) &gt;&gt; # step 1<br/>  mutate(speed = X.distance / (X.air_time * 60)) &gt;&gt; # step 2<br/>  group_by(X.origin) &gt;&gt; # step 3a<br/>  summarize(mean_speed = X.speed.mean()) &gt;&gt; # step 3b<br/>  arrange(X.mean_speed, ascending=False) # step 4<br/>)</span></pre><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nw"><img src="../Images/0a4b84c8da7f4e81c081ade5394d3b7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/format:webp/1*GHlf98bwbcTuwpcbeMBY8Q.png"/></div></div></figure><p id="2310" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们使用<code class="fe kw kx ky kz b">pandas</code>数据操作函数，而不是<code class="fe kw kx ky kz b">dfply</code>的，我们的代码看起来会像这样:</p><pre class="lz ma mb mc gt md kz me mf aw mg bi"><span id="f376" class="lb lc jb kz b gy mh mi l mj mk">flight_data.loc[flight_data['hour'] &gt; 10, 'speed'] = flight_data['distance'] / (flight_data['air_time'] * 60)<br/>result = flight_data.groupby('origin', as_index=False)['speed'].mean()<br/>result.sort_values('speed', ascending=False)</span></pre><p id="3eb5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我发现<code class="fe kw kx ky kz b">dfply</code>版本比<code class="fe kw kx ky kz b">pandas</code>版本更容易阅读和理解。</p><h1 id="9a1f" class="mr lc jb bd ld ms mt mu lg mv mw mx lj my mz na lm nb nc nd lp ne nf ng ls nh bi translated">结论</h1><p id="06c7" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这绝不是对<code class="fe kw kx ky kz b">dfply</code>包功能的详尽介绍。<a class="ae la" href="https://github.com/kieferk/dfply" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc">包文档</strong> </a>真的很好，我建议你去看看了解更多。</p><p id="cf64" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你有建议或问题，请在下面的评论区留言。也可以发邮件到hello [at] allenkunle [dot] me或者tweet at me<a class="ae la" href="https://twitter.com/allenakinkunle" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc">@ allenakinkulle</strong></a>我会尽快回复。</p><p id="3b39" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇博文的完整源代码可以在<a class="ae la" href="https://github.com/allenakinkunle/dplyr-style-data-manipulation-in-python" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> Github </strong> </a>上找到。感谢您的阅读，请不要忘记分享。</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="6e9d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="oe">本帖原载于2018年1月3日</em> <a class="ae la" href="http://allenkunle.me/dplyr-style-data-manipulation-in-python" rel="noopener ugc nofollow" target="_blank"> <em class="oe">艾伦·阿肯昆勒的个人博客</em> </a> <em class="oe">。</em></p></div></div>    
</body>
</html>