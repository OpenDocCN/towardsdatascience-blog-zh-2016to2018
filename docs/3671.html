<html>
<head>
<title>Python Sets and Set Theory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 集和集合论</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-sets-and-set-theory-2ace093d1607?source=collection_archive---------5-----------------------#2018-06-06">https://towardsdatascience.com/python-sets-and-set-theory-2ace093d1607?source=collection_archive---------5-----------------------#2018-06-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8830" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解 Python 集合:它们是什么，如何创建它们，何时使用它们，内置函数，以及它们与集合论运算的关系。</h2></div><h1 id="46de" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">集合与列表和元组</h1><p id="402d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">列表和元组是在序列中存储值的标准 Python 数据类型。集合是另一种也存储值的标准 Python 数据类型。主要区别在于，与列表或元组不同，集合不能多次出现相同的元素，也不能存储无序值。</p><h1 id="f116" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">Python 集合的优势</h1><p id="fd13" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因为集合不能多次出现相同的元素，所以集合对于有效地从列表或元组中删除重复值以及执行像联合和交集这样的常见数学运算非常有用。</p><p id="a5a6" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">本教程将向您介绍几个关于 Python 集合和集合论的主题:</p><ul class=""><li id="6cf4" class="ly lz iq kz b la lt ld lu lg ma lk mb lo mc ls md me mf mg bi translated">如何初始化空集和有值集？</li><li id="e07d" class="ly lz iq kz b la mh ld mi lg mj lk mk lo ml ls md me mf mg bi translated">如何在集合中添加和删除值</li><li id="45f3" class="ly lz iq kz b la mh ld mi lg mj lk mk lo ml ls md me mf mg bi translated">如何有效地将集合用于成员资格测试和从列表中删除重复值等任务。</li><li id="49cf" class="ly lz iq kz b la mh ld mi lg mj lk mk lo ml ls md me mf mg bi translated">如何执行常见的集合运算，如并集、交集、差集和对称差集。</li><li id="6177" class="ly lz iq kz b la mh ld mi lg mj lk mk lo ml ls md me mf mg bi translated">集合和冷冻集合的区别</li></ul><p id="4125" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">就这样，让我们开始吧。</p><h1 id="1e2f" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">初始化集合</h1><p id="68e9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">集合是不同的(唯一的)不可变值的可变集合，这些值是无序的。</p><p id="50fd" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">您可以使用<code class="fe mm mn mo mp b">set()</code>初始化空集。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="27f0" class="my kg iq mp b gy mz na l nb nc">emptySet = set()</span></pre><p id="b0c9" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">要用值初始化一个集合，您可以向<code class="fe mm mn mo mp b">set()</code>传递一个列表。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="c824" class="my kg iq mp b gy mz na l nb nc">dataScientist = set(['Python', 'R', 'SQL', 'Git', 'Tableau', 'SAS']) dataEngineer = set(['Python', 'Java', 'Scala', 'Git', 'SQL', 'Hadoop'])</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nd"><img src="../Images/59270156a2dc38ced12f2ad71cc222a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pzusPodyCKiz8F6d.png"/></div></div></figure><p id="466c" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果您查看上面的 dataScientist 和 dataEngineer 变量的输出，请注意集合中的值没有按照中添加的顺序排列。这是因为集合是无序的。</p><p id="cd42" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir">包含值</strong>的集合也可以用花括号初始化。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="162e" class="my kg iq mp b gy mz na l nb nc">dataScientist = {'Python', 'R', 'SQL', 'Git', 'Tableau', 'SAS'} dataEngineer = {'Python', 'Java', 'Scala', 'Git', 'SQL', 'Hadoop'}</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nl"><img src="../Images/19573cf5134bdbb8e5ee1bcb82b35818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IR2YWM_kW-8ehtkk.png"/></div></div></figure><p id="74e0" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">请记住，花括号只能用于初始化包含值的集合。下图显示了使用不带值的花括号是初始化字典而不是集合的方法之一。</p><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nm"><img src="../Images/be3f7dc8ce4de45c602b17db6f72b843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GIiMf9fgCRsea8bE.png"/></div></div></figure><h1 id="57aa" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">添加和删除集合中的值</h1><p id="7d4c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">要在集合中添加或删除值，首先必须初始化集合。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="394f" class="my kg iq mp b gy mz na l nb nc"># Initialize set with values <br/>graphicDesigner = {'InDesign', 'Photoshop', 'Acrobat', 'Premiere', 'Bridge'}</span></pre><h2 id="01e3" class="my kg iq bd kh nn no dn kl np nq dp kp lg nr ns kr lk nt nu kt lo nv nw kv nx bi translated">向集合中添加值</h2><p id="0485" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您可以使用<code class="fe mm mn mo mp b">add</code>方法向集合中添加一个值。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="ccca" class="my kg iq mp b gy mz na l nb nc">graphicDesigner.add('Illustrator')</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ny"><img src="../Images/6305d4eed367b23e297a3a8b7821bd0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JdQgHSh0ZfUoEZ3H.png"/></div></div></figure><p id="bc4e" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">需要注意的是，您只能向集合中添加不可变的值(如字符串或元组)。例如，如果您试图向集合中添加列表，将会得到一个 TypeError。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="5127" class="my kg iq mp b gy mz na l nb nc">graphicDesigner.add(['Powerpoint', 'Blender'])</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nz"><img src="../Images/0d51fcadec515aae134cb6d32752ccdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5EjInYUBZsrnUidg.png"/></div></div></figure><p id="46a0" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">有几种方法可以从集合中删除一个值。</p><p id="08f1" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir">选项 1: </strong>您可以使用<code class="fe mm mn mo mp b">remove</code>方法从集合中删除一个值。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="6bee" class="my kg iq mp b gy mz na l nb nc">graphicDesigner.remove('Illustrator')</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi oa"><img src="../Images/f9f0355f4593cc3d83a4c823682825a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kMTZ6fohfoC2mr2I.png"/></div></div></figure><p id="f881" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这种方法的缺点是，如果您试图删除一个不在您的集合中的值，您将得到一个 KeyError。</p><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ob"><img src="../Images/ce587a907ddde7cc2f062ac2a8cdc8b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5QPk0iY7s5thAHjc.png"/></div></div></figure><p id="c81e" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir">选项 2: </strong>您可以使用<code class="fe mm mn mo mp b">discard</code>方法从集合中移除一个值。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="0a44" class="my kg iq mp b gy mz na l nb nc">graphicDesigner.discard('Premiere')</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi oc"><img src="../Images/736d7a515a68cdc8f81d6c04d9d7236b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cXitKx0PlfFKMynY.png"/></div></div></figure><p id="c034" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这种方法相对于<code class="fe mm mn mo mp b">remove</code>方法的好处是，如果您试图删除一个不属于集合的值，您将不会得到一个 KeyError。如果您熟悉字典，您可能会发现这与<a class="ae od" href="https://hackernoon.com/python-basics-10-dictionaries-and-dictionary-methods-4e9efa70f5b9" rel="noopener ugc nofollow" target="_blank">字典方法 get </a>的工作方式类似。</p><p id="a7a8" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir">选项 3: </strong>您还可以使用<code class="fe mm mn mo mp b">pop</code>方法来<strong class="kz ir">移除和返回</strong>集合中的任意值。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="1e6e" class="my kg iq mp b gy mz na l nb nc">graphicDesigner.pop()</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi oe"><img src="../Images/fbaf7d9cffc6d507b52d45457d050181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wDCMZH80DirMij1I.png"/></div></div></figure><p id="8c61" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">需要注意的是，如果集合为空，该方法会引发一个 KeyError。</p><h1 id="72e3" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">从集合中删除所有值</h1><p id="64ce" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您可以使用<code class="fe mm mn mo mp b">clear</code>方法从集合中移除所有值。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="3751" class="my kg iq mp b gy mz na l nb nc">graphicDesigner.clear()</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div class="gh gi of"><img src="../Images/26ebaa0075036290506ec3f074ebd55f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/0*EShMwDOCWaSiiAWU.png"/></div></figure><h1 id="1abf" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">遍历一个集合</h1><p id="9f33" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">像许多标准 python 数据类型一样，可以遍历一个集合。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="6a06" class="my kg iq mp b gy mz na l nb nc"># Initialize a set <br/>dataScientist = {'Python', 'R', 'SQL', 'Git', 'Tableau', 'SAS'} </span><span id="783d" class="my kg iq mp b gy og na l nb nc">for skill in dataScientist: <br/>   print(skill)</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/005e57569f84acdce9f1ee2f33802dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/0*DYOzwStGCq7Kankw.png"/></div></figure><p id="9664" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果您查看在 dataScientist 中打印每个值的输出，请注意，在集合中打印的值没有按照它们被添加的顺序。这是因为集合是无序的。</p><h1 id="7383" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">将集合转换为有序值</h1><p id="7f78" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">本教程强调了集合是无序的。如果您发现您需要以有序的形式从集合中获取值，那么您可以使用<code class="fe mm mn mo mp b">sorted</code>函数，它输出一个有序的列表。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="a16d" class="my kg iq mp b gy mz na l nb nc">type(sorted(dataScientist))</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/5735d1fde77e4de3c7eb2f19f3624298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*ke2eOTx4beRXrdoL.png"/></div></figure><p id="e70e" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">下面的代码按字母降序输出数据集 dataScientist 中的值(本例中为 Z-A)。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="ced8" class="my kg iq mp b gy mz na l nb nc">sorted(dataScientist, reverse = True)</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi oj"><img src="../Images/7a1f536605c44437c7fecb8e9e7f224f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/0*_D0DDUnzKb8ZPeBJ.png"/></div></div></figure><h1 id="9387" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">从列表中删除重复项</h1><p id="911e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">本节的部分内容之前已经在教程<a class="ae od" href="https://www.datacamp.com/community/tutorials/18-most-common-python-list-questions-learn-python#question15" rel="noopener ugc nofollow" target="_blank"> 18 个最常见的 Python 列表问题</a>中探讨过，但是需要强调的是，集合是从列表中删除重复项的最快方式<a class="ae od" href="https://www.peterbe.com/plog/fastest-way-to-uniquify-a-list-in-python-3.6" rel="noopener ugc nofollow" target="_blank">。为了说明这一点，让我们研究两种方法之间的性能差异。</a></p><p id="f119" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir">方法 1: </strong>使用集合从列表中删除重复项。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="339c" class="my kg iq mp b gy mz na l nb nc">print(list(set([1, 2, 3, 1, 7])))</span></pre><p id="6970" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir">方法 2: </strong>使用列表理解来删除列表中的重复项(如果你想复习列表理解，请参见本<a class="ae od" href="https://www.datacamp.com/community/tutorials/python-list-comprehension" rel="noopener ugc nofollow" target="_blank">教程</a>)。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="2d6e" class="my kg iq mp b gy mz na l nb nc">def remove_duplicates(original):<br/>    unique = []<br/>    [unique.append(n) for n in original if n not in unique]<br/>    return(unique)</span><span id="9c07" class="my kg iq mp b gy og na l nb nc">print(remove_duplicates([1, 2, 3, 1, 7]))</span></pre><p id="ec4a" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">可以使用<code class="fe mm mn mo mp b">timeit</code>库来测量性能差异，该库允许您对 Python 代码计时。下面的代码为每种方法运行代码 10000 次，并以秒为单位输出总时间。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="702c" class="my kg iq mp b gy mz na l nb nc">import timeit</span><span id="2433" class="my kg iq mp b gy og na l nb nc"># Approach 1: Execution time <br/>print(timeit.timeit('list(set([1, 2, 3, 1, 7]))', number=10000))</span><span id="e54a" class="my kg iq mp b gy og na l nb nc"># Approach 2: Execution time<br/>print(timeit.timeit('remove_duplicates([1, 2, 3, 1, 7])', globals=globals(), number=10000))</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ok"><img src="../Images/bd6f1dd6053aa2550d517fe488cf5384.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6vjFfF86Slov15J5.png"/></div></div></figure><p id="e3dd" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">比较这两种方法表明，使用集合来删除重复项更有效。虽然这看起来像是时间上的一个小差异，但是如果你有非常大的列表，它可以节省你很多时间。</p><h1 id="08b0" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">设置操作方法</h1><p id="3a32" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Python 中集合的一个常见用途是计算标准数学运算，如并、交、差和对称差。下图显示了两个集合 A 和 b 上的几个标准数学运算。每个维恩图的红色部分是给定集合运算的结果集合。</p><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ol"><img src="../Images/9ea8c2e3f7b79acd7b74efb776a161eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*a02OPI3-TnbKXyub.png"/></div></div></figure><p id="2942" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">Python 集合提供了允许您执行这些数学运算的方法，以及提供等效结果的运算符。</p><p id="2f81" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">在探索这些方法之前，让我们从初始化两组数据科学家和数据工程师开始。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="7e02" class="my kg iq mp b gy mz na l nb nc">dataScientist = set(['Python', 'R', 'SQL', 'Git', 'Tableau', 'SAS'])<br/>dataEngineer = set(['Python', 'Java', 'Scala', 'Git', 'SQL', 'Hadoop'])</span></pre><h1 id="7d39" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">联盟</h1><p id="eaa1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">表示为 dataScientist ∪ dataEngineer 的并集是 dataScientist 和/或 dataEngineer 的所有值的集合。您可以使用<code class="fe mm mn mo mp b">union</code>方法找出两个集合中的所有唯一值。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="2e9f" class="my kg iq mp b gy mz na l nb nc"># set built-in function union<br/>dataScientist.union(dataEngineer)</span><span id="026e" class="my kg iq mp b gy og na l nb nc"># Equivalent Result <br/>dataScientist | dataEngineer</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi om"><img src="../Images/b7cdbd41e90dc2ddf3e4e127d5f25dab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yB4XsEojDiifBTSx.png"/></div></div></figure><p id="02c3" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">从并集返回的集合可以被可视化为下面维恩图的红色部分。</p><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi on"><img src="../Images/8a1ed41c5d9a8ea00ead4a73f68dbe10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zyiepqoHsfy9aQyS.png"/></div></div></figure><h1 id="41cb" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">交集</h1><p id="4bea" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">两个集合 dataScientist 和 dataEngineer 的交集表示为 dataScientist ∩ dataEngineer，它是 dataScientist 和 dataEngineer 的所有值的集合。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="f04f" class="my kg iq mp b gy mz na l nb nc"># Intersection operation<br/>dataScientist.intersection(dataEngineer)</span><span id="c094" class="my kg iq mp b gy og na l nb nc"># Equivalent Result<br/>dataScientist &amp; dataEngineer</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi oo"><img src="../Images/cb0d8795bfac2d79ad5eb7e7ffc106c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uCyawYeIrEZqY7jb.png"/></div></div></figure><p id="5352" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">从交集返回的集合可以被可视化为下面维恩图的红色部分。</p><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi op"><img src="../Images/887d9e2355ab268e1ef818027d0d788b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*R0EhGyRTwunQshmC.png"/></div></div></figure><p id="0f93" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">您可能会发现，在这种情况下，您希望确保两个集合没有公共值。换句话说，你希望两个集合的交集是空的。这两个集合称为不相交集合。您可以通过使用<code class="fe mm mn mo mp b">isdisjoint</code>方法来测试不相交的集合。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="d0fd" class="my kg iq mp b gy mz na l nb nc"># Initialize a set<br/>graphicDesigner = {'Illustrator', 'InDesign', 'Photoshop'}</span><span id="5056" class="my kg iq mp b gy og na l nb nc"># These sets have elements in common so it would return False<br/>dataScientist.isdisjoint(dataEngineer)</span><span id="be20" class="my kg iq mp b gy og na l nb nc"># These sets have no elements in common so it would return True<br/>dataScientist.isdisjoint(graphicDesigner)</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi oq"><img src="../Images/5db71538347ac56eb4bd9688d404c12a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5hZSX7L2Fo_Bi0vq.png"/></div></div></figure><p id="4ca4" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">您可以注意到，在下面维恩图所示的交集中，不相交集 dataScientist 和 graphicDesigner 没有共同的值。</p><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi op"><img src="../Images/99104c89125648d77468e5bde1c6f1d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NhQ9GXc9b2z-IBfk.png"/></div></div></figure><h1 id="4e1d" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">差异</h1><p id="4e46" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">两个集合 dataScientist 和 dataEngineer 的差，表示为 dataScientist \ dataEngineer，是 dataScientist 的所有值的集合，这些值不是 dataEngineer 的值。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="a5e8" class="my kg iq mp b gy mz na l nb nc"># Difference Operation<br/>dataScientist.difference(dataEngineer)</span><span id="3b71" class="my kg iq mp b gy og na l nb nc"># Equivalent Result<br/>dataScientist - dataEngineer</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi or"><img src="../Images/d2d3473b670e0aab1695c629464f3d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FZfnjcReD1fAw8HG.png"/></div></div></figure><p id="ca89" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">从差异返回的集合可以被可视化为下面维恩图的红色部分。</p><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi on"><img src="../Images/458863dd26e6d42e000b2ba35dcec4fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DAzUYmb11nqxufNu.png"/></div></div></figure><h1 id="4fe1" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">对称 _ 差异</h1><p id="80d3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">两个数据集 dataScientist 和 dataEngineer 的对称差表示为 dataScientist △ dataEngineer，它是恰好是两个集合中一个集合的值而不是两个集合的值的集合。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="b276" class="my kg iq mp b gy mz na l nb nc"># Symmetric Difference Operation<br/>dataScientist.symmetric_difference(dataEngineer)</span><span id="95b3" class="my kg iq mp b gy og na l nb nc"># Equivalent Result<br/>dataScientist ^ dataEngineer</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi os"><img src="../Images/e8e88f25cb6f392985a61ed835acb892.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qds2Q4TeFu0_8SUK.png"/></div></div></figure><p id="8c34" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">从对称差返回的集合可以被可视化为下面维恩图的红色部分。</p><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ot"><img src="../Images/fca74c88005021a56008d09bb81e72a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*q5BAmYxXbb7YTSxK.png"/></div></div></figure><h1 id="b2ef" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">集合理解</h1><p id="3ae8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您可能之前已经了解了<a class="ae od" href="https://www.datacamp.com/community/tutorials/python-list-comprehension#plc" rel="noopener ugc nofollow" target="_blank">列表理解</a>、<a class="ae od" href="https://www.datacamp.com/community/tutorials/python-dictionary-comprehension" rel="noopener ugc nofollow" target="_blank">字典理解</a>和生成器理解。还有一套理解。集合理解非常相似。Python 中的集合理解可以按如下方式构造:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="721a" class="my kg iq mp b gy mz na l nb nc">{skill for skill in ['SQL', 'SQL', 'PYTHON', 'PYTHON']}</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ou"><img src="../Images/36847c64cdb9486af29bbc1cd3b19e67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*d1yA_BEF_xyby3do.png"/></div></div></figure><p id="e4e8" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">上面的输出是两个值的集合，因为集合不能有相同元素的多次出现。</p><p id="2d23" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">使用集合理解背后的想法是让你用代码写和推理，就像你用手做数学一样。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="0c96" class="my kg iq mp b gy mz na l nb nc">{skill for skill in ['GIT', 'PYTHON', 'SQL'] if skill not in {'GIT', 'PYTHON', 'JAVA'}}</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ov"><img src="../Images/a593d108095261ccb925661f2b428733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tFLf9EqaxNeS36oh.png"/></div></div></figure><p id="f253" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">上面的代码类似于您之前了解到的集合差异。只是看起来有点不一样。</p><h1 id="33bd" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">会员测试</h1><p id="f985" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">成员资格测试检查特定元素是否包含在序列中，例如字符串、列表、元组或集合。在 Python 中使用集合的一个主要优点是它们为成员测试进行了高度优化。例如，集合比列表更有效地进行成员资格测试。如果你有计算机科学背景，这是因为对于列表，集合中成员测试的平均用例时间复杂度是 O(1)比 O(n)。</p><p id="f2a4" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">下面的代码显示了一个使用列表的成员测试。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="e9fc" class="my kg iq mp b gy mz na l nb nc"># Initialize a list<br/>possibleList = ['Python', 'R', 'SQL', 'Git', 'Tableau', 'SAS', 'Java', 'Spark', 'Scala']</span><span id="3585" class="my kg iq mp b gy og na l nb nc"># Membership test<br/>'Python' in possibleList</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ow"><img src="../Images/19dcbb8d9c9ce52738ec234874b942c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vBkTxffb72h7kSji.png"/></div></div></figure><p id="a667" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">对于器械包也可以做类似的事情。集合只是碰巧更有效率。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="6244" class="my kg iq mp b gy mz na l nb nc"># Initialize a set<br/>possibleSet = {'Python', 'R', 'SQL', 'Git', 'Tableau', 'SAS', 'Java', 'Spark', 'Scala'}</span><span id="fab5" class="my kg iq mp b gy og na l nb nc"># Membership test<br/>'Python' in possibleSet</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ox"><img src="../Images/c8957c87b1e84e1e830c5a347df2b773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-kK38Fb1o58uyffv.png"/></div></div></figure><p id="8bf7" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">由于<code class="fe mm mn mo mp b">possibleSet</code>是一个集合，值<code class="fe mm mn mo mp b">'Python'</code>是<code class="fe mm mn mo mp b">possibleSet</code>的值，这可以表示为<code class="fe mm mn mo mp b">'Python'</code> ∈ <code class="fe mm mn mo mp b">possibleSet</code>。</p><p id="5d42" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果你有一个不属于集合的值，比如<code class="fe mm mn mo mp b">'Fortran'</code>，它将被表示为<code class="fe mm mn mo mp b">'Fortran'</code> ∉ <code class="fe mm mn mo mp b">possibleSet</code>。</p><h2 id="8a8e" class="my kg iq bd kh nn no dn kl np nq dp kp lg nr ns kr lk nt nu kt lo nv nw kv nx bi translated">子集</h2><p id="ec56" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">理解成员关系的一个实际应用是子集。</p><p id="3a14" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们先初始化两组。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="1c4a" class="my kg iq mp b gy mz na l nb nc">possibleSkills = {'Python', 'R', 'SQL', 'Git', 'Tableau', 'SAS'} mySkills = {'Python', 'R'}</span></pre><p id="7215" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果集合<code class="fe mm mn mo mp b">mySkills</code>的每个值也是集合<code class="fe mm mn mo mp b">possibleSkills</code>的值，那么<code class="fe mm mn mo mp b">mySkills</code>被称为<code class="fe mm mn mo mp b">possibleSkills</code>的子集，数学上写成<code class="fe mm mn mo mp b">mySkills</code> ⊆ <code class="fe mm mn mo mp b">possibleSkills</code>。</p><p id="aa62" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">您可以使用<code class="fe mm mn mo mp b">issubset</code>方法查看一个集合是否是另一个集合的子集。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="a48f" class="my kg iq mp b gy mz na l nb nc">mySkills.issubset(possibleSkills)</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/2c1f2489a63f48c506d9b294dc274101.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/0*CJQbED14XkArs9RC.png"/></div></figure><p id="c1e0" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">因为该方法在这种情况下返回 True，所以它是一个子集。在下面的维恩图中，注意集合<code class="fe mm mn mo mp b">mySkills</code>的每个值也是集合<code class="fe mm mn mo mp b">possibleSkills</code>的值。</p><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi oz"><img src="../Images/d50aae767ecfab8c0fa29dd0772dc862.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vFmM-Hr2TkYtbIn2.png"/></div></div></figure><h1 id="4203" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">冰冻集</h1><p id="0fd5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您遇到了嵌套列表和元组。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="81ff" class="my kg iq mp b gy mz na l nb nc"># Nested Lists and Tuples<br/>nestedLists = [['the', 12], ['to', 11], ['of', 9], ['and', 7], ['that', 6]]<br/>nestedTuples = (('the', 12), ('to', 11), ('of', 9), ('and', 7), ('that', 6))</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi pa"><img src="../Images/8e2317bfedcff7b17d50aeaea4bce917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sVsn7uFO7vasz1aW.png"/></div></div></figure><p id="1aef" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">嵌套集合的问题是你通常不能有嵌套集合，因为集合不能包含可变值。</p><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ox"><img src="../Images/66b10369aec8a2d6c121ac6c6d73da0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XMeHXuL61i7IAzFB.png"/></div></div></figure><p id="cfe5" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">在这种情况下，您可能希望使用冷冻箱。除了 frozenset 是不可变的之外，frozenset 与集合非常相似。</p><p id="7f46" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">你可以用<code class="fe mm mn mo mp b">frozenset()</code>制作一个冰冻人。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="0d34" class="my kg iq mp b gy mz na l nb nc"># Initialize a frozenset<br/>immutableSet = frozenset()</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/0ff80d340db1605b0ace5e85317e74d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/0*yig4GWlvlLNCNfWK.png"/></div></figure><p id="9b5e" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果您使用类似下面代码的 frozenset，您可以创建一个嵌套集。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="dba7" class="my kg iq mp b gy mz na l nb nc">nestedSets = set([frozenset()])</span></pre><figure class="mq mr ms mt gt ne gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/4632c4da957fb8bdeafdade8e13915f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/0*QdU6Jtsl3u7lB6ce.png"/></div></figure><p id="e428" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">重要的是要记住，frozenset 的一个主要缺点是，由于它们是不可变的，这意味着您不能添加或删除值。</p><h1 id="af33" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">结论</h1><p id="39a5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Python 集合对于从列表等集合中有效移除重复值以及执行联合和交集等常见数学运算非常有用。人们经常遇到的一些挑战是何时使用各种数据类型。例如，如果你觉得不确定什么时候使用字典比使用字典更有利，我鼓励你去看看 DataCamp 的<a class="ae od" href="https://www.datacamp.com/community/blog/introducing-daily-practice-mode" rel="noopener ugc nofollow" target="_blank">日常练习模式</a>。如果您对本教程有任何问题或想法，请在下面的评论中或通过<a class="ae od" href="https://twitter.com/GalarnykMichael" rel="noopener ugc nofollow" target="_blank"> Twitter </a>联系我们。</p></div><div class="ab cl pd pe hu pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="ij ik il im in"><p id="4bc9" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><em class="pk">最初发表于</em><a class="ae od" href="https://www.datacamp.com/community/tutorials/sets-in-python" rel="noopener ugc nofollow" target="_blank"><em class="pk">www.datacamp.com</em></a><em class="pk">。</em></p></div></div>    
</body>
</html>