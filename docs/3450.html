<html>
<head>
<title>Javascript data structure with map, reduce, filter, and ES6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有 map、reduce、filter 和 ES6 的 Javascript 数据结构</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/write-beautiful-javascript-with-%CE%BB-fp-es6-350cd64ab5bf?source=collection_archive---------1-----------------------#2018-05-13">https://towardsdatascience.com/write-beautiful-javascript-with-%CE%BB-fp-es6-350cd64ab5bf?source=collection_archive---------1-----------------------#2018-05-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8215" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如果你是一个 javascript 爱好者，并且每天都在使用它，那么你会爱上它的😃</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/15a9995f605f7e96711dc09f2331e9a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qdrI5piyUFTj0sG77YbDMg.jpeg"/></div></div></figure><p id="0999" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Javascript 是一种允许以任何风格编写代码的语言，从命令式到声明式。大多数程序员使用命令式，要么是因为他们来自 OOPs 背景，也许他们热爱它，要么是因为他们不熟悉其他风格。在我们深入到函数式编程(FP)的声明式风格之前，让我们通过看一个例子来理解两者之间的区别(如果你已经知道区别，那么你可以跳过几段)</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="cf12" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">必要的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="e081" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">命令式风格很酷，但是想象一下，如果这里有一个复杂的数学逻辑，那么代码的大小和可读性将会很差。它增加了阅读时的认知负荷，随着时间的推移，在推理和逻辑上更容易动摇。</p><p id="8abf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，这段代码片段的主要复杂性源于这样一个事实，即我们不是告诉计算机<em class="ms">我们想要</em>它做什么，而是指示它<em class="ms">如何做</em>。</p><h2 id="0ba2" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">宣言的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="0b99" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，这看起来非常干净、简短、有表现力、简洁的代码，不容易出错，更容易维护，也更容易调试。我们是在告诉计算机<em class="ms">我们想要</em>它做什么，而不是<em class="ms">如何去做。</em></p><p id="ef3d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">声明式方法在编译器端很容易优化，副作用也较少。</p><blockquote class="mt mu mv"><p id="819c" class="ku kv ms kw b kx ky ju kz la lb jx lc mw le lf lg mx li lj lk my lm ln lo lp im bi translated">注意:如果你关心上面两个和其他 javascript 函数(map、reduce、filter、find)的性能，那么你应该在这里阅读<a class="ae mz" href="https://medium.com/@ideepak.jsd/javascript-performance-test-for-vs-for-each-vs-map-reduce-filter-find-32c1113f19d7" rel="noopener">获取小数据集，可以在这里查看</a><a class="ae mz" href="https://github.com/dg92/Performance-Analysis-JS" rel="noopener ugc nofollow" target="_blank">获取大数据集(100–1000000)</a></p></blockquote></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="3191" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们从 FP 最常用的 Javascript 函数— <code class="fe na nb nc nd b">.map()</code>开始真正的操作。</p><h2 id="d840" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">地图</h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="ff0c" class="lx ly it nd b gy ni nj l nk nl">// definition <br/>collection.map((currentValue, index) =&gt; {<br/>    // Return element for newArray<br/>});<br/>// example<br/>const arr = [1,2,3,4,5];<br/>const newArray = arr.map(i =&gt; i*10);<br/>// return a new array with all value as multiple of 10;</span></pre><p id="b1ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">map 作用于一个数组并返回一个数组</strong>。上面的代码片段作用于一个集合，即一个数组，接受一个带有当前迭代值的回调，索引作为参数，并返回一个新的数组。</p><blockquote class="mt mu mv"><p id="1fad" class="ku kv ms kw b kx ky ju kz la lb jx lc mw le lf lg mx li lj lk my lm ln lo lp im bi translated">注意:Map 非常适合改变/转换整个数组，而不是在某些情况下中断流程，Map suck 的性能明智，请查看此处的<a class="ae mz" href="https://github.com/dg92/Performance-Analysis-JS" rel="noopener ugc nofollow" target="_blank"/>但易于用于小数据集。</p></blockquote><h2 id="a435" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">减少</h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="9969" class="lx ly it nd b gy ni nj l nk nl">// definition <br/>collection.reduce((accumulator, item, index) =&gt; {<br/>    // logic to perform to get accumulator as a return value<br/>}, initialValue for accumulator);</span><span id="6cff" class="lx ly it nd b gy nm nj l nk nl">// example<br/>const arr = [1,2,3,4,5];<br/>const total = arr.reduce((acc, item) =&gt; acc+= item, 0);<br/>// return a total as 15</span></pre><p id="5fdb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> Reduce 在一个数组上工作，但是可以返回任何你想让它返回的东西</strong>。顾名思义，它可以简化为任何形式，可以表现为<code class="fe na nb nc nd b">map</code>、<code class="fe na nb nc nd b">find</code>、<code class="fe na nb nc nd b">filter</code>或任何其他 JavaScript 数组函数。上面的代码片段作用于一个数组，并简化为计算数组中项目的总值。</p><p id="69aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">解释上面的例子，在第一次运行 reduces 时，<code class="fe na nb nc nd b">acc</code>被赋值为 0，然后<code class="fe na nb nc nd b">acc+= item</code>即<code class="fe na nb nc nd b">acc = acc+item</code>将计算出为 1 的<code class="fe na nb nc nd b">0+1</code>。这个 1 将是下一次迭代的<code class="fe na nb nc nd b">acc</code>值，这将一直持续到我们完成所有的数组项。</p><h2 id="14d5" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">发现</h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="374e" class="lx ly it nd b gy ni nj l nk nl">// definition <br/>collection.find((item) =&gt; {<br/>    // return first element that satisfy the condition<br/>});</span><span id="d888" class="lx ly it nd b gy nm nj l nk nl">// example<br/>const arr = [1,2,8,4,5];<br/>const value = arr.find(i =&gt; i%4 == 0);<br/>// return the first value i.e 8 </span></pre><p id="3429" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> Find 作用于数组，返回函数中满足条件的第一个元素。</strong></p><blockquote class="mt mu mv"><p id="3723" class="ku kv ms kw b kx ky ju kz la lb jx lc mw le lf lg mx li lj lk my lm ln lo lp im bi translated">注意:容易，简单但在大数据集上效率不高，为什么？看这里<a class="ae mz" href="https://github.com/dg92/Performance-Analysis-JS" rel="noopener ugc nofollow" target="_blank">这里</a></p></blockquote><h2 id="100b" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">过滤器</h2><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="4903" class="lx ly it nd b gy ni nj l nk nl">// definition <br/>collection.filter((currentValue, index) =&gt; {<br/>    // logic to filter array on<br/>});<br/>// example<br/>const arr = [1,2,3,4,5];<br/>const newArray = arr.filter(i =&gt; i%2 == 0);<br/>// return a new array with value [2, 4]</span></pre><p id="b636" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">过滤器作用于一个数组，返回一个已过滤项目的数组。</strong>也就是说，它将删除返回 false 值的项目，只返回从函数返回的 true 值数组。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="806f" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">让我们用它们来做一些真实世界的场景+一些 ES6。(让我们在下面的对象键上尝试一些 ARMD)</h2><blockquote class="nn"><p id="ce74" class="no np it bd nq nr ns nt nu nv nw lp dk translated">想知道什么是 ARMD 它的添加，阅读，修改，删除，它的酷硬币你自己的行话😄</p></blockquote><figure class="nx ny nz oa ob kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="bdf2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用<code class="fe na nb nc nd b">users</code>它作为一个数组来进一步举例。</p><p id="c043" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> 1。一个</strong>RMD<strong class="kw iu">——给</strong> <code class="fe na nb nc nd b"><strong class="kw iu">users</strong></code>增加一个新元素</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="2003" class="lx ly it nd b gy ni nj l nk nl">const newUser = {<br/>    id: 4,<br/>    name: "Denomer Crazy",<br/>    username: "crazy.1",<br/>    email: "<a class="ae mz" href="mailto:deno@crazy.com" rel="noopener ugc nofollow" target="_blank">deno@crazy.com</a>",<br/>    phone: "",<br/>    website: "crazy.app",<br/>    password: "crazed_checker"<br/>};</span><span id="817e" class="lx ly it nd b gy nm nj l nk nl">const newData = [...users, newUser]; // add element at last<br/>or <br/>const newData = [newUser, ...users]; // add element at first<br/>or <br/>const newData = users.concat(newUser) // the old way</span></pre><p id="c1b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">ES6 spread 运算符的使用使得向数组添加元素变得非常容易。我们可以使用 spread 操作符连接两个不同的数组，修改对象的形状，或者添加动态键值对，等等。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="e805" class="lx ly it nd b gy ni nj l nk nl">const hobbies = ['chess', 'pool'];<br/>const newUsers = users.<strong class="nd iu">map</strong>(u =&gt; ({...u, hobbies}))<br/>// this will add hobbies to users array and return newUsers array</span></pre><p id="07bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> 2。</strong>A<strong class="kw iu">R</strong>MD<strong class="kw iu">——将</strong> <code class="fe na nb nc nd b"><strong class="kw iu">users</strong></code> <strong class="kw iu">的电子邮件地址、电话号码和网址放入新数组</strong></p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="dbc9" class="lx ly it nd b gy ni nj l nk nl">const contactInfo = users.<strong class="nd iu">map</strong>(({email, website, phone}) =&gt; ({email, website, phone}));</span></pre><p id="2616" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用 ES6 析构对象键和<code class="fe na nb nc nd b">map</code>来获取用户的联系信息数组。</p><p id="ffba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">3.AR <strong class="kw iu"> M </strong> D <strong class="kw iu"> —查找并替换对象</strong>的键值</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="461e" class="lx ly it nd b gy ni nj l nk nl">const newUsers = users.<strong class="nd iu">map</strong>(u =&gt; u.id == 2? ({...u, name: 'te'}): u);<br/>// this will return newUsers with all user having name 'te'</span></pre><p id="3d16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">4.手臂<strong class="kw iu">D</strong>T40】—从对象中删除一些关键点</p><blockquote class="mt mu mv"><p id="79f8" class="ku kv ms kw b kx ky ju kz la lb jx lc mw le lf lg mx li lj lk my lm ln lo lp im bi translated">注意:我们实际上不会删除键而是返回一个新的对象，如果你想删除键使用 delete 操作符，这里我们考虑的是对象的不变性。</p></blockquote><p id="accd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">删除键有很多种方法，但我们将着眼于最简单的，单行的。让我们试着从用户中删除网站。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="01a0" class="lx ly it nd b gy ni nj l nk nl">const newUsers = users.<strong class="nd iu">map</strong>({id, email, name, username, phone, password} =&gt; ({id, email, username, email, phone, password}));<br/>// will return an array with all keys other than website</span></pre><p id="a0a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的代码似乎很难对大对象进行编码。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="8d38" class="lx ly it nd b gy ni nj l nk nl">const newUsers = users.<strong class="nd iu">map</strong>(u =&gt; Object.keys(u).<strong class="nd iu">reduce</strong>((newObj, key) =&gt; key != 'website' ? { ...newObj, [key]: u[key]} : newObj, {}));</span></pre><p id="e26f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们对用户进行映射，然后对每个用户进行归约并形成一个新对象(<code class="fe na nb nc nd b">newObj</code>)，然后检查网站关键字，如果是网站，我们返回之前形成的<code class="fe na nb nc nd b">newObj</code>，如果不是，我们进行扩展操作，并将所需的关键字添加到<code class="fe na nb nc nd b">obj</code>，最后返回<code class="fe na nb nc nd b">newObj</code>。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="ea94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您想加入我的电子邮件列表，请考虑在此输入您的电子邮件地址<a class="ae mz" href="https://goo.gl/forms/MOPINWoY7q1f1APu2" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu"/></a><strong class="kw iu">关注我在</strong><a class="ae mz" href="https://medium.com/@ideepak.jsd" rel="noopener"><strong class="kw iu">medium</strong></a><strong class="kw iu">上阅读更多关于 javascript 的文章，并在</strong><a class="ae mz" href="https://github.com/dg92" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">github</strong></a><strong class="kw iu">上查看我的疯狂代码</strong>。如果有什么不清楚或者你想指出什么，请在下面评论。</p><p id="c363" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可能也会喜欢我的其他文章</p><ol class=""><li id="3816" class="oc od it kw b kx ky la lb ld oe lh of ll og lp oh oi oj ok bi translated"><a class="ae mz" href="https://levelup.gitconnected.com/javascript-execution-context-and-hoisting-c2cc4993e37d" rel="noopener ugc nofollow" target="_blank"> Javascript 执行上下文和提升</a></li><li id="ae72" class="oc od it kw b kx ol la om ld on lh oo ll op lp oh oi oj ok bi translated"><a class="ae mz" href="https://medium.com/datadriveninvestor/javascript-generator-yield-next-async-await-8442d2c77185" rel="noopener"> Javascript —生成器-产出/下一个&amp;异步-等待🤔</a></li><li id="edcb" class="oc od it kw b kx ol la om ld on lh oo ll op lp oh oi oj ok bi translated"><a class="ae mz" href="https://medium.com/datadriveninvestor/javascript-context-this-keyword-9a78a19d5786" rel="noopener">理解 Javascript 'this '关键字(上下文)</a>。</li><li id="43be" class="oc od it kw b kx ol la om ld on lh oo ll op lp oh oi oj ok bi translated"><a class="ae mz" href="https://medium.com/datadriveninvestor/javascript-currying-vs-partial-application-4db5b2442be8" rel="noopener"> Javascript- Currying VS 部分应用</a></li><li id="7b8f" class="oc od it kw b kx ol la om ld on lh oo ll op lp oh oi oj ok bi translated"><a class="ae mz" href="https://medium.com/datadriveninvestor/javascript-es6-iterables-and-iterators-de18b54f4d4" rel="noopener"> Javascript ES6 —可迭代程序和迭代器</a></li><li id="a8af" class="oc od it kw b kx ol la om ld on lh oo ll op lp oh oi oj ok bi translated"><a class="ae mz" href="https://codeburst.io/write-beautiful-javascript-with-%CE%BB-fp-es6-350cd64ab5bf" rel="noopener" target="_blank"> Javascript 性能测试—针对 vs 针对每个 vs (map，reduce，filter，find)。</a></li><li id="18e5" class="oc od it kw b kx ol la om ld on lh oo ll op lp oh oi oj ok bi translated"><a class="ae mz" href="https://medium.com/datadriveninvestor/why-to-use-javascript-proxy-5cdc69d943e3" rel="noopener"> Javascript —代理</a>，<a class="ae mz" href="https://medium.com/datadriveninvestor/still-confused-in-js-scopes-f7dae62c16ee" rel="noopener"> Javascript —作用域</a></li></ol></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="7b66" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">如果这篇文章有帮助，请随意分享并帮助他人找到它！</h2><p id="3910" class="pw-post-body-paragraph ku kv it kw b kx oq ju kz la or jx lc ld os lf lg lh ot lj lk ll ou ln lo lp im bi translated"><strong class="kw iu">谢谢！</strong></p></div></div>    
</body>
</html>