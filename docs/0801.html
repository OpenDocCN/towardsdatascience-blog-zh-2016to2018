<html>
<head>
<title>Sequence to sequence model: Introduction and concepts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">序列对序列模型:简介和概念</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sequence-to-sequence-model-introduction-and-concepts-44d9b41cd42d?source=collection_archive---------1-----------------------#2017-06-23">https://towardsdatascience.com/sequence-to-sequence-model-introduction-and-concepts-44d9b41cd42d?source=collection_archive---------1-----------------------#2017-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="efab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们从高层次来看，seq2seq模型的主要组件包括编码器、解码器和中间步骤:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/c49120a238f19f34e124390e3802ba7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*3lj8AGqfwEE5KCTJ-dXTvg.png"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kw"><img src="../Images/e0a862829e05f5ccdf6464edbb27697c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ismhi-muID5ooWf3ZIQFFg.png"/></div></div></figure><p id="547b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用嵌入，所以我们必须首先编译一个“词汇表”列表，包含我们希望我们的模型能够使用或读取的所有单词。模型输入必须是包含序列中单词id的张量。</p><p id="59e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，有四个符号需要我们的词汇来包含。Seq2seq词汇表通常为这些元素保留前四个位置:</p><ul class=""><li id="63b8" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn lg lh li lj bi translated"><strong class="js iu"> &lt; PAD &gt; </strong>:在训练过程中，我们需要将我们的例子批量地反馈给网络。这些批次中的输入都需要具有相同的宽度，以便网络进行计算。然而，我们的例子长度不同。这就是为什么我们需要填充较短的输入，使它们与批处理的宽度相同</li><li id="c936" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated"><strong class="js iu"> &lt; EOS &gt; </strong>:这也是批处理的另一个必要性，但更多是在解码器端。它允许我们告诉解码器一个句子在哪里结束，也允许解码器在输出中指出同样的事情。</li><li id="fc9b" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated"><strong class="js iu">&lt;&gt;</strong>:如果你在真实数据上训练你的模型，你会发现你可以通过忽略那些在你的词汇表中出现频率不够高、不值得考虑的单词来极大地提高你的模型的资源效率。我们用&lt; UNK &gt;代替那些。</li><li id="0f15" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated"><strong class="js iu"> &lt; GO &gt; </strong>:这是解码器第一个时间步长的输入，让解码器知道什么时候开始产生输出。</li></ul><p id="e407" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:可以使用其他标签来表示这些功能。例如，我见过用<s>和</s>代替<go>和<eos>。因此，通过预处理和模型训练/推理，确保您使用的任何东西都是一致的。</eos></go></p><p id="cd9a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为训练图准备输入稍微复杂一些，原因有两个:</p><blockquote class="lp lq lr"><p id="a75f" class="jq jr ls js b jt ju jv jw jx jy jz ka lt kc kd ke lu kg kh ki lv kk kl km kn im bi translated">1.如果我们向解码器提供我们的目标序列，而不管它的时间步长在训练运行中实际输出什么，这些模型会工作得更好。因此，与图中不同的是，我们不会在下一个时间步中将解码器的输出反馈给自身。</p></blockquote><p id="c2d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.定量</p><p id="f56b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最初的序列对序列论文之一<a class="ae lw" href="https://arxiv.org/abs/1409.3215" rel="noopener ugc nofollow" target="_blank"> Sutskever等人2014 </a>报告称，如果输入相反，模型性能会更好。所以你也可以选择颠倒单词在输入序列中的顺序。</p><p id="6e9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在预处理过程中，我们执行以下操作:</p><ul class=""><li id="4b1a" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn lg lh li lj bi translated">我们建立自己的独特词汇库(并计算出现的次数)</li><li id="1c60" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">我们用<unk>替换频率低的词</unk></li><li id="f9c4" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">创建一个对话的副本，用id替换单词</li><li id="8dff" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">我们可以选择现在将<go>和<eos>单词id添加到目标数据集，或者在训练时进行添加</eos></go></li></ul><p id="7ae1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">学分:来自课堂讲稿:<a class="ae lw" href="https://classroom.udacity.com/nanodegrees/nd101/syllabus" rel="noopener ugc nofollow" target="_blank">https://classroom.udacity.com/nanodegrees/nd101/syllabus</a></p><p id="5e7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">资源:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="81a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">https://github.com/ematvey/tensorflow-seq2seq-tutorials<a class="ae lw" href="https://github.com/ematvey/tensorflow-seq2seq-tutorials" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>