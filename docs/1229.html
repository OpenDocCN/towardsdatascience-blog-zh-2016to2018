<html>
<head>
<title>Instinct: neuro-evolution on steroids</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">本能:类固醇上的神经进化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/neuro-evolution-on-steroids-82bd14ddc2f6?source=collection_archive---------4-----------------------#2017-08-13">https://towardsdatascience.com/neuro-evolution-on-steroids-82bd14ddc2f6?source=collection_archive---------4-----------------------#2017-08-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c790" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kl translated">当我第一次实现神经进化时，我实现了Kenneth O. Stanley和Risto Miikkulainen的论文中描述的算法；<a class="ae ku" href="http://nn.cs.utexas.edu/downloads/papers/stanley.ec02.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="kv">通过扩充拓扑进化神经网络</em> </a>。我设法让它工作，但当我在更复杂的数据集上测试算法时，问题开始出现。</p><p id="5e55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">节点连接偏差的缺乏迫使网络对于简单的问题变得过于庞大和复杂。跟踪所谓的创新数字在计算上非常昂贵。但最重要的是:由于缺少门，该算法永远不会产生任何像我们在LSTM的记忆细胞。</p><p id="fc6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我很快开始修改算法，添加偏差和门，删除创新数，但也添加了节点变异其激活函数的选项:这是一个非常强大的工具，因为基因组现在可以针对数据集/环境完全修改自己。</p><h1 id="d648" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">本能算法</h1><p id="d08f" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">我喜欢称我的算法为本能算法。不仅仅是因为这听起来很酷，还因为神经进化在某些环境中发展了神经代理的本能。</p><blockquote class="lz"><p id="f9ea" class="ma mb iq bd mc md me mf mg mh mi kk dk translated">本能的本质在于它是独立于理性而存在的。—查尔斯·达尔文</p></blockquote><p id="4f16" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">我将仅仅讨论基因组的结构，以及它们应该如何被培育、变异和限制。建立遗传算法取决于你。关于工作示例，请参见<a class="ae ku" href="https://github.com/wagenaartje/neataptic" rel="noopener ugc nofollow" target="_blank">我的Javascript神经进化库</a>。</p><p id="9c30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另请注意，当算法发生变化时，本文将会更新。例如，我已经计划加入共享权重，这将很快加入。</p><h2 id="bc89" class="mo kx iq bd ky mp mq dn lc mr ms dp lg jy mt mu lk kc mv mw lo kg mx my ls mz bi translated">1个基因组</h2><p id="7e3e" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">如图1所示，一个基因组由一组节点和一组连接组成。</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi na"><img src="../Images/55fb91ad817dc2ce54923950dd6e1a40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DAoTlqTn-qsWlxmlFSnmww.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk">(figure 1) Simple example of a genotype and corresponding phenotype</figcaption></figure><p id="75b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 1.1节点</strong></p><p id="2194" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个节点都有一个类型。只有三种:<code class="fe nq nr ns nt b">input</code>、<code class="fe nq nr ns nt b">hidden</code>、<code class="fe nq nr ns nt b">output</code>。类型为<code class="fe nq nr ns nt b">input</code>的节点总是停留在列表的开头，类型为<code class="fe nq nr ns nt b">output</code>的节点将停留在列表的末尾。如果通过突变添加了新节点，它们将总是具有<code class="fe nq nr ns nt b">hidden</code>类型。</p><p id="147c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">index参数没有真正的功能，它只是表示节点被激活的顺序。这是按升序发生的。</p><p id="4f7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个节点都有一个可修改的偏置和挤压(或:激活功能)。偏见没有固定的范围。为每个新变异的节点随机选择激活函数。</p><p id="d0fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 1.2连接</strong></p><p id="817b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">连接从索引为<code class="fe nq nr ns nt b">from</code>的节点连接到索引为<code class="fe nq nr ns nt b">to</code>的节点。即使连接引用了索引，它实际上也引用了它所连接的节点。例如，如果索引2和3上的节点之间存在连接，则该连接总是引用最初在索引2和3上的节点。</p><p id="bfe6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个连接也有自己的权重和网关。重量没有固定范围。<code class="fe nq nr ns nt b">gater</code>参数表示节点基因列表中控制连接的节点的索引，它总是引用该节点，而不管其索引如何。</p><p id="aee4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 1.3激活</strong></p><p id="2517" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">激活基因组的方法与其他神经网络完全相同，但我想在这里放一些(类似JS的)伪代码以防万一。请记住，自连接是由节点先前的<em class="kv">状态</em>而不是节点先前的激活状态相乘的。</p><pre class="nb nc nd ne gt nu nt nv nw aw nx bi"><span id="e078" class="mo kx iq nt b gy ny nz l oa ob">FUNCTION ACTIVATE: <br/>  output = []</span><span id="7942" class="mo kx iq nt b gy oc nz l oa ob">  FOR EACH node IN genome.nodes:<br/>    IF node.type === 'INPUT':<br/>      node.activation = input[i]<br/>    ELSE:<br/>      // self-connections are handled differently!<br/>      node.state = node.selfconnection.weight * node.state *<br/>        genome.nodes[node.selfconnection.gater].activation +<br/>        node.bias</span><span id="be49" class="mo kx iq nt b gy oc nz l oa ob">      FOR EACH connection IN node.incomingConnections:<br/>        node.state += connection.weight *<br/>          genome.nodes[connection.from].activation * <br/>          genome.nodes[connection.gater].activation<br/>      <br/>      <br/>      node.activation = node.squash(node.state)<br/>      <br/>      IF node.type === 'OUTPUT':<br/>        output.add(node.activation)</span></pre><h2 id="99b9" class="mo kx iq bd ky mp mq dn lc mr ms dp lg jy mt mu lk kc mv mw lo kg mx my ls mz bi translated">2交叉</h2><p id="7295" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">杂交是基因组改进的关键。当两个基因组被选择进行杂交时，它们会产生一个独特的后代。它可能会从两个不太健康的父母那里创造出非常健康的后代。它刺激了群体中新网络拓扑的创建。</p><blockquote class="lz"><p id="8041" class="ma mb iq bd mc md me mf mg mh mi kk dk translated">一个普遍的法则，导致所有有机生物的进步，也就是，繁殖，变化，让最强的生存，最弱的死亡。——<a class="ae ku" href="https://en.wikipedia.org/wiki/On_the_Origin_of_Species" rel="noopener ugc nofollow" target="_blank"><strong class="ak">查尔斯·达尔文</strong>，<strong class="ak">物种起源</strong> </a></p></blockquote><p id="7a1b" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">首先，后代的大小被确定。基因组的大小等于基因组的节点数。如果双亲中的一个比另一个具有更高的适合度，那么大小将与最适合的双亲的大小相同。如果双亲同样合适，则在双亲的尺寸之间随机选择一个尺寸。</p><pre class="nb nc nd ne gt nu nt nv nw aw nx bi"><span id="b46e" class="mo kx iq nt b gy ny nz l oa ob">IF parent1.fitness &gt; parent2.fitness:<br/>  offspring.size = parent1.size<br/>ELSE IF parent2.fitness &gt; parent1.fitness:<br/>  offspring.size = parent2.size<br/>ELSE:<br/>  offspring.size = randomBetween(parent1.size, parent2.size)</span></pre><p id="6f30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不管哪个父节点更合适，对于每个索引，节点将从每个父节点中统一选择。这样做，直到节点的数量等于先前确定的大小。</p><p id="d67d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当子代的大小大于最小的父代时，将总是选择来自最大父代的节点。</p><p id="3f2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些规则有两个例外:首先，如果后代的输出节点还没有被选择，那么类型为<code class="fe nq nr ns nt b">output</code>的节点可能永远不会被选择。其次，当为后代选择第<code class="fe nq nr ns nt b">n</code>个输出节点时，则选择双亲之一的第<code class="fe nq nr ns nt b">n</code>个输出节点。</p><pre class="nb nc nd ne gt nu nt nv nw aw nx bi"><span id="d67c" class="mo kx iq nt b gy ny nz l oa ob">FOR i = 0, i &lt; offspring.size, i++:<br/>  IF i &lt; offspring.size - parents.outputSize:<br/>    // Choose non-output nodes<br/>    IF i &gt; parent1.size - parents.outputSize:<br/>      node = parent2.nodes[i];<br/>    ELSE IF i &gt; parent2.size - parents.outputSize:<br/>      node = parent1.nodes[i]<br/>    ELSE:<br/>      node = SELECT_UNIFORM(parent1.nodes[i], parent2.nodes[i])<br/>  ELSE:<br/>    // Choose output nodes<br/>    node = SELECT_UNIFORM(<br/>      parent1.nodes[parent1.size + i - offspring.size],<br/>      parent1.nodes[parent2.size + i - offspring.size]<br/>    )<br/> <br/>  offspring.nodes[i] = node;<br/></span></pre><p id="9c97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦选择了节点，连接被分成两个不同的组:<em class="kv">公共</em>和<em class="kv">额外</em>连接。当两个父节点具有相同的<code class="fe nq nr ns nt b">from</code>和<code class="fe nq nr ns nt b">to</code>值时，这是一个普通连接。否则，它就是一个额外的连接，意味着这个连接只存在于父母中的一个。</p><p id="41db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最有效的方法</p><p id="7923" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kv">公共</em>节点从双亲中统一选择，而不考虑它们的适合度。只有当父母中的一方至少和另一方一样健康时，来自该方的额外基因才会被添加。</p><h2 id="ea46" class="mo kx iq bd ky mp mq dn lc mr ms dp lg jy mt mu lk kc mv mw lo kg mx my ls mz bi translated">3突变</h2><p id="2492" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">与整洁的论文不同，我将描述应该用来从基因组中获得最大效率的突变方法。每个描述都附有一些伪代码。</p><p id="c3d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3.1添加节点突变</strong></p><p id="14c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">拥有一种将节点基因添加到基因组的突变方法是必不可少的。没有这种突变方法，基因组将不会增长，因此在节点被连接饱和后永远不会改善。</p><p id="3b12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当添加新节点时，现有连接将被拆分为两个新连接，新节点位于这两个连接之间。</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi od"><img src="../Images/40b0fb6cc6b328ce5898e2c6476e0b78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ChcYxDze6yg9pPadF3v3Jg.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk">(figure 2) Example of the add node mutation, a new node between 1 and 2 is added</figcaption></figure><p id="8894" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果被删除的连接有一个网关，该网关将被转移到两个新连接中的一个。当一个新的节点被插入到一个基因组的基因列表中时，它被放置在原始连接的接收节点(具有索引<code class="fe nq nr ns nt b">to</code>的节点)的之前<em class="kv">并且从不在具有<code class="fe nq nr ns nt b">output</code>类型的任何</em>节点的之后<em class="kv">。</em></p><p id="0e2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当一个节点被插入到其他节点之间时，被插入节点之后的所有节点的索引增加1。因此，现有的连接总是保留在它们最初被分配到的节点之间。</p><p id="7ae0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">新节点总是被分配一个统一选择的激活函数。</p><pre class="nb nc nd ne gt nu nt nv nw aw nx bi"><span id="d6e7" class="mo kx iq nt b gy ny nz l oa ob">connection = SELECT_UNIFORM(genome.connections)<br/>gater = connection.gater</span><span id="8d2d" class="mo kx iq nt b gy oc nz l oa ob">index = MIN(connection.to, genome.size - genome.outputSize)<br/>node = new Node()</span><span id="78e4" class="mo kx iq nt b gy oc nz l oa ob">genome.nodes.insert(node, index)<br/>genome.connections.remove(connection)</span><span id="58a3" class="mo kx iq nt b gy oc nz l oa ob">newConnection1 = {<br/>  from: connection.from, <br/>  to: index, <br/>  weight: randomNumber(),<br/>  gater: -1<br/>}</span><span id="d264" class="mo kx iq nt b gy oc nz l oa ob">newConnection2 = {<br/>  from: index, <br/>  to: connection.to, <br/>  weight: randomNumber(),<br/>  gater: -1<br/>}</span><span id="97af" class="mo kx iq nt b gy oc nz l oa ob">IF gater !== -1:<br/>  SELECT_UNIFORM(newConnection1, newConnection2).gater = gater</span><span id="0ac9" class="mo kx iq nt b gy oc nz l oa ob">genome.connections.add(newConnection1)<br/>genome.connections.add(newConnection2)</span></pre><p id="0803" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3.2添加连接突变</strong></p><p id="4518" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与变异新节点同等重要的是变异新连接。首先，生成存在<em class="kv">不存在</em>的连接列表。列表生成后，其中一个生成的连接将被放入基因组的连接基因列表中。</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi oe"><img src="../Images/51e78968640efe43f437367aa48e67b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8BoOnDB5CZoOEqHM0C16HQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk">(figure 3) Example of the add connection mutation, a new connection between 1 and 3 is added</figcaption></figure><p id="0614" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来自<code class="fe nq nr ns nt b">hidden</code>或<code class="fe nq nr ns nt b">output</code>类型节点的连接从不连接到<code class="fe nq nr ns nt b">input</code>类型节点，因为<code class="fe nq nr ns nt b">input</code>类型节点的激活值不是计算出来的，而是由数据集提供的。创建这些连接会调用不必要的内存。</p><pre class="nb nc nd ne gt nu nt nv nw aw nx bi"><span id="2150" class="mo kx iq nt b gy ny nz l oa ob">pairs = []</span><span id="f2e6" class="mo kx iq nt b gy oc nz l oa ob">FOR EACH node1 IN genome.nodes:<br/>  FOR EACH node2 IN genome.nodes:<br/>    IF node1.isNotConnectedTo(node2):<br/>      pairs.add([node1, node2])</span><span id="8de6" class="mo kx iq nt b gy oc nz l oa ob">pair = SELECT_UNIFORM(pairs)</span><span id="8c40" class="mo kx iq nt b gy oc nz l oa ob">connection = {<br/>  from: pair[0].index,<br/>  to: pair[1].index,<br/>  weight: random(),<br/>  gater: -1<br/>}</span><span id="f22c" class="mo kx iq nt b gy oc nz l oa ob">genome.connections.add(connection)</span></pre><p id="3564" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3.3添加门突变</strong></p><p id="6f3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">拥有一种设置连接基因闸门的突变方法，对于开发复杂的网络来检测多个连续输入之间的模式是必要的。</p><p id="2f73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">统一选择一个连接，并将<code class="fe nq nr ns nt b">gater</code>值设置为从基因组的节点基因列表中统一选择的节点的索引。</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi of"><img src="../Images/1f121fceb9783b90540fd8de8da39f73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v82vrKS7gXUhj24Vjuumtw.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk">(figure 4) Example of the add gate mutation, connection from 1 to 3 is gated</figcaption></figure><pre class="nb nc nd ne gt nu nt nv nw aw nx bi"><span id="bb00" class="mo kx iq nt b gy ny nz l oa ob">connection = SELECT_UNIFORM(genome.connections)<br/>connection.gater = selectionUniform(genome.nodes).index</span></pre><p id="35d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3.4修改体重突变</strong></p><p id="9379" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">统一选择一个连接，并在该连接的权重上加上或减去一个值。我喜欢把修改固定在<code class="fe nq nr ns nt b">(-1, 1)</code>的范围内。</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi og"><img src="../Images/67ae98210a04d4aba8d833f17c2cbab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7dIAvKAFXIjBMA75I3yLsA.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk">(figure 5) Example of the modify weight mutation</figcaption></figure><pre class="nb nc nd ne gt nu nt nv nw aw nx bi"><span id="f1ce" class="mo kx iq nt b gy ny nz l oa ob">connection = SELECT_UNIFORM(genome.connections)<br/>modification = random() * (max - min) + min</span><span id="5e91" class="mo kx iq nt b gy oc nz l oa ob">connection.weight += modification</span></pre><p id="a6ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3.5修改偏置突变</strong></p><p id="e805" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">统一选择一个节点，并从该节点的偏差中增加或减去一个值。我喜欢修正<code class="fe nq nr ns nt b">(-1, 1)</code>的射程。确保不要突变输入节点，因为这对基因组的输出没有影响。</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi oh"><img src="../Images/3f9a263995233a89c0d4e36fd6f91f2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gmJge65EMBxSNmPAWDfIJA.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk">(figure 6) Example of the modify bias mutation</figcaption></figure><pre class="nb nc nd ne gt nu nt nv nw aw nx bi"><span id="62e0" class="mo kx iq nt b gy ny nz l oa ob">node = SELECT_UNIFORM(genome.nodes) // exclude input nodes<br/>modification = random() * (max - min) + min</span><span id="41cd" class="mo kx iq nt b gy oc nz l oa ob">node.bias += modification</span></pre><p id="34f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3.6修改南瓜突变</strong></p><p id="78a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后但肯定不是最不重要的:修改节点基因激活功能的突变方法。就个人而言，我坚持使用以下激活功能列表:</p><p id="de30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae ku" href="https://en.wikipedia.org/wiki/Logistic_function" rel="noopener ugc nofollow" target="_blank"> <em class="kv">逻辑</em> </a> <em class="kv">，</em> <a class="ae ku" href="https://en.wikipedia.org/wiki/Hyperbolic_function" rel="noopener ugc nofollow" target="_blank"> <em class="kv">双曲正切</em> </a> <em class="kv">，</em> <a class="ae ku" href="https://en.wikipedia.org/wiki/Identity_function" rel="noopener ugc nofollow" target="_blank"> <em class="kv">恒等式</em> </a> <em class="kv">，</em> <a class="ae ku" href="https://en.wikipedia.org/wiki/Heaviside_step_function" rel="noopener ugc nofollow" target="_blank"> <em class="kv">二进制步长</em> </a> <em class="kv">，</em><a class="ae ku" href="https://en.wikipedia.org/wiki/Rectifier_(neural_networks)" rel="noopener ugc nofollow" target="_blank"><em class="kv">ReLU</em></a><em class="kv">，软符号，</em> <a class="ae ku" href="https://en.wikipedia.org/wiki/Gaussian_function" rel="noopener ugc nofollow" target="_blank"> <em class="kv">高斯</em></a></p><p id="fe3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你寻求更多样的激活功能，我推荐<a class="ae ku" href="https://stats.stackexchange.com/questions/115258/comprehensive-list-of-activation-functions-in-neural-networks-with-pros-cons" rel="noopener ugc nofollow" target="_blank">这个列表</a>。</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi oi"><img src="../Images/e0edf61ce114ceec14b12ca303ddab37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rGtSu9oOYnxJU8GaVlcF9w.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk">(figure 7) Example of the modify squash mutation</figcaption></figure><pre class="nb nc nd ne gt nu nt nv nw aw nx bi"><span id="8a5d" class="mo kx iq nt b gy ny nz l oa ob">node = SELECT_UNIFORM(genome.nodes)<br/>newSquash = SELECT_UNIFORM(listOfSquashes)</span><span id="0789" class="mo kx iq nt b gy oc nz l oa ob">node.squash = newSquash</span></pre><p id="5458" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3.7清除节点突变</strong></p><p id="7e2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着基因组的增长，它可能表现得更好，但有时它有利于基因组回复已经发生的突变。这也降低了激活基因组的计算成本。</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi oj"><img src="../Images/052e7d9846c4f5d5ed802d83a6aa0fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wfYH5SwRjNPGZj1z3pmGjw.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk">(figure 8) Example of the remove node mutation, node on index 2 is getting removed</figcaption></figure><p id="c09c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，<code class="fe nq nr ns nt b">input</code>或<code class="fe nq nr ns nt b">output</code>类型的节点永远不会被删除。一旦随机选择一个隐藏类型的节点进行删除，就会创建一个带有节点索引的列表，该列表提供到该节点的所有传入连接(不包括自连接)。另一个列表是用所有输出连接的目标节点索引创建的。同时，不是输入和输出连接的<code class="fe nq nr ns nt b">-1</code>的<code class="fe nq nr ns nt b">gater</code>值被保存。</p><pre class="nb nc nd ne gt nu nt nv nw aw nx bi"><span id="97cb" class="mo kx iq nt b gy ny nz l oa ob">node = SELECT_UNIFORM(genome.nodes)</span><span id="2006" class="mo kx iq nt b gy oc nz l oa ob">gaters = [];<br/>sourceNodes = [];</span><span id="d9de" class="mo kx iq nt b gy oc nz l oa ob">FOR EACH connection IN node.incomingConnections:<br/>  IF connection.from !== node.index:<br/>    sourceNodes.add(connection.from)<br/>    IF connection.gater !== -1:<br/>      gaters.add(connection.gater)</span><span id="194b" class="mo kx iq nt b gy oc nz l oa ob">targetNodes = [];</span><span id="6c6a" class="mo kx iq nt b gy oc nz l oa ob">FOR EACH connection IN node.outgoingConnections:<br/>  IF connection.to !== node.index:<br/>    targetNodes.add(connection.to)<br/>    IF connection.gater !== -1:<br/>      gaters.add(connection.gater)</span></pre><p id="451a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在<code class="fe nq nr ns nt b">sourceNodes</code>阵列中的每个节点索引<em class="kv">与<code class="fe nq nr ns nt b">targetNodes</code>阵列中的每个</em>节点索引<em class="kv">连接(如果尚未连接)。保留了所创建的连接的列表。创建完所有连接后，<code class="fe nq nr ns nt b">gaters</code>中的每个选通器都被分配给一个连接，直到没有连接留给选通器。</em></p><pre class="nb nc nd ne gt nu nt nv nw aw nx bi"><span id="e081" class="mo kx iq nt b gy ny nz l oa ob">newConnections = [];</span><span id="c724" class="mo kx iq nt b gy oc nz l oa ob">FOR EACH source IN sourceNodes:<br/>  FOR EACH target IN targetNodes:<br/>    IF source.notConnectedTo(target):<br/>      connection = {<br/>        from: source,<br/>        to: target,<br/>        weight: random(),<br/>        gater: -1<br/>      }<br/>      newConnections.add(connection)<br/>      genome.connections.add(connection)</span><span id="137a" class="mo kx iq nt b gy oc nz l oa ob">FOR EACH gater IN gaters:<br/>  IF newConnections.length === 0:<br/>    break;<br/>  <br/>  randomConnection = SELECT_UNIFORM(newConnections);<br/>  <br/>  randomConnection.gater = gater<br/>  newConnections.remove(randomConnection)</span></pre><p id="07ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由被移除的节点选通的每个连接的<code class="fe nq nr ns nt b">gater</code>值被设置为<code class="fe nq nr ns nt b">-1</code>。最后，从基因组中移除该节点。</p><pre class="nb nc nd ne gt nu nt nv nw aw nx bi"><span id="d864" class="mo kx iq nt b gy ny nz l oa ob">FOR EACH connection IN genome.connections:<br/>  IF connection.gater === node.index:<br/>    connection.gater = -1</span><span id="069c" class="mo kx iq nt b gy oc nz l oa ob">genome.nodes.remove(node)</span></pre><p id="a4e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3.8移除连接突变</strong></p><p id="ef7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只有当源节点有多个传出连接并且目标节点有多个传入连接时，才能删除连接。这样，所有节点将始终至少有一个传入连接和一个传出连接。</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi ok"><img src="../Images/5b4f6d15c8e32bb1cb594a225152dad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zsvaP8jp_LWFoCTqM-IsIQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk">(figure 9) Example ofthe remove connection mutation, connection between 1 and 3 is being removed</figcaption></figure><pre class="nb nc nd ne gt nu nt nv nw aw nx bi"><span id="da0a" class="mo kx iq nt b gy ny nz l oa ob">connections = [];</span><span id="751e" class="mo kx iq nt b gy oc nz l oa ob">FOR EACH connection IN genome.connections:<br/>  IF connection.from.hasMultipleOutgoingConnections() AND<br/>     connection.to.hasMultipleIncomingConnections():<br/>    connections.add(connection)</span><span id="3a8f" class="mo kx iq nt b gy oc nz l oa ob">connection = SELECT_UNIFORM(connections)<br/>genome.connections.remove(connection)</span></pre><p id="bccc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3.9移除门突变</strong></p><p id="e817" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">先前已经变异的门可能会对基因组的表现造成问题。这种变异方法从随机选择的门控连接中移除门。</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi ol"><img src="../Images/d90554792f9ac0e6ed2b797eaf4a90b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-6gx8WfntZerOg1OvpCpYg.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk">(figure 10) Example of the remove gate connection, connection from 1 to 3 is getting ungated</figcaption></figure><pre class="nb nc nd ne gt nu nt nv nw aw nx bi"><span id="2010" class="mo kx iq nt b gy ny nz l oa ob">gatedConnections = [];</span><span id="856b" class="mo kx iq nt b gy oc nz l oa ob">FOR EACH connection IN genome.connections:<br/>  IF connection.gater !== -1:<br/>    gatedConnections.add(connection)</span><span id="8752" class="mo kx iq nt b gy oc nz l oa ob">connection = SELECT_UNIFORM(gatedConnections)<br/>connection.gater = -1</span></pre><p id="dee7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3.10其他突变方法</strong></p><p id="1031" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有时将添加连接变异方法拆分成多个其他变异方法是有意义的:<em class="kv">添加前馈连接、添加递归连接</em>和<em class="kv">添加自连接</em>。这也需要<em class="kv">移除前馈连接，移除循环连接</em>和<em class="kv">移除自连接。</em></p><p id="d3df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，当数据集没有空间关系(多个样本之间的关系)时，您不希望出现任何重复性突变。</p><h2 id="6529" class="mo kx iq bd ky mp mq dn lc mr ms dp lg jy mt mu lk kc mv mw lo kg mx my ls mz bi translated">4个限制因素</h2><p id="3cad" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">就像任何其他训练方法一样，本能算法有可能过度拟合数据集。为了避免过拟合，引入了一个新的全局参数:<em class="kv">生长</em>。</p><p id="00a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nq nr ns nt b">growth</code>参数不利于基因组变大，但性能相对较低。通常，<code class="fe nq nr ns nt b">growth</code>是十进制数。节点、连接和门的数量乘以<code class="fe nq nr ns nt b">growth</code>得到基因组的适应度惩罚。</p><pre class="nb nc nd ne gt nu nt nv nw aw nx bi"><span id="f725" class="mo kx iq nt b gy ny nz l oa ob">penalty = (genome.nodes.length + genome.connections.length + genome.gates.length) * growth</span></pre><p id="02e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用于计算罚金的参数是自由选择的。例如，罚款计算也可以是:</p><pre class="nb nc nd ne gt nu nt nv nw aw nx bi"><span id="15dd" class="mo kx iq nt b gy ny nz l oa ob">penalty = genome.nodes.length * growth</span></pre><p id="532f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 4.1示例</strong></p><p id="426c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个基因组在某个数据集上有<code class="fe nq nr ns nt b">10</code>的适合度。基因组发生了变异。它获得了一个额外的节点。突然，适应度提高到了<code class="fe nq nr ns nt b">11</code>。可悲的是，随着以下惩罚的应用，最终适应度降低到<code class="fe nq nr ns nt b">9</code>:</p><pre class="nb nc nd ne gt nu nt nv nw aw nx bi"><span id="a132" class="mo kx iq nt b gy ny nz l oa ob">fitness = fitness - genome.nodes.length * growth</span></pre><p id="c9e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其<code class="fe nq nr ns nt b">growth</code>值为<code class="fe nq nr ns nt b">2</code>。因此，如果一个基因组想要达到更高的最终适应度，适应度的增加应该高于<code class="fe nq nr ns nt b">2</code>。</p></div></div>    
</body>
</html>