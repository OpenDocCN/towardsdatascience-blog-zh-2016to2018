<html>
<head>
<title>TDA To Rule Them All: ToMATo Clustering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TDA 统治一切:番茄集群</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tda-to-rule-them-all-tomato-clustering-878e03394a1?source=collection_archive---------0-----------------------#2018-07-13">https://towardsdatascience.com/tda-to-rule-them-all-tomato-clustering-878e03394a1?source=collection_archive---------0-----------------------#2018-07-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b00d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">忘了 K-Means 吧！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d9a7210b473cd37e085428182ab9884b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qT3T4M5swQZ3i1GgE3eorg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Credits: <a class="ae ky" href="https://geometrica.saclay.inria.fr/team/Steve.Oudot/papers/cgos-pbc-09/cgos-pbcrm-11.pdf" rel="noopener ugc nofollow" target="_blank">Original Paper</a></figcaption></figure><p id="dc65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你想念应用数学吗？同样，我的目标是推广<strong class="lb iu">拓扑数据分析</strong>及其提供的多种可能性。前一篇文章提到了机器学习和深度学习，但 TDA 在其中的一个领域找到了用途:<strong class="lb iu">集群</strong>。</p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/from-tda-to-dl-d06f234f51d"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">从拓扑数据分析到深度学习:不劳无获</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">今天，我将尝试给出一些关于 TDA(用于拓扑数据分析)的见解，这是一个快速发展的数学领域…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="2921" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由 TDA 提供支持的聚类概念已经被引入(不那么)著名的番茄(<em class="mn">拓扑模式分析工具</em>)算法，在这篇<a class="ae ky" href="https://geometrica.saclay.inria.fr/team/Steve.Oudot/papers/cgos-pbc-09/cgos-pbcrm-11.pdf" rel="noopener ugc nofollow" target="_blank">论文</a>中介绍。与更常见的(scikit-learn 类)聚类算法相比，该算法有两个优点:</p><ul class=""><li id="9a44" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu mt mu mv mw bi translated">它给你一个方法来知道你的数据似乎有多少个集群；</li><li id="cc3a" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">它为您提供了一种将这些数据收集到<strong class="lb iu">不同集合</strong>中进行聚类的方法。</li></ul><blockquote class="nc nd ne"><p id="51e9" class="kz la mn lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated">我开发了与本文相关的代码作为概念验证，其中肯定有需要改进的地方！不要放弃看一看，我很乐意接受你的批评；) !</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/a63424cc4744a8e89348e3e5247e1908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9HBKK92ToaFhInvzpGjT5g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Credits: Gaijin et al.</figcaption></figure><h1 id="9500" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated"><strong class="ak">算法演示</strong></h1><p id="852f" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">出于解释的目的，我将限于二维考虑。核心思想是将 TDA 应用于我们的数据点的密度估计，提取其最大值，从而提取其表观质心。很好，但是怎么做？</p><p id="0da6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了回到实际的 TDA，你需要建立<strong class="lb iu">单纯形树*<strong class="lb iu">单纯形复形* </strong>的</strong>嵌套族，最终基本上是一个对应于密度函数的图<strong class="lb iu">、</strong>。</p><ul class=""><li id="8b8d" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu mt mu mv mw bi translated">首先，计算密度估计并初始化结构；</li><li id="9415" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">第二，给你数据集的每一个点一个索引；</li><li id="f6c6" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">第三，将每个数据点通过它们的索引插入到你的<strong class="lb iu">单纯形树</strong>中，通过赋予它们相应的密度值作为过滤*值；</li><li id="acac" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">第四，通过平均过滤值将每个点链接到其邻域图。</li></ul><p id="0235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您最终得到一个<strong class="lb iu">实例化的图</strong>，并且您可以通过上层过滤来计算相应的持久性(~ <em class="mn">通过对所获得的过滤值进行递减排序来定义单纯复形的嵌套族</em>，在我的<a class="ae ky" href="http://github.com/Coricos/TdaToolbox" rel="noopener ugc nofollow" target="_blank"> Github </a>库中给出了进一步的说明。</p><blockquote class="nc nd ne"><p id="c0a0" class="kz la mn lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated">(*)概念解释见下文</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/5f81b23a26e161e2bd1b79372c472455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YMsYsxagQSqntKywP40HVA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Density Estimation over a ‘two moons’ Dataset</figcaption></figure><p id="47fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过计算这种过滤的<strong class="lb iu">持久性图</strong>(和持久性条形码),您会得到这样的结果:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="099a" class="om nk it oi b gy on oo l op oq">gen = ClusterGenerator(structure=’anisotropy’, randomize=45)<br/>clf = ToMaTo(*gen.generate())<br/>_ = clf.estimate_clusters(graph=True)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/cf4f66e8874a7f231b12109cea571316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YtAbpe5v1OFWjvuwGUY--A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Obtained Persistence from the upper levels Filtration of the Density Estimate</figcaption></figure><p id="7a00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前面的结果让您对数据有了真正的了解:对角线上有两个元素，对应于具有最大持久性的对象。在这种情况下，持久性表征了已经创建的结构在你的图中难以重叠的程度。<strong class="lb iu">基本上是指全局最大值(用于上层过滤)或全局最小值(用于子层过滤)</strong>。在我们的例子中，我们只观察到你的数据有<em class="mn">两个质心，</em>对应两个密度峰值。现在，您需要将每个数据点链接到这两个质心，以构建不同的聚类。这可以通过一个<strong class="lb iu"> UnionFind </strong>结构(<em class="mn"> disjoint-set 数据结构</em>)来实现，并遵循下面算法中提出的思想。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/ece21e5197e08635475bdc15bd0489ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*4n5t8xSb-jHXJojV2J_jzw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">ToMATo Algorithm</figcaption></figure><p id="d02e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该概念仅基于过滤值的递减顺序。很好的一点是，你只需要一遍所有的数据点。对于每个有序数据点，您有两种可能性:</p><ul class=""><li id="9286" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu mt mu mv mw bi translated">要么它没有具有更高过滤值的邻居，那么它被认为是局部密度最大值；</li><li id="6753" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">它也没有，您需要查看不同的邻居，合并根以将相同的边链接到其对应的最重权重的根(越接近给定的质心，权重越高)。</li></ul><p id="2934" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免创建多个集群，对于由<em class="mn"> tau，</em>给出的过滤值有一个条件，它确保小集群将被链接到更大的集群。python 化后，它给出了以下内容(从一个更大的函数中提取，解释对象方法):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="7c93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比较每个数据点的不同根/父项后:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="c70d" class="om nk it oi b gy on oo l op oq">gen = ClusterGenerator(structure='moons', randomize=45)<br/>clf = ToMaTo(*gen.generate())<br/>_ = clf.estimate_density(graph=<strong class="oi iu">False</strong>)<br/>clf.estimate_clusters(graph=<strong class="oi iu">False</strong>)<br/>prd = clf.fit_predict(num_clusters=2, graph=<strong class="oi iu">True</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/8f89e11291788ef80c274ab98db0494d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w-gW-fzDyam34yDl96VDWQ.png"/></div></div></figure></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><h1 id="5281" class="nj nk it bd nl nm pc no np nq pd ns nt jz pe ka nv kc pf kd nx kf pg kg nz oa bi translated"><strong class="ak">其他例子</strong></h1><p id="4b3b" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">其他例子在我的<a class="ae ky" href="http://github.com/Coricos/TdaToolbox" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Github 资源库</strong> </a>中提供，作为处理各向异性数据的，那个<strong class="lb iu"> k-means </strong>(最常用的聚类算法之一)有聚类的麻烦(参见 scikit-learn 示例)。</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="6c5b" class="om nk it oi b gy on oo l op oq">gen = ClusterGenerator(structure='anisotropy', randomize=45)<br/>clf = ToMaTo(*gen.generate())<br/>_ = clf.estimate_density(graph=<strong class="oi iu">False</strong>)<br/>clf.estimate_clusters(graph=<strong class="oi iu">False</strong>)<br/>prd = clf.fit_predict(num_clusters=3, graph=<strong class="oi iu">True</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/0879fcbe2b10d182369ac77f2b35de00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y8Cvihp270B2HDedU5kHWw.png"/></div></div></figure><h1 id="d534" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated"><strong class="ak"> (*)一些概念</strong></h1><p id="5d28" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">对于那些对固有理论及其数学形式感兴趣的人来说，这里有一些元素可能会告诉你。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/ab2b2a90857d692ac1dd5aaa04dae347.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*695r1QocsHwm2FUDHeOmAQ.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/4c5cbf176bea5c76d3069ba6d8556268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p-c70QtO8bxp7W3EdIBY4Q.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/9c1b6598a8685ef6a8c31f379e34994a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CI-mtR1N8BTebvzajMJITQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Credits: <a class="ae ky" href="https://hal.inria.fr/hal-00707901v1/document" rel="noopener ugc nofollow" target="_blank">The Simplex Tree</a></figcaption></figure><p id="bd0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个理论有很多可能性，这些结果和深度学习之间的接口目前仍在开发中。许多想法将会出现，这使得这个话题变得非常热门和有趣！<em class="mn">敬请期待来稿，想要更多就鼓掌；)</em>！</p><h1 id="26ec" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated"><strong class="ak">参考文献</strong></h1><ul class=""><li id="6aa0" class="mo mp it lb b lc ob lf oc li pk lm pl lq pm lu mt mu mv mw bi translated"><a class="ae ky" href="https://project.inria.fr/gudhi/" rel="noopener ugc nofollow" target="_blank"> <em class="mn">骨质包</em> </a></li><li id="bb8c" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated"><a class="ae ky" href="https://geometrica.saclay.inria.fr/team/Steve.Oudot/papers/cgos-pbc-09/cgos-pbcrm-11.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="mn">黎曼流形中基于持久性的聚类</em> </a></li><li id="ef41" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated"><a class="ae ky" href="https://hal.inria.fr/hal-00707901v1/document" rel="noopener ugc nofollow" target="_blank"> <em class="mn">单形树:一般单形复形的有效数据结构</em> </a></li></ul></div></div>    
</body>
</html>