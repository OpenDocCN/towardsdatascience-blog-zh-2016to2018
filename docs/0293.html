<html>
<head>
<title>Transfer learning using pytorch — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 pytorch 迁移学习—第 1 部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/transfer-learning-using-pytorch-4c3475f4495?source=collection_archive---------0-----------------------#2017-04-13">https://towardsdatascience.com/transfer-learning-using-pytorch-4c3475f4495?source=collection_archive---------0-----------------------#2017-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="340f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有没有想过为什么 ML 模特每次都要从头学起？如果模型可以利用从识别猫、狗、鱼、汽车、公共汽车和许多其他事物中学到的知识来识别分心的汽车司机或识别植物疾病，会怎么样？在迁移学习中，我们使用预训练的神经网络来提取特征，并为特定用例训练新模型。不确定是什么..等到博客结束就好了。</p><h1 id="a1d4" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">为什么是 PyTorch</h1><p id="644d" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">有很多框架像 Keras，Tensoflow，Theano，Torch，Deeplearning.4J 等都可以用于深度学习。在所有这些中，我最喜欢的是 Tensorflow 上的 Keras。Keras 适用于许多成熟的架构，如 CNN、前馈神经网络、用于时间序列的 Lstm，但当您试图实现本质上复杂的新架构时，它会变得有点棘手。由于 Keras 是以良好的模块化方式构建的，因此缺乏灵活性。Pytorch 是一个新成员，它为我们提供了以面向对象的方式构建各种深度学习模型的工具，因此提供了很大的灵活性。最近 PyTorch 正在实现许多复杂的架构。所以我开始探索 PyTorch，在这篇博客中，我们将介绍用很小的数据集和几行代码构建一个最先进的分类器是多么容易。</p><p id="9987" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用以下步骤构建一个用于检测蚂蚁和蜜蜂的分类器。</p><ol class=""><li id="e9e0" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">从<a class="ae lx" href="https://download.pytorch.org/tutorial/hymenoptera_data.zip" rel="noopener ugc nofollow" target="_blank">这里</a>下载数据集。</li></ol><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/1e62ec2d93155d78f5df829a5dece85a.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*00H4V_so4YYeQCGfN5cyjw.png"/></div></figure><p id="31a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.数据增强。</p><p id="f0f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.下载预训练的 resnet 模型(迁移学习)。</p><p id="2717" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.在数据集上训练模型。</p><p id="1cda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.如何衰减每第 n 个<em class="mg">时期的学习率。</em></p><h2 id="3882" class="mh km iq bd kn mi mj dn kr mk ml dp kv jy mm mn kz kc mo mp ld kg mq mr lh ms bi translated">下载数据集:</h2><p id="ec59" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">从上面的链接下载数据集。它包含训练数据集中的 224 幅图像和验证数据集中的 153 幅图像。</p><h2 id="41b6" class="mh km iq bd kn mi mj dn kr mk ml dp kv jy mm mn kz kc mo mp ld kg mq mr lh ms bi translated">数据扩充:</h2><p id="d2e8" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">数据扩充是对现有照片进行更改的过程，如调整颜色、水平或垂直翻转、缩放、裁剪等。Pytorch 提供了一个非常有用的名为 torchvision.transforms 的库，它提供了许多有助于应用数据扩充的方法。transforms 附带了一个 compose 方法，它接受一个转换列表。</p><pre class="lz ma mb mc gt mt mu mv mw aw mx bi"><span id="299e" class="mh km iq mu b gy my mz l na nb">data_transforms <strong class="mu ir">=</strong> {</span><span id="2177" class="mh km iq mu b gy nc mz l na nb">    'train': transforms<strong class="mu ir">.</strong>Compose([<br/>        transforms<strong class="mu ir">.</strong>RandomSizedCrop(224),<br/>        transforms<strong class="mu ir">.</strong>RandomHorizontalFlip(),<br/>        transforms<strong class="mu ir">.</strong>ToTensor(),<br/>        transforms<strong class="mu ir">.</strong>Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])<br/>    ]),<br/>    'val': transforms<strong class="mu ir">.</strong>Compose([<br/>        transforms<strong class="mu ir">.</strong>Scale(256),<br/>        transforms<strong class="mu ir">.</strong>CenterCrop(224),<br/>        transforms<strong class="mu ir">.</strong>ToTensor(),<br/>        transforms<strong class="mu ir">.</strong>Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])<br/>    ]),<br/>}</span></pre><h2 id="5201" class="mh km iq bd kn mi mj dn kr mk ml dp kv jy mm mn kz kc mo mp ld kg mq mr lh ms bi translated">迁移学习:</h2><p id="6d80" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我们将使用微软的 ResNet 模型，该模型在 2015 年赢得了 ImageNet 竞赛。它展示了深层网络是如何成为可能的。让我们不要进入 ResNet 的复杂性。我们将下载模型，大多数现代深度学习框架使加载模型更容易。ResNet 模型包括一组 ResNet 块(卷积和单位块的组合)和一个完全连接的层。该模型在 1000 个类别的 Imagenet 数据集上进行训练，我们将移除最后一个完全连接的层，并添加一个新的完全连接的层，该层输出 2 个类别，这表明图像是蚂蚁或蜜蜂的概率。</p><pre class="lz ma mb mc gt mt mu mv mw aw mx bi"><span id="e32e" class="mh km iq mu b gy my mz l na nb">model_conv <strong class="mu ir">=</strong> torchvision<strong class="mu ir">.</strong>models<strong class="mu ir">.</strong>resnet18(pretrained<strong class="mu ir">=</strong>True)<br/><strong class="mu ir">for</strong> param <strong class="mu ir">in</strong> model_conv<strong class="mu ir">.</strong>parameters():    ----&gt; 1<br/>    param<strong class="mu ir">.</strong>requires_grad <strong class="mu ir">=</strong> False<br/><br/><em class="mg"># Parameters of newly constructed modules have requires_grad=True by default</em><br/>num_ftrs <strong class="mu ir">=</strong> model_conv<strong class="mu ir">.</strong>fc<strong class="mu ir">.</strong>in_features<br/>model_conv<strong class="mu ir">.</strong>fc <strong class="mu ir">=</strong> nn<strong class="mu ir">.</strong>Linear(num_ftrs, 2)   ----&gt; 2</span><span id="ce48" class="mh km iq mu b gy nc mz l na nb"><strong class="mu ir">if</strong> use_gpu:<br/>    model_conv <strong class="mu ir">=</strong> model_conv<strong class="mu ir">.</strong>cuda()       ----&gt; 3</span></pre><ol class=""><li id="3713" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">我们告诉模型不要学习或修改模型的权重/参数。</li><li id="6278" class="lo lp iq jp b jq nd ju ne jy nf kc ng kg nh kk lt lu lv lw bi translated">然后，我们向现有模型添加一个新的全连接层，以训练我们的模型对 2 个类别进行分类。</li><li id="09c8" class="lo lp iq jp b jq nd ju ne jy nf kc ng kg nh kk lt lu lv lw bi translated">如果你有 gpu 的话。cuda()在 GPU 中执行模型。</li></ol><p id="f7a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的模型已经准备好了，我们需要将数据传递给训练。</p><h2 id="b44c" class="mh km iq bd kn mi mj dn kr mk ml dp kv jy mm mn kz kc mo mp ld kg mq mr lh ms bi translated">培训模式:</h2><p id="3323" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">对于培训模型，除了模型之外，我们还需要几样东西，例如:</p><ol class=""><li id="b8e6" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">PyTorch 变量:包装 pytorch 张量的变量。它包含数据和与数据相关的梯度。</li><li id="e9d8" class="lo lp iq jp b jq nd ju ne jy nf kc ng kg nh kk lt lu lv lw bi translated">损失函数:它有助于计算我们的模型有多好。我们将在这里使用分类交叉熵。</li><li id="2470" class="lo lp iq jp b jq nd ju ne jy nf kc ng kg nh kk lt lu lv lw bi translated">优化器:我们将使用 SGD 来优化我们的梯度权重。在我们的例子中，我们只更新最后一层的权重。</li><li id="1fc6" class="lo lp iq jp b jq nd ju ne jy nf kc ng kg nh kk lt lu lv lw bi translated">正向传播:这是我们通过模型传递数据的最简单的部分。</li><li id="e037" class="lo lp iq jp b jq nd ju ne jy nf kc ng kg nh kk lt lu lv lw bi translated">反向传播:这是现代深度学习网络的关键，所有神奇的事情都发生在这里。其中优化器开始计算需要更新多少权重以减少损失或提高准确性。在大多数现代框架中，这是自动化的，因此我们可以专注于构建由深度学习支持的酷应用程序。</li></ol><pre class="lz ma mb mc gt mt mu mv mw aw mx bi"><span id="7273" class="mh km iq mu b gy my mz l na nb">if use_gpu:<br/>    inputs, labels = Variable(inputs.cuda()), Variable(labels.cuda()) --&gt; 1<br/>else:<br/>    inputs, labels = Variable(inputs), Variable(labels)</span><span id="2df5" class="mh km iq mu b gy nc mz l na nb">criterion = nn.CrossEntropyLoss() --&gt; 2</span><span id="ffb9" class="mh km iq mu b gy nc mz l na nb"># Observe that all parameters are being optimized<br/>optimizer_ft = optim.SGD(model_ft.parameters(), lr=0.001, momentum=0.9) --&gt;3</span><span id="0997" class="mh km iq mu b gy nc mz l na nb"># zero the parameter gradients<br/>optimizer.zero_grad()</span><span id="dc3d" class="mh km iq mu b gy nc mz l na nb"># forward <br/>outputs = model(inputs) --&gt; 4<br/>loss = criterion(outputs, labels)</span><span id="4f6b" class="mh km iq mu b gy nc mz l na nb"># backward + optimize only if in training phase<br/>if phase == 'train': --&gt; 5<br/>    loss.backward()<br/>    optimizer.step()</span></pre><h2 id="7fa2" class="mh km iq bd kn mi mj dn kr mk ml dp kv jy mm mn kz kc mo mp ld kg mq mr lh ms bi translated">衰减学习率:</h2><p id="91c4" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">大多数情况下，我们以较高的学习速率开始，这样我们可以更快地减少损失，然后在几个时期后，你想减少它，这样学习变得更慢。我发现 pytorch <a class="ae lx" href="http://pytorch.org/tutorials/beginner/transfer_learning_tutorial.html" rel="noopener ugc nofollow" target="_blank">教程</a>中的这个函数非常有用。</p><pre class="lz ma mb mc gt mt mu mv mw aw mx bi"><span id="d170" class="mh km iq mu b gy my mz l na nb"><strong class="mu ir">def</strong> <strong class="mu ir">lr_scheduler</strong>(optimizer, epoch, init_lr<strong class="mu ir">=</strong>0.001, lr_decay_epoch<strong class="mu ir">=</strong>7):<br/>    """Decay learning rate by a factor of 0.1 every lr_decay_epoch epochs."""<br/>    lr <strong class="mu ir">=</strong> init_lr <strong class="mu ir">*</strong> (0.1<strong class="mu ir">**</strong>(epoch <strong class="mu ir">//</strong> lr_decay_epoch))<br/><br/>    <strong class="mu ir">if</strong> epoch <strong class="mu ir">%</strong> lr_decay_epoch <strong class="mu ir">==</strong> 0:<br/>        <strong class="mu ir">print</strong>('LR is set to {}'<strong class="mu ir">.</strong>format(lr))<br/><br/>    <strong class="mu ir">for</strong> param_group <strong class="mu ir">in</strong> optimizer<strong class="mu ir">.</strong>param_groups:<br/>        param_group['lr'] <strong class="mu ir">=</strong> lr<br/><br/>    <strong class="mu ir">return</strong> optimizer</span></pre><p id="e456" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将每第 n 个时段的学习率降低，在上面的示例 7 中为 0.1。decay_rate 是可配置的。即使在较小的数据集上，我们也可以使用这种方法获得最先进的结果。</p><p id="b962" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想用 pytorch 在你的数据集上尝试迁移学习，代码驻留在<a class="ae lx" href="http://pytorch.org/tutorials/beginner/transfer_learning_tutorial.html" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="c9f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对学习深度学习感兴趣的人，不要忘了看看令人惊叹的 MOOC <a class="ae lx" href="http://course.fast.ai/" rel="noopener ugc nofollow" target="_blank">深度学习，作者是<a class="ae lx" href="https://medium.com/@jeremyphoward" rel="noopener">杰瑞米·霍华德</a>的程序员</a>。</p><p id="b00a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae lx" href="https://medium.com/@vishnuvig/transfer-learning-using-pytorch-part-2-9c5b18e15551" rel="noopener">的下一部分</a>中，我们将讨论如何使用 VGG 更快地进行迁移学习的不同技巧。并比较它在 PyTorch 和 Tensorflow 中的表现。</p></div></div>    
</body>
</html>