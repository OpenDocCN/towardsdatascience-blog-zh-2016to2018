<html>
<head>
<title>Recursive Rolling Calculations with Ramda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Ramda 进行递归滚动计算</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/recursive-rolling-calculations-with-ramda-adf494958a37?source=collection_archive---------23-----------------------#2018-09-27">https://towardsdatascience.com/recursive-rolling-calculations-with-ramda-adf494958a37?source=collection_archive---------23-----------------------#2018-09-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9743" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在函数式编程范式中使用递归来创建移动平均值很有趣</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6d5c9600d871dc4decd898b0aeabad47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*maGGeNUuiK9I6njl2V9h3w.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by stokpic via Pixabay.com (https://pixabay.com/users/stokpic-692575/)</figcaption></figure><p id="b9d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于对随时间波动的数据集感兴趣的人来说，滚动平均或移动平均是最受欢迎的趋势指标之一。对于交易者来说尤其如此，他们总是在金融市场的不断变化中努力解读趋势信号。</p><p id="9bef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文面向具有数据科学背景，并且有兴趣学习更多关于函数式编程方法的人。递归是一个需要花费一些时间和思想来理解的概念，所以我想展示一个在现实世界中使用递归的实用方法。</p><p id="6ffe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我的主要目标是使用递归的函数方法而不是“for 循环”来计算移动平均线(特别是指数移动平均线)。我将非常依赖 Ramda.js，这是一个非常有用的函数式 Javascript 库。</p><h2 id="9410" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">递归</h2><p id="995c" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我假设这篇文章的读者熟悉移动平均线，所以让我们直接跳到递归。这个帖子的灵感直接来源于<a class="ae mp" href="https://medium.com/ventre-tech/recursion-made-simple-with-roman-numerals-4ae3cab27755" rel="noopener">这篇文章</a>和<a class="ae mp" href="https://medium.com/ventre-tech/haskells-triangle-or-more-fun-with-recursion-9350155689ac" rel="noopener">这篇文章</a>。在 Google 中输入“递归”会得到如下定义:</p><blockquote class="mq mr ms"><p id="8de2" class="kv kw mt kx b ky kz jr la lb lc ju ld mu lf lg lh mv lj lk ll mw ln lo lp lq ij bi translated">递归过程或定义的重复应用</p></blockquote><p id="4f05" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个递归定义——酷！</p><p id="0add" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">递归函数是根据自身定义的函数。考虑递归函数的另一种方式是，它调用自己——直到它不调用为止。运行<code class="fe mx my mz na b">const squareMe = n =&gt; squareMe(n*n)</code>会一遍又一遍的运行，迅速吹爆你的调用栈。</p><p id="f0d5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是为什么我们需要一个“基本情况”，这是一个定义函数何时终止的条件。</p><p id="aad0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，递归函数实际上需要调用自身，这被称为“递归”</p><p id="d09f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，为了做任何有用的事情，递归函数需要有一个“动作”</p><p id="bcd6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了演示递归函数的这三个组成部分，让我们编写一个从 1 数到给定数字的函数:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="76f7" class="lr ls iq na b gy nf ng l nh ni">// ES6<br/>const countTo = (num, arr=[], startingN=1) =&gt; {<br/>  // Base case:<br/>  if (arr.length === num) return arr;<br/>  // Recursion and action:<br/>  return countTo(num, arr.concat(startingN), startingN + 1); <br/>};</span></pre><p id="5325" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">调用<code class="fe mx my mz na b">countTo(10)</code>返回<code class="fe mx my mz na b">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>，通过调用动作(<code class="fe mx my mz na b">arr.concat</code>和<code class="fe mx my mz na b">startingN+1</code>)递归调用自身，直到遇到基本情况<code class="fe mx my mz na b">arr.length === num</code>时终止。</p><p id="ad0f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">耶！没有循环了！</p><p id="1c50" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">递归是 for 循环的一种替代方法，也是一种更实用的遍历数据集以获得所需结果的方法。</p><h2 id="128f" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">拉姆达</h2><p id="2521" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">Ramda.js 是一个轻量级的、功能性的 Javascript 库，它是为那些希望保持代码纯净和功能性、函数不可变和没有副作用的人而设计的。哦，还有<em class="mt">数据排在最后</em>——这样更好。</p><h1 id="8e43" class="nj ls iq bd lt nk nl nm lw nn no np lz jw nq jx mc jz nr ka mf kc ns kd mi nt bi translated">简单移动平均线</h1><p id="fbab" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">让我们从一系列数字的简单移动平均开始:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="31af" class="lr ls iq na b gy nf ng l nh ni">//ES6<br/>import R from 'ramda';</span><span id="2ed5" class="lr ls iq na b gy nu ng l nh ni">const sma = (num, data, arr = []) =&gt; {<br/>  if (data.length === 0) return arr;<br/>  if (data.length &lt; num) return sma(<br/>    num,<br/>    data.slice(1), <br/>    R.prepend('not yet!', arr),<br/>  );<br/>  const newData = R.tail(data);<br/>  const movingMean = R.mean(<br/>    R.slice(0, num, data)<br/>  );<br/>  return sma(<br/>    num,<br/>    newData,<br/>    R.append(movingMean, arr)<br/>  );<br/>};</span></pre><p id="6d85" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个功能有三个部分。</p><p id="ae58" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦<code class="fe mx my mz na b">data</code>参数的长度达到 0，第一个<code class="fe mx my mz na b">if</code>语句就返回<code class="fe mx my mz na b">arr</code>。这是“基本情况”。</p><p id="7ee0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当<code class="fe mx my mz na b">data</code>参数的长度小于<code class="fe mx my mz na b">num</code>参数的长度时，第二个<code class="fe mx my mz na b">if</code>语句递归调用<code class="fe mx my mz na b">sma</code>，使用 Ramda 的<code class="fe mx my mz na b">prepend</code>添加‘还没有！’串到<code class="fe mx my mz na b">arr</code>前面。</p><p id="fbbb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后的<code class="fe mx my mz na b">return</code>语句是这个函数的核心。它将 Ramda 的<code class="fe mx my mz na b">mean</code>函数应用于<code class="fe mx my mz na b">newData</code>的适当元素，每次返回一个新的<code class="fe mx my mz na b">arr</code>并附加平均值。</p><p id="2c39" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里要强调的最后一点是，每次函数调用自己时，它是如何在<code class="fe mx my mz na b">newData</code>上这样做的，它只是返回<code class="fe mx my mz na b">data</code>而没有第一个元素(<code class="fe mx my mz na b">R.tail</code>)。让我们在每个<code class="fe mx my mz na b">return</code>语句之前添加一个<code class="fe mx my mz na b">console.log</code>语句，这样我们就可以确切地看到<code class="fe mx my mz na b">sma</code>内部发生了什么:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4aa7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这显示了调用<code class="fe mx my mz na b">sma</code>时的确切情况。在该函数第一次运行后，它返回一个带有首字母<code class="fe mx my mz na b">data</code>的前三个数字的平均值的<code class="fe mx my mz na b">arr</code>的副本。该函数第二次运行时，将返回第一个元素被切掉的<code class="fe mx my mz na b">arr</code>副本的前三个数字的平均值。</p><p id="e840" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你明白了！</p><p id="8775" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，在递归过程的最后，<code class="fe mx my mz na b">'not yet'</code>字符串必须加在<code class="fe mx my mz na b">arr</code>的前面。此外，由于这些是占位符，我们没有得到实际值，这就引出了本文的下一步:指数移动平均线。</p><h1 id="37e9" class="nj ls iq bd lt nk nl nm lw nn no np lz jw nq jx mc jz nr ka mf kc ns kd mi nt bi translated">指数移动平均线</h1><p id="3f78" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">到目前为止，我们已经介绍了递归的基本知识，并在 Ramda 的帮助下，将它们应用于创建一个简单的列表移动平均值。</p><p id="4af7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们以不同的方式处理这个概念，将它应用到现实世界的情况中。我们将使用 IEX API 从股票交易所获取一些纵向数据:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="bd7c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个函数从 IEX 交易 API 获取 AAPL 数据，并返回一个带有<code class="fe mx my mz na b">date</code>和<code class="fe mx my mz na b">value</code>的对象列表。该数据集的图表如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/545e478499a072b7822916e2f522caa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DM7z3bohG6hptfk663eCew.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by author</figcaption></figure><p id="5f96" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们需要编写一个函数，给出这个数据集的指数加权移动平均，为此，我们将使用吴恩达在这里提出的指数加权移动平均。把它写成一个 javascript 函数看起来是这样的【第 8 行】:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="39be" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">哇哦。让我们把这个拆开。</p><p id="0fb2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，<code class="fe mx my mz na b">ewa</code>有两个参数- <code class="fe mx my mz na b">decay</code>是您想要权衡的天数，而<code class="fe mx my mz na b">data</code>是您想要操作的对象列表。接下来，<code class="fe mx my mz na b">ewa</code>定义了<code class="fe mx my mz na b">beta</code>，它是使用一点指数代数从<code class="fe mx my mz na b">decay</code>计算出来的，本质上控制算法的平滑。</p><p id="7917" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">函数<code class="fe mx my mz na b">checkArr</code>是算法的神奇之处。在<code class="fe mx my mz na b">ewa</code>的第一次迭代中，<code class="fe mx my mz na b">arr</code>为空，因此<code class="fe mx my mz na b">checkArr</code>只是将新<code class="fe mx my mz na b">arr</code>的第一个元素的<code class="fe mx my mz na b">value</code>设置为<code class="fe mx my mz na b">data</code>[第 7 行]中的第一个<code class="fe mx my mz na b">value</code>。没有之前的数据点来指数加权！在其余的<code class="fe mx my mz na b">ewa</code>递归调用中，<code class="fe mx my mz na b">checkArr</code>返回算法中由<code class="fe mx my mz na b">beta</code>控制的加权值，因为<code class="fe mx my mz na b">arr</code>不再为空。</p><p id="6bf7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们可以在图表中添加一个<code class="fe mx my mz na b">ewa(20, getData())</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/0d4117b382f5228d2b59d39bd690a8c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FgJ_WAjWvF0u25FA9J9rfg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by author</figcaption></figure><h2 id="a144" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">更多拉姆达！</h2><p id="46b0" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在函数式编程中,“curried”函数是这样一种函数，如果提供的参数少于它所需要的参数，它将返回一个采用剩余参数的新函数。当您需要编写新函数时，这种技术非常有用。让我们使用拉姆达的<code class="fe mx my mz na b">curry</code>函数来创建一堆不同的<code class="fe mx my mz na b">ewa</code>函数:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="0099" class="lr ls iq na b gy nf ng l nh ni">const curriedEwa = R.curry(ewa);</span><span id="a871" class="lr ls iq na b gy nu ng l nh ni">const ewaTwenty = curriedEwa(20);</span><span id="40f0" class="lr ls iq na b gy nu ng l nh ni">const ewaFifty = curriedEwa(50);</span><span id="f924" class="lr ls iq na b gy nu ng l nh ni">const ewaHundred = curriedEwa(100);</span></pre><p id="5420" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，将<code class="fe mx my mz na b">ewaTwenty</code>、<code class="fe mx my mz na b">ewaFifty</code>和<code class="fe mx my mz na b">ewaHundred</code>制成图表给我们看:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/b64d27719f0d0f90bede63d65b82ed91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q-z3fRCB2E2C0IFOyoshrA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by author</figcaption></figure><p id="0a63" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">函数式编程 FTW！</p><p id="876b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有很多内容，我希望我已经帮助展示了递归和 Ramda 是多么有用。如果你还不熟悉这些概念，你可能需要一段时间来理解它们(至少对我来说是这样)。然而，我已经建立了一个<a class="ae mp" href="https://beta.observablehq.com/@johnwcothran/a-recursive-rolling-average-function-with-ramdajs" rel="noopener ugc nofollow" target="_blank">可观察笔记本</a>，在那里你可以深入探究这篇文章中的代码。</p></div></div>    
</body>
</html>