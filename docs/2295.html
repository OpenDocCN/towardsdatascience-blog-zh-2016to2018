<html>
<head>
<title>Categorical Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分类数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-feature-engineering-part-2-categorical-data-f54324193e63?source=collection_archive---------0-----------------------#2018-01-06">https://towardsdatascience.com/understanding-feature-engineering-part-2-categorical-data-f54324193e63?source=collection_archive---------0-----------------------#2018-01-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="2d18" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/tds-feature-engineering" rel="noopener" target="_blank">了解特征工程</a>(第二部分)</h2><div class=""/><div class=""><h2 id="d50b" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">处理离散分类数据的策略</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/4c3f2a08beb7d78286cec864bf4ac151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FgMeHrpzkMgDc1RCrl8JNw.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Source: <a class="ae le" href="https://pixabay.com" rel="noopener ugc nofollow" target="_blank">https://pixabay.com</a></figcaption></figure><h1 id="f089" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">介绍</h1><p id="d290" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">我们在本系列的前一篇文章<a class="ae le" rel="noopener" target="_blank" href="/understanding-feature-engineering-part-1-continuous-numeric-data-da4e47099a7b"><em class="mt"/></a><em class="mt">中介绍了处理结构化连续数字数据的各种特征工程策略。在本文中，我们将关注另一种类型的结构化数据，这种数据本质上是离散的，通常被称为分类数据。处理数字数据通常比分类数据更容易，因为我们不必处理与任何分类类型的数据属性中的每个类别值相关的额外的复杂语义。我们将使用实践方法来讨论处理分类数据的几种编码方案，以及处理大规模特征爆炸的几种流行技术，通常称为<a class="ae le" href="https://en.wikipedia.org/wiki/Curse_of_dimensionality" rel="noopener ugc nofollow" target="_blank"> <em class="mt">【维数灾难】</em> </a>。</em></p><h1 id="35d9" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">动机</h1><p id="8627" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">我相信到现在你一定意识到特征工程的动机和重要性，我们在本系列的<a class="ae le" rel="noopener" target="_blank" href="/understanding-feature-engineering-part-1-continuous-numeric-data-da4e47099a7b"> <strong class="lz ja"> <em class="mt">【第一部分】</em> </strong> </a>中做了同样详细的强调。如果有必要的话，一定要检查一下，快速复习一下。简而言之，机器学习算法不能直接处理分类数据，在开始对数据建模之前，您需要对这些数据进行一些工程和转换。</p><h1 id="c23b" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">理解分类数据</h1><p id="e465" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在深入特性工程策略之前，让我们先了解一下分类数据表示。通常，任何本质上是分类的数据属性都表示属于特定有限类别集的离散值。在由模型预测的属性或变量(通常称为响应变量)的上下文中，这些通常也称为类或标签。这些离散值本质上可以是文本或数字(甚至是像图像这样的非结构化数据！).分类数据有两大类，名义数据和序数数据。</p><p id="d61e" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">在任何名义分类数据属性中，该属性的值之间没有排序的概念。考虑一个简单的天气类别示例，如下图所示。我们可以看到，在这个特定的场景中，我们有六个主要的类别或种类，没有任何顺序的概念或概念(<em class="mt">多风</em>并不总是发生在<em class="mt">晴朗</em>之前，也不小于或大于<em class="mt">晴朗</em>)。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mz"><img src="../Images/70cbf5bab1017ccd57c89b77acf95e8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iKsDex5fUBQoYTju.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Weather as a categorical attribute</figcaption></figure><p id="7ae1" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">类似地，电影、音乐和视频游戏类型、国家名称、食物和烹饪类型是其他名义分类属性的例子。</p><p id="76b0" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">有序分类属性在其值中具有某种意义或顺序概念。例如，请看下图中的衬衫尺寸。很明显，当考虑衬衫时，顺序或者在这种情况下的<em class="mt">‘size’</em>很重要(<strong class="lz ja"> <em class="mt"> S </em> </strong>小于<strong class="lz ja"> <em class="mt"> M </em> </strong>，M  小于<strong class="lz ja"> <em class="mt"> L </em> </strong>等等)。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi na"><img src="../Images/0ae0a411a2a7650d4151c125ae9cf7b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*ychLO4DAe5cvD1UwUuvjZw.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Shirt size as an ordinal categorical attribute</figcaption></figure><p id="ea70" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">鞋号、教育水平和就业角色是有序分类属性的一些其他示例。对分类数据有了一个很好的概念，现在让我们看看一些特征工程策略。</p><h1 id="1d37" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">分类数据的特征工程</h1><p id="ba20" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">虽然在各种机器学习框架中已经取得了很多进步，以接受复杂的分类数据类型，如文本标签。典型地，特征工程中的任何标准工作流程都涉及将这些分类值的某种形式的<strong class="lz ja"> <em class="mt">转换</em> </strong>为数字标签，然后对这些值应用某种<strong class="lz ja"> <em class="mt">编码方案</em> </strong>。开始之前，我们把必要的必需品都装了起来。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="ebf5" class="ng lg iq nc b gy nh ni l nj nk">import pandas as pd<br/>import numpy as np</span></pre><h2 id="4ce8" class="ng lg iq bd lh nl nm dn ll nn no dp lp mg np nq lr mk nr ns lt mo nt nu lv iw bi translated">转换名义属性</h2><p id="83e2" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">名义属性由离散的分类值组成，它们之间没有概念或顺序感。这里的想法是将这些属性转换成更具代表性的数字格式，以便下游代码和管道能够轻松理解。让我们来看一个关于视频游戏销售的新数据集。这个数据集也可以在<a class="ae le" href="https://www.kaggle.com/gregorut/videogamesales" rel="noopener ugc nofollow" target="_blank"><strong class="lz ja"/></a>以及我的<a class="ae le" href="https://github.com/dipanjanS/practical-machine-learning-with-python/tree/master/notebooks/Ch04_Feature_Engineering_and_Selection" rel="noopener ugc nofollow" target="_blank"><strong class="lz ja">GitHub</strong></a><strong class="lz ja"/>资源库中找到。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="cda0" class="ng lg iq nc b gy nh ni l nj nk">vg_df = pd.read_csv('datasets/vgsales.csv', encoding='utf-8')<br/>vg_df[['Name', 'Platform', 'Year', 'Genre', 'Publisher']].iloc[1:7]</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/b5e917e7e554ecef4a899619180504e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*XlsFdg01yZh1IMPhmhw3Wg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Dataset for video game sales</figcaption></figure><p id="222d" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">让我们关注上面数据框中描述的视频游戏<code class="fe nw nx ny nc b">Genre</code>属性。很明显，这是一个名词性的范畴属性，就像<code class="fe nw nx ny nc b">Publisher</code>和<code class="fe nw nx ny nc b">Platform</code>一样。我们可以很容易地得到独特的视频游戏类型列表如下。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="75cb" class="ng lg iq nc b gy nh ni l nj nk">genres = np.unique(vg_df['Genre'])<br/>genres</span><span id="7453" class="ng lg iq nc b gy nz ni l nj nk"><strong class="nc ja">Output<br/>------</strong><br/>array(['Action', 'Adventure', 'Fighting', 'Misc', 'Platform',  <br/>       'Puzzle', 'Racing', 'Role-Playing', 'Shooter', 'Simulation',  <br/>       'Sports', 'Strategy'], dtype=object)</span></pre><p id="71c6" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">这告诉我们，我们有12种不同的视频游戏类型。我们现在可以生成一个标签编码方案，通过利用<code class="fe nw nx ny nc b">scikit-learn</code>将每个类别映射到一个数值。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="6cfe" class="ng lg iq nc b gy nh ni l nj nk">from sklearn.preprocessing import LabelEncoder</span><span id="1c1a" class="ng lg iq nc b gy nz ni l nj nk">gle = LabelEncoder()<br/>genre_labels = gle.fit_transform(vg_df['Genre'])<br/>genre_mappings = {index: label for index, label in <br/>                  enumerate(gle.classes_)}<br/>genre_mappings<br/></span><span id="cd57" class="ng lg iq nc b gy nz ni l nj nk"><strong class="nc ja">Output<br/>------<br/></strong>{0: 'Action', 1: 'Adventure', 2: 'Fighting', 3: 'Misc',<br/> 4: 'Platform', 5: 'Puzzle', 6: 'Racing', 7: 'Role-Playing',<br/> 8: 'Shooter', 9: 'Simulation', 10: 'Sports', 11: 'Strategy'}</span></pre><p id="4c92" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">因此，在<code class="fe nw nx ny nc b">LabelEncoder</code>对象<code class="fe nw nx ny nc b">gle</code>的帮助下，生成了一个映射方案，其中每个流派值被映射到一个数字。转换后的标签存储在<code class="fe nw nx ny nc b">genre_labels</code>值中，我们可以将该值写回到我们的数据框中。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="d2e9" class="ng lg iq nc b gy nh ni l nj nk">vg_df['GenreLabel'] = genre_labels<br/>vg_df[['Name', 'Platform', 'Year', 'Genre', 'GenreLabel']].iloc[1:7]</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/cb19216d2d79454aa9067b9016979acb.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*_dhZ4-lsPVUzRdHUWbtBNQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Video game genres with their encoded labels</figcaption></figure><p id="fa00" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">如果您计划将这些标签用作预测的响应变量，则可以直接使用这些标签，尤其是在像<code class="fe nw nx ny nc b">scikit-learn</code>这样的框架中，但是如前所述，在将它们用作特性之前，我们需要对它们进行额外的编码。</p><h2 id="0322" class="ng lg iq bd lh nl nm dn ll nn no dp lp mg np nq lr mk nr ns lt mo nt nu lv iw bi translated">转换序数属性</h2><p id="5b9d" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">序数属性是在值之间有顺序感的分类属性。让我们考虑一下我们的<a class="ae le" href="https://www.kaggle.com/abcsds/pokemon/data" rel="noopener ugc nofollow" target="_blank"> <strong class="lz ja"> <em class="mt">神奇宝贝数据集</em> </strong> </a>，我们在本系列的<a class="ae le" rel="noopener" target="_blank" href="/understanding-feature-engineering-part-1-continuous-numeric-data-da4e47099a7b"> <strong class="lz ja">第1部分</strong> </a>中使用过。让我们更具体地关注一下<code class="fe nw nx ny nc b">Generation</code>属性。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="ccf2" class="ng lg iq nc b gy nh ni l nj nk">poke_df = pd.read_csv('datasets/Pokemon.csv', encoding='utf-8')<br/>poke_df = poke_df.sample(random_state=1, <br/>                         frac=1).reset_index(drop=True)</span><span id="de63" class="ng lg iq nc b gy nz ni l nj nk">np.unique(poke_df['Generation'])</span><span id="a7bf" class="ng lg iq nc b gy nz ni l nj nk"><strong class="nc ja">Output<br/>------</strong><br/>array(['Gen 1', 'Gen 2', 'Gen 3', 'Gen 4', 'Gen 5', 'Gen 6'], <br/>         dtype=object)</span></pre><p id="7acb" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">根据上面的输出，我们可以看到总共有<strong class="lz ja"> 6 </strong>代，每个神奇宝贝通常都属于基于视频游戏的特定一代(当它们被发布时),电视连续剧也遵循类似的时间线。这个属性通常是顺序的(领域知识在这里是必要的)，因为大多数属于第1代的神奇宝贝在视频游戏和电视节目中比第2代更早出现，等等。粉丝们可以看看下图，记住每一代流行的一些神奇宝贝(粉丝们的看法可能会有所不同！).</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/648c46c0f1de13b7730cb1454f7905a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zQCDjMFdx-4uo3ec.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Popular Pokémon based on generation and type (source: <a class="ae le" href="https://www.reddit.com/r/pokemon/comments/2s2upx/heres_my_favorite_pokemon_by_type_and_gen_chart" rel="noopener ugc nofollow" target="_blank">https://www.reddit.com/r/pokemon/comments/2s2upx/heres_my_favorite_pokemon_by_type_and_gen_chart</a>)</figcaption></figure><p id="eef5" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">因此他们有一种秩序感。一般来说，没有通用的模块或函数来根据订单自动将这些特征映射和转换成数字表示。因此，我们可以使用自定义编码\映射方案。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="1eca" class="ng lg iq nc b gy nh ni l nj nk">gen_ord_map = {'Gen 1': 1, 'Gen 2': 2, 'Gen 3': 3, <br/>               'Gen 4': 4, 'Gen 5': 5, 'Gen 6': 6}</span><span id="1444" class="ng lg iq nc b gy nz ni l nj nk">poke_df['GenerationLabel'] = poke_df['Generation'].map(gen_ord_map)<br/>poke_df[['Name', 'Generation', 'GenerationLabel']].iloc[4:10]</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/72e07df92ba4802b65babb34f21664a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*IKqNF9wJ11xdlIT5-EQ50Q.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Pokémon generation encoding</figcaption></figure><p id="f01b" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">从上面的代码中可以明显看出，<code class="fe nw nx ny nc b">pandas</code>中的<code class="fe nw nx ny nc b">map(…)</code>函数在转换这个顺序特性时很有帮助。</p><h2 id="6057" class="ng lg iq bd lh nl nm dn ll nn no dp lp mg np nq lr mk nr ns lt mo nt nu lv iw bi translated">编码分类属性</h2><p id="827d" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">如果您还记得我们之前提到的内容，分类数据的特征工程通常包括我们在上一节中描述的转换过程和强制编码过程，在该过程中，我们应用特定的编码方案为特定分类属性中的每个类别\值创建虚拟变量或特征。</p><p id="3041" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">您可能想知道，我们在前面的部分中刚刚将类别转换为数字标签，现在我们究竟为什么需要它呢？原因很简单。考虑到视频游戏流派，如果我们直接将<code class="fe nw nx ny nc b">GenreLabel</code>属性作为机器学习模型中的一个特征，它会认为它是一个连续的数字特征，认为值<strong class="lz ja"> 10 </strong> ( <em class="mt">体育</em>)大于<strong class="lz ja"> 6 </strong> ( <em class="mt">赛车</em>)，但这是没有意义的，因为<em class="mt">体育</em>流派肯定不会大于或小于<em class="mt">赛车</em>，这些是本质上不同的值或类别，不能直接进行比较。因此，我们需要一个额外的编码方案层，其中为每个属性的所有不同类别中的每个唯一值或类别创建虚拟特征。</p><h2 id="2a4f" class="ng lg iq bd lh nl nm dn ll nn no dp lp mg np nq lr mk nr ns lt mo nt nu lv iw bi translated">独热编码方案</h2><p id="1f34" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">考虑到我们具有带有<strong class="lz ja"> <em class="mt"> m </em> </strong>标签的任何分类属性的数字表示(转换后)，一键编码方案将属性编码或转换为<strong class="lz ja"> <em class="mt"> m </em> </strong>二进制特征，其只能包含值1或0。因此，分类特征中的每个观察结果都被转换成大小为<strong class="lz ja"> <em class="mt"> m </em> </strong>的向量，其中只有一个值为<strong class="lz ja"> 1 </strong>(表示它是活动的)。让我们取一个描述两个感兴趣的属性的神奇宝贝数据集的子集。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="52e4" class="ng lg iq nc b gy nh ni l nj nk">poke_df[['Name', 'Generation', 'Legendary']].iloc[4:10]</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi od"><img src="../Images/efe8c624496882266c38e85868f442cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*keUxOv3nOszfDf8BmD4iyQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Subset of our Pokémon dataset</figcaption></figure><p id="048e" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">感兴趣的属性是神奇宝贝<code class="fe nw nx ny nc b">Generation</code>和它们的<code class="fe nw nx ny nc b">Legendary</code>状态。第一步是<em class="mt">将</em>这些属性转换成基于我们之前所学的数字表示。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="40ed" class="ng lg iq nc b gy nh ni l nj nk">from sklearn.preprocessing import OneHotEncoder, LabelEncoder</span><span id="ac1e" class="ng lg iq nc b gy nz ni l nj nk"># transform and map pokemon generations<br/>gen_le = LabelEncoder()<br/>gen_labels = gen_le.fit_transform(poke_df['Generation'])<br/>poke_df['Gen_Label'] = gen_labels</span><span id="1a84" class="ng lg iq nc b gy nz ni l nj nk"># transform and map pokemon legendary status<br/>leg_le = LabelEncoder()<br/>leg_labels = leg_le.fit_transform(poke_df['Legendary'])<br/>poke_df['Lgnd_Label'] = leg_labels</span><span id="9c65" class="ng lg iq nc b gy nz ni l nj nk">poke_df_sub = poke_df[['Name', 'Generation', 'Gen_Label',  <br/>                       'Legendary', 'Lgnd_Label']]<br/>poke_df_sub.iloc[4:10]</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/f76d3b1a602a4acfa067842bdafe409a.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*vMZDgwJ1Fvzj-zOfGN21ug.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Attributes with transformed (numeric) labels</figcaption></figure><p id="4b29" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">特征<code class="fe nw nx ny nc b">Gen_Label</code>和<code class="fe nw nx ny nc b">Lgnd_Label</code>现在描述了我们的分类特征的数字表示。现在让我们对这些特性应用一键编码方案。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="a41f" class="ng lg iq nc b gy nh ni l nj nk"># encode generation labels using one-hot encoding scheme<br/>gen_ohe = OneHotEncoder()<br/>gen_feature_arr = gen_ohe.fit_transform(<br/>                              poke_df[['Gen_Label']]).toarray()<br/>gen_feature_labels = list(gen_le.classes_)<br/>gen_features = pd.DataFrame(gen_feature_arr, <br/>                            columns=gen_feature_labels)</span><span id="48d4" class="ng lg iq nc b gy nz ni l nj nk"># encode legendary status labels using one-hot encoding scheme<br/>leg_ohe = OneHotEncoder()<br/>leg_feature_arr = leg_ohe.fit_transform(<br/>                                poke_df[['Lgnd_Label']]).toarray()<br/>leg_feature_labels = ['Legendary_'+str(cls_label) <br/>                           for cls_label in leg_le.classes_]<br/>leg_features = pd.DataFrame(leg_feature_arr, <br/>                            columns=leg_feature_labels)</span></pre><p id="707c" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">一般来说，你总是可以使用<code class="fe nw nx ny nc b">fit_transform(…)</code>函数将两个特征编码在一起，方法是将两个特征的二维数组传递给它(查看<a class="ae le" href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html" rel="noopener ugc nofollow" target="_blank">文档</a>！).但是我们分别对每个特性进行编码，以便于理解。除此之外，我们还可以创建单独的数据框，并对其进行相应的标注。现在让我们连接这些特征框架，看看最终的结果。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="87e8" class="ng lg iq nc b gy nh ni l nj nk">poke_df_ohe = pd.concat([poke_df_sub, gen_features, leg_features], axis=1)<br/>columns = sum([['Name', 'Generation', 'Gen_Label'],   <br/>               gen_feature_labels, ['Legendary', 'Lgnd_Label'], <br/>               leg_feature_labels], [])<br/>poke_df_ohe[columns].iloc[4:10]</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi of"><img src="../Images/859034aa1344105a2909e8bff4fc6fab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WiBsYgBy-GGRZzvNUBvQFQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">One-hot encoded features for Pokémon generation and legendary status</figcaption></figure><p id="ce2e" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">因此，您可以看到为<code class="fe nw nx ny nc b">Generation</code>创建了<strong class="lz ja"> 6 </strong>虚拟变量或二进制特征，为<code class="fe nw nx ny nc b">Legendary</code>创建了<strong class="lz ja"> 2 </strong>虚拟变量或二进制特征，因为它们分别是这些属性中不同类别的总数。类别的<strong class="lz ja"> <em class="mt">活动</em> </strong>状态由这些虚拟变量之一的<strong class="lz ja"> 1 </strong>值表示，从上述数据帧中可以明显看出。</p><p id="7209" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">假设您在训练数据上建立了这种编码方案，并建立了一些模型，现在您有一些新数据，这些数据必须在预测之前针对如下特征进行设计。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="6672" class="ng lg iq nc b gy nh ni l nj nk">new_poke_df = pd.DataFrame([['PikaZoom', 'Gen 3', True], <br/>                           ['CharMyToast', 'Gen 4', False]],<br/>                       columns=['Name', 'Generation', 'Legendary'])<br/>new_poke_df</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi og"><img src="../Images/e617813196690a8c98de430273cbca32.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*MKqRnwOdBfD33tgLmWM7lw.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Sample new data</figcaption></figure><p id="f7fc" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">在这里，您可以通过对新数据调用先前构建的<code class="fe nw nx ny nc b">LabeLEncoder </code>和<code class="fe nw nx ny nc b">OneHotEncoder </code>对象的<code class="fe nw nx ny nc b">transform(…)</code>函数来利用<code class="fe nw nx ny nc b">scikit-learn’s</code>优秀的API。记住我们的工作流程，首先我们做<strong class="lz ja"> <em class="mt">转换</em> </strong>。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="decb" class="ng lg iq nc b gy nh ni l nj nk">new_gen_labels = gen_le.transform(new_poke_df['Generation'])<br/>new_poke_df['Gen_Label'] = new_gen_labels</span><span id="a049" class="ng lg iq nc b gy nz ni l nj nk">new_leg_labels = leg_le.transform(new_poke_df['Legendary'])<br/>new_poke_df['Lgnd_Label'] = new_leg_labels</span><span id="edd2" class="ng lg iq nc b gy nz ni l nj nk">new_poke_df[['Name', 'Generation', 'Gen_Label', 'Legendary', <br/>             'Lgnd_Label']]</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/cb94a0ebf643ed69a753bc2456aec3d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*j-RLI_vxx-MA7pexi3G5QQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Categorical attributes after transformation</figcaption></figure><p id="eacb" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">一旦我们有了数字标签，现在让我们应用编码方案！</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="0a43" class="ng lg iq nc b gy nh ni l nj nk">new_gen_feature_arr = gen_ohe.transform(new_poke_df[['Gen_Label']]).toarray()<br/>new_gen_features = pd.DataFrame(new_gen_feature_arr, <br/>                                columns=gen_feature_labels)</span><span id="f863" class="ng lg iq nc b gy nz ni l nj nk">new_leg_feature_arr = leg_ohe.transform(new_poke_df[['Lgnd_Label']]).toarray()<br/>new_leg_features = pd.DataFrame(new_leg_feature_arr, <br/>                                columns=leg_feature_labels)</span><span id="5c36" class="ng lg iq nc b gy nz ni l nj nk">new_poke_ohe = pd.concat([new_poke_df, new_gen_features, new_leg_features], axis=1)<br/>columns = sum([['Name', 'Generation', 'Gen_Label'], <br/>               gen_feature_labels,<br/>               ['Legendary', 'Lgnd_Label'], leg_feature_labels], [])</span><span id="369d" class="ng lg iq nc b gy nz ni l nj nk">new_poke_ohe[columns]</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oi"><img src="../Images/6b7ae634e5ce16fee9b6ea8ce8528778.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*za1jYH-6ooFfccLxdggpKg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Categorical attributes after one-hot encoding</figcaption></figure><p id="8f90" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">因此，您可以看到，通过利用<code class="fe nw nx ny nc b">scikit-learn’s</code>强大的API，可以很容易地在新数据上应用这个方案。</p><p id="60f7" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">您还可以通过利用<code class="fe nw nx ny nc b">pandas</code>中的<code class="fe nw nx ny nc b">to_dummies(…)</code>函数轻松应用一键编码方案。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="4387" class="ng lg iq nc b gy nh ni l nj nk">gen_onehot_features = pd.get_dummies(poke_df['Generation'])<br/>pd.concat([poke_df[['Name', 'Generation']], gen_onehot_features], <br/>           axis=1).iloc[4:10]</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/d4c1d15784f084684352dc5e400cc4f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*wRIkttjEX1Udy4pZaPSZeg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">One-hot encoded features by leveraging pandas</figcaption></figure><p id="27cb" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">上述数据框描述了应用于<code class="fe nw nx ny nc b">Generation</code>属性的独热编码方案，其结果与之前的预期结果相同。</p><h2 id="4dc5" class="ng lg iq bd lh nl nm dn ll nn no dp lp mg np nq lr mk nr ns lt mo nt nu lv iw bi translated">虚拟编码方案</h2><p id="39d9" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">伪编码方案类似于独热编码方案，除了在伪编码方案的情况下，当应用于具有<strong class="lz ja"> m </strong>个不同标签的分类特征时，我们得到<strong class="lz ja"> <em class="mt"> m - 1 </em> </strong>个二进制特征。因此，分类变量的每个值都被转换成大小为<strong class="lz ja"> <em class="mt"> m - 1 </em> </strong>的向量。额外的特征被完全忽略，因此如果类别值的范围从<strong class="lz ja"> <em class="mt"> {0，1，…，m-1 }</em></strong><strong class="lz ja"><em class="mt">第0个</em> </strong>或<strong class="lz ja"><em class="mt">m-1个</em> </strong>特征列被丢弃，相应的类别值通常由全零的矢量<strong class="lz ja"> <em class="mt"> (0) </em> </strong>表示。让我们通过删除第一级二进制编码特征(<code class="fe nw nx ny nc b">Gen 1</code>)来尝试在神奇宝贝<code class="fe nw nx ny nc b">Generation </code>上应用虚拟编码方案。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="8e04" class="ng lg iq nc b gy nh ni l nj nk">gen_dummy_features = pd.get_dummies(poke_df['Generation'], <br/>                                    drop_first=True)<br/>pd.concat([poke_df[['Name', 'Generation']], gen_dummy_features], <br/>          axis=1).iloc[4:10]</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/4067a1f1020fd23df6feccdecda55ce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*RrtvTvnqAYtI__CVRsqB8Q.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Dummy coded features for Pokémon g<code class="fe nw nx ny nc b">eneration</code></figcaption></figure><p id="8eef" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">如果你愿意，你也可以选择丢弃最后一级二进制编码特征(<code class="fe nw nx ny nc b">Gen 6</code>)如下。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="fd87" class="ng lg iq nc b gy nh ni l nj nk">gen_onehot_features = pd.get_dummies(poke_df['Generation'])<br/>gen_dummy_features = gen_onehot_features.iloc[:,:-1]<br/>pd.concat([poke_df[['Name', 'Generation']], gen_dummy_features],  <br/>          axis=1).iloc[4:10]</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/e17c4fc7cd212e4bf53981a6412ff6c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*pCnqiKj-Hrdn7FajO0sh1Q.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Dummy coded features for Pokémon g<code class="fe nw nx ny nc b">eneration</code></figcaption></figure><p id="9619" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">基于上面的描述，很清楚属于丢弃特征的类别被表示为零向量(<strong class="lz ja"> 0) </strong>，就像我们之前讨论的那样。</p><h2 id="2285" class="ng lg iq bd lh nl nm dn ll nn no dp lp mg np nq lr mk nr ns lt mo nt nu lv iw bi translated">效果编码方案</h2><p id="af48" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">效果编码方案实际上与虚拟编码方案非常相似，只是在编码过程中，虚拟编码方案中代表所有<strong class="lz ja"> 0 </strong>的类别值的编码特征或特征向量在效果编码方案中被替换为<strong class="lz ja"> -1 </strong>。通过下面的例子，这将变得更加清楚。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="c96f" class="ng lg iq nc b gy nh ni l nj nk">gen_onehot_features = pd.get_dummies(poke_df['Generation'])<br/>gen_effect_features = gen_onehot_features.iloc[:,:-1]<br/>gen_effect_features.loc[np.all(gen_effect_features == 0, <br/>                               axis=1)] = -1.<br/>pd.concat([poke_df[['Name', 'Generation']], gen_effect_features], <br/>          axis=1).iloc[4:10]</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/8e7db9f832acf341764cf09df14c1b5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*ClxVY4HgIWzwL3zxdqOhQg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Effect coded features for Pokémon g<code class="fe nw nx ny nc b">eneration</code></figcaption></figure><p id="7758" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">上面的输出清楚地表明，与虚拟编码中的0相比，属于<code class="fe nw nx ny nc b">Generation</code> 6的神奇宝贝现在由值为-1的向量表示。</p><h2 id="67e5" class="ng lg iq bd lh nl nm dn ll nn no dp lp mg np nq lr mk nr ns lt mo nt nu lv iw bi translated">面元计数方案</h2><p id="fa1a" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">到目前为止，我们讨论的编码方案在一般分类数据上工作得很好，但是当任何特征中不同类别的数量变得非常大时，它们就开始产生问题。对任何一个绝对特征都必不可少的<strong class="lz ja"> <em class="mt"> m </em> </strong>不同的标签，你就得到<strong class="lz ja"> <em class="mt"> m </em> </strong>单独的特征。这很容易增加特征集的大小，从而导致诸如存储问题、关于时间、空间和内存的模型训练问题之类的问题。除此之外，我们还必须处理通常所说的<a class="ae le" href="https://en.wikipedia.org/wiki/Curse_of_dimensionality" rel="noopener ugc nofollow" target="_blank"> <strong class="lz ja"> <em class="mt">【维数灾难】</em></strong></a><strong class="lz ja"><em class="mt"/></strong>等问题，在这些问题中，基本上有大量的特征和没有足够的代表性样本，模型性能开始受到影响，经常导致过度拟合。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ol"><img src="../Images/6debc368e2649851ce690cda7d0d6b13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FwubnnoNlt6Coo9j.png"/></div></div></figure><p id="0927" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">因此，对于具有大量可能类别(如IP地址)的特征，我们需要寻找其他分类数据特征工程方案。容器计数方案对于处理具有许多类别的分类变量是一种有用的方案。在该方案中，我们使用基于概率的关于值和实际目标或响应值的统计信息，而不是使用实际标签值进行编码，我们的目标是在建模工作中预测这些信息。一个简单的例子是基于IP地址和DDOS攻击中使用的IP地址的历史数据；我们可以为由任何IP地址引起的DDOS攻击建立概率值。使用该信息，我们可以对输入特征进行编码，该输入特征描述了如果相同的IP地址在将来出现，导致DDOS攻击的概率值是多少。这个方案需要历史数据作为先决条件，是一个精心制作的方案。用一个完整的例子来描述这一点目前是困难的，但是你可以参考网上的一些资源。</p><h2 id="51a6" class="ng lg iq bd lh nl nm dn ll nn no dp lp mg np nq lr mk nr ns lt mo nt nu lv iw bi translated">特征散列方案</h2><p id="05c7" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">特征散列方案是另一种用于处理大规模分类特征的有用的特征工程方案。在该方案中，散列函数通常与预设的编码特征数量(作为预定义长度的向量)一起使用，使得特征的散列值被用作该预定义向量中的索引，并且值被相应地更新。由于哈希函数将大量值映射到一个有限的小值集，多个不同的值可能会创建相同的哈希，这称为冲突。通常，使用带符号的散列函数，使得从散列中获得的值的符号被用作存储在最终特征向量中适当索引处的值的符号。这将确保更少的冲突和由于冲突导致的更少的误差累积。</p><p id="a372" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">哈希方案适用于字符串、数字和其他结构，如向量。您可以将哈希输出视为一组有限的<strong class="lz ja"> <em class="mt"> b </em> </strong>二进制文件，这样，当哈希函数应用于相同的值\类别时，它们会根据哈希值被分配到<strong class="lz ja"> <em class="mt"> b </em> </strong>二进制文件中的相同二进制文件(或二进制文件的子集)。我们可以预先定义<strong class="lz ja"> <em class="mt"> b </em> </strong>的值，该值成为我们使用特征散列方案编码的每个分类属性的编码特征向量的最终大小。</p><p id="70a1" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">因此，即使我们在一个特征中有超过<strong class="lz ja"> 1000 </strong>个不同的类别，并且我们将<strong class="lz ja"> <em class="mt"> b=10 </em> </strong>设置为最终的特征向量大小，如果我们使用一位热码编码方案，则输出特征集将仍然只有<strong class="lz ja"> 10 </strong>个特征，而不是<strong class="lz ja"> 1000 </strong>个二进制特征。让我们考虑一下视频游戏数据集中的<code class="fe nw nx ny nc b">Genre</code>属性。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="89d0" class="ng lg iq nc b gy nh ni l nj nk">unique_genres = np.unique(vg_df[['Genre']])<br/>print("Total game genres:", len(unique_genres))<br/>print(unique_genres)</span><span id="fde4" class="ng lg iq nc b gy nz ni l nj nk"><strong class="nc ja">Output<br/>------</strong><br/>Total game genres: 12<br/>['Action' 'Adventure' 'Fighting' 'Misc' 'Platform' 'Puzzle' 'Racing'<br/> 'Role-Playing' 'Shooter' 'Simulation' 'Sports' 'Strategy']</span></pre><p id="3b8d" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">我们可以看到一共有12种类型的电子游戏。如果我们在<code class="fe nw nx ny nc b">Genre </code>特性上使用一个独热编码方案，我们最终会有12个二进制特性。相反，我们现在将通过利用<code class="fe nw nx ny nc b">scikit-learn’s</code> <code class="fe nw nx ny nc b">FeatureHasher</code>类来使用一个特性散列方案，它使用一个带符号的32位版本的<em class="mt"> Murmurhash3 </em>散列函数。在这种情况下，我们将预先定义最终的特征向量大小为<strong class="lz ja"> 6 </strong>。</p><pre class="kp kq kr ks gt nb nc nd ne aw nf bi"><span id="9c81" class="ng lg iq nc b gy nh ni l nj nk">from sklearn.feature_extraction import FeatureHasher</span><span id="7ecc" class="ng lg iq nc b gy nz ni l nj nk">fh = FeatureHasher(n_features=6, input_type='string')<br/>hashed_features = fh.fit_transform(vg_df['Genre'])<br/>hashed_features = hashed_features.toarray()<br/>pd.concat([vg_df[['Name', 'Genre']], pd.DataFrame(hashed_features)], <br/>          axis=1).iloc[1:7]</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi om"><img src="../Images/0e38f31c105d5a3d84a6aea0cf31fee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*-EbaK-Nn5L7pNulJzx39YQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Feature Hashing on the Genre attribute</figcaption></figure><p id="dede" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">基于上述输出，<code class="fe nw nx ny nc b">Genre </code>分类属性已经使用哈希方案编码成<strong class="lz ja"> 6 </strong>特征，而不是<strong class="lz ja"> 12 </strong>。我们还可以看到，行<strong class="lz ja"> 1 </strong>和<strong class="lz ja"> 6 </strong>表示相同流派的游戏，<strong class="lz ja"> <em class="mt">平台</em> </strong>被正确地编码到相同的特征向量中。</p><h1 id="b19e" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">结论</h1><p id="ffa8" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">这些例子应该让您对离散、分类数据的特征工程的流行策略有一个很好的了解。如果你阅读了本系列的第一部分 ，你会发现与连续的数字数据相比，处理分类数据有点困难，但是绝对有趣！我们还讨论了一些使用特征工程来处理大特征空间的方法，但是你也应该记住还有其他的技术，包括<a class="ae le" href="https://en.wikipedia.org/wiki/Feature_selection" rel="noopener ugc nofollow" target="_blank"> <em class="mt">特征选择</em> </a>和<a class="ae le" href="https://en.wikipedia.org/wiki/Dimensionality_reduction" rel="noopener ugc nofollow" target="_blank"> <em class="mt">降维</em> </a>方法来处理大特征空间。我们将在后面的文章中讨论其中的一些方法。</p><p id="201d" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">接下来是针对非结构化文本数据的特征工程策略。敬请期待！</p></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><p id="2a40" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">要了解连续数值数据的特征工程策略，请查看本系列的第1部分<a class="ae le" rel="noopener" target="_blank" href="/understanding-feature-engineering-part-1-continuous-numeric-data-da4e47099a7b"><strong class="lz ja"/></a>！</p><p id="b3e3" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">本文中使用的所有代码和数据集都可以从我的<a class="ae le" href="https://github.com/dipanjanS/practical-machine-learning-with-python/tree/master/notebooks/Ch04_Feature_Engineering_and_Selection" rel="noopener ugc nofollow" target="_blank"> <strong class="lz ja"> GitHub </strong> </a>中获得</p><p id="4e20" class="pw-post-body-paragraph lx ly iq lz b ma mu ka mc md mv kd mf mg mw mi mj mk mx mm mn mo my mq mr ms ij bi translated">该代码也可作为<a class="ae le" href="https://github.com/dipanjanS/practical-machine-learning-with-python/blob/master/notebooks/Ch04_Feature_Engineering_and_Selection/Feature%20Engineering%20on%20Categorical%20Data.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="lz ja"> Jupyter笔记本</strong> </a></p></div></div>    
</body>
</html>