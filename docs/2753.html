<html>
<head>
<title>How to Visualize Multivariate Trajectory Confidence Intervals using Plotly R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Plotly R可视化多元轨迹置信区间</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-visualize-multivariate-trajectory-confidence-intervals-using-plotly-r-da345d084bd6?source=collection_archive---------4-----------------------#2018-02-28">https://towardsdatascience.com/how-to-visualize-multivariate-trajectory-confidence-intervals-using-plotly-r-da345d084bd6?source=collection_archive---------4-----------------------#2018-02-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2f6830b4cb731bcb88d626ec545b6430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J7pswJsv7QrQyqTVHYVR7A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Simulated datasets — 3D lines with confidence bands drawn with Plotly R</figcaption></figure><p id="c470" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">统计学或机器学习中的任何概率回归方法都会产生一个折线图以及相关的置信区间，通常定义为平均值周围的两个标准差。尽管Plotly拥有许多强大的图表工具，可用于绘制二维或三维图表，并可为2D折线图绘制误差线或置信区间，但它没有在三维折线图或曲面图中绘制置信区间的选项。</p><h2 id="daed" class="la lb iq bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated"><strong class="ak">多元挑战</strong></h2><p id="d8e0" class="pw-post-body-paragraph kc kd iq ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz ij bi translated">许多有趣的概率回归任务本质上是多元的；例如，跨位置坐标x预测时间t上的数据值z。该预测的结果将是表示时间t上每个点x处的预期值z的3D表面，以及每个值点处的相关误差的估计。这种类型的表面图在表面拓扑探测中很常见，其中传感器网格在目标空间内的每个网格点捕获数据。在Plotly中，该网格将被很好地可视化为跨所有x，y坐标的数据值的3D表面图，但是Plotly不呈现跨该表面的置信边界。</p><h2 id="1900" class="la lb iq bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated"><strong class="ak">轨迹</strong></h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/fcee7de1df0d8d8dc5c02657d1e34cd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dOFx_eN_LT-r2f3SgBJshA.jpeg"/></div></div></figure><p id="ebb1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通常问题的领域局限于通过目标空间的轨迹，而不是整个领域的完整探索。例如，想象一个火箭轨道，在飞行的每个纬度和经度上都标有发动机温度的测量值。温度数据是在相对于位置的每个点捕获的，但是位置数据是整个子午线空间的子集，仅沿着火箭的轨迹测量。这在建模和可视化时，以图形方式显示为一条穿过温度、高度和经度的3D空间中的轨迹的温度线，而不是表面。Plotly允许我们画出这条轨迹，但它不允许我们轻易地在这条线上画出上下置信区间。我们可以重构计算，以显示温度与高度的关系，如2D图，但这样我们会失去空间分辨率，例如，将无法区分火箭向外飞行的方向与向内、向地球飞行的轨迹，在不同的时间穿越相同的高度，这将给我们的回归分析带来问题。</p><h2 id="e350" class="la lb iq bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">如何绘制三维置信区间</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2f6830b4cb731bcb88d626ec545b6430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J7pswJsv7QrQyqTVHYVR7A.png"/></div></div></figure><p id="e6f9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">显示的图表是模拟数据的渲染图，代表样本数据在x，y平面上的三个轨迹，z显示每个点的数据值，带显示置信上限和置信下限。直接沿z轴向下看，可以看到置信带位于z平面内，因为误差是相对于数据值显示的，而观察到的x和y观察点被假设为是已知的，没有误差。这是回归分析中通常采用的方法，通常假设我们可以精确地获得测量坐标。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div class="gh gi md"><img src="../Images/b21bd725b9421f31453e1fb4c68a56e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*HsUzTyQJrA4MeZTr-k76Ng.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Projection down z axis</figcaption></figure><p id="33e5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">用于创建这些图的R代码使用Plotly <strong class="ke ir"> mesh3D </strong>图表类型来构建向上和向下指向的交错三角形的表面，这些三角形链接在一起以在数据值的平面中形成连续的表面。</p><p id="145f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所描述的方法是完全通用的，并且可以用于创建任何形式的表面，例如在3D绘图表面上构造上下边界表面。使用这种方法的唯一限制是表面重叠的复杂性，当在平面图像中渲染时，会使眼睛感到困惑，而不是作为情节动态可视化。</p><h2 id="0d40" class="la lb iq bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">r代码</h2><pre class="lz ma mb mc gt me mf mg mh aw mi bi"><span id="7a81" class="la lb iq mf b gy mj mk l ml mm"><em class="mn">#R code for 3D confidence error intervals</em><br/>install.packages("plotly")<br/>library(plotly)<br/> <br/><em class="mn"># Generate Simulated Data Points</em><br/>x &lt;- seq(-5,5, .1)<br/>y &lt;- seq(0, 10, .1)<br/>y &lt;- cbind(y, sin(y), cos(y))<br/> <br/><em class="mn"># Generate Simulated Data Values</em><br/>z1 = sin(x+y[,1])<br/>z2 = sin((x+y[,1])/2.)<br/>z3 = sin((x+y[,1])/3.)<br/> <br/>z &lt;- cbind(z1, z2, z3)</span><span id="6a1d" class="la lb iq mf b gy mo mk l ml mm"><em class="mn"># Generate Simulated Standard Deviations</em><br/>sd &lt;- sqrt(abs(z) * .05)<br/> <br/>n = length(x)<br/>i = seq(0,n-1)</span><span id="3ed5" class="la lb iq mf b gy mo mk l ml mm"><em class="mn"># Create Plots for each of three simulated trajectories</em><br/>p &lt;- plot_ly(type = 'scatter3d')<br/>for (index in 1:3){<br/>  p &lt;- add_trace(p, x = x, y = y[,index], z = z[,index], mode = 'lines', line = list(width = 8, color=index))<br/>  p &lt;- add_trace(p, type = 'mesh3d',<br/>     <em class="mn"># Setup triangle vertices</em><br/>     x = c(x, x),<br/>     y = c(y[,index], y[,index]),<br/>     z = c(z[,index] - 2 * sd[,index], z[,index] + 2 * sd[,index]),<br/>     <em class="mn"># Create triangles</em><br/>     i = c(i[1:n - 1], i[1:n - 1]),<br/>     j = c(n + i[1:n - 1], n + i[2:n]) ,<br/>     k = c(n + i[2:n], i[2:n]),<br/>     color = index<br/>  )<br/>}<br/> <br/><em class="mn">#END</em></span></pre></div></div>    
</body>
</html>