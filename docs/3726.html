<html>
<head>
<title>Transfer Learning in Tensorflow (VGG19 on CIFAR-10): Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Tensorflow 中的迁移学习(CIFAR-10 上的 VGG19):第二部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/transfer-learning-in-tensorflow-5d2b6ad495cb?source=collection_archive---------3-----------------------#2018-06-12">https://towardsdatascience.com/transfer-learning-in-tensorflow-5d2b6ad495cb?source=collection_archive---------3-----------------------#2018-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b89d69732cdba9fe938c381d58fbf366.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6XaJ_SzbEpzvRH2r"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@nbb_photos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lacie Slezak</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9bf7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是 Tensorflow 中迁移学习的第二部分(CIFAR-10 上的 VGG19)。第一部分可以在这里找到<a class="ae kc" href="https://medium.com/@parkchansung/transfer-learning-in-tensorflow-9e4f7eae3bb4" rel="noopener">。前一篇文章已经给出了关于“迁移学习”、“模型选择”、“模型实现选择”、“知道如何创建模型”和“知道最后一层”的描述。</a></p><p id="1e40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简而言之，第一部分是训练和预测前的准备工作。在本文(第 2 部分)中，我将介绍如何加载预先训练的参数，如何重新缩放输入图像，如何选择批量大小，然后我们将研究结果。你可以在我的 Github 库上找到<a class="ae kc" href="https://github.com/deep-diver/CIFAR10-VGG19-Tensorflow" rel="noopener ugc nofollow" target="_blank"> jupyter 笔记本。</a></p><h1 id="2ce9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">知道如何加载预先训练好的重量</h1><p id="fb1b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果您从官方网站下载重量，并试图将它们加载到您自己的模型中，这将是一项艰巨的工作。这将在一个单独的故事中解释，我以后会写它。然而，如果您已经找到了一个方便的实现，那么这一步就没有必要了。事实上，几乎每个第三方实现都附带了实用函数。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="7096" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于张量网，当你在 tf 上运行 pretrained()方法时。会话，它将开始下载预先训练好的参数并为您加载。这很简单。(提醒一下，logits 是 tensornets 自己创建的 VGG19 模型。VGG19())</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="6e5c" class="lb lc iq bd ld le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly bi translated">知道如何重新缩放原始图像(数据)以适合模型</h1><p id="8597" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在第 1 部分中，我们看到 ImageNet 的输入图像的形状是(224，224，3)，我们准备了大小完全相同的 tf.placeholder。然而，<a class="ae kc" href="https://www.cs.toronto.edu/~kriz/cifar.html" rel="noopener ugc nofollow" target="_blank"> CIFAR-10 </a>中的图像有一个不同的形状，(32，32，3)，相当小。不同形状的图像不能输入到现有的模型中，因为矩阵乘法不起作用。相反，我们应该做的是将图像重新缩放到(224，224，3)。</p><p id="3df5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重新缩放的过程可以通过<strong class="kf ir"><em class="mw">skimage . transform</em></strong>包来处理。<strong class="kf ir"><em class="mw">skim age . transform</em></strong>包附带了<a class="ae kc" href="http://scikit-image.org/docs/dev/api/skimage.transform.html#skimage.transform.resize" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mw">resize</em></strong></a><strong class="kf ir"><em class="mw"/></strong>方法。它有点像<strong class="kf ir"> <em class="mw"> resize(image，output_shape，…) </em> </strong>。有很多参数需要传递，但前两个是最重要的。您传递带有所需 output_shape 的原始图像，在我们的例子中是(224，224，3)，然后<strong class="kf ir"> <em class="mw"> resize </em> </strong>将返回重新缩放的图像。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="7ba6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在重新缩放图像之后，我们需要将它们堆叠在一个数组中，以便可以将一批图像输入到模型中。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="9634" class="lb lc iq bd ld le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly bi translated">批量</h1><p id="7c9a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">批量大小会受到您的设置环境和您选择的模型的影响。如第 1 部分所示，VGG16 和 VGG19 的尺寸相对较大。这意味着如果你批量分配大量的输入图像，物理内存将无法处理它。如果在 GPU 上运行，这个问题可能会更敏感，因为 GPU 通常内存较少。</p><p id="c4c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就我而言，我已经在 11GB 内存的英伟达 GTX 1080Ti 上运行了培训。我已经试验过像 256 这样的大批量，并且随着时间的推移我减少了这个数量。原来我的 GPU 一次只能负担 32 的批量大小。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="70dd" class="lb lc iq bd ld le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly bi translated">有效集内的精度测量</h1><p id="bcb2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果你在那里寻找一些简单的深度学习例子，你会发现他们试图评估整个有效集的准确性。但是，我发现 VGG16 和 VGG19 型号并不是这样。正如我在上一节中解释的那样，我的 GPU 一次只能处理 32 张图片，而我的有效图片集中有 5000 张图片。</p><p id="7309" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我决定对批处理中的有效集运行精度测量过程。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="475e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结果</h1><p id="8e6f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">下面的截图就是结果。我从测试集中随机抽取了 10 张图片。正如你所看到的，VGG19 模型在 CIFAR-10 图像数据集上学习得很好，即使它只有这么小的图像。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/1ff16ef1f0544dc35d3a2caa92221cf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DX7EcGD3VC_PPI128eg3lg.png"/></div></div></figure><h1 id="fa8f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">摘要</h1><p id="fa42" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在结束这个故事之前，我想简单总结一下。</p><ul class=""><li id="a5a5" class="my mz iq kf b kg kh kk kl ko na ks nb kw nc la nd ne nf ng bi translated"><strong class="kf ir">迁移学习</strong>是<strong class="kf ir">建立图像分类系统的良好起点</strong></li><li id="38c2" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">选择<strong class="kf ir">型号取决于</strong>你的<strong class="kf ir">物理(硬件)</strong> <strong class="kf ir">环境</strong>和<strong class="kf ir">你的团队的目标</strong>(有多少种类？).</li><li id="5fa3" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">选择<strong class="kf ir">模型实现</strong>并不重要，但是<strong class="kf ir">有助于简化整个过程</strong>。</li><li id="6f33" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">使用<strong class="kf ir">第三方实现</strong>时，要知道三件事。<strong class="kf ir">‘如何创建模型？’、‘最后一层是什么？’，以及“如何加载预训练参数？</strong>'</li><li id="d88a" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated"><strong class="kf ir">重要的是</strong>到<strong class="kf ir">知道如何重新缩放</strong>你自己的输入图像以适合所选的模型(使用 skimage.transform 包)。</li><li id="194e" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated"><strong class="kf ir">应根据您的物理(硬件)环境仔细考虑批次大小</strong>。</li></ul></div></div>    
</body>
</html>