<html>
<head>
<title>Recommending GitHub Repositories with Google BigQuery and the implicit library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Google BigQuery 和隐式库推荐 GitHub 存储库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/recommending-github-repositories-with-google-bigquery-and-the-implicit-library-e6cce666c77?source=collection_archive---------1-----------------------#2017-06-24">https://towardsdatascience.com/recommending-github-repositories-with-google-bigquery-and-the-implicit-library-e6cce666c77?source=collection_archive---------1-----------------------#2017-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="86f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">跟踪 GitHub 中发布的所有优秀的资源库是一项不可能的任务。<a class="ae kl" href="https://github.com/trending" rel="noopener ugc nofollow" target="_blank">趋势列表</a>帮助不大。正如你可能已经读到的，<a class="ae kl" href="https://medium.com/@jbochi/how-not-to-sort-by-popularity-92745397a7ae" rel="noopener">按受欢迎程度排序并不像看起来那么简单。这里列出的大多数东西通常与我使用的堆栈无关。</a></p><p id="49c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是推荐系统的一个很好的用例。它们帮助我们以个性化的方式过滤信息——存储库。当我们不知道该键入什么时，我认为它们是一个搜索查询。</p><p id="bca0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">推荐系统有几种方法，但通常分为两大类，协作式和基于内容的过滤。以下是 W <a class="ae kl" href="https://en.wikipedia.org/wiki/Recommender_system" rel="noopener ugc nofollow" target="_blank"> ikipedia </a>的定义:</p><blockquote class="km kn ko"><p id="0897" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated"><a class="ae kl" href="https://en.wikipedia.org/wiki/Collaborative_filtering" rel="noopener ugc nofollow" target="_blank">协同过滤</a>根据用户过去的行为(之前购买或选择的项目和/或对这些项目的数字评级)以及其他用户做出的类似决定来构建模型。<a class="ae kl" href="https://en.wikipedia.org/wiki/Content-based_filtering" rel="noopener ugc nofollow" target="_blank">基于内容的过滤</a>方法利用项目的一系列离散特征来推荐具有相似属性的附加项目。</p></blockquote><p id="b12b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种特殊的情况下，很难应用基于内容的方法，因为很难直接通过内容来度量存储库的相似性:代码、文档、标签等等。协同过滤更适合，也更容易应用。正如我在<a class="ae kl" href="https://medium.com/@jbochi/how-not-to-sort-by-popularity-92745397a7ae" rel="noopener">之前的帖子</a>中所说，即使人们没有对你的内容进行评级，隐性反馈也足够了。</p><p id="706e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，我们可以使用当前流行的程序员冷静作为隐式反馈库星星:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/fb2db7c1c32ea99e921772bd55651df4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K38_XHkXdmEM59KmYHZK0Q.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">Stolen from a <a class="ae kl" href="https://github.com/JuliaKikuye/meetup_machine_learning_recsys/blob/master/talk.ipynb" rel="noopener ugc nofollow" target="_blank">talk</a> that Julia and I gave at <a class="ae kl" href="https://www.meetup.com/Machine-Learning-Porto-Alegre/" rel="noopener ugc nofollow" target="_blank">Porto Alegre Machine Learning Meetup</a> (in Portuguese)</figcaption></figure><p id="2785" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将从 Google Big Query 获得本月给出的随机恒星样本，并使用令人惊叹的<a class="ae kl" href="https://github.com/benfred/implicit/" rel="noopener ugc nofollow" target="_blank">隐式</a>库，该库实现了精彩论文<a class="ae kl" href="http://yifanhu.net/PUB/cf.pdf" rel="noopener ugc nofollow" target="_blank">对隐式反馈数据集</a>的协同过滤。算法本身我就不说了，不过你可以看看论文或者<a class="ae kl" href="http://www.benfrederickson.com/matrix-factorization/" rel="noopener ugc nofollow" target="_blank">这篇博文来自</a> <a class="ae kl" href="http://www.benfrederickson.com/" rel="noopener ugc nofollow" target="_blank"> Ben Frederickson </a>《隐式》的作者。</p><p id="7a1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是获取数据的查询:</p><pre class="ku kv kw kx gt lj lk ll lm aw ln bi"><span id="193d" class="lo lp iq lk b gy lq lr l ls lt">WITH stars AS (<br/>     SELECT actor.login AS user, repo.name AS repo<br/>     FROM githubarchive.month.201706<br/>     WHERE type="WatchEvent"<br/>),<br/>repositories_stars AS (<br/>     SELECT repo, COUNT(*) as c FROM stars GROUP BY repo<br/>     ORDER BY c DESC<br/>     LIMIT 1000<br/>),<br/>users_stars AS (<br/>    SELECT user, COUNT(*) as c FROM  stars<br/>    WHERE repo IN (SELECT repo FROM repositories_stars)<br/>    GROUP BY user HAVING c &gt; 10 AND C &lt; 100<br/>    LIMIT 10000<br/>)<br/>SELECT user, repo FROM stars<br/>WHERE repo IN (SELECT repo FROM repositories_stars)<br/>AND user IN (SELECT user FROM users_stars)</span></pre><p id="2f15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我筛选了排名前 1000 的存储库，并随机抽取了 10000 名给排名前 1000 的存储库打了 10 到 100 星的用户。我们希望对关注热门项目的人进行抽样调查，但我们不想让那些给所有东西都打星的用户，因为他们不会添加太多信息。</p><p id="76f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重要的是要意识到我们不需要所有用户的所有明星来给每个人推荐。添加更多数据会提高推荐质量，但也会增加训练时间。如果我们<a class="ae kl" href="https://www.quora.com/How-do-I-speed-up-matrix-factorization-by-sampling-users-without-losing-precision" rel="noopener ugc nofollow" target="_blank">采样正确</a>，就不会损害模型精度。</p><p id="3f9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，说够了，我们如何获得数据和训练模型？</p><pre class="ku kv kw kx gt lj lk ll lm aw ln bi"><span id="da20" class="lo lp iq lk b gy lq lr l ls lt">data = pd.io.gbq.read_gbq(query, dialect="standard", project_id=project_id)</span><span id="631e" class="lo lp iq lk b gy lu lr l ls lt"># map each repo and user to a unique numeric value<br/>data['user'] = data['user'].astype("category")<br/>data['repo'] = data['repo'].astype("category")</span><span id="1af6" class="lo lp iq lk b gy lu lr l ls lt"># create a sparse matrix of all the users/repos<br/>stars = coo_matrix((np.ones(data.shape[0]),<br/>                   (data['repo'].cat.codes.copy(),<br/>                    data['user'].cat.codes.copy())))</span><span id="406a" class="lo lp iq lk b gy lu lr l ls lt"># train model<br/>model = AlternatingLeastSquares(factors=50,<br/>                                regularization=0.01,<br/>                                dtype=np.float64,<br/>                                iterations=50)</span><span id="1f7e" class="lo lp iq lk b gy lu lr l ls lt">confidence = 40<br/>model.fit(confidence * stars)</span></pre><p id="3327" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅此而已。只有 7 行 Python。而且快得惊人。在不到 10 秒的时间内提取数据并训练模型<strong class="jp ir">。我选择了通常工作良好的参数，但是如果我们认真对待它，我们应该做一些<a class="ae kl" href="https://gist.github.com/jbochi/2e8ddcc5939e70e5368326aa034a144e#file-evaluation-ipynb" rel="noopener ugc nofollow" target="_blank">验证</a>。我们跳过这个，直接看结果。与<a class="ae kl" href="https://github.com/tensorflow/tensorflow" rel="noopener ugc nofollow" target="_blank"> tensorflow </a>有什么相似之处？</strong></p><pre class="ku kv kw kx gt lj lk ll lm aw ln bi"><span id="4368" class="lo lp iq lk b gy lq lr l ls lt"># dictionaries to translate names to ids and vice-versa<br/>repos = dict(enumerate(data['repo'].cat.categories))<br/>repo_ids = {r: i for i, r in repos.iteritems()}</span><span id="4934" class="lo lp iq lk b gy lu lr l ls lt">model.similar_items(repo_ids['tensorflow/tensorflow'])]</span><span id="cc15" class="lo lp iq lk b gy lu lr l ls lt">[(u'tensorflow/tensorflow', 1.0000000000000004),<br/> (u'jikexueyuanwiki/tensorflow-zh', 0.52015405760492706),<br/> (u'BVLC/caffe', 0.4161581732982037),<br/> (u'scikit-learn/scikit-learn', 0.40543551306117309),<br/> (u'google/protobuf', 0.40160716582156247),<br/> (u'fchollet/keras', 0.39897590674119598),<br/> (u'shadowsocksr/shadowsocksr-csharp', 0.3798671235574328),<br/> (u'ethereum/mist', 0.37205191726130321),<br/> (u'pandas-dev/pandas', 0.34311692603549021),<br/> (u'karpathy/char-rnn', 0.33868380215281335)]</span></pre><p id="d6ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看起来没错！列表中的几乎所有内容都与机器学习和数据科学有关。</p><p id="548d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">产生用户推荐呢？嗯，我们可以直接使用<code class="fe lv lw lx lk b">model.recommend</code>为训练集中的用户获得推荐，但我们需要从 GitHub API 为所有其他用户获得用户星级。</p><p id="ddb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是从 GitHub 的 API 中获取星星并创建一个新的用户项目矩阵的代码。</p><pre class="ku kv kw kx gt lj lk ll lm aw ln bi"><span id="8322" class="lo lp iq lk b gy lq lr l ls lt">def user_stars(user):<br/>    repos = []<br/>    url = "<a class="ae kl" href="https://api.github.com/users/{}/starred" rel="noopener ugc nofollow" target="_blank">https://api.github.com/users/{}/starred</a>".format(user)<br/>    while url:<br/>        resp = requests.get(url, auth=github_auth)<br/>        repos += [r["full_name"] for r in resp.json()]<br/>        url = resp.links["next"]["url"] if "next" in resp.links else None<br/>    return repos</span><span id="333a" class="lo lp iq lk b gy lu lr l ls lt">def user_items(u_stars):<br/>    star_ids = [repo_ids[s] for s in u_stars if s in repo_ids]<br/>    data = [confidence for _ in star_ids]<br/>    rows = [0 for _ in star_ids]<br/>    shape = (1, model.item_factors.shape[0])<br/>    return coo_matrix((data, (rows, star_ids)), shape=shape).tocsr()</span></pre><p id="e4dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的，我应该检查哪些存储库？</p><pre class="ku kv kw kx gt lj lk ll lm aw ln bi"><span id="8456" class="lo lp iq lk b gy lq lr l ls lt">def recommend(user_items):<br/>    recs = model.recommend(userid=0, user_items=user_items, recalculate_user=True)<br/>    return [(repos[r], s) for r, s in recs]</span><span id="961c" class="lo lp iq lk b gy lu lr l ls lt">jbochi = user_items(user_stars("jbochi"))<br/>recommend(jbochi)</span><span id="541e" class="lo lp iq lk b gy lu lr l ls lt">[(u'ansible/ansible', 1.3480146093553365),<br/> (u'airbnb/superset', 1.337698670756992),<br/> (u'scrapy/scrapy', 1.2682612609169515),<br/> (u'grpc/grpc', 1.1558718295721062),<br/> (u'scikit-learn/scikit-learn', 1.1539551159232055),<br/> (u'grafana/grafana', 1.1265144087278358),<br/> (u'google/protobuf', 1.078458167396922),<br/> (u'lodash/lodash', 1.0690341693223879),<br/> (u'josephmisiti/awesome-machine-learning', 1.0553796439629786),<br/> (u'd3/d3', 1.0546232373207065)]</span></pre><p id="bd59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我发现这些建议非常有用。请注意，我们传递了一个全新的用户评级矩阵，其中只有一个用户，并设置了标志<code class="fe lv lw lx lk b">recalculate_user=True</code>。</p><p id="6500" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个功能是最近<a class="ae kl" href="https://github.com/benfred/implicit/pull/35" rel="noopener ugc nofollow" target="_blank">添加的</a>，可以用来为不在训练集中的用户生成推荐，或者在他或她消费更多项目时更新用户推荐。</p><p id="bfb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我添加到库中的另一个无耻的功能是<a class="ae kl" href="https://github.com/benfred/implicit/pull/37" rel="noopener ugc nofollow" target="_blank">解释推荐</a>的能力:</p><pre class="ku kv kw kx gt lj lk ll lm aw ln bi"><span id="3175" class="lo lp iq lk b gy lq lr l ls lt">def explain(user_items, repo):<br/>    _, recs, _ = model.explain(userid=0, user_items=user_items, itemid=repo_ids[repo])<br/>    return [(repos[r], s) for r, s in recs]</span><span id="e5ca" class="lo lp iq lk b gy lu lr l ls lt">explain(jbochi, 'fchollet/keras')</span><span id="5e82" class="lo lp iq lk b gy lu lr l ls lt">[(u'pandas-dev/pandas', 0.18368079727509334),<br/> (u'BVLC/caffe', 0.15726607611115795),<br/> (u'requests/requests', 0.15263841163355341),<br/> (u'pallets/flask', 0.15259412774463132),<br/> (u'robbyrussell/oh-my-zsh', 0.1503775470984523),<br/> (u'apache/spark', 0.12771260655405856),<br/> (u'tensorflow/tensorflow', 0.12343847633950071),<br/> (u'kripken/emscripten', 0.12294875917036562),<br/> (u'videojs/video.js', 0.12279727716802587),<br/> (u'rust-lang/rust', 0.10859551238691327)]</span></pre><p id="7d1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它会返回我标上星号的对某个特定推荐贡献最大的存储库。结果意味着模型推荐<em class="kp"> keras </em>因为我主演过<em class="kp">熊猫</em>和<em class="kp">咖啡馆</em>。</p><p id="56ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望你喜欢！这是<a class="ae kl" href="https://gist.github.com/jbochi/2e8ddcc5939e70e5368326aa034a144e" rel="noopener ugc nofollow" target="_blank">笔记本，上面有你用用户名运行它所需的所有代码</a>。</p><p id="c84e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">别忘了给<a class="ae kl" href="https://github.com/benfred/implicit/" rel="noopener ugc nofollow" target="_blank">隐</a>一颗星。本应得的。</p></div></div>    
</body>
</html>