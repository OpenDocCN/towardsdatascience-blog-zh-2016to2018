<html>
<head>
<title>“ TIME SERIES ANALYSIS USING NEURAL NETWORK ”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“使用神经网络进行时间序列分析”</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fast-ai-season-1-episode-4-1-time-series-analysis-a23217418bf1?source=collection_archive---------6-----------------------#2018-10-14">https://towardsdatascience.com/fast-ai-season-1-episode-4-1-time-series-analysis-a23217418bf1?source=collection_archive---------6-----------------------#2018-10-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c4ae" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用神经网络建立一个先进的时间序列预测模型。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/f65e7e371b8e232d46e4508f8d637cad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*MuXvCOQAmU-O5Xd5LY4GnQ.jpeg"/></div></figure><p id="eee5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">欢迎来到第四集<a class="ae lj" href="http://www.fast.ai/" rel="noopener ugc nofollow" target="_blank"> Fastdotai </a>，在这里我们将处理<strong class="kp ir">结构化和时间序列数据</strong>。在我们开始之前，我想感谢<a class="ae lj" href="https://twitter.com/jeremyphoward" rel="noopener ugc nofollow" target="_blank"> <strong class="kp ir">【杰瑞米·霍华德】</strong> </a>和<a class="ae lj" href="https://twitter.com/math_rachel" rel="noopener ugc nofollow" target="_blank"> <strong class="kp ir">雷切尔·托马斯</strong> </a>为民主化人工智能所做的努力。</p><p id="689b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了充分利用这个博客系列，请按照以下顺序随意探索这个系列的第一部分:- <a class="ae lj" href="https://machinelearningmarvel.in/dogs-vs-cats-image-classifier/" rel="noopener ugc nofollow" target="_blank">狗和猫的图像分类</a></p><ol class=""><li id="e82f" class="lk ll iq kp b kq kr kt ku kw lm la ln le lo li lp lq lr ls bi translated"><a class="ae lj" rel="noopener" target="_blank" href="/fast-ai-season-1-episode-2-1-e9cc80d81a9d">狗 Vs 猫图像分类</a></li><li id="2407" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated"><a class="ae lj" rel="noopener" target="_blank" href="/fast-ai-season-1-episode-2-2-dog-breed-classification-5555c0337d60">犬种图像分类</a></li><li id="61e2" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated"><a class="ae lj" rel="noopener" target="_blank" href="/fast-ai-season-1-episode-3-a-case-of-multi-label-classification-a4a90672a889">多标签图像分类</a></li><li id="44ac" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated"><a class="ae lj" rel="noopener" target="_blank" href="/fast-ai-season-1-episode-4-1-time-series-analysis-a23217418bf1">利用神经网络进行时间序列分析</a></li><li id="28ee" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated"><a class="ae lj" href="https://geneashis.medium.com/nlp-sentiment-analysis-on-imdb-movie-dataset-fb0c4d346d23" rel="noopener">对 IMDB 电影数据集的 NLP 情感分析</a></li><li id="7df3" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated"><a class="ae lj" rel="noopener" target="_blank" href="/fast-ai-season-1-episode-5-1-movie-recommendation-using-fastai-a53ed8e41269">电影推荐系统的基础</a></li><li id="c1e2" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated"><a class="ae lj" rel="noopener" target="_blank" href="/fast-ai-season-1-episode-5-2-collaborative-filtering-from-scratch-1877640f514a">从无到有的协同过滤</a></li><li id="2075" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated"><a class="ae lj" rel="noopener" target="_blank" href="/fast-ai-season-1-episode-5-3-collaborative-filtering-using-neural-network-48e49d7f9b36">使用神经网络的协同过滤</a></li><li id="f714" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated"><a class="ae lj" href="https://geneashis.medium.com/fast-ai-season-1-episode-6-1-write-philosophy-like-nietzsche-using-rnn-8fe70cfb923c" rel="noopener">像尼采一样写哲学</a></li><li id="8c2f" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated"><a class="ae lj" href="https://geneashis.medium.com/fast-ai-season-1-episode-7-1-performance-of-different-neural-networks-on-cifar-10-dataset-c6559595b529" rel="noopener">不同神经网络在 Cifar-10 数据集上的性能</a></li><li id="1aa2" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated"><a class="ae lj" href="https://medium.com/hackernoon/single-object-detection-e65a537a1c31" rel="noopener"> ML 模型检测图像中最大的物体 Part-1 </a></li><li id="94d1" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated"><a class="ae lj" href="https://medium.com/hackernoon/single-object-detection-part-2-2deafc911ce7" rel="noopener">检测图像中最大物体的 ML 模型 Part-2 </a></li></ol><p id="245f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们将讨论的笔记本是郭/伯克哈恩的[ <a class="ae lj" href="https://arxiv.org/abs/1604.06737" rel="noopener ugc nofollow" target="_blank">分类变量的实体嵌入</a> ]中详述的<a class="ae lj" href="https://www.kaggle.com/c/rossmann-store-sales" rel="noopener ugc nofollow" target="_blank">罗斯曼卡格尔竞赛</a>第三名结果的实现。代码已经在 kaggle 内核的帮助下执行。所以会有一些额外的东西被写出来，这样代码就可以在 kaggle 上流畅地运行。如果您在任何其他云 GPU 平台上运行代码，这些额外的代码行可能是不必要的。我会在这篇博文的最后附上 kaggle 内核链接。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="6006" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">正如上面的代码片段所述，我们将拥有更多的数据集，这将有助于我们丰富特性，从而帮助我们获得更好的准确性。构成特征空间的这些数据集如下所述。</p><p id="cbd2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">特征空间涉及:</strong></p><ul class=""><li id="fa38" class="lk ll iq kp b kq kr kt ku kw lm la ln le lo li ma lq lr ls bi translated">train:包含每天的商店信息，跟踪销售、顾客、当天是否是假日等信息。</li><li id="f700" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated">商店:商店列表。商店的一般信息，包括竞争情况等。</li><li id="0aec" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated">store_states:商店到所在德国州的映射。</li><li id="bc3f" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated">googletrend:某些 google 关键字随时间的变化趋势，用户发现这些关键字与给定的数据有很好的相关性。</li><li id="b16e" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated">天气:每个州的天气情况。</li><li id="c918" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated">测试:与培训表相同，没有销售和客户。</li></ul><p id="9631" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们将这些数据文件名保存在如下所示的特定列表中:-</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="3982" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们可以使用<code class="fe mb mc md me b">head()</code>快速浏览每个表格的内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="2955" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">数据清理/特征工程:- </strong></p><p id="04dc" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在下面的代码片段中，我们将进行数据清理:-</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="bd19" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在继续之前，让我们看一下<code class="fe mb mc md me b">googletrends</code>数据，因为接下来我们将对此进行特性工程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/fb77a1d07272d8e05675ae229d8b09e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*569IA9PZ4pPCLywLj-1cKQ.png"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="0279" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们看一看特征工程后的<code class="fe mb mc md me b">googletrend </code>。检查新列<code class="fe mb mc md me b">Date ,State</code>和对<code class="fe mb mc md me b">State</code>列所做的更改。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/71e17908a1903547c394b23e4f061251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*3EXw7ABC6D1hhDRJC1rRpw.png"/></div></figure><p id="8a21" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">以下步骤对特征工程非常重要:- </strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="0622" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">正如我们在下面的快照中所看到的，我们已经向<code class="fe mb mc md me b">googletrends </code>添加了更多的列，这些列是使用上面的命令从<code class="fe mb mc md me b">Date </code>列形成的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/8429c2df423f1b007aa91c760881b340.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*g9sJCwUBaxNVnBvbbQmC2A.png"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="3664" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在上面的代码片段中，<code class="fe mb mc md me b">joined </code>是我们的训练数据，<code class="fe mb mc md me b">joined_test </code>是我们的测试数据。众所周知，一幅画胜过 1000 句话。让我描述一下我们如何通过合并多个表得到训练数据— <code class="fe mb mc md me b"> joined </code>和测试数据— <code class="fe mb mc md me b">joined_test</code>的流程图。以下快照与<code class="fe mb mc md me b">joined </code>和<code class="fe mb mc md me b">joined_test</code>相同。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mi"><img src="../Images/dac6d52aa153e041d079080f1f000593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IrOsMepJOEJasXZMqTjJaA.png"/></div></div></figure><p id="5d63" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">删除额外变量前后的比较</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mn"><img src="../Images/1eeeb8a7111cecf916c383fabc721c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z3_Zh_Svv6k2IVJD0bUdAA.png"/></div></div></figure><p id="8ed1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">正如我们在下面的代码中看到的，我们将填充训练数据— <code class="fe mb mc md me b">joined </code>和测试数据— <code class="fe mb mc md me b">joined_test</code>中出现的缺失值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="0295" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">输出如下所示:-</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mo"><img src="../Images/0e2d867f17c9aaed33afdcaa28b6c8ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iD5xcingjEGceudcI0-Ptw.png"/></div></div></figure><p id="f658" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在下面的代码中，我们替换了离群值并做了更多的功能工程。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mp"><img src="../Images/dcc66bd596464f8274512cbebc544387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E-VX0q8cOiOFOtw49gyV-w.png"/></div></div></figure><p id="df60" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">促销日期的相同功能工程。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="346f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">让我们关注一下持续时间:- </strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="9cc2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这篇文章你已经看了一半了。干得好。继续走。从这里开始会很有趣。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr lz l"/></div></figure><p id="114d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在，让我们关注分类变量和连续变量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Categorical vs Continuous</figcaption></figure><p id="c008" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">决定哪个变量是分类变量还是连续变量？</strong></p><p id="23bc" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在上面的代码中，我们已经分离了将被视为连续和分类的列。但是怎么做呢？这个需要详细解释。</p><p id="acbb" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因此，根据列/变量的基数<strong class="kp ir">可以说该列/变量是连续的或分类的。基数</strong>被定义为一个类别中级别的数量。例如,<strong class="kp ir">基数</strong>表示一周的天数=7</p><ul class=""><li id="ae72" class="lk ll iq kp b kq kr kt ku kw lm la ln le lo li ma lq lr ls bi translated">无论哪个变量已经以分类形式出现在数据中，都将是模型中的分类变量。</li><li id="4e1e" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated">对于连续变量，我们必须检查它们的基数。如果它们的基数(不同级别的数量)太高，它将是连续的，否则它将被转换成分类变量。</li><li id="989d" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated">连续变量应该具有连续平滑的函数。例如，年份虽然是一个连续变量，但没有很多不同的级别，因此最好将其作为一个分类变量。在这种情况下，连续的是类型为<code class="fe mb mc md me b">floating point </code>或数据类型为<code class="fe mb mc md me b">int </code>的那些。</li><li id="3f58" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated">我们可以绑定一个连续变量，然后将其转换为分类变量。有时候宁滨会很有帮助。</li></ul><p id="98fc" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">哪些变量是分类变量，哪些是连续变量，这是我们必须做出的建模决策之一。 </p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="d405" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这个时间点上，我们的数据看起来像这样。它有一些连续的，一些布尔的，一些分类的等等。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mw"><img src="../Images/ba662dd43fee5a90216da37119769064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L4I9j_eDZkH1gzN7xKEWvQ.png"/></div></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="3fd2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在上面的代码中，Fastai 有一个名为 process _ data frame(<strong class="kp ir">proc _ df</strong>)的函数。</p><ul class=""><li id="1bb3" class="lk ll iq kp b kq kr kt ku kw lm la ln le lo li ma lq lr ls bi translated">它从数据帧<strong class="kp ir">‘joined _ samp’</strong>中取出因变量，即<strong class="kp ir">‘Sales’</strong>，并将其存储在单独的变量<code class="fe mb mc md me b"><strong class="kp ir">y</strong></code>中。</li><li id="d149" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated">除了因变量'<strong class="kp ir"> Sales </strong>'之外的其余数据帧保存在<code class="fe mb mc md me b"><strong class="kp ir">df</strong></code> <strong class="kp ir">中。</strong></li><li id="8bda" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated"><strong class="kp ir"> nas </strong>:返回它创建了哪个<strong class="kp ir"> nas </strong>的字典，以及相关的中位数。</li><li id="ecf1" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated"><strong class="kp ir">映射器</strong>:一个<strong class="kp ir">数据帧映射器</strong>，存储相应连续变量的平均值和标准偏差，然后用于测试期间的缩放。</li><li id="f6c6" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated">它还处理缺失值，因此分类变量中的缺失值变为 0，其他类别变为 1，2，3，4，依此类推。</li><li id="eda8" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated">对于连续变量，它用中值替换缺失值，并创建一个新的布尔列，表示是否缺失。</li></ul><p id="b479" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在输出 df 的所有变量都是连续的。分类列由等价的连续值表示。查看“年份”和“产品组合”栏在此之前和之后的变化。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mx"><img src="../Images/5ffb4066cfee6f299fd1350e37304565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gtXSAgKG3bKa7K_n558Zdg.png"/></div></div></figure><p id="c156" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这样，所有的列都是连续的。</p><ul class=""><li id="3772" class="lk ll iq kp b kq kr kt ku kw lm la ln le lo li ma lq lr ls bi translated">连续的列保持不变。它们被改成了<code class="fe mb mc md me b">float32 </code>，因为这是 pytorch 接受的标准数字数据类型。</li><li id="d1b1" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated">分类列被转换成等效的连续类型。</li></ul><p id="1f1c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">验证数据集</strong></p><p id="ff2d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">根据 Kaggle，我们在 Rossman 数据中的问题陈述是预测接下来两周的销售。由于它是一个时间序列数据，我们的验证数据集不是随机的。相反，它是我们实际应用中的最新数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="2743" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">深度学习从这里开始。</strong></p><ul class=""><li id="1a86" class="lk ll iq kp b kq kr kt ku kw lm la ln le lo li ma lq lr ls bi translated">根据罗斯曼数据竞赛的 Kaggle 规则，我们将在<strong class="kp ir"> RMSPE(均方根百分比误差)的基础上进行评估。</strong></li><li id="6e7e" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated"><strong class="kp ir"> RMSPE </strong>将是度量而不是准确性，因此我们在下面的代码中对此进行了公式化:-</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div></figure><ul class=""><li id="0e32" class="lk ll iq kp b kq kr kt ku kw lm la ln le lo li ma lq lr ls bi translated">让我们创建我们的模型数据对象:-</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div></figure><ul class=""><li id="b4e8" class="lk ll iq kp b kq kr kt ku kw lm la ln le lo li ma lq lr ls bi translated">早些时候是<code class="fe mb mc md me b">ImageClassifierData </code>,因为那时我们正在处理图像。现在在这种情况下，当我们处理纵列表格数据时，它是<code class="fe mb mc md me b">ColumnarModelData</code>。</li><li id="de7c" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated">我们有了<code class="fe mb mc md me b">from_data_frame</code>，而不是<code class="fe mb mc md me b">from_Paths</code>。</li><li id="6f06" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated"><code class="fe mb mc md me b">PATH</code> —存储模型文件的位置。</li><li id="bcbb" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated"><code class="fe mb mc md me b">val_idx</code> —要放入验证数据集中的行的索引列表。</li><li id="afa9" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated"><code class="fe mb mc md me b">df</code> —数据框。</li><li id="2305" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated"><code class="fe mb mc md me b">y1</code> —由因变量组成。</li><li id="5542" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated"><code class="fe mb mc md me b">cat_flds</code> —将所有列视为分类变量，因为此时所有列都转换为数值。</li><li id="8a7d" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated"><code class="fe mb mc md me b">bs</code> —批量大小。</li></ul><p id="e163" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">对分类变量应用嵌入:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi my"><img src="../Images/5b8ce12913dd349a82db9069bdd8bbf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*awtUtuxqliQLRu1V2hExoA.png"/></div></figure><p id="a59e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">上面的代码所做的是，它遍历每个分类变量<code class="fe mb mc md me b">(cat_vars)</code>并打印出它所拥有的不同级别或类别的数量。上面代码中带有类别的<code class="fe mb mc md me b">+1 </code>是为缺失值保留的。<strong class="kp ir">基本上，它打印每个变量的基数和变量名。</strong></p><p id="dd75" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们用每个变量的基数来决定它的嵌入矩阵应该有多大。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/f78cdedf5f6239f922cb2b0b88eb7f0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:284/format:webp/1*sX3mfYORh5OmeS-n2OizyA.png"/></div></figure><p id="5f19" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在上面的代码中，我们遵循一条经验法则，即嵌入大小是<code class="fe mb mc md me b">cardinality size//2 </code>，但不大于 50。</p><p id="d500" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">嵌入矩阵如何工作？</strong></p><ul class=""><li id="03eb" class="lk ll iq kp b kq kr kt ku kw lm la ln le lo li ma lq lr ls bi translated">当我们创建这些矩阵时，它有随机数。因此，我们将它们放入神经网络，并不断更新它们的值，以减少损失函数。这些嵌入矩阵可以与一组权重相比较，这些权重以减少损失的方式自我更新。这样，我们从这些权重的随机值到有意义的更新值。</li><li id="bf36" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated">客观地说，嵌入矩阵的值可以在 0 和该类别的最大层数之间。然后我们可以索引那个矩阵，找到一个特定的行，我们把它附加到所有的连续变量上，之后的一切都和之前一样。</li></ul><p id="710e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">嵌入矩阵的图示:- </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi na"><img src="../Images/e0a334d7f9bbf910b6066f3bdf326758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*haMy7V4Uxa57fNi5jQWZBg.png"/></div></div></figure><p id="58bb" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">将神经网络应用于连续变量:- </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nb"><img src="../Images/2bdfa9aa5e685650184b159f3ba84777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BWvhimQZSD1EG3nGfFBm7w.png"/></div></div></figure><p id="dba6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">上图显示了神经网络如何处理连续变量。查看矩阵乘法如何工作并产生相应的输出。这是一个 2 隐层神经网络。假设有 20 列作为输入，并且我们已经设计了神经网络，使得第一隐藏层具有 100 个隐藏单元，第二隐藏层具有 50 个隐藏单元。因此，我们的输入[1，20]乘以维度为[20，100]的权重矩阵将得到[1，100]。然后，我们将 ReLU 应用于这个[1，100]维度值，这导致[1，100]的激活。然后，这个[1，100]维激活乘以[100，50]维的权重，这导致具有[1，50]维的激活。这个[1，50]激活然后乘以维度[50，1]的权重，这导致 1 输出。我们在最后一层应用 Softmax 来得到最终的输出。</p><ul class=""><li id="6522" class="lk ll iq kp b kq kr kt ku kw lm la ln le lo li ma lq lr ls bi translated"><strong class="kp ir">注意:- </strong>不要将 ReLU 放在最后一层，因为 Softmax 需要负值来创建更低的概率。ReLU 函数去掉了负值。在罗斯曼销售数据的情况下，我们试图预测销售，因此我们最终不需要 Softmax。</li></ul><p id="9363" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们创建我们的学习者。这就是我们如何建立我们的神经网络。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/791bdf2d396048468e14175e150a1591.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*gEygyhm_uPmC2gUG8ixsLA.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">best lr = 1e-3</figcaption></figure><p id="4093" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe mb mc md me b">get_learner()</code>中使用的参数。</p><ul class=""><li id="ce0d" class="lk ll iq kp b kq kr kt ku kw lm la ln le lo li ma lq lr ls bi translated"><code class="fe mb mc md me b">emb_s </code> —对每个分类变量使用此嵌入矩阵。</li><li id="d090" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated"><code class="fe mb mc md me b">len(df.columns)-len(cat_vars)</code> —表示连续变量的数量。</li><li id="fc38" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated"><code class="fe mb mc md me b">0.04</code> —一开始就辍学。</li><li id="b2fb" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated"><code class="fe mb mc md me b">1</code> —最后一个线性层的输出。</li><li id="f2bb" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated"><code class="fe mb mc md me b">[1000,500]</code> —第一和第二线性层的激活次数。</li><li id="016d" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated"><code class="fe mb mc md me b">[0.001,0.01]</code> —用于第一和第二线性层的漏失。</li><li id="b1ae" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated"><code class="fe mb mc md me b">y_range=y_range</code> —前面已经介绍过了。</li><li id="3adc" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated"><code class="fe mb mc md me b">tmp_name=f”{PATH_WRITE}tmp”</code> —(可选)仅在 kaggle 内核中使用。</li><li id="62ef" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li ma lq lr ls bi translated"><code class="fe mb mc md me b">models_name=f”{PATH_WRITE}models”</code> —(可选)仅在 kaggle 内核中使用。</li></ul><p id="fbe1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir"> <em class="mq">？？？有什么问题吗？？？</em>T15】</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr lz l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">!!! Question Time !!!</figcaption></figure><p id="08e7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Qs 1 :-星期嵌入中的四个值表示什么？</p><p id="0d9d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">最初，我们从一些随机的四个值开始。它的功能与砝码相同。所以我们在最小化损失的同时更新这些值。当损失被最小化时，我们将以一些更新的四个值结束。此时，我们会发现这些特定的参数是人类可以解释的，而且非常有趣。</p><p id="af0c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Qs 2 :-除了随机初始化，还有什么方法初始化嵌入矩阵？</p><p id="1cce" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果罗斯曼有一个预先训练好的奶酪销售嵌入矩阵，我们可以用它来预测酒的销售。instacart 和 pinterest 正在使用这种技术。他们有产品和商店的嵌入矩阵，在组织内共享，这样人们就不必培训新的产品和商店。</p><p id="63d2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Qs 3 :-使用嵌入矩阵比一键编码有什么优势？</p><p id="00c2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">以周日的一个热门编码向量为例:-</p><pre class="kg kh ki kj gt nd me ne nf aw ng bi"><span id="c1a3" class="nh ni iq me b gy nj nk l nl nm">[1 0 0 0 0 0 0]</span></pre><p id="dcf8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Sunday 的独热编码表示法的问题是它表示一个浮点数。它只代表一件事。更多的是线性行为。</p><p id="da6d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有了嵌入，星期天就是一个四维空间的概念。更新这些值后我们得到的是丰富的语义概念。例如，如果结果是周末与工作日相比具有不同的行为，那么我们看到在这个嵌入矩阵中周六和周日的某个值会更高。通过拥有这些高维向量，我们给神经网络一个机会来学习这些潜在的丰富表示。正是这种丰富的表现让它能够学习如此有趣的关系。这种表示嵌入的思想被称为“分布式表示”。神经网络具有有时难以解释的高维表示。矩阵中的这些数字不一定只有一个意思。它可以随着上下文改变它的意思，因为它经历了丰富的非线性函数。</p><p id="4d11" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">虽然一个热门的编码在一周的几天中有更多的维度，但它并不是有意义的高维。嵌入矩阵的使用有助于减小尺寸，并更恰当地表示变量。</p><p id="e64a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">问题 3:-嵌入适合某种类型的变量吗？</p><p id="759d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当我们遇到分类变量时，我们使用嵌入的概念。但是对于高基数的变量就不行了。</p><p id="6821" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">问题 4:<code class="fe mb mc md me b">add_datepart() </code>如何影响季节性？</p><p id="8f8e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">fastai 库有一个<code class="fe mb mc md me b">add_datepart()</code>函数，它接受一个数据帧及其表示日期的列。它可以选择删除日期列，而不是返回许多表示该日期有用信息的列。例如用<code class="fe mb mc md me b">dayOfWeek</code>、<code class="fe mb mc md me b"> MonthOfYear</code>、<code class="fe mb mc md me b"> Year</code>、<code class="fe mb mc md me b">Month</code>、<code class="fe mb mc md me b"> Week</code>、<code class="fe mb mc md me b"> Day</code>等代替<code class="fe mb mc md me b">Date </code>等。所以<code class="fe mb mc md me b">daysOFWeek </code>现在可以用一个【8，4】嵌入矩阵来表示。从概念上讲，这允许模型挑选一些有趣的特征和模式。</p><ul class=""><li id="90b3" class="lk ll iq kp b kq kr kt ku kw lm la ln le lo li ma lq lr ls bi translated">假设，有一个 7 天周期的东西，它在周一上涨，周四下跌，只有在柏林，它可以完全提取该模式，因为它有所有需要的信息。这是处理时间序列模型的好方法。我们只需要确保我们的时间序列模型中的周期指标或周期性应该以列的形式存在。</li></ul><p id="c229" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">使用以下命令培养学习者并获得最佳的学习速度。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/1b31d65aadbd20fe2cdf12f186c9fbcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*L5W4eMnoyvcZdW7fYXK4zw.png"/></div></figure><p id="c40a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">正如我们所看到的，最好的学习率在 10^-3.的某个地方所以我们将继续用 lr=10^-3.训练我们的神经网络</p><pre class="kg kh ki kj gt nd me ne nf aw ng bi"><span id="66d3" class="nh ni iq me b gy nj nk l nl nm">m.fit(lr, 3, metrics=[exp_rmspe])<br/>[ 0.       0.02479  0.02205  0.19309]                          <br/>[ 1.       0.02044  0.01751  0.18301]                          <br/>[ 2.       0.01598  0.01571  0.17248]</span><span id="4f7c" class="nh ni iq me b gy no nk l nl nm">m.fit(lr, 5, metrics=[exp_rmspe], cycle_len=1)<br/>[ 0.       0.01258  0.01278  0.16   ]                          <br/>[ 1.       0.01147  0.01214  0.15758]                          <br/>[ 2.       0.01157  0.01157  0.15585]                          <br/>[ 3.       0.00984  0.01124  0.15251]                           <br/>[ 4.       0.00946  0.01094  0.15197]</span><span id="7b78" class="nh ni iq me b gy no nk l nl nm">m.fit(lr, 2, metrics=[exp_rmspe], cycle_len=4)<br/>[ 0.       0.01179  0.01242  0.15512]                           <br/>[ 1.       0.00921  0.01098  0.15003]                           <br/>[ 2.       0.00771  0.01031  0.14431]                           <br/>[ 3.       0.00632  0.01016  0.14358]                           <br/>[ 4.       0.01003  0.01305  0.16574]                           <br/>[ 5.       0.00827  0.01087  0.14937]                           <br/>[ 6.       0.00628  0.01025  0.14506]                           <br/>[ 7.       0.0053   0.01     0.14449]<br/></span></pre><p id="c658" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">注意:- </strong>从梯度推进切换到深度学习是好的，因为它需要更少的特征工程，并且它是需要更少维护的更简单的模型。这是使用深度学习方法的最大好处之一。使用这种方法，我们可以得到很好的结果，但工作量要少得多。</p><p id="e549" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">总结:- </strong></p><p id="5b87" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">第一步:- </strong>列出分类变量名和连续变量名，放入数据框。</p><p id="5f15" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">步骤 2:- </strong>创建一个我们希望包含在验证集中的 row_indexes 列表。</p><p id="eb4b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">步骤 3:- </strong>创建柱状模型数据对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="800a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">步骤 4:- </strong>创建一个我们希望嵌入矩阵有多大的列表。</p><p id="fc8f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">步骤 5:- </strong>调用 get_learner 并使用确切的参数开始。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="0705" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">第六步:- </strong>调用 m.fit()</p><p id="098c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我已经使用了<a class="ae lj" href="https://twitter.com/hortonhearsafoo" rel="noopener ugc nofollow" target="_blank">威廉姆·霍顿</a>的这篇<a class="ae lj" rel="noopener" target="_blank" href="/announcing-fast-ai-part-1-now-available-as-kaggle-kernels-8ef4ca3b9ce6">博文</a>中提到的内核。</p><p id="7fa1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="mq">！！！恭喜你在 fast.ai 上又学完了一课。干得好。！！！</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr lz l"/></div></figure><p id="90c2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="mq">如果你喜欢，那么</em><strong class="kp ir"><em class="mq">ABC</em></strong><em class="mq">(</em><strong class="kp ir"><em class="mq">永远被击节</em> </strong> <em class="mq">。</em><strong class="kp ir">T37】👏 👏👏👏👏😃😃😃😃😃😃😃😃😃<em class="mq">👏 👏👏👏👏👏</em> </strong> <em class="mq"> ) </em></p><p id="d488" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果您有任何问题，请随时在<a class="ae lj" href="http://forums.fast.ai/" rel="noopener ugc nofollow" target="_blank"> fast.ai 论坛</a>或 Twitter 上联系:<a class="ae lj" href="https://twitter.com/ashiskumarpanda" rel="noopener ugc nofollow" target="_blank"> @ashiskumarpanda </a></p><p id="4325" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">注:随着我继续学习其他课程，这篇博文将会更新和改进。更多有趣的东西，可以随时查看我的<a class="ae lj" href="https://github.com/CaptainAshis" rel="noopener ugc nofollow" target="_blank"><em class="mq">Github</em></a><em class="mq">账号。</em></p><p id="2601" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了充分利用这个博客系列，请按照以下顺序随意探索这个系列的第一部分</p><ol class=""><li id="fb8c" class="lk ll iq kp b kq kr kt ku kw lm la ln le lo li lp lq lr ls bi translated"><a class="ae lj" rel="noopener" target="_blank" href="/fast-ai-season-1-episode-2-1-e9cc80d81a9d">狗 Vs 猫图像分类</a></li><li id="2ba3" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated"><a class="ae lj" rel="noopener" target="_blank" href="/fast-ai-season-1-episode-2-2-dog-breed-classification-5555c0337d60">犬种图像分类</a></li><li id="f491" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated"><a class="ae lj" rel="noopener" target="_blank" href="/fast-ai-season-1-episode-3-a-case-of-multi-label-classification-a4a90672a889">多标签图像分类</a></li><li id="a7b7" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated"><a class="ae lj" rel="noopener" target="_blank" href="/fast-ai-season-1-episode-4-1-time-series-analysis-a23217418bf1">使用神经网络的时间序列分析</a></li><li id="adee" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated"><a class="ae lj" href="https://geneashis.medium.com/nlp-sentiment-analysis-on-imdb-movie-dataset-fb0c4d346d23" rel="noopener">IMDB 电影数据集上的 NLP-情感分析</a></li><li id="d5b1" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated"><a class="ae lj" rel="noopener" target="_blank" href="/fast-ai-season-1-episode-5-1-movie-recommendation-using-fastai-a53ed8e41269">电影推荐系统基础</a></li><li id="22f7" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated"><a class="ae lj" rel="noopener" target="_blank" href="/fast-ai-season-1-episode-5-2-collaborative-filtering-from-scratch-1877640f514a">从零开始协同过滤</a></li><li id="6966" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated"><a class="ae lj" rel="noopener" target="_blank" href="/fast-ai-season-1-episode-5-3-collaborative-filtering-using-neural-network-48e49d7f9b36">使用神经网络的协同过滤</a></li><li id="5624" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated"><a class="ae lj" href="https://geneashis.medium.com/fast-ai-season-1-episode-6-1-write-philosophy-like-nietzsche-using-rnn-8fe70cfb923c" rel="noopener">像尼采一样写哲学</a></li><li id="5650" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated"><a class="ae lj" href="https://geneashis.medium.com/fast-ai-season-1-episode-7-1-performance-of-different-neural-networks-on-cifar-10-dataset-c6559595b529" rel="noopener">不同神经网络在 Cifar-10 数据集上的性能</a></li><li id="4ca7" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated"><a class="ae lj" href="https://medium.com/hackernoon/single-object-detection-e65a537a1c31" rel="noopener">检测图像中最大物体的 ML 模型 Part-1 </a></li><li id="ae3d" class="lk ll iq kp b kq lt kt lu kw lv la lw le lx li lp lq lr ls bi translated"><a class="ae lj" href="https://medium.com/hackernoon/single-object-detection-part-2-2deafc911ce7" rel="noopener">检测图像中最大物体的 ML 模型 Part-2 </a></li></ol><p id="34b9" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">编辑 1:-TFW·杰瑞米·霍华德同意你的帖子。💖💖 🙌🙌🙌 💖💖。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np lz l"/></div></figure></div></div>    
</body>
</html>