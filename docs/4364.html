<html>
<head>
<title>Sensor Fusion — Part 1: Kalman Filter basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">传感器融合第 1 部分:卡尔曼滤波基础知识</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sensor-fusion-part-1-kalman-filter-basics-4692a653a74c?source=collection_archive---------2-----------------------#2018-08-11">https://towardsdatascience.com/sensor-fusion-part-1-kalman-filter-basics-4692a653a74c?source=collection_archive---------2-----------------------#2018-08-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/aa6d880a4da948c99ce77d705067b938.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sKpJmj16sJwoAIkAlhkYgQ.jpeg"/></div></div></figure><p id="ad68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本系列中，我将尝试解释卡尔曼滤波算法以及一个在多个传感器输入的帮助下跟踪车辆的实现示例，这通常称为传感器融合。</p><p id="5e6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最基本形式的卡尔曼滤波器由 3 个步骤组成。a)预测——基于车辆位置和运动学方程的先前知识，我们预测时间 t+1 后车辆的位置。b)测量-从传感器获得关于车辆位置的读数，并将其与预测进行比较 C)更新-基于我们的预测和传感器读数更新我们关于车辆位置(或状态)的知识。仅此而已。卡尔曼滤波器的所有变体只是上述 3 个步骤的不同变体，这取决于你想要使用的不同运动学方程和你想要并入算法的不同种类的传感器读数。但是不管变型如何，所有卡尔曼滤波器的实现都包括上述 3 个步骤。因此，让我们使用车辆跟踪示例来分析它们。</p><p id="b62c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">A.预测</p><p id="8e97" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用速度、距离和时间的基本方程，我们知道如果我的车辆在时间<em class="kw"> t </em>的位置在<em class="kw"> x </em>位置，那么在时间<em class="kw"> t+1 </em>车辆将在位置 x+((t+1)-t)* v，其中 v 是车辆的速度。进一步挖掘，如果我们有可用的加速度值，我们可以将它添加到上面的等式中，并将车辆的新位置更新为 x+((t+1)-t)* v+ 0.5 * a *(t+1)-t)2。公式化上述方程，让表示车辆的当前状态，其由作为向量 x 的车辆的当前位置和速度组成。因此向量 x 将具有 4 个元素，即 px、py、vx、vy；分别表示 x 和 y 方向的位置和速度。</p><p id="d4b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了让我们的例子尽可能简单(但不要比它需要的更简单)，我们将在二维空间跟踪车辆，考虑到我们还没有会飞的汽车，这是一个公平的估计😊。位置 x 和 y 距离是相对于我们的车辆本身的位置。所以如果我们说一辆车在位置 px 和 py，我们的意思是它离我们的车有 px 和 py 的距离。</p><p id="717f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">继续，让我们将速度和加速度定义为分别具有 x 和 y 方向上的速度和加速度数据的速度和加速度矢量。我们将时间变化表示为 delta_t，这样，我们跟踪位置和速度的单独方程就变成:</p><p id="7b1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1.Px(t+1)= Px+delta _ t * VX+0.5 * ax * delta _ t 2</p><p id="ed74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.Py(t+1)= Py+delta _ t * vy+0.5 * ay * delta _ T2</p><p id="cb5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.Vx(t+1) = Vx + ax * delta_t</p><p id="f3f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4.Vy(t+1) = Vy + ay * delta_t</p><p id="328d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不用深入细节，我们应该明白的一件事是，执行矩阵运算在计算上比求解单个方程有效得多。一个简单的理由是，如果我们考虑上述 4 个等式，控制器(将执行 1 和 0 操作的实际微控制器)将需要执行以下动作 4 次。I)创建一个变量 Px(t+ 1)，ii)。获取 Px iii 的值)。获取 delta_t iv 的值)。获取 vx v 的值)。获取 ax vi 的值)。执行数学运算 vii)。存储结果。对于每个等式，所有这些操作都必须执行一次。为了更好地解释这个类比，假设你妈妈让你去杂货店买些洋葱(类似于从内存中获取 Px，vx，ax 值)。作为一个听话的孩子，你马上去把它带来。然后她让你切开它们(类似于数学运算)，你照做了，然后就在你要看足球比赛的时候，她让你从商店里带西红柿回来。再次，作为听话的孩子，你回去带西红柿，收集所有的设备(刀，切割片和一个碗来保存它们)，切西红柿并为她储存。然后她让你带些水果来……还有更多。你在这里得到了要点，足以说，那天晚上你不会是一个快乐的孩子。如果你的妈妈给了你所有需要带的东西的清单，并指示你在开始工作前把它们剪下来，这不是更好吗？电脑也是如此。(必须承认，我一直在等着写这个类比😊)</p><p id="fe60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到 1 和 0，让我们把 4 个独立的方程转换成下面的矩阵形式。现在我们的 4 个方程组合在一起，它们看起来像这样。</p><p id="59e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">x_new = A * x + B * u 其中</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kx"><img src="../Images/72ab58265ef6f6c457ad09eaad1d79af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MaQHT-LfjvssRgZlszejQg.png"/></div></div></figure><p id="a844" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从上面的矩阵方程中取出第一行</p><p id="015a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">px _ new =[(1 * px)+(0 * py)+(delta _ t * VX)+(0 * vy)]+[(0.5 * delta _ t * delta _ t * acceleration _ x)+(0 * acceleration _ y)]</p><p id="8faf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">px_new = px + delta_t * vx + 0.5 *加速度 _x * delta_t 2</p><p id="432b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这和我们在把单个方程转换成矩阵形式之前想出来的是一样的。这里矩阵 A 和 B 只是代表位置、速度和加速度的运动学方程的矩阵。</p><p id="d2bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">哦，但是等等..嗯…妈妈在问..去……去…去杂货店(这次她道歉了)…所以你回说嘿，妈妈，我要去看足球比赛，我现在不能去。而且妈妈说<em class="kw">所以告诉我(</em> <strong class="ka ir"> <em class="kw">预测</em> </strong> <em class="kw">)你什么时候能走。</em>和你回复<em class="kw">我就进去</em> <strong class="ka ir"> <em class="kw">关于</em> </strong> <em class="kw"> 2 hrs。</em>那么，你问的这个对话有趣的部分是什么……嗯，是“关于”的部分。正如你能感觉到的，你有点不确定你什么时候能回去。你知道它将在 2 小时内，但有一点点+- 10(或 15 或选择一个数字)分钟的不确定性，你不确定。也许在比赛中增加了很多额外的时间，也许比赛变得无聊了(当你的球队正在输球时阅读它),你决定不等到结束，或者也许这是一场德比比赛中的伟大胜利，你想在比赛庆祝和专家分析后等待和观看。</p><p id="e488" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个不确定因素对计算机也适用。一个想法可能会进入你的脑海，卡尔曼滤波器有什么了不起的，上面提到的运动学方程已经知道几十年了，如果你喜欢，我们可以用它的矩阵形式，并开始预测。但是就像本杰明·富兰克林说的那样，生活中只有两件事是确定的:死亡和纳税。因此，当我们要求计算机预测车辆新状态的价值时，我们也需要询问它的不确定性。在卡尔曼滤波语言中，这种不确定性被表示为协方差矩阵。让我们将状态协方差矩阵表示为</p><p id="f540" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">p =[方差 _px，0，0，0]，</p><p id="ff61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[0，方差 _py，0，0]，</p><p id="fc1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[0，0，方差 _vx，0]，</p><p id="1265" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[0，0，0，方差 _vy]</p><p id="7b39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中，方差 _px、方差 _py、方差 _vx、方差 _vy 分别表示预测的 x 位置、y 位置、x 速度和 y 速度的不确定性。所有剩下的 0 项是说一个值的不确定性独立于另一个值，意思是说我的<em class="kw">位置 x </em>不确定性与我在 y 方向的不确定性无关。这不需要在每种情况下都是正确的。在某些情况下，你所追踪的变量实际上可能是相互依赖的。但是我们将在这里使用简单的方法，并将其他值设为 0。这实际上使它成为一个“方差”矩阵，但协方差是更广泛使用的术语。</p><p id="0249" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">冒着让我们的方程变得有点复杂的风险，我想引入过程噪声协方差矩阵 q。在任何协方差矩阵计算中(在我们的例子中是矩阵 P)，都可能有一定量的噪声需要加入其中，以便在估计中得出新的预测协方差。</p><p id="df83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于卡尔曼滤波是一个连续的迭代过程，我们需要在每次从传感器获得新的读数时预测状态向量及其协方差矩阵，这样我们就可以将预测值(步骤 a)与传感器值(步骤 b)进行比较，并更新我们正在跟踪的车辆的信息(步骤 c)。我们已经有了更新状态向量的方程，更新协方差矩阵的方程如下所示。这样，我们用下面两个方程结束了预测的步骤 a。</p><p id="4a0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">状态向量:x = A * x + B * u</p><p id="015f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">协方差矩阵:P = A * P * AT * Q</p><p id="c5dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">B.尺寸</p><p id="c1e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，假设我们接收到一个传感器读数，显示我们正在跟踪的车辆的位置。实际上，操作顺序是，只有当我们收到传感器读数时，才触发卡尔曼滤波计算。传感器读数通常具有与每个读数相关联的时间戳。我们读取时间戳，计算最后一次读取时间戳和这次读取的时间戳之间的差异。使用 delta_t =两个读数之间的时间戳差值，按照上述说明进行预测，然后进入传感器输入的测量和更新部分。像激光雷达和飞行时间传感器这样常用传感器会给你关于车辆位置的读数，但不是它的速度。因此，我们的传感器读数将是矢量 z = [px，py]的形式。如前所述，我们需要将该测量值与步骤 a 中预测的值进行比较。但是查看两个向量(预测的状态向量 x 和测量向量 z)，我们会发现两者的阶数不同。因此，为了将状态矩阵转换为与 z 相同的大小，我们引入了矩阵“H”。进入矩阵基础，要将一个 4 x 1 ' <em class="kw"> x' </em>矩阵转换成 2 x 1 ' <em class="kw"> z' </em>矩阵(同时保持前两个值不变并移除速度变量),我们使用一个 2 x 4 矩阵 h。因此，比较预测值和测量值的等式变为 y = z-Hx，这给出了两个值之间的差异。</p><p id="56b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一步，我们还将计算卡尔曼增益。该增益系数基本上用于确定车辆状态的最终值，在预测值和测量值之间选择一个合适的值。我们已经将预测值中的不确定性视为状态协方差矩阵 p。测量读数的相应不确定性矩阵是测量协方差矩阵，用字母 r 表示。我们的状态变量有 4 个变量(x，y 位置和速度),因此其协方差矩阵为 4 x 4 矩阵。如前所述，让我们考虑我们的传感器只给我们 x 和 y 方向的位置读数。在这种情况下，我们的测量协方差矩阵将是 2 x 2 的形状，如下所示。</p><p id="cff9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">r =[[方差 _ 输入 _ 位置 _ x _ 读数，0]</p><p id="e2a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[0，方差 _ 输入 _ 位置 _ y _ 读数]</p><p id="f50b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">显然，在决定最终值时，我们希望更倾向于具有较少不确定性的值。在<em class="kw">卡尔曼增益</em>值中，我们通过计算预测值中的不确定度占总不确定度的百分比来比较预测和测量方法中的不确定度。换句话说</p><p id="4d89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">卡尔曼增益=预测状态的不确定性/(预测状态的不确定性+测量读数的不确定性)。</strong>我们知道预测状态中的不确定性是矩阵 P，测量值中的不确定性是矩阵 r。但正如您所见，两者大小不同。因此，我们使用 H 矩阵将 P 矩阵转换为正确的大小。这样，卡尔曼增益方程就变成= &gt;</p><p id="6569" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">K = ( P * HT ) / ( ( H * P * HT ) + R)</p><p id="3513" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用 4 x 4 P 矩阵和 2 x 2 R 矩阵计算卡尔曼增益所需的 h 矩阵如下所示</p><p id="f082" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">H = [ [1，0，0，0]，</p><p id="fdd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">[0, 1, 0, 0] ]</p><p id="b7e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还是那句话，P 矩阵周围 H 矩阵的填充只是为了矩阵运算，请不要让它吓到你。卡尔曼增益只是一个简单的百分比公式。</p><p id="fbed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，有了预测值、测量值和卡尔曼增益值，是时候移动到更新状态了，在这里我们对状态向量 x 及其相应的协方差矩阵 p 进行最终更新。</p><p id="a572" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">C.更新</p><p id="bdc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">即使我想，我也不能让这一步变得复杂，所以我会给你最终状态向量的方程--&gt; x = x+Ky。假设我们对预测值非常有信心，那么我们的协方差 P 将会有非常小的方差值。这反过来将使卡尔曼增益(即<em class="kw">预测状态的不确定性/预测状态的不确定性+测量读数的不确定性</em>)。)作为最终等式的小数字将是<em class="kw">小数字/(小数字+大数字)</em>的形式。在这种情况下，如果我们考虑最终的 x 方程，我们取预测值，只将它的一小部分差值(即预测值和测量值之间的差值)加到测量值上。因为根据上述理论，卡尔曼增益将是一个小值，所以 x 的方程将是:x = x +(小数字* y)</p><p id="4203" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，这将导致最终 x 更倾向于预测值，这与我们最初假设一致，即与测量值相比，我们对预测值有更高信心。类似地，更新协方差矩阵的等式为 P = (I-KH) P。同样，H 矩阵用于矩阵操作。</p><p id="7eca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，我们就有了实现完整卡尔曼滤波器所需的所有工具，公式如下</p><p id="2fdd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">A.预测:</p><p id="c789" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">a.X = A * X + B * u</p><p id="ee6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">b.P = A * P * AT * Q</p><p id="256a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">B.尺寸</p><p id="bd74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">a.Y = Z — H * X</p><p id="f45f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">b.K = ( P * HT ) / ( ( H * P * HT ) + R)</p><p id="e7d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">C.更新</p><p id="909d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">a.X = X + K * Y</p><p id="5954" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">b.P = ( I — K * H ) * P</p><p id="19c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与我的其他文章类似，我也想在这篇文章中加入玩具代码，但是这篇文章读起来很长。我肯定会在这个系列的后续部分中添加它，我计划使用卡尔曼滤波器完成传感器融合。</p><p id="bb5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像往常一样，如果你喜欢我的文章，用喜欢和评论来表达你的欣赏。你也可以在 twitter 上找到我和我的其他文章</p><p id="e64f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">直到下一次…干杯！！</p></div></div>    
</body>
</html>