<html>
<head>
<title>Deep Learning; Personal Notes Part 1 Lesson 3: CNN theory; Convolutional filters, Max pooling, activations, softmax, sigmoid &amp; submitting results to Kaggle.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度学习；个人笔记 Part 1 第三课:CNN 理论；卷积过滤器，最大池，激活，softmax，sigmoid &amp;提交结果给 Kaggle。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deep-learning-personal-notes-part-1-lesson-3-cnn-theory-convolutional-filters-max-pooling-dbe68114848e?source=collection_archive---------17-----------------------#2018-08-21">https://towardsdatascience.com/deep-learning-personal-notes-part-1-lesson-3-cnn-theory-convolutional-filters-max-pooling-dbe68114848e?source=collection_archive---------17-----------------------#2018-08-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9c4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着我对快速人工智能<a class="ae kl" href="http://www.fast.ai/" rel="noopener ugc nofollow" target="_blank">课程的第二次尝试，这个博客系列将会更新。</a>以上是我的个人笔记；a 努力把事情理解清楚，解释好。没什么新意，只活出了这个<a class="ae kl" href="https://medium.com/@itsmuriuki/why-i-will-be-writing-about-machine-learning-and-deep-learning-57c68090f201" rel="noopener"> <em class="km">博客</em> </a> <em class="km">。</em></p></div><div class="ab cl kn ko hu kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ij ik il im in"><p id="f34d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">快狗 Vs 猫</strong></p><p id="6723" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是一个端到端的过程，以获得狗与猫的最先进的结果:</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ku"><img src="../Images/3f02fa2a66bb22e840edf994eb068584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ExH5UYcljSjnyHeN1yxx-g.png"/></div></div></figure><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="45ba" class="ll lm iq lh b gy ln lo l lp lq">PATH = "data/dogscats/"</span></pre><p id="0d24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们假设您的数据在<code class="fe lr ls lt lh b">data</code>文件夹中。但是你可能想把它们放在别的地方。在这种情况下，你可以使用符号链接或简称符号链接。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi lu"><img src="../Images/64aebd0c3e157dbbb1893fe6c88a88b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EJCKyus85jhJlv8DlazxMA.png"/></div></div></figure><p id="e422" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:我们没有设置<code class="fe lr ls lt lh b">pre_compue=True</code>。这是一种快捷方式，可以缓存一些中间步骤，不必每次都重新计算，也可以省去。当<code class="fe lr ls lt lh b">pre_compute=True</code>时，数据增强不起作用。</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="df5d" class="ll lm iq lh b gy ln lo l lp lq">learn.unfreeze() <br/>learn.<strong class="lh ir">bn_freeze</strong>(<strong class="lh ir">True</strong>) <br/>%time learn.fit([1e-5, 1e-4,1e-2], 1, cycle_len=1)</span></pre><p id="c9f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lr ls lt lh b">bn_freeze</code> —如果您正在使用更大更深的模型，如 ResNet50 或 ResNext101，即在与 ImageNet 非常相似的数据集上编号大于 34 的任何东西，即尺寸在 200-500 像素之间与 ImageNet 相似的标准对象的侧面照片，您应该添加此行。<em class="km">它导致批量标准化移动平均值不被更新。</em></p><h2 id="598d" class="ll lm iq bd lv lw lx dn ly lz ma dp mb jy mc md me kc mf mg mh kg mi mj mk ml bi translated">使用其他库— Keras</h2><p id="4675" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">就像 fast ai 坐在 pytorch 上面，keras 坐在 TensorFlow，MXNet，CNTK 等上面。</p><p id="6244" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您需要安装 Keras 或 tensorflow 作为后端:</p><p id="f899" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lr ls lt lh b">pip install tensorflow-gpu keras</code></p><p id="91de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进口:</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="f2c9" class="ll lm iq lh b gy ln lo l lp lq">import numpy as np<br/>from keras.preprocessing.image import ImageDataGenerator<br/>from keras.preprocessing import image<br/>from keras.layers import Dropout, Flatten, Dense<br/>from keras.applications import ResNet50<br/>from keras.models import Model, Sequential<br/>from keras.layers import Dense, GlobalAveragePooling2D<br/>from keras import backend as K<br/>from keras.applications.resnet50 import preprocess_input</span></pre><p id="b95e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据路径:</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="825f" class="ll lm iq lh b gy ln lo l lp lq">PATH = "data/dogscats/"<br/>sz=224<br/>batch_size=64</span><span id="123f" class="ll lm iq lh b gy mr lo l lp lq">train_data_dir = f'{PATH}train'<br/>validation_data_dir = f'{PATH}valid'</span></pre><p id="8523" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Keras 使用 train 文件夹和 validation 文件夹的概念，子文件夹带有标签名称。</p><p id="04c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Keras 需要更多的代码和设置更多的参数。</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="edf5" class="ll lm iq lh b gy ln lo l lp lq">train_datagen = ImageDataGenerator(preprocessing_function=preprocess_input,<br/>    shear_range=0.2, zoom_range=0.2, horizontal_flip=True)</span><span id="d589" class="ll lm iq lh b gy mr lo l lp lq">test_datagen = ImageDataGenerator(preprocessing_function=preprocess_input)</span><span id="f7d2" class="ll lm iq lh b gy mr lo l lp lq">train_generator = train_datagen.flow_from_directory(train_data_dir,<br/>    target_size=(sz, sz),<br/>    batch_size=batch_size, class_mode='binary')</span><span id="dce4" class="ll lm iq lh b gy mr lo l lp lq">validation_generator = test_datagen.flow_from_directory(validation_data_dir,<br/>    shuffle=False,<br/>    target_size=(sz, sz),<br/>    batch_size=batch_size, class_mode='binary')</span></pre><p id="6ee3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不是创建一个单一的数据对象，而是在 Keras 中定义<code class="fe lr ls lt lh b">DataGenerator</code>，它指定如何生成数据，还指定我们希望它做什么样的数据扩充(<code class="fe lr ls lt lh b">shear_range=0.2, zoom_range=0.2, horizontal_flip=True)</code>以及做什么样的规范化(<code class="fe lr ls lt lh b">preprocessing_function=preprocess_input)</code>)。换句话说，在 Fast.ai 中，我们可以只说“无论 ResNet50 需要什么，请为我这样做”，但在 Keras 中，您需要知道期望什么。没有标准的扩充集。</p><p id="5a6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lr ls lt lh b">train_generator</code> —通过从目录中查找、设置图像的大小以及小批量和小类的大小来生成图像。当训练时，你随机地重新排序图像，显示它们以不同的顺序显示，通过混洗使它们随机。</p><p id="dd80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lr ls lt lh b">class_mode= ‘binary’</code>——如果你有两个可能的输出，就用二进制，如果是倍数，就用<code class="fe lr ls lt lh b">‘categorical’</code></p><p id="49a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lr ls lt lh b">train_generator</code> —通过从目录中查找、设置图像大小和小批量的大小来生成图像。</p><p id="c5db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后创建一个验证数据生成器<code class="fe lr ls lt lh b">validation_generator</code>，这个生成器没有数据扩充。还要告诉它不要为了验证而打乱数据集，因为否则你无法跟踪你做得有多好。</p><h2 id="43a7" class="ll lm iq bd lv lw lx dn ly lz ma dp mb jy mc md me kc mf mg mh kg mi mj mk ml bi translated">创建模型</h2><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="ca01" class="ll lm iq lh b gy ln lo l lp lq">base_model = ResNet50(weights='imagenet', include_top=False)<br/>x = base_model.output<br/>x = GlobalAveragePooling2D()(x)<br/>x = Dense(1024, activation='relu')(x)<br/>predictions = Dense(1, activation='sigmoid')(x)</span></pre><p id="3285" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用 ResNet50，因为 keras 没有 ResNet34。对于 keras，您不能告诉它创建一个适合特定数据集的模型。你必须用手来做。</p><p id="232e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先创建一个<code class="fe lr ls lt lh b">base_model</code>，然后构建你想要添加的层，即<code class="fe lr ls lt lh b">x</code>，在这种情况下，我们添加 3 层。</p><h2 id="bc4a" class="ll lm iq bd lv lw lx dn ly lz ma dp mb jy mc md me kc mf mg mh kg mi mj mk ml bi translated">冻结图层并编译模型</h2><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="62b5" class="ll lm iq lh b gy ln lo l lp lq">model = Model(inputs=base_model.input, outputs=predictions)</span><span id="47d1" class="ll lm iq lh b gy mr lo l lp lq">for layer in base_model.layers: layer.trainable = False</span><span id="c2fa" class="ll lm iq lh b gy mr lo l lp lq">model.compile(optimizer='rmsprop', loss='binary_crossentropy', metrics=['accuracy'])</span></pre><p id="cc71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lr ls lt lh b">layer.trainable=False </code> —循环浏览各层，并使用<code class="fe lr ls lt lh b">.trainable = False</code>冻结</p><p id="abe8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过传递您想要使用的<code class="fe lr ls lt lh b">optimizer</code>、要查找的<code class="fe lr ls lt lh b">loss</code>和要使用的<code class="fe lr ls lt lh b">metric</code>来编译模型。</p><h2 id="b1eb" class="ll lm iq bd lv lw lx dn ly lz ma dp mb jy mc md me kc mf mg mh kg mi mj mk ml bi translated">适合的</h2><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="11a8" class="ll lm iq lh b gy ln lo l lp lq">%%time<br/>model.fit_generator(train_generator, train_generator.n // batch_size, epochs=3, workers=4,<br/>        validation_data=validation_generator, validation_steps=validation_generator.n // batch_size)</span></pre><p id="0ff2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">调用 fit_generator 并传递<code class="fe lr ls lt lh b">train_generator </code>和<code class="fe lr ls lt lh b">validation _generator</code></p><p id="884d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为 keras 希望您告诉它每个时期有多少批，所以 bathes 的数量=大小是生成器除以批大小，告诉它有多少个时期，以及有多少个工人，即处理器。</p><h2 id="6364" class="ll lm iq bd lv lw lx dn ly lz ma dp mb jy mc md me kc mf mg mh kg mi mj mk ml bi translated">微调</h2><p id="701d" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">解冻一些层，编译，然后再次适合。</p><p id="439a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没有层组或差异学习率或部分取消冻结的概念，你必须打印出所有的层，并决定有多少你想要微调。我们从<code class="fe lr ls lt lh b">140 </code>开始微调。</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="b39f" class="ll lm iq lh b gy ln lo l lp lq">split_at = 140</span><span id="69eb" class="ll lm iq lh b gy mr lo l lp lq"><strong class="lh ir">for</strong> layer <strong class="lh ir">in</strong> model.layers[:split_at]: layer.trainable = <strong class="lh ir">False</strong><br/><strong class="lh ir">for</strong> layer <strong class="lh ir">in</strong> model.layers[split_at:]: layer.trainable = <strong class="lh ir">True</strong></span><span id="3dda" class="ll lm iq lh b gy mr lo l lp lq">model.compile(optimizer='rmsprop', loss='binary_crossentropy',<br/>    metrics=['accuracy'])</span><span id="b7ec" class="ll lm iq lh b gy mr lo l lp lq">%%time<br/>model.fit_generator(train_generator, train_generator.n // batch_size, epochs=1, workers=3,<br/>        validation_data=validation_generator, validation_steps=validation_generator.n // batch_size)</span></pre><p id="8f4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">微调后，你必须重新编译模型，然后拟合。</p><h1 id="9bfc" class="ms lm iq bd lv mt mu mv ly mw mx my mb mz na nb me nc nd ne mh nf ng nh mk ni bi translated">向 Kaggle 提交结果</h1><p id="68e1" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">在 kaggle 竞赛中，有一个称为评估的部分描述了如何对竞赛进行评估:</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi nj"><img src="../Images/57af6b1480dd1e424d07d52c39addf47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vuVUqKozpr6lFZ2PP08N6A.png"/></div></div></figure><p id="0937" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于标签位于不同文件夹的数据集，使用<code class="fe lr ls lt lh b">ImageClassifierData.from_paths</code>。如果您有带标签的 aCSV 文件，您可以使用<code class="fe lr ls lt lh b">ImageClassifierData.from_csv</code>。</p><p id="60e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要创建提交，您需要使用:</p><p id="0ac0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lr ls lt lh b">data.classes</code>:包含所有不同的类</p><p id="8eb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lr ls lt lh b">data.test_ds.fnames</code>:包含测试文件名</p><p id="5053" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用测试时间增加(TTA)是一个好主意。通过使用<code class="fe lr ls lt lh b">is_test=True</code>,它将给出测试集的预测，而不是验证集的预测。</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="18a3" class="ll lm iq lh b gy ln lo l lp lq">log_preds, y = learn.TTA(is_test=True) <br/>probs = np.exp(log_preds)</span></pre><p id="8d74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数 PyTorch 模型会给你返回预测的日志，所以你需要做<code class="fe lr ls lt lh b">np.exp(log_preds)</code>来得到概率。</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="94fc" class="ll lm iq lh b gy ln lo l lp lq">probs.shape #(n_images, n_classes(breeds))<br/>(10357, 120)</span></pre><p id="9e15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将矩阵转换成 kaggle 格式，我们使用熊猫数据帧:</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="5ec1" class="ll lm iq lh b gy ln lo l lp lq">df = pd.DataFrame(probs)<br/>df.columns = data.classes</span></pre><p id="c570" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个熊猫数据框架并传递矩阵(<code class="fe lr ls lt lh b">probs</code>)。将列名设置为<code class="fe lr ls lt lh b">data.classes</code></p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="4620" class="ll lm iq lh b gy ln lo l lp lq">df.insert(0, 'id', [o[5:-4] for o in data.test_ds.fnames])</span></pre><p id="c3d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在零位置插入一个名为<code class="fe lr ls lt lh b">id</code>的包含文件名的新列。这是文件名的样子。<code class="fe lr ls lt lh b">test/ab2520c527e61f197be228208af48191.jpg’</code>。删除前 5 个和最后 4 个字母以获得 id。</p><p id="89bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看数据帧:</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi nk"><img src="../Images/83e3163eed65818c92583d0c9cc31dd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0odViLIJP3GdYHIPHBBW8w.png"/></div></div></figure><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="39d6" class="ll lm iq lh b gy ln lo l lp lq">SUBM = f'{PATH}/subm/'<br/>os.makedirs(SUBM, exist_ok=True)<br/>df.to_csv(f'{SUBM}subm.gz', compression='gzip', index=False)</span></pre><p id="b05f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">调用<code class="fe lr ls lt lh b">df.to_csv</code>创建一个 CSV 文件，并使用<code class="fe lr ls lt lh b">compression=’gzip’</code>对其进行压缩。这将文件保存到服务器。您可以使用 kaggle CLI 通过使用此命令<code class="fe lr ls lt lh b">$ kg submissions</code>进行提交，或者使用<code class="fe lr ls lt lh b">FileLink(f’{SUBM}subm.gz’)</code>将其下载到您的计算机并上传到 kaggle。这将为您提供一个链接，将文件从服务器下载到您的计算机上。</p><h2 id="78bd" class="ll lm iq bd lv lw lx dn ly lz ma dp mb jy mc md me kc mf mg mh kg mi mj mk ml bi translated">个体预测</h2><p id="a3f6" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">通过模型运行单个图像以获得预测。</p><p id="e5f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打开验证集中的第一个文件:</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="1260" class="ll lm iq lh b gy ln lo l lp lq">fn = data.val_ds.fnames[0]<br/>fn<br/>'train/000bec180eb18c7604dcecc8fe0dba07.jpg'<br/>Image.open(PATH + fn).resize((150, 150))</span></pre><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/58a3d20fa1865e82fc97763e36fda90f.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*uB3KNm7Wq8IUhY48S8d-_A.png"/></div></figure><p id="f8ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行预测:</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="b515" class="ll lm iq lh b gy ln lo l lp lq">trn_tfms, val_tfms = tfms_from_model(arch, sz)<br/>im = val_tfms(open_image(PATH + fn)) # open_image() returns numpy.ndarray<br/>preds = learn.predict_array(im[None])<br/>np.argmax(preds)</span></pre><p id="4c28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个形象必须改变。<code class="fe lr ls lt lh b">tfms_from_model</code>返回定型转换和验证转换。在这种情况下，我们将使用验证转换。</p><p id="e69e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">传递给模型或从模型返回的所有东西通常都被认为是小批量的。这里我们只有一个图像，但是我们必须把它变成一个小批量的单个图像。换句话说，我们需要创建一个不只是<code class="fe lr ls lt lh b">[rows, columns, channels]</code>而是<code class="fe lr ls lt lh b">[number of images, rows, columns, channels]</code>的张量。通过使用<code class="fe lr ls lt lh b">im[None]</code>索引到一个数组，在开始处添加一个额外的单位轴，从而将其从一个图像转换为一个小批量的图像。</p><h1 id="a600" class="ms lm iq bd lv mt mu mv ly mw mx my mb mz na nb me nc nd ne mh nf ng nh mk ni bi translated">卷积神经网络理论</h1><p id="2460" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">这是一个卷积神经网络可视化视频，由 Word Lens 的优秀创作者奥塔维奥制作。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="17d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你输入一幅图像，计算机会把它们识别为数字(像素)。</p><h2 id="5f35" class="ll lm iq bd lv lw lx dn ly lz ma dp mb jy mc md me kc mf mg mh kg mi mj mk ml bi translated">输入层</h2><p id="b59a" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">7 号图像数据来自<a class="ae kl" href="http://yann.lecun.com/exdb/mnist/" rel="noopener ugc nofollow" target="_blank"> MNIST </a>数据库，我们假设您使用<a class="ae kl" href="https://medium.com/coinmonks/deep-learning-personal-notes-part-1-lesson-1-f134cc8a7f2e" rel="noopener">预训练模型</a>进行分类。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi no"><img src="../Images/18973b2ab975445b9bfd0cd23add81dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CvaxOus07bpZiIxsQ8s0Tw.png"/></div></div></figure><h2 id="648c" class="ll lm iq bd lv lw lx dn ly lz ma dp mb jy mc md me kc mf mg mh kg mi mj mk ml bi translated">隐藏层 1</h2><p id="dd3a" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">隐藏图层是对输入进行转换，以便从输出图层的数据中识别更复杂的要素，从而做出更好的评估。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi np"><img src="../Images/5e0bcefc11ff5b84e84cc320a0ca3dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IX-KB61OGg41WKDUlXkSHQ.png"/></div></div></figure><p id="3d77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们应用一个<strong class="jp ir">过滤器/内核</strong>来检测大部分 3×3 的水平边缘。注意，内核<code class="fe lr ls lt lh b">A</code>顶部的<code class="fe lr ls lt lh b">1’s</code>和中间的<code class="fe lr ls lt lh b">0’s</code>以及底部的<code class="fe lr ls lt lh b">-1’s</code>:</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="ccc5" class="ll lm iq lh b gy ln lo l lp lq"> 1,   1,   1<br/> 0,   0,   0<br/>-1,  -1,  -1</span></pre><p id="b610" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果滤波器与输入相乘，我们将为高数值分配高数值，因为它们与 1 相乘，而对低数值几乎不分配任何数值，因为它们与 0 或-1 相乘。因此，我们得到了称为<strong class="jp ir"> <em class="km">激活</em> </strong> <em class="km">的第一卷积的输出，它基本上是一个通过从输入中取出某个数字，然后应用某种线性运算(即卷积核)来计算输出(激活)的数字。</em></p><p id="fd01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Conv1 显示了对输入的 3x3 部分进行处理并乘以卷积内核后两者的激活情况。</p><p id="5a6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们假设网络经过训练，在训练结束时，它创建了一个<a class="ae kl" href="http://setosa.io/ev/image-kernels/" rel="noopener ugc nofollow" target="_blank">卷积滤波器</a>，其中有 9 个数字。</p><p id="7ae9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">卷积</strong>在深度学习中，我们几乎总是有一个 3×3 的小矩阵，并将该矩阵的每个元素乘以图像的 3×3 部分的每个元素，然后将它们加在一起，以在一个点上获得卷积的结果。</p><p id="90e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们应用第二个卷积滤波器<code class="fe lr ls lt lh b">B</code>，它也有 9 个数。滤镜<code class="fe lr ls lt lh b">B</code>找到垂直边缘，作为隐藏层输出。</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="fb98" class="ll lm iq lh b gy ln lo l lp lq">1,   0,  -1<br/>1,   0,  -1<br/>1,   0,  -1</span></pre><p id="e624" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Pytorch 不会将它们存储为两个独立的 9 位数组，而是将其存储为<a class="ae kl" href="https://en.wikipedia.org/wiki/Tensor" rel="noopener ugc nofollow" target="_blank">张量</a>。这是多维数组。额外的轴允许我们将额外的过滤器堆叠在一起。<em class="km">滤镜和内核意思相同它指的是 3x3 矩阵。</em></p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi nq"><img src="../Images/fc14462a718701c36f77120b39d498db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KUgb4GfV47ATrgzvL7D6sw.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">How convolution work: Activation -3 equals the sum of matrix product of the kernel and input</figcaption></figure><p id="4dfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">隐藏层(conv1)的大小为 2，因为它有 2 个过滤器/内核。</p><p id="a11a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将应用另一个过滤器，即隐藏层 2 中的过滤器<code class="fe lr ls lt lh b">C</code>，它是两个 2x3x3 内核，然后应用<strong class="jp ir">校正线性单元(ReLu) </strong>来消除负像。从而创建第二隐藏层 conv2。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi nv"><img src="../Images/db287aa0b8763d2d966eada9da1dcd23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TWmhDdxfe9FGBEwIHgWt7g.png"/></div></div></figure><p id="672b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">整流线性单元(ReLU)</strong>-是一种非线性，即扔掉底片。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/532b9c36b4706a8123e7733f8b06b19d.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*m-SmBCOtW7EnEMaP-pehrw.png"/></div></figure><p id="4266" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">建筑</strong></p><p id="eb3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">架构意味着第一层的内核有多大，第一层的内核中有多少滤波器，第一层有一个 3x3，第二层有一个 3x3，这种架构从两个 3x3 卷积内核开始。第二层有两个 2x3x3 内核。</p><p id="9972" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="km">最大统筹</em> </strong></p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/3e0fcac1c038243911d252d6ea56f715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*S86gKd43MIYquHIeR9m8JQ.png"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">convolved feature vs pooled feature</figcaption></figure><p id="cbfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着用最大值替换输出矩阵中的最大值。例如最大 2x2 池。注意:它是不重叠的，因此会降低分辨率。</p><p id="ad03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是最大池层:</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ny"><img src="../Images/80fa49f7ef9adcb0bdcc999bfd00e20e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7brLR0llnWqtkdJ14msdmQ.png"/></div></div></figure><p id="65d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最大池的结果得到适合密集权重一个完全连接的层。</p><p id="5a94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">全连接层</strong>挑选每一个最大汇集激活，给它们一个权重，并挑选最大汇集激活和 3 维张量的 2 级权重的和积。向外放一个<strong class="jp ir">密集激活</strong></p><p id="23a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这与卷积不同，在卷积中，我们使用 3×3 内核一次激活几次。但是在完全连接的层中，我们创建了一个相当于整个输入的大权重矩阵。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi nz"><img src="../Images/c7925e5766e66cd1e28561add0da5e48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ELm4B9giiTXKeKqkfQTeg.png"/></div></div></figure><p id="4d6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大量使用全连接层的架构可能会有很多权重，因此可能会有过度拟合和速度慢的问题。例如，VGG 有多达 19 层，包含一个完全连接的层，4096 个权重连接到 4096 个隐藏层激活，因此(4096 x 4096 x 内核数)，这几乎是 3 亿个权重。</p><p id="480a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">如果我们有 3 个输入通道，滤波器会是什么形状？</em>如果我们有 3 个输入通道，它看起来就像 conv1，它有 2 个通道，因此有 2 个滤波器，因此每个通道有 2 个滤波器。</p><p id="caa4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们从零开始训练时，我们不是从精心训练的过滤器开始，而是从随机数开始，并使用随机梯度下降来改善这些数字，使它们不那么随机。</p><p id="11ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际上，我们必须为十位数计算不止一个数。我们会有十次密集激活。</p><p id="ddda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Softmax </strong></p><p id="3609" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">预测图像是猫、狗、飞机、鱼还是建筑物。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/42ff28bdca8d6f6c7de70c620e40f3cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*SVPLOw1GHgqt08qBtkS9Ew.png"/></div></figure><p id="e39e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在全连接层之外，我们将有 5 个数字。请注意，在最后一层没有 Relu，所以我们可以有底片。你想把 5 个数字转换成从 0 到 1 的概率，如果是猫、狗、飞机、鱼或建筑物，就匹配它。这 5 个类别的概率应该在 0 和 1 之间，并且它们的总和应该为 1。为此，我们使用一个<strong class="jp ir"> <em class="km">激活函数</em> </strong> <em class="km">这是一个应用于激活的函数。它接受一个数字，吐出另一个数字。</em></p><p id="65cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要把线性和非线性函数叠加在一起做深度学习。我们在每个隐藏层之后使用的非线性是一个 ReLu。激活函数是非线性函数。</p><p id="66a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Softmax </strong> <em class="km">激活发生在最后一层。softmax 吐出介于</em> <code class="fe lr ls lt lh b"><em class="km">0</em></code> <em class="km">和</em> <code class="fe lr ls lt lh b"><em class="km">1</em></code> <em class="km">之间的数字，这些数字加起来就是</em> <code class="fe lr ls lt lh b"><em class="km">1</em></code> <em class="km">。</em></p><p id="b8a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了让 softmax 发挥作用，我们需要消除所有负面因素。我们将使用对数和指数。他们出现了很多机器和深度学习。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/4365df3daf5f40132a8e9cf9fcfcce78.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*keXXrJ38HLp2wPyLO9n3Sw.png"/></div></figure><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/00cda952edd024320fb211fad8d076c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*2N8Ed492kqWH4mdPKkBKqw.jpeg"/></div></figure><p id="d2d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们做<code class="fe lr ls lt lh b">e^-0.36</code>得到<code class="fe lr ls lt lh b">exp</code>，然后把它们加起来得到<code class="fe lr ls lt lh b">51.31</code>。为了得到<code class="fe lr ls lt lh b">softmax</code>，我们除以<code class="fe lr ls lt lh b">51.31</code>，得到<code class="fe lr ls lt lh b">0.01</code>。softmax 的总和应该等于<code class="fe lr ls lt lh b">1.</code></p><p id="4977" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lr ls lt lh b">exp</code>的一个特点是，如果一个数字(<code class="fe lr ls lt lh b">output</code>)比另一个稍大，它会使<code class="fe lr ls lt lh b">exp</code>变得更大。softmax 倾向于选择一个强有力的东西，也就是说，它将一个高概率分配给一个类。</p><p id="56ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">如果要把图片归类为猫和狗，我们用什么样的激活函数？Softmax 不喜欢预测多个事物。它想挑一样东西。我们可能想要这样做的一个原因是进行多标签分类。</em></p><h1 id="5d5c" class="ms lm iq bd lv mt mu mv ly mw mx my mb mz na nb me nc nd ne mh nf ng nh mk ni bi translated">星球竞赛:从太空了解亚马逊</h1><p id="5480" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">对于猫和狗比赛的单标签分类，图像要么是猫，要么是狗，不是两者都是。对于<a class="ae kl" href="https://www.kaggle.com/c/planet-understanding-the-amazon-from-space" rel="noopener ugc nofollow" target="_blank">卫星竞赛</a>来说，图像按照天气(阴霾和晴朗)、农业、原始雨林和水(河流)进行分类。在这种情况下，我们需要预测多种情况，softmax 不会很好，因为它想选择一种情况。</p><p id="5e74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">拟人化你的激活功能(赋予个性)</em> softmax 倾向于挑选一个特定的东西。</p><p id="eb03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有多个标签，Fast.ai 库将自动切换到多标签模式。所以你什么都不用做。但这是幕后发生的事情:</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="d930" class="ll lm iq lh b gy ln lo l lp lq"><strong class="lh ir">from</strong> <strong class="lh ir">planet</strong> <strong class="lh ir">import</strong> f2 </span><span id="6d87" class="ll lm iq lh b gy mr lo l lp lq">metrics=[f2] <br/>f_model = resnet34</span><span id="1516" class="ll lm iq lh b gy mr lo l lp lq">label_csv = f'<strong class="lh ir">{PATH}</strong>train_v2.csv'<br/>n = len(list(open(label_csv)))-1<br/>val_idxs = get_cv_idxs(n)</span><span id="1746" class="ll lm iq lh b gy mr lo l lp lq"><strong class="lh ir">def</strong> get_data(sz):<br/>    tfms = tfms_from_model(f_model, sz,aug_tfms=transforms_top_down,<br/>max_zoom=1.05)<br/>    <strong class="lh ir">return</strong> ImageClassifierData.from_csv(PATH, 'train-jpg',label_csv, tfms=tfms,suffix='.jpg', val_idxs=val_idxs, test_name='test-jpg')</span><span id="569e" class="ll lm iq lh b gy mr lo l lp lq">data = get_data(256) #gets images of 256x256</span></pre><p id="5f20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用<code class="fe lr ls lt lh b">from_csv</code>,因为多标签分类不能使用 Keras 风格的方法，其中子文件夹是标签的名称。</p><p id="f2a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lr ls lt lh b">transform_top_down</code>:它不仅仅是一个垂直翻转。正方形有八种可能的对称。它可以旋转 0 度、90 度、180 度和 270 度，并且可以翻转(<a class="ae kl" href="https://en.wikipedia.org/wiki/Dihedral_group" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="km">二面角</em> </strong> <em class="km">八组</em> </a>)</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="3249" class="ll lm iq lh b gy ln lo l lp lq">x,y = next(iter(data.val_dl))</span></pre><p id="530f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe lr ls lt lh b">ds</code>(数据集)我们可以得到一个单独的图像<em class="km">。</em></p><p id="096e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lr ls lt lh b">dl</code>是一个<em class="km">数据加载器，它会给你一个小批量</em>，特别是<em class="km">转换的</em>小批量。使用数据加载器，您不能请求特定的小批量，您只能取回<code class="fe lr ls lt lh b">next</code>小批量。在 Python 中，它被称为“生成器”或“迭代器”。</p><p id="9f2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PyTorch 真正利用了现代 Python 方法。如果你很了解 python，PyTorch 来的很自然。如果你不太了解 python，PyTorch 是学好 python 的一个很好的理由。</p><p id="ec0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lr ls lt lh b">x</code>是小批量的图像，<code class="fe lr ls lt lh b">y</code>是小批量的标签。打印 y:</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi od"><img src="../Images/73f3c8c0c3ad91f332ca094c08dc60ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YG0NUB1wxT2FUigB2jCC3Q.png"/></div></div></figure><p id="708d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，批大小为 64，可能的类为 17。</p><p id="f43f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看<code class="fe lr ls lt lh b">0</code>的图片标签:</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="ce7d" class="ll lm iq lh b gy ln lo l lp lq">list(zip(data.classes, y[0]))<br/><br/><em class="km">[('agriculture', 1.0),<br/> ('artisinal_mine', 0.0),<br/> ('bare_ground', 0.0),<br/> ('blooming', 0.0),<br/> ('blow_down', 0.0),<br/> ('clear', 1.0),<br/> ('cloudy', 0.0),<br/> ('conventional_mine', 0.0),<br/> ('cultivation', 0.0),<br/> ('habitation', 0.0),<br/> ('haze', 0.0),<br/> ('partly_cloudy', 0.0),<br/> ('primary', 1.0),<br/> ('road', 0.0),<br/> ('selective_logging', 0.0),<br/> ('slash_burn', 1.0),<br/> ('water', 1.0)]</em></span></pre><p id="540e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是农业，清晰，主要刀耕火种和水。</p><p id="4cf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PyTorch 和 fast.ai 是把标签变成<strong class="jp ir"><em class="km">one-hot-encoded</em></strong>标签。如果实际标签是 dog，它看起来会像这样:</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/bf338fbb186f60fd744c5cf3bd43e1db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6mFxLWcvyCXDlUXvvOQQVg.png"/></div></figure><p id="cb55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们采用<code class="fe lr ls lt lh b">softmax</code>并与<code class="fe lr ls lt lh b">actuals</code>进行比较来实际预测。<code class="fe lr ls lt lh b">actuals</code>和<code class="fe lr ls lt lh b">softmax</code>之差加在一起给出了误差，即<strong class="jp ir">损失函数。</strong></p><p id="a3bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">One-hot-encoding 对于排序来说效率非常低，所以我们将存储一个<code class="fe lr ls lt lh b">index</code>值(单个整数)，而不是目标值的 0 和 1(<code class="fe lr ls lt lh b">y</code>)。如果您查看狗品种竞赛的<code class="fe lr ls lt lh b">y</code>值，您实际上不会看到一个由 1 和 0 组成的大列表，但是您会看到一个单一的整数。</p><p id="d22b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PyTorch 在内部将索引转换为 one-hot-encoded vector(尽管您实际上永远看不到它)。PyTorch 对于热编码的和非热编码的有不同的损失函数——但是这些细节被 fast.ai 库隐藏了，所以你不必担心。但要意识到的一件很酷的事情是，我们正在为单标签分类和多标签分类做完全相同的事情。</p><p id="fd81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">为 softmax 更改 log 的基数有意义吗？</em>不，改变基底只是神经网络可以轻松学习的线性缩放:</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi of"><img src="../Images/cbe930eaf50edd6faef333d579f06e22.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*dfivFo64MYI3HVYVK98OQg.png"/></div></figure><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi og"><img src="../Images/bfdf8e9b6b268956707e1b6f8775a2f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_B6_P3KsCYOplYc0uQR8A.png"/></div></div></figure><p id="edec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:图像只是数字的矩阵。图像被洗掉了，所以为了让它更明显(“亮一点”)我们乘以<code class="fe lr ls lt lh b">*1.4</code>。</p><p id="9cd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像这样试验图像是很好的，因为这些图像一点也不像 ImageNet。你所做的绝大多数涉及卷积神经网络的事情实际上不会像 ImageNet 一样，它们将是医学成像，对不同种类的钢管、卫星图像等进行分类</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="a64b" class="ll lm iq lh b gy ln lo l lp lq">sz=64</span><span id="2f44" class="ll lm iq lh b gy mr lo l lp lq">data = get_data(sz)</span><span id="d754" class="ll lm iq lh b gy mr lo l lp lq">data = data.resize(int(sz*1.3), 'tmp')</span></pre><p id="a0ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们不会用<code class="fe lr ls lt lh b">sz=64</code>来进行猫和狗的比赛，因为我们是从预先训练的 ImageNet 网络开始的，它开始时近乎完美。如果我们用 64 乘 64 的图像重新训练整个集合，我们会破坏已经非常好的权重。请记住，大多数 ImageNet 模型都是用 224×224 或 299×299 的图像训练的。</p><p id="efd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">image net 中没有与上面的卫星图像相似的图像。imageNet 唯一有用的部分是发现边缘和渐变的第一层，发现纹理和重复图案的第二层。</p><p id="1259" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当使用卫星图像时，首先用小图像进行训练效果很好。</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="61e7" class="ll lm iq lh b gy ln lo l lp lq">learn = ConvLearner.pretrained(f_model, data, metrics=metrics)</span><span id="b4ca" class="ll lm iq lh b gy mr lo l lp lq">lrf=learn.lr_find()<br/>learn.sched.plot()</span></pre><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi oh"><img src="../Images/1b66f2b8bf0b3a36bb80dcaf74b340d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9uIOjNr2fU7rg5p7nYgj6Q.png"/></div></div></figure><h2 id="827a" class="ll lm iq bd lv lw lx dn ly lz ma dp mb jy mc md me kc mf mg mh kg mi mj mk ml bi translated">适合的</h2><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi oi"><img src="../Images/5f407e16f8b88339b9ec7e107a24b0e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MrcAjQLarOJPuFxu4WO0Bg.png"/></div></div></figure><p id="6b8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe lr ls lt lh b">[lr/9, lr/3, lr]</code>是因为图像不同于 ImageNet 图像，并且早期的图层可能没有接近它们需要的样子。</p><p id="0f6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">绘制损失图:</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi oj"><img src="../Images/6953e979d9cc9cd36cd0b85a41cab8c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yQe1nHHByxu5LUNyxq-rsg.png"/></div></div></figure><p id="c47d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们先将图像尺寸翻倍至 128，然后调整，再翻倍至 256，这样可以达到 93.5%的准确率:</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ok"><img src="../Images/2119e6fae1262ac327458ea9b6a20ffd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HYat7ZP7mmGDciHIi1FJ8w.png"/></div></div></figure><p id="0b1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试时间增加使我们达到 93.6%；</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="837c" class="ll lm iq lh b gy ln lo l lp lq">data = data.resize(int(sz*1.3), 'tmp')</span></pre><p id="839e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">这是做什么的？</em></p><p id="afed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们指定要应用什么转换时，我们传递一个大小:</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="e3b7" class="ll lm iq lh b gy ln lo l lp lq">tfms = tfms_from_model(f_model, sz,<br/>        aug_tfms=transforms_top_down, max_zoom=1.05)</span></pre><p id="cb76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据加载器做的一件事是按需调整图像的大小。这与<code class="fe lr ls lt lh b">data.resize</code>无关。如果初始输入图像是 1000 乘 1000，读取 JPEG 并将其调整为 64 乘 64 比训练卷积网络花费更多的时间。</p><p id="32b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lr ls lt lh b">data.resize</code>告诉它我们不会使用比<code class="fe lr ls lt lh b">sz*1.3</code>更大的图像，所以遍历一次并创建这个大小的新 JPEG，它是矩形的，所以最小边的新 JPEG 的大小是<code class="fe lr ls lt lh b">sz*1.3</code>中心裁剪的。这类似于循环调整图像大小的批处理脚本。这会节省你很多时间。<code class="fe lr ls lt lh b">data.resize</code>是加速便利功能。</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="3a1c" class="ll lm iq lh b gy ln lo l lp lq">metrics=[f2]</span></pre><p id="35ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们没有使用<code class="fe lr ls lt lh b">accuacy</code>，而是使用了<a class="ae kl" href="http://scikit-learn.org/stable/modules/generated/sklearn.metrics.fbeta_score.html" rel="noopener ugc nofollow" target="_blank"> F-beta </a>，这是一种衡量假阴性和假阳性的方法。我们使用它的原因是因为这个特别的 Kaggle 比赛想要使用它。查看 planet.py，了解如何使用 Skitlearn 创建自己的度量函数。这是最后打印出来的。在每个时期之后<code class="fe lr ls lt lh b">[ 0. 0.08932 0.08218 <strong class="jp ir">0.9324 </strong>]</code></p><h2 id="a1ad" class="ll lm iq bd lv lw lx dn ly lz ma dp mb jy mc md me kc mf mg mh kg mi mj mk ml bi translated">多标签分类的激活函数</h2><p id="7e7a" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">Fast.ai 检查标签以查看一个图像是否有多个标签，并自动选择激活功能。</p><p id="6bff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">多标签分类的激活函数称为<strong class="jp ir"> sigmoid。</strong></p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/bf338fbb186f60fd744c5cf3bd43e1db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6mFxLWcvyCXDlUXvvOQQVg.png"/></div></figure><p id="05f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了找到乙状结肠，选择<code class="fe lr ls lt lh b">exp</code>除以<code class="fe lr ls lt lh b">1+exp</code>，即:</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="847e" class="ll lm iq lh b gy ln lo l lp lq">0.01/1+0.01 = 0.01<br/>0.08/1+0.08 = 0.07 </span></pre><p id="7010" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这使得可以一次预测多种情况。如果某个值小于 0，则其 sigmoid 小于 0.5，如果大于 0，则其大于 0.5。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ol"><img src="../Images/2a6e54997ae56a1c0ef5ceea9861069d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ieHprxRNJNE_L_edoXKlVw.png"/></div></div></figure><p id="0302" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">与其单独训练最后几层，不如从差别学习率开始训练？你可以跳过最后一层的训练，直接学习不同的学习率，但你可能不想这样做。卷积层都包含预先训练好的权重，所以不是随机的——对于接近 ImageNet 的东西，真的很好；对于不接近 ImageNet 的东西，有总比没有好。然而，我们所有完全连接的层都是完全随机的。因此，您总是希望通过先对它们进行一点训练，使完全连接的权重优于随机权重。否则，如果你直接去解冻，那么你实际上是在摆弄那些早期的层权重，而后面的层权重仍然是随机的——这可能不是你想要的。</em></p><p id="ee6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">解冻时，你想改变什么？内核(过滤器)和权重。训练的意思是设置过滤器和密集权重。密集权重用于完全连接的层，过滤器/内核权重用于卷积。<em class="km">另一方面，激活</em>是根据权重和先前层激活或输入计算的。</em></p><p id="9b19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">如何获得 64 乘 64 的图像尺寸？这取决于变换。默认情况下，我们的变换采用最小的边缘，将其缩小，并为其拍摄中心裁剪，但当使用数据增强时，它会随机选择。</em></p><p id="c51f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">准确性不是模型试图优化的。它优化了损失函数，例如交叉熵，这个指标是打印出来的，让我们可以看到发生了什么。</p><p id="7a10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">当您使用差异学习率时，这三个学习率是否在各层之间均匀分布？</em> fast.ai 库有一个“图层组”的概念。在类似 ResNet50 的东西中，有数百个层，您可能不希望编写数百个学习率，因此库为您决定如何拆分它们，最后一个总是指的是我们随机初始化并添加的完全连接的层，其余的学习率在层之间拆分。</p><h2 id="c9c0" class="ll lm iq bd lv lw lx dn ly lz ma dp mb jy mc md me kc mf mg mh kg mi mj mk ml bi translated">可视化图层</h2><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="7da7" class="ll lm iq lh b gy ln lo l lp lq">learn.summary()</span><span id="44a0" class="ll lm iq lh b gy mr lo l lp lq"><em class="km">[('Conv2d-1',<br/>  OrderedDict([('input_shape', [-1, 3, 64, 64]),<br/>               ('output_shape', [-1, 64, 32, 32]),<br/>               ('trainable', False),<br/>               ('nb_params', 9408)])),<br/> ('BatchNorm2d-2',<br/>  OrderedDict([('input_shape', [-1, 64, 32, 32]),<br/>               ('output_shape', [-1, 64, 32, 32]),<br/>               ('trainable', False),<br/>               ('nb_params', 128)])),<br/> ('ReLU-3',<br/>  OrderedDict([('input_shape', [-1, 64, 32, 32]),<br/>               ('output_shape', [-1, 64, 32, 32]),<br/>               ('nb_params', 0)])),<br/> ('MaxPool2d-4',<br/>  OrderedDict([('input_shape', [-1, 64, 32, 32]),<br/>               ('output_shape', [-1, 64, 16, 16]),<br/>               ('nb_params', 0)])),<br/> ('Conv2d-5',<br/>  OrderedDict([('input_shape', [-1, 64, 16, 16]),<br/>               ('output_shape', [-1, 64, 16, 16]),<br/>               ('trainable', False),<br/>               ('nb_params', 36864)]))</em><br/> ...</span></pre><p id="58ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lr ls lt lh b">conv2d-1</code>是层的名称。</p><p id="7846" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lr ls lt lh b">‘input_shape’, [-1, <strong class="jp ir">3, 64, 64</strong>]</code> — PyTorch 在图像尺寸<code class="fe lr ls lt lh b">64, 64</code>前列出频道<code class="fe lr ls lt lh b">3</code>。按照这个顺序，一些 GPU 计算会运行得更快。这是一个 4 维的小批量。</p><p id="d9a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lr ls lt lh b">-1</code>是指无论批量有多大，都可以改变。Keras 使用<code class="fe lr ls lt lh b">None</code></p><p id="d948" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lr ls lt lh b">‘output_shape’ , [-1, <strong class="jp ir">64</strong>, <strong class="jp ir">32, 32</strong>]</code> 64 是内核数，32 乘 32 是<strong class="jp ir">步距。</strong>像 maxpooling 一样改变大小。</p><p id="9c0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">一个非常小的数据集的学习率查找器返回奇怪的数字，图为空</em>。学习率查找器将一次完成一个小批量。如果你有一个很小的数据集，就没有足够的小批量。所以诀窍是让你的批量非常小。</p><h1 id="d031" class="ms lm iq bd lv mt mu mv ly mw mx my mb mz na nb me nc nd ne mh nf ng nh mk ni bi translated">结构化和时间序列数据</h1><p id="4d5f" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">有两种类型的数据集。</p><p id="9581" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">非结构化</strong> —音频、图像、自然语言文本，其中一个对象内部的所有东西都是同一种东西——像素、波形幅度或单词。</p><p id="7eb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">结构化</strong> —损益表，关于脸书用户的信息，其中每一列在结构上不同。“结构化”指的是列数据，您可能会在数据库或电子表格中找到，其中不同的列代表不同种类的事物，每行代表一个观察值。</p><p id="7c9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结构化数据在学术界经常被忽视，因为如果你有一个更好的物流模型，它很难在花哨的会议记录中发表。但它让世界运转，让每个人都赚钱，提高效率。我们不会忽视它，因为我们正在进行实用的深度学习，Kaggle 也不会，因为人们把奖金放在 Kaggle 上，以解决现实世界的问题。</p><p id="e077" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">探索这种架构背后的动机是它与现实世界应用的相关性。工业中用于日常决策的大多数数据是结构化或时间序列数据。我们将通过实际的结构化数据问题来探索使用神经网络的端到端过程。</p><p id="35a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">示例:</p><p id="5715" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">预测大型杂货连锁店的销售额。<a class="ae kl" href="https://www.kaggle.com/c/favorita-grocery-sales-forecasting" rel="noopener ugc nofollow" target="_blank">此处</a></p><p id="4617" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用商店、促销和竞争对手数据预测销售。<a class="ae kl" href="https://www.kaggle.com/c/rossmann-store-sales" rel="noopener ugc nofollow" target="_blank">此处</a></p><h2 id="087d" class="ll lm iq bd lv lw lx dn ly lz ma dp mb jy mc md me kc mf mg mh kg mi mj mk ml bi translated">罗斯曼商店销售</h2><p id="cd9f" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">进口:</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="9dae" class="ll lm iq lh b gy ln lo l lp lq"><strong class="lh ir">from</strong> <strong class="lh ir">fastai.structured</strong> <strong class="lh ir">import</strong> *<br/><strong class="lh ir">from</strong> <strong class="lh ir">fastai.column_data</strong> <strong class="lh ir">import</strong> *<br/>np.set_printoptions(threshold=50, edgeitems=20)<br/><br/>PATH='data/rossmann/'</span></pre><p id="1c71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lr ls lt lh b">structured</code> —不特定于 PyTorch，也用于机器学习课程中，在完全没有 PyTorch 的情况下进行随机森林。它可以在没有 Fast.ai 库的任何其他部分的情况下单独使用。</p><p id="ece5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lr ls lt lh b">fastai.column_data</code> —允许我们用柱状结构化数据做 Fast.ai 和 PyTorch 之类的东西。</p><p id="bff2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于结构化数据，我们需要大量使用熊猫。不熟悉熊猫，这里的<a class="ae kl" href="http://shop.oreilly.com/product/0636920050896.do" rel="noopener ugc nofollow" target="_blank"/>(用于数据分析的 Python)是熊猫作者写的一本好书。</p><h1 id="efa0" class="ms lm iq bd lv mt mu mv ly mw mx my mb mz na nb me nc nd ne mh nf ng nh mk ni bi translated">创建数据集</h1><p id="ef58" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">除了提供的数据，我们还将使用 Kaggle 竞赛参与者收集的外部数据集，例如 google trends 和 weather。你可以在这里下载所有的<a class="ae kl" href="http://files.fast.ai/part2/lesson14/rossmann.tgz" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="96e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有大量的数据预处理，这个笔记本包含了第三名获胜者的整个管道(<a class="ae kl" href="https://arxiv.org/abs/1604.06737" rel="noopener ugc nofollow" target="_blank">分类变量的实体嵌入</a>)。本课程不涉及数据处理，但机器学习课程会详细介绍，因为特征工程非常重要。</p><p id="dc0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看 CSV 文件:</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi om"><img src="../Images/02b5dd06118df3d875bf6a57f1dfd744.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j7jDqGTkQtrNXM6B6nchdw.png"/></div></div></figure><p id="793b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lr ls lt lh b">StoreType</code> —你经常会得到一些列包含“代码”的数据集。代码是什么意思并不重要。远离了解太多，先看看数据怎么说。然后稍后查看经常随数据一起提供的数据字典。</p><h2 id="5db1" class="ll lm iq bd lv lw lx dn ly lz ma dp mb jy mc md me kc mf mg mh kg mi mj mk ml bi translated">连接表格</h2><p id="3744" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">这是一个关系数据集，您已经将相当多的表连接在一起——这对于使用<code class="fe lr ls lt lh b">merge</code>的 Pandas 来说很容易做到:</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi on"><img src="../Images/7351e3a8c2e706a81dec7eeaa86b3b04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kcw29oQh9WKWPC7qUcNMFA.png"/></div></div></figure><p id="8fa2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">fast.ai 还提供以下功能:</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="ff6c" class="ll lm iq lh b gy ln lo l lp lq">add_datepart(train, "Date", drop=False)</span></pre><p id="edb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">获取一个日期，提取一系列列，如“星期几”、“季度初”、“一年中的月份”等，并将它们全部添加到数据集中。</p><p id="2582" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">持续时间部分将计算距离下一个假期还有多长时间，距离上一个假期还有多长时间，等等。</p><p id="ce5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">保存包含数据的整个结构化文件:</p><pre class="kv kw kx ky gt lg lh li lj aw lk bi"><span id="0f6b" class="ll lm iq lh b gy ln lo l lp lq">joined.to_feather(f'{PATH}joined')</span></pre><p id="363e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lr ls lt lh b">to_feather</code>:将一个熊猫的数据帧保存为“羽毛”格式，这种格式将它保存在 RAM 中，并将其转储到磁盘中。所以它真的真的很快。厄瓜多尔杂货比赛有 3.5 亿条记录，所以你会关心用羽毛节省多长时间，它需要 6 秒。</p><p id="2ba7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该数据包含特定日期商店中特定商品的销售数量。我们的目标是预测在未来的某一天，在某个特定的商店里会卖出多少这样的商品。</p><h2 id="79ef" class="ll lm iq bd lv lw lx dn ly lz ma dp mb jy mc md me kc mf mg mh kg mi mj mk ml bi translated">下一课</h2><p id="3c31" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">我们将列分为两种类型:分类的和连续的。</p><p id="975d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">分类变量</strong>:是<code class="fe lr ls lt lh b">store_id</code> 1 和<code class="fe lr ls lt lh b">store_id</code> 2 在数值上没有关系。它们是类别。一周中的每一天；周一(第 0 天)和周二(第 1 天)的电子贸易条件分类数据将被热编码，并且</p><p id="e9da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">连续变量:</strong>像到最近的竞争对手的公里距离这样的东西是我们用数字处理的数字。连续数据将按原样馈入全连接层。</p><p id="3b76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">步骤:</p><ol class=""><li id="3686" class="oo op iq jp b jq jr ju jv jy oq kc or kg os kk ot ou ov ow bi translated">创建验证集。</li><li id="39fd" class="oo op iq jp b jq ox ju oy jy oz kc pa kg pb kk ot ou ov ow bi translated"><code class="fe lr ls lt lh b">ColumnarModelData.from_data_frame</code>是我们加载列数据的方式。基本的 API 概念与图像识别相同。</li><li id="ca9c" class="oo op iq jp b jq ox ju oy jy oz kc pa kg pb kk ot ou ov ow bi translated"><code class="fe lr ls lt lh b">.get_learner</code></li><li id="3e83" class="oo op iq jp b jq ox ju oy jy oz kc pa kg pb kk ot ou ov ow bi translated">找出我们的最佳学习率并画出来。</li><li id="c32e" class="oo op iq jp b jq ox ju oy jy oz kc pa kg pb kk ot ou ov ow bi translated"><code class="fe lr ls lt lh b">.fit</code>带着一个<code class="fe lr ls lt lh b">metric</code></li><li id="6280" class="oo op iq jp b jq ox ju oy jy oz kc pa kg pb kk ot ou ov ow bi translated"><code class="fe lr ls lt lh b">.fit </code>同一个<code class="fe lr ls lt lh b">cycle_len</code></li></ol><p id="c6d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读！<em class="km">跟随</em><a class="ae kl" href="https://twitter.com/itsmuriuki" rel="noopener ugc nofollow" target="_blank"><em class="km">@ itsmuriuki</em></a><em class="km">。</em></p><p id="e234" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回归学习！</p></div></div>    
</body>
</html>