# 效率与清晰度

> 原文：<https://towardsdatascience.com/efficiency-vs-clarity-28241d6ece7f?source=collection_archive---------4----------------------->

作为一名数据科学家，编写代码时要考虑的一个问题是如何最好地平衡效率和清晰度。(在这里，效率=代码执行的速度，清晰性=同样的代码组织得有多好，有多容易理解。)在这种情况下，量化效率比量化清晰更容易，但是查看两组代码并确定哪一组更有组织性是很简单的。(嗯，这在理论上是真的，这意味着在现实中可能一点也不真实。)

![](img/242013467647158e1732bf65691b1ad6.png)

Giphy >> computer >> download funniest GIF near top of page

一方面，代码的目标几乎总是解决一些问题——那么为什么不尽可能地高效呢？如果我们能更快地解决一个问题，那就比解决得更慢更好…对吗？

> 小故事:几年前，我的男朋友飞往加州，试图阅读安伯托·艾柯的《福柯的钟摆》。通过机场时，美国运输安全管理局把他的书签抖了出来。他后来找到了自己的位置，读了 20 分钟，意识到自己已经读完了那一部分。(这本书显然难以置信的密集。)这种情况发生了两三次，直到他最终放弃完成这本书。

![](img/9a8bddad960271e8a1538dfcca8a6b5e.png)

Me, in grad school.

这是积极的数据科学家/程序员/开发人员/任何做过项目的人的困境。你已经上床睡觉了——没有星巴克、Soylent 或你选择的燃料——第二天早上醒来时，你不知道你在代码中的什么位置，也不知道一部分如何与其他部分相适应。也许你正在与他人合作编写代码，因此愿意为了清晰而牺牲一些效率。作为数据科学爱好者，我们认识到一些实际的限制可能会干扰最巧妙和最快的解决方案。当然，我们可以(也应该！)在我们的代码中包含注释，但这并不意味着我们不能力求清晰…只要这种清晰不影响我们的效率！

![](img/c987ee627cafbbaa0044862839af7932.png)

“Fizzbuzz”问题，经常在技术面试中使用(包括我自己的一个！)，这是一个很好的例子，说明用不同的方法处理不同优先级的问题可以得到相同的解决方案。

TL；博士——“T2”问题需要有人描述一种算法，对于 1 到 100 之间的每个整数:

*   如果这个数能被 3 整除，打印“Fizz”
*   如果数字能被 5 整除，打印“Buzz”
*   如果数字能被 15 整除，打印“FizzBuzz”，或者
*   如果数字不能被 3、5 或 15 整除，则打印数字本身。

期望的输出将类似于:

```
1, 2, “Fizz,” 4, “Buzz,” “Fizz,” 7, 8, "Fizz," ...
```

即使你以前没有见过这个问题，你们中的超逻辑者可能已经有了一个你将如何着手解决它的心理草图。创建一个取值为 1，2，…，99，100 的变量。对于每个值，检查它与 3、5 和 15 的整除性。认识到 3、5 和 15 会有一些重叠，我们要小心。在这一点上，我们可能最好把笔放在纸上(或手指放在键盘上)并尝试一下。

![](img/15fbae78aa2e87c76e820ee29599f81d.png)

Click.

在我的 Python 访谈中，我在黑板上写下了以下内容:

```
for i in range(1,101):
    if i % 3 == 0:
        if i % 5 == 0:
            print 'Fizzbuzz'
        else:
            print 'Fizz'
    elif i % 5 == 0:
        print 'Buzz'
    else:
        print i
```

那时，一位面试官问我为什么要这样安排。这在我的思考中是最有意义的——我知道被 3 和 5 整除的数字会更棘手，所以我想在一开始就考虑被 15 整除的可能性。然而，退后一步，让写在白板上的面试神经稍微平静下来，它*确实*看起来很笨拙。我提到，这样可能会更有效率，因为我们运行的操作更少，但考虑到这些紧张因素，我不想强调这一点，以免我忽略了一些愚蠢的事情。

在面试官的要求下，我又做了一遍:

```
for i in range(1,101):
    if i % 3 == 0 & i % 5 == 0:
        print ‘Fizzbuzz’
    elif i % 3 == 0:
        print ‘Fizz’
    elif i % 5 == 0:
        print ‘Buzz’
    else:
        print i
```

这似乎更优雅。显然更清楚了。如果我试图教某人编码，或者如果我和一群都接触相同代码的人一起工作，这似乎是一个更好的解决方案。

![](img/56f6aa18063860930febfad428cac41b.png)

Yup. Nerding out 24/7.

直到我回到家，我一直在回想哪个代码块会更有效率。当我回到家，我坐下来展示了运行我最初写的算法确实会更有效率。*(对数字 1 到 1，000，000 运行这个程序，我的第一个代码将运行 33.39 秒，而第二个代码将运行 34.80 秒。这是因为第一个代码片段对于所有不能被 3 和 5 整除的数字只需要少一次运算。)*

不幸的是，就像数据科学中的许多事情一样，效率和清晰之间几乎没有硬性的规则。说“如果许多人在同一代码上工作，你应该关注清晰性”或“如果你在‘大数据’上使用代码，那么效率可能更重要”是相当琐碎的。但是我对你的最佳实践感兴趣！

> 对编码人员来说，什么时候更重要？
> 
> 对于非编码人员，格兰芬多即使读到这里也要加 100 分，但是你对日常环境中“效率与清晰”的概念有什么想法？