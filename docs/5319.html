<html>
<head>
<title>Python vs. Scala: a comparison of the basic commands (Part I)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 与 Scala:基本命令的比较(第一部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-vs-scala-a-comparison-of-the-basic-commands-fae23b3ede23?source=collection_archive---------3-----------------------#2018-10-11">https://towardsdatascience.com/python-vs-scala-a-comparison-of-the-basic-commands-fae23b3ede23?source=collection_archive---------3-----------------------#2018-10-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/88d83568f581f6fc7a6c20de84935d5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MQCagguIxVmU3ucb"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">“MacBook Pro on brown wooden table” by <a class="ae kc" href="https://unsplash.com/@maxcodes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Max Nelson</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="21ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我最近开始玩一点 Scala，我不得不说这是一种创伤。我<strong class="kf ir">喜欢</strong>学习新事物，但在用 Python 编程数月后，在解决数据科学问题时将它放在一边并切换模式是不自然的。在学习一门新语言的时候，不管是编码还是口语，出现这种情况是很正常的。我们倾向于用我们知道的东西来填补我们不知道的东西的空白，即使它们不属于我们试图写/说的语言！当试图学习一门新语言时，完全被你想学的语言所包围是很重要的，但首先，在已知语言和新语言之间建立良好的平行关系是很重要的，至少在开始时是如此。这对我很有用，我是一个双语的人，在成年后很快就学会了第二语言。一开始，我需要意大利语(我所知道的语言)和英语(我正在学习的语言)之间的联系，但是随着我的英语越来越流利，我开始忘记平行关系，因为这变得很自然，我不再需要先在脑子里翻译它了。事实上，我决定写这篇文章的原因是为了在 Python 和 Scala 之间建立并行性，对于像我一样精通其中一种，并开始学习另一种的人来说。</p><p id="7f63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我最初是想把重点放在熊猫/Sklearn 和 Spark 上，但我意识到，不先把基础打好，意义不大。这就是为什么在这篇文章中，我们将看看 Python 和 Scala 的基础知识:如何处理字符串、列表、字典等等。我打算在不久的将来发表第二部分，其中我将介绍如何用两种语言处理数据帧和构建预测模型。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="2dd8" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">1.重要的事情先来</h1><p id="d732" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">第一个区别是当编码是这两种语言时使用的约定:如果你不遵循它，这不会抛出一个错误或任何类似的东西，但它只是一个编码者遵循的非书面规则。</p><p id="627f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当定义一个新的变量、函数或其他东西时，我们总是选择一个对我们有意义的名字，这个名字很可能由两个或更多的单词组成。如果是这种情况，在 Python 中我们将使用<code class="fe ml mm mn mo b">snake_case</code>，而在 Scala 中<code class="fe ml mm mn mo b">camelCase</code>:差别是显而易见的。在蛇的情况下，所有的单词都是小写的，我们使用<code class="fe ml mm mn mo b">_</code>来分隔它们，在骆驼的情况下没有分隔，除了第一个单词，所有的单词都是大写的。</p><p id="d089" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个显著的区别是我们如何定义两种语言中的变量。在 Python 中，我们只需创建一个名称，并将其赋给我们需要的值，而在 Scala 中，我们需要指定我们是在定义一个变量还是一个值，我们通过在名称前分别放置<code class="fe ml mm mn mo b">var</code>或<code class="fe ml mm mn mo b">val</code>来做到这一点(注意，无论我们是在赋数值还是字符串，这都是有效的)。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/9f9326fe4e2febad161e939e9a109ac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sbm5O0hKW2_qpHhcG62A2w.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Initializing values and variables in Scala.</figcaption></figure><p id="a1bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ml mm mn mo b">var</code>和<code class="fe ml mm mn mo b">val</code>的区别很简单:变量可以修改，而值不能。在图中所示的例子中，我实例化了一个<code class="fe ml mm mn mo b">var</code>字符串，然后将其更改为:all good。然后，我将同一个字符串赋给了一个<code class="fe ml mm mn mo b">val</code>，并试图再次改变它:不可行。</p><p id="969e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 Python 中，不需要指定:如果你想改变你之前分配的东西，这取决于你。在 Python 的情况下，我只需要做<code class="fe ml mm mn mo b">string = 'my_string'</code>。</p><p id="1c00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个普遍的区别是关于注释。在 Python 中，只有一种方法可以做到这一点，不管是单行还是多行，那就是在每一行的注释前加一个<code class="fe ml mm mn mo b">#</code>:</p><p id="6e75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ml mm mn mo b"># this is a commented line in Python</code></p><p id="d980" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Scala 提供了两种注释方式，要么将<code class="fe ml mm mn mo b">//</code>放在每一行，要么将注释放在<code class="fe ml mm mn mo b">/*</code>和<code class="fe ml mm mn mo b">*/</code>之间:</p><pre class="mq mr ms mt gt mu mo mv mw aw mx bi"><span id="4874" class="my lj iq mo b gy mz na l nb nc">// this is a commented line in Scala<br/>/* and this is a multiline comment, still in Scala...<br/>...just choose! */</span></pre><p id="2f5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，非常基础的解释，让我们看看潜水更深。</p><h1 id="643d" class="li lj iq bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">2.列表和数组</h1><p id="e613" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">list(Python 中的)或 Array(Scala 中的)是最重要的对象:它们可以包含字符串和/或数字，我们可以操作它们，遍历它们，添加或减去元素等等。它们基本上可以服务于任何目的，我不认为我曾经不使用它们编码过任何东西，所以让我们看看我们可以用它们做什么，以及如何做。</p><h2 id="29dd" class="my lj iq bd lk ni nj dn lo nk nl dp ls ko nm nn lw ks no np ma kw nq nr me ns bi translated">2.1.规定</h2><p id="1ce8" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">让我们创建一个包含数字和字符串混合的列表。</p><p id="c12b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ml mm mn mo b">my_list = [2, 5, 'apple', 78] <strong class="kf ir"># Python</strong></code></p><pre class="mq mr ms mt gt mu mo mv mw aw mx bi"><span id="4897" class="my lj iq mo b gy mz na l nb nc">var myArray = Array(2, 5, "apple", 78) <strong class="mo ir">// Scala</strong><br/><strong class="mo ir">/* notice that in Scala I wrapped the string between "", and that is the only way to do it! In python you can use both "" and '' indifferently */</strong></span></pre><h2 id="2942" class="my lj iq bd lk ni nj dn lo nk nl dp ls ko nm nn lw ks no np ma kw nq nr me ns bi translated">2.2.索引</h2><p id="05d5" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">列表和数组都是零索引的，这意味着第一个元素放在索引 0 处。所以，如果我们想提取第二个元素:</p><p id="a660" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ml mm mn mo b">my_list[1] <strong class="kf ir"># Python </strong>uses [] to index</code></p><p id="3b8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ml mm mn mo b">myArray(1) <strong class="kf ir">// Scala</strong> uses () to index</code></p><h2 id="20c6" class="my lj iq bd lk ni nj dn lo nk nl dp ls ko nm nn lw ks no np ma kw nq nr me ns bi translated">2.3.限幅</h2><p id="0168" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在这两种语言中，切片时不会计算第二个索引。所以，如果我们想提取前三个元素:</p><p id="2dcb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ml mm mn mo b">my_list[0:3] <strong class="kf ir"># Python </strong>slicing works like indexing</code></p><p id="f007" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ml mm mn mo b">myArray.slice(0,3) <strong class="kf ir">// Scala </strong>needs the .slice()</code></p><h2 id="5894" class="my lj iq bd lk ni nj dn lo nk nl dp ls ko nm nn lw ks no np ma kw nq nr me ns bi translated">2.4.检查第一个、最后一个、最大和最小元素</h2><pre class="mq mr ms mt gt mu mo mv mw aw mx bi"><span id="9bf2" class="my lj iq mo b gy mz na l nb nc"><strong class="mo ir"># Python</strong></span><span id="74ff" class="my lj iq mo b gy nt na l nb nc">my_list[0]     # first element<br/>my_list[-1]    # last element<br/>max(my_list)   # maximum element<br/>min(my_list)   # minimum element</span><span id="201a" class="my lj iq mo b gy nt na l nb nc"># NOTE: min() and max() will work exclusively if the list contains <br/># numbers only!</span><span id="1670" class="my lj iq mo b gy nt na l nb nc"><strong class="mo ir">// Scala</strong></span><span id="a20e" class="my lj iq mo b gy nt na l nb nc">myArray.head    // first element<br/>myArray(0)      // other way to check the first element<br/>myArray.last    // last element<br/>myArray.max     // maximum element<br/>myArray.min     // minimum element</span><span id="7f25" class="my lj iq mo b gy nt na l nb nc">/* NOTE: .min and .max will work exclusively if the array contains numbers only!*/</span></pre><h2 id="3b80" class="my lj iq bd lk ni nj dn lo nk nl dp ls ko nm nn lw ks no np ma kw nq nr me ns bi translated">2.5.总和与乘积</h2><p id="6ad5" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">对于 min 和 max，只有当列表/数组只包含数字时，才支持这些操作。此外，为了将 Python 列表中的所有元素相乘，我们需要建立一个<code class="fe ml mm mn mo b">for</code>循环，这将在本文中进一步讨论。与 Scala 不同，它没有预加载的功能。</p><p id="70c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ml mm mn mo b">sum(my_list) # summing elements in <strong class="kf ir">Python</strong>'s list</code></p><pre class="mq mr ms mt gt mu mo mv mw aw mx bi"><span id="333f" class="my lj iq mo b gy mz na l nb nc">// <strong class="mo ir">Scala</strong><br/>myArray.sum   // summing elements in array<br/>myArray.product  // multiplying elements in array</span></pre><h2 id="e9ba" class="my lj iq bd lk ni nj dn lo nk nl dp ls ko nm nn lw ks no np ma kw nq nr me ns bi translated">2.6.添加元素</h2><p id="fb61" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">列表和数组是没有顺序的，所以通常的做法是在末尾添加元素。假设我们想要添加字符串<code class="fe ml mm mn mo b">"last words"</code>:</p><p id="7b6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ml mm mn mo b">my_list.append('last words') # adding at the end of <strong class="kf ir">Python</strong>'s list</code></p><p id="a727" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ml mm mn mo b">myArray :+= "last words" // adding at the end of <strong class="kf ir">Scala</strong>'s array</code></p><p id="ea8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果出于某种原因，我们想在最开始添加一些东西，就说数字<code class="fe ml mm mn mo b">99</code>:</p><pre class="mq mr ms mt gt mu mo mv mw aw mx bi"><span id="f38b" class="my lj iq mo b gy mz na l nb nc">my_list.insert(0, 99) # this is a generic method in <strong class="mo ir">Python</strong>. The <br/># first number you specify in the parenthesis is the index of the <br/># position where you want to add the element.<br/># 0 means that you want the element to be added at the very <br/># beginning</span><span id="1a51" class="my lj iq mo b gy nt na l nb nc">myArray +:= 99 /* adding an element at the beginning of <strong class="mo ir">Scala</strong>'s array */</span></pre><h1 id="1e5f" class="li lj iq bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">3.打印</h1><p id="7c30" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">这也是我们在编码时一直使用的东西，幸运的是这两种语言之间只有一点点差别。</p><p id="bce2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ml mm mn mo b">print("whatever you want") # printing in <strong class="kf ir">Python</strong></code></p><p id="97d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ml mm mn mo b">println("whatever you want") // printing in <strong class="kf ir">Scala</strong></code></p><h1 id="f04c" class="li lj iq bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">4.For 循环</h1><p id="cbaa" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">这里有一些不同:Python 需要缩进来创建语句后的块和冒号，而 Scala 需要括号中的 for 条件，以及不需要缩进的花括号中的块。尽管如此，我还是喜欢使用缩进，它让代码看起来更整洁。</p><pre class="mq mr ms mt gt mu mo mv mw aw mx bi"><span id="d2db" class="my lj iq mo b gy mz na l nb nc"># for loop in <strong class="mo ir">Python</strong><br/>for i in my_list:<br/>    print(i)</span><span id="e640" class="my lj iq mo b gy nt na l nb nc">// for loop in <strong class="mo ir">Scala</strong><br/>for (i &lt;- myArray){<br/>    println(i)<br/>}</span></pre><h1 id="d20e" class="li lj iq bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">5.映射和/或过滤</h1><p id="4ee3" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在 Python 中，所有的事情都可以通过使用列表理解来完成。在 Scala 中，我们将不得不使用函数。</p><h2 id="e77e" class="my lj iq bd lk ni nj dn lo nk nl dp ls ko nm nn lw ks no np ma kw nq nr me ns bi translated">5.1.绘图</h2><p id="bc7f" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">假设我们有一个只有数值的列表/数组，我们想把它们都增加三倍。</p><p id="f117" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ml mm mn mo b">[i*3 for i in my_list] # mapping in <strong class="kf ir">Python</strong></code></p><p id="72aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ml mm mn mo b">myArray.map(i =&gt; i*3) // mapping in <strong class="kf ir">Scala</strong></code></p><h2 id="e8be" class="my lj iq bd lk ni nj dn lo nk nl dp ls ko nm nn lw ks no np ma kw nq nr me ns bi translated">5.2.过滤</h2><p id="1666" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">假设我们有一个只有数值的列表/数组，我们想只过滤那些能被 3 整除的数值。</p><p id="59bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ml mm mn mo b">[i for i in my_list if i%3 == 0] # filtering in <strong class="kf ir">Python</strong></code></p><p id="f8de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ml mm mn mo b">myArray.filter(i =&gt; i%3 == 0) // filtering in <strong class="kf ir">Scala</strong></code></p><h2 id="2f94" class="my lj iq bd lk ni nj dn lo nk nl dp ls ko nm nn lw ks no np ma kw nq nr me ns bi translated">5.3.过滤和映射</h2><p id="9b3e" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">如果我们想找到偶数并且只将它们乘以 3 呢？</p><p id="b50a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ml mm mn mo b">[i*3 for i in my_list if i%2 == 0] # <strong class="kf ir">Python</strong></code></p><p id="a5b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ml mm mn mo b">myArray.filter(i =&gt; i%2 == 0).map(i =&gt; i*3) // <strong class="kf ir">Scala</strong></code></p><h1 id="490f" class="li lj iq bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">6.字典/地图</h1><p id="0170" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">虽然它们在两种语言中的名称不同，但它们完全是一回事。它们都有<code class="fe ml mm mn mo b">keys</code>，我们给它们赋值<code class="fe ml mm mn mo b">values</code>。</p><h2 id="996e" class="my lj iq bd lk ni nj dn lo nk nl dp ls ko nm nn lw ks no np ma kw nq nr me ns bi translated">6.1.创建字典/地图</h2><p id="6048" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">让我们创建一个存储我的名、姓和年龄的数据库，并假设我 18 岁。</p><pre class="mq mr ms mt gt mu mo mv mw aw mx bi"><span id="ddfe" class="my lj iq mo b gy mz na l nb nc"># <strong class="mo ir">Python</strong><br/>my_dict = {<br/>'first_name': 'Emma',<br/>'last_name': 'Grimaldi',<br/>'age': 18<br/>}</span></pre><p id="f946" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 Scala 中，我们可以用两种不同的方式做到这一点。</p><pre class="mq mr ms mt gt mu mo mv mw aw mx bi"><span id="d721" class="my lj iq mo b gy mz na l nb nc">// <strong class="mo ir">Scala</strong> mode 1<br/>var myMap = (<br/>"firstName" -&gt; "Emma",<br/>"lastName" -&gt; "Grimaldi",<br/>"age" -&gt; 18<br/>)</span><span id="9e7e" class="my lj iq mo b gy nt na l nb nc">// Scala mode 2<br/>var myMap = (<br/>("firstName", "Emma"),<br/>("lastName", "Grimaldi"),<br/>("age", 18)<br/>)</span></pre><h2 id="f7a7" class="my lj iq bd lk ni nj dn lo nk nl dp ls ko nm nn lw ks no np ma kw nq nr me ns bi translated">6.2.添加到字典/地图</h2><p id="c146" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">让我们把我的原籍国加入我的字典/地图。</p><p id="055a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ml mm mn mo b">my_dict['country_of_origin'] = 'Italy' # creating new key in <strong class="kf ir">Python</strong></code></p><p id="db2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ml mm mn mo b">myMap += ("countryOfOrigin" -&gt; "Italy") /* creating new key in <strong class="kf ir">Scala</strong> */</code></p><h2 id="fdec" class="my lj iq bd lk ni nj dn lo nk nl dp ls ko nm nn lw ks no np ma kw nq nr me ns bi translated">6.3.索引</h2><p id="e7a7" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">这与索引列表/数组的工作方式相同，但是我们使用的是键，而不是位置。如果我想看我的名字:</p><pre class="mq mr ms mt gt mu mo mv mw aw mx bi"><span id="e7c5" class="my lj iq mo b gy mz na l nb nc"># <strong class="mo ir">Python</strong><br/>my_dict['first_name']</span><span id="afad" class="my lj iq mo b gy nt na l nb nc">// <strong class="mo ir">Scala</strong><br/>myMap("firstName")</span></pre><h2 id="7a0c" class="my lj iq bd lk ni nj dn lo nk nl dp ls ko nm nn lw ks no np ma kw nq nr me ns bi translated">6.4.环</h2><p id="0c36" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">如果我们想打印字典/映射，在这两种情况下，我们都必须通过键和值进行 for 循环。</p><pre class="mq mr ms mt gt mu mo mv mw aw mx bi"><span id="2a4a" class="my lj iq mo b gy mz na l nb nc"># Python<br/>for key, value in my_dict.items():<br/>    print(key)<br/>    print(value)</span><span id="e176" class="my lj iq mo b gy nt na l nb nc">// Scala<br/>for ((key, value) &lt;- myMap){<br/>    println(key)<br/>    println(value)<br/>}</span></pre><h1 id="8eed" class="li lj iq bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">7.元组</h1><p id="685d" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">是的，它们在两种语言中的叫法是一样的！但是，虽然它们在 Python 中是零索引，但在 Scala 中却不是。让我们创建一个元组<code class="fe ml mm mn mo b">(1, 2, 3)</code>，然后调用第一个值。</p><pre class="mq mr ms mt gt mu mo mv mw aw mx bi"><span id="e633" class="my lj iq mo b gy mz na l nb nc"># Python<br/>my_tup = (1, 2, 3)<br/>my_tup[0]<br/># the indexing is the same as lists</span><span id="643f" class="my lj iq mo b gy nt na l nb nc">// Scala<br/>myTup = (1, 2, 3)<br/>myTup._1<br/>// the indexing is way different than arrays!</span></pre><h1 id="e9e8" class="li lj iq bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">8.设置</h1><p id="444b" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">是的，另一个共同的名字！在下面的两个例子中，集合将只包含<code class="fe ml mm mn mo b">1, 3, 5</code>，因为集合不接受副本。</p><p id="8683" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ml mm mn mo b">my_set = {1, 3, 5, 1} # in <strong class="kf ir">Python</strong>, sets are defined by curly braces</code></p><p id="fe4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ml mm mn mo b">mySet = Set(1, 3, 5, 1) // <strong class="kf ir">Scala</strong></code></p><h1 id="29c8" class="li lj iq bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">9.功能</h1><p id="6ad0" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">到目前为止，我们已经做了很多，如果你成功了，做得很好！这是这篇文章的最后一段，幸运的是在 Python 和 Scala 之间定义函数并没有太大的不同。它们都以<code class="fe ml mm mn mo b">def</code>开头，而前者需要一个<code class="fe ml mm mn mo b">return</code>语句，后者不需要。另一方面，Scala 想知道我们将要输入和输出什么类型的变量，而 Python 并不关心。让我们编写一个非常简单的函数，它接受一个字符串作为输入，并返回前 5 个字符。</p><pre class="mq mr ms mt gt mu mo mv mw aw mx bi"><span id="a292" class="my lj iq mo b gy mz na l nb nc"># <strong class="mo ir">Python</strong><br/>def chop_string(input_string):<br/>    return input_string[0:5]</span></pre><p id="744e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">缩进在 Python 中也很重要，否则函数将不起作用。Scala 只是喜欢它的花括号。</p><pre class="mq mr ms mt gt mu mo mv mw aw mx bi"><span id="fc19" class="my lj iq mo b gy mz na l nb nc">// <strong class="mo ir">Scala</strong><br/>def chopString(inputString: String): String = {<br/>    inputString.slice(0, 5)<br/>}</span></pre></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="96bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！我希望这对那些刚刚开始熟悉 Python 或 Scala 的人有所帮助。下一步将构建类似的指南，探索熊猫/sklearn 和 sparks 的不同之处，期待！我希望你也一样！</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="6dd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想知道为什么应该使用 Python 而不是 Scala，或者反之亦然，我发现下面的图片非常有助于澄清两者之间的直接差异。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/1a2db3d91af5867c9e63aa31a934fe04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*ViBVUplkI1_XZtQghucv6A.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://www.kdnuggets.com/2018/05/apache-spark-python-scala.html" rel="noopener ugc nofollow" target="_blank">source link</a></figcaption></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/e617ba7ebe3f3cc33ed5ad510738322e.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*-3XTARCS1twqTj73tB78wg.png"/></div></figure><p id="c737" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请随意查看:</p><p id="d84c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://medium.com/@emmagrimaldi/python-pandas-vs-scala-how-to-handle-dataframes-part-ii-d3e5efe8287d" rel="noopener">本帖第二部分</a></p><p id="b6ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的其他媒体帖子。</p><p id="e83a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://www.linkedin.com/in/emmagrimaldi/" rel="noopener ugc nofollow" target="_blank">我的 LinkedIn 个人资料。</a></p><p id="4fe9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">感谢您的阅读！</strong></p></div></div>    
</body>
</html>