<html>
<head>
<title>Behavioural Cloning Applied to Self-Driving Car on a Simulated Track</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">行为克隆在自动驾驶汽车模拟赛道上的应用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/behavioural-cloning-applied-to-self-driving-car-on-a-simulated-track-5365e1082230?source=collection_archive---------1-----------------------#2017-01-27">https://towardsdatascience.com/behavioural-cloning-applied-to-self-driving-car-on-a-simulated-track-5365e1082230?source=collection_archive---------1-----------------------#2017-01-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4851" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近我在<a class="ae kl" href="https://www.udacity.com/" rel="noopener ugc nofollow" target="_blank"> Udacity </a>上了一门课程，重点是<a class="ae kl" href="https://www.udacity.com/drive" rel="noopener ugc nofollow" target="_blank">无人驾驶汽车</a>，所以我终于能够在课程中发布其中一个项目了。</p><p id="5fbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个项目，标题如上，有一个目标是<em class="km">训练一个模型在模拟轨道上自动驾驶汽车。该模型驾驶汽车的能力是通过克隆人类驾驶员的行为来学习的。训练数据从模拟器中的人类驾驶示例中获得，然后输入到深度学习网络中，该网络学习模拟中遇到的每一帧的响应(转向角度)。换句话说，该模型被训练为在驾驶时为每一帧预测适当的转向角度。然后，在新的轨迹上验证该模型，以检查用于执行转向角预测的学习特征的一般化。</em></p><p id="b035" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我对这个项目的解决方案受到了nvidia论文、<a class="ae kl" href="https://arxiv.org/pdf/1608.01230v1.pdf" rel="noopener ugc nofollow" target="_blank"> comma.ai论文</a>和<a class="ae kl" href="https://chatbotslife.com/using-augmentation-to-mimic-human-driving-496b569760a9#.5dpi87xzi" rel="noopener ugc nofollow" target="_blank"> vivek博客</a>的影响，我在制定解决方案时参考了这些论文。<a class="ae kl" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank"> Keras深度学习库</a>与<a class="ae kl" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> Tensorflow </a>后端一起使用，执行深度学习操作。</p><p id="262a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章组织如下:1。数据记录，2。数据处理，3。模特培训，4。模型测试；5 .结论。</p><p id="6acc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 1。数据记录</strong></p><p id="cc77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模拟器有两种模式——训练模式和自主模式。训练模式用于收集训练数据，方法是在赛道上行驶，并将行驶数据记录在文件夹中。自主模式用于测试经过训练的模型。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kn"><img src="../Images/0ab73c9615aa083874325450ec3ffe6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*e5bSv8oI5ca7sVzumPRguA.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Self-Driving Car Simulator</figcaption></figure><p id="a86a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Udacity提供了一组训练数据(24，108个数据集)，可以通过模拟器下载。我认为Udacity数据集可能不够，所以我记录了自己的训练数据(104，145个数据集)，并将使用Udacity数据集进行验证。绘制10，000个训练数据样本的直方图显示，由于轨道的性质，来自轨道1的数据具有更多的0°和左转向角，因此我们的处理步骤还将包括数据扩充和平衡，以防止我们的模型偏向于直行和左转。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/5b190d5d7e6ff772710cdb03850e3d54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*JUgZCAc-0gEthkJgHU53SA.jpeg"/></div></figure><h1 id="28bb" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">2.数据处理</h1><p id="c354" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">进行数据处理是为了让我们的模型能够轻松地处理用于训练的原始数据。在这个项目中，数据处理内置在一个生成器(keras <em class="km"> fit_generator </em>)中，以允许实时处理数据。这样做的好处是，在我们处理大量数据的情况下，整个数据集不会加载到内存中，因此我们可以一次处理一批可管理的数据。因此，为了提高效率，发电机与模型并行运行。</p><p id="cf77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是对数据执行的处理步骤:</p><ol class=""><li id="9b84" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated"><strong class="jp ir">从中心、左、右摄像机图像中随机选择:</strong>模拟器提供三个摄像机视图，即:中央、左侧和右侧视图。因为我们只需要使用一个摄像机视图，所以我们从三个视图中随机选择。在使用左右图像时，我们分别给转向角加上和减去0.25，以补偿相机偏移<a class="ae kl" href="https://arxiv.org/pdf/1604.07316v1.pdf" rel="noopener ugc nofollow" target="_blank"> 1 </a>。</li><li id="2c16" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated"><strong class="jp ir">平移图像(抖动)并补偿转向角:</strong>由于原始图像大小为160x320像素，我们随机将图像向左或向右平移，并以每平移像素0.008补偿转向角的平移。然后，我们从图像中裁剪出一个120x220像素的感兴趣区域。<em class="km">请注意，对于我的解决方案，我仅在水平方向平移。</em></li><li id="63ea" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated"><strong class="jp ir">随机翻转图像:</strong>为了平衡左右图像，我们随机翻转图像并改变转向角的符号。下图显示了经过抖动、裁剪和角度校正后的左、右和中央摄像机的视图。右摄像机视图已经翻转，因此看起来像左摄像机图像。</li><li id="c0a0" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated"><strong class="jp ir">增亮</strong>我们通过将图像转换为HSV通道，并随机缩放V通道来模拟不同的亮度场合。</li></ol><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/4247412d0475c1c3eef3b8cd7a91a8e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*mk0W_9Dar3FMSvq1GuqsAg.jpeg"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Camera views after processing and steering angle compensation.</figcaption></figure><p id="65a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">绘制10，000个已处理图像的样本显示了处理后转向角的更平衡的分布:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/5e3bdbb5ae40e22349dbc2b32ab8969d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*jO2pH72MrbuMVQBTMsZHNg.jpeg"/></div></figure><h1 id="bcda" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">3.模特培训</h1><p id="3743" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">采用<a class="ae kl" href="https://arxiv.org/pdf/1604.07316v1.pdf" rel="noopener ugc nofollow" target="_blank"> Nvidia模型</a>进行训练，因为它在试验了其他类型的模型(例如comma.ai)后给出了更好的结果。该网络由9层组成，包括一个归一化层、5个卷积层和3个全连接层。与Nvidia模型相反，输入图像在传送到网络之前被分割成HSV平面。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/ede85ade0a7f8d0a8ea71b16bf8efb54.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*oXymn6qB8dm1cY1A-w2z_A.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk"><a class="ae kl" href="https://arxiv.org/pdf/1604.07316v1.pdf" rel="noopener ugc nofollow" target="_blank">Nvidia model</a></figcaption></figure><p id="5fb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图像在第一层被标准化。根据Nvidia的论文，这使得标准化也可以通过GPU处理来加速。</p><p id="4f9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">卷积在前三层中使用2x2步长和5x5内核，非步长卷积在后两层中使用3x3内核。</p><p id="bda0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">卷积层之后是三个全连接层，然后输出转向角。</p><p id="396f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过在所有层上使用积极的下降(0.2)和在第一层上使用L2正则化(0.001)来减少过拟合。这被证明是一个很好的实践，因为该模型可以推广到第二个轨道，而无需将其用于培训。</p><p id="f0be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Adam优化器用于优化。由于学习速率是自适应的，这几乎不需要调整。此外，在训练过程中使用检查点和早期停止机制，通过监控验证损失来选择最佳训练模型，如果损失在连续三个时期内没有减少，则停止训练。</p><p id="8c6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然有超过100，000个训练数据，但是每个时期包括24，064个样本。这使得训练更容易处理，并且由于我们使用了生成器，所有的训练数据仍然在训练中使用，但是在不同的时期。</p><p id="9beb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再次重申，自我记录的数据用于训练，而Udacity提供的数据用于训练期间的验证。</p><h1 id="602e" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">4.模型检验</h1><p id="46b7" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">经过训练的模型在第一条跑道上进行了测试。这给出了一个很好的结果，因为赛车可以在赛道上平稳行驶。<a class="ae kl" href="https://youtu.be/PAouMCtEhWY" rel="noopener ugc nofollow" target="_blank">参见下面的路线1测试结果视频</a></p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6b6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，为了测试推广性，在第二个轨道上测试了模型。值得注意的是，该模型从未在这条赛道的样本上训练过，但它在这条赛道上驾驶成功。<a class="ae kl" href="https://youtu.be/hOsUNo5g3A4" rel="noopener ugc nofollow" target="_blank">参见下面的路线2测试结果视频:</a></p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="b312" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">5.结论</h1><p id="e91f" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">通过使用人类行为采样数据来训练在模拟轨道上自主驾驶的深度学习模型。该模型包括5个卷积层和3个更完全连接的层，能够通过克隆人类行为进行学习，并能够概括对新测试轨道的反应。虽然该模型只控制转向角，但它也可以扩展到控制油门和刹车。</p><h1 id="5848" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">笔记</h1><p id="1dd9" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">以下是我在这个项目中的个人笔记:</p><ol class=""><li id="2f85" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated"><strong class="jp ir">数据处理和学习过程一样重要:</strong>我意识到，也许这个项目最重要的部分是提出一种预测测试用例并进行归纳的数据处理，因此使用了抖动和亮度增强。一旦我能够在Nvidia模型上训练，在comma.ai模型上工作也很容易，在相同的数据处理下，它也给出了令人满意的结果。</li><li id="e42b" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated"><strong class="jp ir">数据量统计:</strong>更多的数据最能提高学习效率。当我有大量数据进行训练时，我可以很容易地看到改进，并能够根据Udacity数据集进行验证。</li><li id="06b8" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated"><strong class="jp ir">一些我觉得没用的处理:</strong>虽然其他一些人也用了这些方法，但对我来说并没有什么影响。例如，垂直平移、通过添加一些均匀噪声来扰动0°附近的转向角，以及使用正方形大小的输入。</li></ol><p id="7307" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在我的<a class="ae kl" href="https://github.com/toluwajosh" rel="noopener ugc nofollow" target="_blank"> github这里</a>找到这个项目和其他自动驾驶汽车相关的项目。虽然这个项目已经完成，但我想改进或者训练这辆车在越野赛道上行驶。请在评论中给出任何建议、更正或补充。</p></div></div>    
</body>
</html>