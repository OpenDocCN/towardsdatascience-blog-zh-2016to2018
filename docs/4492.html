<html>
<head>
<title>Mapping the UK’s Traffic Accident Hotspots</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">英国交通事故热点地图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mapping-the-uks-traffic-accident-hotspots-632b1129057b?source=collection_archive---------14-----------------------#2018-08-19">https://towardsdatascience.com/mapping-the-uks-traffic-accident-hotspots-632b1129057b?source=collection_archive---------14-----------------------#2018-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/674d4593426c70923a147d6704d2a996.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QoPE4ip0T71jje8D"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@chrislawton?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Chris Lawton</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1524" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">在寻找一些有趣的地理数据时，我偶然发现了英国政府发布的<a class="ae kc" href="https://data.gov.uk/dataset/cb7ae6f0-4be6-4935-9277-47e5ce24a11f/road-safety-data" rel="noopener ugc nofollow" target="_blank">道路安全数据</a>。这是一个非常全面的道路事故数据集，包括事件的地理坐标，以及其他相关数据，如当地的天气情况，能见度，警察出勤等。早在 2009 年就有可用的数据，一直到 2016 年，所以这是一个非常有趣的数据集，可以用于地理和机器学习目的。</p><p id="c9a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我看到这些数据时，我立即想到在地图上可视化它。也许有可能找出交通事故密度较高的地区？由于一年的数据量巨大，仅 2016 年就超过 136，000 个点，将所有的点都转储到交互式地图中的天真方法被证明是不可能的。根据我的经验，这对于一个交互式网络地图来说太多了。这里需要另一种方法，显而易见的想法是为此探索基于密度的聚类算法。</p><p id="beea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与将整个输入空间划分为互补区域或聚类的其他聚类算法相反，这里我们只关注交通事故密度较高的区域，而将所有其他点作为噪声丢弃。对于这些高密度区域中的每一个，我们将创建一个地理围栏，作为其周围的包络，并使用它作为其中包含的点的图形表示。这种新的地理实体(多边形)可以存储在地理数据库中，以后可以用于在英国非常繁忙的街道上行驶时提供驾驶辅助。想象一下你的车辆 GPS 系统的一个额外功能，它会通知你进入一个道路事故热点，就像它警告你不要靠近高速摄像机一样。我打赌你在那里会试着开车更安全，不是吗？</p><p id="9493" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们想象一下，我们的任务是使用来自英国政府的数据来实现这样一个系统。我们必须以某种方式将这一长串地理位置转换成地理围栏，将道路事故地理密度较高的区域圈起来。有了<a class="ae kc" href="https://en.wikipedia.org/wiki/Geo-fence" rel="noopener ugc nofollow" target="_blank">地理围栏</a>——一种用地理坐标表示的多边形——我们可以很容易地测试你的车辆是否正在接近一个这样的热点，如果它已经进入或离开它。</p><h1 id="3b56" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">基于密度的聚类</h1><p id="106d" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">因此，为了检测事故热点，我们必须找到事故位置密度高的区域，并在每个区域周围绘制一个多边形。首先，我们必须澄清我们所说的密度是什么，以及如何测量它。此外，我们必须了解如何处理低密度区域。</p><blockquote class="mn mo mp"><p id="d20f" class="kd ke mq kf b kg kh ki kj kk kl km kn mr kp kq kr ms kt ku kv mt kx ky kz la ij bi translated">基于密度的数据分析技术背后的基本思想是，感兴趣的数据集代表来自未知概率密度函数(PDF)的样本，该函数描述了负责产生观察数据的一种或多种机制。[1]</p></blockquote><p id="ad18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，我们将聚类定义为包围高密度区域的区域，而所有其他点将被视为噪声，因此从分析中丢弃。有几种算法可以处理这种类型的数据，我为本文选择的算法是<a class="ae kc" href="https://en.wikipedia.org/wiki/DBSCAN" rel="noopener ugc nofollow" target="_blank"> DBSCAN </a> [2]。</p><blockquote class="mn mo mp"><p id="4fce" class="kd ke mq kf b kg kh ki kj kk kl km kn mr kp kq kr ms kt ku kv mt kx ky kz la ij bi translated">我们识别聚类的主要原因是，在每个聚类内，我们都有一个典型的点密度，该密度远高于聚类外的密度。此外，噪声区域内的密度低于任何聚类中的密度。[2]</p></blockquote><p id="5e98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在这里阅读关于这个聚类算法<a class="ae kc" rel="noopener" target="_blank" href="/how-dbscan-works-and-why-should-i-use-it-443b4a191c80">的很好的描述，并且本文中使用的实现是由</a><a class="ae kc" href="http://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html" rel="noopener ugc nofollow" target="_blank">scikit-learn</a>【3】提供的。注意，有两个非常重要的参数需要设置:聚类点之间的最小距离(<em class="mq"> eps </em>)和每个聚类的最小点数(<em class="mq"> minPts </em>)。为了更好地理解这些参数如何工作以及它们如何影响聚类结果，您可以在笔记本单元格上单独设置它们:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="87da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，<em class="mq"> minPts </em>参数被创造性地命名为<em class="mq"> num_samples </em>。这些参数决定了什么属于一个聚类，什么被认为是噪声，因此这些参数将对最终聚类集的数量和大小产生直接影响。</p><p id="f7b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行 DBSCAN 实际上非常简单:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">One-liner for running DBSCAN. See the GitHub repository for more information.</figcaption></figure><p id="e27d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在对数据运行 DBSCAN 之后，我们得到了一个集群及其对应点的集合。噪声点用聚类号-1 标记，并从我们的分析中排除。</p><h1 id="5b4a" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">气泡</h1><p id="a5f3" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">现在是用这些数据做有趣事情的时候了，在本文中，我们将使用每个星团的云的形状来绘制地理围栏。有几种策略可以做到这一点，比如绘制一个<a class="ae kc" href="https://en.wikipedia.org/wiki/Convex_hull" rel="noopener ugc nofollow" target="_blank">凸包</a>或者甚至一个<a class="ae kc" href="http://ubicomp.algoritmi.uminho.pt/local/concavehull.html" rel="noopener ugc nofollow" target="_blank">凹包</a>，但是这里我将使用一个非常简单的方法，可以称为“聚结气泡”。这个想法很简单:在每个点周围画一个圆，然后将它们合并在一起。像这样:</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/4e5cf26bada7b7d0caaaf70810f5556f.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*qSfKFE7X59buUmUMTG9y7A.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The “coalescing bubbles” process of geofence calculation.</figcaption></figure><p id="beef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个两步的过程，我们首先将所有的位置点“膨胀”成一个给定半径的圆，然后将所有的圆合并成一个多边形。创建圆(<em class="mq">缓冲</em>)代码如下:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="d615" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">投影代码需要在米(我们用于圆半径的单位)和地理坐标(纬度和经度对)之间进行转换。至于半径，我们使用一个比<em class="mq"> eps </em>小 0.6 倍的值，以避免出现非常大的圆。</p><p id="bc0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看这在代码中是如何工作的。首先，我们必须根据聚类标识符对点进行分组。记住噪声点用-1 标记。</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="55cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以开始冒泡过程。为了提高效率，我使用了<em class="mq"> shapely </em>中的<a class="ae kc" href="http://toblerity.org/shapely/manual.html#cascading-unions" rel="noopener ugc nofollow" target="_blank"> <em class="mq"> cascaded_union </em> </a>函数。</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Bubble creation process</figcaption></figure><p id="ba9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以使用上面创建的列表创建一个地理数据框架，并简单地绘制它。就像这样简单:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Create a geopandas GeoDataFrame and plot it.</figcaption></figure><p id="bd82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们可以用两行代码将整个事情发送到一个交互式地图:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Show the interactive map.</figcaption></figure><p id="8722" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完整代码可在相关的<a class="ae kc" href="https://github.com/joaofig/uk-accidents" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中获得。尽情享受吧！</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/7696716b77a75226ac3030e4a60fa54f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uAhHKPoTxkiPPFyXqxrgog.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">London traffic accident hotspots example using data between 2015 and 2016.</figcaption></figure><h1 id="1c61" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><strong class="ak">所需包</strong></h1><p id="449a" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">为了运行笔记本，您必须首先安装几个包，即 geopandas 和所有依赖项。这不是一个简单的任务，但幸运的是 Geoff Boeing 在他出色的博客文章<a class="ae kc" href="https://geoffboeing.com/2014/09/using-geopandas-windows/" rel="noopener ugc nofollow" target="_blank">在 Windows 上使用 geo pandas</a>中为我们简化了这个任务。</p><p id="a074" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你还需要安装<a class="ae kc" href="https://pypi.org/project/descartes/" rel="noopener ugc nofollow" target="_blank">笛卡尔</a>包来渲染地图上的多边形。</p><p id="1380" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，你还需要<a class="ae kc" href="https://pypi.org/project/mplleaflet/" rel="noopener ugc nofollow" target="_blank">mple leaf</a>，在浏览器上渲染交互式地图。</p><h1 id="b8d3" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><strong class="ak">参考文献</strong></h1><p id="8b69" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">[1] <a class="ae kc" href="https://dl.acm.org/citation.cfm?doid=2808688.2733381" rel="noopener ugc nofollow" target="_blank">用于数据聚类、可视化和异常值检测的分层密度估计</a></p><p id="6f0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[2]<a class="ae kc" href="http://jmlr.csail.mit.edu/papers/v12/pedregosa11a.html" rel="noopener ugc nofollow" target="_blank">sci kit-learn:Python 中的机器学习</a>，Pedregosa <em class="mq">等人</em>，JMLR 12，第 2825–2830 页，2011。</p><p id="8b63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[3] Ester，m .，Kriegel，H.P .等人(1996)一种用于在带有噪声的大型空间数据库中发现聚类的基于密度的算法。KDD，226–231</p><p id="7904" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[4] <a class="ae kc" href="http://michelleful.github.io/code-blog/2015/07/15/making-maps/" rel="noopener ugc nofollow" target="_blank">用 Python 制作地图</a>，米歇尔·富尔伍德</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="nc mz l"/></div></figure></div></div>    
</body>
</html>