<html>
<head>
<title>Overfitting vs. Underfitting: A Complete Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">过度拟合与欠拟合:一个完整的例子</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/overfitting-vs-underfitting-a-complete-example-d05dd7e19765?source=collection_archive---------1-----------------------#2018-01-28">https://towardsdatascience.com/overfitting-vs-underfitting-a-complete-example-d05dd7e19765?source=collection_archive---------1-----------------------#2018-01-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/22557da7915b38c3b7cdc76dbe01b817.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZqVjBShffTGrOophe9RsRw.jpeg"/></div></div></figure><div class=""/><p id="2a04" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">探索和解决基础数据科学问题</strong></p><p id="d8f1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当你学习数据科学时，你会意识到没有真正复杂的想法，只是许多简单的积木组合在一起。神经网络可能看起来非常先进，但它实际上只是无数小想法的组合。当您想要开发一个模型时，不要试图一次学习所有的东西，一次完成一个模块会更有效率，也更少令人沮丧。这可以确保你对基本原理有一个坚实的概念，避免许多会阻碍他人的常见错误。此外，每一部分都开辟了新的概念，让你不断积累知识，直到你可以创建一个有用的机器学习系统，同样重要的是，理解它是如何工作的。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi kw"><img src="../Images/93f7a6d06d8d5ed85e4d5575836a87be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vhuuTIB0tl1Ka39itIIoHQ.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Out of simple ideas come powerful systems (<a class="ae lf" href="https://medium.com/@ageitgey/machine-learning-is-fun-part-3-deep-learning-and-convolutional-neural-networks-f40359318721" rel="noopener">Source</a>)</figcaption></figure><p id="3c8d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章通过一个完整的例子展示了一个基本的数据科学构建模块:欠拟合与过拟合问题。我们将探讨这个问题，然后实现一个叫做交叉验证的解决方案，这是模型开发的另一个重要原则。如果你正在寻找一个关于这个话题的概念框架，<a class="ae lf" rel="noopener" target="_blank" href="/overfitting-vs-underfitting-a-conceptual-explanation-d94ee20ca7f9">请看我之前的帖子</a>。这篇文章中生成的所有图表和结果都是用Python代码写的，这些代码在<a class="ae lf" href="https://github.com/WillKoehrsen/Data-Analysis" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。我鼓励任何人去检查代码，并做出自己的改变！</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="4dae" class="ln lo jb bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">模型基础</h1><p id="2661" class="pw-post-body-paragraph jy jz jb ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">为了讨论欠拟合和过拟合，我们需要从基础开始:什么是模型？模型只是一个将输入映射到输出的系统。例如，如果我们想预测房价，我们可以制作一个模型，它接收房子的平方英尺并输出价格。一个模型代表了一个问题的理论:在平方英尺和价格之间有一些联系，我们制作一个模型来了解这种关系。模型是有用的，因为我们可以使用它们来预测给定输入的新数据点的输出值。</p><p id="603a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模型从训练数据集中学习输入(称为要素)和输出(称为标注)之间的关系。在训练期间，模型被给予特征和标签，并学习如何将前者映射到后者。训练好的模型在测试集上进行评估，我们只给它特征，它进行预测。我们将预测与测试集的已知标签进行比较，以计算准确性。模型可以采取多种形式，从简单的线性回归到深度神经网络，但所有监督模型都基于从训练数据中学习输入和输出之间关系的基本思想。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="61ef" class="ln lo jb bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">培训和测试数据</h1><p id="9000" class="pw-post-body-paragraph jy jz jb ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">要做一个模型，我们首先需要有底层关系的数据。对于本例，我们将使用x值(要素)和y值(标注)创建自己的简单数据集。我们数据生成的一个重要部分是给标签添加随机噪声。在任何真实世界的过程中，无论是自然的还是人为的，数据都不完全符合趋势。在我们无法测量的关系中，总是存在噪音或其他变量。在房价的例子中，面积和价格之间的趋势是线性的，但是由于影响房价的其他因素，价格并不完全在一条线上。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mq"><img src="../Images/9bd52072fa8fc77f072d98388454e93f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*khzX1tmUj86vfpzE6Gkf0A.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Example of a real-world relationship (<a class="ae lf" href="https://rstudio-pubs-static.s3.amazonaws.com/64900_3f884598a6e84ea3aacef364cbfc54ba.html" rel="noopener ugc nofollow" target="_blank">Source</a>)</figcaption></figure><p id="645c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的数据同样具有趋势(我们称之为真实函数)和随机噪声，以使其更加真实。创建数据后，我们将其分成随机的训练集和测试集。该模型将尝试学习训练数据上的关系，并根据测试数据进行评估。在这种情况下，70%的数据用于训练，30%用于测试。下图显示了我们将探究的数据。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/7337dbcfea397fb626896c8720005410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*5w7HRScKcuO1WZoPQFhjvw.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Data and True Generating Funtion</figcaption></figure><p id="c26a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到，由于我们添加了随机噪声，我们的数据在真实函数(部分正弦波)周围分布有一些变化(<a class="ae lf" href="https://github.com/WillKoehrsen/Data-Analysis/blob/master/over_vs_under/Over%20vs%20Under%20Fitting%20Example.ipynb" rel="noopener ugc nofollow" target="_blank">详见代码</a>)。在训练过程中，我们希望我们的模型学习真正的功能，而不会被噪音“分散注意力”。</p><h2 id="6935" class="ms lo jb bd lp mt mu dn lt mv mw dp lx kj mx my mb kn mz na mf kr nb nc mj nd bi translated"><strong class="ak">模型建筑</strong></h2><p id="0bdb" class="pw-post-body-paragraph jy jz jb ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">选择一个模型可能看起来令人生畏，但是一个好的规则是从简单开始，然后逐步建立。最简单的模型是线性回归，其中输出是输入的线性加权组合。在我们的模型中，我们将使用线性回归的<a class="ae lf" href="https://onlinecourses.science.psu.edu/stat501/node/324" rel="noopener ugc nofollow" target="_blank">扩展，称为多项式回归</a>来了解x和y之间的关系。多项式回归，其中输入被提升到不同的幂，仍然被认为是“线性”回归的一种形式，即使图形没有形成直线(这一开始也让我很困惑！)多项式的一般方程如下。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/09ca3870e76b6d102769b4eafb67bbe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*-28slRIHFanLBJkFpBfKZA.png"/></div></figure><p id="b649" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里y代表标签，x代表特征。β项是将在训练期间学习的模型参数，ε是任何模型中存在的误差。一旦模型学习了β值，我们可以插入x的任何值，并获得y的相应预测。多项式由其阶定义，它是方程中x的最高幂。直线是一次多项式，而抛物线是二次多项式。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nf"><img src="../Images/66bef2a81c57fa84ce0416b047cb7978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pjIp920-MZdS_3fLVhf-Dw.jpeg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Polynomials of Varying Degree (<a class="ae lf" href="http://brandon.ai/2017/01/27/multivariate-polynomial-regression.html" rel="noopener ugc nofollow" target="_blank">Source</a>)</figcaption></figure><h1 id="7e3b" class="ln lo jb bd lp lq ng ls lt lu nh lw lx ly ni ma mb mc nj me mf mg nk mi mj mk bi translated">过度拟合与欠拟合</h1><p id="4fb1" class="pw-post-body-paragraph jy jz jb ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated"><a class="ae lf" href="https://docs.aws.amazon.com/machine-learning/latest/dg/model-fit-underfitting-vs-overfitting.html" rel="noopener ugc nofollow" target="_blank">过拟合vs欠拟合</a>的问题终于在我们谈到多项式次数的时候出现了。程度代表模型中的灵活性，较高的能力允许模型自由地触及尽可能多的数据点。拟合不足的模型灵活性较低，并且无法解释数据。理解这个问题的最好方法是看一看展示这两种情况的模型。</p><p id="0403" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先是一个1次多项式拟合的欠拟合模型。在左图中，橙色的模型函数显示在真实函数和训练观测值的顶部。在右侧，显示了测试数据的模型预测与真实功能和测试数据点的比较。</p><div class="kx ky kz la gt ab cb"><figure class="nl is nm nn no np nq paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/faf8d8029ac76338c772bbaca8eed030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*kZfqaD6hl9iYGYXkMwV-JA.png"/></div></figure><figure class="nl is nm nn no np nq paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/7b6e6f8c0c76550ee5175fac1b741046.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*2RXJ2O-_c2ukaq5p-WQ9tQ.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk nr di ns nt">Underfit 1 degree polynomial model on training (left) and testing (right) datasets</figcaption></figure></div><p id="fd28" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的模型直接通过训练集，不考虑数据！这是因为欠拟合模型具有低方差和高偏差。方差是指模型对训练数据的依赖程度。对于1次多项式的情况，该模型很少依赖于训练数据，因为它几乎不关注点！相反，该模型具有很高的偏差，这意味着它对数据做出了强有力的假设。对于这个例子，假设数据是线性的，这显然是错误的。当模型进行测试预测时，偏差会导致它做出不准确的估计。由于这种偏差，模型无法学习x和y之间的关系，这是一个明显的拟合不足的例子。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><p id="8dde" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们看到低学位导致不适合。一个自然的结论是学习训练数据，我们应该只是增加模型的程度来捕捉数据中的每一个变化。然而这不是最好的决定！</p><div class="kx ky kz la gt ab cb"><figure class="nl is nm nn no np nq paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/4d055cc19b520b38c9db2d4b488527f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Di7rY6ALXtkhlmlcKRSCoA.png"/></div></figure><figure class="nl is nm nn no np nq paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/89a6665bbaa00659aa40890a7c30184d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*QzA45ATjeEbwv5f1G99GnQ.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk nr di ns nt">Overfit 25 degree polynomial model on training (left) and testing (right) datasets</figcaption></figure></div><p id="8d6d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于具有如此高的灵活性，该模型尽最大努力考虑每一个训练点。这似乎是个好主意——难道我们不想从数据中学习吗？此外，该模型在训练数据上具有很高的分数，因为它接近所有的点。虽然如果训练观察完美地代表了真实函数，这是可以接受的，但是因为数据中存在噪声，所以我们的模型最终符合噪声。这是一个方差很大的模型，因为它会根据训练数据发生显著变化。测试集上的预测优于1度模型，但是25度模型仍然不学习关系，因为它本质上记忆训练数据和噪声。</p><p id="1ac2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的问题是，我们想要一个不是“记忆”训练数据，而是学习实际关系的模型！怎样才能找到一个多项式次数合适的平衡模型？如果我们选择训练集上得分最高的模型，我们将只选择过拟合模型，但这不能很好地推广到测试数据。幸运的是，有一种成熟的数据科学技术来开发最佳模型:验证。</p><h1 id="20c1" class="ln lo jb bd lp lq ng ls lt lu nh lw lx ly ni ma mb mc nj me mf mg nk mi mj mk bi translated">确认</h1><p id="3c9e" class="pw-post-body-paragraph jy jz jb ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">我们需要创建一个具有最佳设置(程度)的模型，但我们不想一直经历训练和测试。在我们的例子中，测试性能差并没有什么后果，但是在一个实际的应用程序中，我们可能正在执行一个关键的任务，比如诊断癌症，部署一个有缺陷的模型会有严重的负面影响。我们需要某种预测试来用于模型优化和评估。这种预先测试被称为验证集。</p><p id="26e7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个基本的方法是除了训练集和测试集之外还使用一个验证集。但是这也带来了一些问题:我们可能会过度适应验证集，并且我们会有更少的训练数据。验证概念的一个更聪明的实现是k重交叉验证。</p><p id="2f05" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个想法很简单:我们不使用单独的验证集，而是将训练集分成许多子集，称为折叠。我们以五折为例。我们执行一系列的训练和评估循环，每次我们在4个折叠上训练，在第5个折叠上测试，称为坚持组。我们重复这个循环5次，每次使用不同的折叠进行评估。最后，我们对每个折叠的分数进行平均，以确定给定模型的整体性能。这允许我们在部署之前优化模型，而不必使用额外的数据。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/a33278171f1281c323319ed6b466d261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0G9CzbPadQaCXkxrTkqN7A.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Five-Fold Cross-Validation (<a class="ae lf" href="https://stackoverflow.com/questions/31947183/how-to-implement-walk-forward-testing-in-sklearn" rel="noopener ugc nofollow" target="_blank">Source</a>)</figcaption></figure><p id="7162" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的问题，我们可以通过创建一系列不同程度的模型，使用交叉验证来选择最佳模型，并使用5重交叉验证来评估每个模型。具有最低交叉验证分数的模型将在测试数据上表现最佳，并且将在欠拟合和过拟合之间实现平衡。我选择使用从1到40度的模型，以覆盖广泛的范围。为了比较模型，我们计算均方误差，即预测值和实际值的平方之间的平均距离。下表显示了按最低误差排序的交叉验证结果，该图显示了y轴上有误差的所有结果。</p><div class="kx ky kz la gt ab cb"><figure class="nl is nv nn no np nq paragraph-image"><img src="../Images/80ab8f0d7cf3c6dcf916b88daea816ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*OzIFRoF2YqN4yzIE5gAkdg.png"/></figure><figure class="nl is nw nn no np nq paragraph-image"><img src="../Images/a89b01ac07fbb3a8861d7d887b37b322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*yizsmPde0t0EIn-aHaBvYg.png"/><figcaption class="lb lc gj gh gi ld le bd b be z dk nx di ny nt">Cross Validation Results</figcaption></figure></div><p id="1763" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">欠拟合和过拟合模型的交叉验证误差超出了图表范围！4度的模型似乎是最佳的。为了测试结果，我们可以制作一个4度模型，并查看训练和测试预测。</p><div class="kx ky kz la gt ab cb"><figure class="nl is nm nn no np nq paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/ddcc75a4b651488e9273793d28425f28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*PL88RSFfQp0p9yBwC-o7Jg.png"/></div></figure><figure class="nl is nm nn no np nq paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/bcb3dfabdf08f5b7ad0d9badaf276a52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*pOkhETBM6is2t7JpnkOpTQ.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk nr di ns nt">Balanced Four degree polynomial model on training (left) and testing (right) datasets</figcaption></figure></div><p id="07de" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">没有比符合数据的模型更美的了！此外，我们知道我们的模型不仅密切跟踪训练数据，它实际上已经了解了x和y之间的关系。</p><p id="3b0e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了验证我们拥有最佳模型，我们还可以绘制出所谓的训练和测试曲线。这些在x轴上显示了我们调整的模型设置，在y轴上显示了训练和测试误差。欠拟合的模型将具有高训练和高测试误差，而过拟合的模型将具有极低的训练误差但高测试误差。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/e283c7e03058b9d0631a743ae7ddfceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*72c0UVyvEbxLNB1J43id5Q.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Training and Testing Curves</figcaption></figure><p id="d300" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个图表很好地总结了过度拟合和欠拟合的问题。随着模型灵活性的增加(通过增加多项式次数)，由于灵活性的增加，<em class="oa">训练</em>误差不断减小。然而，<em class="oa">测试</em>设置的误差只会随着我们将灵活性增加到一定程度而降低。在这种情况下，这发生在5度，当灵活性增加超过该点时，训练误差增加，因为模型已经记忆了训练数据和噪声。交叉验证在这个测试数据上产生了第二好的模型，但是从长远来看，我们期望我们的交叉验证模型表现最好。确切的度量标准取决于测试集，但平均来说，交叉验证的最佳模型将优于所有其他模型。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="7a43" class="ln lo jb bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">结论</h1><p id="21e1" class="pw-post-body-paragraph jy jz jb ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">过度拟合和欠拟合是一个基本问题，即使是经验丰富的数据分析师也会犯错误。在我的实验室里，我见过许多研究生用极低的误差拟合他们的数据，然后急切地用结果写一篇论文。他们的模型看起来很棒，但问题是他们甚至从未使用过测试集，更不用说验证集了！该模型只不过是训练数据的过度拟合表示，当其他人试图将他们的模型应用于新数据时，学生很快就会学到这一课。</p><p id="fa08" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是，这是一个我们可以很容易避免的错误，因为我们已经看到了使用交叉验证进行模型评估和优化的重要性。一旦我们理解了数据科学中的基本问题以及如何解决它们，我们就可以自信地建立更复杂的模型，并帮助他人避免错误。这篇文章涵盖了很多主题，但希望你现在对建模的基础、过度拟合与欠拟合、偏差与方差以及交叉验证的模型优化有所了解。数据科学就是要乐于学习，并不断向你的技能组合中添加更多工具。这个领域令人兴奋，因为它潜在的有益影响和不断学习新技术的机会。</p><p id="c104" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我欢迎反馈和建设性的批评。可以在推特上找到我，电话是<a class="ae lf" href="https://twitter.com/koehrsen_will" rel="noopener ugc nofollow" target="_blank"> @koehrsen_will </a>。我要感谢Scikit-Learn的贡献者，感谢他们在这个主题上的<a class="ae lf" href="http://scikit-learn.org/stable/auto_examples/model_selection/plot_underfitting_overfitting.html" rel="noopener ugc nofollow" target="_blank">优秀范例</a>。</p></div></div>    
</body>
</html>