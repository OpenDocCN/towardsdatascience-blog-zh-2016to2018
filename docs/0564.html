<html>
<head>
<title>Kaggle: Chicago West Nile Virus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">芝加哥西尼罗河病毒</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-go-at-kaggle-723447f8d95f?source=collection_archive---------3-----------------------#2017-05-22">https://towardsdatascience.com/a-go-at-kaggle-723447f8d95f?source=collection_archive---------3-----------------------#2017-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8cf9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我刚刚学到了一些令人沮丧的教训——作为对卡格尔西尼罗河病毒竞赛的敬意。<a class="ae kl" href="https://www.kaggle.com/c/predict-west-nile-virus" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/c/predict-west-nile-virus</a>。这不是我们有过的最大或最棘手的项目，但它让我很困惑。我的方法过于草率，陷入了竞争的心态，这让我陷入了许多兔子洞，所有这些都是可以避免的。这些都是糟糕的流程和代码混乱的症状。我很高兴我得到了教训，因为我不会让它再次发生！至少这是希望..有了这些经验教训。</p><ul class=""><li id="7bf7" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated"><strong class="jp ir">不要混淆你的笔记本进度</strong>。<em class="kv">没有什么比从头开始运行单元并失败更糟糕的了，因为一部分 EDA 是在未来的数据帧上执行的</em></li><li id="b901" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk kr ks kt ku bi translated"><strong class="jp ir">制作函数并使其动态化</strong>。<em class="kv">这不仅允许添加功能，也允许省略功能；允许您操作数据以快速迭代，通常是朝着更好的先前数据集进行多次迭代。</em></li><li id="a78f" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk kr ks kt ku bi translated"><strong class="jp ir">保存表现良好的提交数据/模型。</strong> <em class="kv">这个数据集仍然是小规模的，可以在几秒钟内重新运行，但没有理由忘记哪些功能让你获得了 0.73 的 Kaggle 分数！</em></li><li id="8121" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk kr ks kt ku bi translated"><strong class="jp ir">确认训练/测试集具有相同的列。</strong> <em class="kv">您对测试数据的预测最终取决于它提供的列/值——当然您也可以对其进行特征工程——但是确保您可以将测试集传递到您的训练数据转换函数中是关键。</em></li></ul><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/b90344477082c37ca4bbfd735a07e9ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mQLZ-LZP8L6yOpY3AZMa5g.png"/></div></div></figure><p id="b258" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这个数据集，对数据有个概念是相当容易的。我们正在查看芝加哥的一些捕蚊器，以及一些关于它们的位置、捕捉的蚊子类型、日期和一些其他琐碎特征的数据。训练集约为 12k 行；测试约 112k。Kaggle 对提交的内容进行评分的标准是 AUC。更多内容请见下文。</p><p id="66ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们在看一个分类问题，EDA 之后的第一步实际上是获得基线分数:就准确性而言，最简单的预测会给你多少分。在这种情况下，目标变量是 WnvPresent，由于西尼罗病毒的罕见性质，如果我们猜测一只蚊子没有西尼罗病毒，我们 94.8%的时间都是正确的！这是一个简单但<em class="kv">* *关键** </em>的概念。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ln"><img src="../Images/84062f92160f4511f1b79a6f1c11b260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9zSzDuDiXOcErNjhaYTjIQ.png"/></div></div></figure><p id="623f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的下一步是向 Kaggle 发送一个示例提交，这样我就可以确认格式。你知道，登上排行榜。有了这个剪刀，我就在那里。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lo"><img src="../Images/f5667bdc9257658cfbbad68818b74717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T7AYOtnEFstF8kRCIeZPWw.png"/></div></div></figure><p id="4a36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从这里开始，最初的 jupyter 笔记本是这样的。调查分类数据预测西尼罗河的可能性。看看这些数字，找出它们之间的关系。假设。重复一遍。它很乱，我忽略了让它容易重复。第二天我非常后悔。</p><p id="8ec5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很明显，很多陷阱都是惯犯。此外，NumMosquitos 特性似乎会使预测变得容易。记住，任何高于 0.0525 的预测西尼罗河的机会都是值得研究的。这是我们的基线谈话。所以这些落在 0.09 以上的陷阱看起来是很好的预测。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lp"><img src="../Images/9e7d7d4b2268b847671c0bfd2021b692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nzK0ySMqe6gRRjVq0LpONg.png"/></div></div></figure><p id="c037" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">捕获的蚊子越多，蚊子数量就越多。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lq"><img src="../Images/11b2cfe4085f93850830a2a1ebda0989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m0fyVQ7j1Gq1RFz6fiIV8A.png"/></div></div></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/26c61589cd70d9fe9f4510ee432142f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*AflcPxAm-0hyQWqf8PTufA.png"/></div></figure><p id="00fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我创建了一个快速而肮脏的虚拟变量函数，将陷阱和块数据放入一些数字中，删除了其他大部分列，然后将我的测试集放入模型中，然后嘎然而止。在我对它进行变换后，会有更多的列。为什么？该死。没想到会这样。你看，我们的课程往往有非常干净的数据。嗯，并不是说这很混乱，但它与我的假设 test.columns = train.columns 不同。测试集中也有新的数据。看不见的陷阱。和一个新物种。这就是大多数额外栏目的来源。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ls"><img src="../Images/a3205b0070ee9566f6a16f9d2e1b544a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z2CJv4MmftLckH9WB9fp3A.png"/></div></div></figure><p id="f8f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我不完全确定在这种情况下什么是正确的决定。大多数其他学生都在用相反的方法运行，即找出几个最有可能感染西尼罗河病毒的关键特征，然后用它们运行他们的模型。我喜欢快速迭代替代方案，这意味着我需要弄清楚如何手动修复大约 200 个特性列<em class="kv">而不是</em>。我能想到的最好的办法是从一开始就连接测试和训练，并重复虚拟预处理。我想，这将确保它们具有相同数量的列，并且我可以将它们从 Id 列中分离出来，Id 列是测试集的数字，NaN 是火车的数字。</p><p id="4b4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着测试集中的新列与可预测性无关。尽管他们不会，除非我们能以某种方式概括他们。比如把陷阱按 10 个一组分组之类的。我也不确定是否使用了年份数据——因为我添加了虚拟值，但是从测试到训练的年份不同。我决定下次再考虑这个问题。</p><p id="f008" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">经过一两个小时的忙碌，我提交了下一套，很高兴地发现在 Kaggle 上获得了 70 AUC。AUC 指标在这里也很重要，但要理解它，我们首先需要理解什么是混淆矩阵。</p><p id="8e68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在像西尼罗河病毒这样的二元分类中，有 4 种可能的结果:</p><ul class=""><li id="b4ac" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated"><strong class="jp ir"> TP </strong> —真阳性:WNV 出现，WNV 被预测。</li><li id="d500" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk kr ks kt ku bi translated"><strong class="jp ir"> FP </strong> —误报:<em class="kv">(第一类错误)</em> WNV 不存在而 WNV 却被预测到了。</li><li id="7164" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk kr ks kt ku bi translated"><strong class="jp ir">TN</strong>——真正的否定:WNV 不在，WNV 没有被预测到。</li><li id="361b" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk kr ks kt ku bi translated"><strong class="jp ir"> FN </strong> —假阴性:<em class="kv">(第二类错误)</em> WNV 是存在的，但 WNV 却没有被预测到。</li></ul><p id="1311" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些是我们判断分类器的依据。混淆矩阵有许多最常用的评估指标:</p><ul class=""><li id="e923" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">准确度= (TP + TN) / (TP + FP + TN + FN)</li><li id="a7a7" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk kr ks kt ku bi translated">精度= TP / (TP + FP)</li><li id="ee46" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk kr ks kt ku bi translated">召回率(TPR)= TP/(TP+FN)-正确预测的阳性数据点占全部阳性数据点的比例。</li><li id="3b56" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk kr ks kt ku bi translated">脱落(FPR)= FP/(FP+TN)-被错误预测的负数据点占负数据点总数的比例。</li></ul><p id="0f49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">AUROC 或通常称为 AUC，是真阳性率和假阳性率之比的曲线下面积。理想的分类器是 AUC 为 1 的分类器；其中 TPR = 1，而 FPR = 0。AUC 讲述了在我们可以选择的阈值范围内，我们的分类器的 TPR 如何与其 FPR 相关的整体情况。在下面的例子中，TPR 在大约 0.6 FPR 时达到最大值。意思是要正确分类所有的正面事例，我们会错误地把 6/10 的负面事例分类为正面。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/89473a44969c166278616e04a5993388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*a-LuNkGd5hgbOOSlVt22rw.png"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">The AUROC commonly referred to as the AUC is the ratio of the TPR over the FPR</figcaption></figure><p id="4cbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很好地解释了这一切是如何运作的:<a class="ae kl" href="https://www.youtube.com/watch?v=OAl6eAyP-yo&amp;t=6s" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=OAl6eAyP-yo&amp;t = 6s</a></p><p id="84cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我能够添加的一些最好的功能是基于位置和天气的。两者都是在数据中发现更高概率的 WNV 聚类的例子。在地理位置方面，我在奥黑尔机场附近找到了 WVN 的一个热点。通过将距离&lt; 3 英里归类为 1，我能够创建一个二进制列，使样本中存在 WNV 的几率为 0 . 1。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ly"><img src="../Images/4eada5a5ab9b7c49642019435ef7fe0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I4L8gWUDegnTQ2crLCmIvQ.png"/></div></div></figure><p id="af57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一种是使用湿球值作为高于某一阈值的二元指标。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lz"><img src="../Images/dc8945522c3c4ae86ce83cc0f56e0896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VQlyVet-zm-81lA6k4RniA.png"/></div></div></figure><p id="0224" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我太沉迷于添加和删除功能以及重新训练我的模型，以至于失去了我最初的最好成绩。在我对自己感到相当沮丧之后，我重新构建了许多代码，并且有条不紊地修改了我的解决方案。结果是能够获得更高的分数，并且能够在不失去我的位置的情况下快速迭代。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ma"><img src="../Images/77c6c6b0e303e8f60191b1a1f9344ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5zIjD1JzFbxSoJzPGB_h9Q.png"/></div></div></figure><p id="c321" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个故事的寓意是，获得最快最好的结果不应该以不可复制的数据为代价。你的流程越有条理，你在函数中构建的自由度越大，你就越有能力改变你的数据和模型。</p></div></div>    
</body>
</html>