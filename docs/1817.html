<html>
<head>
<title>Smart way of storing data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">存储数据的巧妙方式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/smart-way-of-storing-data-d22dd5077340?source=collection_archive---------1-----------------------#2017-10-28">https://towardsdatascience.com/smart-way-of-storing-data-d22dd5077340?source=collection_archive---------1-----------------------#2017-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/7025e4f427ec26a8305cc2d8881ad3e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CEDIS5-8bpwtZ7zd5d98bQ.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="fda7" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">让我们来谈谈位打包、重复数据删除等等</h2></div><p id="3a8d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">位打包就是让数据表示像手套一样适合你的数据。这是一个非常形象的比喻，但可能会有点混乱，所以让我们直接看第一个也是最简单的例子:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="51ef" class="lv lw jb lr b gy lx ly l lz ma">00000001 00000000 00000001</span></pre><p id="f5e6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">上面看到的是一个布尔数组的二进制表示:<code class="fe mb mc md lr b">true, false, true</code>。在大多数编程语言中，布尔值以8位存储，其中<code class="fe mb mc md lr b">0</code>是<code class="fe mb mc md lr b">false</code>，而<code class="fe mb mc md lr b">&gt;=1</code>是<code class="fe mb mc md lr b">true</code>。这一切都是有意义的，因为CPU是如何读取数据的，但是如果我们知道我们要存储一个布尔值数组，我们可以使用一个<a class="ae me" href="https://en.wikipedia.org/wiki/Bit_array" rel="noopener ugc nofollow" target="_blank">位数组</a>:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="01f4" class="lv lw jb lr b gy lx ly l lz ma">00000101</span></pre><p id="eff5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这种情况下，bool数组可以表示为一个字节数组，其中size是<code class="fe mb mc md lr b">ceil(size/8)</code>。当我们请求索引<code class="fe mb mc md lr b">i</code>处的元素时，我们需要从<code class="fe mb mc md lr b">i</code>创建两个索引:</p><ol class=""><li id="1335" class="mf mg jb ks b kt ku kw kx kz mh ld mi lh mj ll mk ml mm mn bi translated">字节索引<code class="fe mb mc md lr b">floor(i/8)</code></li><li id="cea0" class="mf mg jb ks b kt mo kw mp kz mq ld mr lh ms ll mk ml mm mn bi translated">位索引<code class="fe mb mc md lr b">i mod 8</code>，或者你也可以做<code class="fe mb mc md lr b">i — (byteIndex * 8)</code>如果你不想做<a class="ae me" href="https://en.wikipedia.org/wiki/Modulo_operation" rel="noopener ugc nofollow" target="_blank">模</a>运算。</li></ol><p id="bdd5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了找出索引<code class="fe mb mc md lr b">i</code>处的值是<code class="fe mb mc md lr b">true</code>还是<code class="fe mb mc md lr b">false</code>，我们需要从比特索引<code class="fe mb mc md lr b">1 &lt;&lt; bitIndex</code>创建一个比特掩码，然后应用下面的表达式:<code class="fe mb mc md lr b">bitArray[byteIndex] &amp; mask != 0</code>。</p><p id="9f35" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">正如我们所看到的，从位数组中读取布尔值需要一些计算，但在最好的情况下可以将存储数据的大小减少87.5%。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="ab0a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在我们来谈谈数字。数字以字节存储:</p><ul class=""><li id="3026" class="mf mg jb ks b kt ku kw kx kz mh ld mi lh mj ll na ml mm mn bi translated">1字节:0… <strong class="ks jc"> 256 </strong></li><li id="63ee" class="mf mg jb ks b kt mo kw mp kz mq ld mr lh ms ll na ml mm mn bi translated">2字节:0…<strong class="ks jc">65536</strong></li><li id="0bb3" class="mf mg jb ks b kt mo kw mp kz mq ld mr lh ms ll na ml mm mn bi translated">4字节:0… <strong class="ks jc"> 4，294，967，296 </strong></li><li id="ac0c" class="mf mg jb ks b kt mo kw mp kz mq ld mr lh ms ll na ml mm mn bi translated">8字节:0… <strong class="ks jc"> 18，446，744，073，709，551，616 </strong></li></ul><h2 id="d20d" class="lv lw jb bd nb nc nd dn ne nf ng dp nh kz ni nj nk ld nl nm nn lh no np nq nr bi translated">但是如果我们知道我们的数据是由较小的数字组成的呢？</h2><p id="ac99" class="pw-post-body-paragraph kq kr jb ks b kt ns kc kv kw nt kf ky kz nu lb lc ld nv lf lg lh nw lj lk ll ij bi translated">四分之一字节可以代表数字0…3，一半字节可以代表数字0…15。</p><p id="280b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们可以使用与位数组中相同的技术——计算两个索引，并通过几次<a class="ae me" href="https://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts" rel="noopener ugc nofollow" target="_blank">位移操作</a>得到值。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="3a9d" class="lv lw jb lr b gy lx ly l lz ma">00000001 00000010 00000011 00000000</span></pre><p id="0dee" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">其中值为<code class="fe mb mc md lr b">1, 2, 3, 0</code>。可以变成:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="b4fa" class="lv lw jb lr b gy lx ly l lz ma">00111001</span></pre><p id="4259" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">实现了75%的减少。我将让读者去思考如何用半字节表示保存一个数组。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h2 id="b0e4" class="lv lw jb bd nb nc nd dn ne nf ng dp nh kz ni nj nk ld nl nm nn lh no np nq nr bi translated">存储一个6位数字有意义吗？</h2><p id="c3bb" class="pw-post-body-paragraph kq kr jb ks b kt ns kc kv kw nt kf ky kz nu lb lc ld nv lf lg lh nw lj lk ll ij bi translated">如果我们存储的数不是二位数的幂(1，2，4，8)，我们将不得不面对这样一个事实，即一个数存储在两个字节之间。这意味着我们必须先读取第一个字节，然后再读取第二个字节。所以一般来说这是可能的，但老实说我从未见过有人这样做。然而，我所看到的是——将两个小数字的元组一起存储在一个字节中。例如<a class="ae me" href="https://google.github.io/flatbuffers/flatbuffers_internals.html" rel="noopener ugc nofollow" target="_blank"> FlexBuffers类型定义</a>是:</p><ul class=""><li id="4821" class="mf mg jb ks b kt ku kw kx kz mh ld mi lh mj ll na ml mm mn bi translated">2个较低的位代表子的位宽(8，16，32，64)</li><li id="c215" class="mf mg jb ks b kt mo kw mp kz mq ld mr lh ms ll na ml mm mn bi translated">6位代表实际类型</li></ul></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h2 id="c78e" class="lv lw jb bd nb nc nd dn ne nf ng dp nh kz ni nj nk ld nl nm nn lh no np nq nr bi translated">如果我不知道我的数字会有多大呢？</h2><p id="3242" class="pw-post-body-paragraph kq kr jb ks b kt ns kc kv kw nt kf ky kz nu lb lc ld nv lf lg lh nw lj lk ll ij bi translated">在这种情况下，你可以选择尽可能大的尺寸，或者应用<a class="ae me" href="https://en.wikipedia.org/wiki/Variable-length_quantity" rel="noopener ugc nofollow" target="_blank">可变长度数量</a>技术。</p><p id="fa70" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这种技术中，我们取一个代表数字的比特流，并将其分成7个比特。第8位成为“标志”位。如果下一个7位分区不包含所有的<code class="fe mb mc md lr b">0</code>，标志位将被设置为<code class="fe mb mc md lr b">1</code>，如果您对细节感兴趣，请查看<a class="ae me" href="https://en.wikipedia.org/wiki/Variable-length_quantity" rel="noopener ugc nofollow" target="_blank">维基百科文章</a>。</p><p id="6bd2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">协议缓冲区中使用了可变长度数量技术，这对格式非常重要，这是<a class="ae me" href="https://developers.google.com/protocol-buffers/docs/encoding" rel="noopener ugc nofollow" target="_blank">编码文档</a>解释的第一件事。</p><p id="4b2c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有趣的是，如果你看看<a class="ae me" href="https://en.wikipedia.org/wiki/UTF-8" rel="noopener ugc nofollow" target="_blank"> UTF-8 </a>编码。这基本上是相同的技术，只是在扫描字节方面有一点小小的调整。字节序列中的第一个字节，它编码一个<a class="ae me" href="https://en.wikipedia.org/wiki/Unicode" rel="noopener ugc nofollow" target="_blank"> Unicode字符</a>告诉你序列有多长。如果字节以<code class="fe mb mc md lr b">0</code>开始(从左到右方向),则只有这一个字节。如果unicode字符需要两个字节，那么第一个字节的“开始”将是<code class="fe mb mc md lr b">11</code>，如果是三个字节，则是<code class="fe mb mc md lr b">111</code>，依此类推。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="6216" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在我们转向重复数据消除之前，我还想讨论一项技术。我说的是<strong class="ks jc">存储增量</strong>。</p><p id="ace1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">假设您正在存储一个时间戳序列，表示为<a class="ae me" href="https://en.wikipedia.org/wiki/Unix_time" rel="noopener ugc nofollow" target="_blank"> unix时间</a>。如果我们按原样存储时间戳，每个条目将消耗4个字节。然而，如果我们只按原样存储第一个条目，而所有其他条目只作为增量存储，那么我们可以对所有后续条目使用小得多的数字表示。最佳情况下，事件之间的间隔总是小于255秒(4分15秒)。因此，我们可以用1字节存储时间戳，节省大约75%的空间。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h2 id="17b4" class="lv lw jb bd nb nc nd dn ne nf ng dp nh kz ni nj nk ld nl nm nn lh no np nq nr bi translated">现在我们来谈谈重复数据消除。</h2><p id="d252" class="pw-post-body-paragraph kq kr jb ks b kt ns kc kv kw nt kf ky kz nu lb lc ld nv lf lg lh nw lj lk ll ij bi translated">每个数据都有某种重复。重复数据删除技术试图找到这些重复数据并<em class="nx">【消除】</em>它们。</p><p id="07ba" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">消除是一个很强的词，我们不能因为一个值存储了两次就删除它。我们能做的，是间接地储存价值。一个很好的重复数据删除的老例子是<a class="ae me" href="https://en.wikipedia.org/wiki/GIF" rel="noopener ugc nofollow" target="_blank"> GIF格式</a>。在GIF中，一种颜色用24位——3字节来表示。它存储在调色板中。一个调色板可以容纳256个条目(3 * 256 = 768字节)。存储图像中的每个像素都存储为1字节调色板索引。</p><h2 id="b049" class="lv lw jb bd nb nc nd dn ne nf ng dp nh kz ni nj nk ld nl nm nn lh no np nq nr bi translated">让我们做一些数学</h2><p id="fc38" class="pw-post-body-paragraph kq kr jb ks b kt ns kc kv kw nt kf ky kz nu lb lc ld nv lf lg lh nw lj lk ll ij bi translated">我们有768字节的开销，每像素66%的收益。这意味着，如果我们有超过384像素:<code class="fe mb mc md lr b">384 * 3 = 384 * 1 + 768</code>我们弥补了调色板的成本，并开始了我们的旅程，以减少66%的空间。</p><p id="09ac" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">同样的技术可以应用于大数字、文本串或任何其他在我们的数据集中重复出现的数据。这种技术的唯一问题是，我们需要知道数据有多少种不同的表现形式。使用GIF，调色板是以某种方式创建的，一些颜色可能被“挤压”成一种颜色。这不是图像的问题，但是你可能不想对文本做同样的事情。</p><p id="5b6d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果你仔细阅读前面的章节，你可能已经知道答案了。我们可以将调色板索引存储为可变长度的量。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="58e9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们还可以做另一件聪明的事情。我们可以尝试使用大数定律。在一个大的数据集中，我们可以假设一些条目会比其他条目出现得更频繁。在这种情况下，我们可以为X个最常出现的值创建一个小调色板，使用另一个调色板/数组来存储不经常出现的数字，这些值将存储在一个位打包数组中，该数组将指示该数字是否经常出现。好的，这很抽象，让我们举个小例子。</p><p id="906e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">假设我们正在存储数字，我们知道<code class="fe mb mc md lr b">7, 13, 42</code>是我们通常存储的三个最常用的数字。现在让我们看一个数据序列的例子:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="05d6" class="lv lw jb lr b gy lx ly l lz ma">Initial: 7, 7, 7, 13, 13, 13, 2345, 42, 42, 7, 13, 6543, 7</span><span id="11f2" class="lv lw jb lr b gy ny ly l lz ma">=&gt;</span><span id="125d" class="lv lw jb lr b gy ny ly l lz ma">Index:    1, 1, 1, 2, 2, 2, 0, 3, 3, 1, 2, 0, 1<br/>Frequent: 7, 13, 42<br/>Other:    2345, 6543</span></pre><p id="d4a6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">所以我们看到我们有一个13个条目的索引，它存储从<code class="fe mb mc md lr b">0</code>到<code class="fe mb mc md lr b">3</code>的数字。这是我们存储的一系列值。如果值大于<code class="fe mb mc md lr b">0</code>，则表示“频繁”的号码:<code class="fe mb mc md lr b">1 -&gt; 7, 2 -&gt; 13, 3 -&gt; 42</code>。如果是<code class="fe mb mc md lr b">0</code>，那么我们需要从“其他”数组中取出下一个数字。</p><p id="710b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这意味着我们不能通过索引来访问值，我们只能遍历它们，但是由于索引是一个在<code class="fe mb mc md lr b">0</code>和<code class="fe mb mc md lr b">3</code>之间的数字，我们可以用四分之一字节来存储13个值，用2个字节来存储5个其他值。让我们再计算一下:</p><ul class=""><li id="dca2" class="mf mg jb ks b kt ku kw kx kz mh ld mi lh mj ll na ml mm mn bi translated">索引:<code class="fe mb mc md lr b">ceil(13 / 4) = 4</code>字节</li><li id="aa4a" class="mf mg jb ks b kt mo kw mp kz mq ld mr lh ms ll na ml mm mn bi translated">频率+其他:<code class="fe mb mc md lr b">5 * 2 = 10</code>字节</li></ul><p id="aa7a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">总计<code class="fe mb mc md lr b">14</code>字节与<code class="fe mb mc md lr b">13 * 2 = 26</code>字节相比。</p><p id="1c2e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">看起来，如果你有很多条目，并且<a class="ae me" href="https://en.wikipedia.org/wiki/Law_of_large_numbers" rel="noopener ugc nofollow" target="_blank">大数定律</a>站在你这边，那么争论是值得的。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="e3a2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一个用例是当你处理一个稀疏值序列时，大数定律肯定是对你有利的。我说的稀疏值序列是指一个序列，其中许多值可以是“默认”或<code class="fe mb mc md lr b">null</code>(缺少值<a class="ae me" href="https://en.wikipedia.org/wiki/Null_(SQL)" rel="noopener ugc nofollow" target="_blank"/>)。在这种情况下，我们的索引可以只是一个位数组，表示没有值。我们不需要“频繁”数组，我们只需要“其他/值”。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="fdfc" class="lv lw jb lr b gy lx ly l lz ma">Initial: 23, 45, null, null, null, null, null, 3</span><span id="d6fb" class="lv lw jb lr b gy ny ly l lz ma">=&gt;</span><span id="41e9" class="lv lw jb lr b gy ny ly l lz ma">Index:  1, 1, 0, 0, 0, 0, 0, 1<br/>Values: 23, 45, 3</span></pre></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="4fbc" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">另一种技术是基于大数定律的T2霍夫曼编码。我认为理解其背后概念的最好方法，是看一下<a class="ae me" href="https://en.wikipedia.org/wiki/Morse_code" rel="noopener ugc nofollow" target="_blank">莫尔斯电码</a>。在莫尔斯电码中，最常用的字符用最短的序列表示，不常用的用最长的序列表示。这样，当你用莫尔斯电码交流时，你可能会花更少的时间传输。<a class="ae me" href="https://en.wikipedia.org/wiki/Huffman_coding" rel="noopener ugc nofollow" target="_blank">霍夫曼编码</a>有点复杂，因为它是二进制格式，其中<a class="ae me" href="https://en.wikipedia.org/wiki/Morse_code" rel="noopener ugc nofollow" target="_blank">莫尔斯码</a>是三进制的(短、长、无声)，但想法非常接近。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="a407" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">可能有更聪明的方法来存储数据，但遗憾的是，这是我所能得到的。我很乐意在评论中看到更多的技巧。如果你愿意，你可以鼓掌。</p></div></div>    
</body>
</html>