<html>
<head>
<title>Logistic Regression using Python (scikit-learn)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 进行逻辑回归(scikit-learn)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/logistic-regression-using-python-sklearn-numpy-mnist-handwriting-recognition-matplotlib-a6b31e2b166a?source=collection_archive---------0-----------------------#2017-09-13">https://towardsdatascience.com/logistic-regression-using-python-sklearn-numpy-mnist-handwriting-recognition-matplotlib-a6b31e2b166a?source=collection_archive---------0-----------------------#2017-09-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/63a3a528689afd71ace95280121c3326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1TkgO9Zz6rC3KpAYNl5KfA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><em class="kc">Visualizing the Images and Labels in the MNIST Dataset</em></figcaption></figure><p id="35f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python 的 scikit-learn 库最令人惊讶的一点是，它有一个 4 步建模模式，使编写机器学习分类器变得很容易。虽然本教程使用了一个称为逻辑回归的分类器，但本教程中的编码过程也适用于 sklearn 中的其他分类器(决策树、K-最近邻等)。在本教程中，我们使用逻辑回归来预测基于图像的数字标签。上图显示了一组来自 MNIST 数据集的训练数字(观察值)，其类别成员是已知的(标签 0-9)。使用逻辑回归训练模型后，它可用于预测给定图像的图像标签(标签 0-9)。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Logistic Regression using Python Video</figcaption></figure><p id="23e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇教程文章的第一部分介绍了一个玩具数据集(digits dataset ),快速展示了 scikit-learn 的 4 步建模模式，并展示了逻辑回归算法的行为。本教程的第二部分介绍了一个更真实的数据集(MNIST 数据集)，以简要说明更改模型的默认参数如何影响性能(包括模型的计时和精度)。就这样，让我们开始吧。如果你迷路了，我建议在一个单独的标签中打开上面的<a class="ae lh" href="https://www.youtube.com/watch?v=71iXeuKFcQM" rel="noopener ugc nofollow" target="_blank">视频</a>。本教程中使用的代码如下</p><p id="9153" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lh" href="https://github.com/mGalarnyk/Python_Tutorials/blob/master/Sklearn/Logistic_Regression/LogisticRegression_toy_digits_Codementor.ipynb" rel="noopener ugc nofollow" target="_blank">数字逻辑回归</a>(教程代码的第一部分)</p><p id="756d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lh" href="https://github.com/mGalarnyk/Python_Tutorials/blob/master/Sklearn/Logistic_Regression/LogisticRegression_MNIST_Codementor.ipynb" rel="noopener ugc nofollow" target="_blank"> MNIST 逻辑回归</a>(教程代码的第二部分)</p><h2 id="da7c" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">入门(先决条件)</h2><p id="a184" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">如果您已经安装了 anaconda，请跳到下一节。我建议安装 anaconda(Python 2 或 3 对本教程来说都很好)，这样在导入库时就不会有任何问题。</p><p id="62e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以从官方网站下载 anaconda 并自行安装，也可以按照下面的 anaconda 安装教程在您的操作系统上安装 anaconda。</p><p id="c6ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 Windows 上安装 Anaconda:<a class="ae lh" href="https://medium.com/@GalarnykMichael/install-python-anaconda-on-windows-2020-f8e188f9a63d" rel="noopener">链接</a></p><p id="05d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 Mac 上安装 Anaconda:<a class="ae lh" href="https://medium.com/@GalarnykMichael/install-python-on-mac-anaconda-ccd9f2014072" rel="noopener">链接</a></p><p id="3da2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 Ubuntu 上安装 Anaconda(Linux):<a class="ae lh" href="https://medium.com/@GalarnykMichael/install-python-on-ubuntu-anaconda-65623042cb5a" rel="noopener">链接</a></p><h1 id="3f89" class="mg lj iq bd lk mh mi mj ln mk ml mm lq mn mo mp lt mq mr ms lw mt mu mv lz mw bi translated">数字数据集上的逻辑回归</h1><h2 id="1a7f" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">加载数据(数字数据集)</h2><p id="9b0e" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">digits 数据集是 scikit-learn 附带的数据集之一，不需要从外部网站下载任何文件。下面的代码将加载数字数据集。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="cdf1" class="li lj iq my b gy nc nd l ne nf">from sklearn.datasets import load_digits<br/>digits = load_digits()</span></pre><p id="63f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在您已经加载了数据集，您可以使用下面的命令</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="8bba" class="li lj iq my b gy nc nd l ne nf"># Print to show there are 1797 images (8 by 8 images for a dimensionality of 64)<br/>print(“Image Data Shape” , digits.data.shape)</span><span id="9f4b" class="li lj iq my b gy ng nd l ne nf"># Print to show there are 1797 labels (integers from 0–9)<br/>print("Label Data Shape", digits.target.shape)</span></pre><p id="2f6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要查看数据集中有 1797 个图像和 1797 个标签</p><h2 id="2d0b" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">显示图像和标签(数字数据集)</h2><p id="2877" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">这一部分实际上只是展示图像和标签的样子。可视化数据通常有助于了解您正在处理的内容。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="8a83" class="li lj iq my b gy nc nd l ne nf">import numpy as np <br/>import matplotlib.pyplot as plt</span><span id="e879" class="li lj iq my b gy ng nd l ne nf">plt.figure(figsize=(20,4))<br/>for index, (image, label) in enumerate(zip(digits.data[0:5], digits.target[0:5])):<br/> plt.subplot(1, 5, index + 1)<br/> plt.imshow(np.reshape(image, (8,8)), cmap=plt.cm.gray)<br/> plt.title('Training: %i\n' % label, fontsize = 20)</span></pre><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/9ea19c3c22fe5508bd1b9f58a7fd545f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-d-FqrdbS3q8ksMiyc3lmA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Visualizing the Images and Labels in our Dataset</figcaption></figure><h2 id="ecae" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">将数据分为训练集和测试集(数字数据集)</h2><p id="30fe" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">下面的代码执行<a class="ae lh" rel="noopener" target="_blank" href="/understanding-train-test-split-scikit-learn-python-ea676d5e3d1">训练测试分割</a>，将 75%的数据放入训练集，25%的数据放入测试集。这是为了确保我们的分类算法能够很好地推广到新数据。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="eac0" class="li lj iq my b gy nc nd l ne nf">from sklearn.model_selection import train_test_split<br/>x_train, x_test, y_train, y_test = train_test_split(digits.data, digits.target, test_size=0.25, random_state=0)</span></pre><h2 id="abea" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">sci kit-学习 4 步建模模式(数字数据集)</h2><p id="e89a" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">第一步。导入您想要使用的模型</p><p id="54e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 sklearn 中，所有的机器学习模型都是作为 Python 类实现的</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="f10b" class="li lj iq my b gy nc nd l ne nf">from sklearn.linear_model import LogisticRegression</span></pre><p id="cba5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二步。制作模型的一个实例</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="edbf" class="li lj iq my b gy nc nd l ne nf"># all parameters not specified are set to their defaults<br/>logisticRegr = LogisticRegression()</span></pre><p id="1c10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第三步。根据数据训练模型，存储从数据中学习到的信息</p><p id="1ec6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模型正在学习数字(x_train)和标签(y_train)之间的关系</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="8494" class="li lj iq my b gy nc nd l ne nf">logisticRegr.fit(x_train, y_train)</span></pre><p id="05b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第四步。预测新数据(新图像)的标签</p><p id="3187" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用模型在模型训练过程中学习到的信息</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="6d4f" class="li lj iq my b gy nc nd l ne nf"># Returns a NumPy Array<br/># Predict for One Observation (image)<br/>logisticRegr.predict(x_test[0].reshape(1,-1))</span></pre><p id="1e47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一次预测多个观察结果(图像)</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="6a77" class="li lj iq my b gy nc nd l ne nf">logisticRegr.predict(x_test[0:10])</span></pre><p id="8616" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对整个测试数据进行预测</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="935d" class="li lj iq my b gy nc nd l ne nf">predictions = logisticRegr.predict(x_test)</span></pre><h2 id="083a" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">衡量模型性能(数字数据集)</h2><p id="106f" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">虽然有其他方法来衡量模型性能(精确度、召回率、F1 分数、<a class="ae lh" rel="noopener" target="_blank" href="/receiver-operating-characteristic-curves-demystified-in-python-bd531a4364d0"> ROC 曲线</a>等)，但我们将保持简单，使用精确度作为我们的衡量标准。<br/>要做到这一点，我们要看看模型在新数据(测试集)上的表现</p><p id="1064" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">精确度定义为:</p><p id="4791" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(正确预测的分数):正确预测/数据点总数</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="14f4" class="li lj iq my b gy nc nd l ne nf"># Use score method to get accuracy of model<br/>score = logisticRegr.score(x_test, y_test)<br/>print(score)</span></pre><p id="adb8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的准确率是 95.3%。</p><h2 id="958b" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">混淆矩阵(数字数据集)</h2><p id="85ea" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">混淆矩阵是一个表格，通常用于描述一个分类模型(或“分类器”)对一组真实值已知的测试数据的性能。在这一节中，我将展示两个 python 包(Seaborn 和 Matplotlib ),它们使混淆矩阵更容易理解，在视觉上更有吸引力。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="3fd2" class="li lj iq my b gy nc nd l ne nf">import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>from sklearn import metrics</span></pre><p id="71bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的混淆矩阵在视觉上并不丰富，也不吸引人。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="4c08" class="li lj iq my b gy nc nd l ne nf">cm = metrics.confusion_matrix(y_test, predictions)<br/>print(cm)</span></pre><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/8021e31856967525cbd0b4563e358393.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/format:webp/1*9pzQbJf5KHGoK95W1LyDZg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Not a visually appealing way to view a confusion matrix</figcaption></figure><p id="6762" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">方法 1(海上分娩)</strong></p><p id="595c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你在下面看到的，这个方法使用 seaborn 产生了一个更容易理解和视觉可读的混淆矩阵。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="7f7c" class="li lj iq my b gy nc nd l ne nf">plt.figure(figsize=(9,9))<br/>sns.heatmap(cm, annot=True, fmt=".3f", linewidths=.5, square = True, cmap = 'Blues_r');<br/>plt.ylabel('Actual label');<br/>plt.xlabel('Predicted label');<br/>all_sample_title = 'Accuracy Score: {0}'.format(score)<br/>plt.title(all_sample_title, size = 15);</span></pre><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/a96788437b3213dad48dec06a5ed3174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*ksA9op39TlAvHtU5lBaDdQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><em class="kc">Confusion Matrix using Seaborn</em></figcaption></figure><p id="9060" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">方法 2 (Matplotlib) </strong> <br/>这个方法显然多了很多代码。我只是想向人们展示如何在 matplotlib 中也这样做。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="6638" class="li lj iq my b gy nc nd l ne nf">plt.figure(figsize=(9,9))<br/>plt.imshow(cm, interpolation='nearest', cmap='Pastel1')<br/>plt.title('Confusion matrix', size = 15)<br/>plt.colorbar()<br/>tick_marks = np.arange(10)<br/>plt.xticks(tick_marks, ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], rotation=45, size = 10)<br/>plt.yticks(tick_marks, ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], size = 10)<br/>plt.tight_layout()<br/>plt.ylabel('Actual label', size = 15)<br/>plt.xlabel('Predicted label', size = 15)<br/>width, height = cm.shape</span><span id="4846" class="li lj iq my b gy ng nd l ne nf">for x in xrange(width):<br/> for y in xrange(height):<br/>  plt.annotate(str(cm[x][y]), xy=(y, x), <br/>  horizontalalignment='center',<br/>  verticalalignment='center')</span></pre><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/818410cd36f286d09342df770d5fb923.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oHwtNTIVDXsO4bjRS19stA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Confusion Matrix using Matplotlib</figcaption></figure><h1 id="a69a" class="mg lj iq bd lk mh mi mj ln mk ml mm lq mn mo mp lt mq mr ms lw mt mu mv lz mw bi translated">逻辑回归(MNIST)</h1><p id="4d90" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">需要强调的一点是，sklearn 中包含的数字数据集太小，不能代表真实世界的机器学习任务。<br/>我们将使用 MNIST 数据集，因为它是为那些希望在真实世界数据上尝试学习技术和模式识别方法，同时在预处理和格式化方面花费最少精力的人准备的。我们将注意到的一件事是，参数调整可以大大加快机器学习算法的训练时间。</p><h2 id="3038" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">下载数据(MNIST)</h2><p id="42e4" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">MNIST 数据集并非来自 scikit-learn 内部</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="acad" class="li lj iq my b gy nc nd l ne nf">from sklearn.datasets import fetch_mldata<br/>mnist = fetch_mldata('MNIST original')</span></pre><p id="64ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在您已经加载了数据集，您可以使用下面的命令</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="a02a" class="li lj iq my b gy nc nd l ne nf"># These are the images<br/># There are 70,000 images (28 by 28 images for a dimensionality of 784)<br/>print(mnist.data.shape)</span><span id="5078" class="li lj iq my b gy ng nd l ne nf"># These are the labels<br/>print(mnist.target.shape)</span></pre><p id="8d22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要查看数据集中有 70000 张图像和 70000 个标签</p><h2 id="d04d" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">将数据分成训练集和测试集(MNIST)</h2><p id="53ea" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">下面的代码执行了一次<a class="ae lh" rel="noopener" target="_blank" href="/understanding-train-test-split-scikit-learn-python-ea676d5e3d1">列车测试分割</a>。<code class="fe nl nm nn my b">test_size=1/7.0</code>使训练集大小为 60，000 幅图像，测试集大小为 10，000 幅图像。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="12f7" class="li lj iq my b gy nc nd l ne nf">from sklearn.model_selection import train_test_split</span><span id="53e2" class="li lj iq my b gy ng nd l ne nf">train_img, test_img, train_lbl, test_lbl = train_test_split(<br/> mnist.data, mnist.target, test_size=1/7.0, random_state=0)</span></pre><h2 id="c7fe" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">显示图像和标签(MNIST)</h2><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="0e1c" class="li lj iq my b gy nc nd l ne nf">import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="431d" class="li lj iq my b gy ng nd l ne nf">plt.figure(figsize=(20,4))<br/>for index, (image, label) in enumerate(zip(train_img[0:5], train_lbl[0:5])):<br/> plt.subplot(1, 5, index + 1)<br/> plt.imshow(np.reshape(image, (28,28)), cmap=plt.cm.gray)<br/> plt.title('Training: %i\n' % label, fontsize = 20)</span></pre><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/63a3a528689afd71ace95280121c3326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1TkgO9Zz6rC3KpAYNl5KfA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Visualizing the Images and Labels in our Dataset</figcaption></figure><h2 id="20db" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">sci kit-学习 4 步建模模式(MNIST)</h2><p id="0e4d" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">我想提到的一点是参数调整的重要性。虽然对于较小的数字数据集来说，这可能没什么关系，但对于较大和更复杂的数据集来说，这就有很大的不同了。虽然通常是为了精确而调整参数，但在下面的例子中，我们调整了参数求解器以加速模型的拟合。</p><p id="481e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一步。导入您想要使用的模型</p><p id="7c77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 sklearn 中，所有的机器学习模型都是作为 Python 类实现的</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="f9cc" class="li lj iq my b gy nc nd l ne nf">from sklearn.linear_model import LogisticRegression</span></pre><p id="6ac1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二步。制作模型的一个实例</p><p id="bc5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想知道变化求解器是做什么的，请看这个<a class="ae lh" href="https://medium.com/distributed-computing-with-ray/how-to-speed-up-scikit-learn-model-training-aaf17e2d1e1" rel="noopener">教程</a>。本质上，我们正在改变优化算法。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="7ec5" class="li lj iq my b gy nc nd l ne nf"># all parameters not specified are set to their defaults<br/># default solver is incredibly slow thats why we change it<br/>logisticRegr = LogisticRegression(solver = 'lbfgs')</span></pre><p id="2709" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第三步。根据数据训练模型，存储从数据中学习到的信息</p><p id="9c9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模型正在学习 x(数字)和 y(标签)之间的关系</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="8ccb" class="li lj iq my b gy nc nd l ne nf">logisticRegr.fit(train_img, train_lbl)</span></pre><p id="8ae3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第四步。预测新数据(新图像)的标签<br/>使用模型在模型训练过程中学习到的信息</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="a0e4" class="li lj iq my b gy nc nd l ne nf"># Returns a NumPy Array<br/># Predict for One Observation (image)<br/>logisticRegr.predict(test_img[0].reshape(1,-1))</span></pre><p id="5342" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一次预测多个观察结果(图像)</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="bdde" class="li lj iq my b gy nc nd l ne nf">logisticRegr.predict(test_img[0:10])</span></pre><p id="4e81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对整个测试数据进行预测</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="77de" class="li lj iq my b gy nc nd l ne nf">predictions = logisticRegr.predict(test_img)</span></pre><h2 id="5752" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">衡量模型性能(MNIST)</h2><p id="47ce" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">虽然有其他方法来衡量模型性能(精确度、召回率、F1 分数、<a class="ae lh" rel="noopener" target="_blank" href="/receiver-operating-characteristic-curves-demystified-in-python-bd531a4364d0"> ROC 曲线</a>等)，但我们将保持简单，使用精确度作为我们的衡量标准。<br/>为此，我们将观察模型在新数据(测试集)上的表现</p><p id="99bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">精确度定义为:</p><p id="7fc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(正确预测的分数):正确预测/数据点总数</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="7a3c" class="li lj iq my b gy nc nd l ne nf">score = logisticRegr.score(test_img, test_lbl)<br/>print(score)</span></pre><p id="2dbb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想简单提一下的一件事是，默认的优化算法参数是<code class="fe nl nm nn my b">solver = liblinear</code>，它花了 2893.1 秒运行，准确率为 91.45%。我设置<code class="fe nl nm nn my b">solver = lbfgs</code>的时候，用了 52.86 秒运行，准确率 91.3%。改变求解器对精确度有一个小的影响，但至少它快了很多。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/25bb3cf8e7c92e753c2f8368baf920dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/1*XVFmo9NxLnwDr3SxzKy-rA.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Depending on the problem, <a class="ae lh" href="https://www.anyscale.com/blog/how-to-speed-up-scikit-learn-model-training" rel="noopener ugc nofollow" target="_blank">some optimization algorithms can take longer</a> (<a class="ae lh" href="https://www.datasciencecentral.com/profiles/blogs/an-overview-of-gradient-descent-optimization-algorithms" rel="noopener ugc nofollow" target="_blank">image source</a>)</figcaption></figure><h2 id="903f" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">显示带有预测标签的错误分类图像(MNIST)</h2><p id="47fb" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">虽然我可以展示另一个混淆矩阵，但我认为人们宁愿看到错误分类的图片，也不希望有人觉得有趣。</p><p id="a907" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">获取错误分类图像的索引</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="c52a" class="li lj iq my b gy nc nd l ne nf">import numpy as np <br/>import matplotlib.pyplot as plt</span><span id="a4b9" class="li lj iq my b gy ng nd l ne nf">index = 0<br/>misclassifiedIndexes = []<br/>for label, predict in zip(test_lbl, predictions):<br/> if label != predict: <br/>  misclassifiedIndexes.append(index)<br/>  index +=1</span></pre><p id="b19a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用 matplotlib 显示错误分类的图像和图像标签</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="c487" class="li lj iq my b gy nc nd l ne nf">plt.figure(figsize=(20,4))<br/>for plotIndex, badIndex in enumerate(misclassifiedIndexes[0:5]):<br/> plt.subplot(1, 5, plotIndex + 1)<br/> plt.imshow(np.reshape(test_img[badIndex], (28,28)), cmap=plt.cm.gray)<br/> plt.title(‘Predicted: {}, Actual: {}’.format(predictions[badIndex], test_lbl[badIndex]), fontsize = 15)</span></pre><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e428131bb2ed91694b26d58cfe475665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oq3buG2nTrpmbcgzelMnkg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Showing Misclassified Digits</figcaption></figure><h2 id="cba6" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">结束语</h2><p id="5b80" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">这里需要注意的重要一点是，在 scikit-learn 中制作一个机器学习模型并不需要很多工作。我希望这篇文章对你正在做的事情有所帮助。我的下一个机器学习教程使用 Python 复习了<a class="ae lh" href="https://medium.com/@GalarnykMichael/pca-using-python-scikit-learn-e653f8989e60" rel="noopener"> PCA。如果你对本教程有任何问题或想法，欢迎在下面的评论中，通过</a><a class="ae lh" href="https://www.youtube.com/watch?v=71iXeuKFcQM" rel="noopener ugc nofollow" target="_blank"> YouTube 视频页面</a>，或通过<a class="ae lh" href="https://twitter.com/GalarnykMichael" rel="noopener ugc nofollow" target="_blank"> Twitter </a>联系我们！如果想学习其他机器学习算法，请考虑上我的<a class="ae lh" href="https://www.linkedin.com/learning/machine-learning-with-scikit-learn/effective-machine-learning-with-scikit-learn" rel="noopener ugc nofollow" target="_blank">机器学习 with Scikit-Learn LinkedIn 学习课程</a>。</p></div></div>    
</body>
</html>