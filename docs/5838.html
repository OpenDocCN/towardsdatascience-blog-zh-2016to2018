<html>
<head>
<title>Data Wrangling With Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与熊猫的数据争论</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-wrangling-with-pandas-5b0be151df4e?source=collection_archive---------3-----------------------#2018-11-12">https://towardsdatascience.com/data-wrangling-with-pandas-5b0be151df4e?source=collection_archive---------3-----------------------#2018-11-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/43a781b83b044fdda6ba966eac14c981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q02XGyfFbDkG67EC"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">“panda eating bamboo” by <a class="ae kc" href="https://unsplash.com/@jaywennington?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jay Wennington</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4788" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">互联网的巨大资源使我进入数据科学的旅程成为可能。《T2 数据科学杂志》将它定义为几乎所有与数据有关的事物。在工作中，这意味着使用数据通过增加价值对组织产生影响。最常见的是使用和应用数据来解决复杂的业务问题。数据科学工作中最常见的步骤之一是数据争论。以下是如何使用<a class="ae kc" href="https://pandas.pydata.org/pandas-docs/stable/" rel="noopener ugc nofollow" target="_blank">熊猫</a>库在 python 中探索、操作和重塑数据的简明指南。</p><p id="79e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将探索一个乳腺癌数据集(鸣谢:<a class="ae kc" href="https://archive.ics.uci.edu/ml/datasets/breast+cancer+wisconsin+(original)" rel="noopener ugc nofollow" target="_blank"> UCI </a>)，并使用熊猫来清理、重塑、按摩并给我们一个干净的数据集，所有这些都将有助于大幅提高我们数据的质量。<strong class="kf ir">注:</strong>数据质量是机器学习算法实现最佳性能的<strong class="kf ir">关键</strong>。</p><blockquote class="lk ll lm"><p id="0bc5" class="kd ke ln kf b kg kh ki kj kk kl km kn lo kp kq kr lp kt ku kv lq kx ky kz la ij bi translated">如果你想继续下去，看看<a class="ae kc" href="https://github.com/moeraza/pandas_data_wrangling" rel="noopener ugc nofollow" target="_blank"> GitHub </a> repo 页面，尝试使用<a class="ae kc" href="https://github.com/moeraza/pandas_data_wrangling/blob/master/data/breast_cancer_data.csv" rel="noopener ugc nofollow" target="_blank">数据集</a>和<a class="ae kc" href="https://github.com/moeraza/pandas_data_wrangling/blob/master/dataWranglingWithPandas.ipynb" rel="noopener ugc nofollow" target="_blank"> python 代码</a>进行实验。</p></blockquote></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><p id="dd0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将涵盖以下熊猫功能:</p><ol class=""><li id="c602" class="ly lz iq kf b kg kh kk kl ko ma ks mb kw mc la md me mf mg bi translated"><strong class="kf ir">数据浏览</strong> —列、列中的唯一值、描述、重复</li><li id="7c15" class="ly lz iq kf b kg mh kk mi ko mj ks mk kw ml la md me mf mg bi translated"><strong class="kf ir">处理缺失值</strong> —量化每列缺失值，填充&amp;丢弃缺失值</li><li id="68bb" class="ly lz iq kf b kg mh kk mi ko mj ks mk kw ml la md me mf mg bi translated"><strong class="kf ir">重塑数据</strong> —一次热编码、数据透视表、连接、分组和聚合</li><li id="e45c" class="ly lz iq kf b kg mh kk mi ko mj ks mk kw ml la md me mf mg bi translated"><strong class="kf ir">过滤数据</strong></li><li id="946e" class="ly lz iq kf b kg mh kk mi ko mj ks mk kw ml la md me mf mg bi translated"><strong class="kf ir">其他</strong>——制作描述性列，基于元素的条件运算</li></ol></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h2 id="cfa4" class="mm mn iq bd mo mp mq dn mr ms mt dp mu ko mv mw mx ks my mz na kw nb nc nd ne bi translated"><strong class="ak">数据探索</strong></h2><p id="2217" class="pw-post-body-paragraph kd ke iq kf b kg nf ki kj kk ng km kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">让我们首先将数据集(csv 文件)读入 pandas，并显示列名及其数据类型。还需要花点时间来查看整个数据集。</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="1a8f" class="mm mn iq np b gy nt nu l nv nw">import pandas as pd</span><span id="9138" class="mm mn iq np b gy nx nu l nv nw">filename = 'data/breast_cancer_data.csv'<br/>df = pd.read_csv(filename)<br/>df.dtypes</span><span id="c51d" class="mm mn iq np b gy nx nu l nv nw">patient_id                 int64<br/>clump_thickness          float64<br/>cell_size_uniformity     float64<br/>cell_shape_uniformity      int64<br/>marginal_adhesion          int64<br/>single_ep_cell_size        int64<br/>bare_nuclei               object<br/>bland_chromatin          float64<br/>normal_nucleoli          float64<br/>mitoses                    int64<br/>class                     object<br/>doctor_name               object<br/>dtype: object</span></pre><p id="4e9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在数据中，我们有以下由<a class="ae kc" href="https://archive.ics.uci.edu/ml/datasets/breast+cancer+wisconsin+(original)" rel="noopener ugc nofollow" target="_blank">源</a>描述的列—患者 ID: <em class="ln"> id 号</em>，团块厚度:<em class="ln">1–10</em>，细胞大小均匀度:<em class="ln">1–10</em>，细胞形状均匀度:<em class="ln">1–10</em>，边缘粘附:<em class="ln">1–10</em>，单个上皮细胞大小:<em class="ln">1–10</em>，裸细胞核:<em class="ln"/></p><p id="51ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基于此，我们可以假设<code class="fe ny nz oa np b">patient_id</code>是一个唯一的标识符，<code class="fe ny nz oa np b">class</code>将告诉我们肿瘤是恶性的(癌变的)还是良性的(非癌变的)。除了作为分类特征的<code class="fe ny nz oa np b">doctor_name</code>之外，其余列是肿瘤的数字医学描述。</p><blockquote class="lk ll lm"><p id="306a" class="kd ke ln kf b kg kh ki kj kk kl km kn lo kp kq kr lp kt ku kv lq kx ky kz la ij bi translated">要记住的事情——如果我们的目标是根据剩余的特征来预测肿瘤是否是癌性的，我们将不得不对分类数据进行编码，并清理数字数据。</p></blockquote><p id="793c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从我们的第一个输出中，我们看到<code class="fe ny nz oa np b">bare_nuclei</code>被读取为<code class="fe ny nz oa np b">object</code>数据类型，尽管描述是数字的。因此，我们需要改变这一点。</p><p id="ea8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了验证我们的数据与源匹配，我们可以使用 pandas 中的描述选项:</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="f424" class="mm mn iq np b gy nt nu l nv nw">df.describe()</span></pre><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/de4921cc5385313c6d68d81ac68f11bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rDksQ773LakfyU5l0j2q4g.png"/></div></div></figure><p id="82c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这简洁地总结了所有数字列的一些统计数据。似乎所有的。对于分类数据，我们可以通过<a class="ae kc" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.groupby.html" rel="noopener ugc nofollow" target="_blank">将</a>的值组合在一起:</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="6c3e" class="mm mn iq np b gy nt nu l nv nw">df.groupby(by =[‘class’, ‘doctor_name’]).size()</span></pre><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/b9f71d3c55f2b213ed7511d2b0facc87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PahxdYthukmdOppX8-OCeQ.png"/></div></div></figure><h2 id="6d9e" class="mm mn iq bd mo mp mq dn mr ms mt dp mu ko mv mw mx ks my mz na kw nb nc nd ne bi translated"><strong class="ak">处理缺失值</strong></h2><p id="095e" class="pw-post-body-paragraph kd ke iq kf b kg nf ki kj kk ng km kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">对于每个数据集，评估缺失值至关重要。有多少？是错误吗？缺少的值太多了吗？缺失的值相对于其上下文有意义吗？</p><p id="9f94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用以下公式来合计总缺失值:</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="cced" class="mm mn iq np b gy nt nu l nv nw">df.isna().sum()</span></pre><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/f5d1e10e28410b5782fa269efba424b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLHzNR0WEY61s9sMgwFNpA.png"/></div></div></figure><p id="0921" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们已经确定了我们缺少的价值，我们有几个选择。我们可以用某个值(零、平均值/最大值/按列中值、字符串)填充它们，或者按行删除它们。由于几乎没有丢失的值，我们可以<a class="ae kc" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.dropna.html" rel="noopener ugc nofollow" target="_blank">删除</a>这些行，以避免在进一步的分析中扭曲数据。</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="acf8" class="mm mn iq np b gy nt nu l nv nw">df = df.dropna(axis = 0, how = 'any')</span></pre><p id="533e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这允许我们删除<strong class="kf ir">行</strong>和<strong class="kf ir">行中的任何</strong>缺失值。</p><h2 id="8694" class="mm mn iq bd mo mp mq dn mr ms mt dp mu ko mv mw mx ks my mz na kw nb nc nd ne bi translated"><strong class="ak">检查副本</strong></h2><p id="773b" class="pw-post-body-paragraph kd ke iq kf b kg nf ki kj kk ng km kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">要查看重复行，我们可以从查看每列中唯一值的数量开始。</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="7af0" class="mm mn iq np b gy nt nu l nv nw">df.nunique()</span></pre><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/90b8b5f469e605b6f8ad59d437d953ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NTJIuToAea30S1ns5xMYPw.png"/></div></div></figure><p id="d4d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在这里看到，虽然有 699 行，但只有 645 个唯一的 patient_id。这可能意味着一些患者在数据集中出现不止一次。为了隔离这些患者并查看他们的数据，我们使用后面的<a class="ae kc" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.duplicated.html" rel="noopener ugc nofollow" target="_blank">:</a></p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="c876" class="mm mn iq np b gy nt nu l nv nw">df[df.duplicated(subset = 'patient_id', keep =False)].sort_values('patient_id')</span></pre><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/a2eaf48ad657972dcfd239c883e0cb69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ypkd8k7CIYD5otxMDMNQMg.png"/></div></div></figure><p id="bd1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该行按顺序显示所有重复的患者编号。还可以查看患者在数据集中出现的次数。</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="67f8" class="mm mn iq np b gy nt nu l nv nw">repeat_patients = df.groupby(by = 'patient_id').size().sort_values(ascending =False)</span></pre><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/1062723735b3b01f3f7ff26eb29d338b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tR2GhcYwFJSxTy0l-yK0_w.png"/></div></div></figure><p id="1ee2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这表明一个患者在数据中出现了 6 次！</p><h2 id="79b3" class="mm mn iq bd mo mp mq dn mr ms mt dp mu ko mv mw mx ks my mz na kw nb nc nd ne bi translated">过滤数据</h2><p id="6a73" class="pw-post-body-paragraph kd ke iq kf b kg nf ki kj kk ng km kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">如果我们想删除在数据集中出现 2 次以上的患者。</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="480f" class="mm mn iq np b gy nt nu l nv nw">filtered_patients = repeat_patients[repeat_patients &gt; 2].to_frame().reset_index()</span><span id="b25c" class="mm mn iq np b gy nx nu l nv nw">filtered_df = df[~df.patient_id.isin(filtered_patients.patient_id)]</span></pre><p id="5282" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们没有波浪号(“~”)，我们将得到重复两次以上的所有个体。通过添加波浪符，熊猫布尔序列被反转，因此得到的数据帧是那些不重复超过两次的数据帧。</p><h2 id="a1e7" class="mm mn iq bd mo mp mq dn mr ms mt dp mu ko mv mw mx ks my mz na kw nb nc nd ne bi translated">重塑数据</h2><p id="065f" class="pw-post-body-paragraph kd ke iq kf b kg nf ki kj kk ng km kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">数据集在“doctor_name”列中有分类数据的元素。为了将这些数据输入到机器学习管道中，我们需要将其转换为一个 hot 编码列。这可以通过一个<a class="ae kc" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html" rel="noopener ugc nofollow" target="_blank">科学工具包学习包</a>来完成，但是我们将在熊猫身上做，以演示<a class="ae kc" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.pivot_table.html" rel="noopener ugc nofollow" target="_blank">旋转</a>和<a class="ae kc" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.merge.html" rel="noopener ugc nofollow" target="_blank">合并</a>功能。首先用分类数据创建一个新的数据框架。</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="ff43" class="mm mn iq np b gy nt nu l nv nw">categorical_df = df[['patient_id','doctor_name']]<br/>categorical_df['doctor_count'] = 1 </span></pre><p id="e740" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们增加了一列，一个额外的列，用来识别病人与哪个医生联系。旋转该表，使单元格中只有数值，列成为医生的姓名。然后<a class="ae kc" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.fillna.html" rel="noopener ugc nofollow" target="_blank">用 0 填充空单元格中的</a>。</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="44f7" class="mm mn iq np b gy nt nu l nv nw">doctors_one_hot_encoded = pd.pivot_table( categorical_df,<br/>                                  index = categorical_df.index, <br/>                                  columns = ['doctor_name'], <br/>                                   values = ['doctor_count'] )</span><span id="829e" class="mm mn iq np b gy nx nu l nv nw">doctors_one_hot_encoded = doctors_one_hot_encoded.fillna(0)</span></pre><p id="cc28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后删除多索引列:</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="12f3" class="mm mn iq np b gy nt nu l nv nw">doctors_one_hot_encoded.columns = doctors_one_hot_encoded.columns.droplevel()</span></pre><p id="eff2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“doctors_one_hot_encoded”数据帧如下所示。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/a9afcce2a4dea7297355056a33b765bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vu8KDc_up9qPdjhNHa5a3g.png"/></div></div></figure><p id="147b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以将它重新加入我们的主牌桌。熊猫的左连接通常是这样的:</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="0d36" class="mm mn iq np b gy nt nu l nv nw">leftJoin_df = pd.merge(df1, df2, on ='col_name', how='left')</span></pre><p id="a680" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们是在索引上连接，所以我们传递“left_index”和“right_index”选项来指定连接键是两个表的索引</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="d07a" class="mm mn iq np b gy nt nu l nv nw">combined_df = pd.merge(df, one_hot_encoded, left_index = True,right_index =True, how =’left’)</span></pre><p id="508b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">生成的左连接如下所示。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/602f495b0776818eff3e4b25f22d43b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*71n1Z7P49yoZkt-iwvYoVg.png"/></div></div></figure><p id="10db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过下面的方法<a class="ae kc" href="https://pandas.pydata.org/pandas-docs/version/0.21/generated/pandas.DataFrame.drop.html" rel="noopener ugc nofollow" target="_blank">删除</a>不再需要的列</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="3db4" class="mm mn iq np b gy nt nu l nv nw">combined_df = combined_df.drop(columns=['doctor_name']</span></pre><h2 id="6446" class="mm mn iq bd mo mp mq dn mr ms mt dp mu ko mv mw mx ks my mz na kw nb nc nd ne bi translated">逐行操作</h2><p id="554c" class="pw-post-body-paragraph kd ke iq kf b kg nf ki kj kk ng km kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">数据争论的另一个关键部分是能够进行行或列操作。这方面的例子有:根据列的值重命名列中的元素，并创建一个新列，该列根据行中的多个属性生成特定的值。</p><p id="0874" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本例中，我们创建一个新列，根据属性将患者单元分类为正常或异常。我们首先定义我们的功能以及它将执行的操作。</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="aa54" class="mm mn iq np b gy nt nu l nv nw">def celltypelabel(x):</span><span id="f8ee" class="mm mn iq np b gy nx nu l nv nw">    if ((x['cell_size_uniformity'] &gt; 5) &amp;      (x['cell_shape_uniformity'] &gt; 5)):<br/>        <br/>        return('normal')</span><span id="d7c8" class="mm mn iq np b gy nx nu l nv nw">    else:<br/>        return('abnormal')</span></pre><p id="f2b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们使用 pandas <a class="ae kc" href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.apply.html" rel="noopener ugc nofollow" target="_blank"> apply </a>函数在数据帧上运行 celltypelabel(x)函数。</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="f5f4" class="mm mn iq np b gy nt nu l nv nw">combined_df['cell_type_label'] = combined_df.apply(lambda x: celltypelabel(x), axis=1)</span></pre></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h2 id="2008" class="mm mn iq bd mo mp mq dn mr ms mt dp mu ko mv mw mx ks my mz na kw nb nc nd ne bi translated">结论</h2><p id="fde4" class="pw-post-body-paragraph kd ke iq kf b kg nf ki kj kk ng km kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">虽然其中一些数据操作步骤可以在 SAS 和 excel 中完成。用 python 来做不仅可以让你将数据连接到计算机视觉、机器和深度学习中的大量开源资源，还可以用于 ETL 自动化目的等等。</p><p id="9c36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的阅读。</p><p id="1e24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">穆罕默德·拉扎</p><p id="39c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">邮箱:raza@datalchemy.ai</p></div></div>    
</body>
</html>