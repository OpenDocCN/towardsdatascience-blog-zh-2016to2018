<html>
<head>
<title>Flocking with Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">蜂拥而至</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/flocking-with-go-2dcf6fcab144?source=collection_archive---------6-----------------------#2018-01-14">https://towardsdatascience.com/flocking-with-go-2dcf6fcab144?source=collection_archive---------6-----------------------#2018-01-14</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="afec" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">如何使用Go在你的终端上创建一个群集模拟</h2></div><p id="fcc3" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我写植绒模拟已经很久了。我用Java尝试过，但我仍有记录的最早版本是用JRuby和Swing开发的，名为<a class="ae lf" href="https://youtu.be/x44s8TTWm5E" rel="noopener ugc nofollow" target="_blank"> Utopia </a>。我用<a class="ae lf" href="http://shoesrb.com/" rel="noopener ugc nofollow" target="_blank">鞋</a>写了一个，那是我的<a class="ae lf" href="http://shop.oreilly.com/product/0636920022626.do" rel="noopener ugc nofollow" target="_blank"> <em class="lg">用R和Ruby </em> </a>探索日常事物书中的那个。过了一段时间，(总体来说，我对鞋子不太满意)，我用2D的一个Ruby和C++游戏开发库<a class="ae lf" href="https://github.com/gosu/gosu" rel="noopener ugc nofollow" target="_blank"> Gosu </a>重新写了一遍。这个版本可以在<a class="ae lf" href="https://github.com/sausheong/utopia" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="6106" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><a class="ae lf" href="https://en.wikipedia.org/wiki/Flocking_(behavior)" rel="noopener ugc nofollow" target="_blank">群集</a>模拟基本上是一个模拟鸟类群集行为的软件程序。这种群集行为与昆虫的群集行为或鱼类的群集行为非常相似。这被认为是一种紧急行为——一种源于个体遵循简单规则的行为，不涉及任何中央协调。这种行为，尤其是在椋鸟或成群梭鱼的低语中看到的，可能是一种令人惊叹的现象。</p><figure class="li lj lk ll gu lm gi gj paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gi gj lh"><img src="../Images/d51a06d50f3b526ae765b326108afce1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LRy__B0eXHzbzIz6zlvdXQ.jpeg"/></div></div><figcaption class="lt lu gk gi gj lv lw bd b be z dk">Photo by <a class="ae lf" href="https://unsplash.com/@tumbao1949?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">James Wainscoat</a> on <a class="ae lf" href="https://unsplash.com/s/photos/flock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="43a0" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">Boids</h1><p id="51e5" class="pw-post-body-paragraph kj kk iu kl b km mp jv ko kp mq jy kr ks mr ku kv kw ms ky kz la mt lc ld le in bi translated">群集最早是由程序员Craig Reynolds用软件模拟的，他开发了一个名为<a class="ae lf" href="http://www.red3d.com/cwr/boids/" rel="noopener ugc nofollow" target="_blank"> <em class="lg"> boids </em> </a>的软件程序，并于1987年在ACM SIGGRAPH conference上发表了一篇关于该主题的论文。从那以后，在模拟群集方面有了很多进步，但是基本思想仍然很简单。</p><p id="d692" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">Boids本身使用三个基本规则来描述单个boid如何移动:</p><ul class=""><li id="de31" class="mu mv iu kl b km kn kp kq ks mw kw mx la my le mz na nb nc bi translated"><em class="lg">分离</em>——避免拥挤附近的其他蜂群</li><li id="94d9" class="mu mv iu kl b km nd kp ne ks nf kw ng la nh le mz na nb nc bi translated"><em class="lg">对齐</em>——向附近队友的平均方向移动</li><li id="cba1" class="mu mv iu kl b km nd kp ne ks nf kw ng la nh le mz na nb nc bi translated"><em class="lg">凝聚力</em>——向附近队友的平均位置移动</li></ul><figure class="li lj lk ll gu lm gi gj paragraph-image"><div class="gi gj ni"><img src="../Images/7432595ee69fc4562b700224bd16917e.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/0*LIMTrKhzQYhRZ600.gif"/></div></figure><figure class="li lj lk ll gu lm gi gj paragraph-image"><div class="gi gj ni"><img src="../Images/a848bcde220b50d9cc2ba9c9819b5697.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/0*IY_5DIFbQHHmtA-f.gif"/></div></figure><figure class="li lj lk ll gu lm gi gj paragraph-image"><div class="gi gj ni"><img src="../Images/10083767d9454a844ea7901fba05ebcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/0*zfCjrO6FHAR0EkkV.gif"/></div></figure><p id="d87d" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这些规则得到了扩展，在某些情况下，添加了更多的规则，但基本思想是，个人遵循一些简单规则的局部反应可能会导致复杂的、意想不到的行为。</p><h1 id="71ba" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">在围棋中做</h1><p id="fc0e" class="pw-post-body-paragraph kj kk iu kl b km mp jv ko kp mq jy kr ks mr ku kv kw ms ky kz la mt lc ld le in bi translated">虽然我已经认真地用Go编程几年了(它现在是我的主要编程语言)，但我一直没有找到用Go编写群集模拟的好方法。最大的问题是，Go主要是一种后端编程语言，并没有真正的GUI工具包。虽然有一些尝试，包括绑定到GTK和QT，但没有一个符合我的要求。如果你正在寻找一个桌面应用程序，你可能会更好地使用<a class="ae lf" href="https://github.com/electron/electron" rel="noopener ugc nofollow" target="_blank"> Electron </a>并在Go中构建一个web应用程序来支持它。</p><p id="38f7" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">也就是说，直到我在我的帖子<a class="ae lf" rel="noopener" target="_blank" href="/a-gentle-introduction-to-genetic-algorithms-c5bc15827e2d"><em class="lg"/></a>中摆弄遗传算法。在那篇文章中，我试图向终端显示一个图像，在我的例子中，是优秀的<a class="ae lf" href="https://www.iterm2.com/" rel="noopener ugc nofollow" target="_blank"> iTerm2 </a>。这就是我在iTerm2上偶然发现这个允许我在屏幕上显示图像的黑客的地方。</p><p id="6280" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">当然，如果我可以显示一个图像，我就可以显示多个图像。如果我可以显示多幅图像，我也可以将它们一幅接一幅地重叠显示。如果我能足够快地展示它们…</p><figure class="li lj lk ll gu lm"><div class="bz fq l di"><div class="nj nk l"/></div><figcaption class="lt lu gk gi gj lv lw bd b be z dk">How to make a flip book (credits: Andymation <a class="ae lf" href="https://www.youtube.com/watch?v=Un-BdBSOGKY" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=Un-BdBSOGKY</a>)</figcaption></figure><h1 id="6300" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">黄金</h1><p id="4e31" class="pw-post-body-paragraph kj kk iu kl b km mp jv ko kp mq jy kr ks mr ku kv kw ms ky kz la mt lc ld le in bi translated">当然，我称它们为黄金。一个<code class="fe nl nm nn no b">Goid</code>是一个简单的结构，带有位置、速度和颜色的信息。</p><pre class="li lj lk ll gu np no nq nr aw ns bi"><span id="c592" class="nt ly iu no b gz nu nv l nw nx">type Goid struct {<br/>	X     int // position<br/>	Y     int<br/>	Vx    int // velocity<br/>	Vy    int<br/>	R     int // radius<br/>	Color color.Color<br/>}</span></pre><p id="2ee8" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">位置和颜色很容易理解。这里的速度不仅仅是金子移动的速度，也是它移动的方向。在这种情况下，<code class="fe nl nm nn no b">Vx</code>和<code class="fe nl nm nn no b">Vy</code>是高尔夫球在下一个循环中将要离开的距离，也是它将要去的方向。从数学上来说，<code class="fe nl nm nn no b">X</code>和<code class="fe nl nm nn no b">Y</code>是<em class="lg">标量</em>位置(它告诉你在2D平面上离原点有多远)，而<code class="fe nl nm nn no b">Vx</code>和<code class="fe nl nm nn no b">Vy</code>是<a class="ae lf" href="http://mathinsight.org/vector_introduction" rel="noopener ugc nofollow" target="_blank"> <em class="lg">矢量</em> </a>。</p><p id="d7f2" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">创建goids相对简单。每个goid必须在窗口内，并且它的起始速度小于它的大小。</p><pre class="li lj lk ll gu np no nq nr aw ns bi"><span id="50f2" class="nt ly iu no b gz nu nv l nw nx">func createRandomGoid() (g Goid) {<br/>	g = Goid{<br/>		X:     rand.Intn(windowWidth),<br/>		Y:     rand.Intn(windowHeight),<br/>		Vx:    rand.Intn(goidSize),<br/>		Vy:    rand.Intn(goidSize),<br/>		R:     goidSize,<br/>		Color: goidColor,<br/>	}<br/>	return<br/>}</span></pre><p id="d9de" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">大部分工作都在<code class="fe nl nm nn no b">move</code>函数中。</p><pre class="li lj lk ll gu np no nq nr aw ns bi"><span id="b18d" class="nt ly iu no b gz nu nv l nw nx">// move the goids with the 3 classic boid rules<br/>func move(goids []*Goid) {<br/>	for _, goid := range goids {<br/>		neighbours := goid.nearestNeighbours(goids)<br/>		separate(goid, neighbours)		<br/>		align(goid, neighbours)<br/>        cohere(goid, neighbours)</span><span id="f40c" class="nt ly iu no b gz ny nv l nw nx">		stayInWindow(goid)<br/>	}<br/>}</span></pre><p id="3c45" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">自30年前以来，群集模拟已经有了相当大的进步，但是对于这个简单的模拟，我使用了boids的3个经典规则。这三条规则都要求goid知道谁是它的邻居，所以首先弄清楚这一点是有意义的。</p><pre class="li lj lk ll gu np no nq nr aw ns bi"><span id="af58" class="nt ly iu no b gz nu nv l nw nx">// find the nearest neighbours<br/>func (g *Goid) nearestNeighbours(goids []*Goid) (neighbours []Goid) {<br/>	neighbours = make([]Goid, len(goids))<br/>	for _, goid := range goids {<br/>		neighbours = append(neighbours, *goid)<br/>	}<br/>	sort.SliceStable(neighbours, func(i, j int) bool {<br/>		return g.distance(neighbours[i]) &lt; g.distance(neighbours[j])<br/>	})<br/>	return<br/>}</span><span id="05f2" class="nt ly iu no b gz ny nv l nw nx">// distance between 2 goids<br/>func (g *Goid) distance(n Goid) float64 {<br/>	x := g.X - n.X<br/>	y := g.Y - n.Y<br/>	return math.Sqrt(float64(x*x + y*y))</span><span id="622b" class="nt ly iu no b gz ny nv l nw nx">}</span></pre><p id="8f73" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">首先，我们克隆整个goid群体，然后我们使用<code class="fe nl nm nn no b">sort.SliceStable</code>按照与所讨论的goid的距离对克隆的数组进行排序。找到距离只是一个使用毕达哥拉斯定理的问题。</p><figure class="li lj lk ll gu lm gi gj paragraph-image"><div class="gi gj nz"><img src="../Images/b718535377981a9319781c9dda617873.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*WTHCN_SkD-DdLNmm.png"/></div></figure><p id="b952" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这给了我们一个相邻高尔夫球的列表，按距离排序。让我们看看第一条规则。</p><h1 id="271d" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">分离规则</h1><p id="184f" class="pw-post-body-paragraph kj kk iu kl b km mp jv ko kp mq jy kr ks mr ku kv kw ms ky kz la mt lc ld le in bi translated">这就是<em class="lg">个人空间</em>法则。比方说，你和许多其他通勤者在一列火车上，它停在一个有许多人上车的车站。当他们进来的时候，他们会填满空间，会有一些人最终离你太近。你会怎么做？你会离开他们一点，但不会离其他人太近，最终会和其他人保持一个舒适的距离。这是规则。</p><pre class="li lj lk ll gu np no nq nr aw ns bi"><span id="1ae9" class="nt ly iu no b gz nu nv l nw nx">// steer to avoid crowding local goids<br/>func separate(g *Goid, neighbours []Goid) {<br/>	x, y := 0, 0<br/>	for _, n := range neighbours[0:numNeighbours] {<br/>		if g.distance(n) &lt; separationFactor {<br/>			x += g.X - n.X<br/>			y += g.Y - n.Y<br/>		}<br/>	}<br/>	g.Vx = x<br/>	g.Vy = y<br/>	g.X += x<br/>	g.Y += y<br/>}</span></pre><p id="bac3" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们只对有限数量的相邻goids感兴趣，这由参数<code class="fe nl nm nn no b">numNeighbours</code>指定。相邻的高尔夫球场也必须在参数<code class="fe nl nm nn no b">separationFactor</code>内(不是所有相邻的高尔夫球场都足够近，不会让人不舒服)。一旦这些金球进入那个空间，我们就远离它们。然后我们把速度更新到那个距离，然后用那个速度移动高尔夫球。</p><h1 id="69d2" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">对齐规则</h1><p id="19ac" class="pw-post-body-paragraph kj kk iu kl b km mp jv ko kp mq jy kr ks mr ku kv kw ms ky kz la mt lc ld le in bi translated">这就是<em class="lg">同辈压力</em>法则。同辈压力是同辈人对人们施加的直接影响，使他们改变行为以符合群体的要求。你可能对同辈压力很熟悉——当你看到你的邻居拥有闪亮的新4K电视或iPhone X时，你可能也会想给自己买一台。在我们的生活中，还有很多其他不需要进一步解释的同伴压力的例子，而这正是对齐规则。</p><pre class="li lj lk ll gu np no nq nr aw ns bi"><span id="6e3a" class="nt ly iu no b gz nu nv l nw nx">// steer towards the average heading of local goids<br/>func align(g *Goid, neighbours []Goid) {<br/>	x, y := 0, 0<br/>	for _, n := range neighbours[0:numNeighbours] {<br/>		x += n.Vx<br/>		y += n.Vy<br/>	}<br/>	dx, dy := x/numNeighbours, y/numNeighbours<br/>	g.Vx += dx<br/>	g.Vy += dy<br/>	g.X += dx<br/>	g.Y += dy<br/>}</span></pre><p id="befe" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">和以前一样，我们只对由<code class="fe nl nm nn no b">numNeighbours</code>指定的有限数量的相邻goids感兴趣。然而，这条规则并不影响高尔夫球的位置，而是改变高尔夫球的速度，我们将所有相邻高尔夫球的速度相加，然后除以相邻高尔夫球的数量。最终值会修改速度，而不是完全替换它，同时新值会修改goid的位置。</p><h1 id="39b8" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">内聚规则</h1><p id="df09" class="pw-post-body-paragraph kj kk iu kl b km mp jv ko kp mq jy kr ks mr ku kv kw ms ky kz la mt lc ld le in bi translated">这就是<em class="lg">方阵</em>法则。希腊方阵是一个矩形的、紧密排列的步兵编队，作为一个整体行进和战斗。这是古代战争中最有效和持久的军事编队之一。它的效力在于密不透风的盾牌和长矛组成的紧密队形，缓慢地向前推进，突破敌人的行列。罗马人后来采取了同样的想法，创建了三线罗马军团，用于征服已知世界。</p><pre class="li lj lk ll gu np no nq nr aw ns bi"><span id="cf23" class="nt ly iu no b gz nu nv l nw nx">// steer to move toward the average position of local goids<br/>func cohere(g *Goid, neighbours []Goid) {<br/>	x, y := 0, 0<br/>	for _, n := range neighbours[0:numNeighbours] {<br/>		x += n.X<br/>		y += n.Y<br/>	}<br/>	dx, dy := ((x/numNeighbours)-g.X)/coherenceFactor, ((y/numNeighbours)-g.Y)/coherenceFactor<br/>	g.Vx += dx<br/>	g.Vy += dy<br/>	g.X += dx<br/>	g.Y += dy<br/>}</span></pre><p id="c1a2" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">和其他规则一样，我们只对邻近的金子感兴趣。我们取所有这些邻居的平均位置(将所有邻居的位置相加，然后除以邻居的数量)，并从中减去goid的位置。然后将这个值除以一个<code class="fe nl nm nn no b">coherenceFactor</code>,这个值决定了goids希望与其邻居保持一致的程度。如果<code class="fe nl nm nn no b">coherenceFactor</code>太高，高尔夫球将不会移动，如果太低，高尔夫球将会彼此贴得太近，形成紧密结合的高尔夫球簇。</p><h1 id="697e" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">呆在视野之内</h1><p id="320f" class="pw-post-body-paragraph kj kk iu kl b km mp jv ko kp mq jy kr ks mr ku kv kw ms ky kz la mt lc ld le in bi translated">现在我们有了规则，我们可以运行模拟，但由于我们的视图仅限于参数<code class="fe nl nm nn no b">windowWidth</code>和<code class="fe nl nm nn no b">windowHeight</code>，一旦黄金离开屏幕，我们就再也看不到它了。也就是说过一段时间，就只是一个空屏幕了。为了防止这种情况发生，如果一个黄金离开了屏幕，我们会神奇地把它转移到窗口的另一边。</p><pre class="li lj lk ll gu np no nq nr aw ns bi"><span id="007d" class="nt ly iu no b gz nu nv l nw nx">// if goid goes out of the window frame it comes back on the other side<br/>func stayInWindow(goid *Goid) {<br/>	if goid.X &lt; 0 {<br/>		goid.X = windowWidth + goid.X<br/>	} else if goid.X &gt; windowWidth {<br/>		goid.X = windowWidth - goid.X<br/>	}<br/>	if goid.Y &lt; 0 {<br/>		goid.Y = windowHeight + goid.Y<br/>	} else if goid.Y &gt; windowHeight {<br/>		goid.Y = windowHeight - goid.Y<br/>	}<br/>}</span></pre><h1 id="2c1f" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">显示框架</h1><p id="ae5a" class="pw-post-body-paragraph kj kk iu kl b km mp jv ko kp mq jy kr ks mr ku kv kw ms ky kz la mt lc ld le in bi translated">拼图的最后一块是画出金子本身。</p><pre class="li lj lk ll gu np no nq nr aw ns bi"><span id="b547" class="nt ly iu no b gz nu nv l nw nx">// draw the goids<br/>func draw(goids []*Goid) *image.RGBA {<br/>	dest := image.NewRGBA(image.Rect(0, 0, windowWidth, windowHeight))<br/>	gc := draw2dimg.NewGraphicContext(dest)<br/>	for _, goid := range goids {<br/>		gc.SetFillColor(goid.Color)<br/>		gc.MoveTo(float64(goid.X), float64(goid.Y))<br/>		gc.ArcTo(float64(goid.X), float64(goid.Y), float64(goid.R), float64(goid.R), 0, -math.Pi*2)<br/>		gc.LineTo(float64(goid.X-goid.Vx), float64(goid.Y-goid.Vy))<br/>		gc.Close()<br/>		gc.Fill()<br/>	}<br/>	return dest<br/>}</span></pre><p id="ee73" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">每一帧都是宽<code class="fe nl nm nn no b">windowWidth</code>高<code class="fe nl nm nn no b">windowHeight</code>的图像。在这个框架中，我们将每个goid绘制为一个圆，然后我们绘制一条线来表示goid的尾巴。这条线与高尔夫球前进的方向相反，所以我们从高尔夫球的速度中减去它的位置。</p><h1 id="025e" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">显示模拟</h1><p id="e5ac" class="pw-post-body-paragraph kj kk iu kl b km mp jv ko kp mq jy kr ks mr ku kv kw ms ky kz la mt lc ld le in bi translated">我们现在已经有了所有需要的函数，所以让我们把它们放在<code class="fe nl nm nn no b">main</code>函数中。</p><pre class="li lj lk ll gu np no nq nr aw ns bi"><span id="d93e" class="nt ly iu no b gz nu nv l nw nx">func main() {<br/>	clearScreen()<br/>	hideCursor()</span><span id="b4e7" class="nt ly iu no b gz ny nv l nw nx">	goids := make([]*Goid, 0)<br/>	for i := 0; i &lt; populationSize; i++ {<br/>		g := createRandomGoid()<br/>		goids = append(goids, &amp;g)<br/>	}</span><span id="4640" class="nt ly iu no b gz ny nv l nw nx">	for i := 0; i &lt; loops; i++ {<br/>		move(goids)<br/>		frame := draw(goids)<br/>		printImage(frame.SubImage(frame.Rect))<br/>		fmt.Printf("\nLoop: %d", i)</span><span id="180e" class="nt ly iu no b gz ny nv l nw nx">	}<br/>	showCursor()<br/>}</span></pre><p id="5a0d" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">还有几个你以前没见过的功能。什么是<code class="fe nl nm nn no b">clearScreen</code>、<code class="fe nl nm nn no b">hideCursor</code>、<code class="fe nl nm nn no b">showCursor</code>、<code class="fe nl nm nn no b">printImage</code>？这些是实际显示模拟的函数。</p><p id="461e" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">再来看<code class="fe nl nm nn no b">clearScreen</code>、<code class="fe nl nm nn no b">hideCursor</code>和<code class="fe nl nm nn no b">showCursor</code>。</p><pre class="li lj lk ll gu np no nq nr aw ns bi"><span id="ffb1" class="nt ly iu no b gz nu nv l nw nx">func hideCursor() {<br/>	fmt.Print("\x1b[?25l")<br/>}</span><span id="0379" class="nt ly iu no b gz ny nv l nw nx">func showCursor() {<br/>	fmt.Print("\x1b[?25h\n")<br/>}</span><span id="6252" class="nt ly iu no b gz ny nv l nw nx">func clearScreen() {<br/>	fmt.Print("\x1b[2J")<br/>}</span></pre><p id="c449" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">那么我们用了哪些奇怪的转义序列呢？这些是<a class="ae lf" href="https://en.wikipedia.org/wiki/ANSI_escape_code" rel="noopener ugc nofollow" target="_blank"> ANSI转义序列</a>，用于控制文本终端上的各种选项。它们大多是过去的遗留物，但仍在iTerm2等终端仿真器中广泛实现。所有序列都以<code class="fe nl nm nn no b">ESC</code> (27或十六进制0x1B)开头，后面是提供控制选项的第二个字节。特别是，<code class="fe nl nm nn no b">ESC</code>后跟<code class="fe nl nm nn no b">[</code>表示下一个字节是控制序列引入器(CSI)，它是一组有用的序列。例如，<code class="fe nl nm nn no b">?25h</code>显示光标，<code class="fe nl nm nn no b">?25l</code>隐藏光标。您可能已经猜到了，<code class="fe nl nm nn no b">2J</code>清除整个屏幕并将光标移到屏幕的左上角。</p><p id="fd19" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">让我们看看如何将图像打印到屏幕上。</p><pre class="li lj lk ll gu np no nq nr aw ns bi"><span id="1eae" class="nt ly iu no b gz nu nv l nw nx">// this only works for iTerm!<br/>func printImage(img image.Image) {<br/>	var buf bytes.Buffer<br/>	png.Encode(&amp;buf, img)<br/>	imgBase64Str := base64.StdEncoding.EncodeToString(buf.Bytes())<br/>	fmt.Printf("\x1b[2;0H\x1b]1337;File=inline=1:%s\a", imgBase64Str)<br/>}</span></pre><p id="2725" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这是一个有趣的黑客行为，只在<a class="ae lf" href="https://www.iterm2.com/documentation-images.html" rel="noopener ugc nofollow" target="_blank"> iTerm2 </a>中发现(据我所知)。这允许您获取二进制图像的base64表示，并在终端上内联打印出来。在行首的转义序列<code class="fe nl nm nn no b">2;0H</code>是一个CSI，它将光标移动到第2行第0列，在那里我们要打印图像。</p><h1 id="8349" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">最终模拟</h1><p id="8c84" class="pw-post-body-paragraph kj kk iu kl b km mp jv ko kp mq jy kr ks mr ku kv kw ms ky kz la mt lc ld le in bi translated">这是我运行它时的样子。</p><figure class="li lj lk ll gu lm gi gj paragraph-image"><div class="gi gj oa"><img src="../Images/98f6b5beeef9272417e2e354dc791bef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*2na0vKL-LaH56nZU.gif"/></div></figure><h1 id="b286" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">密码</h1><p id="7dfd" class="pw-post-body-paragraph kj kk iu kl b km mp jv ko kp mq jy kr ks mr ku kv kw ms ky kz la mt lc ld le in bi translated">这里找到的所有代码都可以在<a class="ae lf" href="http://github.com/sausheong/goids" rel="noopener ugc nofollow" target="_blank">http://github.com/sausheong/goids</a>找到。</p><h1 id="ad91" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">我为什么要这么做？</h1><p id="95f0" class="pw-post-body-paragraph kj kk iu kl b km mp jv ko kp mq jy kr ks mr ku kv kw ms ky kz la mt lc ld le in bi translated">群集模拟已经被做得死去活来，但是我喜欢写它。看到这些小家伙不是作为个体，而是作为一个有自己思想的群体四处活动，有一种禅意。在学习了群集和编写群集模拟之后，我开始做更多的模拟，将来我可能会写更多。</p></div></div>    
</body>
</html>