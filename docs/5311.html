<html>
<head>
<title>A Quick Introduction to Neural Arithmetic Logic Units</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">神经算术逻辑单元快速介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-quick-introduction-to-neural-arithmetic-logic-units-288da7e259d7?source=collection_archive---------14-----------------------#2018-10-10">https://towardsdatascience.com/a-quick-introduction-to-neural-arithmetic-logic-units-288da7e259d7?source=collection_archive---------14-----------------------#2018-10-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3fe4539e26f693ffc64d31efa608cd23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oSve-gjiEqwPPc_XUE5jvw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">(Credit: <a class="ae kc" href="https://pixabay.com/en/users/aitoff-388338/" rel="noopener ugc nofollow" target="_blank">aitoff</a>)</figcaption></figure><p id="c7d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">经典的神经网络非常灵活，但是它们不太适合某些任务。特别是一些算术运算，对神经网络来说是个挑战。这就是为什么 Trask 等人在他们的论文<a class="ae kc" href="https://arxiv.org/pdf/1808.00508.pdf" rel="noopener ugc nofollow" target="_blank">神经算术逻辑单元</a>中介绍了两个新模块，这两个模块旨在很好地执行某些算术任务。在这篇博文中，我将描述本文旨在解决的问题，<strong class="kf ir"> </strong>提出的解决方案，并讨论使用 PyTorch 的实现细节和结果再现。</p><h2 id="1e75" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">所以你想学习恒等函数？</h2><p id="e39e" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">对于神经网络来说，这听起来是一个足够简单的任务，对吗？如果我们的测试集和我们的训练集在同一个范围内，那就是这样。然而，一旦我们的测试数据超出训练范围，大多数神经网络就会失败。这个失败揭示了一个令人不安的事实:理论上，多层感知器能够表示任何连续的函数，但架构、训练数据和学习时间表的选择将严重偏离 MLP 最终学习的函数。Trask 等人用下图有效地说明了这一失败:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/0ada934af61efbd7e01ae2b0bc905ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d6nwF7G8GNT-829iKlCuKQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Failure of MLPs to learn the identity function. (Credit: Trask et al)</figcaption></figure><p id="cd92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了克服这些限制，该论文建议使用两个新模块:神经累加器(NAC)和神经算术逻辑单元(NALU)。让我们看看它们是什么，以及它们背后的数学原理。</p><h2 id="df21" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">南汽和 NALU</h2><p id="40d8" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">先说 NAC:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/602890902734f7994e48f58b17881c69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*Xdu50KL-c8Tq0GIylSxU0g.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">NAC (Credit: Trask et al)</figcaption></figure><p id="f8e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们在上面看到的，NAC 类似于线性变换，但我们使用的权重矩阵是两个学习矩阵的结果，我们在将它们按元素相乘之前对其应用了<code class="fe mf mg mh mi b">tanh</code>和<code class="fe mf mg mh mi b">sigmoid</code>:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/f5bbc5a5ae08303196dab0272cf8f467.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*dXCwT1Xut9cZxAaWj5g87g.png"/></div></div></figure><p id="ac84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么要这么麻烦？这如何帮助我们的网络正确地学习算术函数？让我们来看看下图:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/0c004dfd673210ba0f5deb5f4602fc89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9lZetkZVgS2XaFnlDpHtzA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">tanh(x) * sigmoid(y)</figcaption></figure><p id="9cca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到权重向量的值偏向 0、1 和-1。这意味着 NAC 的输出是输入向量的加法和减法，而不是缩放。这允许 NAC 无限地堆叠在一起，并且仍然保持输入表示的一致缩放。这对于学习处理加减的算术运算显然是有帮助的，但对于乘除就不行了。</p><p id="a85e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是 NALU 的用武之地:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/880894464407ee26ffd1604b923c18bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ne7ck-q4K1LH9bTe5prq7w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">NALU (Credit: Trask et al)</figcaption></figure><p id="8536" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">NALU 使用 NAC 作为子单元，并增加两个额外的信息流。第一个使用 NAC 在对数空间中操作，第二个用作学习门，计算标准 NAC 和对数空间 NAC 之间的加权和。这在理论上应该允许 NALU 学习诸如乘法和除法以及加法和减法之类的功能。</p><h2 id="ab77" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">闲聊够了，让我们看看代码！</h2><p id="f54c" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">NAC 和 NALU 的实现相当简单。你可以看看<a class="ae kc" href="https://github.com/vrxacs/NALU" rel="noopener ugc nofollow" target="_blank"> GitHub 回购</a>，但我会在这里回顾重要的部分。首先，我们将从 NAC 开始:</p><pre class="ma mb mc md gt mm mi mn mo aw mp bi"><span id="4153" class="lb lc iq mi b gy mq mr l ms mt">class NAC(Module):    <br/>  def __init__(self, n_in, n_out):<br/>    super().__init__()<br/>    self.W_hat = Parameter(torch.Tensor(n_out, n_in))<br/>    self.M_hat = Parameter(torch.Tensor(n_out, n_in))<br/>    self.reset_parameters()</span><span id="30b4" class="lb lc iq mi b gy mu mr l ms mt">  def reset_parameters(self):<br/>    init.kaiming_uniform_(self.W_hat)         <br/>    init.kaiming_uniform_(self.M_hat)</span><span id="c147" class="lb lc iq mi b gy mu mr l ms mt">  def forward(self, input):<br/>    weights = torch.tanh(self.W_hat) * torch.sigmoid(self.M_hat)<br/>    return F.linear(input, weights)</span></pre><p id="c49f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码应该是不言自明的。我们首先对 PyTorch 的<code class="fe mf mg mh mi b">Module</code>进行子类化。在初始化步骤中，我们将两个学习到的矩阵<code class="fe mf mg mh mi b">W_hat</code>和<code class="fe mf mg mh mi b">M_hat</code>定义为<code class="fe mf mg mh mi b">Parameters</code>，并使用初始化对它们进行初始化。在向前的步骤中，在我们将<code class="fe mf mg mh mi b">W_hat</code>和<code class="fe mf mg mh mi b">M_hat</code>相乘之前，我们通过<code class="fe mf mg mh mi b">tanh</code>和<code class="fe mf mg mh mi b">sigmoid</code>传递它们。然后，我们获取生成的矩阵，并使用它和单元的输入执行线性变换。这就是你拥有的:一个全功能的 NAC 模块！</p><p id="702d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们转向 NALU 实现之前，重要的是要强调这样一个事实，即在上面的代码中只有两个学习过的矩阵。被传递到线性变换中的矩阵没有被训练，只是实际学习的矩阵<code class="fe mf mg mh mi b">W_hat</code>和<code class="fe mf mg mh mi b">M_hat</code>的数学运算的结果。当 NALU 的论文第一次出现时，许多 PyTorch 实现将最终重量作为参数，<a class="ae kc" href="https://github.com/vrxacs/NALU/blob/master/fauxNAC.ipynb" rel="noopener ugc nofollow" target="_blank">这将它们的 NAC 变成简单的线性层</a>。这些<strong class="kf ir">我称之为 FauxNALUs </strong>，成为一项意外消融研究，我将在下一节讨论它们的意义。</p><p id="71dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们到达那里之前，我们仍然需要看一看 NALU 的实现:</p><pre class="ma mb mc md gt mm mi mn mo aw mp bi"><span id="2232" class="lb lc iq mi b gy mq mr l ms mt">class NALU(Module):    <br/>  def __init__(self, n_in, n_out):<br/>    super().__init__()        <br/>    self.NAC = NAC(n_in, n_out)        <br/>    self.G = Parameter(torch.Tensor(1, n_in))        <br/>    self.eps = 1e-6        <br/>    self.reset_parameters()        </span><span id="efeb" class="lb lc iq mi b gy mu mr l ms mt">  def reset_parameters(self):        <br/>    init.kaiming_uniform_(self.G)        </span><span id="839c" class="lb lc iq mi b gy mu mr l ms mt">  def forward(self, input):        <br/>    g = torch.sigmoid(F.linear(input, self.G))        <br/>    y1 = g * self.NAC(input)        <br/>    y2 = (1 - g) * <br/>         torch.exp(self.NAC(torch.log(torch.abs(input) + self.eps)))<br/>    return y1 + y2</span></pre><p id="7c2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们首先定义 NAC 和学习门矩阵，并初始化它们。在前面的步骤中，我们首先通过对输入和门矩阵进行线性变换来计算门值<code class="fe mf mg mh mi b">G</code>。然后，我们计算标准 NAC 输出和对数空间 NAC 输出，然后返回它们的加权和。值得注意的是，在计算 log-space NAC 时，我们需要向<code class="fe mf mg mh mi b">log</code>函数传递一个小的 epsilon 值，以避免任何未定义的行为。</p><h2 id="2963" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">数学课时间到了</h2><p id="7e4f" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">现在我们知道了 NALUs 背后的理论以及如何在 PyTorch 中实现它们，剩下的就是实际观察它们的运行了。我们将尝试使用基于<a class="ae kc" href="https://github.com/kevinzakka/NALU-pytorch" rel="noopener ugc nofollow" target="_blank"> kevinzakka 的代码</a>的脚本来重现论文中函数学习部分的结果，我已经修改了这些脚本，在这里加入了 FauxNALU <a class="ae kc" href="https://github.com/vrxacs/NALU-pytorch" rel="noopener ugc nofollow" target="_blank">的代码</a>。函数学习测试的想法是，我们将提供符合特定函数(加、减、除、平方根等)的随机生成的输入数据，然后测试我们的 MLP 是否能够正确地学习算术函数:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/191ce408588f674ea245fbea43b509f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3KXwxc5sf0cY3mBpYBEYgw.png"/></div></div></figure><p id="9175" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从这些结果中可以得出以下几点:</p><ul class=""><li id="e4fe" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated"><strong class="kf ir"> NAC </strong>在加法和减法方面表现惊人，但在乘法、除法和幂函数方面表现糟糕。这是有意义的，因为当它必须学习其他函数时，使它强大的加法(没有输入的任意缩放)的同样的东西极大地限制了它。</li><li id="b3a6" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">除了减法之外，NALU 在其他方面都表现得很好。鉴于<strong class="kf ir"> NAC </strong>和<strong class="kf ir"> FauxNALU </strong>在减法上表现良好，这表明 log gate 和<strong class="kf ir"> NAC </strong>在减法用例中以某种方式相互干扰。</li><li id="0793" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">FauxNALU 的结果最有趣。它的表现与<strong class="kf ir"> None </strong> MLP(仅使用线性的那种)一样好，这表明学习门本身对学习这些功能没有帮助。在学习除法和平方根方面，NALU 决定性地击败了 T21<strong class="kf ir">,这表明对数空间 NAC 和标准 NAC 的结合真正发挥了作用。</strong></li></ul><h2 id="da90" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">就这些了，伙计们！</h2><p id="19b7" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">NAC 和 NALU 当然是有趣的模块，尽管他们在我们所研究的玩具问题上表现不一。只有时间和进一步的实验才能告诉我们这些专门的模块是否会成为机器学习实践者常规工具箱的一部分。有一件事是肯定的:我们可以通过巧妙定义权重矩阵和使用门来设计具有特定偏好的模块，这一想法将继续存在，我们将看到许多其他模块利用这一点。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="59c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读！如有任何问题或建议，欢迎留言或推文<a class="ae kc" href="https://twitter.com/AlexievValeri" rel="noopener ugc nofollow" target="_blank"> @AlexievValeri </a>。</p></div></div>    
</body>
</html>