<html>
<head>
<title>Web based voice command recognition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于网络的语音命令识别</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/web-based-voice-command-recognition-58a9bb1ec8db?source=collection_archive---------8-----------------------#2018-01-04">https://towardsdatascience.com/web-based-voice-command-recognition-58a9bb1ec8db?source=collection_archive---------8-----------------------#2018-01-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/00010a642e4bd69feed2f6fc9e18ac61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BXVwwuoX0y8-Zrg7vuw4Hw.jpeg"/></div></div></figure><p id="0e42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="http://smus.com/web-audio-ml-features" rel="noopener ugc nofollow" target="_blank">上次</a>我们将音频缓冲区转换成图像。这次我们将拍摄这些图像，并使用<a class="ae kw" href="https://deeplearnjs.org/" rel="noopener ugc nofollow" target="_blank"> deeplearn.js </a>训练一个神经网络。结果是<a class="ae kw" href="https://google.github.io/web-audio-recognition/inference-demo/?model=yesno" rel="noopener ugc nofollow" target="_blank">一个基于浏览器的演示</a>，让你说出一个命令(“是”或“否”)，并实时查看分类器的输出，就像这样:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kx"><img src="../Images/1cb2b40a46d1fd73c97d0d60914b3c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mRwjwLmtoOnLa7vEAE0DGw.png"/></div></div></figure><p id="05de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很好奇想玩玩它，看看它除了识别<em class="lc">是</em>和<em class="lc">否</em>之外，是否还识别<em class="lc">耶</em>或<em class="lc">否</em>？<a class="ae kw" href="https://google.github.io/web-audio-recognition/inference-demo/?model=yesno" rel="noopener ugc nofollow" target="_blank">现场试用</a>。你会很快发现表演远非完美。但这对我来说没问题:这个例子是为了成为在网络上进行各种音频识别的合理起点。现在，让我们深入了解这是如何工作的。</p><h1 id="7dd4" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">快速入门:训练和测试命令识别器</h1><p id="b3cc" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">以下是你如何训练自己的是/否分类器:</p><p id="4194" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1.进入<a class="ae kw" href="https://google.github.io/web-audio-recognition/train-model/?data_url=https://storage.googleapis.com/audio-recognition-data&amp;data_extension=mp3" rel="noopener ugc nofollow" target="_blank">车型培训页面</a>。从服务器下载<a class="ae kw" href="https://storage.googleapis.com/audio-recognition-data/yes.mp3" rel="noopener ugc nofollow" target="_blank">训练</a> <a class="ae kw" href="https://storage.googleapis.com/audio-recognition-data/no.mp3" rel="noopener ugc nofollow" target="_blank">数据</a>需要一点时间。</p><p id="e20d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.单击训练按钮，您将看到一个显示训练进度的图表。一旦你准备好了(这将需要一段时间，可能 500 次迭代或 2 分钟，取决于你的硬件)，停止训练，并按下保存重量(文件)按钮。这将下载一个 JSON 文件。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/ff659b99eeb4e4766b9b836e01bab4b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lt4Vl7GzDWXhtGV6.png"/></div></div></figure><p id="8b4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.然后进入<a class="ae kw" href="https://google.github.io/web-audio-recognition/inference-demo/?model=yesno" rel="noopener ugc nofollow" target="_blank">推理演示页面</a>，按下 load weights (file)按钮，选择下载的 JSON 文件，加载训练好的模型。</p><p id="b7a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4.翻转开关，允许使用麦克风，并尝试说“是”或“否”。您将在页面底部看到麦克风和置信度。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kx"><img src="../Images/6e15bb194606b2dc32bc753ef57e3a4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0E4IkUZuArYUdzUK.png"/></div></div></figure><p id="7fd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以上是对训练示例如何工作的机械描述。如果你有兴趣了解血淋淋的(和有趣的)细节，请继续阅读。</p><h1 id="50f4" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">数据预处理和加载</h1><p id="5a62" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">训练一个神经网络需要大量的训练数据。在实践中，可能需要数百万个样本，但我们将使用的数据集按照现代标准来看是很小的，<em class="lc">只有</em> 65，000 个标记样本。每个示例都是一个单独的 wav 文件，文件名中带有标签。</p><p id="79fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将每一个训练 wav 作为一个单独的请求来加载被证明是非常慢的。每个请求的开销很小，但是当超过几千次时，就真的开始感觉到了。为了更快地加载数据，一个简单的优化方法是将带有相同标签的所有示例放入一个长音频文件中。解码音频文件非常快，把它们分成一秒钟长的缓冲区也是如此。进一步的优化是使用压缩音频格式，例如 mp3。<code class="fe mh mi mj mk b"><a class="ae kw" href="https://github.com/google/web-audio-recognition/blob/master/train-model/scripts/preprocess.py" rel="noopener ugc nofollow" target="_blank">scripts/preprocess.py</a></code>会为你做这个连接，产生这个<a class="ae kw" href="https://storage.googleapis.com/audio-recognition-data/yes.mp3" rel="noopener ugc nofollow" target="_blank">迷人的结果</a>。</p><p id="00d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们“再水合”我们的原始音频示例之后，我们将原始数据的缓冲区处理成特征。我们使用我在<a class="ae kw" href="http://smus.com/web-audio-ml-features" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中提到的<a class="ae kw" href="http://smus.com/web-audio-ml-features" rel="noopener ugc nofollow" target="_blank">音频特征提取器</a>来完成这项工作，它接收原始音频，并生成 log-mel 声谱图。这相对较慢，并且占据了加载数据集的大部分时间。</p><h1 id="2d21" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">模型培训注意事项</h1><p id="716e" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">对于是/否识别器，我们只关心两个命令:“是”和“否”。但是我们也想发现任何这样的话语的缺乏，以及沉默。我们包括一组随机话语<a class="ae kw" href="https://storage.googleapis.com/audio-recognition-data/other.mp3" rel="noopener ugc nofollow" target="_blank">作为“其他”类别(没有一个是或不是)。这个例子也是由</a><a class="ae kw" href="https://github.com/google/web-audio-recognition/blob/master/train-model/scripts/preprocess.py" rel="noopener ugc nofollow" target="_blank">预处理脚本</a>生成的。</p><p id="52fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们面对的是真正的麦克风，我们从来没有期望听到纯粹的寂静。相反，“静音”是某种程度的环境噪音加上糟糕的麦克风质量。幸运的是，训练数据还包括背景噪声，我们将它与不同音量的训练样本混合在一起。我们还生成了一组无声示例，其中仅包括背景音频。一旦我们准备好样品，我们就生成最终的光谱图作为我们的输入。</p><p id="6a4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了生成这些最终的频谱图，我们需要决定缓冲区和跳跃长度。合理的缓冲长度是 1024，跳长是 512。由于我们处理的是 16000 Hz 的采样速率，因此计算出的窗口持续时间约为 60ms，每 30ms 采样一次。</p><p id="da36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们标记了光谱图，我们需要将输入和标签转换为 deeplearn 数组。标签字符串“是”、“否”、“其他”、“沉默”会被<a class="ae kw" href="https://en.wikipedia.org/wiki/One-hot" rel="noopener ugc nofollow" target="_blank">一键</a>编码为四个整数的<code class="fe mh mi mj mk b">Array1D</code> s，意思是“是”对应<code class="fe mh mi mj mk b">[1, 0, 0, 0]</code>,“否”对应<code class="fe mh mi mj mk b">[0, 1, 0, 0]</code>。来自特征提取器的光谱图需要转换成一个<code class="fe mh mi mj mk b">Array3D</code>，作为模型的输入。</p><p id="b0d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们正在训练的模型由两个卷积层和一个完全连接的层组成。我直接从 deeplearn.js 的 MNIST 示例中获得了这个架构，并且根本没有为处理 spectrograms 进行定制。结果，性能与最先进的语音识别相差甚远。要查看更多的错误分类，请尝试音频的<a class="ae kw" href="https://google.github.io/web-audio-recognition/inference-demo/?model=number" rel="noopener ugc nofollow" target="_blank">MNIST</a>，它可以识别语音数字(例如“0”到“10”)。我相信，通过遵循本文<a class="ae kw" href="http://www.isca-speech.org/archive/interspeech_2015/papers/i15_1478.pdf" rel="noopener ugc nofollow" target="_blank">我们可以做得更好。现实世界的语音识别器可能根本不使用卷积，而是选择更适合处理时间序列数据的</a><a class="ae kw" href="https://en.wikipedia.org/wiki/Long_short-term_memory" rel="noopener ugc nofollow" target="_blank"> LSTM </a>。</p><p id="5581" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们想告诉机器学习框架如何训练模型。用 ML 的说法，我们需要设置<a class="ae kw" href="https://en.wikipedia.org/wiki/Hyperparameter_(machine_learning)" rel="noopener ugc nofollow" target="_blank">超参数</a>，包括设置学习率(每步跟随梯度多少)和批量大小(一次摄取多少个例子)。我们出发去比赛:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/653d0c6d74b0891958e22676f5715a09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*t5hUBo3Jxwkn1p4y.png"/></div></div></figure><p id="f0e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在训练过程中，梯度下降算法试图最小化成本，你可以看到蓝色。我们还用橙色绘制了准确性，这是偶尔通过在测试集上运行推理来计算的。我们使用测试集的随机子集，因为推理需要时间，我们希望尽可能快地训练。</p><p id="084b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们对测试的准确性感到满意，我们就可以保存模型权重并用它们来推断结果。</p><h1 id="b947" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">保存和加载模型权重</h1><p id="dfdc" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">一个模型由它的架构和它的承重节点的重量来定义。权重是在模型训练过程中学习的值，并且不是所有节点都具有权重。ReLUs 和 flatten 节点不会。但是卷积和全连接节点既有权重也有偏差。这些重量是任意形状的张量。为了保存和加载模型，我们需要能够保存图<strong class="ka ir">和</strong>的权重。</p><p id="c0eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">保存和加载模型很重要，原因如下:</p><ol class=""><li id="ca70" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">模特训练需要时间，所以你可能想训练一下，减肥，休息一下，然后从你停下的地方继续。这称为检查点。</li><li id="2c17" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">从推论上来说，拥有一个可以加载和运行的自包含模型是很有用的。</li></ol><p id="86fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在撰写本文时，deeplearn.js 还没有序列化模型和模型权重的工具。对于这个例子，我实现了一种加载和保存权重的方法，假设模型架构本身是硬编码的。<code class="fe mh mi mj mk b"><a class="ae kw" href="https://github.com/google/web-audio-recognition/blob/master/train-model/src/GraphSaverLoader.ts" rel="noopener ugc nofollow" target="_blank">GraphSaverLoader</a></code>类可以保存来自本地存储(IndexedDB)或文件的&amp;负载。最终，我们将需要一种非黑客的方式来保存和加载模型及其相应的权重，我对 ML 开发人员工效学的改进感到兴奋。</p><h1 id="729c" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">包扎</h1><p id="c5e2" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">非常感谢<a class="ae kw" href="https://twitter.com/nsthorat" rel="noopener ugc nofollow" target="_blank"> Nikhil </a>和<a class="ae kw" href="https://twitter.com/dsmilkov" rel="noopener ugc nofollow" target="_blank"> Daniel </a>在 deeplearn.js 上的辛勤工作，以及愿意回答我一连串愚蠢的小问题。另外，还要感谢<a class="ae kw" href="https://twitter.com/petewarden" rel="noopener ugc nofollow" target="_blank">皮特</a>，他负责创建和发布我在这篇文章中使用的<a class="ae kw" href="https://storage.cloud.google.com/download.tensorflow.org/data/speech_commands_v0.01.tar.gz" rel="noopener ugc nofollow" target="_blank">数据集</a>。亲爱的读者，谢谢你读到这里。</p><p id="84cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我很高兴看到这种基于浏览器的音频识别技术如何应用于令人兴奋的教育 ML 项目，如<a class="ae kw" href="https://teachablemachine.withgoogle.com/" rel="noopener ugc nofollow" target="_blank">可教机器</a>。如果你能制造一个自我改进的系统，对每一个额外的口语进行训练，那该有多酷？在浏览器中训练这些类型的模型的能力允许我们以保护隐私的方式考虑这样的可能性，而不用向任何服务器发送任何东西。</p><p id="5e79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以你有它！这是对网络上语音命令识别的解释。我们在<a class="ae kw" href="http://smus.com/web-audio-ml-features" rel="noopener ugc nofollow" target="_blank">的上一篇文章</a>中讨论了特征提取，而这一次，我们稍微探讨了一下完全在浏览器中进行的<a class="ae kw" href="https://google.github.io/web-audio-recognition/train-model/?data_url=https://storage.googleapis.com/audio-recognition-data&amp;data_extension=mp3" rel="noopener ugc nofollow" target="_blank">模型训练</a>和<a class="ae kw" href="https://google.github.io/web-audio-recognition/inference-demo/?model=yesno" rel="noopener ugc nofollow" target="_blank">实时推理</a>。</p><p id="0169" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你以这个例子为基础，请在 twitter 上给我留言。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="c495" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lc">最初发表于</em><a class="ae kw" href="http://smus.com/web-voice-command-recognition/" rel="noopener ugc nofollow" target="_blank"><em class="lc">smus.com</em></a><em class="lc">。</em></p></div></div>    
</body>
</html>