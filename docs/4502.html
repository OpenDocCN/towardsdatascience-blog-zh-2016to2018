<html>
<head>
<title>Understanding NumPy sum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解数字总和</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-numpy-sum-1587eec69527?source=collection_archive---------2-----------------------#2018-08-20">https://towardsdatascience.com/understanding-numpy-sum-1587eec69527?source=collection_archive---------2-----------------------#2018-08-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/014f64ace7d153435f5fa55e8f07491b.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*uEGr_zcWPIOaPkyGjM1CXA.jpeg"/></div></figure><p id="6afe" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你不清楚 NumPy 是什么或者它是如何工作的，请先看看这篇文章。</p><div class="ks kt gp gr ku kv"><a rel="noopener follow" target="_blank" href="/first-step-in-data-science-with-python-numpy-5e99d6821953"><div class="kw ab fo"><div class="kx ab ky cl cj kz"><h2 class="bd ir gy z fp la fr fs lb fu fw ip bi translated">Python 数据科学的第一步— NumPy</h2><div class="lc l"><h3 class="bd b gy z fp la fr fs lb fu fw dk translated">我读到过学习的最好方法是写博客。因为我学习数据科学已经有一段时间了…</h3></div><div class="ld l"><p class="bd b dl z fp la fr fs lb fu fw dk translated">towardsdatascience.com</p></div></div><div class="le l"><div class="lf l lg lh li le lj js kv"/></div></div></a></div><p id="1b79" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在那篇介绍 NumPy 的文章中，我在 NumPy 数组上做了一个<strong class="jw ir">按行添加的操作</strong>。然后，帖子的一位读者回应说，我所做的是列方向的添加，而不是行方向的添加。事实上，当我学习它的时候，我同样觉得它不应该这样工作。这与它应该如何工作正好相反。所以，我看了一下<a class="ae lk" href="https://docs.scipy.org/doc/numpy-1.10.0/glossary.html" rel="noopener ugc nofollow" target="_blank">文件</a>，但是上面说</p><blockquote class="ll lm ln"><p id="aa82" class="ju jv lo jw b jx jy jz ka kb kc kd ke lp kg kh ki lq kk kl km lr ko kp kq kr ij bi translated"><em class="iq">我们可以对数组的每一行求和，在这种情况下，我们沿着列或轴 1 进行操作</em></p></blockquote><p id="1547" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">没用。我还是很困惑。我继续寻找，然后我发现了<a class="ae lk" href="https://medium.com/@aerinykim/numpy-sum-axis-intuition-6eb94926a5d1" rel="noopener">Aerin Kim</a>的这篇文章，它改变了我看待 NumPy 数组求和的方式。所以以她的帖子为基础，这是我对 NumPy 数组和的看法。</p><p id="e5b2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你不清楚问题是什么，让我们正式定义它。</p><h1 id="b730" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">问题</h1><p id="2828" class="pw-post-body-paragraph ju jv iq jw b jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr ij bi translated">我们有一个 5x5 NumPy 阵列，如下所示</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="dd8f" class="ne lt iq na b gy nf ng l nh ni">a = array([[ 12., -22., -20., -19.,  -3.],<br/>       [-23.,  21., -17., -11.,  -1.],<br/>       [ -4.,  -5.,  16.,  -9., -14.],<br/>       [-10.,  -6., -18.,  15.,  -8.],<br/>       [-25.,  -2., -13.,  -7.,  24.]])</span></pre><p id="1c7e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们在上面的数组中使用</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="73a1" class="ne lt iq na b gy nf ng l nh ni">sum_matrix = a.sum(axis=1)</span></pre><p id="7e37" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们最终在<code class="fe nj nk nl na b">sum_matrix</code>中得到下面的数组</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="1efc" class="ne lt iq na b gy nf ng l nh ni">array([-52., -31., -16., -27., -23.])</span></pre><p id="acfb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果<code class="fe nj nk nl na b">axis=1</code>指的是逐行相加，这似乎是正确的。没问题。除此之外，<code class="fe nj nk nl na b">axis=0</code>实际上应该是指行而不是<code class="fe nj nk nl na b">axis=1</code>。当我们看到 NumPy 数组是如何形成的时，这一点会更清楚。让我们取另一个 NumPy 数组。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="ddf3" class="ne lt iq na b gy nf ng l nh ni">arr = np.arange(12).reshape(4,3)</span></pre><p id="fc4d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们在<code class="fe nj nk nl na b">arr</code>得到的是</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="9c56" class="ne lt iq na b gy nf ng l nh ni">array([[ 0,  1,  2],<br/>       [ 3,  4,  5],<br/>       [ 6,  7,  8],<br/>       [ 9, 10, 11]])</span></pre><p id="95af" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">很明显，它是 4 行 3 列。因此，第一个轴<code class="fe nj nk nl na b">axis=0</code>应该表示行，第二个轴<code class="fe nj nk nl na b">axis=1</code>应该表示列。</p><p id="fcba" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你观察熊猫，这一点也会得到证实。让我们举一个数据帧的例子。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="6ffb" class="ne lt iq na b gy nf ng l nh ni">df = pd.DataFrame(data=np.arange(12).reshape(4,3),index=['row1','row2','row3','row4'],columns=['col1','col2','col3'])</span></pre><p id="b12d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe nj nk nl na b">df</code>看起来是这样的</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/2409cbfc7c6742db6576751f41a2c903.png" data-original-src="https://miro.medium.com/v2/resize:fit:332/format:webp/1*DMGjUIJ39fLGD47WZii5Qg.png"/></div></figure><p id="2f9f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你现在做<code class="fe nj nk nl na b">df.drop(labels=[‘row1’], axis=0)</code>，你会得到的回报是</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/8df92a90cea5658f7c8585b139fc5140.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*DbhmEUbq0cIz1xwX0BoYLA.png"/></div></figure><p id="0beb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你做了<code class="fe nj nk nl na b">df.drop(labels=[‘col2’], axis=1)</code>，你会得到</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/c029a139918b2bcd2c22ae3afff2443b.png" data-original-src="https://miro.medium.com/v2/resize:fit:260/format:webp/1*nJL5rfCRFjw2wIRoHhPpdw.png"/></div></figure><p id="b445" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">显然，<code class="fe nj nk nl na b">axis=0</code>表示行，<code class="fe nj nk nl na b">axis=1</code>表示列。那么，为什么 NumPy sum 的做法不同呢？</p><h1 id="6ec1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">解决办法</h1><p id="e5cf" class="pw-post-body-paragraph ju jv iq jw b jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr ij bi translated">引用<a class="ae lk" href="https://medium.com/@aerinykim" rel="noopener"> Aerin Kim </a>在她的<a class="ae lk" href="https://medium.com/@aerinykim/numpy-sum-axis-intuition-6eb94926a5d1" rel="noopener">帖子</a>中的话，她写道</p><blockquote class="ll lm ln"><p id="225c" class="ju jv lo jw b jx jy jz ka kb kc kd ke lp kg kh ki lq kk kl km lr ko kp kq kr ij bi translated"><em class="iq">的方式来理解 numpy 的</em> <strong class="jw ir"> <em class="iq">轴</em> </strong> <em class="iq">求和就是将</em> <strong class="jw ir"> <em class="iq">折叠</em> </strong> <em class="iq">指定轴。所以当它折叠轴 0(行)时，它就变成了一行和一列的总和。</em></p></blockquote><p id="2355" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们看看这是什么意思。现在，它在 2D 可能会变得有点混乱，所以让我们首先在一个更高的维度上理解这一点，然后我们将逐步进入 2D；就像她在岗位上做的一样。</p><p id="49b2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以，我们来取一个形状为<code class="fe nj nk nl na b">(4,3,2)</code>的 3D 数组。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="c48b" class="ne lt iq na b gy nf ng l nh ni">three_d_array = np.arange(24).reshape(4,3,2)</span></pre><p id="2465" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe nj nk nl na b">three_d_array</code>现在变成等于</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="8e29" class="ne lt iq na b gy nf ng l nh ni">array([[[ 0,  1],<br/>        [ 2,  3],<br/>        [ 4,  5]],<br/><br/>       [[ 6,  7],<br/>        [ 8,  9],<br/>        [10, 11]],<br/><br/>       [[12, 13],<br/>        [14, 15],<br/>        [16, 17]],<br/><br/>       [[18, 19],<br/>        [20, 21],<br/>        [22, 23]]])</span></pre><p id="e408" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，让我们看看沿第一轴的元素，<code class="fe nj nk nl na b">axis=0</code>。沿着<code class="fe nj nk nl na b">axis=0</code>我们有 4 个元素。这些可以用<code class="fe nj nk nl na b">three_d_array[0]</code>、<code class="fe nj nk nl na b">three_d_array[1]</code>、<code class="fe nj nk nl na b">three_d_array[2]</code>和<code class="fe nj nk nl na b">three_d_array[3]</code>查看</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/cedb3fcd45c6d60753eb896774cd9e47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*C5520SYmi4tZFNRn_Uwlhw.jpeg"/></div></figure><p id="0888" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">每一个都是形状为<code class="fe nj nk nl na b">(3,2)</code>的 2D 阵列。现在，如果我们把上面所有的 2D 阵列加起来，</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="ccc9" class="ne lt iq na b gy nf ng l nh ni">three_d_array[0]+three_d_array[1]+three_d_array[2]+three_d_array[3]</span></pre><p id="aeef" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在逐个元素相加之后，我们得到一个 3x2 的数组，如下所示:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="1e8b" class="ne lt iq na b gy nf ng l nh ni">array([[36, 40],<br/>       [44, 48],<br/>       [52, 56]])</span></pre><p id="c273" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这正是我们做<code class="fe nj nk nl na b">three_d_array.sum(axis=0)</code>时得到的结果。我们将带走<code class="fe nj nk nl na b">axis=0</code>的所有元素。然后我们一个元素一个元素地求和。最初，我们有一个 3D 形状数组<code class="fe nj nk nl na b">(4,3,2)</code>。求和之后，我们得到了一个形状为<code class="fe nj nk nl na b">(3,2)</code>的 2D 数组。于是，我们丢掉了第一轴<code class="fe nj nk nl na b">4</code>，保留了剩下的两根<code class="fe nj nk nl na b">(3,2)</code>。这可能就是 Kim 所说的“<strong class="jw ir">它会折叠轴</strong>”的意思。</p><p id="6cdb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，我们来看看<code class="fe nj nk nl na b">axis=1</code>。这次我们保持第一个轴不变，沿着第二个轴求和，<code class="fe nj nk nl na b">axis=1</code>。这里，我们有 12 个元素，从第一个轴 0 开始，每个轴上有 3 个元素。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/54daf3e9b789c6c26ce2f604221b1194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*-koq7OBamQd8_t-DmAKGaQ.jpeg"/></div></figure><p id="966c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">加上所有这些，我们回到</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/f5a69cb9d5469315cdbe7a19493d1312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*bw-HVwvXo_6722ao6fsV-w.png"/></div></figure><p id="ed86" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">类似地，我们为剩下的三个添加</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/fc63b8c18eba678f5109cc06a2f3532f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*nFme3MKjs-GF80u29AY-HA.png"/></div></figure><p id="13c9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将所有 4 个组合起来，我们得到一个如下所示的数组:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="fd0d" class="ne lt iq na b gy nf ng l nh ni">array([[ 6,  9],<br/>       [24, 27],<br/>       [42, 45],<br/>       [60, 63]])</span></pre><p id="2e6a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这正是我们做<code class="fe nj nk nl na b">three_d_array.sum(axis=1)</code>时得到的；沿着<code class="fe nj nk nl na b">axis=1</code>逐个元素执行加法。同样，和矩阵的形状是<code class="fe nj nk nl na b">(4,2)</code>，这表明我们从原来的<code class="fe nj nk nl na b">(4,3,2)</code>中去掉了第二轴<code class="fe nj nk nl na b">3</code>。</p><p id="dc78" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于最后的轴 2，我们做同样的事情。这次我们有所有 24 个元素，我们通过保持前两个轴不变来沿着<code class="fe nj nk nl na b">axis=2</code>求和。这里，我们只看前 6 个元素。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/7242bded0be3e74c1cc0584496a8981e.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*-azmTMkD1u5_rGiYyHREzw.jpeg"/></div></figure><p id="974a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这给了我们一行 sum 数组。我们对剩下的部分做同样的事情，最后我们得到了下面的数组，</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="ff84" class="ne lt iq na b gy nf ng l nh ni">array([[ 1,  5,  9],<br/>       [13, 17, 21],<br/>       [25, 29, 33],<br/>       [37, 41, 45]])</span></pre><p id="5e96" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这正是我们在<code class="fe nj nk nl na b">three_d_array.sum(axis=2)</code>上得到的。同样，求和数组的形状是<code class="fe nj nk nl na b">(4,3)</code>，这里我们失去了最后一个轴<code class="fe nj nk nl na b">2</code>。</p><h2 id="cfd1" class="ne lt iq bd lu nu nv dn ly nw nx dp mc kf ny nz mg kj oa ob mk kn oc od mo oe bi translated">最后，回到最初的问题</h2><p id="4ad8" class="pw-post-body-paragraph ju jv iq jw b jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr ij bi translated">我们的阵列是</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="5a78" class="ne lt iq na b gy nf ng l nh ni">a = array([[ 12., -22., -20., -19.,  -3.],<br/>       [-23.,  21., -17., -11.,  -1.],<br/>       [ -4.,  -5.,  16.,  -9., -14.],<br/>       [-10.,  -6., -18.,  15.,  -8.],<br/>       [-25.,  -2., -13.,  -7.,  24.]])</span></pre><p id="67ec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，当我们沿着<code class="fe nj nk nl na b">axis=0</code>移动元素时，我们得到</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi of"><img src="../Images/e1f6499d533e2052992e4421ec1a5613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*XowtSfE5oM8z8uv3ThdpEQ.png"/></div></figure><p id="5877" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个元素一个元素地添加这些元素给我们</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/7fbae15ccc6f9d3ac8bddc73a913c125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*lK4xiKgyCqBpNFOWygSl8w.png"/></div></figure><p id="b035" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这相当于<code class="fe nj nk nl na b">a.sum(axis=0)</code>。</p><p id="0968" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">类似地，当我们沿着<code class="fe nj nk nl na b">axis=1</code>提取元素时，</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi oh"><img src="../Images/322363e935f48c3d5d866007a80bf8bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yzc0BcrbTQ170nq-WGc4SQ.png"/></div></div></figure><p id="b817" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，如果我们分别对所有的<code class="fe nj nk nl na b">a[0]s</code>、所有的<code class="fe nj nk nl na b">a[1]s</code>、所有的<code class="fe nj nk nl na b">a[2]s</code>、所有的<code class="fe nj nk nl na b">a[3]s</code>和所有的<code class="fe nj nk nl na b">a[4]s</code>求和，我们得到</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi om"><img src="../Images/d23fc29c4e1a4837f0c46c2526804f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*S1cGy-4if7ZsufXmpqG5Fw.png"/></div></figure><p id="89ae" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就是我们用<code class="fe nj nk nl na b">a.sum(axis=1)</code>得到的。如果我们检查形状，我们得到<code class="fe nj nk nl na b">(5,)</code>。如果我们只看 2D 数组，这可能不清楚，但正如我们前面看到的，这只是折叠轴 1 并返回剩余轴 0 的形状。</p><p id="282d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，如果我们回头看看文档中的语句，“我们可以对数组的每一行求和，在这种情况下，我们沿着列或轴 1 操作”，我认为这更有意义。因此，尽管我们计算了每行的总和，但从技术上讲，这是一个<strong class="jw ir">列相加</strong>而不是<strong class="jw ir">行相加</strong>，因为 axis=0 是行，axis=1 是列。</p><p id="e3a1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为什么 NumPy 不像熊猫那样直截了当？嗯，老实说，我也不知道答案。但这就是饼干碎裂的方式。</p></div></div>    
</body>
</html>