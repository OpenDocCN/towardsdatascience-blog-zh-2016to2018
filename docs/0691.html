<html>
<head>
<title>Introduction to text representation and similarity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">文本表示和相似性介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-text-representation-and-similarity-b5dd3fd71737?source=collection_archive---------0-----------------------#2017-06-09">https://towardsdatascience.com/introduction-to-text-representation-and-similarity-b5dd3fd71737?source=collection_archive---------0-----------------------#2017-06-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3da7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">机器学习和数据挖掘任务中最基本的就是比较对象的能力。我们必须在聚类、分类、查询和其他方面比较(有时是平均)对象。文本也不例外，在这篇文章中，我想探索文本的不同表示/嵌入以及一些最流行的距离/相似度函数。</p><p id="432d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我想谈谈我们希望文本表示和距离/相似性函数具有什么样的属性:</p><ol class=""><li id="d073" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">相同的文本必须具有相同的表示和零距离(最大相似度)。</li><li id="6714" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">当我们有多个文本t1、t2和t3时，我们希望能够说t1比t3更类似于t2。</li><li id="619b" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">相似度/距离应该表达文本之间的语义比较，文本长度应该影响不大。</li></ol><p id="7f05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么让我们开始，考虑这三句话:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="e9c1" class="li lj iq le b gy lk ll l lm ln">s1 = “David loves dogs”<br/>s2 = “Dogs are ok with David”<br/>s3 = “Cats love rain”</span></pre><p id="993f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在假设我们想把这些句子分成两组。很明显，句子1和句子2属于同一组。但是我们如何通过编程来比较它们呢？</p><p id="60e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们将定义2个函数:1)向量函数，它获取某个句子并返回表示该句子的向量。以及2)距离函数，其接收两个向量并返回它们如何远离或相似。</p><p id="fe1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最基本的表达句子的方式是使用一组单词。在大多数情况下，我们会希望预处理我们的文本，以减少噪音。预处理可能包括小写、词干、删除停用词等。在我们的例子中，我们将把单词转换成它的基本形式，并去掉无用的单词。所以句子是:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="89cc" class="li lj iq le b gy lk ll l lm ln">s1 = (“david”, “love”, “dog”)<br/>s2 = (“dog”,”ok”,”david”)<br/>s3 = (“cat”,”love”,”rain”)</span></pre><p id="4869" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">比较这些句子，我们可以用<a class="ae lo" href="https://en.wikipedia.org/wiki/Jaccard_index" rel="noopener ugc nofollow" target="_blank"> Jaccard相似度</a>。Jaccard相似度是两个句子的常用词数量(交集)和总词数量(并集)之间的比例。句子1和2的并集是(“大卫”、“爱”、“狗”、“好”)，交集是(“大卫”、“狗”)，所以Jaccard相似度将是2/4 = 0.5。</p><p id="28a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，句子1和3之间的Jaccard相似度是1/6 = 0.166，句子2和3之间的相似度是0/6 = 0。</p><p id="4cbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这种方法解决了我们的问题，但也有一些缺点。概括这些缺点的最佳方式是表示和距离函数都不是“数学的”，即我们不能进行句子平均，例如，使用其他数学函数操纵距离函数(如求导)。</p><p id="9739" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解决这个问题，我们必须用一种更科学的方式来表达我们的句子:<a class="ae lo" href="https://en.wikipedia.org/wiki/Vector_space" rel="noopener ugc nofollow" target="_blank">向量</a>。</p><p id="5c4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这非常简单:我们将使用语料库中的所有单词(所有句子)构建一个词汇表，每个单词都有一个索引。在我们的示例中，它看起来像这样:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="fcb4" class="li lj iq le b gy lk ll l lm ln">{'cat': 0, 'david': 1, 'dog': 2, 'love': 3, 'ok': 4, 'rain': 5}</span></pre><p id="8894" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将把每个句子表示为一个6维向量，并在索引中为每个单词存储1，在其他地方存储0。以下是我们的句子:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="9c48" class="li lj iq le b gy lk ll l lm ln">s1 = [0, 1, 1, 1, 0, 0]     <br/>s2 = [0, 1, 1, 0, 1, 0]    <br/>s3 = [1, 0, 0, 1, 0, 1]   </span></pre><p id="664b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，每个句子只是6维空间中的一个点(或一个向量)。以下是我们使用主成分分析法在二维空间中将其可视化后的效果:</p><figure class="kz la lb lc gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi lp"><img src="../Images/c530ea2e2c11337eb18266846baf1ba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aeayaMhGOMzPg1lc4wvjwg.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Sentence 1 and 2 — Blue, Sentence 3 — Red</figcaption></figure><p id="440d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以看到第一句和第二句的观点都比第三句更接近。有很多种方式来表达他们之间的距离。最直观的是“<a class="ae lo" href="https://en.wikipedia.org/wiki/Euclidean_distance" rel="noopener ugc nofollow" target="_blank">欧几里德距离</a>”(也叫L2范数)其中计算这条线:</p><figure class="kz la lb lc gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi mb"><img src="../Images/5836b2130b6eb1a9cd16b53123f0d455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kn4DxzjOMWG1ml1C-V66pQ.png"/></div></div></figure><p id="8fe0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，没必要自己实现；有很多实现(例如python中的numpy.linalg.norm)。</p><p id="94fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是欧几里德距离的值:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="7fbb" class="li lj iq le b gy lk ll l lm ln">                 ╔══════╦════════╦════════╦════════╗<br/>                 ║      ║   <strong class="le ir">S1</strong>   ║   <strong class="le ir">S2</strong>   ║   <strong class="le ir">S3</strong>   ║  <br/>                 ╠══════╬════════╬════════╬════════╣<br/>                 ║ <strong class="le ir">S1</strong>   ║    0   ║  1.41  ║    2   ║<br/>                 ╠══════╬════════╬════════╬════════╣<br/>                 ║ <strong class="le ir">S2</strong>   ║  1.41  ║   0    ║  2.44  ║<br/>                 ╠══════╬════════╬════════╬════════╣<br/>                 ║ <strong class="le ir">S2</strong>   ║    2   ║  2.44  ║    0   ║<br/>                 ╚══════╩════════╩════════╩════════╝</span></pre><p id="ecda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它看起来不错，但还是有一些缺点。很多时候，文本语义是由某个词出现的次数决定的。例如，如果我们阅读一篇关于“向量”的文章，那么“向量”这个术语会出现很多次。在这种情况下，在我们的文本向量中只使用二进制值将忽略文本的真正语义。最简单的解决方案是将单词出现的次数存储在向量的正确位置。</p><p id="d515" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑这些句子:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="84e8" class="li lj iq le b gy lk ll l lm ln">s1 = “David loves dogs dogs dogs dogs”<br/>s2 = “Dogs are ok with David”<br/>s3 = “Cats love rain”</span></pre><p id="7453" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，第一句话在语法上是不正确的，但是我们可以说它是关于狗的。让我们看看相应的向量:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="8c8e" class="li lj iq le b gy lk ll l lm ln">s1 = [0, 1, 5, 1, 0, 0]     <br/>s2 = [0, 1, 1, 0, 1, 0]    <br/>s3 = [1, 0, 0, 1, 0, 1]</span></pre><p id="89b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这几个向量和前面的唯一区别是，这一次，我们在第一个句子向量的“狗”位置存储5。</p><p id="31d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们再次使用PCA绘制这些向量:</p><figure class="kz la lb lc gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi mc"><img src="../Images/fa032c8304c35118c09b39a3466e442c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rfdBr2EM572IC4YU8kWodQ.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Sentence 1 — Blue, Sentence 2 — Green, Sentence 3 — Red</figcaption></figure><p id="2bf6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看发生了什么；现在，句子2(绿色)和3(红色)比1(蓝色)和2(绿色)更接近。这对我们非常不利，因为我们不能表达句子的语义。</p><p id="af1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个问题最典型的解决方案是，我们可以比较两个向量之间的角度，而不是计算两点之间的距离，例如，这些值:</p><figure class="kz la lb lc gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi md"><img src="../Images/d5eb6401cd54977cbdeb757acd32d2dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m465Yl06qhuFxOjdxB90fg.png"/></div></div></figure><p id="b57e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以看到句子1和2的角度比1和3或者2和3更近。实际的相似性度量被称为“<a class="ae lo" href="https://en.wikipedia.org/wiki/Cosine_similarity" rel="noopener ugc nofollow" target="_blank">余弦相似性</a>，它是两个向量之间角度的余弦。0的余弦是1(最相似)，180的余弦是0(最不相似)。</p><p id="8833" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，我们能够更好地表示文本的语义，以及比较文本对象。</p><p id="7512" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">结论</strong></p><p id="a99f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们看到了表示文本和比较文本对象的不同方法。没有更好或最好的方法，在文本机器学习和数据挖掘相关任务中有许多类型的问题和挑战，我们应该了解并选择适合我们的选项。</p><p id="861d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有许多其他的表示和距离/相似性函数，包括TfIdf和Word2Vec，它们是非常常见的文本表示(我希望我会再写一篇文章)。</p></div></div>    
</body>
</html>