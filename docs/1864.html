<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-what-it-is-and-why-it-should-interest-you-97fcf3f68d04?source=collection_archive---------2-----------------------#2017-11-05">https://towardsdatascience.com/machine-learning-what-it-is-and-why-it-should-interest-you-97fcf3f68d04?source=collection_archive---------2-----------------------#2017-11-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><p id="d5f5" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">机器学习——它是什么，为什么你会感兴趣！</p><p id="c026" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">机器学习是使用算法来识别模式和/或基于输入数据集进行预测的概念。有很多种算法可用，每种算法都有自己的优缺点和复杂程度。这些算法很容易获得，并且可以通过许多编程工具(R 和 Python 以及许多其他工具)以不同的编码需求级别进行访问。它们可以消除对专门为您的应用定制的详细编码指令的需要，而是使用大量通用指令。</p><p id="0afc" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">机器学习与经典计算的不同之处在于，它能够“学习”并(根据设定的参数)决定如何构建自身以实现最佳结果。例如，它可以访问用于测量模型准确性的指标来更改参数，从而进行自我优化。</p><p id="06b2" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">机器学习代表了高级分析的未来，或者说是现在。当您或分析师完成数据收集和高级分析后，也许是时候考虑机器学习，而不是通过 Excel 等工具强行推出高级解决方案了。机器学习提供了快速、准确和灵活的解决方案，这可能代表着企业分析的下一步。</p><p id="7e65" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">机器学习可以分为有监督和无监督的算法，然后进一步分为它们试图实现的输出类型——分类、回归或聚类。为了阐明这三种输出类型之间的差异，让我们考虑一个基于一组人的属性的数据集。分类可能涉及尝试将每个人标记为“矮”或“高”，回归将尝试预测每个人的身高，聚类是指没有身高标签，而是算法将基于相似的特征(例如，相似的体重或鞋码，这可能表明某人是高还是矮)将人聚类在一起。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi jo"><img src="../Images/ef55fca756c99967da3a7665e7a1aa14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CxmZga8rJ6h_ZTem6nK-cg.png"/></div></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk">Comparison of the three common output types produced through machine learning. Icons made by <a class="ae ke" href="http://www.freepik.com/" rel="noopener ugc nofollow" target="_blank">Freepik</a> from <a class="ae ke" href="https://www.flaticon.com/" rel="noopener ugc nofollow" target="_blank">www.flaticon.com</a> is licensed by <a class="ae ke" href="http://creativecommons.org/licenses/by/3.0/" rel="noopener ugc nofollow" target="_blank">CC 3.0 BY</a></figcaption></figure><p id="2c34" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">随机森林是一种监督学习算法，是一种常用于分类或回归问题的更简单的解决方案。该算法试图建立一个决策“树”的“森林”,然后可用于集体预测结果。决策树只是在得出结果之前所做决策的映射。例如，对于问题“我需要一杯咖啡吗？”影响我决策的一些变量可能是“太阳还没升起吗？”，“我已经喝了五杯咖啡了吗？”，“我在上班吗？”等等。这个关键问题的决策树如下所示。在每一个决定中，如果答案是“是”,树向左移动，如果答案是“否”,树向右移动。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/2b061d37a4fe2b6f4c6f9ec8774a8269.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*qR3r-3H63rSOsxKywKioWw.png"/></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk">My personal decisioning process for grabbing a coffee. This is a slow decision process without machine learning…</figcaption></figure><p id="62e5" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">在随机森林机器学习场景中，森林可能由数百个决策树组成，这些决策树都基于训练数据集的随机子部分。当向模型提供新数据(测试集)时，每一行(观察值)都经过所有决策树，每一棵树都提供一个建议的分类。由最大数量的树提供的分类是由算法选择并返回的分类。数据子集选择的随机性质是该算法的特征之一，这使得它非常健壮。结合其易于应用的特点，随机森林通常是许多数据科学家最先使用的机器学习算法之一。</p><p id="ae81" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">这篇博客的其余部分确实变得稍微更具技术性，通过一个工作实例给你一个更深入的介绍。请不要停止阅读，因为我希望故事的其余部分仍然有趣，并希望对任何考虑学习更多机器学习的人有所帮助！</p><p id="03d9" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">在我们的例子中，我们创建了一个虚拟的房价数据集，包含五个可变列，包括卧室、浴室和停车位的数量，以及街区大小和建造年份。该活动的目的是建立一个模型，根据可用的相同变量来预测任何未来房屋的价值。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi kg"><img src="../Images/ec2f4df0df53b1c627eb3be9a744f35d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*J31IFeaSkn9motNu7aSqrg.png"/></div></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk">Sample house price data set. 2000 rows of data with 1- 4 bedroom properties, varying numbers of bathrooms, parking spaces and block sizes and ultimately varying final values.</figcaption></figure><p id="ce8f" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">构建定价模型是一项非常开放的任务，因为它可以以用户认为合适的任何方式进行，从完全手动(笔、纸和本能)到 Excel 中的半自动建模，甚至是人工智能和深度学习/神经网络。我们将看到的解决方案将使用一个在 r 中生成的简单的二叉决策树。</p><p id="db96" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">在这种情况下，手动准备模型不会太困难，因为只有五个变量。如果这个例子是真实世界中更典型的情况，我们可能会有更多的列，这将成倍增加复杂性。当将来需要包含额外的功能时，手动模型也可能变得具有挑战性。该模型将需要修改，并且取决于它是如何建立的，可能需要相当大的努力。此外，模型的质量严重依赖于准备模型的个人或团队，这给长期可靠性带来了风险。</p><p id="515a" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">我们的 2，000 行数据集的前 1，400 行被分成“训练”集，其余 600 行被分成“测试”集。这样做的原因是允许模型访问前 1，400 行，使其能够了解值的最佳预测值。该模型应用于测试集以预测值，并允许我们检查准确性。这样做有多种原因，但其中一个原因是为了减少“过拟合”的可能性，即模型完美地预测了训练数据集的结果，但不够通用，无法准确预测新的观察结果。</p><p id="2c8c" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">在 R 中创建了一个二叉决策树(每个决策有两个可能的结果),以根据训练数据集提供预测的属性值。像 R 中使用的许多算法一样，有一系列“控制参数”代表算法的限制。如果没有输入值，R 通常会插入自己的默认值，这些值在第一次决策树尝试中使用过。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi kh"><img src="../Images/37f8247d88a568f5e187500ff0bd8061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nTGBCoV7rRGr3jUefU1pEw.png"/></div></div></figure><p id="039f" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">令人惊讶的是，即使考虑到少量的变量，这个决策树也非常简单。通常，决策树的第一次迭代可能非常复杂，需要“修剪”。浴室的数量和街区的大小并没有出现在树中，所以这些变量的“重要性”被重新评估。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi ki"><img src="../Images/edc7aecff0bbdfbf49a779f798d1f162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V1FPr2a3ib_-mWzowyDjXw.png"/></div></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk">Variable importance for original binary decision tree.</figcaption></figure><p id="d432" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">正如我们所看到的，“卧室”是最重要的变量，紧随其后的是“街区大小”和“停车位”，然而后两个变量没有出现在树中。先前，默认设置用于控制参数。对这些数字进行了调整，以定义决策树中允许的层数，以及需要落入树的最终“叶子”之一的训练集中的最小观察数。原始决策树中的所有绿色方框代表叶子，因为在这些方框之后没有决策。每个叶子代表来自模型的潜在输出，并且如果少于来自训练集的定义数量的观察值到达该叶子，则该叶子被从树上“修剪”掉。这种修剪减少了过度拟合的可能性，因为它使模型更简单，因此更通用。它还降低了树的复杂性，从而使树运行得更快。</p><p id="0785" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">一旦调整了控制参数，就产生了新的树。</p><figure class="jp jq jr js gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi kj"><img src="../Images/ebdf5cba139c06c32960199a9e8906d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K3NRlm12m6Y7qm7ycJZEMw.png"/></div></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk">New decision tree with adjusted control parameters.</figcaption></figure><p id="ecfe" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">新的决策树变得更加复杂，现在包括了“街区大小”和“浴室”变量。均方根误差(RMSE)通常用于确定机器学习算法的准确性。第二个模型使用这种方法大约精确 40%,训练集和测试集的 RMSE 值非常相似，表明该模型没有过度拟合。基于精度的提高，第二棵树可能是一个更好的选择，因为它看起来没有不必要的复杂，并且提供了显著的精度提高。</p><p id="88a4" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">这篇博客的目的是提供一些关于机器学习如何能够很容易地应用于解决现实世界问题的说明。这个简单的值预测函数只是一个例子，其中机器学习可以用来避免建立一个潜在的僵化和复杂的手动模型，并最终节省时间和精力。有很多很棒的(而且免费！)在线资源，如果这激起了您了解更多信息的欲望！</p><p id="f50c" class="pw-post-body-paragraph io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ij bi translated">祝你好运！</p></div></div>    
</body>
</html>