<html>
<head>
<title>Speeding up your code (1): the example of the mean shift clustering in Poincaré ball space</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加速你的代码(1):庞加莱球空间中均值漂移聚类的例子</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/speeding-up-your-code-1-the-example-of-the-mean-shift-clustering-in-poincar%C3%A9-ball-space-d46169bfdfc8?source=collection_archive---------7-----------------------#2017-08-13">https://towardsdatascience.com/speeding-up-your-code-1-the-example-of-the-mean-shift-clustering-in-poincar%C3%A9-ball-space-d46169bfdfc8?source=collection_archive---------7-----------------------#2017-08-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9f39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来自本系列:</p><ol class=""><li id="b2b1" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">庞加莱球空间中均值漂移聚类的例子(本帖)</li><li id="7ddf" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><a class="ae kz" href="https://medium.com/@vincenzo.lavorini/speeding-up-your-code-2-vectorizing-the-loops-with-numpy-e380e939bed3" rel="noopener">用Numpy对循环进行矢量化</a></li><li id="a59f" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><a class="ae kz" href="https://medium.com/@vincenzo.lavorini/speeding-up-your-code-3-batches-and-multiprocess-52d2d34a4091" rel="noopener">批处理和多线程</a></li><li id="0497" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><a class="ae kz" href="https://medium.com/@vincenzo.lavorini/speeding-up-your-code-4-in-time-compilation-with-numba-177d6849820e" rel="noopener">用Numba实时编译</a></li></ol><p id="c91d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你好社区！</p><p id="5f65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一系列文章中的第一篇，我将描述使用Python和Numpy构建快速聚类算法的步骤，该算法将在特定的“双曲线”空间中使用。</p><p id="82b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我想展示一个真实的开发案例，所以在第一篇文章中，我将描述我必须达到的目标，详细描述我必须实现目标的环境以及我在那里的原因，然后是代码的第一个原始版本。</p><p id="c214" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以让我们开始吧！</p><h2 id="f696" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">为什么会这样？</h2><p id="95ed" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">2017年5月，在《人工智能世界》杂志上，来自脸书人工智能研究所的Maximilian Nickel和Douwe Kiela发表了一篇<a class="ae kz" href="https://arxiv.org/abs/1705.08039" rel="noopener ugc nofollow" target="_blank">论文</a>。这篇论文的内容有望对代表学习领域产生巨大的影响。</p><p id="ecdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">严格来说，表示学习技术的目标是翻译属于一个集合(例如，一本书)的对象(例如，单词)的“含义”，考虑到它们之间存在的属性(例如，语义)，目标是具有一个随后可以被AI算法使用的基础。对象表现得越好，后续的算法就越有效。</p><p id="386c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些技术的尖端使用“嵌入”:每个对象由多维空间中的一个点来表示，并且该点将理想地“嵌入”该对象相对于集合所具有的所有属性。因此，具有相似含义的对象将发现它们的嵌入在几何上彼此接近。这就是为什么我必须建立一个聚类算法。</p><p id="b561" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种多维空间通常是“平面”型的，也就是说，具有我们在现实空间中看到的几何性质，也就是我们在学校里学过的那些。相反，在提到的论文中，他们使用了一个特殊的“弯曲”空间:庞加莱球模型。这是因为这种空间非常适合表示层次结构，因此集合中的潜在层次结构很容易表示。事实上，它们使用低得多的维度在许多领域显示了最先进的结果。</p><p id="01a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个庞加莱球是什么样子的？作为例子，下面有两个二维球(即一个圆)表示。你看到的弧线就是所谓的“<a class="ae kz" href="https://en.wikipedia.org/wiki/Geodesic" rel="noopener ugc nofollow" target="_blank">测地线</a>，也就是两点之间最短的步行距离。这是相对于“平坦的”欧几里得空间的最明显的区别之一，在欧几里得空间中，点之间的最短穿行是一条直线。另一个很大的不同是，在圆之外没有任何东西可以存在:实际上，离中心很远的点(“在无穷远处”)位于圆盘圆周上。因此，连接你在左图中看到的点的弧线都有相同的长度。令人兴奋，不是吗？</p><div class="ly lz ma mb gt ab cb"><figure class="mc md me mf mg mh mi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><img src="../Images/d2077f21e160a699e5a2ac79786da3d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*N45ub2ymOpWOF79UmuPOVA.png"/></div></figure><figure class="mc md mp mf mg mh mi paragraph-image"><img src="../Images/ab8eed0739dc7047d8377c41618d7d28.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/1*gU80MiPQhUa0_Qla-D8Q4Q.gif"/><figcaption class="mq mr gj gh gi ms mt bd b be z dk mu di mv mw">Left: the lines connecting the points have all the same distance. Right: the animation of a rotation within the Poincaré disk. Credits: <a class="ae kz" href="http://mathworld.wolfram.com/PoincareHyperbolicDisk.html" rel="noopener ugc nofollow" target="_blank">Wolfram.com</a></figcaption></figure></div><h2 id="59ce" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">目标</h2><p id="b585" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">我必须建立一个算法，将空间中彼此靠近的点组合在一起。我需要这个算法在没有预先指定聚类数的情况下工作。然后我选择<a class="ae kz" href="https://en.wikipedia.org/wiki/Mean_shift" rel="noopener ugc nofollow" target="_blank">均值漂移</a>程序。</p><p id="37d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该过程将每个点向其最近的点群移动，并且单个参数定义了最近的点群有多远。如果最近的大块太远，该点将自己形成一个孤立的簇。</p><p id="349e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是二维庞加莱盘中结果的动画，其中算法将以13个聚类结束:</p><figure class="ly lz ma mb gt md gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mx"><img src="../Images/43863b466c1495b6cbc1cfeb01dde7cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*SrVWzTejlFfhhAgSJEYYpQ.gif"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Mean shift clustering in Poicaré disk.</figcaption></figure><p id="0fa5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以注意到，圆边界附近的点(相对距离似乎很小)不会聚集。相反，靠近圆心的点，其相对距离似乎比圆周上的点要大，实际上会聚集在一起。</p><p id="4855" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们所在的弯曲空间的影响，庞加莱球:正如我已经提到的，你离中心越远，距离实际上就越大，比你在照片上看到的要大。</p><p id="7cb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以说很多细节，但那超出了本帖的范围。但是，如果你想了解更多关于均值漂移过程和花哨的庞加莱球空间模型，只需搜索网络，有大量的资源。</p><h2 id="a761" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">履行</h2><p id="d9f3" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">描述性地，为了实现均值漂移过程，我们必须用所有其他点的加权和来代替每个点<em class="my"> P </em>。应用于每个点的权重取决于它与所考虑的点的距离(<em class="my"> P </em>)。并且必须重复这个过程，直到所有的点都聚集在一起。</p><p id="bf64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在网上找到该算法的几种实现，基本上适用于每种编程语言。但是没有人会在这个空间工作！</p><p id="7781" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原因是我们计算点与点之间距离的方式。所有这些算法都是为在“平坦的”欧几里得空间中工作而设计的，因此它们以欧几里得方式计算点之间的距离。相反，在这个特定的空间中，距离是更复杂的。</p><p id="d267" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是用Python和Numpy写的基本代码。我从杰瑞米·霍华德<a class="mz na ep" href="https://medium.com/u/34ab754f8c5e?source=post_page-----d46169bfdfc8--------------------------------" rel="noopener" target="_blank">的精彩</a><a class="ae kz" href="http://course.fast.ai/lessons/lesson11.html" rel="noopener ugc nofollow" target="_blank">课程</a>中得到这个版本:</p><figure class="ly lz ma mb gt md"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">The basic code</figcaption></figure><p id="85ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个通用的meanshift实现。对于我们的例子，区别在于我们定义点之间的区别的方式:</p><figure class="ly lz ma mb gt md"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="0dee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，Numpy的<a class="ae kz" href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" rel="noopener ugc nofollow" target="_blank">广播</a>功能在编写简单代码方面帮助很大。为了理解广播，请看高斯函数:它接受两个元素作为输入(<em class="my"> d </em>作为距离，<em class="my"> bw </em>作为带宽)。它们都可以是数字，或者任何n维数组(向量、矩阵、张量)，如果它们的形状兼容，Numpy会知道如何以适当的方式处理它们。在我们的例子中，我们为函数提供一个向量(<em class="my"> dists </em>)和一个数字(sigma)。</p><p id="f9ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了完整起见，庞加莱球模型中两点之间的距离定义为:</p><figure class="ly lz ma mb gt md gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/3033ee85e1ba609d9293033eb82bee6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/1*sr0-rzX9VEzb8szDp7WqjA.gif"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Definition of distance in the Poincaré Ball space</figcaption></figure><p id="b924" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，搞定了？是也不是。它是有效的，你之前看到的动画就是用这种算法制作的。但是很慢:在我的笔记本电脑(i7–4750 HQ CPU @ 2.00 GHz，8GB RAM)上，对于集群1200点，每步需要14秒，算法收敛需要10步。</p><p id="e470" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我需要改进代码。</p><h2 id="4202" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">加快代码速度</h2><p id="631d" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">可以做很多很好的尝试来改进它:使用近似技术、随机矩阵、多线程、GPU等等。</p><figure class="ly lz ma mb gt md gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/75cf37601bccda1cc3bbe40566557d62.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*qs65guoEgvy_hLF81Fvzug.jpeg"/></div></figure><p id="cd68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但我们是程序员，有义务多动脑，少蛮力。所以我想尝试的第一个尝试是<a class="ae kz" href="https://en.wikipedia.org/wiki/Array_programming" rel="noopener ugc nofollow" target="_blank">向量化</a>两个循环:一个在<em class="my"> dist_poinc </em>函数中，另一个在mean算法中。</p><p id="471a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一篇文章中，我会展示原因和结果。但是作为开胃菜，看看这个情节:</p><figure class="ly lz ma mb gt md gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/339ec257968da4ff533407665b478f33.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*SdJ8OYFY8IgpMGMJKxH84g.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Percentage of execution time of a vectorized product with respect to a looped one.</figcaption></figure><p id="1dbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，你读得不错:一个简单操作的矢量化版本的执行时间不到完成循环所需时间的1.3%。</p><p id="0fb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">难道不值得一试吗？</p></div></div>    
</body>
</html>