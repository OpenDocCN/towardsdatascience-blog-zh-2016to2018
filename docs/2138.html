<html>
<head>
<title>Simulating Text With Markov Chains in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python中的马尔可夫链模拟文本</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/simulating-text-with-markov-chains-in-python-1a27e6d13fc6?source=collection_archive---------2-----------------------#2017-12-22">https://towardsdatascience.com/simulating-text-with-markov-chains-in-python-1a27e6d13fc6?source=collection_archive---------2-----------------------#2017-12-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cfd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的上一篇文章中，我在马尔可夫链蒙特卡罗方法的背景下介绍了马尔可夫链。这篇文章是那篇文章的一个小附录，展示了你可以用马尔可夫链做的一件有趣的事情:模拟文本。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/20c550dff38d392aa1d586f3bb3288fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uwVjPMrF_ApTINCCWxqy7g.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Pixabay</figcaption></figure><p id="81a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">马尔可夫链是一个模拟的事件序列。序列中的每个事件都来自一系列相互依赖的结果。特别是，每个结果决定了接下来可能会发生哪些结果。在马尔可夫链中，预测下一个事件所需的所有信息都包含在最近的事件中。这意味着知道马尔可夫链的全部历史并不能比只知道上一个结果更好地帮助你预测下一个结果。</p><p id="9f92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">马尔可夫链通常不是近期事件的可靠预测，因为现实世界中的大多数过程比马尔可夫链允许的要复杂得多。然而，马尔可夫链被用来检验一系列事件的长期行为，这些事件以固定的概率相互关联。</p><p id="4b60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于世界上非独立事件的任何序列，并且在有限数量的结果可能发生的情况下，可以计算将每个结果相互关联的条件概率。通常情况下，这只是简单地采取计算特定结果在观察到的序列中一个接一个出现的频率的形式。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="0380" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要生成基于某个文本的模拟，请计算使用的每个单词。然后，对于每个单词，存储下一个使用的单词。这是文本中单词的分布<em class="kl">取决于</em>前面的单词。</p><p id="3f35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了模拟唐纳德·特朗普的一些文字，让我们使用他在2016年竞选中的演讲集<a class="ae lj" href="https://github.com/ryanmcdermott/trump-speeches" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="90f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先导入numpy和包含特朗普演讲的文本文件:</p><pre class="kn ko kp kq gt lk ll lm ln aw lo bi"><span id="16c5" class="lp lq iq ll b gy lr ls l lt lu">import numpy as np<br/>trump = open('speeches.txt', encoding='utf8').read()</span></pre><p id="034e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，将文本文件拆分成单个单词。注意，我们保留了所有的标点符号，所以我们的模拟文本有标点符号:</p><pre class="kn ko kp kq gt lk ll lm ln aw lo bi"><span id="24eb" class="lp lq iq ll b gy lr ls l lt lu">corpus = trump.split()</span></pre><p id="2c25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们定义一个函数来给出演讲中所有的词对。我们使用惰性求值，产生一个生成器对象，而不是用每一对单词填充我们的内存:</p><pre class="kn ko kp kq gt lk ll lm ln aw lo bi"><span id="672c" class="lp lq iq ll b gy lr ls l lt lu">def make_pairs(corpus):<br/>    for i in range(len(corpus)-1):<br/>        yield (corpus[i], corpus[i+1])<br/>        <br/>pairs = make_pairs(corpus)</span></pre><p id="310c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们实例化一个空字典，并用我们对中的单词填充它。如果单词对中的第一个单词已经是字典中的一个关键字，只需将下一个单词添加到该单词后面的单词列表中。否则，在字典中初始化一个新条目，其键等于第一个单词，值为长度为1的列表:</p><pre class="kn ko kp kq gt lk ll lm ln aw lo bi"><span id="e89b" class="lp lq iq ll b gy lr ls l lt lu">word_dict = {}</span><span id="a63f" class="lp lq iq ll b gy lv ls l lt lu">for word_1, word_2 in pairs:<br/>    if word_1 in word_dict.keys():<br/>        word_dict[word_1].append(word_2)<br/>    else:<br/>        word_dict[word_1] = [word_2]</span></pre><p id="782c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们随机挑选一些单词来启动这个链，并选择我们想要模拟的单词数量:</p><pre class="kn ko kp kq gt lk ll lm ln aw lo bi"><span id="60c8" class="lp lq iq ll b gy lr ls l lt lu">first_word = np.random.choice(corpus)</span><span id="447a" class="lp lq iq ll b gy lv ls l lt lu">chain = [first_word]</span><span id="d755" class="lp lq iq ll b gy lv ls l lt lu">n_words = 30</span></pre><p id="ce37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第一个单词之后，链中的每个单词都是从特朗普实际演讲中跟随该单词的单词列表中随机抽取的:</p><pre class="kn ko kp kq gt lk ll lm ln aw lo bi"><span id="cbc3" class="lp lq iq ll b gy lr ls l lt lu">for i in range(n_words):<br/>    chain.append(np.random.choice(word_dict[chain[-1]]))</span></pre><p id="c612" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一个<code class="fe lw lx ly ll b">join</code>命令以字符串形式返回链:</p><pre class="kn ko kp kq gt lk ll lm ln aw lo bi"><span id="7487" class="lp lq iq ll b gy lr ls l lt lu">' '.join(chain)</span></pre><p id="b0b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我运行这段代码时，我的第一个结果是:</p><blockquote class="lz ma mb"><p id="833a" class="jn jo kl jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated">我将能够投票。找回来了。我们要编造一个彻头彻尾的谎言，然后被证明。“期间正好相反。我们有一些出席者。我的病人真的</p></blockquote></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="5116" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里好的一点是，我们使用字典实际上是在链中查找下一个单词。当然，您可以将所有这些都打包到一个函数中，我将它作为一个练习留给读者。</p><p id="ad4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有很多工具可以用来发'<a class="ae lj" href="https://github.com/jsvine/markovify" rel="noopener ugc nofollow" target="_blank">马克维奇</a>'短信，我鼓励你去查一下。但是对于刚刚学习马尔可夫链的人来说，这里的代码是一个容易的起点。但是改进的可能性是无限的。例如，您可能要求第一个单词大写，这样您的文本就不会从句子中间开始:</p><pre class="kn ko kp kq gt lk ll lm ln aw lo bi"><span id="5927" class="lp lq iq ll b gy lr ls l lt lu">while first_word.islower():<br/>    first_word = np.random.choice(corpus)</span></pre><p id="6ab7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这有助于你们开始进入马尔可夫链的广阔世界。如果这段代码可以在不牺牲清晰度的情况下得到改进，请留下评论！</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure></div></div>    
</body>
</html>