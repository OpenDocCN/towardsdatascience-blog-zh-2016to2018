<html>
<head>
<title>Controlling the Web with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 控制 Web</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/controlling-the-web-with-python-6fceb22c5f08?source=collection_archive---------0-----------------------#2018-03-10">https://towardsdatascience.com/controlling-the-web-with-python-6fceb22c5f08?source=collection_archive---------0-----------------------#2018-03-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/6c86771c2262dc4a3e3f2b3ba006ce4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yn4G6YMwJz2wecPROKMZAA.jpeg"/></div></div></figure><div class=""/><p id="513e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">简单网络自动化的冒险</strong></p><p id="0ca3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">问题:</strong>提交课堂作业需要浏览错综复杂的网页，以至于好几次我都把作业提交错了地方。此外，虽然这个过程只需要 1-2 分钟，但有时它似乎是一个不可逾越的障碍(比如当我晚上很晚才完成一项任务，而我几乎记不起我的密码)。</p><p id="8ffa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">解决方案:</strong>使用 Python 自动提交完成的作业！理想情况下，我将能够保存一个任务，键入几个键，并在几秒钟内上传我的工作。起初，这听起来好得难以置信，但后来我发现了<a class="ae kw" href="https://selenium-python.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"> selenium </a>，一个可以与 Python 一起使用来为你导航网络的工具。</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/d708c36470f3c501ebe45ce3afd2ecc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/0*ZglaEb3qQK6xCBC6.png"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk"><a class="ae kw" href="https://xkcd.com/353/" rel="noopener ugc nofollow" target="_blank">Obligatory XKCD</a></figcaption></figure></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><p id="b12b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当我们发现自己在网上用同样的步骤重复单调乏味的动作时，这是一个编写程序来自动化这个过程的好机会。使用 selenium 和 Python，我们只需要编写一次脚本，然后我们可以多次运行它，避免重复单调的任务(在我的例子中，消除了在错误的地方提交任务的机会)！</p><p id="1d75" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我将介绍我开发的自动(并且正确地)提交作业的解决方案。同时，我们将介绍使用 Python 和 selenium 以编程方式控制 web 的基础知识。虽然这个程序确实有效(我每天都在使用它！)这是非常定制的，所以您不能为您的应用程序复制和粘贴代码。尽管如此，这里的通用技术可以应用于无限多的情况。(如果你想看完整的代码，可以在 GitHub 上找到<a class="ae kw" href="https://gist.github.com/WillKoehrsen/127fb3963b12b4f0b339ff0c8ee14558" rel="noopener ugc nofollow" target="_blank">)。</a></p><h1 id="b4d4" class="ln lo jb bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">方法</h1><p id="0da5" class="pw-post-body-paragraph jy jz jb ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">在我们开始自动化 web 的有趣部分之前，我们需要弄清楚我们解决方案的总体结构。没有计划就直接开始编程是在沮丧中浪费很多时间的一个好方法。我想写一个程序，把完成的课程作业提交到画布上正确的位置(我大学的<a class="ae kw" href="https://en.wikipedia.org/wiki/Learning_management_system" rel="noopener ugc nofollow" target="_blank">“学习管理系统】</a>)。从基础开始，我需要一种方法来告诉程序要提交的作业的名称和类。我采用了一种简单的方法，创建了一个文件夹来存放每门课的已完成作业及其子文件夹。在子文件夹中，我放置了为特定任务命名的完整文档。该程序可以从文件夹中找出类名，并通过文档标题指定名称。</p><p id="459c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个例子，类名是 EECS491，作业是“作业 3——大型图形模型中的推理”。</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/d6f686464e3dd1ce78d114081eeee65c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*3WzLi_pB4gI999Xzp_tBrQ.png"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">File structure (left) and Complete Assignment (right)</figcaption></figure><p id="64fb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">程序的第一部分是一个遍历文件夹的循环，以找到我们存储在 Python 元组中的赋值和类:</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="5355" class="mw lo jb ms b gy mx my l mz na"># os for file management<br/>import os</span><span id="677e" class="mw lo jb ms b gy nb my l mz na"># Build tuple of (class, file) to turn in<br/>submission_dir = 'completed_assignments'</span><span id="511f" class="mw lo jb ms b gy nb my l mz na">dir_list = list(os.listdir(submission_dir))</span><span id="6f42" class="mw lo jb ms b gy nb my l mz na">for directory in dir_list:<br/>    file_list = list(os.listdir(os.path.join(submission_dir, <br/>directory)))<br/>    if len(file_list) != 0:<br/>        file_tup = (directory, file_list[0])<br/>    <br/>print(file_tup)</span><span id="f104" class="mw lo jb ms b gy nb my l mz na"><strong class="ms jc">('EECS491', 'Assignment 3 - Inference in Larger Graphical Models.txt')</strong></span></pre><p id="a9db" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这负责文件管理，程序现在知道要上交的程序和作业。下一步是使用 selenium 导航到正确的网页并上传作业。</p><h2 id="82e1" class="mw lo jb bd lp nc nd dn lt ne nf dp lx kj ng nh mb kn ni nj mf kr nk nl mj nm bi translated">使用 Selenium 的 Web 控件</h2><p id="12d2" class="pw-post-body-paragraph jy jz jb ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">为了开始使用 selenium，我们导入这个库并创建一个 web 驱动程序，这是一个由我们的程序控制的浏览器。在这种情况下，我将使用 Chrome 作为我的浏览器，并将驱动程序发送到我提交作业的 Canvas 网站。</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="d9a6" class="mw lo jb ms b gy mx my l mz na">import selenium</span><span id="ebe4" class="mw lo jb ms b gy nb my l mz na"># Using Chrome to access web<br/>driver = webdriver.Chrome()</span><span id="88f2" class="mw lo jb ms b gy nb my l mz na"># Open the website<br/>driver.get('<a class="ae kw" href="https://canvas.case.edu'" rel="noopener ugc nofollow" target="_blank">https://canvas.case.edu'</a>)</span></pre><p id="0f22" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们打开画布网页时，迎接我们的第一个障碍是一个登录框！要通过这一步，我们需要填写 id 和密码，然后单击登录按钮。</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nn"><img src="../Images/bce12e5defe0700072999546db25287e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*6K21H6TqFp52ilxqhnyJ7g.png"/></div></div></figure><p id="bb47" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">把网络驱动想象成一个从未见过网页的人:我们需要准确地告诉它点击哪里，键入什么，按哪个按钮。有许多方法可以告诉我们的 web 驱动程序要查找什么元素，所有这些方法都使用了选择器。一个<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Selectors" rel="noopener ugc nofollow" target="_blank">选择器</a>是网页上一个元素的唯一标识符。为了找到特定元素的选择器，比如上面的 CWRU ID 框，我们需要检查网页。在 Chrome 中，这是通过按“ctrl + shift + i”或右键单击任何元素并选择“Inspect”来完成的。这带来了<a class="ae kw" href="https://developer.chrome.com/devtools" rel="noopener ugc nofollow" target="_blank"> Chrome 开发者工具</a>，这是一个非常有用的应用程序，可以显示任何网页下面的<a class="ae kw" href="https://www.pathinteractive.com/blog/design-development/rendering-a-webpage-with-google-webmaster-tools/" rel="noopener ugc nofollow" target="_blank"> HTML。</a></p><p id="61e0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了找到“CWRU ID”框的选择器，我在框中单击鼠标右键，点击“Inspect ”,并在开发工具中看到以下内容。突出显示的行对应于 id box 元素(这一行称为 HTML 标记)。</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/4c8f57536b7b1f7c7e59f14230d27bc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*smbJ9oczUAAZ5aSCREAvWA.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">HTML in Chrome developer tools for the webpage</figcaption></figure><p id="a811" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个 HTML 可能看起来让人不知所措，但是我们可以忽略大部分信息，只关注<code class="fe np nq nr ms b">id = "username"</code>和<code class="fe np nq nr ms b">name="username"</code>部分。(这些被称为 HTML 标签的属性)。</p><p id="33ac" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要用我们的 web 驱动程序选择 id 框，我们可以使用在开发工具中找到的<code class="fe np nq nr ms b">id</code>或<code class="fe np nq nr ms b">name</code>属性。selenium 中的 Web 驱动程序有许多不同的方法来选择网页上的元素，并且通常有多种方法来选择完全相同的项目:</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="6def" class="mw lo jb ms b gy mx my l mz na"># Select the id box<br/>id_box = driver.find_element_by_name('username')</span><span id="680d" class="mw lo jb ms b gy nb my l mz na"># Equivalent Outcome! <br/>id_box = driver.find_element_by_id('username')</span></pre><p id="0f66" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的程序现在可以访问<code class="fe np nq nr ms b">id_box</code>，我们可以用各种方式与它交互，比如键入按键，或者点击(如果我们选择了一个按钮)。</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="d39e" class="mw lo jb ms b gy mx my l mz na"># Send id information<br/>id_box.send_keys('my_username')</span></pre><p id="ad2c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们对密码框和登录按钮执行相同的过程，根据我们在 Chrome 开发者工具中看到的内容来选择它们。然后，我们向元素发送信息，或者根据需要点击它们。</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="a82d" class="mw lo jb ms b gy mx my l mz na"># Find password box<br/>pass_box = driver.find_element_by_name('password')</span><span id="0bc4" class="mw lo jb ms b gy nb my l mz na"># Send password<br/>pass_box.send_keys('my_password')</span><span id="f702" class="mw lo jb ms b gy nb my l mz na"># Find login button<br/>login_button = driver.find_element_by_name('submit')</span><span id="441a" class="mw lo jb ms b gy nb my l mz na"># Click login<br/>login_button.click()</span></pre><p id="6605" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">登录后，我们会看到这个有点吓人的仪表板:</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ns"><img src="../Images/6efbfed6eaf8d69240883e3506b45fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jG-_h99LhbiWsJSeMwSGaw.png"/></div></div></figure><p id="61ca" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们再次需要通过准确指定点击的元素和输入的信息来引导程序浏览网页。在这种情况下，我告诉程序从左边的菜单中选择课程，然后选择与我需要上交的作业相对应的课程:</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="e83b" class="mw lo jb ms b gy mx my l mz na"># Find and click on list of courses<br/>courses_button = driver.find_element_by_id('global_nav_courses_link')</span><span id="f6dd" class="mw lo jb ms b gy nb my l mz na">courses_button.click()</span><span id="a4e7" class="mw lo jb ms b gy nb my l mz na"># Get the name of the folder<br/>folder = file_tup[0]<br/>    <br/># Class to select depends on folder<br/>if folder == 'EECS491':<br/>    class_select = driver.find_element_by_link_text('Artificial Intelligence: Probabilistic Graphical Models (100/10039)')</span><span id="8058" class="mw lo jb ms b gy nb my l mz na">elif folder == 'EECS531':<br/>    class_select = driver.find_element_by_link_text('Computer Vision (100/10040)')</span><span id="d1e1" class="mw lo jb ms b gy nb my l mz na"># Click on the specific class<br/>class_select.click()</span></pre><p id="058f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">程序使用我们在第一步中存储的文件夹的名称找到正确的类。在这种情况下，我使用选择方法<code class="fe np nq nr ms b">find_element_by_link_text</code>来查找特定的类。元素的“链接文本”只是我们可以通过检查页面找到的另一个选择器。：</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nt"><img src="../Images/bd574a44b8371609c8ce338c32b9cdbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KAkAswxW6VGIkF-Vb1D-TA.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">Inspecting the page to find the selector for a specific class</figcaption></figure><p id="77e8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个工作流程可能看起来有点乏味，但是记住，我们只需要在编写程序的时候做一次！之后，我们可以多次点击 run，程序会为我们导航所有这些页面。</p><p id="7a5f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用相同的“检查页面—选择元素—与元素交互”过程来通过几个屏幕。最后，我们到达作业提交页面:</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/8fce156f79eda4fbfb63aeb6178c1d85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iyz1HiKgExkyWmzW2M5Vxg.png"/></div></div></figure><p id="b654" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一点上，我可以看到终点线，但最初这个屏幕困扰着我。我可以很容易地点击“选择文件”框，但是我应该如何选择我需要上传的实际文件呢？答案非常简单！我们使用选择器定位<code class="fe np nq nr ms b">Choose File</code>框，并使用<code class="fe np nq nr ms b">send_keys</code>方法将文件的确切路径(在下面的代码中称为<code class="fe np nq nr ms b">file_location</code>)传递给该框:</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="0356" class="mw lo jb ms b gy mx my l mz na"># Choose File button<br/>choose_file = driver.find_element_by_name('attachments[0][uploaded_data]')</span><span id="f85b" class="mw lo jb ms b gy nb my l mz na"># Complete path of the file<br/>file_location = os.path.join(submission_dir, folder, file_name)</span><span id="c8e0" class="mw lo jb ms b gy nb my l mz na"># Send the file location to the button<br/>choose_file.send_keys(file_location)</span></pre><p id="a23d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！通过将文件的确切路径发送到按钮，我们可以跳过在文件夹中导航以找到正确文件的整个过程。发送位置后，我们会看到下面的屏幕，显示我们的文件已经上传，可以提交了。</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nv"><img src="../Images/c643ab5a25c8359fa08d21b970512722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RUaMhWWmRg47s10a8Pv6lg.png"/></div></div></figure><p id="0479" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们选择“提交作业”按钮，点击，我们的作业就上交了！</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="ca03" class="mw lo jb ms b gy mx my l mz na"># Locate submit button and click<br/>submit_assignment = driver.find_element_by_id('submit_file_button')<br/>submit_assignent.click()</span></pre><figure class="ky kz la lb gt is gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/723f257fc12072b409a38d350ef66816.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*dfC4W3awW86kw-KpQH-rOQ.png"/></div></figure><h2 id="50a3" class="mw lo jb bd lp nc nd dn lt ne nf dp lx kj ng nh mb kn ni nj mf kr nk nl mj nm bi translated">清理</h2><p id="75b2" class="pw-post-body-paragraph jy jz jb ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">文件管理始终是一个关键步骤，我想确保我不会重新提交或丢失旧的任务。我认为最好的解决方案是在任何时候都将提交的单个文件存储在<code class="fe np nq nr ms b">completed_assignments</code>文件夹中，并在文件提交后将其移动到<code class="fe np nq nr ms b">submitted_assignments</code>文件夹中。最后一段代码使用 os 模块，通过将已完成的赋值重命名为所需的位置来移动它:</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="6ad4" class="mw lo jb ms b gy mx my l mz na"># Location of files after submission<br/>submitted_file_location = os.path.join(submitted_dir, submitted_file_name)</span><span id="e4d6" class="mw lo jb ms b gy nb my l mz na"># Rename essentially copies and pastes files<br/>os.rename(file_location, submitted_file_location)</span></pre><p id="c3c2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有的后续代码都封装在一个脚本中，我可以从命令行运行这个脚本。为了减少出错的机会，我一次只提交一个作业，这没什么大不了的，因为运行这个程序只需要 5 秒钟。</p><p id="9065" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是我启动程序时的样子:</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nx"><img src="../Images/b166bd48fe6aa1253a6e077e845bceb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FK2MNOJQgCabZdXAEYT2Gw.png"/></div></div></figure><p id="e37f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个程序让我有机会在上传之前确认这是正确的作业。程序完成后，我得到以下输出:</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ny"><img src="../Images/5da9a5e126e2939d5b55b758450704da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fihdzm-vnWULTULOVI97JQ.png"/></div></div></figure><p id="2bd7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当程序运行时，我可以看到 Python 为我工作:</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nz"><img src="../Images/439a2de6403319a6fe2c753a61d8c8ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-drw9BuNnPEsDkm5TWRaOA.gif"/></div></div></figure><h1 id="2b4f" class="ln lo jb bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">结论</h1><p id="1dff" class="pw-post-body-paragraph jy jz jb ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">使用 Python 实现 web 自动化的技术对于许多任务都非常有用，无论是一般任务还是我的数据科学领域。例如，我们可以使用 selenium 每天自动下载新的数据文件(假设网站没有<a class="ae kw" href="https://en.wikipedia.org/wiki/Application_programming_interface" rel="noopener ugc nofollow" target="_blank"> API </a>)。虽然最初编写脚本看起来工作量很大，但好处在于我们可以让计算机以完全相同的方式多次重复这个序列。这个程序将永远不会失去焦点而偏离到 Twitter 上。它将忠实地执行完全一致的一系列步骤(这在网站改变之前非常有效)。</p><p id="c0ce" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我应该指出，在自动化关键任务之前，您确实需要小心谨慎。这个例子风险相对较低，因为我可以随时返回并重新提交作业，而且我通常会仔细检查程序的工作。网站会改变，如果你不相应地改变程序，你可能会得到一个脚本，它做的事情和你最初想做的完全不同！</p><p id="d2b1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就回报而言，这个程序为我每次作业节省了大约 30 秒，而我花了 2 个小时来写。所以，如果我用它来交 240 份作业，那么我就能按时完成了！然而，这个项目的回报是为一个问题设计一个很酷的解决方案，并在这个过程中学到很多东西。虽然我的时间本可以更有效地花在作业上，而不是解决如何自动上交作业，但我非常享受这个挑战。很少有事情像解决问题一样令人满意，而 Python 被证明是一个非常好的工具。</p><p id="49ea" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一如既往，我欢迎反馈和建设性的批评。可以通过推特<a class="ae kw" href="http://twitter.com/@koehrsen_will" rel="noopener ugc nofollow" target="_blank"> @koehrsen_will </a>联系到我。</p></div></div>    
</body>
</html>