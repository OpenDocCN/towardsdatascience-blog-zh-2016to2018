<html>
<head>
<title>DeepClassifyML Week 2 Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DeepClassifyML第2周第1部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deepclassifyml-week-2-part-1-1e1bafca79eb?source=collection_archive---------1-----------------------#2017-06-17">https://towardsdatascience.com/deepclassifyml-week-2-part-1-1e1bafca79eb?source=collection_archive---------1-----------------------#2017-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><p id="1532" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="ks">这篇文章是“Hasura实习”系列文章的一部分，涵盖了为其设置开发环境。查看</em> <a class="ae kt" href="https://medium.com/@akshaybhatia10/deepclassifyml-week-1-part-1-b1c53e0a7cc" rel="noopener"> <em class="ks">第一部分</em> </a> <em class="ks">、</em> <a class="ae kt" href="https://medium.com/towards-data-science/deepclassifyml-week-1-part-2-3b234ca3fcb4" rel="noopener"> <em class="ks">第二部分</em> </a> <em class="ks">了解app想法和一些计算机视觉和神经网络基础知识。</em></p><p id="5497" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">前两篇帖子得到了很大的反响，第二部分<a class="ae kt" href="https://medium.com/towards-data-science/deepclassifyml-week-1-part-2-3b234ca3fcb4" rel="noopener"><em class="ks"/></a><em class="ks"/>发表在<a class="ae kt" href="https://medium.com/towards-data-science" rel="noopener"> <em class="ks">【走向数据科学】</em> </a> <em class="ks">上。这篇文章将讲述如何为图像分类应用程序设置开发环境。我使用的是macOS X，但是这些说明适用于Windows、Mac OS X和Linux平台。这个项目的所有库都可以使用<a class="ae kt" href="https://pypi.python.org/pypi/pip" rel="noopener ugc nofollow" target="_blank"> <em class="ks"> pip </em> </a>或<a class="ae kt" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank"> <em class="ks"> brew </em> </a> <em class="ks">安装。</em>这个项目的主要库是<a class="ae kt" href="http://keras.io" rel="noopener ugc nofollow" target="_blank"> <em class="ks"> Keras </em> </a>(带<a class="ae kt" href="http://tensorflow.org" rel="noopener ugc nofollow" target="_blank"> <em class="ks"> Tensorflow </em> </a>后端)和<a class="ae kt" href="https://pypi.python.org/pypi/Flask/0.12.2" rel="noopener ugc nofollow" target="_blank"> <em class="ks"> Flask </em> </a>。如果想建立一个完整的机器学习环境，最好的办法就是安装<a class="ae kt" href="https://www.continuum.io/downloads" rel="noopener ugc nofollow" target="_blank"> <em class="ks"> Anaconda </em> </a>。它是一个开源平台，为数据科学和机器学习提供了100多个最流行的Python和R包。先从<a class="ae kt" href="https://www.continuum.io/downloads" rel="noopener ugc nofollow" target="_blank"> <em class="ks">这里</em> </a>安装Anaconda。确保选择适合您的平台(Windows、OSX或Linux)的下载选项和正确的python版本(2.7或3.5)。安装是一个快速简单的过程，应该不到10分钟(取决于您的连接)，并占用大约1 GB的驱动器空间。Anaconda附带了一套叫做Anaconda Navigator的图形工具。</em></p><p id="8109" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">深度学习部分，我推荐名为<a class="ae kt" href="http://conda.pydata.org/docs/index.html" rel="noopener ugc nofollow" target="_blank"> <em class="ks"> conda </em> </a>的Anaconda命令行环境。Conda快速、简单，很难隐藏错误消息，并且您可以快速确认您的环境已安装并正常工作。接下来的几个步骤在<a class="ae kt" href="https://github.com/leriomaggio/deep-learning-keras-tensorflow" rel="noopener ugc nofollow" target="_blank"> <em class="ks">这里</em> </a> <em class="ks"> </em>下<em class="ks"> </em>设置环境部分有很好的记录，所以我将跳过这一部分。另一个很棒的博文是<a class="ae kt" href="https://www.dataweekends.com/blog/2017/03/09/set-up-your-mac-for-deep-learning-with-python-keras-and-tensorflow" rel="noopener ugc nofollow" target="_blank"> <em class="ks">这里</em> </a>。</p><p id="3326" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在你有了一个工作的Python环境，可以开始学习、实践、开发和解决机器学习和深度学习问题。你也可以在这里 阅读<a class="ae kt" href="https://medium.com/@datitran" rel="noopener"> <em class="ks"> Dat Tran </em> </a>关于在AWS <a class="ae kt" href="https://medium.com/towards-data-science/using-docker-to-set-up-a-deep-learning-environment-on-aws-6af37a78c551" rel="noopener"> <em class="ks">上建立深度学习环境的一篇很棒的帖子。</em></a></p><p id="5eed" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">深度学习需要数学。因此，在开始构建我们自己的神经网络之前，理解基础知识非常重要。这篇文章旨在提供一个关于线性代数的vert简短复习，以及一些使用已经预装在Anaconda中的<a class="ae kt" href="http://www.numpy.org/" rel="noopener ugc nofollow" target="_blank"> NumPy </a>库的指导，以便在Python中有效地处理矩阵。那我们开始吧。(<em class="ks">注:需要基本的Python编程</em>)</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/0ce4fa844291181cb3f7589758bbe481.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*mmCWDvPgmTsCmn8I0EcnzQ.jpeg"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">Numpy</figcaption></figure><p id="886f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">NumPy为Python中的数学运算提供了快速的替代方法，因此被设计成可以有效地处理数字组，比如矩阵。你一定要花些时间探索它的<a class="ae kt" href="https://docs.scipy.org/doc/numpy/reference/" rel="noopener ugc nofollow" target="_blank"> <em class="ks">文档</em> </a>来了解更多。我们在NumPy中处理数字最常见的方式是通过<code class="fe lg lh li lj b"><a class="ae kt" href="https://docs.scipy.org/doc/numpy/reference/arrays.html" rel="noopener ugc nofollow" target="_blank">ndarray</a></code>对象。它们类似于Python列表，但是可以有任意数量的维度。<code class="fe lg lh li lj b">ndarray</code>支持非常快速的数学运算(这正是我们想要的)，而使用python列表会非常慢，不适合这里。一个<code class="fe lg lh li lj b">ndarray</code>的元素是同质的(都是相同的<code class="fe lg lh li lj b">dtype</code>)，并且由一个正整数元组索引。因为它可以存储任意数量的维度，所以您可以使用<code class="fe lg lh li lj b">ndarray</code>来表示我们之前讨论过的任何数据类型:标量、向量、矩阵或张量。我们可以从嵌套的Python列表中初始化numpy数组，并使用方括号访问元素:</p><pre class="kv kw kx ky gt lk lj ll lm aw ln bi"><span id="064d" class="lo lp iq lj b gy lq lr l ls lt">import numpy as np</span><span id="9939" class="lo lp iq lj b gy lu lr l ls lt">a = np.array([[0, 1, 2], [3, 4, 5]])   <em class="ks"># a 2D, 2 x 3, array</em><br/>a</span></pre><p id="d53d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">输出:</p><pre class="kv kw kx ky gt lk lj ll lm aw ln bi"><span id="1a40" class="lo lp iq lj b gy lq lr l ls lt">array([[0, 1, 2],<br/>       [3, 4, 5]])</span></pre><p id="b3fb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Numpy还提供了许多创建数组的函数:</p><pre class="kv kw kx ky gt lk lj ll lm aw ln bi"><span id="b89d" class="lo lp iq lj b gy lq lr l ls lt">import numpy as np</span><span id="ac8b" class="lo lp iq lj b gy lu lr l ls lt">a = np.zeros((2,2))   <em class="ks"># Create an array of all zeros</em><br/>print(a)              <em class="ks"># Prints "[[ 0.  0.]</em><br/>                      <em class="ks">#          [0.  0.]]"</em></span><span id="7519" class="lo lp iq lj b gy lu lr l ls lt">b = np.ones((1,2))    <em class="ks"># Create an array of all ones</em><br/>print(b)              <em class="ks"># Prints "[[ 1.  1.]]"</em></span><span id="8f1c" class="lo lp iq lj b gy lu lr l ls lt">d = np.eye(2)         <em class="ks"># Create a 2x2 identity matrix</em><br/>print(d)              <em class="ks"># Prints "[[ 1.  0.]</em><br/>                      <em class="ks">#          [ 0.  1.]]"</em></span></pre><p id="1287" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可以在文档中阅读关于数组创建<a class="ae kt" href="http://docs.scipy.org/doc/numpy/user/basics.creation.html#arrays-creation" rel="noopener ugc nofollow" target="_blank">的其他方法。</a></p><h1 id="07f3" class="lv lp iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">标量</h1><p id="366f" class="pw-post-body-paragraph ju jv iq jw b jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr ij bi translated">NumPy 中的标量比Python中的要复杂一些。而不是Python的基本类型像<code class="fe lg lh li lj b">int</code>、<code class="fe lg lh li lj b">float</code>等。，NumPy让我们指定有符号和无符号类型，以及不同的大小。所以除了Python的<code class="fe lg lh li lj b">int</code>，还有类似<code class="fe lg lh li lj b">uint8</code>、<code class="fe lg lh li lj b">int8</code>、<code class="fe lg lh li lj b">uint16</code>、<code class="fe lg lh li lj b">int16</code>等类型。</p><p id="3788" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以创建一个Numpy标量，如下所示:</p><pre class="kv kw kx ky gt lk lj ll lm aw ln bi"><span id="b266" class="lo lp iq lj b gy lq lr l ls lt">a = np.array(5)</span></pre><p id="a6e2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">不过，您仍然可以在<code class="fe lg lh li lj b">ndarray</code>、NumPy标量和普通Python标量之间执行数学运算，您将在基于元素的数学课程中看到这一点。</p><p id="38d6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以通过检查它们的<code class="fe lg lh li lj b">shape</code>属性来查看数组的形状。维数是数组的<em class="ks">秩</em>；数组的<em class="ks">形状</em>是一个整数元组，给出了数组在每个维度上的大小。</p><pre class="kv kw kx ky gt lk lj ll lm aw ln bi"><span id="8f51" class="lo lp iq lj b gy lq lr l ls lt">a.shape</span></pre><p id="a8e0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">即使标量在数组内部，你仍然可以像普通标量一样使用它们。所以你可以输入:</p><pre class="kv kw kx ky gt lk lj ll lm aw ln bi"><span id="5fc7" class="lo lp iq lj b gy lq lr l ls lt">n = a + 3</span></pre><p id="eab1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">并且<code class="fe lg lh li lj b">n </code>现在将等于<code class="fe lg lh li lj b">8</code>。注意，<code class="fe lg lh li lj b">n</code>的类型是<code class="fe lg lh li lj b">numpy.int64</code>，因为它使用NumPy类型，而不是Python类型。</p><h1 id="e95e" class="lv lp iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">矩阵</h1><p id="224d" class="pw-post-body-paragraph ju jv iq jw b jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr ij bi translated">我们使用NumPy的<code class="fe lg lh li lj b">array</code>函数创建矩阵，就像我们创建向量一样。然而，我们不是仅仅传入一个列表，而是提供一个列表的列表，其中每个列表代表一行。因此，要创建一个包含数字1到9的3x3矩阵，我们可以这样做:</p><pre class="kv kw kx ky gt lk lj ll lm aw ln bi"><span id="f9c7" class="lo lp iq lj b gy lq lr l ls lt">m = np.array([[1,2,3], [4,5,6], [7,8,9]])</span></pre><p id="e3ca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">检查它的<code class="fe lg lh li lj b">shape</code>属性将返回元组<code class="fe lg lh li lj b">(3, 3)</code>以表明它有两个维度，每个长度为3。</p><p id="f72c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以像访问向量一样访问矩阵的元素，但是使用额外的索引值。所以为了在上面的矩阵中找到数字<code class="fe lg lh li lj b">6</code>，我们将访问<code class="fe lg lh li lj b">m[1][2]</code>。</p><h1 id="a251" class="lv lp iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">Numpy中的元素式操作</h1><pre class="kv kw kx ky gt lk lj ll lm aw ln bi"><span id="a34c" class="lo lp iq lj b gy lq lr l ls lt">values = [1,2,3,4,5]<br/>values = np.array(values) + 5</span><span id="58b9" class="lo lp iq lj b gy lu lr l ls lt">It now holds [6,7,8,9,10]</span></pre><p id="9217" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，如果您已经有了一个名为<code class="fe lg lh li lj b">values</code>的<code class="fe lg lh li lj b">ndarray</code>，您可以只做:</p><pre class="kv kw kx ky gt lk lj ll lm aw ln bi"><span id="79a8" class="lo lp iq lj b gy lq lr l ls lt">values += 5</span></pre><p id="3ac4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">NumPy实际上有加法、乘法等功能。但是它也支持使用标准的数学运算符。所以下面两行是等价的:</p><pre class="kv kw kx ky gt lk lj ll lm aw ln bi"><span id="fb53" class="lo lp iq lj b gy lq lr l ls lt">x = np.multiply(array, 5)<br/>x = array * 5</span></pre><p id="034b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">需要注意的是<code class="fe lg lh li lj b">*</code>是元素式乘法，不是矩阵乘法。相反，我们使用<code class="fe lg lh li lj b">dot </code>函数来计算向量的内积，将向量乘以矩阵，以及将矩阵相乘。<code class="fe lg lh li lj b">dot</code>既可以作为numpy模块中的函数，也可以作为数组对象的实例方法:</p><pre class="kv kw kx ky gt lk lj ll lm aw ln bi"><span id="6654" class="lo lp iq lj b gy lq lr l ls lt">x = np.array([[1,2],[3,4]])<br/>y = np.array([[5,6],[7,8]])</span><span id="7828" class="lo lp iq lj b gy lu lr l ls lt">v = np.array([9,10])<br/>w = np.array([11, 12])</span><span id="44a0" class="lo lp iq lj b gy lu lr l ls lt"><em class="ks"># Inner product of vectors; both produce 219</em><br/>print(v.dot(w))<br/>print(np.dot(v, w))</span><span id="5f31" class="lo lp iq lj b gy lu lr l ls lt"><em class="ks"># Matrix / vector product; both produce the rank 1 array [29 67]</em><br/>print(x.dot(v))<br/>print(np.dot(x, v))</span><span id="f43e" class="lo lp iq lj b gy lu lr l ls lt"><em class="ks"># Matrix / matrix product; both produce the rank 2 array</em><br/><em class="ks"># [[19 22]</em><br/><em class="ks">#  [43 50]]</em><br/>print(x.dot(y))<br/>print(np.dot(x, y))</span></pre><p id="79c8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Numpy为在数组上执行计算提供了许多有用的函数；其中最有用的是<code class="fe lg lh li lj b">sum</code>:</p><pre class="kv kw kx ky gt lk lj ll lm aw ln bi"><span id="9d77" class="lo lp iq lj b gy lq lr l ls lt">import numpy as np</span><span id="d07b" class="lo lp iq lj b gy lu lr l ls lt">x = np.array([[1,2],[3,4]])</span><span id="589d" class="lo lp iq lj b gy lu lr l ls lt">print(np.sum(x))  <em class="ks"># Compute sum of all elements; prints "10"</em><br/>print(np.sum(x, axis=0))  <em class="ks"># Compute sum of each column; prints "[4 6]"</em><br/>print(np.sum(x, axis=1))  <em class="ks"># Compute sum of each row; prints "[3 7]"</em></span></pre><p id="47c1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">除了使用数组计算数学函数之外，我们经常需要对数组中的数据进行整形或操作。这种操作最简单的例子是转置一个矩阵；要转置一个矩阵，只需使用数组对象的<code class="fe lg lh li lj b">T</code>属性:</p><pre class="kv kw kx ky gt lk lj ll lm aw ln bi"><span id="f370" class="lo lp iq lj b gy lq lr l ls lt">import numpy as np</span><span id="468e" class="lo lp iq lj b gy lu lr l ls lt">x = np.array([[1,2], [3,4]])<br/>print(x)    <em class="ks"># Prints "[[1 2]</em><br/>            <em class="ks">#          [3 4]]"</em><br/>print(x.T)  <em class="ks"># Prints "[[1 3]</em><br/>            <em class="ks">#          [2 4]]"</em></span><span id="4e17" class="lo lp iq lj b gy lu lr l ls lt"><em class="ks"># Note that taking the transpose of a rank 1 array does nothing:</em><br/>v = np.array([1,2,3])<br/>print(v)    <em class="ks"># Prints "[1 2 3]"</em><br/>print(v.T)  <em class="ks"># Prints "[1 2 3]"</em></span></pre><h1 id="31ee" class="lv lp iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">矩阵积</h1><p id="4a6d" class="pw-post-body-paragraph ju jv iq jw b jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr ij bi translated">要找到矩阵乘积，可以使用NumPy的<code class="fe lg lh li lj b">matmul</code>函数。</p><pre class="kv kw kx ky gt lk lj ll lm aw ln bi"><span id="cf41" class="lo lp iq lj b gy lq lr l ls lt">a = np.array([[1,2,3,4],[5,6,7,8]])<br/>a<br/># displays the following result:<br/># array([[1, 2, 3, 4],<br/>#        [5, 6, 7, 8]])<br/>a.shape<br/># displays the following result:<br/># (2, 4)</span><span id="2ce2" class="lo lp iq lj b gy lu lr l ls lt">b = np.array([[1,2,3],[4,5,6],[7,8,9],[10,11,12]])<br/>b<br/># displays the following result:<br/># array([[ 1,  2,  3],<br/>#        [ 4,  5,  6],<br/>#        [ 7,  8,  9],<br/>#        [10, 11, 12]])<br/>b.shape<br/># displays the following result:<br/># (4, 3)</span><span id="3323" class="lo lp iq lj b gy lu lr l ls lt">c = np.matmul(a, b)<br/>c<br/># displays the following result:<br/># array([[ 70,  80,  90],<br/>#        [158, 184, 210]])<br/>c.shape<br/># displays the following result:<br/># (2, 3)</span></pre><p id="8ff6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果您的矩阵有不兼容的形状，您会得到一个错误，如下所示:</p><pre class="kv kw kx ky gt lk lj ll lm aw ln bi"><span id="b3cc" class="lo lp iq lj b gy lq lr l ls lt">np.matmul(b, a)<br/># displays the following error:<br/># ValueError: shapes (4,3) and (2,4) not aligned: 3 (dim 1) != 2 (dim 0)</span></pre><p id="f164" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">尽管理解Numpy的工作原理非常重要，但我想让这篇文章保持真正的介绍性，所以很明显Numpy中有很多操作没有在这里介绍。因此我在下面链接了一些很棒的资源。</p><p id="ebf6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后让我们看看权重(你在第二部分  <em class="ks">中学到的)如何将</em>与Numpy矩阵和转置函数联系起来:</p><p id="dd41" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">假设你有下面两个矩阵，叫做“输入”和“权重”。“输入”是传递给你的神经网络的数据，“权重”是你的神经网络学习修改以找到最佳可能的解决方案。</p><pre class="kv kw kx ky gt lk lj ll lm aw ln bi"><span id="fbb6" class="lo lp iq lj b gy lq lr l ls lt">inputs = np.array([[-0.27,  0.45,  0.64, 0.31]])<br/>inputs<br/># displays the following result:<br/># array([[-0.27,  0.45,  0.64,  0.31]])</span><span id="5c6e" class="lo lp iq lj b gy lu lr l ls lt">inputs.shape<br/># displays the following result:<br/># (1, 4)</span><span id="6f24" class="lo lp iq lj b gy lu lr l ls lt">weights = np.array([[0.02, 0.001, -0.03, 0.036], \<br/>    [0.04, -0.003, 0.025, 0.009], [0.012, -0.045, 0.28, -0.067]])</span><span id="76df" class="lo lp iq lj b gy lu lr l ls lt">weights<br/># displays the following result:<br/># array([[ 0.02 ,  0.001, -0.03 ,  0.036],<br/>#        [ 0.04 , -0.003,  0.025,  0.009],<br/>#        [ 0.012, -0.045,  0.28 , -0.067]])</span><span id="9937" class="lo lp iq lj b gy lu lr l ls lt">weights.shape<br/># displays the following result:<br/># (3, 4)</span></pre><p id="8bfe" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们试着把它们相乘，因为这就是我们如何得到神经网络的输出。</p><pre class="kv kw kx ky gt lk lj ll lm aw ln bi"><span id="d3bc" class="lo lp iq lj b gy lq lr l ls lt">np.matmul(inputs, weights)<br/># displays the following error:<br/># ValueError: shapes (1,4) and (3,4) not aligned: 4 (dim 1) != 3 (dim 0)</span></pre><p id="93eb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你像他们现在这样尝试，你会得到一个错误。由于左矩阵中的列数<code class="fe lg lh li lj b">4</code>与右矩阵中的行数<code class="fe lg lh li lj b">3</code>不相等，导致形状不兼容，从而出现错误。</p><p id="16af" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是如果我们对“权重”矩阵进行转置，结果是:</p><pre class="kv kw kx ky gt lk lj ll lm aw ln bi"><span id="7b7c" class="lo lp iq lj b gy lq lr l ls lt">np.matmul(inputs, weights.T)<br/># displays the following result:<br/># array([[-0.01299,  0.00664,  0.13494]])</span></pre><p id="9f01" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你转置“输入”并交换它们的顺序，它也是有效的。</p><pre class="kv kw kx ky gt lk lj ll lm aw ln bi"><span id="37ca" class="lo lp iq lj b gy lq lr l ls lt">np.matmul(weights, inputs.T)<br/># displays the following result:<br/># array([[-0.01299],# <br/>#        [ 0.00664],<br/>#        [ 0.13494]])</span></pre><p id="99dc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">两个答案是彼此的转置，所以我们使用的乘法的顺序实际上取决于我们想要的形状。</p><p id="c7b0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在下一篇文章中，我们将把这些概念应用到一个神经网络问题中。</p><blockquote class="mx my mz"><p id="9d4b" class="ju jv ks jw b jx jy jz ka kb kc kd ke na kg kh ki nb kk kl km nc ko kp kq kr ij bi translated">Numpy链接:</p><p id="3e97" class="ju jv ks jw b jx jy jz ka kb kc kd ke na kg kh ki nb kk kl km nc ko kp kq kr ij bi translated"><a class="ae kt" href="https://github.com/jrjohansson/scientific-python-lectures/blob/master/Lecture-2-Numpy.ipynb" rel="noopener ugc nofollow" target="_blank"> <em class="iq">这本</em> </a>笔记本详细解释了许多操作。还要查看Numpy库文档:<a class="ae kt" href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html" rel="noopener ugc nofollow" target="_blank">https://docs.scipy.org/doc/numpy-dev/user/quickstart.html</a>。另一个很好的资源是关于这个主题的科学讲座系列。Numpy章出自<a class="ae kt" href="https://github.com/jakevdp/PythonDataScienceHandbook/blob/master/notebooks/02.00-Introduction-to-NumPy.ipynb" rel="noopener ugc nofollow" target="_blank">本<em class="iq">本</em>本</a>本。</p></blockquote></div></div>    
</body>
</html>