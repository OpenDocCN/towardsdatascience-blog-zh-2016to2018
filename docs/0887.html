<html>
<head>
<title>Introduction to PonyGE2 for Grammatical Evolution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">语法演变的PonyGE2介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-ponyge2-for-grammatical-evolution-d51c29f2315a?source=collection_archive---------1-----------------------#2017-07-05">https://towardsdatascience.com/introduction-to-ponyge2-for-grammatical-evolution-d51c29f2315a?source=collection_archive---------1-----------------------#2017-07-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8c49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">语法进化是算法优化的一种强有力的方法。给定一个目标函数和一个搜索空间(语法)，有可能使用进化计算方法来进化一个算法，以最优地(或至少有效地)最大化目标函数。</p><p id="b12a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PonyGE2 是Python3的一个实现，它让GE变得简单。本演练讨论了GE的优点和缺点，并提供了一个如何用GE改进您自己的算法的示例。一篇全面描述PonyGE2运作的论文可以在<a class="ae kl" href="https://arxiv.org/pdf/1703.08535.pdf" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="2bfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，在当前计算机上用PonyGE2进行语法进化还不够快，不能在合理的时间内从大量语法中进化出函数，但这种技术肯定是未来需要关注的。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="224d" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">语法演变</h1><p id="1b4f" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">这种方法最初是由<a class="ae kl" href="http://ieeexplore.ieee.org/document/942529/" rel="noopener ugc nofollow" target="_blank">的迈克尔·奥尼尔</a>(付费墙)博士在2001年提出的，作为一种将进化计算方法应用于具有正式语法结构的问题的方式，比如算法。</p><p id="60cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个正式的语法可以被认为是定义一种语言的一套规则，或者仅仅是一种规定什么样的单词组合有意义的官方方式。在英语中，我们在学说话时从父母那里学到这些，在学校里也是如此。学习第二语言时，通常可以分为两个步骤:</p><ol class=""><li id="831f" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated">学习词汇</li><li id="afa8" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">学习语法</li></ol><p id="4f94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编程并没有太大的不同，编程语言之间的主要区别不是你试图实现什么，而是你如何告诉计算机去做。</p><p id="8da3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么我们如何向计算机教授语法呢？那么这些词是如何用于进化优化的呢？</p><p id="7823" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个过程大概是这样的:</p><ol class=""><li id="379d" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated">定义语法的巴克斯诺尔形式(BNF)表示；</li><li id="a6c2" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">随机生成线性染色体来编码信息；</li><li id="92d8" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">通过将语法映射到染色体并对照适应度函数进行测试来评估染色体的适应度；</li><li id="7a10" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">使用交叉、变异、繁殖等遗传算子生成下一代染色体；</li><li id="66c7" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">重复第3步和第4步一定数量的世代。</li></ol></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h2 id="599b" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">巴克斯诺尔形式</h2><p id="995e" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">BNF语法是一种编写计算机可以理解的语法的方式(上下文无关)。在Python中，它由包含4个集合的元组表示:</p><ul class=""><li id="af6f" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated">t:终端设备</li><li id="4891" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mw mc md me bi translated">n:非终结集</li><li id="f263" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mw mc md me bi translated">生产规则集</li><li id="cd9f" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mw mc md me bi translated">s:开始符号(是N的成员)。</li></ul><p id="9766" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可能不能澄清事实，但是记住这一点是有好处的。让我们看一个例子:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="2076" class="mk ku iq nc b gy ng nh l ni nj">T = {+, -, /, *, x, y}</span></pre><p id="e8d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以终端集是你想在程序中使用的所有操作符和变量的集合。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="bb56" class="mk ku iq nc b gy ng nh l ni nj">N = {&lt;e&gt;, &lt;o&gt;, &lt;v&gt;}</span></pre><p id="73c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">非终结集是程序可以承担的所有生产活动的集合。在这种情况下，<code class="fe nk nl nm nc b">&lt;e&gt;</code>是一个表达式，<code class="fe nk nl nm nc b">&lt;o&gt;</code>是一个运算符，<code class="fe nk nl nm nc b">&lt;v&gt;</code>是一个变量。</p><p id="8afb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nk nl nm nc b">P</code>接下来是生产规则的设定:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="4120" class="mk ku iq nc b gy ng nh l ni nj">&lt;e&gt; ::= &lt;e&gt;&lt;o&gt;&lt;e&gt; | &lt;v&gt;<br/>&lt;o&gt; ::= + | - | / | *<br/>&lt;v&gt; ::= x | y</span></pre><p id="0265" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，<code class="fe nk nl nm nc b">P</code>中的所有条目都是<code class="fe nk nl nm nc b">T</code>或<code class="fe nk nl nm nc b">N</code>的条目。管道操作符<code class="fe nk nl nm nc b">|</code>代表<code class="fe nk nl nm nc b">or</code>。因此，当在染色体中遇到<code class="fe nk nl nm nc b">&lt;e&gt;</code>时，它要么被替换为<code class="fe nk nl nm nc b">&lt;e&gt;&lt;o&gt;&lt;e&gt;</code>，要么被替换为<code class="fe nk nl nm nc b">&lt;v&gt;</code>，对于<code class="fe nk nl nm nc b">&lt;o&gt;</code>和<code class="fe nk nl nm nc b">&lt;v&gt;</code>也是如此。</p><p id="44f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，开始符号:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="1f17" class="mk ku iq nc b gy ng nh l ni nj">S = &lt;e&gt;</span></pre><p id="1ee6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可能仍然很令人困惑，但是在评估染色体时，以这种形式表示语法的原因变得很明显。</p><h2 id="ba44" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">染色体</h2><p id="4fcb" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">描述染色体最简单的方式是作为一个非负整数数组。值并不重要，但长度很重要(稍后会详细介绍)。</p><p id="7203" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">举个例子，我们称我们的染色体为:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="a635" class="mk ku iq nc b gy ng nh l ni nj">C: [4, 15, 75, 8, 41, 12]</span></pre><h2 id="cf0e" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">将染色体映射到语法</h2><p id="dab7" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">现在一切都在一起了。记得我们的开始符号是:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="6324" class="mk ku iq nc b gy ng nh l ni nj">&lt;e&gt;</span></pre><p id="fd55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，根据我们的生产规则<code class="fe nk nl nm nc b">P</code>，当遇到一个<code class="fe nk nl nm nc b">&lt;e&gt;</code>时，要么用<code class="fe nk nl nm nc b">&lt;e&gt;&lt;o&gt;&lt;e&gt;</code>替换，要么用<code class="fe nk nl nm nc b">&lt;v&gt;</code>替换。但是我们怎么知道是哪一个呢？染色体告诉我们。染色体的第一个值是<code class="fe nk nl nm nc b">4</code>，产生式规则中有<code class="fe nk nl nm nc b">&lt;e&gt;</code>的<code class="fe nk nl nm nc b">2</code>选项。<code class="fe nk nl nm nc b">4 mod 2</code>是<code class="fe nk nl nm nc b">0</code>，所以我们从产生式规则<code class="fe nk nl nm nc b">&lt;e&gt;&lt;o&gt;&lt;e&gt;</code>中取第<code class="fe nk nl nm nc b">0</code> -th(零索引，所以真的是<code class="fe nk nl nm nc b">1</code> -st条目)选项。</p><p id="bf5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以现在我们的表达式已经扩展到了<code class="fe nk nl nm nc b">&lt;e&gt;&lt;o&gt;&lt;e&gt;</code>，我们正在评估第一个条目<code class="fe nk nl nm nc b">&lt;e&gt;</code>(因为它不是终端集的成员，所以我们一直评估每个条目，直到它被终端集的成员替换)。</p><p id="57f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们知道在产生式规则中有<code class="fe nk nl nm nc b">&lt;e&gt;</code>的<code class="fe nk nl nm nc b">2</code>选项，所以我们取染色体中的第二个条目<code class="fe nk nl nm nc b">15</code>，并且<code class="fe nk nl nm nc b">15 mod 2</code>给出了<code class="fe nk nl nm nc b">1</code>，所以我们从产生式规则<code class="fe nk nl nm nc b">&lt;v&gt;</code>中取第一个(零索引，所以实际上是第二个条目)选项。</p><p id="a179" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们继续以下步骤:</p><ul class=""><li id="1fbc" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated">完整表达式:<code class="fe nk nl nm nc b">&lt;v&gt;&lt;o&gt;&lt;e&gt;</code> <br/>当前表达式:<code class="fe nk nl nm nc b">&lt;v&gt;</code> <br/>语法中<code class="fe nk nl nm nc b">&lt;v&gt;</code>选项个数:<code class="fe nk nl nm nc b">2</code> <br/>染色体值:<code class="fe nk nl nm nc b">75</code><code class="fe nk nl nm nc b">75 mod 2 = 1</code><br/>用<code class="fe nk nl nm nc b">y</code>替换<code class="fe nk nl nm nc b">&lt;v&gt;</code></li><li id="8ab9" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mw mc md me bi translated">完整表达式:<code class="fe nk nl nm nc b">y &lt;o&gt;&lt;e&gt;</code> <br/>当前表达式:<code class="fe nk nl nm nc b">&lt;o&gt;</code> <br/>语法中<code class="fe nk nl nm nc b">&lt;o&gt;</code>选项个数:<code class="fe nk nl nm nc b">4</code> <br/>染色体值:<code class="fe nk nl nm nc b">8</code> <br/> <code class="fe nk nl nm nc b">8 mod 4 = 0</code> <br/>用<code class="fe nk nl nm nc b">+</code>替换<code class="fe nk nl nm nc b">&lt;o&gt;</code></li><li id="5b54" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mw mc md me bi translated">完整表达式:<code class="fe nk nl nm nc b">y + &lt;e&gt;</code> <br/>当前表达式:<code class="fe nk nl nm nc b">&lt;e&gt;</code> <br/>语法中<code class="fe nk nl nm nc b">&lt;e&gt;</code>选项个数:<code class="fe nk nl nm nc b">2</code> <br/>染色体值:<code class="fe nk nl nm nc b">41</code> <br/> <code class="fe nk nl nm nc b">41 mod 2 = 1</code> <br/>用<code class="fe nk nl nm nc b">&lt;v&gt;</code>替换<code class="fe nk nl nm nc b">&lt;e&gt;</code></li><li id="0d0d" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mw mc md me bi translated">完整表达式:<code class="fe nk nl nm nc b">y + &lt;v&gt;</code> <br/>当前表达式:<code class="fe nk nl nm nc b">&lt;v&gt;</code> <br/>语法中<code class="fe nk nl nm nc b">&lt;v&gt;</code>选项个数:<code class="fe nk nl nm nc b">2</code> <br/>染色体值:<code class="fe nk nl nm nc b">12</code> <br/> <code class="fe nk nl nm nc b">12 mod 2 = 0</code> <br/>用<code class="fe nk nl nm nc b">x</code>替换<code class="fe nk nl nm nc b">&lt;v&gt;</code></li></ul><p id="3e82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终表情:<code class="fe nk nl nm nc b">y + x</code></p><p id="acdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们已经用我们的语法表示把我们的染色体(数组)变成了一个函数！请随意重读几遍，因为理解表达式和运算符的来源需要一些时间。</p><h2 id="d186" class="mk ku iq bd kv ml mm dn kz mn mo dp ld jy mp mq lh kc mr ms ll kg mt mu lp mv bi translated">评估适应度函数</h2><p id="8ea6" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">现在我们有了一个语法上正确的函数，我们可以根据一些适应度函数来评估这个函数的性能。那些表现良好的功能有更大的机会将它们的DNA传递给下一代染色体。从这一点来看，GE与其他遗传算法没有太大的不同，因为染色体被交叉和变异以产生下一代染色体，然后这些染色体被映射到语法并根据适应度函数进行测试。</p><p id="240c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将持续用户指定的代数，最后将最有效的(适应度函数的最佳分数)算法返回给您。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="c8df" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">通用电气公司分析</h1><p id="7e53" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">现在你(希望)对语法进化有了更多的了解，你可能会问为什么它这么好？</p><p id="8bbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先是快，真的快。通过代代相传信息，它大大改进了随机搜索。</p><p id="6e57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其次，因为语法是你写的，你可以很容易地将领域知识编码到函数中。你可能会经常听到这种说法，并问“这到底是什么意思？”(我知道我有)。以下是一些例子:</p><ul class=""><li id="866d" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated">允许访问你所有的信息，不管它是否有用。这可以通过在语法中使用一个<code class="fe nk nl nm nc b">&lt;v&gt;</code>表达式来实现，并且包含你想要的所有变量。</li><li id="52b4" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mw mc md me bi translated">根据需要使程序尽可能复杂或简单。在<code class="fe nk nl nm nc b">&lt;e&gt;</code>中包含许多选项(包括重复的选项，以改变特定操作符被选中的机会)允许容易地操纵进化程序的复杂性。</li><li id="9baa" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mw mc md me bi translated">通过设置<code class="fe nk nl nm nc b">&lt;n&gt; ::= 0|1|2|3|4|5|6|7|8|9</code>然后<code class="fe nk nl nm nc b">&lt;const&gt; ::= &lt;n&gt;&lt;n&gt;&lt;n&gt;.&lt;n&gt;&lt;n&gt;&lt;n&gt;</code>来定义常量的精度等级，设置精度为3位小数的0到999之间的常量。</li><li id="9b4a" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mw mc md me bi translated">包含表达式包含<code class="fe nk nl nm nc b">&lt;fn&gt;(&lt;e&gt;)</code>和<code class="fe nk nl nm nc b">&lt;fn&gt; ::= sin | max</code>的函数</li></ul><p id="2da1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一切都很酷，但通用电气也有一些缺点。首先，如上所述，染色体的长度确实会导致程序无效。对于上面的例子，如果染色体中的倒数第二个条目是42而不是41，那么<code class="fe nk nl nm nc b">&lt;e&gt;</code>将被替换为<code class="fe nk nl nm nc b">&lt;e&gt;&lt;o&gt;&lt;e&gt;</code>，但是没有留下染色体数据来评估这些表达式。由于该染色体无效，因此不能根据适应度函数对其进行评估。因此，虽然一条染色体可能包含接近好的解决方案，但它永远不会为人所知。</p><p id="b8eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与此相反的是，程序进化时没有使用整个染色体。剩余的数据称为尾部，可以忽略。因此，通常最好将染色体构造为长尾，因为这可以减少无效解出现的机会。</p><p id="4252" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，可能最大的缺点是，语法必须非常非常仔细地构建，为问题构建适当的语法和适应度函数需要一点艺术。除此之外，“大”语法可能需要很长时间才能进化。包括单级for循环、if语句、列表函数和字典操作的语法可能需要12个小时以上才能完成。希望这在未来会有所改善，但这是阻止语法进化取代人类代码优化器的主要原因吗…</p><p id="5a12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以现在你有希望对语法演变有更多的了解，我们可以尝试在PonyGE2中实现一个简单的例子。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="ee15" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">PonyGE2</h1><p id="28a8" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">PonyGE2可以从<a class="ae kl" href="https://github.com/jmmcd/PonyGE2" rel="noopener ugc nofollow" target="_blank">这里</a>克隆或者分叉。不需要任何设置，演化将从带有适当参数的命令行运行。</p><p id="e567" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">研究这个包的最好方法是通过一个例子来完成。我们将尝试开发一个函数来查找列表中的最大值。这很容易在Python中用<code class="fe nk nl nm nc b">max()</code>或函数实现:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="3c87" class="mk ku iq nc b gy ng nh l ni nj">for val in list:<br/>    if val &gt;= current_max:<br/>        current_max = val</span></pre><p id="7589" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一步是创建一个适应度函数，或者我们想要最大化或最小化的函数。这里的术语有点混乱，因为我们正在进化一个函数，其结果将优化适应度函数。目前我们只是在讨论适应度函数。</p><p id="1107" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些例子的所有代码都包含在https://github.com/Padam-0/NC-GA的<a class="ae kl" href="https://github.com/Padam-0/NC-GA" rel="noopener ugc nofollow" target="_blank">中</a></p><p id="ece1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe nk nl nm nc b">PonyGE2/src/fitness</code>中有很多例子，要运行你自己的，在那个文件夹中创建一个名为<code class="fe nk nl nm nc b">max_in_list.py</code>的文件，结构如下:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="c7f8" class="mk ku iq nc b gy ng nh l ni nj"><em class="nn">from </em>fitness.base_ff_classes.base_ff <em class="nn">import </em>base_ff<br/>import random<br/>import time</span><span id="f711" class="mk ku iq nc b gy no nh l ni nj"><em class="nn">class </em>max_in_list(base_ff):<br/>    <em class="nn">def </em>__init__(self):<br/>        # Initialise base fitness function class.<br/>        super().__init__()</span><span id="60a8" class="mk ku iq nc b gy no nh l ni nj"><em class="nn">    def </em>evaluate(self, <em class="nn">ind</em>, <em class="nn">**kwargs</em>):<br/>        p = <em class="nn">ind</em>.phenotype</span><span id="c79d" class="mk ku iq nc b gy no nh l ni nj">        print("\n" + p)</span><span id="6182" class="mk ku iq nc b gy no nh l ni nj">        fitness = 0</span><span id="32e4" class="mk ku iq nc b gy no nh l ni nj">        for trial in range(50):<br/>            self.test_list = generate_list()<br/>            m = max(self.test_list)</span><span id="7657" class="mk ku iq nc b gy no nh l ni nj">            d = {'test_list': self.test_list}</span><span id="9396" class="mk ku iq nc b gy no nh l ni nj"><em class="nn">            try</em>:<br/>                t0 = time.time()<br/>                exec(p, d)<br/>                t1 = time.time()</span><span id="9b88" class="mk ku iq nc b gy no nh l ni nj">                guess = d['return_val']</span><span id="8a5c" class="mk ku iq nc b gy no nh l ni nj">                fitness += len(p)</span><span id="a043" class="mk ku iq nc b gy no nh l ni nj">                v = abs(m - guess)<br/>                if v &lt;= 10**6:<br/>                    fitness += v<br/>                else:<br/>                    fitness = self.default_fitness<br/>                    break</span><span id="7da1" class="mk ku iq nc b gy no nh l ni nj">                if t1 - t0 &lt; 10:<br/>                    fitness = self.default_fitness<br/>                    break<br/>                else:<br/>                    fitness += (t1 - t0) * 1000</span><span id="089c" class="mk ku iq nc b gy no nh l ni nj">            <em class="nn">except</em>:<em class="nn"><br/>                </em>fitness = self.default_fitness<br/>                break</span><span id="ace0" class="mk ku iq nc b gy no nh l ni nj">        return fitness<br/></span><span id="660b" class="mk ku iq nc b gy no nh l ni nj"><em class="nn">def </em>generate_list():<br/>    return [random.randint(0, round(random.random() * 90 + 10, 0)) for i in range(9)]</span></pre><p id="3120" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们一行一行地来。</p><p id="3e28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第1–3行:</p><ul class=""><li id="396d" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated">进口。<code class="fe nk nl nm nc b">base-ff</code>是我们将要继承的类，random用于生成随机列表，time用于跟踪执行时间</li></ul><p id="2c85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第5行:</p><ul class=""><li id="e73a" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated">定义类，<code class="fe nk nl nm nc b">max_in_list</code>，继承自<code class="fe nk nl nm nc b">base_ff</code>。这需要与您正在处理的文件同名(在本例中是<code class="fe nk nl nm nc b">max_in_list.py</code>)。</li></ul><p id="b4cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第6–9行:</p><ul class=""><li id="b721" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated">该类的实例初始化信息。</li></ul><p id="a72e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第10行:</p><ul class=""><li id="41b4" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated">创建带有三个参数的<code class="fe nk nl nm nc b">evaluate</code>函数，self、ind和kwargs。</li></ul><p id="026b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nn">到目前为止，这是每个健身功能的标准配置。下一步是独立于每一个正在进化的算法。</em></p><p id="275c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第11–13行:</p><ul class=""><li id="0928" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated">从进化中返回当前算法作为<code class="fe nk nl nm nc b">p</code>。我们可以将它打印到命令行(如我们在第13行中所做的那样)，并查看它。</li></ul><p id="061b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第15行:</p><ul class=""><li id="eac5" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated">将适应性初始化为<code class="fe nk nl nm nc b">0</code></li></ul><p id="5aa6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第17行:</p><ul class=""><li id="40b7" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated">将for循环设置为运行50次。如果我们不这样做，每个算法将运行在同一个“随机”列表上，并可能演化出一行，如随后返回的<code class="fe nk nl nm nc b">m=49</code>。<code class="fe nk nl nm nc b">49</code>可能恰好在那个列表里，而且是最大值，所以计算机认为找到了完美的算法。短、快、准！但是对于这个例子来说。在任何其他列表中，如果<code class="fe nk nl nm nc b">49</code>不在其中(或者不是最大值)，那么算法就是错误的。因此，我们给出了适应度函数的50个列表，每个列表都有不同的值(实际上是最大可能值)，以避免过度适应。</li></ul><p id="e84e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第18行:</p><ul class=""><li id="ad65" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated">从函数<code class="fe nk nl nm nc b">generate_list()</code>创建随机列表<code class="fe nk nl nm nc b">self.test_list</code></li><li id="13e5" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mw mc md me bi translated">跳到最后几行，这个函数在<code class="fe nk nl nm nc b">0</code>之间生成10个随机整数，以及10到100之间的某个数字。这是避免过度拟合的最好方法。</li></ul><p id="5e27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第19行:</p><ul class=""><li id="25a8" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated">找出当前使用列表的最大值。重要的是在这里完成，而不是在算法执行之后，因为在执行过程中列表可能会改变(如果语法中已经包含列表操作)，所以可能不会返回正确的结果。</li><li id="44c7" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mw mc md me bi translated">此时你可能(正确地)会问，如果我们已经有了一个函数来寻找列表的最大值，那么做这些有什么意义呢？这是一个很好的问题，通用电气的重点是找到一种潜在的更有效的方法来做到这一点。对于简单的函数来说，这并不值得，但却是一个很好的学习练习。</li></ul><p id="c507" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第21行:</p><ul class=""><li id="b338" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated">创建一个字典<code class="fe nk nl nm nc b">d</code>，其中有一个条目<code class="fe nk nl nm nc b">test_list</code>，用于保存当前列表。这在我们写语法的时候会更有意义。</li></ul><p id="10a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第23/45–47行:</p><ul class=""><li id="296b" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated">Try/Except语句。一般来说，拥有一个开放式Except语句不是一个好主意，因为你永远不会捕捉到错误，但在这种情况下，所有错误都可能发生在进化的算法中(因为它只是半随机地将单词放在一起，所以它们不可能都是完美的代码)，所以该语句是合理的。</li><li id="23c4" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mw mc md me bi translated">如果返回一个错误，该算法的适合度被设置为默认值(NA ),循环被中断，下一个算法被测试。</li></ul><p id="abed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第24行:</p><ul class=""><li id="35a5" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated">获取开始时间。</li></ul><p id="0e4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第25行:</p><ul class=""><li id="28c0" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated">执行算法<code class="fe nk nl nm nc b">p</code>并在<code class="fe nk nl nm nc b">d</code>内传递参数，以便可以访问它们。这是实际评估算法的地方。返回的值作为<code class="fe nk nl nm nc b">return_val</code>写入字典<code class="fe nk nl nm nc b">d</code>(我们在语法中定义了这一点)。</li></ul><p id="54aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第26行:</p><ul class=""><li id="ffd5" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated">获取结束时间。</li></ul><p id="b26f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第28行:</p><ul class=""><li id="d7eb" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated">从当前算法中检索最大值猜测。</li></ul><p id="d40a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第30行:</p><ul class=""><li id="0607" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated">将当前适应度分数增加算法的长度。这是为了避免臃肿和不必要的if语句。进化试图让事情尽可能的短。</li></ul><p id="d5d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第32行:</p><ul class=""><li id="51f2" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated">求列表的实际最大值和猜测值之差。最好的情况是这是<code class="fe nk nl nm nc b">0</code>，但如果不是，这是一个算法如何接近得到正确答案的代理。</li></ul><p id="c554" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第33–37行:</p><ul class=""><li id="d1b9" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated">有一些算法可能会产生完全超大的猜测，这将破坏进化，所以最好保留一个if语句来检查值是否高于某个永远不可行的大(但不太大)数。</li><li id="b254" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mw mc md me bi translated">同样，如果该检查失败，则将适应度设置为NA，并继续下一个算法。否则，将猜测值和正确值之间的差加到当前的适应性分数上。</li></ul><p id="63b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第39–43行:</p><ul class=""><li id="2255" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated">一些算法(具有多层for循环，或<code class="fe nk nl nm nc b">for i in range(1000)</code>语句)需要很长时间来评估。除非这是预期的，否则这表示有错误，因此建议使用if语句来捕获那些花费了更多时间(在本例中为10秒)的错误。</li><li id="e40f" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mw mc md me bi translated">如果算法花费的时间少于此，则可以将该时间添加到适应度分数中，这样，工作更快的算法将获得较低的适应度。由于时间尺度很小，建议将这部分分数放大100或1000倍。</li></ul><p id="a430" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第49行:</p><ul class=""><li id="e133" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated">还健身，就完事了！</li></ul><p id="2fb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有很多东西需要理解，有一些可能没有意义，但我们会继续写语法，希望有了完整的描述，会更清晰一些。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="b914" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">语法</h1><p id="ca3e" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">这是困难的部分，因为你必须对你写的东西非常精确和深思熟虑。我们将逐步介绍发展max函数所需的基本语法，但是包括附加逻辑、列表函数和字典函数的语法扩展可在<a class="ae kl" href="https://github.com/Padam-0/NC-GA" rel="noopener ugc nofollow" target="_blank">https://github.com/Padam-0/NC-GA</a>获得。</p><p id="65c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，PonyGE2在PonyGE2/grammars目录中提供了语法示例。在那里创建你的(它可以被称为任何东西，但是给它扩展名<code class="fe nk nl nm nc b">.pybnf</code>)。</p><p id="43b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一行包含程序的起点:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="5099" class="mk ku iq nc b gy ng nh l ni nj">&lt;fc&gt; ::= &lt;deff&gt;{::}&lt;callf&gt;</span></pre><p id="0869" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用英语来说，这表示:</p><ul class=""><li id="616a" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated"><code class="fe nk nl nm nc b">&lt;fc&gt;</code>是起始符号，包含一个选项:<code class="fe nk nl nm nc b">&lt;deff&gt;</code>后面跟一个换行符(<code class="fe nk nl nm nc b">{::}</code>代表换行符，<code class="fe nk nl nm nc b">{:</code>是缩进(tab或4个空格)<code class="fe nk nl nm nc b">:}</code>关闭缩进)，后面跟<code class="fe nk nl nm nc b">&lt;callf&gt;</code>。</li></ul><p id="a4b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一行，我们定义<code class="fe nk nl nm nc b">&lt;deff&gt;</code>:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="8599" class="mk ku iq nc b gy ng nh l ni nj">&lt;deff&gt; ::= def fun(li):{:m = 0{::}&lt;code&gt;{::}return m:}</span></pre><p id="7315" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这看起来有点像Python。我们可以看到我们有一个名为<code class="fe nk nl nm nc b">fun()</code>的函数的函数定义，有一个参数<code class="fe nk nl nm nc b">li</code>。</p><p id="8ff7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来我们打开一个缩进(像Python要求的那样)，初始化我们的变量<code class="fe nk nl nm nc b">m=0</code>，开始一个新行，写一些<code class="fe nk nl nm nc b">&lt;code&gt;</code>，开始一个新行，返回<code class="fe nk nl nm nc b">m</code>，然后关闭缩进。</p><p id="a968" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还是那句话，<code class="fe nk nl nm nc b">&lt;deff&gt;</code>只有一个选项，所以这个肯定会写。接下来，<code class="fe nk nl nm nc b">&lt;callf&gt;</code>:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="62ed" class="mk ku iq nc b gy ng nh l ni nj">&lt;callf&gt; ::= return_val = fun(test_list)</span></pre><p id="6406" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，这看起来更像Python。而且只有一个选项，所以不管染色体如何，我们的算法看起来总是这样:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="e70f" class="mk ku iq nc b gy ng nh l ni nj">def fun(li):<br/>    m = 0<br/>    &lt;code&gt;<br/>    return m<br/>return_val = fun(test_list)</span></pre><p id="f752" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nk nl nm nc b">&lt;code&gt;</code>部分是进化完成的地方，但是在大多数情况下，我们现在将有一个工作函数。酷嘿！天气变凉了。</p><p id="fe77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还记得在我们的健身函数中，我们给了字典<code class="fe nk nl nm nc b">d</code>一个名为<code class="fe nk nl nm nc b">test_list</code>的键吗？嗯，因为我们调用了<code class="fe nk nl nm nc b">exec(p, d)</code>，所以程序可以看到那个字典<code class="fe nk nl nm nc b">d</code>的内容，所以当它在算法中看到<code class="fe nk nl nm nc b">test_list</code>的时候，就用字典<code class="fe nk nl nm nc b">d</code>中<code class="fe nk nl nm nc b">test_list</code>对应的值来替换它，或者在我们的例子中，就是我们想要找到的最大值的随机列表！很酷吧，现在我们有办法将数据从我们的适应函数传递到我们的进化函数中。</p><p id="05fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，在我们的适应度函数中，我们设置<code class="fe nk nl nm nc b">guess = d['return_val']</code>？事实证明，我们不仅可以从<code class="fe nk nl nm nc b">d</code>读取，还可以向它写入，从<code class="fe nk nl nm nc b">fun(test_list)</code>返回的值作为<code class="fe nk nl nm nc b">return_val</code>传递给<code class="fe nk nl nm nc b">d</code>，这样我们就可以在适应度函数中访问进化算法的返回值，这样我们就可以访问它的适应度了！</p><p id="9254" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们现在可以双向发送数据，我建议重新阅读适应度函数部分，看看这是否更有意义。对我来说绝对是。</p><p id="e07b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至于我们剩下的语法:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="e510" class="mk ku iq nc b gy ng nh l ni nj">&lt;code&gt; ::= &lt;stmt&gt; | &lt;stmt&gt;{::}&lt;code&gt;</span></pre><p id="ce6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码可以是一条语句，也可以是一条语句后在新的一行上跟随更多的代码。这样我们就可以给自己多线功能了！这种语法的递归性质是非常有用的，将会出现很多，使我们能够增加进化的复杂性。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="761c" class="mk ku iq nc b gy ng nh l ni nj">&lt;stmt&gt; ::= &lt;var&gt; = &lt;expr&gt; | &lt;for&gt; | &lt;if&gt;</span></pre><p id="2736" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，语句要么将表达式赋给变量，要么赋给for循环，要么赋给if语句。让我们以相反的顺序来看这些:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="ed09" class="mk ku iq nc b gy ng nh l ni nj">&lt;if&gt; ::= if &lt;cond&gt;:&lt;if-opt&gt;<br/>&lt;if-opt&gt; ::= {:&lt;code&gt;:} | {:&lt;code&gt;:}else:{:&lt;code&gt;:} | {:&lt;code&gt;:}elif &lt;cond&gt;:{:&lt;if-opt&gt;:}</span><span id="715c" class="mk ku iq nc b gy no nh l ni nj">&lt;cond&gt; ::= &lt;expr&gt; &lt;c-op&gt; &lt;expr&gt;<br/>&lt;c-op&gt; ::= "&gt;=" | "&lt;=" | "&gt;" | "&lt;"</span></pre><p id="1af3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以if语句接受一个条件，然后是一个选项。条件采用表达式、运算符和表达式的形式。</p><p id="b8e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使这一点更清楚，现在有必要讨论一下<code class="fe nk nl nm nc b">&lt;expr&gt;</code>标签:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="f176" class="mk ku iq nc b gy ng nh l ni nj">&lt;expr&gt; ::= &lt;number&gt; | &lt;var&gt; | &lt;expr&gt; &lt;op&gt; &lt;expr&gt;</span></pre><p id="6c0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以一个表达式要么是一个数字，要么是一个变量，要么是一个操作(后面会详细介绍)。</p><p id="b8ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回到我们的if语句，我们的条件采用形式<code class="fe nk nl nm nc b">if &lt;cond&gt;:</code>,它扩展为:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="e3a0" class="mk ku iq nc b gy ng nh l ni nj">if &lt;expr&gt; &lt;c-op&gt; &lt;expr&gt;:</span></pre><p id="04ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后可以扩展为:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="e566" class="mk ku iq nc b gy ng nh l ni nj">if &lt;var&gt; &gt;= &lt;number&gt;:</span></pre><p id="ddaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有一个我们认可的if语句。<code class="fe nk nl nm nc b">&lt;if-opt&gt;</code>稍微复杂一点，因为它们必须包括<code class="fe nk nl nm nc b">elif</code>和<code class="fe nk nl nm nc b">else</code>功能，但是它们都归结为一个if语句、一个条件，然后一些<code class="fe nk nl nm nc b">&lt;code&gt;</code>被写入其中。</p><p id="3331" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，对于循环:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="8a5f" class="mk ku iq nc b gy ng nh l ni nj">&lt;for&gt; ::= for i in &lt;list-var&gt;:{:&lt;fl-code&gt;:}<br/>&lt;fl-stmt&gt; ::= &lt;var&gt; = &lt;expr&gt; | &lt;fl-if&gt;<br/>&lt;fl-code&gt; ::= &lt;fl-stmt&gt; | &lt;fl-stmt&gt;{::}&lt;fl-code&gt;</span></pre><p id="892f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，for循环采用形式<code class="fe nk nl nm nc b">for i in list:</code>,然后为某个语句创建一个缩进(在新的一行上)。语句本身可能只是我们上面的<code class="fe nk nl nm nc b">&lt;stmt&gt;</code>，但是这将允许嵌套for循环，这会成倍地增加计算时间。除非您认为嵌套的for循环是绝对必要的，否则请避免使用它们(一般来说，这是一个非常好的编程规则)。</p><p id="2a47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们的<code class="fe nk nl nm nc b">&lt;fl-stmt&gt;</code>只包括变量赋值，和一个特殊的if语句，<code class="fe nk nl nm nc b">&lt;fl-if&gt;</code>:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="5720" class="mk ku iq nc b gy ng nh l ni nj">&lt;fl-if&gt; ::= if &lt;cond&gt;:&lt;fl-if-opt&gt;<br/>&lt;fl-if-opt&gt; ::= {:&lt;fl-code&gt;:} | {:&lt;fl-code&gt;:}else:{:&lt;fl-code&gt;:} | {:&lt;fl-code&gt;:}elif &lt;cond&gt;:{:&lt;fl-if-opt&gt;:}</span></pre><p id="f4f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这实际上与上面的if语句语法相同，但是它不调用<code class="fe nk nl nm nc b">&lt;code&gt;</code>，而是调用<code class="fe nk nl nm nc b">&lt;fl-code&gt;</code>，基本上是为了避免for循环内部的if语句内部出现for循环。有点麻烦，但比允许嵌套for循环要好！</p><p id="39df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，变量赋值。我们已经看过<code class="fe nk nl nm nc b">&lt;expr&gt;</code>，所以让我们看看组成它的零件:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="3278" class="mk ku iq nc b gy ng nh l ni nj">&lt;var&gt; ::= m | i<br/>&lt;list-var&gt; ::= li</span><span id="fa03" class="mk ku iq nc b gy no nh l ni nj">&lt;number&gt; ::= &lt;num&gt;&lt;num&gt;&lt;num&gt; | &lt;num&gt;&lt;num&gt; | &lt;num&gt;<br/>&lt;num&gt; ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</span><span id="1585" class="mk ku iq nc b gy no nh l ni nj">&lt;op&gt; ::= + | - | * | / | // | %</span></pre><p id="bb4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这应该很简单。我们的变量是开始时初始化的<code class="fe nk nl nm nc b">m</code>和运行for循环时初始化的<code class="fe nk nl nm nc b">i</code>。数字可以从0到999，我们有所有的python运算符(除了指数运算符，它会导致整数溢出和一大堆执行非常慢的算法。像嵌套的for循环一样，只在需要时才包含它)。</p><p id="6241" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">信不信由你，这就是我们的语法！让我们看看如何从一个<code class="fe nk nl nm nc b">&lt;code&gt;</code>标签到我们的最终函数。像这样的染色体:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="5188" class="mk ku iq nc b gy ng nh l ni nj">[0, 1, 0, 1, 0, 1, 1, 2, 1, 0, 0, 0, 0, 1, 1]</span></pre><p id="827f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">绘制出来后，我们可以得到:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="464e" class="mk ku iq nc b gy ng nh l ni nj">def fun(li):<br/>    for i in li:<br/>        if i &gt; m:<br/>            m = i<br/>return_val = fun(test_list)</span></pre><p id="bbf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太棒了。现在我们有了适应度函数和语法，我们如何用PonyGE2运行它呢？</p><p id="98e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，如果fitness函数在PonyGE2/src/fitness中(并且与它保存的类具有相同的文件名，在本例中是max_in_list)，并且语法在PonyGE2/grammars中，我们可以从命令行运行:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="a6df" class="mk ku iq nc b gy ng nh l ni nj">python ponyge.py --fitness_function max_in_list --grammar_file max_in_list.pybnf</span></pre><p id="f578" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将运行您的语法和健身功能的演变，与其他选项的默认参数。有很多，值得一读参考文献<a class="ae kl" href="https://github.com/PonyGE/PonyGE2/wiki" rel="noopener ugc nofollow" target="_blank"/>，但两个真正重要的是人口规模和世代数。</p><p id="8635" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">群体大小是在开始时产生的染色体的数量，并且在每一代进化。这个数字越大，搜索范围越广，但进化时间越慢。</p><p id="b9d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代数是染色体进化的次数。同样，它扩大了搜索范围，但以进化速度为代价。</p><p id="f600" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以通过以下方式设置这些参数:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="0384" class="mk ku iq nc b gy ng nh l ni nj">python ponyge.py --fitness_function max_in_list --grammar_file MIL_e2.pybnf --population_size 500 --generations 100</span></pre><p id="efcb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，对于简单的语法，这些参数的值在100-500的范围内就足够了，但是随着语法变得更加复杂，它们需要更多的群体和世代来确保进化出足够的算法。一个好的测试是给你的语法增加复杂性，用和上面一样的适应度函数来运行它。如果你得到一个在列表中找到最大值的函数，你可以确信你的参数是合适的，然后把它转换到你要解决的问题的另一个适应度函数上。</p><p id="8385" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，运行时间变得很快。对我来说，2000代和750代的人口需要大约6个半小时，这不足以用上面的语法进化出一个合适的算法(但也包括列表和字典操作)。</p><p id="750a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是通用电气的问题所在。承诺是，如果你能写一个适应度函数，和一个包含大量Python操作的健壮语法，那么ge将能进化出一种更有效的做事方式。不幸的是，目前这种处理能力和时间在公共机器上是不可行的。</p><p id="c239" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不管怎样，这是一个值得关注的领域，就像我们要教机器编码一样，很有可能语法进化与此有关。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="5726" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">其他示例</h1><p id="ffcc" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated"><a class="ae kl" href="http://ncra.ucd.ie/index.shtml" rel="noopener ugc nofollow" target="_blank"> UCD自然计算研究和应用集团</a>的团队是这项研究的前沿，他们发表了许多展示通用电气力量的伟大论文(尽管是在超级计算机上)。其中包括:</p><ul class=""><li id="6168" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mw mc md me bi translated"><a class="ae kl" href="https://arxiv.org/abs/1704.04119" rel="noopener ugc nofollow" target="_blank">寻找正则表达式的改进性能</a>；</li><li id="1aed" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mw mc md me bi translated"><a class="ae kl" href="http://www.sciencedirect.com/science/article/pii/S0020025514002904" rel="noopener ugc nofollow" target="_blank">用语法进化优化复杂的桥塔结构</a>；和</li><li id="7fdd" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mw mc md me bi translated"><a class="ae kl" href="https://link.springer.com/chapter/10.1007%2F978-3-642-20520-0_21?LI=true" rel="noopener ugc nofollow" target="_blank">结合结构分析和多目标标准的进化建筑设计</a>。</li></ul></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="fedf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你喜欢这篇文章，请点击❤按钮让你的追随者知道，或者让我知道你的想法。</p><figure class="mx my mz na gt nq gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi np"><img src="../Images/852d66557edc7439da173eedcc04738f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0J8nrlZcxO4mBZdoiENgzg.gif"/></div></div></figure></div></div>    
</body>
</html>